	//SAI ADDED
	long refcount = 0;

	//We need to prepend server name to object path
	//Need to make sure everything fits in buffer size
	SWORD cbServerLen = 0;
	SWORD cbObjPathLen = 0;

	if (lpServerName)
		cbServerLen = (SWORD) _mbstrlen( (LPSTR)lpServerName);



	//RAID 57673 WMI has changed such that if you
	//connect locally and pass a username and password
	//it will fail
	//Check for local connection
	BOOL fIsLocalConnection = IsLocalServer((LPSTR) lpServerName);



	if (objectPath)
		cbObjPathLen = strlen ( (LPSTR)objectPath);

	if ( (cbServerLen + cbObjPathLen + 1) > MAX_DATABASE_NAME_LENGTH)
	{
		pLocator->Release();
		ODBCTRACE("\nWBEM ODBC Driver : ISAMGetGatewayServer version 1 : Error position 2\n");
		return;
	}

	//Construct string (namespace)
	CBString namespaceBSTR;
	
	if (cbServerLen)
	{
		char pCharBuff [MAX_DATABASE_NAME_LENGTH + 1];
		pCharBuff[0] = 0;
		sprintf (pCharBuff, "%s\\%s", (LPUSTR)lpServerName, (LPSTR)objectPath);

		CString myText;
		myText.Format("\nWBEM ODBC Driver : Connecting using : %s\n", pCharBuff);
		ODBCTRACE(myText);

		//Convert to wide string
		namespaceBSTR.AddString(pCharBuff, FALSE);
	}
	else
	{
		if (objectPath)
		{
			namespaceBSTR.AddString((LPSTR)objectPath, FALSE);
		}
	}

	//Get user and password fields
	CBString localeBSTR;
	CBString authorityBSTR;

	localeBSTR.AddString((char*)lpLocale, FALSE);

	authorityBSTR.AddString((char*)lpAuthority, FALSE);


	//Convert wide characters to BSTR for DCOM
	//----------------------------------------
	CBString userBSTR;

	if (!fIsLocalConnection)
		userBSTR.AddString((LPSTR)lpUserName, FALSE);


	CBString passwdBSTR;

	if (!fIsLocalConnection)
		passwdBSTR.AddString((LPSTR)lpPassword, fIntpretEmptPwdAsBlank);

	sc = pLocator->ConnectServer (namespaceBSTR.GetString(), userBSTR.GetString(), passwdBSTR.GetString(), localeBSTR.GetString(), 0, authorityBSTR.GetString(), NULL, &pGateway);
 
	if (sc == S_OK)
	{
		sc  = GetAuthImp( pGateway, &dwAuthLevel, &dwImpLevel);
		if(sc == S_OK)
		{
			if (dwAuthLevel > RPC_C_AUTHN_LEVEL_NONE)
				dwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;


			sc = ISAMSetCloaking1( pGateway, 
						fIsLocalConnection, 
						IsW2KOrMore(), 
						dwAuthLevel, 
						dwImpLevel,
						authorityBSTR.GetString(), 
						userBSTR.GetString(), 
						passwdBSTR.GetString(), 
						ppAuthIdent );
/*
			if ( fIsLocalConnection && IsW2KOrMore() )
			{
				WbemSetDynamicCloaking(pGateway, dwAuthLevel, dwImpLevel);
			}
			else
			{
				sc = SetInterfaceSecurityEx(pGateway, authorityBSTR.GetString(), userBSTR.GetString(), passwdBSTR.GetString(), 
					   dwAuthLevel, dwImpLevel, EOAC_NONE, ppAuthIdent, &gpPrincipal);
			}
*/
		}
	}

	pLocator->Release();

	if ( FAILED(sc) )
	{
		ODBCTRACE("\nWBEM ODBC Driver : ISAMGetGatewayServer version 1 : Error position 3\n");
		return;
	}
}

/***************************************************************************/

/* Function to fix MSQuery bug which appends   */
/* a \ infront of _ characters in table names  */

void ISAM_MSQueryBugFix(LPSTR lpOrigPattern, LPSTR lpNewPattern, SWORD &cbPattern)
{
	SWORD iNewPatternIndex = 0;

	for (SWORD iIndex = 0; iIndex < cbPattern; iIndex++)
	{
		//Check for '\' character follwed by a '_'
		if ( (lpOrigPattern[iIndex] == '\\') && (lpOrigPattern[iIndex + 1] == '_') )
		{
			//Skip underscore character
			iIndex++;
		}

		//Copy character
		lpNewPattern[iNewPatternIndex++] = lpOrigPattern[iIndex];
	}

	//Null terminate new string
	lpNewPattern[iNewPatternIndex] = 0;

	//Update length of new string
	cbPattern = iNewPatternIndex;
}

/***************************************************************************/

/* Stores the necessary information to obtain a list of database tables */
/* with match the search pattern                                        */

SWORD INTFUNC ISAMGetTableList (LPISAM lpISAM, LPUSTR lpPattern, SWORD cbPattern,
								LPUSTR lpQualifierName, SWORD cbQualifierName,
								LPISAMTABLELIST FAR *lplpISAMTableList, BOOL fWantSysTables, BOOL fEmptyList)
{
	//Local Variables
    HGLOBAL             h;
    LPISAMTABLELIST     lpISAMTableList;

    lpISAM->errcode = NO_ISAM_ERR;

	//Allocate memory for table list structure on the heap
    h = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (ISAMTABLELIST));
    if (h == NULL || (lpISAMTableList = (LPISAMTABLELIST) GlobalLock (h)) == NULL) 
	{
        if (h)
            GlobalFree(h);

        lpISAM->errcode = ISAM_MEMALLOCFAIL;
        return ISAM_MEMALLOCFAIL;
    }

	//Check table name
	//There is a bug in MSQuery which appends extra \ character(s)
	//to table names which have underscore(s)
	//If this is the case we remove the \ character(s)
	char* lpNewPattern = new char [cbPattern + 1];
	ISAM_MSQueryBugFix((LPSTR)lpPattern, lpNewPattern, cbPattern);

	//Copy search pattern
    _fmemcpy(lpISAMTableList->lpPattern, lpNewPattern, cbPattern);

	//Save search pattern length
    lpISAMTableList->cbPattern = cbPattern;

	//Delete tempory buffer
	delete lpNewPattern;

	//Copy qualifer name if it is non-null and not the default database
	lpISAMTableList->lpQualifierName[0] = 0;
	if (cbQualifierName)
	{
		strncpy((LPSTR)lpISAMTableList->lpQualifierName, (LPSTR)lpQualifierName, cbQualifierName);
	}
	else
	{
		cbQualifierName = 0;
	}

	lpISAMTableList->lpQualifierName[cbQualifierName] = 0;

#ifdef TESTING
	//Remember to remove this printf
	printf ("Qualifier = %s", (char*)lpISAMTableList->lpQualifierName );
#endif

	//Is this table list going to be an empty one because
	//we requested a table type other than TABLE or SYSTEM TABLE ?
	lpISAMTableList->fEmptyList = fEmptyList;
	
	//Do we want System Tables ?
	lpISAMTableList->fWantSysTables = fWantSysTables;
	
	//Save the qualifier length
	lpISAMTableList->cbQualifierName = cbQualifierName;

	//Save flag to indicate if this is the first time table list is accessed
    lpISAMTableList->fFirstTime = TRUE;

	//Save information to create a context to database
    lpISAMTableList->lpISAM = lpISAM;

	//Initialize pointer to enumerated list of tables
	lpISAMTableList->pTblList = new CPtrList();

	//Create an object to store WbemServices pointer
	lpISAMTableList->pGateway2 = new CSafeWbemServices();

	//Setup output parameter
	*lplpISAMTableList = lpISAMTableList;
    lpISAMTableList->netISAMTableList = NET_OPAQUE_INVALID;

    return NO_ISAM_ERR;
}

/***************************************************************************/

/* Stores the necessary information to obtain a list of database qualifiers */

SWORD INTFUNC ISAMGetQualifierList(LPISAM lpISAM, LPISAMQUALIFIERLIST FAR *lplpISAMQualifierList)
{
	//Local Variables
    HGLOBAL             h;
	LPISAMQUALIFIERLIST	lpISAMQualifierList;

    lpISAM->errcode = NO_ISAM_ERR;

	//Allocate memory for qualifier list structure on heap
    h = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (ISAMQUALIFIERLIST));
    if (h == NULL || (lpISAMQualifierList = (LPISAMQUALIFIERLIST) GlobalLock (h)) == NULL) 
	{
        if (h)
            GlobalFree(h);

        lpISAM->errcode = ISAM_MEMALLOCFAIL;
        return ISAM_MEMALLOCFAIL;
    }


	//Save flag to indicate if this is the first qualifier list is accessed
    lpISAMQualifierList->fFirstTime = TRUE;

	//Save information to create a context to database
    lpISAMQualifierList->lpISAM = lpISAM;

	//Setup output parameter
	*lplpISAMQualifierList = lpISAMQualifierList;

    return NO_ISAM_ERR;
}

/***************************************************************************/

/* Retrieves next table name from table list */
// Checked for SetInterfaceSecurityEx on IWbemServices

SWORD INTFUNC ISAMGetNextTableName(UDWORD fSyncMode, LPISAMTABLELIST lpISAMTableList, LPUSTR lpTableName, LPUSTR lpTableType)
{   
    //Initialize, no errors found yet
    lpISAMTableList->lpISAM->errcode = NO_ISAM_ERR;
	IWbemClassObject* pSingleTable = NULL;
	BOOL fReleaseSingleTable = FALSE;

	//Check if we have detacted an empty table list due
	//to the fact that we requested a table type other than TABLE
	if (lpISAMTableList->fEmptyList)
	{
		lpISAMTableList->lpISAM->errcode = ISAM_EOF;
		return ISAM_EOF;
	}

	//We need to get the next table in the list from the LPISAMTABLELIST
	//However, if this is the first time this function is called, no table list
	//will be present, and we will need to get it from the Gateway Server

	
	// First time through?
    if (lpISAMTableList->fFirstTime)
	{
		//Clear out any old values
		if (lpISAMTableList->pTblList && lpISAMTableList->pTblList->GetCount())
		{
			POSITION thePos = NULL;
			for ( thePos = lpISAMTableList->pTblList->GetHeadPosition(); thePos != NULL; )
			{
				IWbemClassObject* pTheValue = (IWbemClassObject*) lpISAMTableList->pTblList->GetNext(thePos);

				pTheValue->Release();
			}
			lpISAMTableList->pTblList->RemoveAll();
		}

		//Initialize
		if (lpISAMTableList->pGateway2)
			lpISAMTableList->pGateway2->Invalidate();
		lpISAMTableList->iIndex = NULL;
		lpISAMTableList->fFirstTime = FALSE;
		lpISAMTableList->fGotAllInfo = FALSE;

        //Get list of tables from the
		//Gateway Server which match search pattern
        
		//First get the Gateway Interface
		//remember to Release it after use

		lpISAMTableList->pGateway2->SetInterfacePtr
				(lpISAMTableList->lpISAM, (LPUSTR)lpISAMTableList->lpQualifierName, lpISAMTableList->cbQualifierName);

		//Check if a valid interface was returned
		if ( ! lpISAMTableList->pGateway2->IsValid() )
		{
			//Could not create a Gateway Interface, return error
			lpISAMTableList->lpISAM->errcode = ISAM_PROVIDERFAIL;
			return ISAM_PROVIDERFAIL;
		}

		//First check if we need to get one table or a list of tables
		//by using the pattern matcher class

		if ( IsRegularExpression((char*)lpISAMTableList->lpPattern) )
		{
			//We want a table LIST
			//We enumerate for tables, the resultant enumeration will be allocated on
			//the HEAP by the Gateway Server and referneced by pEnum
			BSTR emptySuperClass = SysAllocString(L"");

			//Check if we want to get list asynchronously
			if (fSyncMode == SQL_ASYNC_ENABLE_ON)
			{
				//Create notification object
				CNotifyTableNames* pNotifyTable = new CNotifyTableNames(lpISAMTableList);
				
				IWbemContext* pContext = ISAMCreateLocaleIDContextObject(lpISAMTableList->lpISAM->m_Locale);

				IWbemServicesPtr myServicesPtr = NULL;
				ISAMGetIWbemServices(lpISAMTableList->lpISAM, *(lpISAMTableList->pGateway2), myServicesPtr);

				//cloaking
				BOOL fIsLocalConnection = lpISAMTableList->lpISAM->fIsLocalConnection;

				if ( fIsLocalConnection && (lpISAMTableList->lpISAM->fW2KOrMore) )
				{
					WbemSetDynamicCloaking(myServicesPtr, lpISAMTableList->lpISAM->dwAuthLevel, lpISAMTableList->lpISAM->dwImpLevel);
				}

				if ( FAILED(myServicesPtr->CreateClassEnumAsync
					(_bstr_t(), WBEM_FLAG_DEEP, pContext, pNotifyTable)) )
				{
					//Tidy Up
					lpISAMTableList->pGateway2->Invalidate();
					SysFreeString(emptySuperClass);

					
					if (pContext)
						pContext->Release();

					//Flag error
					lpISAMTableList->lpISAM->errcode = ISAM_TABLELISTFAIL;
					return ISAM_TABLELISTFAIL;
				}

				//Tidy Up
				SysFreeString(emptySuperClass);

				if (pContext)
						pContext->Release();
				
				//BREAK OUT OF THIS FUNCTION
				return ISAM_STILL_EXECUTING;
			}

			IEnumWbemClassObjectPtr	pEnum = NULL;

			IWbemContext* pContext = ISAMCreateLocaleIDContextObject(lpISAMTableList->lpISAM->m_Locale);

			IWbemServicesPtr myServicesPtr = NULL;
			ISAMGetIWbemServices(lpISAMTableList->lpISAM, *(lpISAMTableList->pGateway2), myServicesPtr);

			//cloaking
			BOOL fIsLocalConnection = lpISAMTableList->lpISAM->fIsLocalConnection;

			if ( fIsLocalConnection && (lpISAMTableList->lpISAM->fW2KOrMore) )
			{
				WbemSetDynamicCloaking(myServicesPtr, lpISAMTableList->lpISAM->dwAuthLevel, lpISAMTableList->lpISAM->dwImpLevel);
			}

			HRESULT hRes = myServicesPtr->CreateClassEnum
				(_bstr_t(), WBEM_FLAG_DEEP, pContext, &pEnum);

			if (pContext)
				pContext->Release();
		
			ISAMSetCloaking2(pEnum, 
							fIsLocalConnection, 
							lpISAMTableList->lpISAM->fW2KOrMore, 
							lpISAMTableList->lpISAM->dwAuthLevel, 
							lpISAMTableList->lpISAM->dwImpLevel,
							lpISAMTableList->lpISAM->gpAuthIdentity);

/*
			if ( fIsLocalConnection && (lpISAMTableList->lpISAM->fW2KOrMore) )
			{
				WbemSetDynamicCloaking(pEnum, lpISAMTableList->lpISAM->dwAuthLevel, lpISAMTableList->lpISAM->dwImpLevel);
			}
			else
			{
				SetInterfaceSecurityEx(pEnum, lpISAMTableList->lpISAM->gpAuthIdentity, gpPrincipal, lpISAMTableList->lpISAM->dwAuthLevel, lpISAMTableList->lpISAM->dwImpLevel);
			}
*/
			//Tidy Up
			SysFreeString(emptySuperClass);

			if (FAILED(hRes))
			{
				//Tidy Up
				lpISAMTableList->pGateway2->Invalidate();

				//Flag error
				lpISAMTableList->lpISAM->errcode = ISAM_TABLELISTFAIL;
				return ISAM_TABLELISTFAIL;
			}

			//Now we have the table enumeration get the first item
			ULONG puReturned;
			SCODE sc1 = pEnum->Reset();

			SCODE sc2 = pEnum->Next(-1, 1, &pSingleTable, &puReturned);

			BOOL f1 = (S_OK == sc1) ? TRUE : FALSE;
			BOOL f2 = ( S_OK == sc2) ? TRUE : FALSE;

			if ( (pEnum == NULL) || (!f1) || (!f2)
				)
			{
				//Tidy Up
				lpISAMTableList->pGateway2->Invalidate();

				//Flag error
				lpISAMTableList->lpISAM->errcode = ISAM_EOF;

				return ISAM_EOF;
			}
			else
			{
				fReleaseSingleTable = TRUE;

				//Place any remaining tables in the pTblList
				IWbemClassObject* pSingleTable2 = NULL;
				while (S_OK == pEnum->Next(-1, 1, &pSingleTable2, &puReturned))
				{
					lpISAMTableList->pTblList->AddTail(pSingleTable2);
				}

				//Set index to correct start position for next items
				lpISAMTableList->iIndex = lpISAMTableList->pTblList->GetHeadPosition();
			}
		}
		else
		{
			//We want a SINGLE table

			//Set this flag in case you are asynchronously requesting 
			//for 1 table !!!
			lpISAMTableList->fGotAllInfo = TRUE;

			//Create a pointer to store table class definition
			//the class definition object will be CREATED on the HEAP
			//by the GetClass function
			pSingleTable = NULL;

			LONG cLength = lstrlen((char*)lpISAMTableList->lpPattern);
			wchar_t* pWClassName = new wchar_t [cLength + 1];
			pWClassName[0] = 0;
			int iItemsCopied = mbstowcs(pWClassName, (char*)lpISAMTableList->lpPattern, cLength);
			pWClassName[cLength] = 0;

			BSTR pTheTableName = SysAllocStringLen(pWClassName, cLength);

			IWbemContext* pContext = ISAMCreateLocaleIDContextObject(lpISAMTableList->lpISAM->m_Locale);

			IWbemServicesPtr myServicesPtr = NULL;
			ISAMGetIWbemServices(lpISAMTableList->lpISAM, *(lpISAMTableList->pGateway2), myServicesPtr);

			SCODE sStatus = myServicesPtr->GetObject(pTheTableName, 0, pContext, &pSingleTable, NULL);

			if (pContext)
				pContext->Release();

			fReleaseSingleTable = TRUE;

			SysFreeString(pTheTableName);
			delete pWClassName;

			if ( FAILED(sStatus) || (!pSingleTable) )
			{
				//Failed to get named class definition

				//Tidy Up
				lpISAMTableList->pGateway2->Invalidate();

				//Flag error
				lpISAMTableList->lpISAM->errcode = ISAM_EOF;

				return ISAM_EOF;
			}
		}
    }
    else 
	{
        //Get next item in enumeration if applicable
		//Check if function is asynchronous, if so
		//we must first check the fGotAllInfo flag
		//if we have all the info we can get the next table
		//we assign the pSingleTable pointer
		if ( (fSyncMode == SQL_ASYNC_ENABLE_ON) && (!lpISAMTableList->fGotAllInfo) )
			return ISAM_STILL_EXECUTING;

		//Get Next
		if (lpISAMTableList->iIndex)
		{
			pSingleTable = (IWbemClassObject*)lpISAMTableList->pTblList->GetNext(lpISAMTableList->iIndex);
		}
		else
		{
			lpISAMTableList->lpISAM->errcode = ISAM_EOF;

			return ISAM_EOF;
		}			
    }

	//Now we have the class definition object
	//for the next table let us get table name
	SWORD sc = S_OK; // ISAMGetNextTableName2(pSingleTable, fSyncMode, lpISAMTableList,lpTableName);
	

	//Because of stack overflow problems I have moved the 
	//ISAMGetNextTableName2 code here
	
	BOOL fMatchingPattern = FALSE;
	do 
	{
		//Now we have the class definition object
		//The table name is held in the property attribute __CLASS
		VARIANT grVariant;
		BSTR classBSTR = SysAllocString(WBEMDR32_L_CLASS);
		if (FAILED(pSingleTable->Get(classBSTR, 0, &grVariant, NULL, NULL)))
		{
			lpISAMTableList->lpISAM->errcode = ISAM_TABLENAMEFAIL;
			SysFreeString(classBSTR);
			sc = ISAM_TABLENAMEFAIL;
		}
		else
		{
			SysFreeString(classBSTR);

			/* Does this filename match the pattern? */
			char pBuffer [MAX_TABLE_NAME_LENGTH+1];
			pBuffer[0] = 0;
			wcstombs(pBuffer, grVariant.bstrVal, MAX_TABLE_NAME_LENGTH);
			pBuffer[MAX_TABLE_NAME_LENGTH] = 0;

			//Also do not add any class which starts with __ to table list
			//If you don't want SYSTEM TABLES
			if ( !PatternMatch(TRUE, (LPUSTR) pBuffer, SQL_NTS,
							 (LPUSTR)lpISAMTableList->lpPattern, lpISAMTableList->cbPattern,
							 ISAMCaseSensitive(lpISAMTableList->lpISAM)) || (!(lpISAMTableList->fWantSysTables) && !_strnicmp("__", pBuffer, 2))  )

			{
				/* No.  Get the next one */
				VariantClear(&grVariant);
				
				//Get the next table here

				if (lpISAMTableList->iIndex)
				{
					if (fReleaseSingleTable)
						pSingleTable->Release();

					pSingleTable = NULL;
					fReleaseSingleTable = FALSE;
					pSingleTable = (IWbemClassObject*)lpISAMTableList->pTblList->GetNext(lpISAMTableList->iIndex);
				}
				else
				{
					lpISAMTableList->lpISAM->errcode = ISAM_EOF;

					return ISAM_EOF;
				}		
			}
			else
			{
				/* Return the name found */
				lpTableName[0] = 0;

				//RAID 42256
				char* pTemp = (char*) lpTableName;
				_bstr_t myValue((BSTR)grVariant.bstrVal);
				Utility_WideCharToDBCS(myValue, &pTemp, MAX_TABLE_NAME_LENGTH);

				lpTableName[MAX_TABLE_NAME_LENGTH] = 0;
				VariantClear(&grVariant);
				fMatchingPattern = TRUE; //to break out of loop

				sc = NO_ISAM_ERR;
			}
	
		}
	} while (!fMatchingPattern);

	//Setup table type, either SYSTEM TABLE or TABLE
	if (sc == NO_ISAM_ERR)
	{
		lpTableType[0] = 0;

		if (lpTableName && strlen((LPSTR)lpTableName) && (_strnicmp("__", (LPSTR)lpTableName, 2) == 0))
		{
			s_lstrcpy(lpTableType, "SYSTEM TABLE");	
		}
		else
		{
			s_lstrcpy(lpTableType, "TABLE");
		}
	}

	//We have finished with interfaces
	//so release them
	if (fReleaseSingleTable)
		pSingleTable->Release();

    return sc;
}


/***************************************************************************/

/* Retrieves next qualifier name from qualifier list */

SWORD INTFUNC ISAMGetNextQualifierName(UDWORD fSyncMode, LPISAMQUALIFIERLIST lpISAMQualifierList,
									   LPUSTR lpQualifierName)
{
    
    //Initialize, no errors found yet
    lpISAMQualifierList->lpISAM->errcode = NO_ISAM_ERR;

	//We need to get the next qualifier in the list from the LPISAMQUALIFIERLIST
	//However, if this is the first time this function is called, no qualifier list
	//will be present, and we will need to get it

	
	// First time through?
    if (lpISAMQualifierList->fFirstTime)
	{
		//Initialize
		lpISAMQualifierList->iIndex = NULL;
		lpISAMQualifierList->fFirstTime = FALSE;

        //Get list of qualifiers from the
		//Gateway Server, this maps to getting a list 
		//of namespaces. However, this list is already held in the
		//ISAM structure, so we simply extract from there
		//All we need to do is setup the correct position within the list

		//Setup first position in qualifier list
		lpISAMQualifierList->iIndex = lpISAMQualifierList->lpISAM->pNamespaceMap->GetStartPosition();
    }
    
	
	//Get the next qualifier (namespace)
	return ISAMGetNextQualifierName2(lpISAMQualifierList, lpQualifierName);
}

/***************************************************************************/

/* This is the second phase of getting the next qualifier name        */
/* This function is called when we have got all the information back  */
/* from the MO Server                                                 */

SWORD INTFUNC ISAMGetNextQualifierName2(LPISAMQUALIFIERLIST lpISAMQualifierList, LPUSTR lpQualifierName)
{
	//Now we have the namespace list, we need to get the 'iIndex' item for the next qualifier
	//If the 'iIndex' item is NULL we have reached the end of the list
	CString key;
	CNamespace* pN;
	CString pStr;	
	
	if (lpISAMQualifierList->iIndex)
	{
		lpISAMQualifierList->lpISAM->pNamespaceMap->GetNextAssoc(lpISAMQualifierList->iIndex, key, (CObject* &)pN);
		pStr = pN->GetName();
	}
	else
	{
		lpISAMQualifierList->lpISAM->errcode = ISAM_EOF;
		return ISAM_EOF;
	}

	//Return Qualifier name
	lpQualifierName[0] = 0;
	s_lstrcpy (lpQualifierName, pStr);

    return NO_ISAM_ERR;
}

/***************************************************************************/

/* Frees the table list stored in the LPISAMTABLELIST structure */

SWORD INTFUNC ISAMFreeTableList(LPISAMTABLELIST lpISAMTableList)
{
    lpISAMTableList->lpISAM->errcode = NO_ISAM_ERR;

	if (lpISAMTableList->pTblList)
	{
		if (lpISAMTableList->pTblList->GetCount())
		{
			POSITION thePos = NULL;
			for ( thePos = lpISAMTableList->pTblList->GetHeadPosition(); thePos != NULL; )
			{
				IWbemClassObject* pTheValue = (IWbemClassObject*) lpISAMTableList->pTblList->GetNext(thePos);

				pTheValue->Release();
			}
			lpISAMTableList->pTblList->RemoveAll();
		}
		delete lpISAMTableList->pTblList;
		lpISAMTableList->pTblList = NULL;
	}

	if (lpISAMTableList->pGateway2)
	{
		delete lpISAMTableList->pGateway2;
		lpISAMTableList->pGateway2 = NULL;
	}

    GlobalUnlock (GlobalPtrHandle(lpISAMTableList));
    GlobalFree (GlobalPtrHandle(lpISAMTableList));
    return NO_ISAM_ERR;
}

/***************************************************************************/

/* Frees the qualifier list stored in the LPISAMQUALIFIERLIST structure */

SWORD INTFUNC ISAMFreeQualifierList(LPISAMQUALIFIERLIST lpISAMQualifierList)
{

    lpISAMQualifierList->lpISAM->errcode = NO_ISAM_ERR;

	//Initialize
	lpISAMQualifierList->iIndex = NULL;

    GlobalUnlock (GlobalPtrHandle(lpISAMQualifierList));
    GlobalFree (GlobalPtrHandle(lpISAMQualifierList));

    return NO_ISAM_ERR;
}

/***************************************************************************/

SWORD INTFUNC ISAMForeignKey(LPISAM lpISAM, LPUSTR lpszPrimaryKeyTableName,
                    LPUSTR lpszForeignKeyTableName, LPUSTR lpPrimaryKeyName,
                    LPUSTR lpForeignKeyName, SWORD FAR *lpfUpdateRule,
                    SWORD FAR *lpfDeleteRule, UWORD FAR *lpcISAMKeyColumnList,
                    LPISAMKEYCOLUMNNAME ISAMPrimaryKeyColumnList,
                    LPISAMKEYCOLUMNNAME ISAMForeignKeyColumnList)
{
    /* Never any foreign keys */
    return ISAM_EOF;
}


/***************************************************************************/

SWORD INTFUNC ISAMCreateTable(LPISAM lpISAM, LPUSTR lpszTableName,
                           LPISAMTABLEDEF FAR *lplpISAMTableDef)
{
	return ISAM_NOTSUPPORTED;
}

/***************************************************************************/

SWORD INTFUNC ISAMAddColumn(LPISAMTABLEDEF lpISAMTableDef, LPUSTR lpszColumnName,
                        UWORD iSqlType, UDWORD udParam1, UDWORD udParam2)
{
	return ISAM_NOTSUPPORTED;
}

/***************************************************************************/

SWORD INTFUNC ISAMCreateIndex(LPISAMTABLEDEF lpISAMTableDef,
                              LPUSTR lpszIndexName, BOOL fUnique, UWORD count,
                              UWORD FAR *icol, BOOL FAR *fDescending)
{
    return ISAM_NOTSUPPORTED;
}

/***************************************************************************/

SWORD INTFUNC ISAMDeleteIndex(LPISAM lpISAM, LPUSTR lpszIndexName)
{
    return ISAM_NOTSUPPORTED;
}

/***************************************************************************/

/* Opens a specific table and produces a table definition to clearly define the table structure */
// Checked for SetInterfaceSecurityEx on IWbemServices

SWORD INTFUNC ISAMOpenTable(LPISAM lpISAM, LPUSTR szTableQualifier, SWORD cbTableQualifier,
							LPUSTR lpszTableName, BOOL fReadOnly, 
							LPISAMTABLEDEF FAR *lplpISAMTableDef, LPSTMT lpstmt)

{
    HGLOBAL     h;
    LPISAMTABLEDEF lpISAMTableDef;
    LPDBASEFILE lpFile;

    /* Opening the passthrough SQL result set? */
    lpISAM->errcode = NO_ISAM_ERR;

	//Create a pointer to store table class definition
	//the class definition object will be CREATED on the HEAP
	//by the GetClass function or left a NULL pointer
	IWbemClassObject* pSingleTable = NULL;


	//Allocate memory for DBASEFILE
	h = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (DBASEFILE));
	if (h == NULL || (lpFile = (LPDBASEFILE) GlobalLock (h)) == NULL) 
	{
		if (h)
            GlobalFree(h);

		lpISAM->errcode = ISAM_MEMALLOCFAIL;
		return ISAM_MEMALLOCFAIL;
	}

	//Allocate memory for TABLEDEF
	h = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (ISAMTABLEDEF));
	if (h == NULL || (lpISAMTableDef = (LPISAMTABLEDEF) GlobalLock (h)) == NULL) 
	{
		if (h)
            GlobalFree(h);

		if (lpFile)
		{
			GlobalUnlock(GlobalPtrHandle(lpFile));
			GlobalFree(GlobalPtrHandle(lpFile));
			lpFile = NULL;
		}


		lpISAM->errcode = ISAM_MEMALLOCFAIL;
		return ISAM_MEMALLOCFAIL;
	}


	//Initialize
	lpFile->tempEnum = new CSafeIEnumWbemClassObject();
	lpISAMTableDef->pGateway2 = new CSafeWbemServices();
	lpISAMTableDef->pBStrTableName = NULL;
	lpISAMTableDef->pSingleTable = NULL;
	lpISAMTableDef->pColumnInfo = NULL;
	lpISAMTableDef->passthroughMap = NULL;
	lpISAMTableDef->firstPassthrInst = NULL;
	lpISAMTableDef->virtualInstances = new VirtualInstanceManager();

	//Check if PassthroughSQL
	BOOL fIsPassthroughSQL = FALSE;
	char* virTbl = WBEMDR32_VIRTUAL_TABLE2;
	if (lpstmt && (s_lstrcmp(lpszTableName, virTbl) == 0))
	{
		fIsPassthroughSQL = TRUE;
	}

	lpISAMTableDef->fIsPassthroughSQL = fIsPassthroughSQL;



 //   if (s_lstrcmpi(lpszTableName, WBEMDR32_VIRTUAL_TABLE)) 
	{

		//Ignore below statement
        /* NO, not passthough */
		

		//First get the Gateway Interface
		//remember to Release it after use
		if (fIsPassthroughSQL)
		{
			lpISAMTableDef->pGateway2->Transfer(*(lpstmt->lpISAMStatement->pProv));
			lpISAMTableDef->passthroughMap = lpstmt->lpISAMStatement->passthroughMap;
			lpstmt->lpISAMStatement->passthroughMap = NULL;
			lpISAMTableDef->firstPassthrInst= lpstmt->lpISAMStatement->firstPassthrInst;
			lpstmt->lpISAMStatement->firstPassthrInst = NULL;
		}
		else
		{
			lpISAMTableDef->pGateway2->SetInterfacePtr( lpISAM, szTableQualifier, cbTableQualifier);
		}
		//Check if a valid interface was returned
		if ( ! lpISAMTableDef->pGateway2->IsValid() )
		{
			//Could not create a Gateway Interface, return error

			if (lpFile)
			{

				if (lpFile->tempEnum)
				{
					delete lpFile->tempEnum;
					lpFile->tempEnum = NULL;
				}

				GlobalUnlock(GlobalPtrHandle(lpFile));
				GlobalFree(GlobalPtrHandle(lpFile));
				lpFile = NULL;
			}

			if (lpISAMTableDef->virtualInstances)
			{
				delete (lpISAMTableDef->virtualInstances);
				lpISAMTableDef->virtualInstances = NULL;
			}

			if (lpISAMTableDef->pBStrTableName)
			{
				delete lpISAMTableDef->pBStrTableName;
				lpISAMTableDef->pBStrTableName = NULL;
			}

			if (lpISAMTableDef->pGateway2)
			{
				delete lpISAMTableDef->pGateway2;
				lpISAMTableDef->pGateway2 = NULL;
			}

			if (lpISAMTableDef)
			{
				GlobalUnlock(GlobalPtrHandle(lpISAMTableDef));
				GlobalFree(GlobalPtrHandle(lpISAMTableDef));
				lpISAMTableDef = NULL;
			}

			lpISAM->errcode = ISAM_PROVIDERFAIL;
			return ISAM_PROVIDERFAIL;
		}

		lpISAMTableDef->pBStrTableName = new CBString();
		lpISAMTableDef->pBStrTableName->AddString((LPSTR)lpszTableName, FALSE);

		//Get the class definition
		if (fIsPassthroughSQL)
		{
			//Get class definition from lpstmt
			pSingleTable = lpstmt->lpISAMStatement->classDef;

			lpstmt->lpISAMStatement->classDef = NULL;
		}
		else
		{
			IWbemServicesPtr myServicesPtr = NULL;
			ISAMGetIWbemServices(lpISAM, *(lpISAMTableDef->pGateway2), myServicesPtr);

			if ( FAILED(myServicesPtr->GetObject(lpISAMTableDef->pBStrTableName->GetString(), 0, lpISAMTableDef->pContext, &pSingleTable, NULL)) )
			{
				//Failed to get named class definition


				if (lpFile)
				{
					if (lpFile->tempEnum)
					{
						delete lpFile->tempEnum;
						lpFile->tempEnum = NULL;
					}
					GlobalUnlock(GlobalPtrHandle(lpFile));
					GlobalFree(GlobalPtrHandle(lpFile));
					lpFile = NULL;
				}

				if (lpISAMTableDef->virtualInstances)
				{
					delete (lpISAMTableDef->virtualInstances);
					lpISAMTableDef->virtualInstances = NULL;
				}

				if (lpISAMTableDef->pBStrTableName)
				{
					delete lpISAMTableDef->pBStrTableName;
					lpISAMTableDef->pBStrTableName = NULL;
				}

				if (lpISAMTableDef->pGateway2)
				{
					delete lpISAMTableDef->pGateway2;
					lpISAMTableDef->pGateway2 = NULL;
				}

				if (lpISAMTableDef)
				{
					GlobalUnlock(GlobalPtrHandle(lpISAMTableDef));
					GlobalFree(GlobalPtrHandle(lpISAMTableDef));
					lpISAMTableDef = NULL;
				}

				lpISAM->errcode = ISAM_TABLEFAIL;
				return ISAM_TABLEFAIL;
			}
		}
    }

    /* Fill in table definition */
	lpISAMTableDef->szTableName[0] = 0;
    s_lstrcpy(lpISAMTableDef->szTableName, lpszTableName);
    s_lstrcpy(lpISAMTableDef->szPrimaryKeyName, "");
    lpISAMTableDef->lpISAM = lpISAM;
    lpISAMTableDef->lpFile = lpFile;
    lpISAMTableDef->fFirstRead = TRUE;
    lpISAMTableDef->iRecord = -1;

	if (lpFile)
	{
		lpISAMTableDef->lpFile->sortArray = NULL;

		if (fIsPassthroughSQL)
		{
			lpISAMTableDef->lpFile->pAllRecords = new CMapWordToPtr();
			lpISAMTableDef->lpFile->fMoreToCome = TRUE; //more instances need to be fetched (none fetched so far)


			if (lpISAMTableDef->lpFile->tempEnum)
				delete (lpISAMTableDef->lpFile->tempEnum);

			lpISAMTableDef->lpFile->tempEnum = lpstmt->lpISAMStatement->tempEnum;
			lpstmt->lpISAMStatement->tempEnum = NULL; //SAI NEW to avoid enumeration being deleted in ISAMFreeStatement
			
		}
		else
		{
			lpISAMTableDef->lpFile->pAllRecords = new CMapWordToPtr();			

			delete lpISAMTableDef->lpFile->tempEnum;
			lpISAMTableDef->lpFile->tempEnum = new CSafeIEnumWbemClassObject();
			lpISAMTableDef->lpFile->fMoreToCome = FALSE; //not used but set it with a value anyway
		}

		lpISAMTableDef->lpFile->record = NULL;
	}

    lpISAMTableDef->netISAMTableDef = NET_OPAQUE_INVALID;
    lpISAMTableDef->hPreFetchedValues = NULL;
    lpISAMTableDef->cbBookmark = 0;
	lpISAMTableDef->bookmark.currentRecord = 0;
    lpISAMTableDef->bookmark.currentInstance = 0;

	//this is 8 - see assinment above
	lpISAMTableDef->pSingleTable = pSingleTable; //Contains class info
	

	//We must indicate to the class below how to parse the information
	//Ther unique case is when we do passthrough for multi-tables
	//and we get a __Generic class
	//We check for this
	BOOL fIs__Generic = FALSE;

	if (fIsPassthroughSQL)
	{
		//Extract class name from class definition
		//The table name is held in the property attribute __CLASS
		VARIANT grVariant;
		BSTR classBSTR = SysAllocString(WBEMDR32_L_CLASS);
		if (FAILED(pSingleTable->Get(classBSTR, 0, &grVariant, NULL, NULL)))
		{

			//SAI ADDED - Failed should we also 
			//free pSingleTable ? 

			lpISAM->errcode = ISAM_NOTSUPPORTED;
			SysFreeString(classBSTR);


			if (lpFile)
			{
				if (lpFile->tempEnum)
				{
					delete lpFile->tempEnum;
					lpFile->tempEnum = NULL;
				}

				GlobalUnlock(GlobalPtrHandle(lpFile));
				GlobalFree(GlobalPtrHandle(lpFile));
				lpFile = NULL;
			}

			if (lpISAMTableDef->virtualInstances)
			{
				delete (lpISAMTableDef->virtualInstances);
				lpISAMTableDef->virtualInstances = NULL;
			}

			if (lpISAMTableDef->pBStrTableName)
			{
				delete lpISAMTableDef->pBStrTableName;
				lpISAMTableDef->pBStrTableName = NULL;
			}

			if (lpISAMTableDef->pGateway2)
			{
				delete lpISAMTableDef->pGateway2;
				lpISAMTableDef->pGateway2 = NULL;
			}

			if (lpISAMTableDef->pSingleTable)
			{
				lpISAMTableDef->pSingleTable->Release();
				lpISAMTableDef->pSingleTable = NULL;
			}

			if (lpISAMTableDef)
			{
				GlobalUnlock(GlobalPtrHandle(lpISAMTableDef));
				GlobalFree(GlobalPtrHandle(lpISAMTableDef));
				lpISAMTableDef = NULL;
			}

			return ISAM_NOTSUPPORTED;
		}

		SysFreeString(classBSTR);

		//Compare with __Generic
		if (_wcsicmp(grVariant.bstrVal, L"__Generic") == 0)
		{
			fIs__Generic = TRUE;
		}

	}

	lpISAMTableDef->fIs__Generic = fIs__Generic;

	ClassColumnInfoBase* tempInfo = new ClassColumnInfoBase(lpISAMTableDef,lpISAMTableDef->fIs__Generic);
	lpISAMTableDef->pColumnInfo = tempInfo;

	//DCR 29279
	//Add LocaleID context object
	lpISAMTableDef->pContext = NULL;
	ISAMAddLocaleIDContextObject(lpISAMTableDef, lpISAMTableDef->lpISAM);

    *lplpISAMTableDef = lpISAMTableDef;

    return NO_ISAM_ERR;
}

IWbemContext* ISAMCreateLocaleIDContextObject(char* lpLocale)
{
	IWbemContext* pContext = NULL;

	if (!lpLocale)
		return NULL;

	if (!lstrlen(lpLocale))
		return NULL;

	//First get the context interface
	//===============================
	SCODE sc = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER , IID_IWbemContext, (void**) ( &pContext ) );

	if ( FAILED(sc) )
	{
		ODBCTRACE("WBEM ODBC DRIVER : Failed to create context object for LocaleId");
		return NULL;
	}

	//Now add the locale value
	_bstr_t myLocaleParm ("LocaleID");
	_variant_t myLocaleVal(lpLocale);
	sc = pContext->SetValue(myLocaleParm, 0, &myLocaleVal);

	if ( FAILED(sc) )
	{
		ODBCTRACE("WBEM ODBC DRIVER : Failed to set LocaleId in context object");
		return NULL;
	}

	return pContext;
}

void ISAMAddLocaleIDContextObject(LPISAMTABLEDEF lpISAMTableDef, LPISAM lpISAM)
{	
	//add locale id to context object
	lpISAMTableDef->pContext = ISAMCreateLocaleIDContextObject(lpISAM->m_Locale);
}

/***************************************************************************/
SWORD INTFUNC ISAMRewind(LPISAMTABLEDEF lpISAMTableDef)
{
    lpISAMTableDef->lpISAM->errcode = NO_ISAM_ERR;
    lpISAMTableDef->fFirstRead = TRUE;
    lpISAMTableDef->iRecord = -1;
    return NO_ISAM_ERR;
}
/***************************************************************************/

SWORD INTFUNC ISAMSort(LPISAMTABLEDEF lpISAMTableDef,
                       UWORD          count,
                       UWORD FAR *    icol,
                       BOOL FAR *     fDescending)
{
	if (count)
	{
		lpISAMTableDef->lpISAM->errcode = ISAM_NOTSUPPORTED;
		return ISAM_NOTSUPPORTED;
	}

	lpISAMTableDef->lpISAM->errcode = NO_ISAM_ERR;
	return NO_ISAM_ERR;
	
}

/***************************************************************************/

SWORD INTFUNC ISAMRestrict(LPISAMTABLEDEF    lpISAMTableDef,
                           UWORD             count,
                           UWORD FAR *       icol,
                           UWORD FAR *       fOperator,
                           SWORD FAR *       fCType, 
                           PTR FAR *         rgbValue, 
                           SDWORD FAR *      cbValue)
{
    /* Note: Indexes are not used in this implementation, so this   */
    /*       restriction is ignored.                                */

    lpISAMTableDef->lpISAM->errcode = ISAM_NOTSUPPORTED;
    return ISAM_NOTSUPPORTED;
}

// Checked for SetInterfaceSecurityEx on IWbemServices

void ISAMPatchUpGatewaySecurity(LPISAM lpISAM, IWbemServices* myServicesPtr)
{
	SCODE sc  = GetAuthImp( myServicesPtr, &(lpISAM->dwAuthLevel), &(lpISAM->dwImpLevel));
	
	if(sc == S_OK)
	{		
		if (lpISAM->dwAuthLevel > RPC_C_AUTHN_LEVEL_NONE)
			lpISAM->dwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;


//		CBString myServerStr;
//		myServerStr.AddString( (LPSTR)lpISAM->szServer, FALSE );
//		CServerLocationCheck myCheck (myServerStr);
		BOOL fIsLocalConnection = lpISAM->fIsLocalConnection;//myCheck.IsLocal();

		sc = ISAMSetCloaking2(myServicesPtr, 
							fIsLocalConnection, 
							lpISAM->fW2KOrMore, 
							lpISAM->dwAuthLevel, 
							lpISAM->dwImpLevel,
							lpISAM->gpAuthIdentity);
/*
		if ( fIsLocalConnection && (lpISAM->fW2KOrMore) )
		{
			sc = WbemSetDynamicCloaking(myServicesPtr, lpISAM->dwAuthLevel, lpISAM->dwImpLevel);
		}
		else
		{
			sc = SetInterfaceSecurityEx(myServicesPtr, lpISAM->gpAuthIdentity, gpPrincipal, lpISAM->dwAuthLevel, lpISAM->dwImpLevel);
		}
*/
	}
}

/***************************************************************************/

#define WBEMDR32_ELEMENTS_TO_READ 1000

/* retrieves the next record from the selected table */
// Checked for SetInterfaceSecurityEx on IWbemServices and IEnumWbemClassObject

SWORD INTFUNC ISAMNextRecord(LPISAMTABLEDEF lpISAMTableDef, LPSTMT lpstmt)
{
	ODBCTRACE("\nWBEM ODBC Driver : ISAMNextRecord\n");

    SWORD err = DBASE_ERR_SUCCESS;

    // Move to the next record 
    lpISAMTableDef->lpISAM->errcode = NO_ISAM_ERR;

    if (lpISAMTableDef->lpFile != NULL) 
	{
        if (lpISAMTableDef->fFirstRead)
		{
			//copy table name
			char pTableName [MAX_TABLE_NAME_LENGTH+1];
			pTableName[0] = 0;
			wcstombs(pTableName, lpISAMTableDef->pBStrTableName->GetString(), MAX_TABLE_NAME_LENGTH);
			pTableName[MAX_TABLE_NAME_LENGTH] = 0;
			
			//Get enumeration of all instances of current class

			
			//First check if this table has been RESET
			SCODE sc;

			if (lpISAMTableDef->lpFile->tempEnum->IsValid())
			{
				//Yes, reuse old enumeration
				//Passthrough SQL will always go here !!!
				sc = S_OK;
			}
			else
			{
				//no old enumeration, so create one
				lpISAMTableDef->lpFile->tempEnum->Invalidate();

				//before getting enumeration check if we can perform
				//some optimization by converting to an WBEM Level 1 query
				//base on a single table

				LPSQLNODE lpRootNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
				LPSQLNODE lpSqlNode2 = ToNode(lpstmt->lpSqlStmt, lpRootNode->node.root.sql);

				char* buffer = NULL;
				BOOL fOptimization = FALSE;

				//Check if WBEM Level 1 optimization is enabled
		
				if (lpISAMTableDef->lpISAM->fOptimization)
				{
					if ( lpSqlNode2->node.select.Predicate != NO_SQLNODE)
					{
						LPSQLNODE lpPredicateNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode2->node.select.Predicate); 
						PredicateParser theParser (&lpRootNode, lpISAMTableDef);
						
						theParser.GeneratePredicateString(lpPredicateNode, &buffer);
					}
				}

				//Sai Wong
//				if (buffer && lstrlen(buffer))
				{
					//Get select list
				
					char* selectStr = NULL;

					TableColumnInfo selectInfo (&lpRootNode, &lpSqlNode2);
				
					lpISAMTableDef->passthroughMap = NULL;
					selectInfo.BuildSelectList(lpISAMTableDef, &selectStr, TRUE, &(lpISAMTableDef->passthroughMap));

					if (selectStr)
					{
						fOptimization = TRUE;
						_bstr_t sqltextBSTR =  L"SELECT ";
						_bstr_t sqltextBSTR2;
						sqltextBSTR			+= selectStr;
						sqltextBSTR			+= L" FROM ";
						sqltextBSTR			+= pTableName;

						//Is there a WHERE statement ?
						if (buffer && lstrlen(buffer))
						{
							//RAID 29811
							//If this query contains a JOIN do not add in the WHERE predicate
							//so we do the ON and WHERE in the correct order
							//Get the table list first to find out if we are 
							//SQL-89 or SQL-92
							char* checkTableList = NULL;
							BOOL fIsSQL89 = TRUE;
							selectInfo.BuildTableList(&checkTableList, fIsSQL89);
							delete checkTableList;

							if (fIsSQL89)
							{
								sqltextBSTR2         = sqltextBSTR; //make copy of this 
								sqltextBSTR			+= L" WHERE ";
								sqltextBSTR			+= buffer;
							}
						}

						sc = lpISAMTableDef->lpFile->tempEnum->SetInterfacePtr(lpISAMTableDef->lpISAM, WMI_EXEC_QUERY, sqltextBSTR, lpISAMTableDef->pGateway2);
						
						ODBCTRACE(_T("\nWBEM ODBC Driver : Non-passthrough WQL = "));
						ODBCTRACE(sqltextBSTR);
						ODBCTRACE(_T("\n"));

						CString sMessage;
						sMessage.Format(_T("\nWBEM ODBC Driver : sc = %ld\n"), sc);
						ODBCTRACE(sMessage);

						sMessage.Format(_T("\nWBEM ODBC Driver : LPISAM data : szUser = %s\nszPassword = %s\nszDatabase = %s\nszServer = %s\n"), 
							lpISAMTableDef->lpISAM->szUser,
							lpISAMTableDef->lpISAM->szPassword,
							lpISAMTableDef->lpISAM->szDatabase,
							lpISAMTableDef->lpISAM->szServer
							);
						ODBCTRACE(sMessage);


						if (! lpISAMTableDef->pGateway2->IsValid() )
							ODBCTRACE( _T("\nWBEM ODBC Driver :pGateway is NULL\n"));

						//If ExecQuery is not supported or if there is any problems, get all entries as normal 
						if ( (sc == WBEM_E_NOT_SUPPORTED) || (sc == WBEM_E_FAILED) || (sc == WBEM_E_INVALID_QUERY) )
						{
							//Try it without the LIKE predicate
							if ( sqltextBSTR2.length() )
							{
								if (lpISAMTableDef->lpISAM->fOptimization)
								{
									if ( lpSqlNode2->node.select.Predicate != NO_SQLNODE)
									{
										if (buffer)
											delete buffer;

										buffer = NULL;

										LPSQLNODE lpPredicateNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode2->node.select.Predicate); 
										PredicateParser theParser (&lpRootNode, lpISAMTableDef, FALSE);
										
										theParser.GeneratePredicateString(lpPredicateNode, &buffer);

										if ( buffer && lstrlen(buffer) )
										{
											sqltextBSTR2 += L" WHERE ";
											sqltextBSTR2 += buffer;
										}

										ODBCTRACE(_T("\nWBEM ODBC Driver : Non-passthrough WQL (attempt 2) = "));
										ODBCTRACE(sqltextBSTR2);
										ODBCTRACE(_T("\n"));

										sc = lpISAMTableDef->lpFile->tempEnum->SetInterfacePtr(lpISAMTableDef->lpISAM, WMI_EXEC_QUERY, sqltextBSTR, lpISAMTableDef->pGateway2);

										//If ExecQuery is not supported or if there is any problems, get all entries as normal 
										if ( (sc == WBEM_E_NOT_SUPPORTED) || (sc == WBEM_E_FAILED) || (sc == WBEM_E_INVALID_QUERY) )
										{
											fOptimization = FALSE;
										}
									}
								}
							}
							else
							{
								fOptimization = FALSE;
							}
						}
						
						delete selectStr;
					}
					
				}

				if (!fOptimization)
				{
					//no optimization allowed
					ODBCTRACE(_T("\nWBEM ODBC Driver : Non-passthrough WQL failed performing CreateInstanceEnum\n"));

					sc = lpISAMTableDef->lpFile->tempEnum->SetInterfacePtr(lpISAMTableDef->lpISAM, WMI_CREATE_INST_ENUM, lpISAMTableDef->pBStrTableName->GetString(), lpISAMTableDef->pGateway2);

				}

				//Tidy up
				if (buffer)
					delete buffer;
			}
			
			if ( sc != S_OK )
			{
				err = DBASE_ERR_NODATAFOUND;
			}
			else
			{
				if (lpISAMTableDef->lpFile->tempEnum->IsValid())
				{
					IWbemServicesPtr myServicesPtr = NULL;
					ISAMGetIWbemServices(lpISAMTableDef->lpISAM, *(lpISAMTableDef->pGateway2), myServicesPtr);

					IEnumWbemClassObjectPtr myIEnumWbemClassObject = NULL;
					lpISAMTableDef->lpFile->tempEnum->GetInterfacePtr(myIEnumWbemClassObject);


//					CBString myServerStr;
//					myServerStr.AddString( (LPSTR)lpISAMTableDef->lpISAM->szServer, FALSE );
//					CServerLocationCheck myCheck (myServerStr);
					BOOL fIsLocalConnection = lpISAMTableDef->lpISAM->fIsLocalConnection;//myCheck.IsLocal();


					ISAMSetCloaking2(myIEnumWbemClassObject, 
									fIsLocalConnection, 
									lpISAMTableDef->lpISAM->fW2KOrMore, 
									lpISAMTableDef->lpISAM->dwAuthLevel, 
									lpISAMTableDef->lpISAM->dwImpLevel,
									lpISAMTableDef->lpISAM->gpAuthIdentity);
/*
					if ( fIsLocalConnection && IsW2KOrMore() )
					{
						WbemSetDynamicCloaking(myIEnumWbemClassObject, lpISAMTableDef->lpISAM->dwAuthLevel, lpISAMTableDef->lpISAM->dwImpLevel);
					}
					else
					{
						SetInterfaceSecurityEx(myIEnumWbemClassObject,
							lpISAMTableDef->lpISAM->gpAuthIdentity, 
							gpPrincipal,
							lpISAMTableDef->lpISAM->dwAuthLevel, 
							lpISAMTableDef->lpISAM->dwImpLevel);
					}
*/
					//Reset to beginning of list
					myIEnumWbemClassObject->Reset();

					//Read in ALL records (if not already read)
					//but only for non-passthrough SQL case
					//if this is passthrough SQL delay retrieval
		
					if (
							(!lpISAMTableDef->fIsPassthroughSQL) && 
							(lpISAMTableDef->lpFile->pAllRecords->IsEmpty()) 
						)
					{
						WORD fElements2Read = WBEMDR32_ELEMENTS_TO_READ;
						ULONG puReturned = 0;
						IWbemClassObject* myRecords [WBEMDR32_ELEMENTS_TO_READ];

						//Initialize array
						for (ULONG loop = 0; loop < fElements2Read; loop++)
						{
							myRecords[loop] = NULL; //reset for next instance
						}

						WORD elementNumber = 0;
						while ( myIEnumWbemClassObject->Next(-1, fElements2Read, myRecords, &puReturned) == S_OK )
						{
							for (loop = 0; loop < puReturned; loop++)
							{
								lpISAMTableDef->lpFile->pAllRecords->SetAt(elementNumber++, (void*)myRecords[loop] );
								myRecords[loop] = NULL; //reset for next instance
							}
							puReturned = 0;
						}

						//This could be the last time around the loop
						if (puReturned)
						{
							for (ULONG loop = 0; loop < puReturned; loop++)
							{
								lpISAMTableDef->lpFile->pAllRecords->SetAt(elementNumber++, (void*)myRecords[loop] );
							}
						}
					}

					//Setup bookmark
					lpISAMTableDef->lpFile->currentRecord = 0;
				}
				else
				{
					err = DBASE_ERR_NODATAFOUND;
				}				
			}
		}
        
		if (err != DBASE_ERR_NODATAFOUND)
		{
			//Now fetch the next record

			//Check Virtual Instances
			//they occur if you query for array type columns which map
			//to multiple instances
			BOOL fFetchNextInstance = TRUE;

			if ( lpISAMTableDef->virtualInstances )
			{
				long numInst = lpISAMTableDef->virtualInstances->cNumberOfInstances;
				long currInst = lpISAMTableDef->virtualInstances->currentInstance;

				CString myText;
				myText.Format("\nWBEM ODBC Driver : number of virtual instances = %ld   current virtual instance = %ld\n", numInst, currInst);
				ODBCTRACE(myText);

				if ( (numInst != 0) && ( (currInst + 1) < numInst ) )
				{
					//Don't fetch another instance
					//just increment virtual instance
					ODBCTRACE ("\nWBEM ODBC Driver : not fetching another instance, just updating virtual instance number\n");

					fFetchNextInstance = FALSE;
					++(lpISAMTableDef->virtualInstances->currentInstance);
				}

			}

			if (fFetchNextInstance)
			{
				//In passthrough SQL case you might not have any instances yet
				//or we might have read all the 10 instances and need to load the next batch,
				//therefore we make a check now
				if ( lpISAMTableDef->fIsPassthroughSQL )
				{
					//Do we need to load in the next batch of 10 instances ?
					if ( 
							( 
								lpISAMTableDef->lpFile->pAllRecords->IsEmpty() ||
								lpISAMTableDef->lpFile->currentRecord >= BATCH_NUM_OF_INSTANCES
							) 
							&& lpISAMTableDef->lpFile->fMoreToCome )
					{

						//Yes, load next batch
						ODBCTRACE ("\nWBEM ODBC Driver : Need to Load next batch of 10 instances\n");


						//First clear out old instances, if applicable
						if (! lpISAMTableDef->lpFile->pAllRecords->IsEmpty() )
						{
							for(POSITION pos = lpISAMTableDef->lpFile->pAllRecords->GetStartPosition(); pos != NULL; )
							{
								WORD key = 0;
								IWbemClassObject* pa = NULL;
								lpISAMTableDef->lpFile->pAllRecords->GetNextAssoc( pos, key, (void*&)pa );

								if (pa)
								{
									pa->Release();
								}
							}
							delete (lpISAMTableDef->lpFile->pAllRecords);
							lpISAMTableDef->lpFile->pAllRecords = new CMapWordToPtr();
						}
						

						

						//Load the next 10 instances
						lpISAMTableDef->lpFile->currentRecord = 0;

						WORD fElements2Read = BATCH_NUM_OF_INSTANCES;
						ULONG puReturned = 0;
						IWbemClassObject* myRecords [BATCH_NUM_OF_INSTANCES];

						//Initialize array
						for (ULONG loop = 0; loop < fElements2Read; loop++)
						{
							myRecords[loop] = NULL; //reset for next instance
						}

						WORD elementNumber = 0;

						//Special case. The 1st SQL passthrough instance was 
						//already fetched
						BOOL fSpecialCase = FALSE;
						if (lpISAMTableDef->firstPassthrInst)
						{
							fSpecialCase = TRUE;


							
							lpISAMTableDef->lpFile->pAllRecords->SetAt(elementNumber++, (void*)lpISAMTableDef->firstPassthrInst);
							
							lpISAMTableDef->firstPassthrInst = NULL; //mark as used


						}

						ODBCTRACE("\nWBEM ODBC Driver : Calling Next(...)\n");


						IEnumWbemClassObjectPtr myIEnumWbemClassObject = NULL;
						lpISAMTableDef->lpFile->tempEnum->GetInterfacePtr(myIEnumWbemClassObject); // Note: don't need to call SetInterfaceSecurityEx because it has already been called for this ptr

//						CBString myServerStr;
//						myServerStr.AddString( (LPSTR)lpISAMTableDef->lpISAM->szServer, FALSE );
//						CServerLocationCheck myCheck (myServerStr);
						BOOL fIsLocalConnection = lpISAMTableDef->lpISAM->fIsLocalConnection;//myCheck.IsLocal();

						if ( fIsLocalConnection && (lpISAMTableDef->lpISAM->fW2KOrMore) )
						{
							WbemSetDynamicCloaking(myIEnumWbemClassObject, lpISAMTableDef->lpISAM->dwAuthLevel, lpISAMTableDef->lpISAM->dwImpLevel);
						}

						

						if (SUCCEEDED(myIEnumWbemClassObject->Next(-1, fElements2Read-(fSpecialCase?1:0), myRecords, &puReturned)))
						{
							CString myText;
							myText.Format("\nWBEM ODBC Driver : We got back a batch of %ld instances\n", puReturned);
							ODBCTRACE(myText);
							int i = 0;
							loop = 0;

							for (; i < puReturned; i++)
							{
								lpISAMTableDef->lpFile->pAllRecords->SetAt(elementNumber++, (void*)myRecords[i] );
								loop++;
							}

							puReturned+=((fSpecialCase?1:0));

							//Did we get 10 instances back or less
							BOOL fGotFullSetofInstances = TRUE;
							fGotFullSetofInstances = (puReturned == BATCH_NUM_OF_INSTANCES) ? TRUE : FALSE;

							if ( !fGotFullSetofInstances )
							{
								//This is the last set of 10 instances
								lpISAMTableDef->lpFile->fMoreToCome = FALSE;
							}
						}
					}
				}

				lpISAMTableDef->lpFile->record = NULL;

				ODBCTRACE ("\nWBEM ODBC Driver : Fetching next instance from CMapWordToPtr\n");

				
				BOOL fStatus = lpISAMTableDef->lpFile->pAllRecords->Lookup
								((WORD)lpISAMTableDef->lpFile->currentRecord, (void* &)lpISAMTableDef->lpFile->record);
				
				//Check that a record was returned
				if (fStatus && lpISAMTableDef->lpFile->record)
				{
					//Increment bookmark
					++(lpISAMTableDef->lpFile->currentRecord);

					//Remove previous virtual instance map (if there was one)
					delete (lpISAMTableDef->virtualInstances);

					lpISAMTableDef->virtualInstances = new VirtualInstanceManager();

					lpISAMTableDef->virtualInstances->Load(lpISAMTableDef->passthroughMap, lpISAMTableDef->lpFile->record);
				}
				else
				{
					err = DBASE_ERR_NODATAFOUND;
				}
			}			
		}
    }
    else 
	{
        if (lpISAMTableDef->iRecord != 1)
            err = DBASE_ERR_SUCCESS;
        else
            err = DBASE_ERR_NODATAFOUND;
    }

    // Error if end of file? 
    if (err == DBASE_ERR_NODATAFOUND) 
	{
        lpISAMTableDef->lpISAM->errcode = ISAM_EOF;
        return ISAM_EOF;
    }
    else if (err != DBASE_ERR_SUCCESS) 
	{
        lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
        return ISAM_ERROR;
    }

    lpISAMTableDef->fFirstRead = FALSE;
    return NO_ISAM_ERR;
}

/***************************************************************************/

/* Provides default value for selected column  */

SWORD ISAMProvideDefaultValue(SWORD             fCType, 
							  PTR               rgbValue, 
							  SDWORD            cbValueMax, 
							  SDWORD FAR        *pcbValue)
{
	SWORD err = NO_ISAM_ERR;

	switch (fCType)
	{
	case SQL_C_DOUBLE:
		{
			//Check that you have enough buffer to store value
			*pcbValue = sizeof(double);
			if (cbValueMax >= *pcbValue)
			{
				*((double *)rgbValue) = (double)0;
			}
			else
			{
				*pcbValue = 0;
				err = ISAM_ERROR;
			}
		}
		break;
	case SQL_C_DATE:
		{
			*pcbValue = sizeof (DATE_STRUCT);
			DATE_STRUCT FAR* pDateStruct = (DATE_STRUCT FAR*)rgbValue;
			if ( cbValueMax >= (*pcbValue) )
			{
				pDateStruct->year = (SWORD)0;
				pDateStruct->month = (UWORD)0;
				pDateStruct->day = (UWORD)0;
			}
			else
			{
				*pcbValue = 0;
				err =  ISAM_ERROR;
			}
		}
		break;
	case SQL_C_TIME:
		{
			//Check that you have enough buffer to store value
			*pcbValue = sizeof (TIME_STRUCT);
			TIME_STRUCT FAR* pTimeStruct = (TIME_STRUCT FAR*)rgbValue;
			if ( cbValueMax >= (*pcbValue) )
			{
				pTimeStruct->hour = (UWORD)0;
				pTimeStruct->minute = (UWORD)0;
				pTimeStruct->second = (UWORD)0;
			}
			else
			{
				*pcbValue = 0;
				err = ISAM_ERROR;
			}
		}
		break;
	case SQL_C_TIMESTAMP:
		{
			//Check that you have enough buffer to store value
			*pcbValue = sizeof (TIMESTAMP_STRUCT);
			TIMESTAMP_STRUCT FAR* pTimeStampStruct = (TIMESTAMP_STRUCT FAR*)rgbValue;
			if ( cbValueMax >= (*pcbValue) )
			{
				pTimeStampStruct->year = (SWORD)0;
				pTimeStampStruct->month = (UWORD)0;
				pTimeStampStruct->day = (UWORD)0;
				pTimeStampStruct->hour = (UWORD)0;
				pTimeStampStruct->minute = (UWORD)0;
				pTimeStampStruct->second = (UWORD)0;
				pTimeStampStruct->fraction = 0;
			
			}
			else
			{
				*pcbValue = 0;
				err = ISAM_ERROR;
			}
		}
		break;
	case SQL_C_CHAR:
	case SQL_C_BINARY:
	default:
		{
			*pcbValue = SQL_NULL_DATA;
		}
		break;
	}

	return err;
}

/***************************************************************************/

/* Gets the data value for the selected column */

SWORD INTFUNC ISAMGetData(LPISAMTABLEDEF    lpISAMTableDef,
                          UWORD             icol,
                          SDWORD            cbOffset, 
                          SWORD             fCType, 
                          PTR               rgbValue, 
                          SDWORD            cbValueMax, 
                          SDWORD FAR        *pcbValue)
{
	//This manages the thread locale id
	ThreadLocaleIdManager myThreadStuff(lpISAMTableDef->lpISAM);
	
	lpISAMTableDef->lpISAM->errcode = NO_ISAM_ERR;

    if ((fCType != SQL_CHAR) && (lpISAMTableDef->lpFile == NULL)) 
	{
        lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
		ODBCTRACE("\nWBEM ODBC Driver : ISAMGetData : Error position 1\n");
        return ISAM_ERROR;
    }

	if (cbValueMax == SQL_NTS)
		cbValueMax = s_lstrlen (rgbValue);

	//create SAFEARRAY to store BSTR's
	SAFEARRAY FAR* rgSafeArray = NULL; 

	//Create a store for column name
	BSTR lpbString;
	CBString temppbString;

	//Stores table alias
	CBString cbTableAlias;

	//Check if you have a __Generic class
	BOOL fIs__Generic = lpISAMTableDef->fIs__Generic;

	//Points to the current instance for the property
	IWbemClassObjectPtr theRecord = NULL;

	//Points to the current class definition
	IWbemClassObjectPtr theClassDefinition = NULL;
	
	if (!fIs__Generic)
	{
		//Setup the record pointer
		theRecord = lpISAMTableDef->lpFile->record;



		//Setup the class definition pointer
		theClassDefinition = lpISAMTableDef->pSingleTable;


		//Fetch name of column "icol"
		//Remeber with abstract and derived classes the properities in the class definition
		//may be different to the properties in the instances.
		//The "icol" maps to a class property,so we get the names from the class
		
		lpISAMTableDef->pSingleTable->GetNames(NULL, 0, NULL, &rgSafeArray);
		SafeArrayLock(rgSafeArray);
		
		LONG iColumnNum = (LONG)icol;
		if ( FAILED(SafeArrayGetElement(rgSafeArray, &iColumnNum, &lpbString)) )
		{

			//To be more resilient we specify a default value
			//NULL for SQL_C_CHAR and zero for numeric values
			SWORD fErr = ISAMProvideDefaultValue(fCType, rgbValue, cbValueMax, pcbValue);

			if (fErr != NO_ISAM_ERR)
			{
				lpISAMTableDef->lpISAM->errcode = fErr;
				SafeArrayUnlock(rgSafeArray);
				SafeArrayDestroy(rgSafeArray); //SAI ADDED
				ODBCTRACE("\nWBEM ODBC Driver : ISAMGetData : Error position 2\n");
				return fErr;
			}

			SafeArrayUnlock(rgSafeArray);
			SafeArrayDestroy(rgSafeArray); //SAI ADDED
			return NO_ISAM_ERR;
		}


#ifdef TESTING
		//copy column name
		char pColumnName [MAX_COLUMN_NAME_LENGTH+1];
		pColumnName[0] = 0;
		wcstombs(pColumnName, lpbString, MAX_COLUMN_NAME_LENGTH);
		pColumnName[MAX_COLUMN_NAME_LENGTH] = 0;
#endif
	}
	else
	{
		//Get the icol from passthrough map
		PassthroughLookupTable* passthroughElement = NULL;
		WORD myIndex = (WORD)icol;
		BOOL status = lpISAMTableDef->passthroughMap->Lookup(myIndex, (void*&)passthroughElement);

		if (status)
		{
			temppbString.AddString(passthroughElement->GetColumnName(), FALSE);

			char* lpTableAlias = passthroughElement->GetTableAlias();
	
			cbTableAlias.AddString(lpTableAlias, FALSE);

			//Get the embedded object (keyed on table alias)
			VARIANT vEmbedded;
			if ( SUCCEEDED(lpISAMTableDef->lpFile->record->Get(cbTableAlias.GetString(), 0, &vEmbedded, NULL, NULL)) )
			{
				IUnknown* myUnk = vEmbedded.punkVal;

				myUnk->QueryInterface(IID_IWbemClassObject, (void**)&theRecord);

				VariantClear(&vEmbedded);
			}
			else
			{
				lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
				ODBCTRACE("\nWBEM ODBC Driver : ISAMGetData : Error position 3\n");
				return ISAM_ERROR;
			}

			//Do the same for class definition
			VARIANT vClassEmbedded;
			if ( SUCCEEDED(lpISAMTableDef->lpFile->record->Get(cbTableAlias.GetString(), 0, &vClassEmbedded, NULL, NULL)) )
			{
				IUnknown* myUnk = vClassEmbedded.punkVal;

				myUnk->QueryInterface(IID_IWbemClassObject, (void**)&theClassDefinition);

				VariantClear(&vClassEmbedded);
			}
			else
			{
				//(9) Should we release theRecord
				lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
				ODBCTRACE("\nWBEM ODBC Driver : ISAMGetData : Error position 4\n");
				return ISAM_ERROR;
			}

		}
		else
		{
			lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
			ODBCTRACE("\nWBEM ODBC Driver : ISAMGetData : Error position 5\n");
			return ISAM_ERROR;
		}
	}

	

	//Get the value of the column
	CIMTYPE wbemType = 0;
	SWORD wbemVariantType = 0;
	VARIANT vVariantVal;

	if ( FAILED(theRecord->Get(fIs__Generic ? temppbString.GetString() : lpbString, 0, &vVariantVal, &wbemType, NULL)) )	
	{
		//To be more resilient we specify a default value
		//NULL for SQL_C_CHAR and zero for numeric values
		SWORD fErr = ISAMProvideDefaultValue(fCType, rgbValue, cbValueMax, pcbValue);

		//Tidy up

		if (rgSafeArray)
		{
			SafeArrayUnlock(rgSafeArray);
			SafeArrayDestroy(rgSafeArray);
		}

		if (fErr != NO_ISAM_ERR)
		{
			//(9) Should we release theRecord and theClassDefinition 
			//if __generic ?
			lpISAMTableDef->lpISAM->errcode = fErr;

			if (!fIs__Generic)
				SysFreeString(lpbString);

			ODBCTRACE("\nWBEM ODBC Driver : ISAMGetData : Error position 6\n");
			return fErr;
		}

		//(9) Should we release theRecord and theClassDefinition 
		//if __generic ?
		if (!fIs__Generic)
			SysFreeString(lpbString);

		return NO_ISAM_ERR;
	}

	//New
	//Get attributes for chosen column
	IWbemQualifierSetPtr pQualifierSet = NULL;

	if ( S_OK != (theClassDefinition->GetPropertyQualifierSet(fIs__Generic ? temppbString.GetString() : lpbString, &pQualifierSet)) )
	{
		pQualifierSet = NULL;
	}


	//Tidy up
	if (rgSafeArray)
	{
		SafeArrayUnlock(rgSafeArray);
		SafeArrayDestroy(rgSafeArray);
	}

	//Get CIMTYPE String
	VARIANT pVal2;
	BSTR syntaxStr = NULL;
	BOOL fClearpVal2 = FALSE;

	if (pQualifierSet)
	{
		BSTR cimtypeBSTR = SysAllocString(WBEMDR32_L_CIMTYPE);
		SCODE result = pQualifierSet->Get(cimtypeBSTR, 0, &pVal2, 0);
		SysFreeString(cimtypeBSTR);

		if ( S_OK == result )
		{
			if (pVal2.bstrVal)
				syntaxStr = pVal2.bstrVal;

			fClearpVal2 = TRUE;
		}
	}

	//Get MAXLEN Value
	VARIANT pVal3;
	SDWORD maxLenVal = 0;

	if (pQualifierSet)
	{
		BSTR maxBSTR = SysAllocString(WBEMDR32_L_MAX);
		SCODE result = pQualifierSet->Get(maxBSTR, 0, &pVal3, 0);
		SysFreeString(maxBSTR);

		if ( S_OK == result )
		{
			maxLenVal = pVal3.iVal;
			VariantClear(&pVal3);
		}
	}

	//Get value from variant
	ISAMGetWbemVariantType(wbemType, wbemVariantType);

	//get the index for this column
	long index = -1;
	_bstr_t theTableAlias = cbTableAlias.GetString();
	_bstr_t theColumnName = fIs__Generic ? temppbString.GetString() : lpbString;
	

	if (lpISAMTableDef->virtualInstances)
	{
		long theInstance = lpISAMTableDef->virtualInstances->currentInstance;

		//Remove previous virtual instance map (if there was one)
		delete (lpISAMTableDef->virtualInstances);
		lpISAMTableDef->virtualInstances = new VirtualInstanceManager();
		lpISAMTableDef->virtualInstances->Load(lpISAMTableDef->passthroughMap, lpISAMTableDef->lpFile->record);

		//Restore current instance
		lpISAMTableDef->virtualInstances->currentInstance = theInstance;
		index = lpISAMTableDef->virtualInstances->GetArrayIndex(theTableAlias, theColumnName, theInstance);
	}

	if (!fIs__Generic)
		SysFreeString(lpbString);


	SWORD err = ISAMGetValueFromVariant(vVariantVal, fCType, 
							  rgbValue, cbValueMax, pcbValue, wbemVariantType, syntaxStr, maxLenVal, index);


	if (fClearpVal2)
		VariantClear(&pVal2);

	if (err != NO_ISAM_ERR)
	{
		lpISAMTableDef->lpISAM->errcode = err;
		ODBCTRACE("\nWBEM ODBC Driver : ISAMGetData : Error position 7\n");
        return err;
	}

	VariantClear(&vVariantVal);
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
	return NO_ISAM_ERR; 
}

/***************************************************************************/
SWORD INTFUNC ISAMPutData(LPISAMTABLEDEF    lpISAMTableDef,
                          UWORD             icol,
                          SWORD             fCType, 
                          PTR               rgbValue, 
                          SDWORD            cbValue)
{
    /* Not allowed for the passthrough table */
    lpISAMTableDef->lpISAM->errcode = NO_ISAM_ERR;
    if (lpISAMTableDef->lpFile == NULL) {
        lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
        return ISAM_ERROR;
    }

    /* Null? */
    if (cbValue == SQL_NULL_DATA) {

        /* Yes.  Set value to NULL */
        if (dBaseSetColumnNull(lpISAMTableDef->lpFile, (UWORD) (icol+1)) !=
                                        DBASE_ERR_SUCCESS) {
            lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
            return ISAM_ERROR;
        }
    }
    else {
        /* No.  Set the value */
         switch (fCType) {
        case SQL_C_DOUBLE:
            {
                UCHAR string[20];
                if (DoubleToChar(*((double far *)rgbValue), TRUE, (LPUSTR)string,
                                  sizeof(string)))
                    string[sizeof(string)-1] = '\0';
                if (dBaseSetColumnCharVal(lpISAMTableDef->lpFile, (UWORD) (icol+1),
                              string, lstrlen((char*)string)) != DBASE_ERR_SUCCESS) {
                    lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
                    return ISAM_ERROR;
                }
            }
            break;
        case SQL_C_CHAR:
            if (cbValue == SQL_NTS)
                cbValue = lstrlen((char*)rgbValue);
            if (dBaseSetColumnCharVal(lpISAMTableDef->lpFile, (UWORD) (icol+1),
                                  (UCHAR FAR*)rgbValue, cbValue) != DBASE_ERR_SUCCESS) {
                lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
                return ISAM_ERROR;
            }
            break;
        case SQL_C_DATE:
            {
                UCHAR string[11];

                DateToChar((DATE_STRUCT far *) rgbValue, (LPUSTR)string);
                if (dBaseSetColumnCharVal(lpISAMTableDef->lpFile, (UWORD) (icol+1),
                              string, lstrlen((char*)string)) != DBASE_ERR_SUCCESS) {
                    lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
                    return ISAM_ERROR;
                }
            }
            break;
        default:
            lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
            return ISAM_ERROR;
        }
    }
    return NO_ISAM_ERR;
}

/***************************************************************************/
SWORD INTFUNC ISAMInsertRecord(LPISAMTABLEDEF lpISAMTableDef)
{
    lpISAMTableDef->lpISAM->errcode = NO_ISAM_ERR;
    if (lpISAMTableDef->lpFile == NULL) {
        lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
        return ISAM_ERROR;
    }

    if (dBaseAddRecord(lpISAMTableDef->lpFile) != DBASE_ERR_SUCCESS) {
        lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
        return ISAM_ERROR;
    }

    return NO_ISAM_ERR;
}
/***************************************************************************/
SWORD INTFUNC ISAMUpdateRecord(LPISAMTABLEDEF lpISAMTableDef)
{
    lpISAMTableDef->lpISAM->errcode = NO_ISAM_ERR;
    if (lpISAMTableDef->lpFile == NULL) {
        lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
        return ISAM_ERROR;
    }

    return NO_ISAM_ERR;
}
/***************************************************************************/
SWORD INTFUNC ISAMDeleteRecord(LPISAMTABLEDEF lpISAMTableDef)
{
    lpISAMTableDef->lpISAM->errcode = NO_ISAM_ERR;
    if (lpISAMTableDef->lpFile == NULL) {
        lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
        return ISAM_ERROR;
    }

    if (dBaseDeleteRecord(lpISAMTableDef->lpFile) != DBASE_ERR_SUCCESS) {
        lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
        return ISAM_ERROR;
    }

    return NO_ISAM_ERR;
}
/***************************************************************************/

SWORD INTFUNC ISAMGetBookmark(LPISAMTABLEDEF lpISAMTableDef,
                              LPISAMBOOKMARK lpISAMBookmark)
{
    lpISAMTableDef->lpISAM->errcode = NO_ISAM_ERR;
    if (lpISAMTableDef->lpFile != NULL) 
	{
		lpISAMBookmark->currentRecord = lpISAMTableDef->lpFile->currentRecord;
    }
    else 
	{
        lpISAMBookmark->currentRecord = lpISAMTableDef->iRecord;
    }

	if (lpISAMTableDef->virtualInstances)
	{
		lpISAMBookmark->currentInstance = lpISAMTableDef->virtualInstances->currentInstance;
	}

    return NO_ISAM_ERR;
}

/***************************************************************************/

SWORD INTFUNC ISAMPosition(LPISAMTABLEDEF lpISAMTableDef,
                           LPISAMBOOKMARK ISAMBookmark)
{
    lpISAMTableDef->lpISAM->errcode = NO_ISAM_ERR;

	if ( lpISAMTableDef->lpFile && lpISAMTableDef->lpFile->tempEnum->IsValid()) 
	{
		BOOL fStatus = lpISAMTableDef->lpFile->pAllRecords->Lookup
								( (WORD)(ISAMBookmark->currentRecord - 1), (void* &)lpISAMTableDef->lpFile->record);
		
		if (fStatus && lpISAMTableDef->lpFile->record)
		{
			//Update bookmark to next entry
			lpISAMTableDef->lpFile->currentRecord = ISAMBookmark->currentRecord;// + 1;
		}
		else
		{
			lpISAMTableDef->lpISAM->errcode = ISAM_ERROR;
			return ISAM_ERROR;
		}
	}
	else 
	{
        lpISAMTableDef->iRecord = (SDWORD) ISAMBookmark->currentRecord;
    }

	if (lpISAMTableDef->virtualInstances)
	{
		lpISAMTableDef->virtualInstances->currentInstance = ISAMBookmark->currentInstance;
	}

    return NO_ISAM_ERR;
}

/***************************************************************************/

/* Closes a specific table and deallocates the table definition */

SWORD INTFUNC ISAMCloseTable(LPISAMTABLEDEF lpISAMTableDef)
{
	//Check if lpISAMTableDef exists
	if (! lpISAMTableDef)
		return NO_ISAM_ERR;

    /* Close the dBASE file */
    lpISAMTableDef->lpISAM->errcode = NO_ISAM_ERR;
    if (lpISAMTableDef->lpFile != NULL) 
	{
		//Release interface pointers if applicable

		//Empty out all instances
		if (lpISAMTableDef->lpFile->pAllRecords)
		{
			for(POSITION pos = lpISAMTableDef->lpFile->pAllRecords->GetStartPosition(); pos != NULL; )
			{
				WORD key = 0;
				IWbemClassObject* pa = NULL;
				lpISAMTableDef->lpFile->pAllRecords->GetNextAssoc( pos, key, (void*&)pa );

				if (pa)
				{
					pa->Release();
				}
			}
			delete (lpISAMTableDef->lpFile->pAllRecords);
			lpISAMTableDef->lpFile->pAllRecords = NULL;
		}

		

		if (lpISAMTableDef->lpFile->tempEnum)
		{
			delete (lpISAMTableDef->lpFile->tempEnum);
			lpISAMTableDef->lpFile->tempEnum = NULL;
		}
		
    }

	if (lpISAMTableDef->pBStrTableName)
	{
		delete (lpISAMTableDef->pBStrTableName);
		lpISAMTableDef->pBStrTableName = NULL;
	}

	if (lpISAMTableDef->pSingleTable)
	{
		lpISAMTableDef->pSingleTable->Release();
		lpISAMTableDef->pSingleTable = NULL;
	}

	TidyupPassthroughMap(lpISAMTableDef->passthroughMap);
	lpISAMTableDef->passthroughMap = NULL;

	if (lpISAMTableDef->pGateway2)
	{
		delete lpISAMTableDef->pGateway2;
		lpISAMTableDef->pGateway2 = NULL;
	}

	if (lpISAMTableDef->pColumnInfo)
	{
		delete (lpISAMTableDef->pColumnInfo);
		lpISAMTableDef->pColumnInfo = NULL;
	}

	if (lpISAMTableDef->pContext)
	{
		lpISAMTableDef->pContext->Release();
		lpISAMTableDef->pContext = NULL;
	}

	if (lpISAMTableDef->lpFile)
	{
		GlobalUnlock(GlobalPtrHandle(lpISAMTableDef->lpFile));
		GlobalFree(GlobalPtrHandle(lpISAMTableDef->lpFile));
		lpISAMTableDef->lpFile = NULL;
	}

	delete lpISAMTableDef->virtualInstances;
	lpISAMTableDef->virtualInstances = NULL;

    GlobalUnlock(GlobalPtrHandle(lpISAMTableDef));
    GlobalFree(GlobalPtrHandle(lpISAMTableDef));
	lpISAMTableDef = NULL;
    return NO_ISAM_ERR;
}

/***************************************************************************/
SWORD INTFUNC ISAMDeleteTable(LPISAM lpISAM, LPUSTR lpszTableName)
{
	return ISAM_NOTSUPPORTED;
/*
    UCHAR    szFilename[MAX_DATABASE_NAME_LENGTH+MAX_TABLE_NAME_LENGTH+6];

    // Create the filename 
    lpISAM->errcode = NO_ISAM_ERR;
    lstrcpy((char*)szFilename, (char*)lpISAM->szDatabase);
    lstrcat((char*)szFilename, "\\");
    lstrcat((char*)szFilename, lpszTableName);
    lstrcat((char*)szFilename, ".DBF");

    // Delete the file
    dBaseDestroy((char*)szFilename);

    return NO_ISAM_ERR;
*/
}
/***************************************************************************/

// Checked for SetInterfaceSecurityEx on IWbemServices and IEnumWbemClassObject

SWORD INTFUNC ISAMPrepare(LPISAM lpISAM, UCHAR FAR *szSqlStr, SDWORD cbSqlStr,
                          LPISAMSTATEMENT FAR *lplpISAMStatement,
                          LPUSTR lpszTablename, UWORD FAR *lpParameterCount
#ifdef IMPLTMT_PASSTHROUGH
						  , LPSTMT lpstmt
#endif
						  )
{

	ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare\n"));

	//For now disable Passthrough SQL
//	lpISAM->errcode = ISAM_NOTSUPPORTED;
//	return ISAM_NOTSUPPORTED;
/*
	//Test
	CBString s1;
	CBString s2;
	CBString s3;
	CBString s4;
	CBString s5;

	s1.AddString("", FALSE);
	s2.AddString(NULL, FALSE);
	s3.AddString("\\\\.", FALSE);
	s4.AddString("\\\\SaiWong4", FALSE);
	s5.AddString("\\\\SaiWong2", FALSE);

	CServerLocationCheck one(s1);
	CServerLocationCheck two(s2);
	CServerLocationCheck three(s3);
	CServerLocationCheck four(s4);
	CServerLocationCheck five(s5);
*/

    HGLOBAL h;
    LPISAMSTATEMENT lpISAMStatement;

    lpISAM->errcode = NO_ISAM_ERR;
    h = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (ISAMSTATEMENT));
    if (h == NULL || (lpISAMStatement = (LPISAMSTATEMENT) GlobalLock (h)) == NULL) {
        
        if (h)
            GlobalFree(h);

        lpISAM->errcode = ISAM_ERROR;
        return ISAM_ERROR;
    }

	ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 1\n"));

	//Initialize passthrough parameters
	lpISAMStatement->pProv = NULL;
	lpISAMStatement->currentRecord = 0;
	lpISAMStatement->tempEnum = new CSafeIEnumWbemClassObject();

	lpISAMStatement->firstPassthrInst = NULL;
	lpISAMStatement->classDef = NULL;
	lpISAMStatement->tempEnum2 = new CSafeIEnumWbemClassObject();

    if ((cbSqlStr == 15) && (!_fmemicmp(szSqlStr, "MessageBox(?,?)", 15))) {
        s_lstrcpy(lpszTablename, "");
        *lpParameterCount = 2;
        lpISAMStatement->lpISAM = lpISAM;
        lpISAMStatement->resultSet = FALSE;
        lpISAMStatement->lpszParam1 = NULL;
        lpISAMStatement->cbParam1 = SQL_NULL_DATA;
        lpISAMStatement->lpszParam2 = NULL;
        lpISAMStatement->cbParam2 = SQL_NULL_DATA;
    }
#ifdef IMPLTMT_PASSTHROUGH
	else if (TRUE)
	{
		//Try passthrough
		*lpParameterCount = 0;
        lpISAMStatement->lpISAM = lpISAM;
        lpISAMStatement->resultSet = TRUE;
        lpISAMStatement->lpszParam1 = NULL;
        lpISAMStatement->cbParam1 = SQL_NULL_DATA;
        lpISAMStatement->lpszParam2 = NULL;
        lpISAMStatement->cbParam2 = SQL_NULL_DATA;

		ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 2\n"));

		/* No.  Create a PASSTHROUGH parse tree */	
        SCODE sc = Parse(lpstmt, lpISAM, (LPUSTR) szSqlStr,
                                cbSqlStr, &(lpstmt->lpSqlStmt));

		ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 3\n"));

        if (sc != SQL_SUCCESS) {

			FreeTree(lpstmt->lpSqlStmt);
			lpstmt->lpSqlStmt = NULL;


			delete lpISAMStatement->tempEnum;
			delete lpISAMStatement->tempEnum2;

            GlobalUnlock(h);
			GlobalFree(h);
			lpISAM->errcode = ISAM_NOTSUPPORTED;
			return ISAM_NOTSUPPORTED;
        }

		//Need to do a semantic check so that any
		//Table.* will get expanded
		sc = SemanticCheck(lpstmt, &(lpstmt->lpSqlStmt),
              ROOT_SQLNODE, FALSE, ISAMCaseSensitive(lpstmt->lpdbc->lpISAM),
              NO_SQLNODE, NO_SQLNODE);

		if (sc != SQL_SUCCESS) {

			FreeTree(lpstmt->lpSqlStmt);
			lpstmt->lpSqlStmt = NULL;

			delete lpISAMStatement->tempEnum;
			delete lpISAMStatement->tempEnum2;

            GlobalUnlock(h);
			GlobalFree(h);
			lpISAM->errcode = ISAM_NOTSUPPORTED;
			return ISAM_NOTSUPPORTED;
        }

		ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 3b\n"));

		//Generate WQL statement using parse tree
		LPSQLNODE lpRootNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
		LPSQLNODE lpSqlNode2 = ToNode(lpstmt->lpSqlStmt, lpRootNode->node.root.sql);

		char* fullWQL = NULL;

		BOOL fHasAggregateFunctions = FALSE;

		TableColumnInfo selectInfo (&lpRootNode, &lpSqlNode2, WQL_MULTI_TABLE);
		CMapWordToPtr* passthroughMap;
		selectInfo.BuildFullWQL(&fullWQL, &passthroughMap);

		ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 3c\n"));

		//Extra check for aggregate functions what WQL does not support
		//so we must fail SQL passthrough
		if ( selectInfo.HasAggregateFunctions() )
		{
			fHasAggregateFunctions = TRUE;
		}

		//At this point we can check for 'SELECT * FROM .....'
		//If this is so we need to work out the full column list 
		//and re-parse and try again (only for single tables)
		if ( selectInfo.IsSelectStar() && selectInfo.IsZeroOrOneList() )
		{
			//get new query string
			char* lpWQLStr = NULL;
			char* lpWQLSelectStarList = NULL;
			BOOL  fIsThisDistinct = selectInfo.IsDistinct();

			ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 4\n"));

			ISAMGetSelectStarList(&lpWQLSelectStarList, &selectInfo, lpISAM);

			ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 5\n"));

			//clean up parse tree
			FreeTree(lpstmt->lpSqlStmt);
			lpstmt->lpSqlStmt = NULL;

			//clean up passthrough map
			TidyupPassthroughMap(passthroughMap);
			passthroughMap = NULL;

			ISAMStringConcat(&lpWQLStr, "SELECT ");

			//Add tail end of previous string
			char* oldString = fullWQL;
			oldString += 7; //skip over SELECT
			
			if ( fIsThisDistinct )
			{
				ISAMStringConcat(&lpWQLStr, "distinct ");
				oldString += 9;	//skip over DISTINCT
			}

			if (lpWQLSelectStarList)
			{
				ISAMStringConcat(&lpWQLStr, lpWQLSelectStarList);
			}

			ISAMStringConcat(&lpWQLStr, oldString);

			ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 6\n"));

			CString sMessage;
			sMessage.Format("\nWBEM ODBC Driver : detected select * : reparsing query :\n%s\n", lpWQLStr);
			ODBCTRACE(sMessage);

			// No.  Create a PASSTHROUGH parse tree 	
			sc = Parse(lpstmt, lpISAM, (LPUSTR) lpWQLStr,
									lstrlen(lpWQLStr), &(lpstmt->lpSqlStmt));

			ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 7\n"));

			if (lpWQLStr)
				delete lpWQLStr;

			if (sc != SQL_SUCCESS) {

				FreeTree(lpstmt->lpSqlStmt);
				lpstmt->lpSqlStmt = NULL;


				delete lpISAMStatement->tempEnum;
				delete lpISAMStatement->tempEnum2;

				GlobalUnlock(h);
				GlobalFree(h);
				lpISAM->errcode = ISAM_NOTSUPPORTED;
				return ISAM_NOTSUPPORTED;
			}

			//Generate WQL statement using parse tree
			lpRootNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
			lpSqlNode2 = ToNode(lpstmt->lpSqlStmt, lpRootNode->node.root.sql);


			ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 8\n"));

			delete fullWQL;
			fullWQL = NULL;
			TableColumnInfo selectInfo2 (&lpRootNode, &lpSqlNode2, WQL_MULTI_TABLE);
			selectInfo2.BuildFullWQL(&fullWQL, &passthroughMap);

			ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 9\n"));

			//Extra check for aggregate functions what WQL does not support
			//so we must fail SQL passthrough
			if ( selectInfo2.HasAggregateFunctions() )
			{
				fHasAggregateFunctions = TRUE;
			}

		}

		_bstr_t sqltextBSTR = fullWQL;
		delete fullWQL;

		CString wqlTextDebug(_T("\nWBEM ODBC Driver : WQL query : "));
		wqlTextDebug += (LPCTSTR)sqltextBSTR;
		wqlTextDebug += _T("\n");

		ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 7b\n"));


		//Get instances by executing query
		sc = WBEM_E_FAILED;

		char* lpTblQualifier = NULL;
		
//		if (idxQual != NO_STRING)
//		{
//			lpTblQualifier = (LPSTR) ToString(lpRootNode, idxQual);
//		}
//		else
		{
			lpTblQualifier = lpstmt->lpdbc->lpISAM->szDatabase;
		}

		ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 7c\n"));

		lpISAMStatement->pProv = new CSafeWbemServices();


		lpISAMStatement->pProv->SetInterfacePtr(lpstmt->lpdbc->lpISAM, (LPUSTR) lpTblQualifier, (SWORD) lstrlen(lpTblQualifier));

		ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 7d\n"));

		lpISAMStatement->passthroughMap = passthroughMap;

		//Get prototype 'class' definition
		if (lpISAMStatement->pProv->IsValid())
		{

			ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 10\n"));

			sc = lpISAMStatement->tempEnum2->SetInterfacePtr(lpstmt->lpdbc->lpISAM, WMI_PROTOTYPE, sqltextBSTR, lpISAMStatement->pProv);


			ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 11\n"));

			//Extra check for aggregate functions what WQL does not support
			//so we must fail SQL passthrough
			if ( fHasAggregateFunctions )
			{
				sc = WBEM_E_NOT_SUPPORTED;
			}
		}
		else
		{
			sc = WBEM_E_NOT_SUPPORTED;
			ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 7e\n"));
		}

		if ( (sc == WBEM_E_NOT_SUPPORTED) || (sc == WBEM_E_FAILED) || (sc == WBEM_E_INVALID_QUERY) || (sc == WBEM_E_NOT_FOUND) || (sc == WBEM_E_ACCESS_DENIED) )
		{

			if ( fHasAggregateFunctions )
			{
				ODBCTRACE(_T("\nWBEM ODBC Driver : Failing SQL passthrough as original SQL query has aggregate functions which WQL does not support\n"));
			}
			else
			{
				ODBCTRACE(_T("\nWBEM ODBC Driver : Getting prototype failed\n"));
			}

			//ExecQuery failed
			delete lpISAMStatement->pProv;
			lpISAMStatement->pProv = NULL;

			TidyupPassthroughMap(lpISAMStatement->passthroughMap);
			lpISAMStatement->passthroughMap = NULL;

			FreeTree(lpstmt->lpSqlStmt);
			lpstmt->lpSqlStmt = NULL;

			ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 12\n"));

			delete lpISAMStatement->tempEnum;
			delete lpISAMStatement->tempEnum2;

			GlobalUnlock(h);
			GlobalFree(h);
			lpISAM->errcode = ISAM_NOTSUPPORTED;
			return ISAM_NOTSUPPORTED;
		}


		ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 12\n"));

		IWbemServicesPtr myServicesPtr = NULL;
		ISAMGetIWbemServices(lpISAM, *(lpISAMStatement->pProv), myServicesPtr);

		IEnumWbemClassObjectPtr myIEnumWbemClassObject = NULL;
		lpISAMStatement->tempEnum2->GetInterfacePtr(myIEnumWbemClassObject);

//		CBString myServerStr;
//		myServerStr.AddString( (LPSTR)lpISAM->szServer, FALSE );
//		CServerLocationCheck myCheck (myServerStr);
		BOOL fIsLocalConnection = lpISAM->fIsLocalConnection;//myCheck.IsLocal();

		ISAMSetCloaking2(myIEnumWbemClassObject, 
                        fIsLocalConnection, 
                        lpISAM->fW2KOrMore, 
                        lpISAM->dwAuthLevel, 
						lpISAM->dwImpLevel,
						lpISAM->gpAuthIdentity);
/*
		if ( fIsLocalConnection && IsW2KOrMore() )
		{
			WbemSetDynamicCloaking(myIEnumWbemClassObject, lpISAM->dwAuthLevel, lpISAM->dwImpLevel);
		}
		else
		{
			SetInterfaceSecurityEx(myIEnumWbemClassObject, 
							lpISAM->gpAuthIdentity, 
							gpPrincipal,
							lpISAM->dwAuthLevel, 
							lpISAM->dwImpLevel);
		}
*/
		ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 13\n"));

		//There should be only 1 instance which is the class definition
		ULONG puReturned = 0;
		
		ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 14\n"));

		myIEnumWbemClassObject->Reset();

		if (myIEnumWbemClassObject->Next(-1, 1, &(lpISAMStatement->classDef), &puReturned) != S_OK)
		{

			ODBCTRACE(_T("\nWBEM ODBC Driver : Getting Prototype instance failed\n"));

			delete lpISAMStatement->pProv;
			lpISAMStatement->pProv = NULL;

			TidyupPassthroughMap(lpISAMStatement->passthroughMap);
			lpISAMStatement->passthroughMap = NULL;

			FreeTree(lpstmt->lpSqlStmt);
			lpstmt->lpSqlStmt = NULL;


			delete lpISAMStatement->tempEnum;
			delete lpISAMStatement->tempEnum2;

			GlobalUnlock(h);
			GlobalFree(h);
			lpISAM->errcode = ISAM_NOTSUPPORTED;
			return ISAM_NOTSUPPORTED;
		}

		//Now execute the real query
		if (lpISAMStatement->pProv->IsValid())
		{
			sc = lpISAMStatement->tempEnum->SetInterfacePtr(lpISAM, WMI_EXEC_FWD_ONLY, sqltextBSTR, lpISAMStatement->pProv);

			ODBCTRACE(_T("\nWBEM ODBC Driver :ISAMPrepare : Pos 15\n"));

			//As semi-synchronous does not indicate if any error occurs
			//we need to get the first record back now
			if ( SUCCEEDED(sc) )
			{
				
				IEnumWbemClassObjectPtr myIEnumWbemClassObj1 = NULL;
				lpISAMStatement->tempEnum->GetInterfacePtr(myIEnumWbemClassObj1);

				ISAMSetCloaking2(myIEnumWbemClassObj1, 
								fIsLocalConnection, 
								lpISAM->fW2KOrMore, 
								lpISAM->dwAuthLevel, 
								lpISAM->dwImpLevel,
								lpISAM->gpAuthIdentity);

/*				
				if ( fIsLocalConnection && IsW2KOrMore() )
				{
					WbemSetDynamicCloaking(myIEnumWbemClassObj1, lpISAM->dwAuthLevel, lpISAM->dwImpLevel);
				}
				else
				{
					SetInterfaceSecurityEx(myIEnumWbemClassObj1, 
    					lpISAM->gpAuthIdentity, 
	    				gpPrincipal,
		    			lpISAM->dwAuthLevel, 
			    		lpISAM->dwImpLevel);
				}
*/
				ULONG numReturned = 0;
				sc = myIEnumWbemClassObj1->Next(-1, 1, &(lpISAMStatement->firstPassthrInst), &numReturned);
			}
		}
		else
		{
			sc = WBEM_E_NOT_SUPPORTED;
		}

		CString sSCODE;
		sSCODE.Format("\nMAGIC NUMBER = 0x%X\n", sc);
		ODBCTRACE(sSCODE);

		if ( sc != WBEM_S_NO_ERROR )
		{

			ODBCTRACE(_T("\nWBEM ODBC Driver : Passthrough SQL Failed or Not Supported\n"));

			//ExecQuery failed
			lpISAM->errcode = ERR_PASSTGHONLY_NOTSUPP;

			//default error string
			((char*)lpstmt->szISAMError)[0] = 0;
			CString sDefaultError;
			sDefaultError.LoadString(STR_EXECQUERY);
			sprintf((char*)lpstmt->szError, "%s 0x%X", sDefaultError, sc);
			lpISAM->errcode = ERR_WBEM_SPECIFIC;

			//Test here
			//need to get the WBEM specific error
			IErrorInfo* pEI = NULL;
			IWbemClassObject *pErrorObject = NULL;
			if(GetErrorInfo(0, &pEI) == S_OK) 
			{
				pEI->QueryInterface(IID_IWbemClassObject, (void**)&pErrorObject);
				pEI->Release();
			}

			if (pErrorObject)
			{
				VARIANT varString;

				if (pErrorObject->InheritsFrom(L"__NotifyStatus") != WBEM_NO_ERROR) 
				{
//					fprintf(stdout, "Unrecognized Error Object type\n");
				} 
				else if (pErrorObject->InheritsFrom(L"__ExtendedStatus") == WBEM_NO_ERROR) 
				{
					sc = pErrorObject->Get(L"Description", 0L, &varString, NULL, NULL);
					if ( (sc == S_OK) && (varString.vt == VT_BSTR) ) 
					{
						lstrcpy((char*)lpstmt->szISAMError, "");
						wcstombs((char*)lpstmt->szError,varString.bstrVal ? varString.bstrVal : L" ", MAX_ERROR_LENGTH);

						lpISAM->errcode = ERR_WBEM_SPECIFIC;

						VariantClear(&varString);
					}
				}
				pErrorObject->Release();
			}

			delete lpISAMStatement->pProv;
			lpISAMStatement->pProv = NULL;

			lpISAMStatement->classDef->Release();


			TidyupPassthroughMap(lpISAMStatement->passthroughMap);
			lpISAMStatement->passthroughMap = NULL;

			SWORD savedErrorCode = lpISAM->errcode;

			FreeTree(lpstmt->lpSqlStmt);
			lpstmt->lpSqlStmt = NULL;

			delete lpISAMStatement->tempEnum;
			delete lpISAMStatement->tempEnum2;

            GlobalUnlock(h);
			GlobalFree(h);

			lpISAM->errcode = savedErrorCode;

			

			return ISAM_NOTSUPPORTED;
		}

		//ExecQuery succeeded
		myServicesPtr = NULL;
		ISAMGetIWbemServices(lpISAM, *(lpISAMStatement->pProv), myServicesPtr);

		//free up enumeration before resetting to NULL
		IEnumWbemClassObject* tempEnum = myIEnumWbemClassObject.Detach();

		if (tempEnum)
			tempEnum->Release();

		myIEnumWbemClassObject = NULL;
		lpISAMStatement->tempEnum->GetInterfacePtr(myIEnumWbemClassObject);


		ISAMSetCloaking2(myIEnumWbemClassObject, 
						fIsLocalConnection, 
						lpISAM->fW2KOrMore, 
						lpISAM->dwAuthLevel, 
						lpISAM->dwImpLevel,
						lpISAM->gpAuthIdentity);

/*		
		if ( fIsLocalConnection && IsW2KOrMore() )
		{
			WbemSetDynamicCloaking(myIEnumWbemClassObject, lpISAM->dwAuthLevel, lpISAM->dwImpLevel);
		}
		else
		{
			SetInterfaceSecurityEx(myIEnumWbemClassObject, 
						lpISAM->gpAuthIdentity, 
						gpPrincipal,
						lpISAM->dwAuthLevel, 
						lpISAM->dwImpLevel);
		}
*/	
		ODBCTRACE(_T("\nWBEM ODBC Driver : Passthrough SQL succeeded, getting instances\n"));

		//Copy table name
		lpszTablename[0] = 0;
		wchar_t* virTbl = WBEMDR32_VIRTUAL_TABLE;
		wcstombs((char*)lpszTablename, virTbl, MAX_TABLE_NAME_LENGTH);
		lpszTablename[MAX_TABLE_NAME_LENGTH] = 0;

		//Free the Parse tree.
		//A new Parse tree will be created for
		//SELECT * FROM WBEMDR32VirtualTable
		FreeTree(lpstmt->lpSqlStmt);
		lpstmt->lpSqlStmt = NULL;
	}
#else

    else if ((cbSqlStr == 3) && (!_fmemicmp(szSqlStr, "SQL", 3))) {
        s_lstrcpy(lpszTablename, "SQL");
        *lpParameterCount = 0;
        lpISAMStatement->lpISAM = lpISAM;
        lpISAMStatement->resultSet = TRUE;
        lpISAMStatement->lpszParam1 = NULL;
        lpISAMStatement->cbParam1 = SQL_NULL_DATA;
        lpISAMStatement->lpszParam2 = NULL;
        lpISAMStatement->cbParam2 = SQL_NULL_DATA;
    }
    else {


		test if we reach here


		delete lpISAMStatement->tempEnum;
		delete lpISAMStatement->tempEnum2;

        GlobalUnlock(h);
        GlobalFree(h);
        lpISAM->errcode = ISAM_NOTSUPPORTED;
        return ISAM_NOTSUPPORTED;
    }
#endif

	
    *lplpISAMStatement = lpISAMStatement;
    return NO_ISAM_ERR;
}

// Checked for SetInterfaceSecurityEx on IWbemServices

void INTFUNC ISAMGetSelectStarList(char** lpWQLSelectStarList, TableColumnInfo* pSelectInfo, LPISAM lpISAM)
{
	//First check you have one table in the select list
	char* mytable = NULL;
	BOOL fDummyValue = FALSE;
	pSelectInfo->BuildTableList(&mytable, fDummyValue);

	if ( mytable && lstrlen (mytable) )
	{
		//got the table, now fetch the column names
		CBString	pBStrTableName;
		pBStrTableName.AddString((LPSTR)mytable, FALSE);

		IWbemContext* pContext = ISAMCreateLocaleIDContextObject(lpISAM->m_Locale);

		//Get class object based on table name
		IWbemClassObjectPtr pSingleTable = NULL;
		IWbemServicesPtr    pGateway     = NULL;
		ISAMGetGatewayServer(pGateway, lpISAM, (LPUSTR)lpISAM->szDatabase, (SWORD) lstrlen(lpISAM->szDatabase));

		if ( FAILED(pGateway->GetObject(pBStrTableName.GetString(), 0, pContext, &pSingleTable, NULL)))
		{
			if (pContext)
				pContext->Release();

			if (mytable)
				delete mytable;

			return;
		}

		if (pContext)
				pContext->Release();

		//Get the names of all the properties/columns
		SAFEARRAY FAR* rgSafeArray = NULL;

		SCODE scT = pSingleTable->GetNames ( NULL, 0, NULL, &rgSafeArray );

		//Work out number of properties/columns
		LONG iLBound = 0;
		LONG iUBound = 0;
		SafeArrayGetLBound(rgSafeArray, 1, &iLBound );
		SafeArrayGetUBound(rgSafeArray, 1, &iUBound );

		//Loop through column names
		char pColumnName [MAX_COLUMN_NAME_LENGTH+1];
		BOOL fFirstTime = TRUE;
		for (LONG loop = iLBound; loop <= iUBound; loop++)
		{
			BSTR lpbString;
			if ( FAILED(SafeArrayGetElement(rgSafeArray, &loop, &lpbString)) )
			{
				if (mytable)
					delete mytable;

				SafeArrayUnlock(rgSafeArray); //SAI ADDED
				SafeArrayDestroy(rgSafeArray);//SAI ADDED

				//(11) Should we also release pSingleTable
				return;
			}

			//copy column name
			pColumnName[0] = 0;
			wcstombs(pColumnName, lpbString, MAX_COLUMN_NAME_LENGTH);
			pColumnName[MAX_COLUMN_NAME_LENGTH] = 0;

			//filters - check for system properties
			BOOL fAddToList = TRUE;

			if (! lpISAM->fSysProps && !_strnicmp("__", pColumnName, 2))
			{
				fAddToList = FALSE;
			}

			//filters - check for lazy properties
			if (fAddToList)
			{
				BOOL fIsLazyProperty = FALSE;

				//Now get the qualifiers (if available)
				IWbemQualifierSet* pQualifierSet = NULL;
				if ( S_OK == (pSingleTable->GetPropertyQualifierSet
													(lpbString, &pQualifierSet)) )
				{
					//Get the lazy qualifer (if applicable)
					VARIANT pValLazy;
					BSTR lazyStr = SysAllocString(WBEMDR32_L_LAZY);
					if ( S_OK == (pQualifierSet->Get(lazyStr, 0, &pValLazy, NULL)) )
					{
						fAddToList = FALSE;
						VariantClear(&pValLazy);
					}

					SysFreeString(lazyStr);
				
					//Tidy up
					if (pQualifierSet)
						pQualifierSet->Release();
				}
			}

			//add to select list
			if (fAddToList)
			{
				if (!fFirstTime)
				{
					ISAMStringConcat(lpWQLSelectStarList, ", ");
				}

				ISAMStringConcat(lpWQLSelectStarList, pColumnName);

				fFirstTime = FALSE;
			}

			SysFreeString(lpbString);
		}
	}
}


/***************************************************************************/
SWORD INTFUNC ISAMParameter(LPISAMSTATEMENT lpISAMStatement, UWORD ipar,
                            SWORD fCType, PTR rgbValue, SDWORD cbValue)
{
    lpISAMStatement->lpISAM->errcode = NO_ISAM_ERR;
    if (fCType != SQL_C_CHAR) {
        lpISAMStatement->lpISAM->errcode = ISAM_ERROR;
        return ISAM_ERROR;
    }
    if (cbValue > MAX_CHAR_LITERAL_LENGTH) {
        lpISAMStatement->lpISAM->errcode = ISAM_ERROR;
        return ISAM_ERROR;
    }
    if (cbValue == SQL_NULL_DATA)
        cbValue = 0;
    if (ipar == 1) {
        lpISAMStatement->lpszParam1 = (LPSTR)rgbValue;
        lpISAMStatement->cbParam1 = cbValue;
    }
    else if (ipar == 2) {
        lpISAMStatement->lpszParam2 = (LPSTR)rgbValue;
        lpISAMStatement->cbParam2 = cbValue;
    }
    else {
        lpISAMStatement->lpISAM->errcode = ISAM_ERROR;
        return ISAM_ERROR;
    }
    return NO_ISAM_ERR;
}
/***************************************************************************/
SWORD INTFUNC ISAMExecute(LPISAMSTATEMENT lpISAMStatement,
                          SDWORD FAR *lpcRowCount)
{
    lpISAMStatement->lpISAM->errcode = NO_ISAM_ERR;
    if (lpISAMStatement->resultSet)
	{
 //       *lpcRowCount = 2;

		//Return number of READ instances
		//we never know the total number of instances returned
		//via passthrough SQL (we get them in batches of 10)
		//*lpcRowCount = lpISAMStatement->pAllRecords->GetCount();
		*lpcRowCount = 0;
	}
    else 
	{
        MessageBox(NULL, lpISAMStatement->lpszParam1,
                   lpISAMStatement->lpszParam2, 0);
        *lpcRowCount = 0;
    }
    return NO_ISAM_ERR;
}
/***************************************************************************/
SWORD INTFUNC ISAMFreeStatement(LPISAMSTATEMENT lpISAMStatement)
{
    lpISAMStatement->lpISAM->errcode = NO_ISAM_ERR;

	//Free 1st SQL passthrough instance (if not already freed)
	if (lpISAMStatement->firstPassthrInst)
	{
		lpISAMStatement->firstPassthrInst->Release();
		lpISAMStatement->firstPassthrInst = NULL;
	}

	//Free Enumeration of Class definitions
	if (lpISAMStatement->tempEnum)
	{
		delete lpISAMStatement->tempEnum;
		lpISAMStatement->tempEnum = NULL;
	}

	if (lpISAMStatement->tempEnum2)
	{
		delete lpISAMStatement->tempEnum2;
		lpISAMStatement->tempEnum2 = NULL;
	}

	if (lpISAMStatement->pProv)
	{
		delete lpISAMStatement->pProv;
		lpISAMStatement->pProv = NULL;
	}

	if (lpISAMStatement->passthroughMap)
	{
		TidyupPassthroughMap(lpISAMStatement->passthroughMap);
		lpISAMStatement->passthroughMap = NULL;
	}

    GlobalUnlock(GlobalPtrHandle(lpISAMStatement));
    GlobalFree(GlobalPtrHandle(lpISAMStatement));
    return NO_ISAM_ERR;
}
/***************************************************************************/
SWORD INTFUNC ISAMSetTxnIsolation(LPISAM lpISAM, UDWORD fTxnIsolationLevel)
{
    /* Select one of the isolation modes from TxnIsolationOption */
    if (!(fTxnIsolationLevel & lpISAM->fTxnIsolationOption)) {
        lpISAM->errcode = ISAM_NOTSUPPORTED;
        return ISAM_NOTSUPPORTED;
    }

    lpISAM->errcode = NO_ISAM_ERR;
    return NO_ISAM_ERR;
}
/***************************************************************************/
SWORD INTFUNC ISAMCommitTxn(LPISAM lpISAM)
{
    lpISAM->errcode = NO_ISAM_ERR;
    return NO_ISAM_ERR;
}
/***************************************************************************/
SWORD INTFUNC ISAMRollbackTxn(LPISAM lpISAM)
{
    lpISAM->errcode = NO_ISAM_ERR;
    return NO_ISAM_ERR;
}
/***************************************************************************/
SWORD INTFUNC ISAMClose(LPISAM lpISAM)
{
    lpISAM->errcode = NO_ISAM_ERR;

	if (lpISAM->pNamespaceMap)
	{
		if (lpISAM->pNamespaceMap->GetCount ())
		{
			CString key;
			CNamespace *pNamespace;
			for (POSITION pos = lpISAM->pNamespaceMap->GetStartPosition (); pos != NULL; )
			{
				if (pos)
				{
					lpISAM->pNamespaceMap->GetNextAssoc (pos, key, (CObject*&)pNamespace);
					delete pNamespace;
				}
			}
		}
		delete lpISAM->pNamespaceMap;
	}

	if (lpISAM->m_Locale)
	{
		delete (lpISAM->m_Locale);
		lpISAM->m_Locale = NULL;
	}

	if (lpISAM->m_Authority)
	{
		delete (lpISAM->m_Authority);
		lpISAM->m_Authority = NULL;
	}

	if (lpISAM->gpAuthIdentity)
	{
		WbemFreeAuthIdentity( lpISAM->gpAuthIdentity );
		lpISAM->gpAuthIdentity = NULL;
	}

	if (lpISAM->Impersonate)
	{
		delete (lpISAM->Impersonate);
		lpISAM->Impersonate = NULL;
	}

	if (lpISAM->hKernelApi)
	{
		BOOL status = FreeLibrary(lpISAM->hKernelApi);
		lpISAM->hKernelApi = NULL;

		if (! status)
		{
			DWORD err = GetLastError();
			CString message ("\n\n***** FreeLibrary(2) KERNEL32 failed : %ld*****\n\n", err);
			ODBCTRACE(message);
		}
	}

    GlobalUnlock(GlobalPtrHandle(lpISAM));
    GlobalFree(GlobalPtrHandle(lpISAM));
    return NO_ISAM_ERR;
}
/***************************************************************************/
void INTFUNC ISAMGetErrorMessage(LPISAM lpISAM, LPUSTR  lpszErrorMessage)
{
    LoadString(s_hModule, lpISAM->errcode, (LPSTR)lpszErrorMessage,
               MAX_ERROR_LENGTH+1);
}
/***************************************************************************/
LPSQLTYPE INTFUNC ISAMGetColumnType(
                    LPISAMTABLEDEF lpISAMTableDef,
                    UWORD icol)
{
    /* There may be more than one entry in SQLTypes[] for any given SQL_x type, */
    /* therefore we need to compare on the type name string */
	ClassColumnInfoBase* cInfoBase = lpISAMTableDef->pColumnInfo;

	if ( !cInfoBase->IsValid() )
	{
        return NULL;
	}

	UWORD cNumberOfCols = cInfoBase->GetNumberOfColumns();

	if (icol >= cNumberOfCols)
        return NULL;
	
	UCHAR* puTypeName = NULL;

	if ( !cInfoBase->GetTypeName(icol, puTypeName) )
	{
        return NULL;
	}

	UCHAR		szTypeName[MAX_COLUMN_NAME_LENGTH+1];
	LONG		cLength = strlen ((char*)puTypeName);
	memcpy(szTypeName, (char*)puTypeName, cLength);
	szTypeName[cLength] = 0;

    return GetType2(szTypeName);
}
/***************************************************************************/

BOOL INTFUNC ISAMCaseSensitive(LPISAM lpISAM)
{
    return FALSE;
}

/***************************************************************************/
LPUSTR INTFUNC ISAMName(LPISAM lpISAM)
{
	char* pName = new char [3 + 1];
	pName[0] = 0;
	sprintf (pName, "%s", "WMI");

	return (LPUSTR)pName;
/*
	char* lpRootDb = (char*)lpISAM->szRootDb;

	IWbemServices* pProv = ISAMGetGatewayServer(lpISAM, (LPUSTR)lpRootDb, lstrlen(lpRootDb));

	if (!pProv)
	{
		return NULL;
	}

	IWbemClassObject * pClassObj = NULL;
	char* pName = NULL;
	BSTR hmomIdBSTR = SysAllocString(WBEMDR32_L_CIMOMIDENTIFICATION);
	IWbemContext* pContext = ISAMCreateLocaleIDContextObject(lpISAM->m_Locale);
    SCODE sc = pProv->GetObject(hmomIdBSTR, 0, pContext, &pClassObj, NULL);

	if (pContext)
		pContext->Release();

	SysFreeString(hmomIdBSTR);

    if (sc == S_OK) 
	{

        VARIANTARG var;
        VariantInit(&var);
		BSTR serverBSTR = SysAllocString(WBEMDR32_L_SERVER);
        pClassObj->Get(serverBSTR,0,&var, NULL, NULL);
		SysFreeString(serverBSTR);
		LONG lLength = wcslen(var.bstrVal);
		char* pTemp = new char [lLength + 1];
		pTemp[0] = 0;
		wcstombs(pTemp, var.bstrVal, lLength);
		pTemp[lLength] = 0;

		pName = new char [lLength + 10];
		pName[0] = 0;
		lstrcpy(pName, "MOServer@");
		lstrcat(pName, pTemp);
		delete pTemp;
		VariantClear(&var);

		pClassObj->Release();

    }
 	
	if (pProv)
		pProv->Release();

	return (LPUSTR)pName;
*/
}

/***************************************************************************/

// Checked for SetInterfaceSecurityEx on IWbemServices

LPUSTR INTFUNC ISAMServer(LPISAM lpISAM)
{
	ODBCTRACE("\nWBEM ODBC Driver : ISAMServer\n");
	char* lpRootDb = (char*)lpISAM->szRootDb;

	IWbemServicesPtr pProv = NULL;
	ISAMGetGatewayServer(pProv, lpISAM, (LPUSTR)lpRootDb, (SWORD) lstrlen(lpRootDb));

	if (pProv == NULL)
	{
		return NULL;
	}

	IWbemClassObject * pClassObj = NULL;
	char* pName = NULL;
	BSTR hmomIdBSTR = SysAllocString(WBEMDR32_L_CIMOMIDENTIFICATION);
	IWbemContext* pContext = ISAMCreateLocaleIDContextObject(lpISAM->m_Locale);

    SCODE sc = pProv->GetObject(hmomIdBSTR, 0, pContext, &pClassObj, NULL);

	if (pContext)
		pContext->Release();

	SysFreeString(hmomIdBSTR);

    if (sc == S_OK) 
	{
        VARIANTARG var;
		BSTR serverBSTR = SysAllocString(WBEMDR32_L_SERVER);
        pClassObj->Get(serverBSTR,0,&var, NULL, NULL);
		SysFreeString(serverBSTR);
		LONG lLength = wcslen(var.bstrVal);
		pName = new char [lLength + 1];
		pName[0] = 0;
		wcstombs(pName, var.bstrVal, lLength);
		pName[lLength] = 0;

		VariantClear(&var);

		long rc = pClassObj->Release();

    }
 	
	return (LPUSTR)pName;
}
/***************************************************************************/
LPUSTR INTFUNC ISAMVersion(LPISAM lpISAM)
{
	char* pVersion = new char [10 + 1];
	pVersion[0] = 0;
	sprintf (pVersion, "%s", "01.00.0000");

	return (LPUSTR)pVersion;
}
/***************************************************************************/
LPCUSTR INTFUNC ISAMDriver(LPISAM lpISAM)
{
    return (LPCUSTR) "WBEMDR32.DLL";
}
/***************************************************************************/
SWORD INTFUNC ISAMMaxTableNameLength(LPISAM lpISAM)
{
    return MAX_TABLE_NAME_LENGTH;//i.e.128
}
/***************************************************************************/
SWORD INTFUNC ISAMMaxColumnNameLength(LPISAM lpISAM)
{
    return MAX_COLUMN_NAME_LENGTH;//i.e.128
}
/***************************************************************************/
LPUSTR INTFUNC ISAMUser(LPISAM lpISAM)
{
    return (LPUSTR) lpISAM->szUser;
}
/***************************************************************************/
LPUSTR INTFUNC ISAMDatabase(LPISAM lpISAM)
{
    return (LPUSTR) lpISAM->szDatabase;
}
/***************************************************************************/
int INTFUNC ISAMSetDatabase (LPISAM lpISAM, LPUSTR database)
{
	if (database && s_lstrlen(database) < MAX_DATABASE_NAME_LENGTH)
	{
		s_lstrcpy (lpISAM->szDatabase, database);
		return TRUE;
	}
	else
		return FALSE;
}
/***************************************************************************/

LPUSTR INTFUNC ISAMRoot (LPISAM lpISAM)
{
	return (LPUSTR) lpISAM->szRootDb;
}

/***************************************************************************/

/* This code was copied from the original Dr DeeBee code and moved to */
/* this separate function for our uses                                */

static SWORD ISAMGetDoubleFromString(BSTR &pString, SDWORD cbValueMax, double &d, BOOL & isNull, BOOL &foundDecimalPoint)
{
	isNull = TRUE;
	BOOL neg = TRUE;
	char* pTemp = new char [cbValueMax + 1];
	pTemp[0] = 0;
	SDWORD cbLen = wcstombs( pTemp, pString, cbValueMax);
	pTemp[cbValueMax] = 0;

	for (SDWORD i=0; i < cbLen; i++) 
	{
		if (*pTemp != ' ')
			break;
		pTemp++;
	}

	neg = FALSE;
	if (i < cbLen) 
	{
		if (*pTemp == '-') 
		{
			neg = TRUE;
			pTemp++;
			i++;
		}
	}

	d = 0.0;
	short scale = 0;
	BOOL negexp = FALSE;
	foundDecimalPoint = FALSE;

	for (;i < cbLen; i++) 
	{
		if (!foundDecimalPoint && (*pTemp == '.'))
			foundDecimalPoint = TRUE;
		else 
		{
			if ((*pTemp == 'E') || (*pTemp == 'e')) 
			{
				pTemp++;
				i++;
				if (i < cbLen) 
				{ 
					if (*pTemp == '-') 
					{
						negexp = TRUE;
						pTemp++;
						i++;
					}
					else if (*pTemp == '+') 
					{
						negexp = FALSE;
						pTemp++;
						i++;
					}
					else
						negexp = FALSE;
				}
				else
					negexp = FALSE;
				short exp = 0;
				for (;i < cbLen; i++) 
				{
					if ((*pTemp < '0') || (*pTemp > '9'))
					{
						delete pTemp;
					   return DBASE_ERR_CONVERSIONERROR;
					}
					exp = (exp * 10) + (*pTemp - '0');
					pTemp++;
				}
				if (negexp)
					scale = scale + exp;
				else
					scale = scale - exp;
				break;
			}
			if ((*pTemp < '0') || (*pTemp > '9'))
			{
				delete pTemp;
				return DBASE_ERR_CONVERSIONERROR;
			}
			d = (d * 10) + (*pTemp - '0');
			isNull = FALSE;
			if (foundDecimalPoint)
				scale++;
		}
		pTemp++;
	}

	for (; (0 < scale); scale--)
		d /= 10;
	for (; (0 > scale); scale++)
		d *= 10;

	
	if (neg)
		d = -d;

	delete pTemp;

	return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

/* Template class to decode array variant value      */
/*                                                   */
/* The fIsBinaryOutput parameter indicates if you    */
/* want the output value a binary data or a string   */


template <class T> SWORD ISAMGetArrayInfo (VARIANT &vVariantVal, T theValue, 
			PTR rgbValue, SDWORD cbValueMax, SDWORD FAR* pcbValue, 
			BOOL fIsBinaryOutput, SWORD wDSDT, UDWORD cbPrecision, long myVirIndex = -1)
{
	//Check if we want all elements of the array or just one element
	BOOL fAllElements = TRUE;
	if (myVirIndex != -1)
	{
		fAllElements = FALSE;
	}


	//Get the value
	SAFEARRAY FAR* pArray = vVariantVal.parray;
	SafeArrayLock(pArray);

	//Find out the bounds of the array
	//Get the upper and lower bounds
	long lLowerBound;
	SafeArrayGetLBound(pArray, 1, &lLowerBound);

	long lUpperBound;
	SafeArrayGetUBound(pArray, 1, &lUpperBound);


	*pcbValue = 0;

	if (cbValueMax)
		((char*)rgbValue)[0] = 0;


	//Initialize
	long cCount = 0;
	SWORD wElemSize = sizeof (T);


	//Setup the filter for the data
	char filter [20];
	filter[0] = 0;

	//Character string length use to represent each element of array
	SWORD wFullCharSize = 0;

	if (!fIsBinaryOutput)
	{
		//Also setup the filter for the data
		filter[0] = 0;
		if ( wDSDT == WBEM_DSDT_REAL_ARRAY )
		{
			if (fAllElements)
			{
				//For character string output the format will be [precision.6f]
				//Thus, we need room for the [ ] and the 'precision.6' 
				wFullCharSize = 9 + REAL_PRECISION;
				sprintf (filter, "%s%d%s", "[%", REAL_PRECISION, ".6g]");
			}
			else
			{
				//For character string output the format will be precision.6f
				//Thus, we need room for the 'precision.6' 
				wFullCharSize = 7 + REAL_PRECISION;
				sprintf (filter, "%s%d%s", "%", REAL_PRECISION, ".6g");
			}
		}
		else if ( wDSDT == WBEM_DSDT_DOUBLE_ARRAY )
		{
			if (fAllElements)
			{
				//For character string output the format will be [precision.6f]
				//Thus, we need room for the [ ] and the 'precision.6' 
				wFullCharSize = 9 + DOUBLE_PRECISION;
				sprintf (filter, "%s%d%s", "[%", DOUBLE_PRECISION, ".6g]");
			}
			else
			{
				//For character string output the format will be precision.6f
				//Thus, we need room for the 'precision.6' 
				wFullCharSize = 7 + DOUBLE_PRECISION;
				sprintf (filter, "%s%d%s", "%", DOUBLE_PRECISION, ".6g");
			}
		}		
		else
		{
			//For character string output the format will be [precision]
			//We add 1 to the precision if the type is signed
			//Thus, we need room for the [ ] and the  
			//ie 2 extra characters for unsigned and 3 for signed

			//Integer type
			//Check if signed
			switch (wDSDT)
			{
			case WBEM_DSDT_SINT8_ARRAY:
			case WBEM_DSDT_SINT16_ARRAY:
			case WBEM_DSDT_SINT32_ARRAY:
				{
					//Signed
					++cbPrecision;

					if (fAllElements)
					{
						wFullCharSize = (SWORD) (cbPrecision + 2);
						strcpy (filter, "[%ld]");
					}
					else
					{
						wFullCharSize = (SWORD) cbPrecision;
						strcpy (filter, "%ld");
					}
				}
				break;
			case WBEM_DSDT_BOOL_ARRAY:
				{
					if (fAllElements)
					{
						wFullCharSize = (SWORD) (cbPrecision + 2);
						strcpy (filter, "[%s]");
					}
					else
					{
						wFullCharSize = (SWORD) cbPrecision;
						strcpy (filter, "%s");
					}
				}
				break;
			default:
				{
					if (fAllElements)
					{
						//Unsigned
						wFullCharSize = (SWORD) (cbPrecision + 2);
						strcpy (filter, "[%lu]");
					}
					else
					{
						//Unsigned
						wFullCharSize = (SWORD) (cbPrecision);
						strcpy (filter, "%lu");
					}
				}
				break;
			}		
		}
	}

	char* tempBuff = new char [wFullCharSize + 1];

	//Loop through each entry to fetch the array data
	BOOL fDoweHaveEnoughBufferSpace = FALSE;

	long loop = 0;
	for (long cIndex = lLowerBound; cIndex <= lUpperBound; cIndex++)
	{
		//Check we have enough buffer space
		if (fIsBinaryOutput)
		{
			fDoweHaveEnoughBufferSpace = ((wElemSize + (*pcbValue)) <= cbValueMax) ? TRUE : FALSE;
		}
		else
		{			
			fDoweHaveEnoughBufferSpace = ((wFullCharSize + (*pcbValue)) <= cbValueMax) ? TRUE : FALSE;
		}


		if ( fDoweHaveEnoughBufferSpace)
		{
			if ( SUCCEEDED(SafeArrayGetElement(pArray, &cIndex, &theValue)) )
			{
				//Check if we want to use this value
				BOOL fUseThisValue = FALSE;

				if (fAllElements)
				{
					fUseThisValue = TRUE;
				}
				else
				{
					if (loop == myVirIndex)
						fUseThisValue = TRUE;
				}


				if (fUseThisValue)
				{
					if (fIsBinaryOutput)
					{
						//Copy
						T* pTemp = (T*)rgbValue;

						pTemp[cCount++] = theValue;

						//Increment counter of number of bytes copied
						(*pcbValue) += wElemSize;
					}
					else
					{
						tempBuff[0] = 0;

						if (wDSDT == WBEM_DSDT_BOOL_ARRAY)
						{
							sprintf (tempBuff, filter, (theValue ? "T" : "F"));
						}
						else
						{
							sprintf (tempBuff, filter, (T) theValue);
						}

						
						lstrcat( (char*)rgbValue, tempBuff);

						//Increment counter of number of bytes copied
						(*pcbValue) += lstrlen (tempBuff);
					}
				}
			}
			else
			{
				//error !!!

				//Tidy Up
				delete tempBuff;
				SafeArrayUnlock(pArray);
				return ISAM_ERROR;
			}
		}
		else
		{
			//No we don't so quit

			//Tidy Up
			delete tempBuff;
			SafeArrayUnlock(pArray);
			return ISAM_TRUNCATION;
		}
		loop++;
	}

	//Tidy Up
	delete tempBuff;
	SafeArrayUnlock(pArray);
	return NO_ISAM_ERR;
}

/**************************************************************************/

SWORD INTFUNC ISAMGetArrayStringInfo (VARIANT &vVariantVal, BSTR syntaxStr, 
			PTR rgbValue, SDWORD cbValueMax, SDWORD FAR* pcbValue, BOOL fIsBinaryOutput, long myVirIndex)
{
	//Check if we want all elements of the array or just one element
	BOOL fAllElements = TRUE;
	if (myVirIndex != -1)
	{
		fAllElements = FALSE;
	}

	//Get the value
	SAFEARRAY FAR* pArray = vVariantVal.parray;
	SafeArrayLock(pArray);

	//Find out the bounds of the array
	//Get the upper and lower bounds
	long lLowerBound;
	SafeArrayGetLBound(pArray, 1, &lLowerBound);

	long lUpperBound;
	SafeArrayGetUBound(pArray, 1, &lUpperBound);
	*pcbValue = 0;

	//Initialize
	long cCount = 0;
	BSTR theValue; 
	((char*)rgbValue)[0] = 0;
	BOOL fOutOfBufferSpace = FALSE;

	long loop = 0;
	for (long cIndex = lLowerBound; (!fOutOfBufferSpace) && (cIndex <= lUpperBound); cIndex++)
	{
		//Check if we want to use this value
		BOOL fUseThisValue = FALSE;

		if (fAllElements)
		{
			fUseThisValue = TRUE;
		}
		else
		{
			if (loop == myVirIndex)
				fUseThisValue = TRUE;
		}
		
		if (fUseThisValue)
		{
			if ( SUCCEEDED(SafeArrayGetElement(pArray, &cIndex, &theValue)) )
			{
				//Now we must add in string value in the format [string]
				//However, if the string contains either [ or ] we must double
				//this character in the string sequence

				ULONG cLength = 0;
				char* theValueStr = NULL;
				if (theValue)
				{
					cLength = wcslen(theValue);
					theValueStr = new char [cLength + 1];
					theValueStr[0] = 0;
					wcstombs(theValueStr, theValue, cLength);
					theValueStr[cLength] = 0;
				}


				SWORD err = NO_ISAM_ERR;

				if (!syntaxStr)
					syntaxStr = L" ";

				
				//Check if this is a string, timestamp, interval, time or date
				BOOL foundMatch = FALSE;
	//			if ( (_wcsicmp(syntaxStr, WBEM_WSYNTAX_DATETIME) == 0) || 
	//				(_wcsicmp(syntaxStr, WBEM_WSYNTAX_INTERVAL) == 0))
				if (_wcsicmp(syntaxStr, WBEM_WSYNTAX_DATETIME) == 0)
				{
					//A timestamp
					DateTimeParser parser(theValue);

	//				if ( parser.IsValid() && parser.IsTimestamp() )
					{
						foundMatch = TRUE;
						if (fIsBinaryOutput)
						{
							if (cbValueMax >= (SDWORD)((*pcbValue) + sizeof (TIMESTAMP_STRUCT)) )
							{
								TIMESTAMP_STRUCT FAR* pTimeStampStruct = (TIMESTAMP_STRUCT FAR*)((char*)rgbValue + (*pcbValue));
								pTimeStampStruct->year = (SWORD)parser.GetYear();
								pTimeStampStruct->month = (UWORD)parser.GetMonth();
								pTimeStampStruct->day = (UWORD)parser.GetDay();
								pTimeStampStruct->hour = (UWORD)parser.GetHour();
								pTimeStampStruct->minute = (UWORD)parser.GetMin();
								pTimeStampStruct->second = (UWORD)parser.GetSec();
								pTimeStampStruct->fraction = 1000 * parser.GetMicroSec();
								*pcbValue += sizeof (TIMESTAMP_STRUCT);
							}
							else
							{
								//not enough space
								err = ISAM_TRUNCATION;
							}
						}
						else
						{
							TIMESTAMP_STRUCT pTimeStampStruct;
									
							pTimeStampStruct.year = (SWORD)parser.GetYear();
							pTimeStampStruct.month = (UWORD)parser.GetMonth();
							pTimeStampStruct.day = (UWORD)parser.GetDay();
							pTimeStampStruct.hour = (UWORD)parser.GetHour();
							pTimeStampStruct.minute = (UWORD)parser.GetMin();
							pTimeStampStruct.second = (UWORD)parser.GetSec();
							pTimeStampStruct.fraction = 1000 * parser.GetMicroSec();

							if (fAllElements)
							{					
								if (cbValueMax >= ( (*pcbValue) + 23+TIMESTAMP_SCALE) )
								{
									char szBuffer[20+TIMESTAMP_SCALE+1];
									TimestampToChar(&pTimeStampStruct, (LPUSTR)szBuffer);
									char* ptrToStr = ((char*)rgbValue + (*pcbValue));
									sprintf (ptrToStr, "[%s]", szBuffer);
									*pcbValue += (22+TIMESTAMP_SCALE); //ignore null
								}
								else
								{
									//not enough space
									err = ISAM_TRUNCATION;
								}
							}
							else
							{
								if (cbValueMax >= ( (*pcbValue) + 21+TIMESTAMP_SCALE) )
								{
									char szBuffer[20+TIMESTAMP_SCALE+1];
									TimestampToChar(&pTimeStampStruct, (LPUSTR)szBuffer);
									char* ptrToStr = ((char*)rgbValue + (*pcbValue));
									sprintf (ptrToStr, "%s", szBuffer);
									*pcbValue += (20+TIMESTAMP_SCALE); //ignore null
								}
								else
								{
									//not enough space
									err = ISAM_TRUNCATION;
								}
							}
						}
					}
					
				}
	/*
				else if (_wcsicmp(syntaxStr, WBEM_WSYNTAX_DATE) == 0)
				{
					//A date
					DateTimeParser parser(theValue);

	//				if ( parser.IsValid() && parser.IsDate() )
					{
						foundMatch = TRUE;
						if (fIsBinaryOutput)
						{
							if (cbValueMax >= (SDWORD)((*pcbValue) + sizeof (DATE_STRUCT)) )
							{
								DATE_STRUCT FAR* pDateStruct = (DATE_STRUCT FAR*)((char*)rgbValue + (*pcbValue));
								pDateStruct->year = (SWORD)parser.GetYear();
								pDateStruct->month = (UWORD)parser.GetMonth();
								pDateStruct->day = (UWORD)parser.GetDay();
								*pcbValue += sizeof (DATE_STRUCT);
							}
							else
							{
								//not enough space
								err = ISAM_TRUNCATION;
							}
						}
						else
						{
							DATE_STRUCT pDateStruct;
									
							pDateStruct.year = (SWORD)parser.GetYear();
							pDateStruct.month = (UWORD)parser.GetMonth();
							pDateStruct.day = (UWORD)parser.GetDay();

							if (cbValueMax >= ( (*pcbValue) + 3 + DATE_PRECISION) )
							{
								char szBuffer[DATE_PRECISION + 1];
								DateToChar(&pDateStruct, szBuffer);
								char* ptrToStr = ((char*)rgbValue + (*pcbValue));
								sprintf (ptrToStr, "[%s]", szBuffer);
								*pcbValue += (2 + DATE_PRECISION);// ignore null
							}
							else
							{
								//not enough space
								err = ISAM_TRUNCATION;
							}		
						}
					}
				}
				else if (_wcsicmp(syntaxStr, WBEM_WSYNTAX_TIME) == 0)
				{
					//A time
					DateTimeParser parser(theValue);

	//				if ( parser.IsValid() && parser.IsTime() )
					{
						foundMatch = TRUE;
						if (fIsBinaryOutput)
						{
							if (cbValueMax >=  (SDWORD)((*pcbValue) + sizeof (TIME_STRUCT)) )
							{
								TIME_STRUCT FAR* pTimeStruct = (TIME_STRUCT FAR*)((char*)rgbValue + (*pcbValue));
								pTimeStruct->hour = (UWORD)parser.GetHour();
								pTimeStruct->minute = (UWORD)parser.GetMin();
								pTimeStruct->second = (UWORD)parser.GetSec();
								*pcbValue += sizeof (TIME_STRUCT);
							}
							else
							{
								//not enough space
								err = ISAM_TRUNCATION;
							}
						}
						else
						{
							TIME_STRUCT pTimeStruct;
									
							pTimeStruct.hour = (UWORD)parser.GetHour();
							pTimeStruct.minute = (UWORD)parser.GetMin();
							pTimeStruct.second = (UWORD)parser.GetSec();

							if (cbValueMax >= ( (*pcbValue) + 3 + TIME_PRECISION) )
							{
								char szBuffer[TIME_PRECISION + 1];
								TimeToChar(&pTimeStruct, szBuffer);
								char* ptrToStr = ((char*)rgbValue + (*pcbValue));
								sprintf (ptrToStr, "[%s]", szBuffer);
								*pcbValue += (2 + TIME_PRECISION);//ignore null
							}
							else
							{
								//not enough space
								err = ISAM_TRUNCATION;
							}		
						}
					}
				}
	*/
				
				if (!foundMatch)
				{
					//Check if string or 64bit integer
					SDWORD fInt64Check = 0;

					if ( (_wcsicmp(syntaxStr, WBEM_WSYNTAX_SINT64) == 0) )
						fInt64Check = WBEM_DSDT_SINT64;

					if ( (_wcsicmp(syntaxStr, WBEM_WSYNTAX_UINT64) == 0) )
						 fInt64Check = WBEM_DSDT_UINT64;
					
					err = ISAMFormatCharParm (theValueStr, fOutOfBufferSpace,
							(char*)rgbValue, cbValueMax, pcbValue, fIsBinaryOutput, fInt64Check, fAllElements);

				}
				
				
				if (theValue)
					delete theValueStr;

				//SAI MOVED
				SysFreeString(theValue);

				if (err != NO_ISAM_ERR)
				{
					SafeArrayUnlock(pArray);
					return err;
				}
			}
			else
			{
				//error !!!
				SafeArrayUnlock(pArray);
				return ISAM_ERROR;
			}
		}
		loop++;
	}

	//Tidy Up
//	SysFreeString(theValue);
	SafeArrayUnlock(pArray);
	return NO_ISAM_ERR;
}

/*
SWORD ISAMGetPropertyArrayInfo(BSTR			&   arrayVal,
							  SWORD             fCType, 
							  PTR               rgbValue, 
							  SDWORD            cbValueMax, 
							  SDWORD FAR        *pcbValue,
							  SWORD             wbemVariantType,
							  BSTR				syntaxStr,
							  BSTR				maxStr)
{
	SWORD err = NO_ISAM_ERR;
	SWORD wDSDT = 0;
	SWORD dummy1 = 0;
	UDWORD cbPrecision = 0;

	//Get the value
	BSTR pString = arrayVal;

	//If no WBEM variant type specified use default
	if (!wbemVariantType)
		wbemVariantType = WBEM_VARIANT_VT_ARRAY_BSTR;

	//How do we want the value returned
	switch (fCType)
	{
	case SQL_C_DOUBLE:
		{
			double dVal;
			BOOL foundDecimalPoint;
			BOOL isNull;
			*pcbValue = sizeof(double);
			if ((cbValueMax >= *pcbValue) &&
				(DBASE_ERR_SUCCESS == ISAMGetDoubleFromString(pString, cbValueMax, dVal, isNull, foundDecimalPoint)) )
			{
				if (isNull)
				{
					*pcbValue = SQL_NULL_DATA;
				}
				else
				{
					*((double *)rgbValue) = dVal;
				}
			}
			else
			{
				*pcbValue = 0;
				return ERR_NOTCONVERTABLE;
			}
		}
		break;
	case SQL_C_CHAR:
		{
			char* pTemp = (char*) rgbValue;
			pTemp[0] = 0;
			*pcbValue = wcstombs( pTemp, pString, cbValueMax);

			//Make an extra check here if you are requesting 64bit integers
			ISAMGetDataSourceDependantTypeInfo
					((SWORD)wbemVariantType, syntaxStr, maxStr, wDSDT, dummy1, cbPrecision);

			//Check for numeric string
			if ( (wDSDT == WBEM_DSDT_SINT64_ARRAY) )
			{
				for (SDWORD ii = 0; ii < (*pcbValue); ii++)
				{

					switch (pTemp[ii])
					{
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
					case '+':
					case '-':
						//OK
						break;
					default:
						return ERR_INVALID_INTEGER;
						break;
					}
				}
			}

			if ( (wDSDT == WBEM_DSDT_UINT64_ARRAY) )
			{
				for (SDWORD ii = 0; ii < (*pcbValue); ii++)
				{

					switch (pTemp[ii])
					{
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						//OK
						break;
					default:
						return ERR_INVALID_INTEGER;
						break;
					}
				}
			}
		}
		break;
	case SQL_C_TIMESTAMP:
		{
			//Check that you have enough buffer to store value
			*pcbValue = sizeof (TIMESTAMP_STRUCT);
			TIMESTAMP_STRUCT FAR* pTimeStampStruct = (TIMESTAMP_STRUCT FAR*)rgbValue;
			if ( cbValueMax >= (*pcbValue) )
			{
				DateTimeParser parser(pString);

//					if ( parser.IsValid() && parser.IsTimestamp() )
				{
					pTimeStampStruct->year = (SWORD)parser.GetYear();
					pTimeStampStruct->month = (UWORD)parser.GetMonth();
					pTimeStampStruct->day = (UWORD)parser.GetDay();
					pTimeStampStruct->hour = (UWORD)parser.GetHour();
					pTimeStampStruct->minute = (UWORD)parser.GetMin();
					pTimeStampStruct->second = (UWORD)parser.GetSec();
					pTimeStampStruct->fraction = 1000 * parser.GetMicroSec();
				}
			}
			else
			{
				*pcbValue = 0;
				return ERR_INSUFF_BUFFER;
			}
		}
		break;
	case SQL_C_BINARY:
	default:
		{
			//No convertion available
			return ERR_NOTCONVERTABLE;
		}
		break;
	}

	return err;
}
*/
/***************************************************************************/

/* Retrieves the value from a variant */


SWORD ISAMGet_VT_I2(short			iShortVal,
					SWORD           fCType, 
					PTR             rgbValue, 
					SDWORD          cbValueMax, 
					SDWORD FAR      *pcbValue,
					SWORD           wbemVariantType,
					BSTR			syntaxStr,
					SDWORD			maxLenVal)
{
	SWORD err = NO_ISAM_ERR;
	SWORD wDSDT = 0;
	SWORD dummy1 = 0;
	UDWORD cbPrecision = 0;

	//If no WBEM variant type specified use default
	if (!wbemVariantType)
		wbemVariantType = WBEM_VARIANT_VT_I2;


	//How do we want the value returned
	switch (fCType)
	{
	case SQL_C_DOUBLE:
		{
			//Check that you have enough buffer to store value
			ISAMGetDataSourceDependantTypeInfo
				((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);

			if ( (wDSDT == WBEM_DSDT_SINT8) || (wDSDT == WBEM_DSDT_SINT8_ARRAY) )
			{
				//Signed 8 bit value
				//Check that you have enough buffer to store value
				*pcbValue = sizeof(signed char);
				if (cbValueMax >= *pcbValue)
				{
					signed char iCharVal = (signed char) iShortVal;
					*((double *)rgbValue) = (double)iCharVal;
				}
				else
				{
					*pcbValue = 0;
					return ERR_INSUFF_BUFFER;
				}
			}
			else
			{
				//Signed 16 bit value
				//Check that you have enough buffer to store value
				*pcbValue = sizeof(double);
				if (cbValueMax >= *pcbValue)
				{
					*((double *)rgbValue) = (double)iShortVal;
				}
				else
				{
					*pcbValue = 0;
					return ERR_INSUFF_BUFFER;
				}
			}
			
		}
		break;
	case SQL_C_CHAR:
		{
			ISAMGetDataSourceDependantTypeInfo
					((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);

			if ( (wDSDT == WBEM_DSDT_SINT8) || (wDSDT == WBEM_DSDT_SINT8_ARRAY) )
			{
				//Signed 8 bit value
				//Check that there is enough buffer space for largest value
				if (cbValueMax >= STINYINT_PRECISION)
				{
					char ttt = (char) iShortVal;
					char* pTemp = (char*)rgbValue;
					pTemp[0] = 0;
					sprintf ((char*)rgbValue, "%d", (short)ttt);
					*pcbValue = lstrlen(pTemp);
				}
				else
				{
					*pcbValue = 0;
					return ERR_INSUFF_BUFFER;
				}
			}
			else
			{
				//Signed 16 bit value
				//Check that there is enough buffer space for largest value
				if (cbValueMax >= SSHORT_PRECISION)
				{
					char* pTemp = (char*)rgbValue;
					pTemp[0] = 0;
					sprintf ((char*)rgbValue, "%ld", iShortVal);
					*pcbValue = lstrlen(pTemp);
				}
				else
				{
					*pcbValue = 0;
					return ERR_INSUFF_BUFFER;
				}
			}

		}
		break;
	case SQL_C_DATE:
	case SQL_C_TIME:
	case SQL_C_TIMESTAMP:
	case SQL_C_BINARY:
	default:
		{
			//No convertion available
			return ISAM_ERROR;
		}
		break;
	}

	return err;
}



SWORD ISAMGet_VT_UI1(UCHAR			iUcharVal,
					SWORD           fCType, 
					PTR             rgbValue, 
					SDWORD          cbValueMax, 
					SDWORD FAR      *pcbValue,
					SWORD           wbemVariantType,
					BSTR			syntaxStr,
					SDWORD			maxLenVal)
{
	SWORD err = NO_ISAM_ERR;
	SWORD wDSDT = 0;
	SWORD dummy1 = 0;
	UDWORD cbPrecision = 0;

	//If no WBEM variant type specified use default
	if (!wbemVariantType)
		wbemVariantType = WBEM_VARIANT_VT_UI1;

	//How do we want the value returned
	switch (fCType)
	{
	case SQL_C_DOUBLE:
		{
			*pcbValue = sizeof(double);
			//Check that you have enough buffer to store value
			if (cbValueMax >= *pcbValue)
			{
				ISAMGetDataSourceDependantTypeInfo
					((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);

				{
					//Unsigned 8 bit value
					*((double *)rgbValue) = (double)iUcharVal;
				}
			}
			else
			{
				*pcbValue = 0;
				return ERR_INSUFF_BUFFER;
			}
		}
		break;
	case SQL_C_CHAR:
		{
			ISAMGetDataSourceDependantTypeInfo
					((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);

			if (cbValueMax >= UTINYINT_PRECISION)
			{
				//Unsigned 8 bit value
				//Check that there is enough buffer space for largest value
				char* pTemp = (char*)rgbValue;
				pTemp[0] = 0;
				_itoa(iUcharVal, pTemp, 10);
				*pcbValue = lstrlen(pTemp);
			}
			else
			{
				*pcbValue = 0;
				return ERR_INSUFF_BUFFER;
			}
		}
		break;
	case SQL_C_DATE:
	case SQL_C_TIME:
	case SQL_C_TIMESTAMP:
	case SQL_C_BINARY:
	default:
		{
			//No convertion available
			return ERR_NOTCONVERTABLE;
		}
		break;
	}

	return err;
}



SWORD ISAMGet_VT_I4(long			iValue,
					SWORD           fCType, 
					PTR             rgbValue, 
					SDWORD          cbValueMax, 
					SDWORD FAR      *pcbValue,
					SWORD           wbemVariantType,
					BSTR			syntaxStr,
					SDWORD			maxLenVal)
{
	SWORD err = NO_ISAM_ERR;
	SWORD wDSDT = 0;
	SWORD dummy1 = 0;
	UDWORD cbPrecision = 0;

	//If no WBEM variant type specified use default
	if (!wbemVariantType)
		wbemVariantType = WBEM_VARIANT_VT_I4;

	//How do we want the value returned
	switch (fCType)
	{
	case SQL_C_DOUBLE:
		{

			ISAMGetDataSourceDependantTypeInfo
					((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);

			*pcbValue = sizeof (double);

			if ( (wDSDT == WBEM_DSDT_UINT16) || (wDSDT == WBEM_DSDT_UINT16_ARRAY) )
			{
				//Unsigned 16 bit value
				//Check that there is enough buffer space for largest value
				if (cbValueMax >= *pcbValue)
				{
					double dd  = (unsigned short) iValue;
					*((double *)rgbValue) = dd;
				}
				else
				{
					*pcbValue = 0;
					return ERR_INSUFF_BUFFER;
				}
			}
			else if ( (wDSDT == WBEM_DSDT_UINT32) || (wDSDT == WBEM_DSDT_UINT32_ARRAY) )
			{
				//Unsigned 32 bit value
				//Check that you have enough buffer to store value
				*pcbValue = sizeof (double);
				if (cbValueMax >= *pcbValue)
				{
					double dd  = (unsigned long) iValue;
					*((double *)rgbValue) = dd;
				}
				else
				{
					*pcbValue = 0;
					return ERR_INSUFF_BUFFER;
				}
			}
			else
			{
				//Signed 32 bit value
				//Check that you have enough buffer to store value
				if (cbValueMax >= *pcbValue)
				{
					*((double *)rgbValue) = (double)iValue;
				}
				else
				{
					*pcbValue = 0;
					return ERR_INSUFF_BUFFER;
				}
			}
		}
		break;
	case SQL_C_CHAR:
		{
			ISAMGetDataSourceDependantTypeInfo
					((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);


			if ( (wDSDT == WBEM_DSDT_UINT16) || (wDSDT == WBEM_DSDT_UINT16_ARRAY) )
			{
				//Unsigned 16 bit value
				//Check that there is enough buffer space for largest value
				if (cbValueMax >= USHORT_PRECISION)
				{
					unsigned short iushort = (unsigned short) iValue;
					char* pTemp = (char*)rgbValue;
					pTemp[0] = 0;
					sprintf ((char*)rgbValue, "%lu", iushort);
					*pcbValue = lstrlen(pTemp);
				}
				else
				{
					*pcbValue = 0;
					return ERR_INSUFF_BUFFER;
				}
			}
			else if ( (wDSDT == WBEM_DSDT_UINT32) || (wDSDT == WBEM_DSDT_UINT32_ARRAY) )
			{
				//Unsigned 32 bit value
				//Check that there is enough buffer space for largest value
				if (cbValueMax >= ULONG_PRECISION)
				{
					unsigned long iulong  = (unsigned long) iValue; 
					char* pTemp = (char*)rgbValue;
					pTemp[0] = 0;
					sprintf ((char*)rgbValue, "%lu", iulong);
					*pcbValue = lstrlen(pTemp);
				}
				else
				{
					*pcbValue = 0;
					return ERR_INSUFF_BUFFER;
				}
			}
			else
			{
				//Signed 32 bit value
				//Check that there is enough buffer space for largest value
				if (cbValueMax >= SLONG_PRECISION)
				{
					char* pTemp = (char*)rgbValue;
					pTemp[0] = 0;
					sprintf ((char*)rgbValue, "%ld", iValue);
					*pcbValue = lstrlen(pTemp);
				}
				else
				{
					*pcbValue = 0;
					return ERR_INSUFF_BUFFER;
				}
			}
		}
		break;
	case SQL_C_DATE:
	case SQL_C_TIME:
	case SQL_C_TIMESTAMP:
	case SQL_C_BINARY:
	default:
		{
			//No convertion available
			return ERR_NOTCONVERTABLE;
		}
		break;
	}

	return err;
}


SWORD ISAMGet_VT_BOOL(VARIANT_BOOL	fBool,
					SWORD           fCType, 
					PTR             rgbValue, 
					SDWORD          cbValueMax, 
					SDWORD FAR      *pcbValue,
					SWORD           wbemVariantType,
					BSTR			syntaxStr,
					SDWORD			maxLenVal)
{
	SWORD err = NO_ISAM_ERR;
	SWORD wDSDT = 0;
	SWORD dummy1 = 0;
	UDWORD cbPrecision = 0;

	//How do we want the value returned
	switch (fCType)
	{
	case SQL_C_DOUBLE:
		{
			*pcbValue = sizeof(double);
			//Check that you have enough buffer to store value
			if (cbValueMax >= *pcbValue)
			{
				if (fBool)
					*((double *)rgbValue) = 1.0;
				else
					*((double *)rgbValue) = 0.0;
			}
			else
			{
				*pcbValue = 0;
				return ERR_INSUFF_BUFFER;
			}
		}
		break;
	case SQL_C_CHAR:
		{
			if (cbValueMax)
			{
				char* pTemp = (char*)rgbValue;
				pTemp[0] = 0;
				if (fBool)
					lstrcpy(pTemp, "T");
				else
					lstrcpy(pTemp, "F");

				*pcbValue = 1;
			}
		}
		break;
	case SQL_C_DATE:
	case SQL_C_TIME:
	case SQL_C_TIMESTAMP:
	case SQL_C_BINARY:
	default:
		{
			//No convertion available
			return ERR_NOTCONVERTABLE;
		}
		break;
	}

	return err;
}


SWORD ISAMGet_VT_R4(float			fltVal,
					SWORD           fCType, 
					PTR             rgbValue, 
					SDWORD          cbValueMax, 
					SDWORD FAR      *pcbValue,
					SWORD           wbemVariantType,
					BSTR			syntaxStr,
					SDWORD			maxLenVal)
{
	SWORD err = NO_ISAM_ERR;
	SWORD wDSDT = 0;
	SWORD dummy1 = 0;
	UDWORD cbPrecision = 0;

	//How do we want the value returned
	switch (fCType)
	{
	case SQL_C_DOUBLE:
		{
			*pcbValue = sizeof(double);
			//Check that you have enough buffer to store value
			if (cbValueMax >= *pcbValue)
			{
				*((double *)rgbValue) = (double)fltVal;
			}
			else
			{
				*pcbValue = 0;
				return ERR_INSUFF_BUFFER;
			}
		}
		break;
	case SQL_C_CHAR:
		{
			int decimal, sign;
			double dblVal = fltVal;
			char* buffer = _ecvt(dblVal, cbValueMax - 2, &decimal, &sign);  
			char* pTemp = (char*) rgbValue;
			pTemp[0] = 0;

			//We need a buffer to store at least "-.3"
			if (cbValueMax < 3)
			{
				*pcbValue = 0;
				return ERR_INSUFF_BUFFER;
			}

			//Check if value is negative
			if (sign)
			{
				strcpy(pTemp, "-");
			}

			//Now copy digits BEFORE the decimal point
			if (cbValueMax && decimal)
			{
				strncat(pTemp, buffer, decimal);
			}

			char* pt = buffer + decimal;

			if (cbValueMax && strlen (pt) )
			{
				//Add the decimal point
				strcat (pTemp, ".");

				//Copy digits AFTER decimal point
				strcat(pTemp, pt);
			}

			*pcbValue = strlen (pTemp);
		}
		break;
	case SQL_C_DATE:
	case SQL_C_TIME:
	case SQL_C_TIMESTAMP:
	case SQL_C_BINARY:
	default:
		{
			//No convertion available
			return ERR_NOTCONVERTABLE;
		}
		break;
	}

	return err;
}


SWORD ISAMGet_VT_R8(double			dblVal,
					SWORD           fCType, 
					PTR             rgbValue, 
					SDWORD          cbValueMax, 
					SDWORD FAR      *pcbValue,
					SWORD           wbemVariantType,
					BSTR			syntaxStr,
					SDWORD			maxLenVal)
{
	SWORD err = NO_ISAM_ERR;
	SWORD wDSDT = 0;
	SWORD dummy1 = 0;
	UDWORD cbPrecision = 0;

	//How do we want the value returned
	switch (fCType)
	{
	case SQL_C_DOUBLE:				
	case SQL_C_DEFAULT:
		{
			*pcbValue = sizeof(double);
			//Check that you have enough buffer to store value
			if (cbValueMax >= *pcbValue)
			{
				*((double *)rgbValue) = (double)dblVal;
			}
			else
			{
				*pcbValue = 0;
				return ERR_INSUFF_BUFFER;
			}
		}
		break;
	case SQL_C_CHAR:
		{
			int decimal, sign;
			char* buffer = _ecvt(dblVal, cbValueMax - 2, &decimal, &sign);  
			char* pTemp = (char*) rgbValue;
			pTemp[0] = 0;

			//We need a buffer to store at least "-.3"
			if (cbValueMax < 3)
			{
				*pcbValue = 0;
				return ERR_INSUFF_BUFFER;
			}

			//Check if value is negative
			if (sign)
			{
				strcpy(pTemp, "-");
			}

			//Now copy digits BEFORE the decimal point
			if (cbValueMax && decimal)
			{
				strncat(pTemp, buffer, decimal);
			}

			char* pt = buffer + decimal;

			if (cbValueMax && strlen (pt) )
			{
				//Add the decimal point
				strcat (pTemp, ".");

				//Copy digits AFTER decimal point
				strcat(pTemp, pt);
			}

			*pcbValue = strlen (pTemp);
		}
		break;
	case SQL_C_DATE:
	case SQL_C_TIME:
	case SQL_C_TIMESTAMP:
	case SQL_C_BINARY:
	default:
		{
			//No convertion available
			return ERR_NOTCONVERTABLE;
		}
		break;
	}

	return err;
}

SWORD ISAMGet_VT_BSTR(BSTR			pString,
					SWORD           fCType, 
					PTR             rgbValue, 
					SDWORD          cbValueMax, 
					SDWORD FAR      *pcbValue,
					SWORD           wbemVariantType,
					BSTR			syntaxStr,
					SDWORD			maxLenVal)
{
	SWORD err = NO_ISAM_ERR;
	SWORD wDSDT = 0;
	SWORD dummy1 = 0;
	UDWORD cbPrecision = 0;

	//If no WBEM variant type specified use default
	if (!wbemVariantType)
		wbemVariantType = WBEM_VARIANT_VT_BSTR;

	//How do we want the value returned
	switch (fCType)
	{
	case SQL_C_DOUBLE:
		{
			double dVal;
			BOOL foundDecimalPoint;
			BOOL isNull;
			*pcbValue = sizeof(double);
			if ((cbValueMax >= *pcbValue) &&
				(DBASE_ERR_SUCCESS == ISAMGetDoubleFromString(pString, cbValueMax, dVal, isNull, foundDecimalPoint)) )
			{
				if (isNull)
				{
					*pcbValue = SQL_NULL_DATA;
				}
				else
				{
					*((double *)rgbValue) = dVal;
				}
			}
			else
			{
				*pcbValue = 0;
				return ERR_NOTCONVERTABLE;
			}
		}
		break;
	case SQL_C_CHAR:
		{
			
			char* pTemp = (char*) rgbValue;
			_bstr_t myValue((BSTR)pString);
			*pcbValue = Utility_WideCharToDBCS(myValue, &pTemp, cbValueMax);

			//Make an extra check here if you are requesting 64bit integers
			ISAMGetDataSourceDependantTypeInfo
					((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);

			//Check for numeric string
			if ( (wDSDT == WBEM_DSDT_SINT64) )
			{
				for (SDWORD ii = 0; ii < (*pcbValue); ii++)
				{

					switch (pTemp[ii])
					{
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
					case '+':
					case '-':
						//OK
						break;
					default:
						return ERR_INVALID_INTEGER;
						break;
					}
				}
			}

			if ( (wDSDT == WBEM_DSDT_UINT64) )
			{
				for (SDWORD ii = 0; ii < (*pcbValue); ii++)
				{

					switch (pTemp[ii])
					{
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						//OK
						break;
					default:
						return ERR_INVALID_INTEGER;
						break;
					}
				}
			}
		}
		break;
/*
	case SQL_C_DATE:
		{
			//Check that you have enough buffer to store value
			*pcbValue = sizeof (DATE_STRUCT);
			DATE_STRUCT FAR* pDateStruct = (DATE_STRUCT FAR*)rgbValue;
			if ( cbValueMax >= (*pcbValue) )
			{

				DateTimeParser parser(pString);

//						if ( parser.IsValid() && parser.IsDate() )
				{
					pDateStruct->year = (SWORD)parser.GetYear();
					pDateStruct->month = (UWORD)parser.GetMonth();
					pDateStruct->day = (UWORD)parser.GetDay();
				}
//						else
//						{
//							*pcbValue = 0;
//							return ERR_INVALID_DATE;
//						}
			}
			else
			{
				*pcbValue = 0;
				return ERR_INSUFF_BUFFER;
			}
		}
		break;
	case SQL_C_TIME:
		{
			//Check that you have enough buffer to store value
			*pcbValue = sizeof (TIME_STRUCT);
			TIME_STRUCT FAR* pTimeStruct = (TIME_STRUCT FAR*)rgbValue;
			if ( cbValueMax >= (*pcbValue) )
			{
				DateTimeParser parser(pString);

//						if ( parser.IsValid() && parser.IsTime() )
				{
					pTimeStruct->hour = (UWORD)parser.GetHour();
					pTimeStruct->minute = (UWORD)parser.GetMin();
					pTimeStruct->second = (UWORD)parser.GetSec();
				}
//						else
//						{
//							*pcbValue = 0;
//							return ERR_INVALID_TIME;
//						}
			}
			else
			{
				*pcbValue = 0;
				return ERR_INSUFF_BUFFER;
			}
		}
		break;
*/
	case SQL_C_TIMESTAMP:
		{
			//Check that you have enough buffer to store value
			*pcbValue = sizeof (TIMESTAMP_STRUCT);
			TIMESTAMP_STRUCT FAR* pTimeStampStruct = (TIMESTAMP_STRUCT FAR*)rgbValue;
			if ( cbValueMax >= (*pcbValue) )
			{
				DateTimeParser parser(pString);

//					if ( parser.IsValid() && parser.IsTimestamp() )
				{
					pTimeStampStruct->year = (SWORD)parser.GetYear();
					pTimeStampStruct->month = (UWORD)parser.GetMonth();
					pTimeStampStruct->day = (UWORD)parser.GetDay();
					pTimeStampStruct->hour = (UWORD)parser.GetHour();
					pTimeStampStruct->minute = (UWORD)parser.GetMin();
					pTimeStampStruct->second = (UWORD)parser.GetSec();
					pTimeStampStruct->fraction = 1000 * parser.GetMicroSec();
				}
//					else
//					{
//						*pcbValue = 0;
//						return ERR_INVALID_TIMESTAMP;
//					}
			}
			else
			{
				*pcbValue = 0;
				return ERR_INSUFF_BUFFER;
			}
		}
		break;
	case SQL_C_BINARY:
	default:
		{
			//No convertion available
			return ERR_NOTCONVERTABLE;
		}
		break;
	}
	
	return err;
}


SWORD ISAMGetValueFromVariant(VARIANT			&vVariantVal,
							  SWORD             fCType, 
							  PTR               rgbValue, 
							  SDWORD            cbValueMax, 
							  SDWORD FAR        *pcbValue,
							  SWORD             wbemVariantType,
							  BSTR				syntaxStr,
							  SDWORD			maxLenVal,
							  long              myVirIndex)
{
	SWORD err = NO_ISAM_ERR;
	SWORD wDSDT = 0;
	SWORD dummy1 = 0;
	UDWORD cbPrecision = 0;

	VARTYPE varType1 = V_VT(&vVariantVal);
	switch( varType1 )
	{
	case VT_NULL:
	{
		*pcbValue = SQL_NULL_DATA;
	}
		break;
	case VT_I2:
		{
			//Get the value
			short iShortVal = vVariantVal.iVal;

			err = ISAMGet_VT_I2(iShortVal,
								fCType, 
								rgbValue, 
								cbValueMax, 
								pcbValue,
								wbemVariantType,
								syntaxStr,
								maxLenVal
								);
		}
		break;
	case VT_I4:
		{
			//Get the value
			long iValue = vVariantVal.lVal;

			err = ISAMGet_VT_I4(iValue,
								fCType, 
								rgbValue, 
								cbValueMax, 
								pcbValue,
								wbemVariantType,
								syntaxStr,
								maxLenVal
								);
		}
		break;
	case VT_UI1:
		{
			//Get the value
			UCHAR iUcharVal = vVariantVal.bVal;

			err = ISAMGet_VT_UI1(iUcharVal,
								fCType, 
								rgbValue, 
								cbValueMax, 
								pcbValue,
								wbemVariantType,
								syntaxStr,
								maxLenVal
								);
		}
		break;
	case VT_BSTR:
		{
			//Get the value
			BSTR pString = vVariantVal.bstrVal;

			err = ISAMGet_VT_BSTR(pString,
								fCType, 
								rgbValue, 
								cbValueMax, 
								pcbValue,
								wbemVariantType,
								syntaxStr,
								maxLenVal
								);

			//Null terminate this string
			if (cbValueMax > *pcbValue)
			{
				((char*)rgbValue)[*pcbValue] = '\0';
//				ODBCTRACE (_T("Null terminating this string"));
			}
			else
			{
//				ODBCTRACE (_T("Not Null terminating this string"));
			}
		}
		break;
	case VT_R8:
		{
			//Get the value
			double dblVal = vVariantVal.dblVal;

			err = ISAMGet_VT_R8(dblVal,
								fCType, 
								rgbValue, 
								cbValueMax, 
								pcbValue,
								wbemVariantType,
								syntaxStr,
								maxLenVal
								);
		}
		break;
	case VT_R4:
		{
			//Get the value
			float fltVal = vVariantVal.fltVal;

			err = ISAMGet_VT_R4(fltVal,
								fCType, 
								rgbValue, 
								cbValueMax, 
								pcbValue,
								wbemVariantType,
								syntaxStr,
								maxLenVal
								);
		}
		break;
	case VT_BOOL:
		{
			//Get the value

			VARIANT_BOOL fBool = vVariantVal.boolVal;

			err = ISAMGet_VT_BOOL(fBool,
								fCType, 
								rgbValue, 
								cbValueMax, 
								pcbValue,
								wbemVariantType,
								syntaxStr,
								maxLenVal
								);
		}
		break;
	default:
		{
			//Before we quit, check whether it is a VT_ARRAY
			BOOL fIsVT_ARRAY = FALSE;
			SWORD wStatus = ISAM_ERROR;

			
			BOOL fIsBinaryOutput = (fCType == SQL_C_BINARY);
			
			if ( varType1 == (VT_ARRAY|VT_UI1 ))
			{
				//If no WBEM variant type specified use default
				if (!wbemVariantType)
					wbemVariantType = WBEM_VARIANT_VT_ARRAY_UI1;


				ISAMGetDataSourceDependantTypeInfo
							((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);

				//Get the precision for a single item in array
				{
				
					UCHAR ubVal = 0;
					cbPrecision = UTINYINT_PRECISION;

					if (myVirIndex == -1)
					{
						//String display for all elements
						wStatus = ISAMGetArrayInfo (vVariantVal, ubVal, 
							rgbValue, cbValueMax, pcbValue, fIsBinaryOutput, wDSDT, cbPrecision, myVirIndex);
					}
					else
					{
						//others
						SAFEARRAY FAR* pArray = vVariantVal.parray;
						if ( SUCCEEDED(SafeArrayGetElement(pArray, &myVirIndex, &ubVal)) )
						{
							err = ISAMGet_VT_UI1(ubVal,
												fCType, 
												rgbValue, 
												cbValueMax, 
												pcbValue,
												wbemVariantType,
												syntaxStr,
												maxLenVal
												);

							wStatus = NO_ISAM_ERR;

							if (err == ERR_INSUFF_BUFFER)
								wStatus = ISAM_TRUNCATION;

							if (err == ISAM_ERROR)
								wStatus = ISAM_ERROR;
						}
					}
				}

				
			}
			else if (( varType1 == (VT_ARRAY|VT_I4)))
			{
				//If no WBEM variant type specified use default
				if (!wbemVariantType)
					wbemVariantType = WBEM_VARIANT_VT_ARRAY_I4;


				ISAMGetDataSourceDependantTypeInfo
							((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);

				//Get the precision for a single item in array
				if (wDSDT == WBEM_DSDT_UINT16_ARRAY)
				{
					USHORT wVal = 0;
					cbPrecision = SMALLINT_PRECISION;

					if (myVirIndex == -1)
					{
						//String display for all elements
						wStatus = ISAMGetArrayInfo (vVariantVal, wVal, 
							rgbValue, cbValueMax, pcbValue, fIsBinaryOutput, wDSDT, cbPrecision, myVirIndex);
					}
					else
					{
						//others
						SAFEARRAY FAR* pArray = vVariantVal.parray;
						if ( SUCCEEDED(SafeArrayGetElement(pArray, &myVirIndex, &wVal)) )
						{
							err = ISAMGet_VT_I4(wVal,
												fCType, 
												rgbValue, 
												cbValueMax, 
												pcbValue,
												wbemVariantType,
												syntaxStr,
												maxLenVal
												);

							wStatus = NO_ISAM_ERR;

							if (err == ERR_INSUFF_BUFFER)
								wStatus = ISAM_TRUNCATION;

							if (err == ISAM_ERROR)
								wStatus = ISAM_ERROR;
						}
					}
				}
				else if (wDSDT == WBEM_DSDT_UINT32_ARRAY)
				{
					ULONG lValue = 0;
					cbPrecision = ULONG_PRECISION;

					if (myVirIndex == -1)
					{
						//String display for all elements
						wStatus = ISAMGetArrayInfo (vVariantVal, lValue, 
							rgbValue, cbValueMax, pcbValue, fIsBinaryOutput, wDSDT, cbPrecision, myVirIndex);
					}
					else
					{
						//others
						SAFEARRAY FAR* pArray = vVariantVal.parray;
						if ( SUCCEEDED(SafeArrayGetElement(pArray, &myVirIndex, &lValue)) )
						{
							err = ISAMGet_VT_I4(lValue,
												fCType, 
												rgbValue, 
												cbValueMax, 
												pcbValue,
												wbemVariantType,
												syntaxStr,
												maxLenVal
												);

							wStatus = NO_ISAM_ERR;

							if (err == ERR_INSUFF_BUFFER)
								wStatus = ISAM_TRUNCATION;

							if (err == ISAM_ERROR)
								wStatus = ISAM_ERROR;
						}
					}
				}
				else
				{
					//SINT32
					long lValue = 0;
					cbPrecision = ULONG_PRECISION + 1;

					if (myVirIndex == -1)
					{
						//String display for all elements
						wStatus = ISAMGetArrayInfo (vVariantVal, lValue, 
								rgbValue, cbValueMax, pcbValue, fIsBinaryOutput, wDSDT, cbPrecision, myVirIndex);
					}
					else
					{
						//others
						SAFEARRAY FAR* pArray = vVariantVal.parray;
						if ( SUCCEEDED(SafeArrayGetElement(pArray, &myVirIndex, &lValue)) )
						{
							err = ISAMGet_VT_I4(lValue,
												fCType, 
												rgbValue, 
												cbValueMax, 
												pcbValue,
												wbemVariantType,
												syntaxStr,
												maxLenVal
												);

							wStatus = NO_ISAM_ERR;

							if (err == ERR_INSUFF_BUFFER)
								wStatus = ISAM_TRUNCATION;

							if (err == ISAM_ERROR)
								wStatus = ISAM_ERROR;
						}
					}
				}

				
			}
			else if ((varType1 == (VT_ARRAY|VT_BOOL)))
			{
				BOOL fBoolVal = TRUE;

				wDSDT = WBEM_DSDT_BOOL_ARRAY;
				cbPrecision = 1;

				if (myVirIndex == -1)
				{
					//String display for all elements
					wStatus = ISAMGetArrayInfo (vVariantVal, fBoolVal, 
							rgbValue, cbValueMax, pcbValue, fIsBinaryOutput, wDSDT, cbPrecision, myVirIndex);
				}
				else
				{
					//others
					SAFEARRAY FAR* pArray = vVariantVal.parray;
					if ( SUCCEEDED(SafeArrayGetElement(pArray, &myVirIndex, &fBoolVal)) )
					{
						err = ISAMGet_VT_BOOL((VARIANT_BOOL) fBoolVal,
											fCType, 
											rgbValue, 
											cbValueMax, 
											pcbValue,
											wbemVariantType,
											syntaxStr,
											maxLenVal
											);

						wStatus = NO_ISAM_ERR;

						if (err == ERR_INSUFF_BUFFER)
							wStatus = ISAM_TRUNCATION;

						if (err == ISAM_ERROR)
							wStatus = ISAM_ERROR;
					}
				}
			}
			else if ((varType1 == (VT_ARRAY|VT_I2)))
			{
				short wVal = 0;

				//If no WBEM variant type specified use default
				if (!wbemVariantType)
					wbemVariantType = WBEM_VARIANT_VT_ARRAY_I2;


				ISAMGetDataSourceDependantTypeInfo
							((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);

				//Get the precision for a single item in array
				if (wDSDT == WBEM_DSDT_SINT8_ARRAY)
				{
					//char bVal = 0;
					short bVal = 0;
					cbPrecision = UTINYINT_PRECISION + 1;

					if (myVirIndex == -1)
					{
						//String display for all elements
						wStatus = ISAMGetArrayInfo (vVariantVal, bVal, 
							rgbValue, cbValueMax, pcbValue, fIsBinaryOutput, wDSDT, cbPrecision, myVirIndex);
					}
					else
					{
						//others
						SAFEARRAY FAR* pArray = vVariantVal.parray;
						if ( SUCCEEDED(SafeArrayGetElement(pArray, &myVirIndex, &bVal)) )
						{
							err = ISAMGet_VT_I2(bVal,
								fCType, 
								rgbValue, 
								cbValueMax, 
								pcbValue,
								wbemVariantType,
								syntaxStr,
								maxLenVal
								);

							wStatus = NO_ISAM_ERR;

							if (err == ERR_INSUFF_BUFFER)
								wStatus = ISAM_TRUNCATION;

							if (err == ISAM_ERROR)
								wStatus = ISAM_ERROR;
						}
					}
				}
				else if (wDSDT == WBEM_DSDT_SINT16_ARRAY)
				{
					short wVal = 0;
					cbPrecision = SMALLINT_PRECISION + 1;

					if (myVirIndex == -1)
					{
						//String display for all elements
						wStatus = ISAMGetArrayInfo (vVariantVal, wVal, 
							rgbValue, cbValueMax, pcbValue, fIsBinaryOutput, wDSDT, cbPrecision, myVirIndex);
					}
					else
					{
						//others
						SAFEARRAY FAR* pArray = vVariantVal.parray;
						if ( SUCCEEDED(SafeArrayGetElement(pArray, &myVirIndex, &wVal)) )
						{
							err = ISAMGet_VT_I2(wVal,
								fCType, 
								rgbValue, 
								cbValueMax, 
								pcbValue,
								wbemVariantType,
								syntaxStr,
								maxLenVal
								);

							wStatus = NO_ISAM_ERR;

							if (err == ERR_INSUFF_BUFFER)
								wStatus = ISAM_TRUNCATION;

							if (err == ISAM_ERROR)
								wStatus = ISAM_ERROR;
						}
					}
				}
			}
			else if ((varType1 == (VT_ARRAY|VT_R4)))
			{
				float fltVal = (float)0.0;

				//If no WBEM variant type specified use default
				if (!wbemVariantType)
					wbemVariantType = WBEM_VARIANT_VT_ARRAY_R4;


				ISAMGetDataSourceDependantTypeInfo
							((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);

				if (myVirIndex == -1)
				{
					//String display for all elements
					wStatus = ISAMGetArrayInfo (vVariantVal, fltVal, 
						rgbValue, cbValueMax, pcbValue, fIsBinaryOutput, wDSDT, cbPrecision, myVirIndex);
				}
				else
				{
					//others
					SAFEARRAY FAR* pArray = vVariantVal.parray;
					if ( SUCCEEDED(SafeArrayGetElement(pArray, &myVirIndex, &fltVal)) )
					{
						err = ISAMGet_VT_R4(fltVal,
							fCType, 
							rgbValue, 
							cbValueMax, 
							pcbValue,
							wbemVariantType,
							syntaxStr,
							maxLenVal
							);

						wStatus = NO_ISAM_ERR;

						if (err == ERR_INSUFF_BUFFER)
							wStatus = ISAM_TRUNCATION;

						if (err == ISAM_ERROR)
							wStatus = ISAM_ERROR;
					}
				}
			}
			else if ((varType1 == (VT_ARRAY|VT_R8)))
			{
				double dblVal = 0;

				//If no WBEM variant type specified use default
				if (!wbemVariantType)
					wbemVariantType = WBEM_VARIANT_VT_ARRAY_R8;


				ISAMGetDataSourceDependantTypeInfo
							((SWORD)wbemVariantType, syntaxStr, maxLenVal, wDSDT, dummy1, cbPrecision);

				if (myVirIndex == -1)
				{
					//String display for all elements
					wStatus = ISAMGetArrayInfo (vVariantVal, dblVal, 
						rgbValue, cbValueMax, pcbValue, fIsBinaryOutput, wDSDT, cbPrecision, myVirIndex);
				}
				else
				{
					//others
					SAFEARRAY FAR* pArray = vVariantVal.parray;
					if ( SUCCEEDED(SafeArrayGetElement(pArray, &myVirIndex, &dblVal)) )
					{
						err = ISAMGet_VT_R8(dblVal,
							fCType, 
							rgbValue, 
							cbValueMax, 
							pcbValue,
							wbemVariantType,
							syntaxStr,
							maxLenVal
							);

						wStatus = NO_ISAM_ERR;

						if (err == ERR_INSUFF_BUFFER)
							wStatus = ISAM_TRUNCATION;

						if (err == ISAM_ERROR)
							wStatus = ISAM_ERROR;
					}
				}
			}
			else if ((varType1 == (VT_ARRAY|VT_BSTR)))
			{
		
				if (myVirIndex == -1)
				{
					//String display for all elements
					wStatus = ISAMGetArrayStringInfo (vVariantVal, syntaxStr, 
							rgbValue, cbValueMax, pcbValue, fIsBinaryOutput, myVirIndex);
				}
				else
				{
					//others
					BSTR pString = NULL;
					SAFEARRAY FAR* pArray = vVariantVal.parray;
					if ( SUCCEEDED(SafeArrayGetElement(pArray, &myVirIndex, &pString)) )
					{
						err = ISAMGet_VT_BSTR(pString,
							fCType, 
							rgbValue, 
							cbValueMax, 
							pcbValue,
							wbemVariantType,
							syntaxStr,
							maxLenVal
							);

						wStatus = NO_ISAM_ERR;

						if (err == ERR_INSUFF_BUFFER)
							wStatus = ISAM_TRUNCATION;

						if (err == ISAM_ERROR)
							wStatus = ISAM_ERROR;

						//SAI ADDED
						SysFreeString(pString);
					}
				}

				if (wStatus == NO_ISAM_ERR)
				{
					//Null terminate this string
					if (cbValueMax > *pcbValue)
					{
						((char*)rgbValue)[*pcbValue] = '\0';
//						ODBCTRACE (_T("Null terminating this string"));
					}
					else
					{
//						ODBCTRACE (_T("Not Null terminating this string"));
					}
				}
			}
			
			if (wStatus == ISAM_TRUNCATION)
			{
				//Truncated data
				return ISAM_TRUNCATION;
			}
			else if (wStatus != NO_ISAM_ERR)
			{
				//No convertion available
				return wStatus;
			}
		}
		break;
	}

	return err;
}

/***************************************************************************/

// Checked for SetInterfaceSecurityEx on IWbemServices and IEnumWbemClassObject

IMPLEMENT_SERIAL (CNamespace, CObject, 1)

SWORD INTFUNC ISAMGetNestedNamespaces (char *parentName, char *namespaceName,
									   IWbemServices *pGatewayIn, 
									   DWORD dwAuthLevelIn, DWORD dwImpLevelIn,
									   char *servername,
//									   WBEM_LOGIN_AUTHENTICATION loginMethod, 
									   char *username, char *password, BOOL fIntpretEmptPwdAsBlank,
									   char* locale, char* authority,
									   CMapStringToOb* map, BOOL bDeep)
{
	// Always want to return absolute names here
	char *absName = NULL;
	IWbemServicesPtr pGateway;
	DWORD dwAuthLevel = 0;
	DWORD dwImpLevel = 0;

	COAUTHIDENTITY* pAuthIdent = NULL;

	if (NULL == pGatewayIn)
	{
		pGateway = NULL;
		ISAMGetGatewayServer (pGateway,
							(LPUSTR)servername, 
//							loginMethod, 
							(LPUSTR)namespaceName, (LPUSTR)username, (LPUSTR)password, (LPUSTR)locale, (LPUSTR)authority,
							dwAuthLevel, dwImpLevel, fIntpretEmptPwdAsBlank , &pAuthIdent);
		if (pGateway == NULL) 
			return ISAM_ERROR;
		// the passed in name is absolute
		absName = new char [strlen (namespaceName) +1];
		absName[0] = 0;
		strcpy (absName, namespaceName);
 		map->SetAt (absName, new CNamespace (absName));  // add self

	}
	else
	{
		pGateway = pGatewayIn;
		pGateway->AddRef ();

		dwAuthLevel = dwAuthLevelIn;
		dwImpLevel  = dwImpLevelIn;

		// the passed in name is relative - so build absolute - and add to map 
		absName = new char [strlen (parentName) + strlen(namespaceName) + 2 
								  + 1 /* for separator */];
		absName[0] = 0;
		strcpy (absName, parentName);
		strcat (absName, "\\");   // add separator
		strcat (absName, namespaceName);
 		map->SetAt (absName, new CNamespace (absName));  
	}

	if (!bDeep)
	{
		delete absName;
		return NO_ISAM_ERR;
	}


	//cloaking
	BOOL fIsLocalConnection = IsLocalServer(servername);

	if ( fIsLocalConnection && IsW2KOrMore() )
	{
		WbemSetDynamicCloaking(pGateway, dwAuthLevel, dwImpLevel);
	}

	//Enumerate children and recurse
	IEnumWbemClassObject* pNamespaceEnum = NULL;
	BSTR nspaceBSTR = SysAllocString(WBEMDR32_L_NAMESPACE);

	IWbemContext* pContext = ISAMCreateLocaleIDContextObject(locale);
	if ( FAILED(pGateway->CreateInstanceEnum(nspaceBSTR, 0, pContext, &pNamespaceEnum)) )
	{
		delete absName;
		SysFreeString(nspaceBSTR);

		if (pContext)
			pContext->Release();

		//Should be not also Release pGateway ?

		return NO_ISAM_ERR;
	}
	else
	{
		ISAMSetCloaking2(pNamespaceEnum, 
						fIsLocalConnection, 
						IsW2KOrMore(), 
						dwAuthLevel, 
						dwImpLevel,
						pAuthIdent);
/*
		if ( fIsLocalConnection && IsW2KOrMore() )
		{
			WbemSetDynamicCloaking(pNamespaceEnum, dwAuthLevel, dwImpLevel);
		}
		else
		{
			//Set Dcom blanket
			SetInterfaceSecurityEx(pNamespaceEnum, pAuthIdent, gpPrincipal, dwAuthLevel, dwImpLevel);
		}
*/
		SysFreeString(nspaceBSTR);

		if (pContext)
			pContext->Release();

		if (!pNamespaceEnum)
		{
			delete absName;
			return NO_ISAM_ERR;

		}	
		ULONG uRet = 0;
		IWbemClassObject* pNewInst = NULL;
		pNamespaceEnum->Reset();

		while ( S_OK == pNamespaceEnum->Next(-1, 1, &pNewInst, &uRet) )
		{

			VARIANTARG var;
//SAI ADDED no need to init			VariantInit (&var);

			BSTR nameBSTR = SysAllocString(WBEMDR32_L_NAME);
			pNewInst->Get(nameBSTR, 0, &var, NULL, NULL);
			SysFreeString(nameBSTR);

			IWbemServicesPtr pNewGateway = NULL;

			COAUTHIDENTITY* pNewAuthIdent = NULL;

			//Get user and password fields
#ifdef USING_ABSPATH
			char testBuff [MAX_QUALIFIER_NAME_LENGTH + 1];
			testBuff[0] = 0;
			wcstombs(testBuff, var.bstrVal, MAX_QUALIFIER_NAME_LENGTH);
			testBuff[MAX_QUALIFIER_NAME_LENGTH] = 0;
				
			char* cTemp2 = new char [strlen (absName) + strlen(testBuff) + 2];
			cTemp2[0] = 0;
			lstrcpy(cTemp2,absName);
			lstrcat(cTemp2, "\\");
			lstrcat(cTemp2,testBuff);
			ISAMGetGatewayServer (pNewGateway, servername, 
//							loginMethod, 
							cTemp2, username, password, locale, authority, &pNewAuthIdent);		
			delete cTemp2;

			if (pNewGateway)
#else
			BSTR myRelativeNamespace =  var.bstrVal;
			CBString cbNS (myRelativeNamespace, FALSE);

			IWbemContext* mycontext = ISAMCreateLocaleIDContextObject(locale);
			if ( SUCCEEDED(pGateway->OpenNamespace(cbNS.GetString(),  0, mycontext, &pNewGateway, NULL)) )
#endif
			{
				BOOL fIsLocalConnection = IsLocalServer(servername);

				ISAMSetCloaking2(pNewGateway, 
								fIsLocalConnection, 
								IsW2KOrMore(), 
								dwAuthLevel, 
								dwImpLevel,
								pNewAuthIdent);

/*
				if ( fIsLocalConnection && IsW2KOrMore() )
				{
					WbemSetDynamicCloaking(pNewGateway, dwAuthLevel, dwImpLevel);
				}
				else
				{
					//Set Dcom blanket
					SetInterfaceSecurityEx(pNewGateway, pNewAuthIdent, gpPrincipal, dwAuthLevel, dwImpLevel);
				}
*/
				size_t len = wcstombs (NULL, var.bstrVal, MB_CUR_MAX);
				if (-1 != len)
				{
					char *name = new char [len + 1];
					name[0] = 0;
					wcstombs (name, var.bstrVal, len);
					name [len] = 0;
					ISAMGetNestedNamespaces (absName, name, pNewGateway, dwAuthLevel, dwImpLevel, servername, 
//						loginMethod,
											username, password, fIntpretEmptPwdAsBlank, locale, authority, map);
					delete name;
				}

				if (pNewAuthIdent)
				{
					WbemFreeAuthIdentity( pNewAuthIdent );
					pNewAuthIdent = NULL;
				}
			}
#ifndef USING_ABSPATH
			if (mycontext)
				mycontext->Release();
#endif
			
			VariantClear(&var);
		}

		//Tidy Up
		if (pNamespaceEnum)
		{
			pNamespaceEnum->Release();
		}
	}	
	delete absName;

	if (pAuthIdent )
	{
		WbemFreeAuthIdentity( pAuthIdent );
		pAuthIdent = NULL;
	}

	return NO_ISAM_ERR;
}

/***************************************************************************/

SWORD INTFUNC ISAMBuildTree (HTREEITEM hParent,
						 char *namespaceName, //relative name
						 CTreeCtrl& treeCtrl,
						 CConnectionDialog& dialog,
						 char *server,
//						 WBEM_LOGIN_AUTHENTICATION loginMethod,
						 char *username,
						 char *password,
						 BOOL fIntpretEmptPwdAsBlank,
						 char *locale,
						 char *authority,
						 BOOL fNeedChildren,
						 BOOL deep,
						 HTREEITEM& hTreeItem)
{
	// Note the first name in the tree will be displayed as absolute
	// could strip off the non- root bit - might do it
	ODBCTRACE ("\nWBEM ODBC Driver :ISAMBuildTree\n");
	
	// Add self
	hTreeItem = dialog.InsertItem(treeCtrl, hParent, namespaceName);

	ODBCTRACE ("\nWBEM ODBC Driver :Add Self :");
	ODBCTRACE (namespaceName);
	ODBCTRACE ("\n");

	//Enumerate children and recurse
	//BUT ONLY IF REQUESTED
	if (fNeedChildren)
	{
		ODBCTRACE ("\nWBEM ODBC Driver : fNeedChildren = TRUE\n");

		//Work out absolute name of new namespace
		TV_ITEM tvItem2;
		tvItem2.hItem = hTreeItem;
		tvItem2.mask = TVIF_PARAM;
		if (treeCtrl.GetItem (&tvItem2))
		{
			char* txt = ((ISAMTreeItemData*)tvItem2.lParam)->absName;

			return ISAMBuildTreeChildren(hTreeItem, txt, treeCtrl, dialog,
							server, 
//							loginMethod, 
							username, password, fIntpretEmptPwdAsBlank,locale, authority, deep);
		}
		else
		{
			return ISAM_ERROR;
		}
	}
	else
	{
		ODBCTRACE ("\nWBEM ODBC Driver : fNeedChildren = FALSE\n");
	}

	return NO_ISAM_ERR;
}

/***************************************************************************/

// Checked for SetInterfaceSecurityEx on IWbemServices and IEnumWbemClassObject

SWORD INTFUNC ISAMBuildTreeChildren (HTREEITEM hParent,
						 char *namespaceName, //absolute name
						 CTreeCtrl& treeCtrl,
						 CConnectionDialog& dialog,
						 char *server,
//						 WBEM_LOGIN_AUTHENTICATION loginMethod,
						 char *username,
						 char *password,
						 BOOL fIntpretEmptPwdAsBlank,
						 char *locale,
						 char *authority,
						 BOOL deep)
{
	ODBCTRACE ("\nWBEM ODBC Driver : ISAMBuildTreeChildren\n");

	MyImpersonator fred (username, password, authority, "ISAMBuildTreeChildren");

	//Advance to the namespace for which you require the children
	DWORD dwAuthLevel = 0;
	DWORD dwImpLevel = 0;
	COAUTHIDENTITY* pAuthIdent = NULL;

	IWbemServicesPtr pGateway = NULL;
	ISAMGetGatewayServer (pGateway, (LPUSTR)server, 
//										loginMethod, 
										(LPUSTR)namespaceName, (LPUSTR)username, (LPUSTR)password, (LPUSTR)locale, (LPUSTR)authority,
										dwAuthLevel, dwImpLevel, fIntpretEmptPwdAsBlank, &pAuthIdent);

	
	if (pGateway == NULL)
	{
		ODBCTRACE ("\nWBEM ODBC Driver : ISAMBuildTreeChildren : Failed to get gateway server\n");
		return ISAM_ERROR;
	}

	//cloaking
	BOOL fIsLocalConnection = IsLocalServer(server);

	if ( fIsLocalConnection && IsW2KOrMore() )
	{
		WbemSetDynamicCloaking(pGateway, dwAuthLevel, dwImpLevel);
	}

	//Indicate that this node has been checked for children
	TV_ITEM tvItem;
	tvItem.hItem = hParent;
	tvItem.mask = TVIF_PARAM;
	if (treeCtrl.GetItem (&tvItem))
	{
		((ISAMTreeItemData*)tvItem.lParam)->fExpanded = TRUE;
	}


	//Get all children namespaces by fetching instances of __NAMESPACE
	IEnumWbemClassObjectPtr pNamespaceEnum = NULL;
	BSTR nspaceBSTR = SysAllocString(WBEMDR32_L_NAMESPACE);

	
	IWbemContext* pContext = ISAMCreateLocaleIDContextObject(locale);
	SCODE scCI = pGateway->CreateInstanceEnum(nspaceBSTR, 0, pContext, &pNamespaceEnum);
	SysFreeString(nspaceBSTR);

	if (pContext)
		pContext->Release();


	ISAMSetCloaking2(pNamespaceEnum, 
					fIsLocalConnection, 
					IsW2KOrMore(), 
					dwAuthLevel, 
					dwImpLevel,
					pAuthIdent);
/*
	if ( fIsLocalConnection && IsW2KOrMore() )
	{
		WbemSetDynamicCloaking(pNamespaceEnum, dwAuthLevel, dwImpLevel);
	}
	else
	{
		//Set Dcom blanket
		SetInterfaceSecurityEx(pNamespaceEnum, pAuthIdent, gpPrincipal, dwAuthLevel, dwImpLevel);
	}
*/
	if ( FAILED(scCI) || (pNamespaceEnum == NULL) )
	{
		return ISAM_ERROR;
	}

		
	ULONG uRet = 0;
	IWbemClassObjectPtr pNewInst = NULL;
	pNamespaceEnum->Reset();
	while ( S_OK == pNamespaceEnum->Next(-1, 1, &pNewInst, &uRet) )
	{
		//(14)
		VARIANTARG var;
		
		BSTR thenameBSTR = SysAllocString(WBEMDR32_L_NAME);
		pNewInst->Get(thenameBSTR, 0, &var, NULL, NULL);
		SysFreeString(thenameBSTR);

		//RAID 42256
		UINT cpThread = Utility_GetCodePageFromLCID(GetThreadLocale());
		int len = WideCharToMultiByte(cpThread,WC_COMPOSITECHECK, (const wchar_t*)var.bstrVal, -1, 
								NULL, 0, NULL, NULL);

		if (-1 != len)
		{
			char *name = new char [len + 1];

			//RAID 42256
			_bstr_t myValue((BSTR)var.bstrVal);
			Utility_WideCharToDBCS(myValue, &name, len);

			name [len] = '\0';

			//Check if this child already exists in tree
			CString fullPath = namespaceName;
			fullPath += "\\";
			fullPath += name;
			HTREEITEM hDummy;
			if (! dialog.FindAbsName((char*)(LPCTSTR)fullPath, hParent, hDummy) )
			{
				//Add child to tree control
				HTREEITEM newTreeItem = NULL;
				ISAMBuildTree (hParent, name,
						 treeCtrl,
						 dialog,
						 server,
//						 loginMethod,
						 username,
						 password,
						 fIntpretEmptPwdAsBlank,
						 locale,
						 authority,
						 deep,
						 deep,
						 newTreeItem);

				if (deep && newTreeItem)
					dialog.AddNamespaces(newTreeItem, FALSE);
			}

			delete name;
		}

		//Tidy Up
		VariantClear(&var);
	}

	if (pAuthIdent )
	{
		WbemFreeAuthIdentity( pAuthIdent );
		pAuthIdent = NULL;
	}

	return NO_ISAM_ERR;
}

/***************************************************************************/

// Checked for SetInterfaceSecurityEx on IWbemServices

void ISAMGetIWbemServices(LPISAM lpISAM, CSafeWbemServices& mServices, IWbemServicesPtr& myServicesPtr)
{
	myServicesPtr = NULL;
	mServices.GetInterfacePtr(myServicesPtr);
	ISAMPatchUpGatewaySecurity(lpISAM, myServicesPtr);
}



void CSafeWbemServices::Transfer(CSafeWbemServices& original)
{
	m_pStream = original.m_pStream;
	original.m_pStream = NULL;

	m_params = original.m_params;
	original.m_params = NULL;

	m_fValid = original.m_fValid;

	original.m_fValid = FALSE;
}

HRESULT CSafeWbemServices::GetInterfacePtr(IWbemServicesPtr& pServices)
{
	bool bRet = false;

	if(m_pStream)
	{
		HRESULT hr;

		//pop Com pointer out from stream
		//as you are popping into &SmartPointer so increase in ref count
		hr = CoGetInterfaceAndReleaseStream(m_pStream,IID_IWbemServices,(void**)&pServices);
		
		
		m_pStream = NULL;

		if (m_params)
			m_params->m_myStream = NULL;

		bRet = true;

		if ( SUCCEEDED(hr) )
		{
			//push value back into stream
			//as you are CoMarshalling into stream ref count bumped up by one
			hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,pServices,&m_pStream);

			if (m_params)
				m_params->m_myStream = m_pStream;
		}
	}

    return S_OK;
}

// Checked for SetInterfaceSecurityEx on IWbemServices

void CSafeWbemServices::SetInterfacePtr(LPISAM lpISAM, LPUSTR lpQualifierName, SWORD cbQualifierName)
{
	ODBCTRACE("\nWBEM ODBC Driver :CSafeWbemServices::SetInterfacePtr\n");

	//
	//Create interface on Working Thread
	//

	//Create parameter set so that an equivalent one can be created
	//on the working thread. (never used but must exist)
	if (m_params)
	{
		BOOL status = PostSuspensiveThreadMessage(glob_myWorkerThread.GetThreadId(), MYUSRMESS_REMOVE_SERVICES, 0, (LPARAM)m_params);
		m_pStream = NULL;

		delete m_params;
		m_params = NULL;
	}

	m_params = new MyWorkingThreadParams(lpISAM, lpQualifierName, cbQualifierName, m_pStream);

	//post message to create this object on working thread

	ODBCTRACE("\nWBEM ODBC Driver :CSafeWbemServices::SetInterfacePtr : pos 1\n");
	BOOL status = PostSuspensiveThreadMessage(glob_myWorkerThread.GetThreadId(), MYUSRMESS_CREATE_SERVICES, 0, (LPARAM)m_params);
	ODBCTRACE("\nWBEM ODBC Driver :CSafeWbemServices::SetInterfacePtr : pos 2\n");


	m_fValid = ( SUCCEEDED(m_params->sc) ) ? TRUE : FALSE;
	m_pStream = m_params->m_myStream;		
}


CSafeWbemServices::CSafeWbemServices()
{
	m_params = NULL;
	m_fValid = FALSE;
	m_pStream = NULL;
}

CSafeWbemServices::~CSafeWbemServices()
{
	//clean up working thread parameters
	//and IWbemServices object on working thread
	if (m_params)
	{

		BOOL status = PostSuspensiveThreadMessage(glob_myWorkerThread.GetThreadId(), MYUSRMESS_REMOVE_SERVICES, 0, (LPARAM)m_params);
		m_pStream = NULL;

		delete m_params;
		m_params = NULL;
	}
}

void CSafeWbemServices::Invalidate()
{
	if (m_params)
	{
		BOOL status = PostSuspensiveThreadMessage(glob_myWorkerThread.GetThreadId(), MYUSRMESS_REMOVE_SERVICES, 0, (LPARAM)m_params);
		m_pStream = NULL;

		delete m_params;
		m_params = NULL;
	}

	m_fValid = FALSE;
	m_pStream = NULL;
}


BOOL CSafeWbemServices::PostSuspensiveThreadMessage(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
{
	BOOL status = FALSE;

	ODBCTRACE("\nWBEM ODBC Driver : CSafeWbemServices::PostSuspensiveThreadMessage\n");

	EnterCriticalSection(& (glob_myWorkerThread.m_cs) );

	ODBCTRACE("\nWBEM ODBC Driver : CSafeWbemServices::PostSuspensiveThreadMessage : in critical section\n");

	//check data in lParam
	MyWorkingThreadParams* myData = (MyWorkingThreadParams*)lParam;

	//Extract Event Handle
	HANDLE EventHnd = myData->m_EventHnd;

	//make sure the event is in its non-signaled state
	//before posting the thread message
	ResetEvent(EventHnd);

	ODBCTRACE("\nWBEM ODBC Driver : CSafeWbemServices::PostSuspensiveThreadMessage: about to leave critical section\n");

	LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );

	//post message
	ODBCTRACE("\nWBEM ODBC Driver : CSafeWbemServices::PostSuspensiveThreadMessage: PostThreadMessage\n");
	status = PostThreadMessage(idThread, Msg, wParam, lParam);

	if (!status)
	{
		ODBCTRACE("\nWBEM ODBC Driver : CSafeWbemServices::PostSuspensiveThreadMessage: PostThreadMessage failed\n");
	}

	//Make it suspensive
	WaitForSingleObject(EventHnd, INFINITE);
	ODBCTRACE("\nWBEM ODBC Driver : CSafeWbemServices::PostSuspensiveThreadMessage : After wait for single object\n");

	return status;
}

// Checked for SetInterfaceSecurityEx on IWbemServices

LONG OnUserCreateServices(UINT wParam, LONG lParam)
{
	ODBCTRACE("\n\n*****WBEM ODBC Driver : OnUserCreateServices*****\n\n");
	COleInitializationManager oleManager;

	EnterCriticalSection(& (glob_myWorkerThread.m_cs) );

	ODBCTRACE("\nWBEM ODBC Driver : OnUserCreateServices : entered critial section\n");

	//this is done on the worker thread
	
	//check data in lParam
	MyWorkingThreadParams* myData = (MyWorkingThreadParams*)lParam;

	//Tidy up existing stream
	if(myData->m_myStream)
	{
		//pop interface into smart pointer.
		//As it goes into &SmartPointer ref count stays the same

		IWbemServicesPtr tempy;
		HRESULT hr = CoGetInterfaceAndReleaseStream(myData->m_myStream, IID_IWbemServices, (void**)&tempy);

		//when SmartPointer goes out of scope it will call Release and free up interface cleanly
	}
	myData->m_myStream = NULL;

	//Setup impersonation on working thread
	MyImpersonator im (myData->m_lpISAM, "Worker Thread:CreateServices");

	//now add IWbemServices
	IWbemServicesPtr tempy = NULL;
	ISAMGetGatewayServer(tempy, myData->m_lpISAM, myData->m_lpQualifierName, myData->m_cbQualifierName);
	myData->pGateway = tempy.Detach();


//	CBString myServerStr;
//	myServerStr.AddString( (LPSTR)myData->m_lpISAM->szServer, FALSE );
//	CServerLocationCheck myCheck (myServerStr);
	BOOL fIsLocalConnection = myData->m_lpISAM->fIsLocalConnection;//myCheck.IsLocal();

	if ( fIsLocalConnection && (myData->m_lpISAM->fW2KOrMore) )
	{
		WbemSetDynamicCloaking(myData->pGateway, myData->m_lpISAM->dwAuthLevel, myData->m_lpISAM->dwImpLevel);
	}


	if (myData->pGateway)
	{
		HRESULT hr;

        ODBCTRACE("\nWBEM ODBC Driver OnUserCreateServices : succeeded to create IWbemServices on working thread\n");

		//push Com pointer in stream
		//The CoMarshalling will bump up ref count by one
		if (SUCCEEDED(hr =
            CoMarshalInterThreadInterfaceInStream(IID_IWbemServices, myData->pGateway, &(myData->m_myStream))))
        {
		    //
		    //Created services pointer now to be marshalled in stream
		    myData->sc = WBEM_S_NO_ERROR;
        }
        else
    		myData->sc = hr;
	}
	else
	{
		myData->sc = WBEM_E_FAILED;
		ODBCTRACE("\nWBEM ODBC Driver OnUserCreateServices : failed to create IWbemServices on working thread\n");
	}

	//so that WaitForSingleObject returns
	SetEvent(myData->m_EventHnd);

	LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );
	ODBCTRACE("\nWBEM ODBC Driver : OnUserCreateServices : left critial section\n");

	return 0;
}

LONG OnUserRemoveServices(UINT wParam, LONG lParam)
{
	ODBCTRACE("\n\n*****WBEM ODBC Driver : OnUserRemoveServices*****\n\n");
	COleInitializationManager oleManager;

	EnterCriticalSection(& (glob_myWorkerThread.m_cs) );

	ODBCTRACE("\nWBEM ODBC Driver : OnUserRemoveServices : entered crital section\n");

	//this is done on the worker thread

	//check data in lParam
	MyWorkingThreadParams* myData = (MyWorkingThreadParams*)lParam;

	ODBCTRACE("\nWBEM ODBC Driver : OnUserRemoveServices : about to Release IWbemServices\n");

	//Remove the interface form the stream
	if(myData->m_myStream)
	{
		//the release should pop any Com pointers out from stream
		//the use of smart pointers should call Release to free up 
		// the Com pointer

	
		IWbemServicesPtr tempy = NULL;
		HRESULT hr = CoGetInterfaceAndReleaseStream(myData->m_myStream, IID_IWbemServices, (void**)&tempy);

		myData->m_myStream = NULL;
	}

	if (myData->pGateway)
	{
		//remove the IWbemServices pointer from worker thread
		myData->pGateway->Release();
		myData->pGateway = NULL;
	}

	//so that WaitForSingleObject returns
	SetEvent(myData->m_EventHnd);

	LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );

	ODBCTRACE("\nWBEM ODBC Driver : OnUserRemoveServices : left critial section\n");

	return 0;
}


LONG OnUserCreateEnum(UINT wParam, LONG lParam)
{
	ODBCTRACE("\n\n*****WBEM ODBC Driver : OnUserCreateEnum*****\n\n");
	COleInitializationManager oleManager;

	EnterCriticalSection(& (glob_myWorkerThread.m_cs) );

	ODBCTRACE("\nWBEM ODBC Driver : OnUserCreateEnum : entered critial section\n");

	//this is done on the worker thread

	//check data in lParam
	MyWorkingThreadParams* myData = (MyWorkingThreadParams*)lParam;

	//now add IEnumWbemClassObject
	//first check if you need to ExecQuery or CreateInstanceEnum
	//remember to return scode in myData
	

	if(myData->m_myStream)
	{
		//the release should pop any Com pointers out from stream
		//the use of smart pointers should call Release to free up 
		// the Com pointer

		IEnumWbemClassObjectPtr tempy = NULL;
		HRESULT hr = CoGetInterfaceAndReleaseStream(myData->m_myStream, IID_IEnumWbemClassObject, (void**)&tempy);
	}
	myData->m_myStream = NULL;

	//Create tempory context object
	IWbemContext* pContext = ISAMCreateLocaleIDContextObject(myData->m_lpISAM->m_Locale);

	//Setup impersonation on working thread
	MyImpersonator im (myData->m_lpISAM, "Worker Thread");

	IWbemServicesPtr myServicesPtr = NULL;
	ISAMGetIWbemServices(myData->m_lpISAM, *(myData->pServ), myServicesPtr);

//	CBString myServerStr;
//	myServerStr.AddString( (LPSTR)myData->m_lpISAM->szServer, FALSE );
//	CServerLocationCheck myCheck (myServerStr);
	BOOL fIsLocalConnection = myData->m_lpISAM->fIsLocalConnection;//myCheck.IsLocal();

	if ( fIsLocalConnection && (myData->m_lpISAM->fW2KOrMore) )
	{
		WbemSetDynamicCloaking(myServicesPtr, myData->m_lpISAM->dwAuthLevel, myData->m_lpISAM->dwImpLevel);
	}

	DWORD dwSize;
	char buffer[1001];
	buffer[0] = 0;
	GetUserName(buffer, &dwSize);
	CString lpMessage;
	lpMessage.Format("\nUser Account just before Enum or ExecQuery : %s\n", buffer);

	ODBCTRACE(lpMessage);

	if ( (myData->fIsExecQuery) == WMI_CREATE_INST_ENUM )
	{
		//CreateInstanceEnum
		myData->sc = myServicesPtr->CreateInstanceEnum(myData->tableName, 0, pContext, &(myData->pEnum));
	}
	else 
	{
		//ExecQuery
		long flags = 0;
		
		if ( (myData->fIsExecQuery) == WMI_EXEC_FWD_ONLY ) 
			flags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;
		else
		if ( (myData->fIsExecQuery) == WMI_PROTOTYPE ) 
			flags = WBEM_FLAG_PROTOTYPE; 

		BSTR wqlBSTR = SysAllocString(WBEMDR32_L_WQL);

		myData->sc = myServicesPtr->ExecQuery(wqlBSTR, myData->sqltextBSTR, flags, pContext, &(myData->pEnum));

		SysFreeString(wqlBSTR);
	}
	

	//Tidy up
	if (pContext)
		pContext->Release();

	
	if ( SUCCEEDED(myData->sc) )
	{
		ODBCTRACE("\nWBEM ODBC Driver OnUserCreateEnum : succeeded to create IEnumWbemClassObject on working thread\n");


		if (myData->pEnum)
		{
			//push Com pointer in stream
			//The CoMarshalling will bump the ref count up by one
			if (FAILED(
                CoMarshalInterThreadInterfaceInStream(IID_IEnumWbemClassObject, myData->pEnum, &(myData->m_myStream))))
            {
        		ODBCTRACE("\nWBEM ODBC Driver OnUserCreateEnum : failed to CoMarshalInterThreadInterfaceInStream\n");
            }
		}
	}
	else
	{
		ODBCTRACE("\nWBEM ODBC Driver OnUserCreateEnum : failed to create IEnumWbemClassObject on working thread\n");
	}

	//so that WaitForSingleObject returns
	SetEvent(myData->m_EventHnd);

	LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );

	ODBCTRACE("\nWBEM ODBC Driver : OnUserCreateEnum : left critial section\n");

	return 0;
}


LONG OnUserRemoveEnum(UINT wParam, LONG lParam)
{
	ODBCTRACE("\n\n*****WBEM ODBC Driver : OnUserRemoveEnum*****\n\n");
	COleInitializationManager oleManager;

	EnterCriticalSection(& (glob_myWorkerThread.m_cs) );

	ODBCTRACE("\nWBEM ODBC Driver : OnUserRemoveEnum : entered crital section\n");

	//this is done on the worker thread

	//check data in lParam
	MyWorkingThreadParams* myData = (MyWorkingThreadParams*)lParam;

	ODBCTRACE("\nWBEM ODBC Driver : OnUserRemoveEnum : about to Release IEnumWbemClassObject\n");


	if(myData->m_myStream)
	{
		//the release should pop any Com pointers out from stream
		//the use of smart pointers should call Release to free up 
		// the Com pointer


		IEnumWbemClassObjectPtr tempy = NULL;
		HRESULT hr = CoGetInterfaceAndReleaseStream(myData->m_myStream, IID_IEnumWbemClassObject, (void**)&tempy);

	}
	myData->m_myStream = NULL;

	if (myData->pEnum)
	{
		//remove the IWbemServices pointer from worker thread
		myData->pEnum->Release();
		myData->pEnum = NULL;
	}

	//so that WaitForSingleObject returns
	SetEvent(myData->m_EventHnd);

	LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );

	ODBCTRACE("\nWBEM ODBC Driver : OnUserRemoveEnum : left critial section\n");

	return 0;
}

void OnIncreamentRefCount(UINT wParam, LONG lParam)
{
	EnterCriticalSection(& (glob_myWorkerThread.m_cs) );

	++glob_myWorkerThread.m_cRef;

	CString message;
	message.Format ("\n***** Working thread count (increment) = %ld *****\n", glob_myWorkerThread.m_cRef);
	ODBCTRACE(message);

	//check data in lParam
	MyWorkingThreadParams* myData = (MyWorkingThreadParams*)lParam;

	//so that WaitForSingleObject returns
	SetEvent(myData->m_EventHnd);

	LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );

}


void OnDecreamentRefCount(UINT wParam, LONG lParam)
{
	EnterCriticalSection(& (glob_myWorkerThread.m_cs) );

	if (glob_myWorkerThread.m_cRef)
	{
		--glob_myWorkerThread.m_cRef;
		CString message;
		message.Format ("\n***** Working thread count (descrement) = %ld *****\n", glob_myWorkerThread.m_cRef);
		ODBCTRACE(message);
	}

	//check data in lParam
	MyWorkingThreadParams* myData = (MyWorkingThreadParams*)lParam;

	//so that WaitForSingleObject returns
	SetEvent(myData->m_EventHnd);

	LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );
}


//DWORD WINAPI MyWorkerThread(LPVOID myVal)
unsigned __stdcall MyWorkerThread(LPVOID myVal)
{
	//this is done on the worker thread
	DWORD dwThreadId = GetCurrentThreadId();

	//force a thread message queue to be created 
	MSG msg;
	PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

	//so that WaitForSingleObject returns

	//infinate loop for thread to read messages
	BOOL status = FALSE;
	BOOL myLoop = TRUE;
	while (myLoop)
	{
		//look for messages in the range WM_USER, MYUSRMESS_REMOVE_ENUM
		status = PeekMessage(&msg, NULL, WM_USER, MYUSRMESS_REMOVE_ENUM, PM_NOREMOVE);

		if (status)
		{
			switch (msg.message)
			{
			case MYUSRMESS_CREATE_SERVICES:
			{
				ODBCTRACE("\nWBEM ODBC Driver : MyWorkerThread : MYUSRMESS_CREATE_SERVICES\n");
				PeekMessage(&msg, NULL, MYUSRMESS_CREATE_SERVICES, MYUSRMESS_CREATE_SERVICES, PM_REMOVE);
				OnUserCreateServices(msg.wParam, msg.lParam);
			}
				break;
			case MYUSRMESS_REMOVE_SERVICES:
			{
				ODBCTRACE("\nWBEM ODBC Driver : MyWorkerThread : MYUSRMESS_REMOVE_SERVICES\n");
				PeekMessage(&msg, NULL, MYUSRMESS_REMOVE_SERVICES, MYUSRMESS_REMOVE_SERVICES, PM_REMOVE);
				OnUserRemoveServices(msg.wParam, msg.lParam);
			}
				break;
			case MYUSRMESS_CLOSE_WKERTHRED:
			{
				ODBCTRACE("\nWBEM ODBC Driver : MyWorkerThread : MYUSRMESS_CLOSE_WKERTHRED\n");
				PeekMessage(&msg, NULL, MYUSRMESS_CLOSE_WKERTHRED, MYUSRMESS_CLOSE_WKERTHRED, PM_REMOVE);
				ISAMCloseWorkerThread2(msg.wParam, msg.lParam);
				myLoop = FALSE; //need to exit thread when ISAMCloseWorkerThread2 exists
			}
				break;
			case MYUSRMESS_REFCOUNT_INCR:
			{
				ODBCTRACE("\nWBEM ODBC Driver : MyWorkerThread : MYUSRMESS_REFCOUNT_INCR\n");
				PeekMessage(&msg, NULL, MYUSRMESS_REFCOUNT_INCR, MYUSRMESS_REFCOUNT_INCR, PM_REMOVE);
				OnIncreamentRefCount(msg.wParam, msg.lParam);
			}
				break;
			case MYUSRMESS_REFCOUNT_DECR:
			{
				ODBCTRACE("\nWBEM ODBC Driver : MyWorkerThread : MYUSRMESS_REFCOUNT_DECR\n");
				PeekMessage(&msg, NULL, MYUSRMESS_REFCOUNT_DECR, MYUSRMESS_REFCOUNT_DECR, PM_REMOVE);
				OnDecreamentRefCount(msg.wParam, msg.lParam);
			}
				break;
			case MYUSRMESS_CREATE_ENUM:
			{
				ODBCTRACE("\nWBEM ODBC Driver : MyWorkerThread : MYUSRMESS_CREATE_ENUM\n");
				PeekMessage(&msg, NULL, MYUSRMESS_CREATE_ENUM, MYUSRMESS_CREATE_ENUM, PM_REMOVE);
				OnUserCreateEnum(msg.wParam, msg.lParam);
			}
				break;
			case MYUSRMESS_REMOVE_ENUM:
			{
				ODBCTRACE("\nWBEM ODBC Driver : MyWorkerThread : MYUSRMESS_REMOVE_ENUM\n");
				PeekMessage(&msg, NULL, MYUSRMESS_REMOVE_ENUM, MYUSRMESS_REMOVE_ENUM, PM_REMOVE);
				OnUserRemoveEnum(msg.wParam, msg.lParam);
			}
				break;
			default:
			{
				CString myMessage;
				myMessage.Format("\nWBEM ODBC Driver : MyWorkerThread : unknown message %ld which I will remove off the thread queue\n", msg.message);
				ODBCTRACE(myMessage);
				PeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
			}
				break;
			}
		}

		Sleep(10);
	}

	//The thread will exit here
	return 500;
}


CWorkerThreadManager::CWorkerThreadManager()
{
	fIsValid = FALSE;

	//initalize critical section for shared data
	InitializeCriticalSection(&m_cs);

	dwThreadId = 0;
	m_cRef = 0;

	hr = NULL; 
}

void CWorkerThreadManager::CreateWorkerThread()
{
	//Create a worker thread
	EnterCriticalSection(& m_cs );
	dwThreadId = 0;
	m_cRef = 1; //sets the ref count to 1

	hr = (HANDLE)_beginthreadex(NULL, 0, &MyWorkerThread, NULL, 0, (unsigned int*)&dwThreadId); 
	fIsValid = TRUE;

	LeaveCriticalSection(& m_cs );
}

void CWorkerThreadManager::Invalidate()
{
	//only called after working thread is exited
	dwThreadId = 0;
	hr = NULL;
	fIsValid = FALSE;
	m_cRef = 0;
}

void ISAMCloseWorkerThread1()
{
	ODBCTRACE("\n\n***** ISAMCloseWorkerThread1 *****\n\n");

	MyWorkingThreadParams* m_params = new MyWorkingThreadParams(NULL, NULL, 0, NULL);
	EnterCriticalSection(& (glob_myWorkerThread.m_cs) );
	HANDLE EventHnd = m_params->m_EventHnd;
	ResetEvent(EventHnd);
	LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );
	PostThreadMessage(glob_myWorkerThread.GetThreadId(), MYUSRMESS_CLOSE_WKERTHRED, 0, (LPARAM)m_params);

	//Wait on termination of thread
	WaitForSingleObject(glob_myWorkerThread.GetThreadHandle(), INFINITE);
	delete m_params;
}

CWorkerThreadManager::~CWorkerThreadManager()
{
	//close thread
	ODBCTRACE("\n\n***** Shutting down worker thread *****\n\n");

	//close critical section
	DeleteCriticalSection(&m_cs);
}

void ISAMCloseWorkerThread2(UINT wParam, LONG lParam)
{
	//this is done on the worker thread
	ODBCTRACE("\n\n***** ISAMCloseWorkerThread2 *****\n\n");

	EnterCriticalSection(& (glob_myWorkerThread.m_cs) );
	
	//this is done on the worker thread

	//check data in lParam
	MyWorkingThreadParams* myData = (MyWorkingThreadParams*)lParam;

	//so that WaitForSingleObject returns
	//so ISAMCloseWorkerThread1 can continue and Invalidate the
	//global worker thread
	SetEvent(myData->m_EventHnd);

	LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );

	//when you exit this method and return to 'MyWorkerThread'
	//it will exit the loop and thus automatically terminate the thread
}

MyWorkingThreadParams::MyWorkingThreadParams(LPISAM lpISAM, LPUSTR lpQualifierName, SWORD cbQualifierName, IStream* myStream)
{
	//This will be created on worker thread
	m_lpISAM = lpISAM;
	m_lpQualifierName = lpQualifierName;
	m_cbQualifierName = cbQualifierName;
	m_myStream = myStream;

	pGateway = NULL; //will be filled in later
	pEnum = NULL;

	//Create an event object
	//so that message to worker thread can be suspensive
	m_EventHnd = CreateEvent(NULL, TRUE, FALSE, NULL);
}

MyWorkingThreadParams::MyWorkingThreadParams(LPISAM lpISAM, WmiEnumTypes a_fIsExecQuery, BSTR theBstrValue, CSafeWbemServices* a_pServ, IStream* myStream)
{
	//This will be created on worker thread
	m_lpISAM = lpISAM;
	fIsExecQuery = a_fIsExecQuery;

	sqltextBSTR = NULL;
	tableName = NULL;

	if (a_fIsExecQuery != WMI_CREATE_INST_ENUM)
	{
		sqltextBSTR = theBstrValue;
	}
	else
	{
		tableName = theBstrValue;
	}

	pServ = a_pServ;
	m_myStream = myStream;

	pGateway = NULL;
	pEnum = NULL; //will be filled in later
	sc = 0;

	//Create an event object
	//so that message to worker thread can be suspensive
	m_EventHnd = CreateEvent(NULL, TRUE, FALSE, NULL);
}

MyWorkingThreadParams::~MyWorkingThreadParams()
{
	//This will be cleaned up on worker thread

	if (m_EventHnd)
	{
		CloseHandle(m_EventHnd);
	}

	if (pGateway)
	{
		ODBCTRACE("\nShould never get here, deleting Gateway\n");
	}

	if (pEnum)
	{
		ODBCTRACE("\nShould never get here, deleting Enumeration\n");
	}
}

COleInitializationManager::COleInitializationManager()
{
	//Initialize Ole
	OleInitialize(0);
}

COleInitializationManager::~COleInitializationManager()
{
	//Uninitialize OLE
	OleUninitialize();
}


CSafeIEnumWbemClassObject::CSafeIEnumWbemClassObject()
{
	m_fValid = FALSE;
	m_pStream = NULL;
	m_params = NULL;
}

CSafeIEnumWbemClassObject::~CSafeIEnumWbemClassObject()
{
	if (m_params)
	{

		BOOL status = PostSuspensiveThreadMessage(glob_myWorkerThread.GetThreadId(), MYUSRMESS_REMOVE_ENUM, 0, (LPARAM)m_params);
		m_pStream = NULL;

		delete m_params;
		m_params = NULL;
	}
}


BOOL CSafeIEnumWbemClassObject::PostSuspensiveThreadMessage(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
{
	BOOL status = FALSE;

	ODBCTRACE("\nWBEM ODBC Driver : CSafeIEnumWbemClassObject::PostSuspensiveThreadMessage\n");

	EnterCriticalSection(& (glob_myWorkerThread.m_cs) );

	ODBCTRACE("\nWBEM ODBC Driver : CSafeIEnumWbemClassObject::PostSuspensiveThreadMessage : in critical section\n");

	//check data in lParam
	MyWorkingThreadParams* myData = (MyWorkingThreadParams*)lParam;

	//Extract Event Handle
	HANDLE EventHnd = myData->m_EventHnd;

	//make sure the event is in its non-signaled state
	//before posting the thread message
	ResetEvent(EventHnd);

	ODBCTRACE("\nWBEM ODBC Driver : CSafeIEnumWbemClassObject::PostSuspensiveThreadMessage: about to leave critical section\n");

	LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );

	//post message
	ODBCTRACE("\nWBEM ODBC Driver : CSafeIEnumWbemClassObject::PostSuspensiveThreadMessage: PostThreadMessage\n");
	status = PostThreadMessage(idThread, Msg, wParam, lParam);

	if (!status)
	{
		ODBCTRACE("\nWBEM ODBC Driver : CSafeWbemServices::PostSuspensiveThreadMessage: PostThreadMessage failed\n");
	}

	//Make it suspensive
	WaitForSingleObject(EventHnd, INFINITE);
	ODBCTRACE("\nWBEM ODBC Driver : CSafeIEnumWbemClassObject::PostSuspensiveThreadMessage : After wait for single object\n");

	return status;
}


HRESULT CSafeIEnumWbemClassObject::GetInterfacePtr(IEnumWbemClassObjectPtr& pIEnum)
{
	bool bRet = false;

	if(m_pStream)
	{
		HRESULT hr;

		//pop Com pointer out from stream
		//as we are using &SmartPointer the ref count stays the same
		hr = CoGetInterfaceAndReleaseStream(m_pStream,IID_IEnumWbemClassObject,(void**)&pIEnum);
		
		
		m_pStream = NULL;
		if (m_params)
			m_params->m_myStream = NULL;

		bRet = true;

		if ( SUCCEEDED(hr) )
		{
			//push the interface back into stream.
			//As we are CoMarshalling the interface the ref count bumps up by one
			hr = CoMarshalInterThreadInterfaceInStream(IID_IEnumWbemClassObject,pIEnum,&m_pStream);

			if (m_params)
			m_params->m_myStream = m_pStream;
		}
	}
    return S_OK;
}

HRESULT CSafeIEnumWbemClassObject::SetInterfacePtr(LPISAM lpISAM, WmiEnumTypes fIsEXecQuery, BSTR theBstrValue, CSafeWbemServices* pServ)
{
	//Tidy up any previous values
	if (m_params)
	{
		BOOL status = PostSuspensiveThreadMessage(glob_myWorkerThread.GetThreadId(), MYUSRMESS_REMOVE_ENUM, 0, (LPARAM)m_params);
		m_pStream = NULL;

		delete m_params;
		m_params = NULL;
	}

	//Set new value
	m_params = new MyWorkingThreadParams(lpISAM, fIsEXecQuery, theBstrValue, pServ, m_pStream);

	//post message to create this object on working thread

	ODBCTRACE("\nWBEM ODBC Driver :CSafeWbemServices::SetInterfacePtr : pos 1\n");
	BOOL status = PostSuspensiveThreadMessage(glob_myWorkerThread.GetThreadId(), MYUSRMESS_CREATE_ENUM, 0, (LPARAM)m_params);
	ODBCTRACE("\nWBEM ODBC Driver :CSafeWbemServices::SetInterfacePtr : pos 2\n");

	m_fValid = ( SUCCEEDED(m_params->sc) ) ? TRUE : FALSE;
	m_pStream = m_params->m_myStream;

	return (m_params->sc);
}

void CSafeIEnumWbemClassObject::Invalidate()
{
	if (m_params)
	{

		BOOL status = PostSuspensiveThreadMessage(glob_myWorkerThread.GetThreadId(), MYUSRMESS_REMOVE_ENUM, 0, (LPARAM)m_params);
		m_pStream = NULL;

		delete m_params;
		m_params = NULL;
	}

	m_pStream = NULL;
	m_fValid = FALSE;
}

// Checked for SetInterfaceSecurityEx on IWbemServices

BOOL IsLocalServer(LPSTR szServer)
{
	//A local server could be specified as a NULL or blank string
	//a '.' character or a fully qualified \\MyLocalServer
	//we need to check each of these cases

	if (!szServer || !*szServer)
		return TRUE;

	// Get past the \\ if any.
	if (szServer[0] == '\\' && szServer[1] == '\\')
		szServer += 2;

	// Check for '.'.
	if (!strcmp(szServer, "."))
		return TRUE;

	// Get the server name and compare.
	char  szName[MAX_COMPUTERNAME_LENGTH + 1] = "";
	DWORD dwSize = sizeof(szName);

	GetComputerNameA(szName, &dwSize);

	return _stricmp(szServer, szName) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\isam.h ===
/***************************************************************************/
/* ISAM.H                                                                  */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
#include "dbase.h"

/* Error codes */
#define NO_ISAM_ERR				0
#define ISAM_EOF				1
#define ISAM_TRUNCATION			2
#define ISAM_NOTSUPPORTED		3
#define ISAM_ERROR				4
#define ISAM_NETERROR			5
#define ISAM_NETVERSION			6
#define ISAM_NETISAM			7

    /*  To create additional error codes that your implementation of the   */
    /*  ISAM functions can return, #define them here (no greater than      */
    /*  LAST_ISAM_ERROR_CODE).                                             */
#define ISAM_MEMALLOCFAIL		8
#define	ISAM_PROVIDERFAIL		9


#define	ISAM_STILL_EXECUTING	999 //added for asynchronous execution

#define LAST_ISAM_ERROR_CODE 1000

#define WBEMDR32_VIRTUAL_TABLE		L"WBEMDR32VirtualTable"
#define WBEMDR32_VIRTUAL_TABLE2		"WBEMDR32VirtualTable"

/* Maximum sizes */

#define MAX_CHAR_LITERAL_LENGTH 255
#define MAX_BINARY_LITERAL_LENGTH 255
#define MAX_COLUMN_NAME_LENGTH 128// was 63
#define MAX_TABLE_NAME_LENGTH 128// was 63
#define MAX_DATABASE_NAME_LENGTH 128//was 127
#define MAX_SERVER_NAME_LENGTH 128
#define MAX_TABLE_TYPE_LENGTH 12 //i.e length of 'SYSTEM TABLE'
#define MAX_LOGIN_METHOD_LENGTH 7
#define MAX_USER_NAME_LENGTH 128// was 63
#define MAX_PASSWORD_LENGTH 128//was 63
#define MAX_HOME_NAME_LENGTH 128
#define MAX_COLUMNS_IN_ORDER_BY 20
#define MAX_QUALIFIER_NAME_LENGTH 128
#define MAX_ISAM_NAME_LENGTH 31
#define MAX_VERSION_NAME_LENGTH 15
#define MAX_DRIVER_NAME_LENGTH 31
#define MAX_HOST_NAME_LENGTH 63
#define MAX_PORT_NUMBER_LENGTH 15
#define MAX_COLUMNS_IN_KEY 15
#define MAX_KEY_NAME_LENGTH 63
#define MAX_INDEX_NAME_LENGTH 63
#define MAX_COLUMNS_IN_INDEX MAX_COLUMNS_IN_KEY

/*  ******* Note: do not change MAX_TABLE_NAME_LENGTH.  If the ISAM's table */
/*  *******       name length is smaller than these values,                 */
/*  *******       ISAMMaxTableNameLength() should return the correct value. */

/*  ******* Note: do not change MAX_COLUMN_NAME_LENGTH.  If the ISAM's      */
/*  *******       table name length is smaller than these values,           */
/*  *******       ISAMMaxColumnNameLength() should return the correct value.*/

/* Comparison operators */

#define ISAM_OP_NONE       0
#define ISAM_OP_EQ         1
#define ISAM_OP_NE         2
#define ISAM_OP_LE         3
#define ISAM_OP_LT         4
#define ISAM_OP_GE         5
#define ISAM_OP_GT         6
/* Note: If you add to this list, you will probably have to add to OP_* in */
/*       PARSE.H                                                           */

/* Network stuff */
#define NET_OPAQUE                      UWORD
#define NET_OPAQUE_INVALID      ((NET_OPAQUE)-1)

//Masks used for Data & Time convertions
#define ISAM_DAY_MASK		31
#define ISAM_MONTH_MASK		736
#define ISAM_YEAR_MASK		65760
#define ISAM_SECOND_MASK	31
#define ISAM_MINUTE_MASK	2016
#define ISAM_HOUR_MASK		65504

//Some string constants
#define WBEMDR32_L_NAME					L"Name"
#define WBEMDR32_L_CIMTYPE				L"CIMTYPE"
#define WBEMDR32_L_LAZY					L"lazy"
#define WBEMDR32_L_MAX					L"MAXLEN"
#define WBEMDR32_L_NAMESPACE				L"__NAMESPACE"
#define WBEMDR32_L_CLASS					L"__CLASS"
#define WBEMDR32_L_CIMOMIDENTIFICATION	L"__CIMOMIdentification"
#define WBEMDR32_L_KEY					L"Key"
#define WBEMDR32_L_SERVER				L"__SERVER"
#define WBEMDR32_L_WQL					L"WQL"


typedef 
enum tag_WmiEnumTypes
    {	WMI_CREATE_INST_ENUM	= 0x1,
		WMI_EXEC_QUERY	= 0x2,
		WMI_EXEC_FWD_ONLY = 0x3,
		WMI_PROTOTYPE = 0x4
    }	WmiEnumTypes;

/***************************************************************************/

//class to make sure Ole is initialized on every thread
//As we don't know which thread the SQL function is called from
//we need to make sure Ole is initialized on every ODBC function call
class COleInitializationManager
{
public:

	COleInitializationManager();
	~COleInitializationManager();
};



template<typename TNDataType>
class SafeArrayManager
{
private:

	BOOL fValid;		//indicate if it stores valid SAFEARRAY

	SAFEARRAY FAR* pa;	//pointer to SAFEARRAY value;

	long iLBound;		//lower and upper bounds of array
	long iUBound;

	long cElements;		//number of elements in array

public:

	//Does this object contain a valid array
	BOOL IsValid()			{return fValid;}

	//returns number of elements in the array
	long Count()			{return cElements;}



    // Extract a value from the array using the [] operator
    TNDataType operator[](long _nItem)
	{
		TNDataType dataItem;

		if(_nItem < cElements)
		{
			HRESULT hr;
			hr = SafeArrayGetElement(pa,&_nItem,&dataItem);
		}

		return dataItem;
	}

	SafeArrayManager(VARIANT* myArray)
	{
		fValid = FALSE;
		pa = NULL;
		iLBound = 0;
		iUBound = 0;
		cElements = 0;

		//Check that variant stores an array type
		if (myArray->vt & VT_ARRAY)
		{
			//Is a valid array type
			pa = myArray->parray;

			//Lock the array value
			SafeArrayLock(pa);

			//Work out number of properties/columns	
			SafeArrayGetLBound(pa, 1, &iLBound );
			SafeArrayGetUBound(pa, 1, &iUBound );
			cElements = (iUBound - iLBound + 1);

			fValid = TRUE;
		}
	}

	~SafeArrayManager()
	{
		if (pa)
		{
			//Unlock the array value
			SafeArrayUnlock(pa);
		}
	}

};

typedef SafeArrayManager<BSTR>           BSTR_SafeArray;
typedef SafeArrayManager<long>           long_SafeArray; //VT_I4
typedef SafeArrayManager<short>          short_SafeArray;//VT_I2
typedef SafeArrayManager<BYTE>           BYTE_SafeArray; //VT_UI1
typedef SafeArrayManager<BOOL>           BOOL_SafeArray; //VT_BOOL

//external declaration
void Utility_DBCSToWideChar(IN const char* _dbcsData,
								OUT wchar_t** _sOutData, SWORD cbLen = 0);

class CBString
{
private:
    BSTR    m_pString;

	wchar_t*	m_temp;


public:
    CBString()
    {
        m_pString = NULL;
		m_temp = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString, BOOL fInterpretAsBlank);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) {
            SysFreeString(m_pString);
			m_pString = NULL;
        }

		if (pwszString && wcslen(pwszString))
			m_pString = SysAllocString(pwszString);

        return *this;
    }

	void AddString(LPSTR pszString, BOOL fInterpretAsBlank, SWORD cbLen = 0)
    {
        if(m_pString) {
            SysFreeString(m_pString);
			m_pString = NULL;
        }

		delete m_temp;
		m_temp = NULL;

		if (pszString)
		{
			if ( _mbstrlen(pszString) )
			{
				Utility_DBCSToWideChar(pszString,
									&m_temp, cbLen);

				m_pString = SysAllocString(m_temp);
			}
			else
			{
				//OK, we have a string of zero length
				//check if we interpret this as blank or NULL
				if (fInterpretAsBlank)
				{
					m_temp = new wchar_t[1];
					m_temp[0] = 0;
					m_pString = SysAllocString(m_temp);
				}
			}
		}
    }
};





class CNamespace : public CObject
{
    DECLARE_SERIAL(CNamespace)
private:
	CString m_name;
public:
    CNamespace () {}
	CNamespace (char *name): m_name (name) {}
    CNamespace (CString& name ):
	            m_name (name) {}
				CNamespace(const CNamespace& a):m_name (a.m_name) {} 
	void Serialize(CArchive& ar)
	{
		if (ar.IsStoring())
			ar << m_name;
		else
			ar >> m_name;
	}

#ifdef _DEBUG
    void AssertValid() const {CObject :: AssertValid ();}
#endif
    const CNamespace& operator=( const CNamespace& a )
    {
        m_name = a.m_name;
		return *this;
    }
    BOOL operator==(CNamespace a)
    {
        return (m_name == a.m_name );
    }
 #ifdef _DEBUG
    void Dump( CDumpContext& dc ) const
    {
        CObject::Dump( dc );
        dc << m_name;
    }
 #endif
	CString& GetName () {return m_name;}
};	


/***************************************************************************/
class ImpersonationManager; //forward declaration

/* ISAM provides low level data access. */

typedef struct  tagISAM {
    /* The following values are only used within ISAM.C */

    UWORD      cSQLTypes;
    LPSQLTYPE  SQLTypes;
    SWORD      fTxnCapable;         /* See the discussion of transactions  */
                                    /* (below) for a description of this   */
                                    /* value.                              */  
    BOOL       fSchemaInfoTransactioned;
                                    /* See the discussion of transactions  */ 
                                    /* (below) for a description of this   */
                                    /* value.                              */
    BOOL       fMultipleActiveTxn;  /* See the discussion of transactions  */
                                    /* (below) for a description of this   */
                                    /* value.                              */
    SDWORD     fTxnIsolationOption; /* See the discussion of transactions  */
                                    /* (below) for a description of this   */
                                    /* value.                              */
    SDWORD     fDefaultTxnIsolation;/* See the discussion of transactions  */
                                    /* (below) for a description of this   */
                                    /* value.                              */

	/* The following values are only used by Network Edition */
    UDWORD     udwNetISAMVersion;

    /* The following values are only used by Network Edition client */
    NET_OPAQUE netISAM;
    LPVOID     netConnection;
    BOOL       fCaseSensitive;
    UCHAR      szName[MAX_ISAM_NAME_LENGTH+1];
    UCHAR      szVersion[MAX_VERSION_NAME_LENGTH+1];
    UCHAR      szDriver[MAX_DRIVER_NAME_LENGTH+1];
    SWORD      cbMaxTableNameLength;
    SWORD      cbMaxColumnNameLength;


	HINSTANCE	hKernelApi;

	char szHomeNamespace[MAX_DATABASE_NAME_LENGTH+1];// home namespace name use to contact MO Server
	CMapStringToOb *pNamespaceMap;
//	WBEM_LOGIN_AUTHENTICATION m_loginMethod;

	char* m_Locale;
	char* m_Authority;

	char szUser [MAX_USER_NAME_LENGTH + 1];
	char szPassword [MAX_PASSWORD_LENGTH + 1];
	char szDatabase [MAX_DATABASE_NAME_LENGTH+1];
	char szServer [MAX_SERVER_NAME_LENGTH+1];

	BOOL fIsLocalConnection;//Flag to indicate if this is a local connection
	BOOL fW2KOrMore;//Flag to indicate if this OS is Window 2000 or higher

	BOOL fIntpretEmptPwdAsBlank; //Flag to indicate a empty password is interpreted as blank rather than NULL

	ImpersonationManager* Impersonate; //Impersonation

	BOOL fOptimization; //indicates if you want WBEM Level 1 optimization
	BOOL fSysProps; //indicates if you want to show system properties
	BOOL fPassthroughOnly;//indicates if you want to work in passthrough only mode
    SWORD      errcode;//error status
	tagISAM () {pNamespaceMap = NULL;}
	~tagISAM () {delete pNamespaceMap;}
	static char *GetRelativeName (char* absoluteName); 
	char szRootDb [MAX_DATABASE_NAME_LENGTH+1];

	//WBEM Client Recognition variables
	DWORD dwAuthLevel;
	DWORD dwImpLevel;
	COAUTHIDENTITY * gpAuthIdentity;

}       ISAM,
        FAR * LPISAM;

//Pointers to functions
typedef BOOL  (CALLBACK *ULPLOGONUSER)(LPTSTR lpUser, LPTSTR lpDomain, LPTSTR lpPasswrd, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE pToken);
typedef BOOL  (CALLBACK *ULPIMPERSONLOGGEDONUSER)(HANDLE myHandle);
typedef void  (CALLBACK *ULPREVERTTOSELF)();

typedef BOOL  (CALLBACK *ULPSETTHREADLOCALE)(LCID myLcid);

class ImpersonationManager
{
private:

	HANDLE hToken;							// handle to a token that represents a logged on user

	HINSTANCE hAdvApi;                      // handle to library
//	HINSTANCE hKernelApi;					// handle to library

	BOOL fImpersonate;						//can we do impersonation

	char szUser [MAX_USER_NAME_LENGTH + 1];

	//Pointers to functions, if applicable
	ULPLOGONUSER			pProcLogonUser;
	ULPIMPERSONLOGGEDONUSER	pProcImpersonateLoggedOnUser;
	ULPREVERTTOSELF			pProcRevertToSelf;

	BOOL DoInitialChecks();

	void ExtractLogonInfo(char* org_szUser, char* szPassword, char* szAuthority);

public:

	BOOL fImpersonatingNow;					//are we impersonating at this moment ?

	BOOL CanWeImpersonate()		{return fImpersonate;}

	BOOL ImpersonatingNow()		{return fImpersonatingNow;}

	void Impersonate(char* displayStr = NULL);

	void RevertToYourself(char* displayStr = NULL);

	ImpersonationManager(char* szUser, char* szPassword, char* szAuthority);
	~ImpersonationManager();

};

//Add this to the start of most ODBC calls
//this will impersonate, if possible, in its constructor
//and RevertToSelf, if applicable in its destructor
class MyImpersonator
{
private:
	LPDBC hdl;
	LPSTMT hstmt;
	LPISAM lpISAM;
	char* displayStr;
	ImpersonationManager* lpImpersonator;

public:

	MyImpersonator(LPDBC hdl, char* displayStr);
	MyImpersonator(LPSTMT hstmt, char* displayStr);
	MyImpersonator(LPISAM lpISAM, char* displayStr);
	MyImpersonator(char* szUser, char* szPassword, char* szAuthority, char* displayStr);

	~MyImpersonator();
};


#define MYUSRMESS_CREATE_SERVICES	WM_USER + 1
#define MYUSRMESS_REMOVE_SERVICES	WM_USER + 2
#define MYUSRMESS_CLOSE_WKERTHRED	WM_USER + 3
#define MYUSRMESS_REFCOUNT_INCR		WM_USER + 4
#define MYUSRMESS_REFCOUNT_DECR		WM_USER + 5
#define MYUSRMESS_CREATE_ENUM		WM_USER + 6
#define MYUSRMESS_REMOVE_ENUM		WM_USER + 7


class CWorkerThreadManager
{
private:
//	HANDLE EventHnd;			//handle to event

	DWORD dwThreadId;			//worker thread id
	HANDLE hr;					//worker thread handle

	BOOL	fIsValid;			//has the worker thread been successfully setup ?


public:

	DWORD m_cRef;				//ref count

	CRITICAL_SECTION m_cs;		//critical section for shared data

//	HANDLE	GetEventHandle()	{return EventHnd;}

	DWORD	GetThreadId()		{return dwThreadId;}
	HANDLE	GetThreadHandle()	{return hr;}
	DWORD	GetRefCount()		{return m_cRef;}

	BOOL	IsValid()			{return fIsValid;}

	void	CreateWorkerThread();
	void	Invalidate();

	CWorkerThreadManager();

	~CWorkerThreadManager();
};

class CSafeWbemServices;

class MyWorkingThreadParams
{
public:

	HANDLE	m_EventHnd; //in order to make this suspensive

	//Tempory pointers to data used for a short
	//time when creating IWbemServices Ole pGateway
	LPISAM m_lpISAM;
	LPUSTR m_lpQualifierName;
	SWORD m_cbQualifierName;
	IStream* m_myStream; //temp copy

	//Extra ones for IEnumClassObject

	CSafeWbemServices* pServ; //tempory pointer to be able to use IWbemServices created on working thread (not in marshalled stream)
	BSTR sqltextBSTR;	//tempory pointer
	BSTR tableName;		//tempory pointer
	WmiEnumTypes fIsExecQuery;	//flag to indicate creation style
	SCODE sc;			//return scode on creating enumeration


	//to be filled in on working thread
	IWbemServices*	pGateway;	//pointer to receive Ole pointer created on working thread
	IEnumWbemClassObject* pEnum;	//pointer to receive Ole pointer created on working thread

	MyWorkingThreadParams(LPISAM lpISAM, LPUSTR lpQualifierName, SWORD cbQualifierName, IStream* myStream);
	MyWorkingThreadParams(LPISAM lpISAM, WmiEnumTypes fIsExecQuery, BSTR theBstrValue, CSafeWbemServices* pServ, IStream* myStream);
	~MyWorkingThreadParams();

};


class CSafeIEnumWbemClassObject
{
private:
	IStream *           m_pStream;   //use to safely store Com pointer

	MyWorkingThreadParams*
						m_params;
public:

	BOOL				m_fValid;	//is the IEnumWbemClassObject pointer valid ?


	//is the IWbemServices pointer valid
	BOOL IsValid()			{return m_fValid;}

	void Invalidate();

	//to manage thread messages using event object
	BOOL PostSuspensiveThreadMessage(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam);

	HRESULT GetInterfacePtr(IEnumWbemClassObjectPtr& pIEnum);

	HRESULT SetInterfacePtr(LPISAM, WmiEnumTypes fIsEXecQuery, BSTR theBstrValue, CSafeWbemServices* pServ);//(IEnumWbemClassObjectPtr& myPtr);

	CSafeIEnumWbemClassObject();
	~CSafeIEnumWbemClassObject();

};


class CSafeWbemServices
{
private:
	IStream *           m_pStream;   //use to safely store Com pointer
	
public :

	MyWorkingThreadParams*
						m_params;	//parameters for this IWbemServices object


	BOOL				m_fValid;	//is the IWbemServices pointer valid ?

	HRESULT GetInterfacePtr(IWbemServicesPtr& pServices);

	void SetInterfacePtr(LPISAM lpISAM, LPUSTR lpQualifierName, SWORD cbQualifierName);

	//to manage thread messages using event object
	BOOL PostSuspensiveThreadMessage(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam);

	//is the IWbemServices pointer valid
	BOOL IsValid()			{return m_fValid;}

	void Invalidate();

	//Transfer the data from one object to this one
	void Transfer(CSafeWbemServices& original);

	CSafeWbemServices();

	~CSafeWbemServices();
};

/***************************************************************************/

/* The ISAM provides a mechanism for the driver to retrieve a list of      */
/* table names.  First ISAMGetTableList() is called to get a               */
/* LPISAMTABLELIST.  Then ISAMGetNextTableName() is called zero or more    */
/* times to get the names off the list.  Finally, ISAMFreeTableList() is   */
/* called to deallocate the list.                                          */

typedef struct  tagISAMTABLELIST {

	/* The following values are only used by Network Edition client */
    NET_OPAQUE      netISAMTableList;

    /* The following values are only used within ISAM.C */
    LPISAM					lpISAM;
    UCHAR					lpPattern[MAX_TABLE_NAME_LENGTH];
    SWORD					cbPattern;
	UCHAR					lpQualifierName[MAX_QUALIFIER_NAME_LENGTH+1];
	SWORD					cbQualifierName;
    BOOL					fFirstTime;
	BOOL					fGotAllInfo;//used to indicate completion of asynchronous retrieval of table list
	POSITION				iIndex;   //position into CPtrList
	CPtrList*				pTblList; //table list (IWBEMClassObjects)
	CSafeWbemServices*		pGateway2;
	BOOL					fEmptyList;//are we asking for no tables
	BOOL					fWantSysTables; //do we want System Tables
}       ISAMTABLELIST,
        FAR * LPISAMTABLELIST;

/***************************************************************************/

typedef struct  tagISAMQUALIFIERLIST {
    /* The following values are only used within ISAM.C */
    LPISAM					lpISAM;
    POSITION				iIndex;//position into list
    BOOL					fFirstTime;
}       ISAMQUALIFIERLIST,
        FAR * LPISAMQUALIFIERLIST;

/***************************************************************************/

/* ISAM provides a mechanism for the driver to retrieve the foreign key    */ 
/* between two tabled.                                                     */

typedef UCHAR ISAMKEYCOLUMNNAME[MAX_COLUMN_NAME_LENGTH+1];
typedef ISAMKEYCOLUMNNAME FAR *LPISAMKEYCOLUMNNAME;

/***************************************************************************/

/* ISAM provides a bookmarking facility.  It allows the ISAM user to get   */
/* get a bookmark for the current record in the table and then later       */
/* reposition to that record.                                              */

//typedef UDWORD ISAMBOOKMARK; 
typedef struct tagISAMBOOKMARK
{
	UDWORD currentRecord;		//in-memory WBEM instance
	UDWORD currentInstance;		//virtual instance number
} ISAMBOOKMARK,
        FAR * LPISAMBOOKMARK;

#define NULL_BOOKMARK 0xFFFFFFFF //set currentRecord to this value to indicate a NULL entry

/***************************************************************************/

struct ISAMTreeItemData 
{
	char *absName;
	char* pszText;
	int included;
	int childInclude;//number of immediate child nodes which are included
	int childChildInclude;//number of non-immediate child nodes which are included
	BOOL fExpanded;		//flag to indicate if this node has been checked for children

	ISAMTreeItemData* pNext;

	~ISAMTreeItemData () {delete absName; delete pszText;}
	ISAMTreeItemData () : absName (NULL), included (FALSE), pNext(NULL), fExpanded(FALSE) {}
};


/***************************************************************************/

/* The ISAM allows the driver to open and access a table.  To open the     */ 
/* table, ISAMOpenTable() is called.  To close the table ISAMCloseTable()  */
/* is called.                                                              */

typedef struct  tagISAMCOLUMNDEF {             /* A column of the table    */

    /* These values must be here.  They are used by the driver             */

    UCHAR       szColumnName[MAX_COLUMN_NAME_LENGTH+1];
                                    /* The name of the column              */
	UCHAR		szTypeName[MAX_COLUMN_NAME_LENGTH+1];
									/* The type name of the column         */
									/* (e.g."MONEY", "INT8" etc...)     */
    SWORD       fSqlType;           /* The type of the column (SQL_*)      */
                                    /* *********************************** */
                                    /* ***                             *** */
                                    /* ***   THIS MUST BE ONE OF THE   *** */
                                    /* *** TYPES SPECIFIED IN SQLTypes *** */
                                    /* *** IN SQLTYPE.C WHICH HAS THE  *** */
                                    /* ***  supported FLAG SET TO TRUE *** */
                                    /* ***                             *** */
                                    /* *********************************** */
    UDWORD      cbPrecision;        /* The precision of the column (see    */
                                    /*     appendix D of the ODBC Spec).   */
    SWORD       ibScale;            /* The scale of the column (see        */
                                    /*     appendix D of the ODBC Spec).   */
    SWORD       fNullable;          /* See SQLColumns(NULLABLE) in the     */
                                    /*     ODBC spec.                      */
    UWORD       fSelectivity;       /* A measure of how unique values of   */
                                    /*     this column are.  The higher    */
                                    /*     the number, the more values     */
                                    /*     there are.  For example, a      */
                                    /*     GENDER column would have low    */
                                    /*     selectivity value, but a SSN    */
                                    /*     column would have high value.   */
                                    /*     This value is used to determine */
                                    /*     the most restrictive condition  */
                                    /*     to send to ISAMRestrict().  If  */
                                    /*     you don't know the selectivity  */
                                    /*     or don't want this column to    */
                                    /*     be sent to ISAMRestrict(),      */
                                    /*     set this value to 0.            */
    UWORD       fKeyComponent;      /* Non-zero if this column is a        */
                                    /*     component of the primary key    */
                                    /*     for the table.                  */
                                    /*                                     */
                                    /*     If the table has a primary key  */
                                    /*     that has multiple components    */
                                    /*     (for example, the combination   */ 
                                    /*     of LAST_NAME and FIRST_NAME     */
                                    /*     is unique but neither           */
                                    /*     FIRST_NAME nor LAST_NAME alone  */
                                    /*     is unique), fKeyComponent has   */
                                    /*     the value 1 for the first key   */ 
                                    /*     component, 2 for the second     */
                                    /*     key component, etc.             */
                                    /*                                     */
                                    /*     If table has multiple primary   */
                                    /*     keys (for example, RECORD_ID    */
                                    /*     alone is unique and NAME alone  */
                                    /*     is unique), fKeyComponent is    */
                                    /*     set for only one of them, not   */
                                    /*     both.                           */
                                    /*                                     */
                                    /*     If the table has no primary     */
                                    /*     keys, fKeyComponent is zero for */
                                    /*     all the columns in the table.   */
                                    /*     Note: If the table has no       */
                                    /*     primary keys, some applications */
                                    /*     such as Microsoft Access or     */ 
                                    /*     PowerBuilder may not be able to */
                                    /*     update the table.               */

    /* The following values are only used by Network Edition client */
    SWORD      iSqlType;
    SDWORD     cbValue;
    PTR        rgbValue;

    /* The following values are only used within ISAM.C */

}       ISAMCOLUMNDEF,
        FAR * LPISAMCOLUMNDEF;

#define REFETCH_DATA SQL_DATA_AT_EXEC

/***************************************************************************/

class ClassColumnInfoBase; //forward declaration
class VirtualInstanceManager; //forward declaration

typedef struct  tagISAMTABLEDEF {
    
    /* These values must be here.  They are used by the driver */


    UCHAR       szTableName[MAX_TABLE_NAME_LENGTH+1]; /*The name of the table*/

	CBString*	pBStrTableName;		//Also the table name but saved for our convenience

    IWbemClassObject* pSingleTable; //The table class object use to get column information
	CSafeWbemServices* pGateway2;
	LPDBASEFILE lpFile;//Use to store enumeration of records for the chosen class 
    BOOL        fFirstRead;
	SDWORD      iRecord; /* row number */
	ClassColumnInfoBase* pColumnInfo;//column info for this table

	UCHAR       szPrimaryKeyName[MAX_KEY_NAME_LENGTH+1];
									/* If there is a primary key  */
                                    /* on the table, the name of  */
                                    /* the primary key.  If there */
                                    /* is not name or no primary  */
                                    /* key, a zero length string  */

    /* The following values are only used by ISAM.C and the Network Edition */
    LPISAM     lpISAM; //Copy from hdbc
	IWbemContext* pContext; //Context object to store LocaleId
	
	/* Is this __Generic class (multi-table join) */
	BOOL fIs__Generic;

	/* Is this Passthrough SQL */
	BOOL		fIsPassthroughSQL;
	CMapWordToPtr* passthroughMap;
	IWbemClassObject* firstPassthrInst;         //1st SQL passthrough instance
	VirtualInstanceManager* virtualInstances;	//stores virtual array map for array columns which map
												//to multiple instances

    /* The following values are only used by Network Edition client */
    NET_OPAQUE  netISAMTableDef;
    HGLOBAL     hPreFetchedValues;
    SDWORD      cbBookmark;
    ISAMBOOKMARK bookmark;

}       ISAMTABLEDEF,
        FAR * LPISAMTABLEDEF;

/***************************************************************************/

/* ISAM allows for an SQL statement to be passed to it (for use with       */
/* backend databases that suport SQL).  An ISAMSQL handle is used to       */
/* identify an SQL statement passed.  See ISAMPrepare() and ISAMExecute(). */

typedef struct  tagISAMSTATEMENT {
    /* The following values are only used by ISAM.C and the Network Edition */
    LPISAM     lpISAM;

    /* The following values are only used by Network Edition client */
    NET_OPAQUE netISAMStatement;

    /* The following values are only used within ISAM.C */
    BOOL       resultSet;
    LPSTR      lpszParam1;
    SDWORD     cbParam1;
    LPSTR      lpszParam2;
    SDWORD     cbParam2;

	/* Added by Sai  for Passthrough SQL */
	CSafeWbemServices*		pProv;			//Gateway Server
	UDWORD					currentRecord;	//record number (zero index)
	CSafeIEnumWbemClassObject*	tempEnum;		//enumeration of all records
	IWbemClassObject*		firstPassthrInst;//first SQL passthrough instance
	CSafeIEnumWbemClassObject*	tempEnum2;		//enumeration of class definition
	IWbemClassObject*		classDef;		//class definition
	CMapWordToPtr*			passthroughMap; //passthrough map
	

}       ISAMSTATEMENT,
        FAR * LPISAMSTATEMENT;


/***************************************************************************/

class ClassColumnInfo
{
private:
//	VARIANT aVariantValue;
	VARIANT aVariantSYNTAX;

	//Flag to indicate if column info valid 
	BOOL		fValidType;

	LPSQLTYPE aDataTypeInfo;
	    
	// The type name of the column      
	//(e.g."MONEY", "INT8" etc...)
	UCHAR		szTypeName[MAX_COLUMN_NAME_LENGTH+1];

	//SQL_* type of the column								
    SWORD       fSqlType;           
    
	//The precision of the column
    UDWORD      cbPrecision;        
    
	//The scale of the column
    SWORD       ibScale;  
	
	//Flag to inidicate if column is NULLable 
    SWORD       fNullable; 

	//Variant type
	LONG		varType;

	//Flag to indicate if column is 'lazy'
	BOOL		fIsLazyProperty;

public:

	//indicates if column info is known
	BOOL		IsValidInfo()		{return fValidType;}

	//returns the variant type for the column value
	LONG		GetVariantType()	{return varType;}

	//returns SQL_* type of column
	SWORD		GetSQLType()		{return fSqlType;}

	//returns type name
	UCHAR*		GetTypeName()		{return szTypeName;}

	//returns precision of column
	UDWORD		GetPrecision()		{return cbPrecision;}

	//returns scale of column
	SWORD		GetScale()			{return ibScale;}

	//indicates if column is NULLable
	SWORD		IsNullable()		{return SQL_NULLABLE;}

	//indicates if column is lazy
	BOOL		IsLazy()			{return fIsLazyProperty;}

	//returns SQL_* type of column
	LPSQLTYPE	GetDataTypeInfo()	{return GetType2(szTypeName);}

	ClassColumnInfo(LONG pType, VARIANT* pSYNTAX, SDWORD maxLenVal, BOOL fGotSyntax = TRUE, BOOL fIsLazy = FALSE);

	~ClassColumnInfo();
};

/***************************************************************************/


class CEmbeddedDataItems
{
private:

public:
	//embedded object name
	//(which is also the table aliase)
	CBString embeddedName;

	//embedded object class 
	IWbemClassObject* cClassObject;

	CEmbeddedDataItems()			{cClassObject = NULL;}

	~CEmbeddedDataItems()
	{
		//(5)
		if (cClassObject)
			cClassObject->Release();//to match QueryInterface class
	}
};


class ClassColumnInfoBase
{
private:
	//Copy of table definition
	LPISAMTABLEDEF pTableDef;

	//Stores column names
	SAFEARRAY FAR* rgSafeArray;

	//Indicates if class is valid
	BOOL isValid;

	//Number of columns
	UWORD cColumnDefs;

	//Lower bound
	LONG iLBound;

	//Upper bound
	LONG iUBound;

	//Extra Column Information
	ClassColumnInfo* pColumnInformation;
	LONG iColumnNumber;

	//Setups up extra column info
	BOOL	Setup(LONG iColumnNum);

	//returns info for a particular column
	SWORD	GetColumnInfo(LONG iColumnNum);

	/**********************************************************/
	/* The following are only for __Generic Passthrough class */
	/**********************************************************/
	//Is this a __Generic Passthrough SQL class
	BOOL fIs__Generic;

	//Number of system properies 
	UWORD cSystemProperties;

/* SAI
	//Array of embedded object names
	//(which are also table aliases)
	CBString* embeddedNames;

	//Array of embedded objects. Each 
	IWbemClassObject** cClassObject;
*/
	CEmbeddedDataItems** embedded;
	UWORD embeddedSize;


	//get embedded class object for column index
	IWbemClassObject* GetClassObject(LONG iColumnNumber, CBString& lpPropName, CBString& lpAliasName);

	//dummy
	CBString dummyStr;

public:

	//returns profile for __Generic class
	UWORD Get__GenericProfile();

	//Indicates if class was created successfully
	BOOL	IsValid()					{return isValid;}

	//returns number of columns
	UWORD	GetNumberOfColumns()		{return cColumnDefs;}
	
	//returns the column name, the buffer pColumnName must be 
	//at least MAX_COLUMN_NAME_LENGTH+1 in size
	SWORD	GetColumnName(LONG iColumnNumber, LPSTR pColumnName, LPSTR pColumnAlias = NULL);

	BOOL	GetVariantType(LONG iColumnNum, LONG &lVariant);

	//returns SQL_* type of column
	BOOL	GetSQLType(LONG iColumnNum, SWORD &wSQLType);

	//returns type name
	BOOL	GetTypeName(LONG iColumnNum, UCHAR* &pbTypeName);

	//returns precision of column
	BOOL	GetPrecision(LONG iColumnNum, UDWORD &uwPrecision);

	//returns scale of column
	BOOL	GetScale(LONG iColumnNum, SWORD &wScale);

	//indicates if column is NULLable
	BOOL	IsNullable(LONG iColumnNum, SWORD &wNullable);

	//indicates if column is 'lazy'
	BOOL	IsLazy(LONG iColumnNum, BOOL &fLazy);

	//returns SQL_* type of column
	BOOL	GetDataTypeInfo(LONG iColumnNum, LPSQLTYPE &pSQLType);

	//indicates how unique column values are
	UWORD	GetSelectivity()	{return 0;}

	//indicates if this column is part of primary key
	SWORD	GetKey(LONG iColumnNumber, BOOL &isAKey);

	//Gets the Lower Bound
	LONG	GetLowerBound()		{return iLBound;}

	//Gets the Upper Bound
	LONG	GetUpperBound()		{return iUBound;}

	//retrieves attribute values for column
	SWORD GetColumnAttr(LONG iColumnNumber, LPSTR pAttrStr, SDWORD cbValueMax, SDWORD& cbBytesCopied);

	ClassColumnInfoBase(LPISAMTABLEDEF pTableDef, BOOL fIs__Generic = FALSE);

	~ClassColumnInfoBase();
};

/***************************************************************************/

//
// Notification classes
//

class CNotifyTableNames : public IWbemObjectSink
{
private:
	HANDLE				m_mutex;			//mutex to protect shared table list resource 
	DWORD				m_cRef;			  //Reference count
	LPISAMTABLELIST		lpISAMTableList; //pointer to store tables names

public:

	STDMETHODIMP			QueryInterface(REFIID, LPVOID FAR*);
	STDMETHODIMP_(ULONG)	AddRef(void);
	STDMETHODIMP_(ULONG)	Release(void);
	
	STDMETHODIMP_(HRESULT)	GetTypeInfoCount(UINT FAR* pctinfo)	{return E_NOTIMPL;}
	STDMETHODIMP_(HRESULT)	GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) {return E_NOTIMPL;}
	STDMETHODIMP_(HRESULT)	GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
									LCID lcid, DISPID FAR* rgdispid) {return E_NOTIMPL;}
	STDMETHODIMP_(HRESULT)	Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
								DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult,
								EXCEPINFO FAR* pexcepinfo, UINT FAR* puArgErr) {return E_NOTIMPL;}
	STDMETHODIMP_(HRESULT)	Indicate(long lObjectCount, IWbemClassObject FAR* FAR* ppObjArray) {return E_NOTIMPL;}

	STDMETHODIMP_(HRESULT)	SetStatus(long lFlags, long lParam, BSTR strParam, IWbemClassObject FAR *pObjParam)	{return E_NOTIMPL;}

	//IMosNotify members
	STDMETHODIMP_(SCODE)	Notify(long lObjectCount, IWbemClassObject** pObjArray);


	CNotifyTableNames(LPISAMTABLELIST lpTblList);
	~CNotifyTableNames();
};

/////////////////////////////////////////////////////////////////////////////
// Some internal functions
/////////////////////////////////////////////////////////////////////////////


/******************************************************************************/

/* Returns the number of column for the table defined in the table definition */
/* This function will return zero if an error is detected                     */

UWORD INTFUNC GetNumberOfColumnsInTable(LPISAMTABLEDEF    lpISAMTableDef);

/***************************************************************************/

/* Creates a communication channel to the Gateway Server                   */
/* via an OLE MS interface                                                 */
/* NULL is returned if the interface could not be created.                 */

void INTFUNC ISAMGetGatewayServer(
								IWbemServicesPtr& pGateway,
								LPISAM lpISAM,
								/* INPUT: Handle returned by ISAMOpen() */
								LPUSTR lpQualifierName = (LPUSTR)"",
									/* INPUT: Qualifier name (parent namespace) */
								SWORD cbQualifierName = 0);
									/* INPUT: Number of bytes in qualifier name */

void INTFUNC ISAMGetGatewayServer(
								IWbemServicesPtr& pGateway,
								LPUSTR lpServerName, 
//								WBEM_LOGIN_AUTHENTICATION loginMethod, 
								LPUSTR objectPath, 
								LPUSTR lpUserName, 
								LPUSTR lpPassword,
								LPUSTR lpLocale,
								LPUSTR lpAuthority,
								DWORD  &dwAuthLevel,
								DWORD  &dwImpLevel,
								BOOL   fIntpretEmptPwdAsBlank,
								COAUTHIDENTITY** ppAuthIdent);

/***************************************************************************/
/* If the ISAM layer reports that it supports transactions, the driver     */
/* be transaction enabled.  When ISAMOpen() is called, it reports back the */
/* transaction capabilites supported in the LPISAM structure:              */
/*                                                                         */
/*      fTxnCapable                                                        */
/*                                                                         */
/*            SQL_TC_NONE: Transactions are not suported                   */
/*                                                                         */
/*            SQL_DC_DML: Transactions can only contain Data Manipulation  */
/*                Language (DML) statements (SELECT, INSERT, UPDATE,       */
/*                DELETE).  Data Definition Language (DDL) statements      */
/*                encountered in a transation cause an error               */ 
/*                                                                         */
/*            SQL_TC_DDL_COMMIT:  Transactions can only contain DML        */
/*                statements.  DDL statements (CREATE TABLE, DROP INDEX,   */
/*                and so on) encountered in a transaction cause the        */
/*                transaction to be committed.                             */
/*                                                                         */
/*            SQL_TC_DDL_IGNORE: Transactions can only contain DML         */
/*                statements.  DDL statements encountered  in a            */
/*                transaction are ignored.                                 */
/*                                                                         */
/*            SQL_TC_ALL: Transactions can contain DDL statements and DML  */
/*                statements in any order.                                 */
/*                                                                         */
/*      fSchemaInfoTransactioned                                           */
/*                                                                         */
/*            There is no explicit "start transaction" ISAM entry point    */
/*            A transaction is started (if there isn't one started         */
/*            already) when certain ISAM calls are made.  This flag        */
/*            specifies if calls that only pertain to the schema of the    */
/*            database (as opposed to calls the pertain to the data in the */
/*            database) will start a transaction or not.                   */
/*                                                                         */
/*            The following functions are only used to process DML         */
/*            statements.  They are not used to process DDL statements.    */
/*            Each of the following functions will start a transaction if  */
/*            one is not already started, regardless of the value of       */ 
/*            fSchemaInfoTransactioned (Note: a transaction will only be   */
/*            started if the function returns ISAM_NO_ERROR, ISAM_EOF, or  */
/*            ISAM_TRUNCATION):                                            */
/*                                                                         */
/*                    ISAMRewind                                           */
/*                    ISAMSort                                             */
/*                    ISAMRestrict                                         */
/*                    ISAMNextRecord                                       */
/*                    ISAMGetData                                          */
/*                    ISAMPutData                                          */
/*                    ISAMInsertRecord                                     */
/*                    ISAMUpdateRecord                                     */
/*                    ISAMDeleteRecord                                     */
/*                    ISAMGetBookmark                                      */
/*                    ISAMPosition                                         */
/*                    ISAMPrepare                                          */
/*                    ISAMParameter                                        */
/*                    ISAMExecute                                          */
/*                                                                         */
/*            The following functions are used to process DML and/or DDL   */
/*            statements.  Each of the following functions will start a    */
/*            transaction if one is not already started only if the value  */
/*            of fSchemaInfoTransactioned is TRUE (Note: a transaction     */
/*            will only be started if the function returns ISAM_NO_ERROR,  */
/*            ISAM_EOF, or ISAM_TRUNCATION):                               */
/*                                                                         */
/*                    ISAMCreateTable                                      */
/*                    ISAMAddColumn                                        */
/*                    ISAMCreateIndex                                      */
/*                    ISAMDeleteIndex                                      */
/*                    ISAMOpenTable                                        */
/*                    ISAMGetTableList                                     */
/*                    ISAMGetNextTableName                                 */
/*                    ISAMForeignKey                                       */
/*                    ISAMDeleteTable                                      */
/*                                                                         */
/*      fMultipleActiveTxn                                                 */
/*                                                                         */
/*            A single user of ISAM may call ISAMOpen() multiple times.    */
/*            If fMultipleActiveTxn is TRUE, separate transactions on each */
/*            of these connections can occur at the same time.  Otherwise, */
/*            only one connection at can have a transaction open at any    */
/*            given time.                                                  */
/*                                                                         */
/*      fTxnIsolationOption                                                */
/*                                                                         */
/*            A 32-bit bitmask enumerating the transaction isolation       */
/*            levels available.  The following bitmasks are used in        */
/*            conjuction with the flag to determine which options are      */
/*            supported:                                                   */
/*                                                                         */
/*                    SQL_TXN_READ_UNCOMMITTED                             */
/*                    SQL_TXN_READ_COMMITTED                               */
/*                    SQL_TXN_REPEATABLE_READ                              */
/*                    SQL_TXN_SERIALIZABLE                                 */
/*                    SQL_TXN_VERSIONING                                   */
/*                                                                         */
/*            These values are described in the ODBC SDK Programmer's      */
/*            reference (under SQLGetInfo(SQL_DEFAULT_TXN_ISOLATION))      */
/*                                                                         */
/*      fDefaultTxnIsolation                                               */
/*            This value specifies which of the above SQL_TXN_* isolation  */
/*            levels is used by default.                                   */
/*                                                                         */
/* Note: ODBC defines an "autocommit" mode which, if enabled, causes       */
/* statements to committed automatically after they are executed. The ISAM */
/* layer does not implement this capability.  The upper levels of the      */
/* system implement autocommit mode.  If the underlying database has an    */                                       
/* autocommit mode, it should be turned off.                               */
/*                                                                         */
/* In addition to reporting this information when ISAMOpen() is called,    */
/* there are three transaction related functions which are used (these are */
/* only called if fTxnCapable is not SQL_TC_NONE):                         */
/*                                                                         */
/*                    ISAMCommitTxn()                                      */
/*                    ISAMRollbackTxn()                                    */
/*                    ISAMSetTxnIsolation()                                */
/*                                                                         */
/***************************************************************************/

SWORD INTFUNC ISAMOpen(
					LPUSTR      lpszServer,
					/* INPUT: The name of the server. If this is an empty string */
					/* the local server will be used                             */
                    LPUSTR      lpszDatabase,
                        /* INPUT: The name of database.  This is specified */
                        /*   by DBQ in the ODBC.INI file or the connect */
                        /*   string. */
                    LPUSTR     lpszDSN,
                        /* INPUT: The name of datasource that is being */
                        /*   connected to. */
//					WBEM_LOGIN_AUTHENTICATION loginMethod,
					    /* INPUT Login method */
                    LPUSTR      lpszUsername,
                        /* INPUT: The user name, as specified at connect */
                        /*   time. */
                    LPUSTR      lpszPassword,
                        /* INPUT: The password, as specified at connect */
                        /*   time. */
					LPUSTR		lpszLocale,
						/* INPUT: Locale */
					LPUSTR		lpszAuthority,
						/* INPUT Authority */
					BOOL      fSysProps,
                        /* INPUT: The system properties flag, as specified at connect */
                        /*   time. */
					CMapStringToOb *pMapStringToOb,
                    LPISAM FAR *lplpISAM,
                        /* OUTPUT: Handle to the ISAM */
                    LPUSTR      lpszErrorMessage,
                        /* OUTPUT: If ISAMOpen() is unsuccessful, an error */
                        /*   message is returned here. */
					BOOL       fOptimization,
						/* INPUT: Flag to indicate is WBEM Level 1 optimzation */
						/* can be used (if applicable) 
						*/
					BOOL       fImpersonate,
						/* INPUT: Flag to indicate if impersonation is requested */
					BOOL       fPassthrghOnly,
						/* INPUT: Flag to indicate if passthrough only mode is requested */
					BOOL		fIntpretEmptPwdAsBlank
						/* INPUT: Flag to indicate how to interpret a blank password */
						);

/* Opens and
 initializes the ISAM.  lpszDatabase points to the name of     */
/* the database.                                                           */

/***************************************************************************/

SWORD INTFUNC ISAMGetTableList(
                    LPISAM lpISAM,
                        /* INPUT: Handle returned by ISAMOpen() */
                    LPUSTR lpPattern,
                        /* INPUT: The pattern to match */
                    SWORD cbPattern,
                        /* INPUT: Number of characters in the pattern */
					LPUSTR lpQualifierName,
						/* INPUT: The qualifier (parent namespace) name */
					SWORD cbQualifierName,
						/* INPUT: Number of characters in the qualifier */
                    LPISAMTABLELIST FAR *lplpISAMTableList,
						/* OUTPUT: Handle to table list */
					BOOL fWantSysTables = TRUE,
						/* INPUT: Do we want system tables */
					BOOL fEmptyTable = FALSE);
					    /* INPUT: Driver only supports table type TABLES */
						/* If this table type is not requested the table */
						/* list should be empty                          */


/* Creates a table list of all that tables that match lpPattern.           */
/* The PatternMatch() function can be used to see if a table               */
/* matches.  cbPattern is always a non-negative number no larger           */
/* the MAX_TABLE_NAME_LENGTH.                                              */
/*                                                                         */
/* This call works outside ISAM's transaction mechanism.  It will not      */
/* start a transaction and the LPISAMTABLELIST handle returned always      */
/* survives a commit or rollback.  The implementation of this function may */
/* have to internally cache the information to return for subsequent calls */
/* to ISAMGetNextTableName().                                              */
/*                                                                         */
/* NULL is returned if the tablelist could not be created.                 */

/***************************************************************************/
/*
class ISAMGetNextTableNameParams
{
public:

	UDWORD fSyncMode;
	LPISAMTABLELIST lpISAMTableList;
	LPUSTR lpTableName;
	LPUSTR lpTableType;					
};


SWORD INTFUNC ISAMGetNextTableName(ISAMGetNextTableNameParams* myParams);
*/

SWORD INTFUNC ISAMGetNextTableName(
					UDWORD fSyncMode,
					/* INPUT: indication if function is to be performed */
					/*        synchronously or asynchronously */
                    LPISAMTABLELIST lpISAMTableList,
                        /* INPUT: Handle returned by ISAMGetTableList() */
                    LPUSTR lpTableName,
                        /* OUTPUT: Buffer where next table name is returned*/
					LPUSTR lpTableType);
						/* OUTPUT: Buffer where table type is returned */


/* Gets the next name from the list.  lpTableName points to a buffer (that */
/* is MAX_TABLE_NAME_LENGTH+1 characters long) that this routine fills in  */
/* with the next table name.  Returns ISAM_EOF if no more tables.          */


/***************************************************************************/

SWORD INTFUNC ISAMGetQualifierList(
					LPISAM lpISAM, 
						/* INPUT: Handle returned by ISAMOpen() */
					LPISAMQUALIFIERLIST FAR *lplpISAMQualifierList);
						/* OUTPUT: Handle to Qualifier list */

/* Creates a qualifier list                                                */
/*                                                                         */
/* NULL is returned if the qualifierlist could not be created.             */

/***************************************************************************/

SWORD INTFUNC ISAMGetNextQualifierName(
					UDWORD fSyncMode,
						/* INPUT: indication if function is to be performed */
						/*        synchronously or asynchronously */
					LPISAMQUALIFIERLIST lpISAMQualifierList,
						/* INPUT: Handle returned by ISAMGetQualifierList() */
					LPUSTR lpQualiferName);
						/* OUTPUT: Buffer where next qualifier name is returned*/

SWORD INTFUNC ISAMGetNextQualifierName2(
					LPISAMQUALIFIERLIST lpISAMQualifierList,
						/* INPUT: Handle returned by ISAMGetQualifierList() */
					LPUSTR lpQualiferName);
						/* OUTPUT: Buffer where next qualifier name is returned*/

/* Gets the next name from the list.lpQualifierName points to a buffer (that */
/* is MAX_QUALIFIER_NAME_LENGTH+1 characters long) that this routine fills in*/
/* with the next qualifier name.  Returns ISAM_EOF if no more qualifiers.    */

/***************************************************************************/

SWORD INTFUNC ISAMFreeTableList(
                    LPISAMTABLELIST lpISAMTableList);
                        /* INPUT: Handle returned by ISAMGetTableList() */

/* Deallocates a table list. */

/***************************************************************************/



SWORD INTFUNC ISAMFreeQualifierList(
					LPISAMQUALIFIERLIST lpISAMQualifierList);
						/* INPUT: Handle returned by ISAMGetQualifierList() */

/* Deallocates a qualifier list. */

/***************************************************************************/

SWORD INTFUNC ISAMForeignKey(
                    LPISAM lpISAM,
                        /* INPUT: Handle returned by ISAMOpen() */
                    LPUSTR lpszPrimaryKeyTableName,
                        /* INPUT: Name of primary key table */
                    LPUSTR lpszForeignKeyTableName,
                        /* INPUT: Name of foreign key table */
                    LPUSTR lpPrimaryKeyName,
                        /* OUTPUT: Buffer where name of primary key is */
                        /*   returned (zero-length string if no name) */
                    LPUSTR lpForeignKeyName,
                        /* OUTPUT: Buffer where name of primary key is */
                        /*   returned (zero-length string if no name) */
                    SWORD FAR *lpfUpdateRule,
                        /* OUTPUT: Update rule for the foreign key */
                        /*   (SQL_CASCASE, SQL_RESTRICT, SQL_SET_NULL, or */
                        /*   -1 if not applicable) */
                    SWORD FAR *lpfDeleteRule,
                        /* OUTPUT: Delete rule for the foreign key */
                        /*   (SQL_CASCASE, SQL_RESTRICT, SQL_SET_NULL, or */
                        /*   -1 if not applicable) */
                    UWORD FAR *lpcISAMKeyColumnList,
                        /* OUTPUT: Number of column in the forien key */
                    LPISAMKEYCOLUMNNAME ISAMPrimaryKeyColumnList,
                        /* OUTPUT: Buffer where name of names of the */
                        /*   primary key columns is returned */
                    LPISAMKEYCOLUMNNAME ISAMForeignKeyColumnList);
                        /* OUTPUT: Buffer where name of names of the */
                        /*   foriegn key columns is returned */

/* Gets a foreign key definition.  lpPrimaryKeyName points to a buffer     */
/* (that is MAX_KEY_NAME_LENGTH+1 characters long) that contains the name  */
/* of the primary key (if any).  lpForeignKeyName points to a buffer (that */
/* is MAX_KEY_NAME_LENGTH+1 characters long) that contains the name of the */
/* foreign key (if any).  lpfUpdateRule specifies the update rule (-1 if   */
/* not applicable.  lpfDeleteRule specifies the update rule (-1 if not     */ 
/* applicable.  ISAMPrimaryKeyColumnList points to an array of buffers     */
/* (each of which is MAX_COLUMN_NAME_LENGTH+1 characters long) that        */ 
/* contains the name of the columns of the primary key.                    */
/* ISAMForeignKeyColumnList points to an array of buffers (each of which   */
/* is MAX_COLUMN_NAME_LENGTH+1 characters long) that contains the name of  */
/* the columns of the foreign key.  The number of key components in        */
/* ISAMPrimaryKeyColumnList and ISAMForeignKeyColumnList is returned       */
/* in lpcISAMKeyColumnList.  Returns ISAM_EOF if no foreign key.           */

/***************************************************************************/

SWORD INTFUNC ISAMCreateTable(
                    LPISAM lpISAM,
                        /* INPUT: Handle returned by ISAMOpen() */
                    LPUSTR lpszTableName,
                        /* INPUT: Name of table to create */
                    LPISAMTABLEDEF FAR *lplpISAMTableDef);
                        /* Output: Handle to the table created */

/* Creates a new table with the given name.  This call be followed by a    */
/* series of ISAMAddColumn() calls and a ISAMCloseTable() call.  No other  */
/* ISAM calls will be made with the LPISAMTABLEDEF returned.               */
/*                                                                         */
/* NULL is returned if the table could not be created.                     */


/***************************************************************************/

SWORD INTFUNC ISAMAddColumn(
                    LPISAMTABLEDEF lpISAMTableDef,
                        /* INPUT: Handle returned by ISAMCreateTable() */
                    LPUSTR lpszColumnName,
                        /* INPUT: The name of the column to create */
                    UWORD iSqlType,
                        /* INPUT: The index into the SQLTypes[] array that */
                        /*   describes the type of the column */
                    UDWORD udParam1,
                        /* INPUT: First create parameter (if any) */
                    UDWORD udParam2);
                        /* INPUT: Second create parameter (if any) */

/* Adds a column to a new table.  lpszColumnName specifies the column      */
/* name.  iSqlType specifies the datatype of the column (it will always be */
/* an index to an element of SQLTypes[] whose 'supported' component is     */ 
/* TRUE).  If the 'params' component designates that there are create      */
/* parameters for the type, udParam1 and udParam2 contain these values.    */
/*                                                                         */
/* This call will only be made on table handles returned by                */
/* ISAMCreateTable().                                                      */ 
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */

/***************************************************************************/


SWORD INTFUNC ISAMCreateIndex(
                    LPISAMTABLEDEF lpISAMTableDef,
                        /* INPUT: Handle returned by ISAMOpenTable() */
                    LPUSTR lpszIndexName,
                        /* INPUT: The name of the index to create/delete */
                    BOOL fUnique,
                        /* INPUT: Unique index? */
                    UWORD          count,
                        /* INPUT: The number of columns in the key */
                    UWORD FAR *    icol,
                        /* INPUT: An array of column ids */
                    BOOL FAR *     fDescending);
                        /* INPUT: An array of ascending/descending flags */

/* Creates an index for this table.  The number of key fields is specified */
/* by count, which must be between 1 and MAX_COLUMNS_IN_INDEX (inclusive). */  
/* icol and fDescending are arrays (count elements long) specifying the    */ 
/* key columns and direction.                                              */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */
/***************************************************************************/

SWORD INTFUNC ISAMDeleteIndex(
                    LPISAM lpISAM,
                        /* INPUT: Handle returned by ISAMOpen() */
                    LPUSTR lpszIndexName);
                        /* INPUT: The name of the index to create/delete */

/* Deletes an index.                                                       */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */

/***************************************************************************/

SWORD INTFUNC ISAMOpenTable(
                    LPISAM lpISAM,
                        /* INPUT: Handle returned by ISAMOpen() */
                    LPUSTR szTableQualifier,
					    /* INPUT: The name of the table qualifier  */
					SWORD cbTableQualifier,
					    /* INPUT: Length of table qualifier  */
					LPUSTR lpszTableName,
                        /* INPUT: The name of the table to open */
                    BOOL fReadOnly,
                        /* INPUT: Flag to indicate whether or not write */
                        /*   access is needed */
                    LPISAMTABLEDEF FAR *lplpISAMTableDef,
                        /* OUTPUT: Handle to the table opened */
					LPSTMT lpstmt = NULL
						/* INPUT : Parent statment handle for Passthrough SQL */
						);

/* Opens the specified table.                                              */

/***************************************************************************/

SWORD INTFUNC ISAMRewind(
                    LPISAMTABLEDEF lpISAMTableDef);
                        /* INPUT: Handle returned by ISAMOpenTable() */

/* Move before the first record in the table.                              */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */


/***************************************************************************/

SWORD INTFUNC ISAMSort(
                    LPISAMTABLEDEF lpISAMTableDef,
                        /* INPUT: Handle returned by ISAMOpenTable() */
                    UWORD          count,
                        /* INPUT: The number of columns to sort on */
                    UWORD FAR *    icol,
                        /* INPUT: An array of column ids */
                    BOOL FAR *     fDescending);
                        /* INPUT: An array of ascending/descending flags */

/* Sorts the records such that ISAMNextRecord() returns the records in     */
/* sorted order.  This may do (but does not have to) a ISAMRewind() before */
/* returning.  After this call is made, ISAMNextRecord() will not be       */ 
/* called until after an ISAMRewind() is called.  The number of sort       */
/* fields is specified by count.  icol and fDescending are arrays (count   */
/* elements long) specifying the sort column and direction.  If count is   */
/* zero, then turn sorting off for this table.                             */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful.  If the ISAM layer cannot      */
/* perform sort, ISAM_NOTSUPPORTED is returned.  Otherwise, ISAM_ERROR     */ 
/* is returned.                                                            */

/***************************************************************************/

SWORD INTFUNC ISAMRestrict(
                    LPISAMTABLEDEF    lpISAMTableDef,
                        /* INPUT: Handle returned by ISAMOpenTable() */
                    UWORD          count,
                        /* INPUT: The number of restrictions */
                    UWORD FAR *       icol,
                        /* INPUT: An array of column ids */
                    UWORD FAR *       fOperator,
                        /* INPUT: An array of ISAM_OP_* value */
                    SWORD FAR *       fCType,
                        /* INPUT: An array of SQL_C_* types of the test */
                        /*        value */
                    PTR FAR *         rgbValue, 
                        /* INPUT: An array of buffers holding the test */
                        /*        value */
                    SDWORD FAR *      cbValue);
                        /* INPUT: An array of lengths of the value in */
                        /*        rgbValue */

/* Specifies that ISAMNextRecord() only needs to return records that       */
/* satisfy:                                                                */
/*                                                                         */
/*                  (<column-1> <operator-1> <value-1>) AND                */
/*                  (<column-2> <operator-2> <value-2>) AND                */
/*                                   ...                                   */
/*                  (<column-n> <operator-n> <value-n>)                    */
/*                                                                         */
/* The columns specified by icol will never have a fSelectivity of 0.      */
/* This may do (but does not have to) a ISAMRewind() before returning.     */
/* After this call is made, ISAMNextRecord() will not be called until      */ 
/* after an ISAMRewind() is called.                                        */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful.  If the ISAM layer cannot      */
/* perform the restriction, ISAM_NOTSUPPORTED is returned.  Otherwise,     */
/* ISAM_ERROR is returned.                                                 */

/***************************************************************************/

SWORD INTFUNC ISAMNextRecord(
                    LPISAMTABLEDEF lpISAMTableDef,
                        /* INPUT: Handle returned by ISAMOpenTable() */
					LPSTMT lpstmt);
						/* INPUT: Handle to current statement */ 

/* Move to the next record in the table.                                   */
/*                                                                         */
/* ISAM_EOF is returned if there are not more record, ISAM_NO_ERROR is     */
/* returned if successful, ISAM_ERROR for failure.                         */

/***************************************************************************/

SWORD INTFUNC ISAMGetData(
                    LPISAMTABLEDEF    lpISAMTableDef,
                        /* INPUT: Handle returned by ISAMOpenTable() */
                    UWORD             icol,
                        /* INPUT: The id of the column */
                    SDWORD            cbOffset, 
                        /* INPUT: When reading a character column the */
                        /*   starting offset to read at.  When reading a */ 
                        /*   binary column as SQL_C_BINARY, the starting */
                        /*   offset to read at.  When reading a binary */
                        /*   column as SQL_C_CHAR the starting character */
                        /*   to return (after the conversion). */
                    SWORD             fCType, 
                        /* INPUT: A SQL_C_* type which designates which */
                        /*   format the data should be returned in. */
                        /*   For character columns this is SQL_C_CHAR.  The */
                        /*       data is returned as a null terminated */
                        /*       character string (if the data is */
                        /*       truncated the entire buffer is filled and */
                        /*       there is no null terminator). */
                        /*   For numerical columns other than SQL_DECIMAL, */
                        /*       SQL_NUMERIC, and SQL_BIGINT; this is */
                        /*       SQL_C_DOUBLE.  The data is returned as */
                        /*       a double. */
                        /*   For numerical columns that are SQL_DECIMAL, */
                        /*       SQL_NUMERIC, or SQL_BIGINT; this is */
                        /*       SQL_C_CHAR.  The data is returned as a */
                        /*       null terminated character string.  For */
                        /*       values with a non-zero scale, 'scale' */
                        /*       digits to the right are returned.  If the */
                        /*       scale is zero, no decimal point is */
                        /*       returned.  The string has no leading or */
                        /*       trailing blanks. */
                        /*    For date columns, this is SQL_C_DATE.  The */
                        /*       data is returned in as a DATE_SRUCT. */
                        /*    For time columns, this is SQL_C_TIME.  The */
                        /*       data is returned in as a TIME_SRUCT. */
                        /*    For timestamp columns, this is */
                        /*       SQL_C_TIMESTAMP data is returned in as a */
                        /*       TIMESTAMP_SRUCT. */
                        /*   For binary columns this is either SQL_C_BINARY */  
                        /*       or SQL_C_CHAR.  If SQL_C_BINARY, the data */
                        /*       is returned in binary form. If SQL_C_CHAR, */
                        /*       the binary value is converted to a */
                        /*       null terminated character string (if the */ 
                        /*       data is truncated the entire buffer is */
                        /*       filled and there is no null terminator). */
                    PTR               rgbValue, 
                        /* OUTPUT: Buffer to hold output value */
                    SDWORD            cbValueMax, 
                        /* INPUT: Size of buffer to hold output value */
                    SDWORD FAR        *pcbValue);
                        /* OUTPUT: Number of bytes returned (not including */
                        /*   null terminator for strings).  If the buffer */
                        /*   is not big enough to return the entire value */
                        /*   this is is set to the total numebe of bytes */
                        /*   for the value, minus cbOffset.  For null */
                        /*   values, this is set to SQL_NULL_DATA */

/* Retrieves a column value from the current record.                       */
/*                                                                         */
/* ISAM_TRUNCATION is returned if the data was too large to fit in the     */
/* buffer provided, ISAM_NO_ERROR is returned if successful, ISAM_ERROR    */
/* for failure.                                                            */

/***************************************************************************/

SWORD INTFUNC ISAMPutData(
                    LPISAMTABLEDEF    lpISAMTableDef,
                        /* INPUT: Handle returned by ISAMOpenTable() */
                    UWORD             icol,
                        /* INPUT: The id of the column */
                    SWORD             fCType, 
                        /* INPUT: A SQL_C_* type which designates which */
                        /*   format the data is sent in. */
                        /*   For character columns this is SQL_C_CHAR.  The */
                        /*       data is a null terminated character */
                        /*       string. */
                        /*   For numerical columns other than SQL_DECIMAL, */
                        /*       SQL_NUMERIC, and SQL_BIGINT); this is */
                        /*       SQL_C_DOUBLE.  The data is a double */
                        /*   For numerical columns that are SQL_DECIMAL, */
                        /*       SQL_NUMERIC, or SQL_BIGINT; this is */
                        /*       SQL_C_CHAR.  The data is a null terminated */ 
                        /*       character string.  For values with a */
                        /*       non-zero scale, the value has 'scale' */
                        /*       digits to the right are returned.  If the */
                        /*       scale is zero, the value has no decimal */
                        /*       point. The string has no leading or */
                        /*       trailing blanks. */
                        /*    For date columns, this is SQL_C_DATE.  The */
                        /*       data is a DATE_SRUCT. */
                        /*    For time columns, this is SQL_C_TIME.  The */
                        /*       data is a TIME_SRUCT. */
                        /*    For timestamp columns, this is */
                        /*       SQL_C_TIMESTAMP.  The data is a */
                        /*       TIMESTAMP_SRUCT. */
                        /*   For binary columns this is SQL_C_BINARY.  The */
                        /*       data is in binary form */
                    PTR               rgbValue, 
                        /* INPUT: The buffer holding the value */ 
                    SDWORD            cbValue);
                        /* INPUT: The size of the buffer.  This is */
                        /*   SQL_NULL_DATA if the value is null. */

/* Updates a column value in the current record.  Note that                */
/* ISAMUpdateRecord will also be called to save the changes.               */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */

/***************************************************************************/

SWORD INTFUNC ISAMInsertRecord(
                    LPISAMTABLEDEF    lpISAMTableDef);
                        /* INPUT: Handle returned by ISAMOpenTable() */

/* Add a new record to the table, and make it the current record.          */
/* All column values in the row are NULL.                                  */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */

/***************************************************************************/

SWORD INTFUNC ISAMUpdateRecord(
                    LPISAMTABLEDEF    lpISAMTableDef);
                        /* INPUT: Handle returned by ISAMOpenTable() */

/* Commit any changes to column values in the current row.                 */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */

/***************************************************************************/

SWORD INTFUNC ISAMDeleteRecord(
                    LPISAMTABLEDEF    lpISAMTableDef);
                        /* INPUT: Handle returned by ISAMOpenTable() */

/* Remove the current record from the table.  Call ISAMNextRecord          */
/* to move the next record before calling ISAMGetData or ISAMPutData.      */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */

/***************************************************************************/

SWORD INTFUNC ISAMGetBookmark(
                    LPISAMTABLEDEF    lpISAMTableDef,
                        /* INPUT: Handle returned by ISAMOpenTable() */
                    LPISAMBOOKMARK    lpISAMBookmark);
                        /* OUTPUT: The bookmark value */

/* Retrieves the bookmark for the current record.  The bookmark is valid   */
/* until the table is closed.  See ISAMPosition().                         */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */

/***************************************************************************/

SWORD INTFUNC ISAMPosition(
                    LPISAMTABLEDEF    lpISAMTableDef,
                        /* INPUT: Handle returned by ISAMOpenTable() */
                    LPISAMBOOKMARK    ISAMBookmark);
                        /* INPUT: The bookmark value */

/* Repositions the current record to the record identified by              */
/* ISAMBookmark.  Note: Once ISAMPosition is called, only ISAMGetData(),   */
/* ISAMPosition(), and ISAMClose() will be called for this table.          */

/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */

/***************************************************************************/

SWORD INTFUNC ISAMCloseTable(
                    LPISAMTABLEDEF    lpISAMTableDef);
                        /* INPUT: Handle returned by ISAMOpenTable() or */
                        /*   ISAMCreateTable() */

/* Closes the table (opened by ISAMOpenTable() or ISAMCreateTable()).      */
/* Note: lpISAMTableDef will be invalid after this call, even if this      */
/* call returns an error.                                                  */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */

/***************************************************************************/

SWORD INTFUNC ISAMDeleteTable(
                    LPISAM lpISAM,
                        /* INPUT: Handle returned by ISAMOpen() */
                    LPUSTR lpszTableName);
                        /* INPUT: The name of the table to delete. */

/* Deletes the table.                                                      */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */

/***************************************************************************/

SWORD INTFUNC ISAMClose(
                    LPISAM lpISAM);
                        /* INPUT: Handle returned by ISAMOpen() */

/* Closes the ISAM (opened by ISAMOpen()).                                 */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful, ISAM_ERROR for failure.        */

/***************************************************************************/

SWORD INTFUNC ISAMPrepare(
                    LPISAM lpISAM,
                        /* INPUT: Handle returned by ISAMOpen() */
                    UCHAR FAR *szSqlStr,
                        /* INPUT: SQL statement to prepare */
                    SDWORD cbSqlStr,
                        /* INPUT: Length of SQL statement to prepare */
                    LPISAMSTATEMENT FAR * lplpISAMStatement,
                        /* OUTPUT: Handle to prepared statement */
                    LPUSTR lpszTablename,
                        /* OUTPUT: If the statement has a result set, */
                        /*   the name of the virtual table that contains */
                        /*   the result set.  Otherwise a zero length */
                        /*   string. */
                    UWORD FAR *lpParameterCount
                        /* OUTPUT: Number of parameters in the statement */
#ifdef IMPLTMT_PASSTHROUGH		
					,LPSTMT lpstmt
#endif
					);
						/* INPUT statement */

/* Prepares an ISAM statment for later execution by ISAMExecute().         */
/*                                                                         */
/* If the statement has a result set (such as a SELECT statement), the     */
/* name of a virtual table that contains the result set is returned.  This */ 
/* table will be opened by ISAMOpenTable() (before ISAMExecute() is        */
/* called).                                                                */  
/*                                                                         */
/* If the statement does not have a result set, a zero length table name   */
/* is returned.                                                            */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful.  If the ISAM layer cannot      */
/* prepare and execute statements, ISAM_NOTSUPPORTED is returned.          */
/* Otherwise, ISAM_ERROR is returned.                                      */

/***************************************************************************/

SWORD INTFUNC ISAMParameter(
                    LPISAMSTATEMENT lpISAMStatement,
                        /* INPUT: Handle returned by ISAMPrepare() */
                    UWORD             ipar,
                        /* INPUT: The id of the parameter (the first */
                        /*       parameter is 1, the second is 2, etc.) */
                    SWORD             fCType, 
                        /* INPUT: A SQL_C_* type which designates which */
                        /*   format the data is sent in. */
                    PTR               rgbValue, 
                        /* INPUT: The buffer holding the value */ 
                    SDWORD            cbValue);
                        /* INPUT: The size of the buffer.  This is */
                        /*   SQL_NULL_DATA if the value is null. */

/* If SQLPrepare() returns a non-zero parameter count this rouitne is      */
/* called once to specify the parameter value ISAMExecute() is to use.     */
/* This routine need not make a copy of the data 'rgbValue' points to,     */
/* it will not change until after SQLExecute() is called.                  */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful.  Otherwise, ISAM_ERROR is      */
/* returned.                                                               */

/***************************************************************************/

SWORD INTFUNC ISAMExecute(
                    LPISAMSTATEMENT lpISAMStatement,
                        /* INPUT: Handle returned by ISAMPrepare() */
                    SDWORD FAR *lpcRowCount);
                        /* OUTPUT: If the prepared statement was an INSERT */
                        /*   UPDATE, or DELETE statement, the number of */
                        /*   rows affected.  Otherwise some meaningful */
                        /*   number is possible (otherwise -1). */

/* Executes a statement previously prepared by ISAMPrepare().  This may    */
/* be called multiple times for one call to ISAMPrepare().                 */
/*                                                                         */
/* ISAM_NO_ERROR is returned if successful.  Otherwise, ISAM_ERROR is      */
/* returned.                                                               */

/***************************************************************************/

SWORD INTFUNC ISAMFreeStatement(
                    LPISAMSTATEMENT lpISAMStatement);
                        /* INPUT: Handle returned by ISAMPrepare() */

/* Frees a previously prepared statement.  ISAM_NO_ERROR is returned if    */
/* successful.  Otherwise, ISAM_ERROR is returned.                         */

/***************************************************************************/
SWORD INTFUNC ISAMSetTxnIsolation(
                    LPISAM lpISAM,
                        /* INPUT: Handle returned by ISAMOpen() */
                    UDWORD fTxnIsolationLevel);
                        /* INPUT: One of the following (see ODBC */
                        /*   documentation for details) : */
                        /*           SQL_TXN_READ_UNCOMMITTED */
                        /*           SQL_TXN_READ_COMMITTED */
                        /*           SQL_TXN_REPEATABLE_READ */
                        /*           SQL_TXN_SERIALIZABLE */
                        /*           SQL_TXN_VERSIONING */

/* Sets the transaction isolation level.  ISAM_NO_ERROR is returned if     */
/* successful.  Otherwise, ISAM_ERROR is returned.                         */

/***************************************************************************/
SWORD INTFUNC ISAMCommitTxn(
                    LPISAM lpISAM);
                        /* INPUT: Handle returned by ISAMOpen() */

/* Commits the current transaction if one is open. If no transaction       */
/* is open, returns successfully anyway.                                   */

/* ISAM_NO_ERROR is returned if successful.  Otherwise, ISAM_ERROR is      */
/* returned.                                                               */

/***************************************************************************/
SWORD INTFUNC ISAMRollbackTxn(
                    LPISAM lpISAM);
                        /* INPUT: Handle returned by ISAMOpen() */

/* Rolls back the current transaction if one is open. If no transaction    */
/* is open, returns successfully anyway.                                   */

/* ISAM_NO_ERROR is returned if successful.  Otherwise, ISAM_ERROR is      */
/* returned.                                                               */

/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/

void INTFUNC ISAMGetErrorMessage(
                    LPISAM lpISAM,
                        /* INPUT: Handle returned by ISAMOpen() */
                    LPUSTR  lpszErrorMessage);
                        /* OUTPUT: The error message associated with the */
                        /*   most recent call to an ISAM call */

/* Returns the error message associated with the most recent call to an    */
/* ISAM function.                                                          */

/***************************************************************************/

LPSQLTYPE INTFUNC ISAMGetColumnType(
                    LPISAMTABLEDEF lpISAMTableDef,
                        /* INPUT: Handle returned by ISAMOpenTable() */
                    UWORD icol);
                        /* INPUT: Id of column */

/* Returns a pointer to the description of the SQL_* type of the column. */

/***************************************************************************/

BOOL INTFUNC ISAMCaseSensitive(LPISAM lpISAM);

/* Are column and table names case-sensitive?                              */

/***************************************************************************/

LPUSTR INTFUNC ISAMName(
					LPISAM lpISAM);
                        /* INPUT: Handle returned by ISAMOpen() */

/* Returns pointer to a string containing the name of the DBMS or file     */
/* format 
                                                                */

/***************************************************************************/
LPUSTR INTFUNC ISAMServer(
					LPISAM lpISAM); 


LPUSTR INTFUNC ISAMVersion(
					LPISAM lpISAM);
                        /* INPUT: Handle returned by ISAMOpen() */

/* Returns pointer to a string containing the version of the DBMS or file  */
/* format.                                                                 */

/***************************************************************************/

LPUSTR INTFUNC ISAMRoot (LPISAM lpISAM);

/***************************************************************************/

SWORD INTFUNC ISAMGetTableAttr(LPISAMTABLEDEF lpISAMTableDef, LPSTR pAttrStr, SDWORD cbValueMax, SDWORD &cbBytesCopied);

/***************************************************************************/

LPCUSTR INTFUNC ISAMDriver(
                    LPISAM lpISAM);
                        /* INPUT: Handle returned by ISAMOpen() */

/* Returns pointer to a string containing the name of driver DLL           */

/***************************************************************************/

SWORD INTFUNC ISAMMaxTableNameLength(
                    LPISAM lpISAM);
                        /* INPUT: Handle returned by ISAMOpen() */

/* Returns the maximum length of a table name.  Must not exceed            */
/* MAX_TABLE_NAME_LENGTH.                                                  */

/***************************************************************************/

SWORD INTFUNC ISAMMaxColumnNameLength(
                    LPISAM lpISAM);
                        /* INPUT: Handle returned by ISAMOpen() */

/* Returns the maximum length of a column name.  Must not exceed           */
/* MAX_COLUMN_NAME_LENGTH.                                                 */

/***************************************************************************/

LPUSTR INTFUNC ISAMUser(
                    LPISAM lpISAM);
                        /* INPUT: Handle returned by ISAMOpen() */

/* Returns the current username.  Must not exceed MAX_USER_NAME_LENGTH.    */

/***************************************************************************/

LPUSTR INTFUNC ISAMDatabase(
                    LPISAM lpISAM);
                        /* INPUT: Handle returned by ISAMOpen() */

/* Returns the current database.  Must not exceed MAX_DATABASE_NAME_LENGTH */

/***************************************************************************/

int INTFUNC ISAMSetDatabase (LPISAM lpISAM, LPUSTR database);

/***************************************************************************/

SWORD ISAMGetValueFromVariant(VARIANT			&vVariantVal,
							  SWORD             fCType, 
							  PTR               rgbValue, 
							  SDWORD            cbValueMax, 
							  SDWORD FAR        *pcbValue,
							  SWORD              wbemVariantType,
							  BSTR				syntaxStr = NULL,
							  SDWORD			maxLenVal  = -1,
							  long              myVirIndex = -1);

/* This function decodes a variant value and stores it in rgbValue*/
/* the format of the value is govend by fcType                    */
/* For more info on parameters see ISAMGetData                    */

/***************************************************************************/

SWORD INTFUNC ISAMBuildTree (HTREEITEM hrootNode, //IN
					  char *namespaceName, //IN
					  CTreeCtrl& treeCtrl, // IN
					  CConnectionDialog& dialog,//IN
					  char *server,			 //IN
//					  WBEM_LOGIN_AUTHENTICATION loginMethod, //IN
					  char *username,		 //IN
					  char *password, 		 //IN
					  BOOL fIntpretEmptPwdAsBlank, //IN
					  char *locale,			 //IN
					  char *authority,		 //IN
					  BOOL fNeedChildren,	 //IN
					  BOOL deep,			 //IN
					  HTREEITEM& hTreeItem); //OUT

/***************************************************************************/

SWORD INTFUNC ISAMBuildTreeChildren (HTREEITEM hParent, //IN
						 char *namespaceName,			//IN
						 CTreeCtrl& treeCtrl,			//IN
						 CConnectionDialog& dialog,		//IN
						 char *server,					//IN
//						 WBEM_LOGIN_AUTHENTICATION loginMethod, //IN
						 char *username,				//IN
						 char *password,				//IN
						 BOOL fIntpretEmptPwdAsBlank,	//IN
						 char *locale,					//IN
						 char *authority,				//IN
						 BOOL deep = FALSE);

/***************************************************************************/

SWORD INTFUNC ISAMGetNestedNamespaces (char *parent, //IN 
									   char *name, //IN
									   IWbemServices *pGateway, //IN
									   DWORD dwAuthLevel, //IN
									   DWORD dwImpLevel, //IN
									   char *server, //IN
//									   WBEM_LOGIN_AUTHENTICATION loginMethod, //IN
									   char *user, //IN
									   char *pswd, //IN
									   BOOL fIntpretEmptPwdAsBlank, //IN
									   char *locale, //IN
									   char *authority, //IN
									   CMapStringToOb *map,	// OUT
									   BOOL bDeep = TRUE); // IN

/***************************************************************************/

IWbemContext* ISAMCreateLocaleIDContextObject(char* lpLocale); //IN

void ISAMAddLocaleIDContextObject(LPISAMTABLEDEF lpISAMTableDef,	//IN OUT
								  LPISAM lpISAM);					//IN

void ISAMStringConcat(char** resultString, char* myStr);

void ISAMCheckTracingOption();

void ISAMPatchUpGatewaySecurity(LPISAM lpISAM, IWbemServices* myServicesPtr);

void ISAMGetIWbemServices(LPISAM lpISAM, CSafeWbemServices& mServices, IWbemServicesPtr& myServicesPtr);

void ISAMCloseWorkerThread1();

void ISAMCloseWorkerThread2(UINT wParam, LONG lParam);

void ISAMCheckWorkingThread_AllocEnv();

void ISAMCheckWorkingThread_FreeEnv();

BOOL IsW2KOrMore(void);

HRESULT WbemSetDynamicCloaking(IUnknown* pProxy, 
                    DWORD dwAuthnLevel, DWORD dwImpLevel);

HRESULT ISAMSetCloaking1(IUnknown* pProxy, BOOL fIsLocalConnection, BOOL fW2KOrMore, DWORD dwAuthLevel, DWORD dwImpLevel,
				 BSTR authorityBSTR, BSTR userBSTR, BSTR passwdBSTR, COAUTHIDENTITY ** gpAuthIdentity);

HRESULT ISAMSetCloaking2(IUnknown* pProxy, BOOL fIsLocalConnection, BOOL fW2KOrMore, DWORD dwAuthLevel, DWORD dwImpLevel,
				 COAUTHIDENTITY * gpAuthIdentity);

BOOL IsLocalServer(LPSTR szServer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\precomp.h ===
// precomp.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>          // MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>         // MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\parse.h ===
/***************************************************************************/
/* PARSE.H                                                                 */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/

#define SQLNODEIDX int
#define NO_SQLNODE (-1)
#define ROOT_SQLNODE 0
#define SQLNODE_ALLOC 16

#define STRINGIDX int
#define NO_STRING (-1)
#define STRING_ALLOC 512 //was 128

#define NO_SCALE (-1)

#define OP_NONE       0
#define OP_EQ         1
#define OP_NE         2
#define OP_LE         3
#define OP_LT         4
#define OP_GE         5
#define OP_GT         6
#define OP_IN         7
#define OP_NOTIN      8
#define OP_LIKE       9
#define OP_NOTLIKE   10
#define OP_NEG       11
#define OP_PLUS      12
#define OP_MINUS     13
#define OP_TIMES     14
#define OP_DIVIDEDBY 15
#define OP_NOT       16
#define OP_AND       17
#define OP_OR        18
#define OP_EXISTS    19

#define AGG_AVG       1
#define AGG_COUNT     2
#define AGG_MAX       3
#define AGG_MIN       4
#define AGG_SUM       5

#define SELECT_NOTSELECT   0
#define SELECT_ALL         1
#define SELECT_ANY         2
#define SELECT_ONE         3
#define SELECT_EXISTS      4

#define NOT_IN_SORT_RECORD 0

typedef struct  tagSQLNODE {   /* Node in SQL parse tree */
    UWORD       sqlNodeType;                /* NODE_TYPE_* */
    SWORD       sqlDataType;                /* TYPE_* (set by SemanticCheck()) */
    SWORD       sqlSqlType;                 /* SQL_* (set by SemanticCheck()) */
    SDWORD      sqlPrecision;               /* Precision (set by SemanticCheck()) */
    SWORD       sqlScale;                   /* Scale if sqlSqlType is */
                                            /*   SQL_DECIMAL or SQL_NUMERIC */
                                            /*   (set by SemanticCheck()) */
    BOOL        sqlIsNull;                  /* Is expression value NULL (set */
                                            /*   at execution time)? */
    union {
        double      Double;          /* When sqlDataType == TYPE_DOUBLE or */
                                     /*    TYPE_INTEGER */
        LPUSTR       String;          /* When sqlDataType == TYPE_CHAR or */
                                     /*    TYPE_NUMERIC */
        DATE_STRUCT Date;            /* When sqlDataType == TYPE_DATE */
        TIME_STRUCT Time;            /* When sqlDataType == TYPE_TIME */
        TIMESTAMP_STRUCT Timestamp;  /* When sqlDataType == TYPE_TIMESTAMP */
        LPUSTR       Binary;          /* When sqlDataType == TYPE_BINARY */
                                     /*    (length is in first four bytes) */
    } value;
    union {

        /* NODE_TYPE_ROOT */
        struct {
            LPISAM      lpISAM;             /* ISAM opening */
            HGLOBAL     hParseArray;        /* Handle to memory holding this */
                                            /*   parse node array */
            int         cParseArray;        /* Number of elements in */
                                            /*   hParseArray */
            int         iParseArray;        /* Last element in hParseArray */
                                            /*   in use */
            HGLOBAL     hStringArea;        /* Handle to memory holding the */
                                            /*   string area */
            LPUSTR       lpStringArea;       /* Pointer to memory holding the */
                                            /*   string area */
            int         cbStringArea;       /* Size of string area */
            int         ibStringArea;       /* Last byte in string area in */
                                            /*   use */
            SQLNODEIDX  sql;                /* CREATE, DROP, SELECT, INSERT, */
                                            /*   DELETE, UPDATE, */
                                            /*   CREATEINDEX, DROPINDEX, */
                                            /*   PASSTHROUGH */
            SQLNODEIDX  parameters;         /* List of parameters for the */
                                            /*   query (this points to a */
                                            /*   PARAMETER or NO_SQLNODE) */
            BOOL        passthroughParams;  /* Are parameters from a */
                                            /*   passthrough statement? */
        } root;

        /* NODE_TYPE_CREATE */
        struct {
            STRINGIDX   Table;              /* Offset into the string area */
                                            /*   for the name of the table */
            SQLNODEIDX  Columns;            /* CREATECOLS */
        } create;

        /* NODE_TYPE_DROP */
        struct {
            STRINGIDX   Table;              /* Offset into the string area */
                                            /*   for the name of the table */
        } drop;

        /* NODE_TYPE_CREATEINDEX */
        struct {
            STRINGIDX   Index;              /* Offset into the string area */
                                            /*   for the name of the table */
            SQLNODEIDX  Table;              /* TABLE */
            SQLNODEIDX  Columns;            /* SORTCOLUMNS */
            BOOL        Unique;             /* Unique index? */
        } createindex;

        /* NODE_TYPE_DROPINDEX */
        struct {
            STRINGIDX   Index;              /* Offset into the string area */
                                            /*   for the name of the index */
        } dropindex;

        /* NODE_TYPE_SELECT */
        struct {
            BOOL        Distinct;           /* TRUE, FALSE */
            SQLNODEIDX  Values;             /* VALUES */
            SQLNODEIDX  Tables;             /* TABLES */
            SQLNODEIDX  Predicate;          /* BOOLEAN, COMPARISON, */
                                            /*   NO_SQLNODE */
            SQLNODEIDX  Groupbycolumns;     /* GROUPBYCOLUMNS, NO_SQLNODE */
            SQLNODEIDX  Having;             /* BOOLEAN, COMPARISON, */
                                            /*   NO_SQLNODE */
            SQLNODEIDX  Sortcolumns;        /* SORTCOLUMNS, NO_SQLNODE */

            /* The following elements are set by SemanticCheck(): */
            STRINGIDX   SortDirective;      /* Offset into the string area */
                                            /*   to sort directive */
            UDWORD      SortRecordsize;     /* Size of records in sort file */
            UDWORD      SortBookmarks;      /* Offset of bookmarks in sort */
                                            /*   record (one based)        */
            SQLNODEIDX  Aggregates;         /* List of aggregates for the */
                                            /*   query (this points to a */
                                            /*   AGGREGATE or NO_SQLNODE) */
            UDWORD      SortKeysize;        /* Size of key in sort file */
            STRINGIDX   DistinctDirective;  /* Offset into the string area */
                                            /*   to DISTINCT sort directive */
            UDWORD      DistinctRecordsize; /* Size of records in DISTINCT */
                                            /*   sort file */
            BOOL        ImplicitGroupby;    /* If TRUE, the user did not */
                                            /*   specify a groupby but one */
                                            /*   that contains the entire */
                                            /*   table was added because */
                                            /*   select list specified had */
                                            /*   an aggregate function */
            SQLNODEIDX  EnclosingStatement; /* SELECT, INSERT, DELETE, */
                                            /*   UPDATE, NO_SQLNODE */

            /* The following elements are set by Optimize(): */
            BOOL        fPushdownSort;      /* Use ISAMSort() routines? */
            BOOL        fMSAccess;          /* Is this the funny MSAccess */
                                            /*   query (see OPTIMIZE.C) ? */

            /* The following elements are set by ExecuteQuery(): */
            SDWORD      RowCount;           /* Number of rows */
            SDWORD      CurrentRow;         /* Current row fetched */
            STRINGIDX   SortfileName;       /* Name of the sortfile */
            HFILE       Sortfile;           /* Sortfile */
            BOOL        ReturningDistinct;  /* Does the sort file contain */
                                            /*   results of a DISTINCT op */
        } select;

        /* NODE_TYPE_INSERT */
        struct {
            SQLNODEIDX  Table;              /* TABLE */
            SQLNODEIDX  Columns;            /* COLUMNS */
            SQLNODEIDX  Values;             /* VALUES, SELECT */
        } insert;

        /* NODE_TYPE_DELETE */
        struct {
            SQLNODEIDX  Table;              /* TABLE */
            SQLNODEIDX  Predicate;          /* BOOLEAN, COMPARISON, */
                                            /*   NO_SQLNODE */
        } delet;

        /* NODE_TYPE_UPDATE */
        struct {
            SQLNODEIDX  Table;              /* TABLE */
            SQLNODEIDX  Updatevalues;       /* UPDATEVALUES */
            SQLNODEIDX  Predicate;          /* BOOLEAN, COMPARISON, */
                                            /*   NO_SQLNODE */
        } update;

        /* NODE_TYPE_PASSTHROUGH */

        /* NODE_TYPE_TABLES */
        struct {
            SQLNODEIDX  Table;              /* TABLE */
            SQLNODEIDX  Next;               /* TABLES, NO_SQLNODE */
        } tables;

        /* NODE_TYPE_VALUES */
        struct {
            SQLNODEIDX  Value;              /* COLUMN, ALGEBRAIC, SCALAR, */
                                            /*   AGGREGATE, NUMERIC, */
                                            /*   STRING, PARAMETER, USER, */
                                            /*   NULL */
            STRINGIDX   Alias;              /* Offset into the string area */
                                            /*   for the alias (only used */
                                            /*   for SELECT statements) */
            SQLNODEIDX  Next;               /* VALUES, NO_SQLNODE */
        } values;

        /* NODE_TYPE_COLUMNS */
        struct {
            SQLNODEIDX  Column;             /* COLUMN */
            SQLNODEIDX  Next;               /* COLUMNS, NO_SQLNODE */
        } columns;

        /* NODE_TYPE_SORTCOLUMNS */
        struct {
            SQLNODEIDX  Column;             /* COLUMN */
            BOOL        Descending;         /* TRUE, FALSE */
            SQLNODEIDX  Next;               /* SORTCOLUMNS, NO_SQLNODE */
        } sortcolumns;

        /* NODE_TYPE_GROUPBYCOLUMNS */
        struct {
            SQLNODEIDX  Column;             /* COLUMN */
            SQLNODEIDX  Next;               /* GROUPBYCOLUMNS, NO_SQLNODE */
        } groupbycolumns;

        /* NODE_TYPE_UPDATEVALUES */
        struct {
            SQLNODEIDX  Column;             /* COLUMN */
            SQLNODEIDX  Value;              /* COLUMN, ALGEBRAIC, SCALAR, */
                                            /*   AGGREGATE, NUMERIC, */
                                            /*   STRING, PARAMETER, USER, */
                                            /*   NULL */
            SQLNODEIDX  Next;               /* UPDATEVALUES, NO_SQLNODE */
        } updatevalues;

        /* NODE_TYPE_CREATECOLS */
        struct {
            STRINGIDX   Name;               /* Offset into the string area */
                                            /*   for the name of the column */
            STRINGIDX   Type;               /* Offset into the string area */
                                            /*   for the data type name */
            UWORD       Params;             /* Number of create params */
            UDWORD      Param1;             /* Value of param 1 (if any) */
            UDWORD      Param2;             /* Value of param 2 (if any) */
            SQLNODEIDX  Next;               /* CREATECOLS, NO_SQLNODE */

            /* The following elements are set by SemanticCheck(): */
            UWORD       iSqlType;           /* Index into SQLTypes[] of */
                                            /*   the type of the column */
        } createcols;

        /* NODE_TYPE_BOOLEAN */
        struct {
            UWORD       Operator;           /* OP_NOT, OP_AND, or OP_OR */ 
            SQLNODEIDX  Left;               /* BOOLEAN, COMPARISON, */
            SQLNODEIDX  Right;              /* BOOLEAN, COMPARISON, */
                                            /*   NO_SQLNODE */
        } boolean;

        /* NODE_TYPE_COMPARISON */
        struct {
            UWORD       Operator;           /* OP_EQ, OP_NE, OP_LE, OP_LT, */
                                            /*    OP_GE, OP_GT, OP_LIKE, */
                                            /*    OP_NOTLIKE, OP_IN, */
                                            /*    OP_NOTIN, OP_EXISTS */
            UWORD       SelectModifier;     /* SELECT_NOTSELECT, */
                                            /*   SELECT_ALL, SELECT_ANY, */
                                            /*   SELECT_ONE, SELECT_EXISTS */
            SQLNODEIDX  Left;               /* COLUMN, ALGEBRAIC, SCALAR, */
                                            /*   AGGREGATE, NUMERIC, */
                                            /*   STRING, PARAMETER, USER, */
                                            /*   SELECT, NULL */
            SQLNODEIDX  Right;              /* COLUMN, ALGEBRAIC, SCALAR, */
                                            /*   AGGREGATE, NUMERIC, */
                                            /*   STRING, PARAMETER, USER, */
                                            /*   VALUES (for IN/NOTIN op), */ 
                                            /*   SELECT, NULL */

            /* The following elements are set by Optimize(): */
            UWORD       fSelectivity;       /* Selectivity the restriction */
            SQLNODEIDX  NextRestrict;       /* COMPARISON, NO_SQLNODE */
                                            /* The next restriction on the */
                                            /* list of restrictions */
        } comparison;

        /* NODE_TYPE_ALGEBRAIC */
        struct {
            UWORD       Operator;           /* OP_NEG, OP_PLUS, */
                                            /*   OP_MINUS, OP_TIMES, */
                                            /*   OP_DIVIDEDBY */
            SQLNODEIDX  Left;               /* COLUMN, ALGEBRAIC, SCALAR, */
                                            /*   AGGREGATE, NUMERIC, */
                                            /*   STRING, PARAMETER, USER, */
                                            /*   NULL */
            SQLNODEIDX  Right;              /* COLUMN, ALGEBRAIC, SCALAR, */
                                            /*   AGGREGATE, NUMERIC, */
                                            /*   STRING, PARAMETER, USER, */
                                            /*   NULL, NO_SQLNODE */

            /* The following elements are set by SemanticCheck(): */
            STRINGIDX   Value;              /* Value used to evaluate      */
                                            /*   expressions               */
            STRINGIDX   WorkBuffer1;        /* Workbuffer used to evaluate */
                                            /*   NUMERIC multiply & divide */
            STRINGIDX   WorkBuffer2;        /* Workbuffer used to evaluate */
                                            /*   NUMERIC divide            */
            STRINGIDX   WorkBuffer3;        /* Workbuffer used to evaluate */
                                            /*   NUMERIC divide            */
            UDWORD      DistinctOffset;     /* The offset the column is in */
                                            /*   in the sort DISTINCT      */
                                            /*   record (one based).       */
            UDWORD      DistinctLength;     /* The length of the column in */
                                            /*   the sort DISTINCT record. */
            SQLNODEIDX  EnclosingStatement; /* SELECT, INSERT, DELETE,     */
                                            /*   UPDATE                    */
        } algebraic;

        /* NODE_TYPE_SCALAR */
        struct {
            STRINGIDX   Function;           /* Name of the function */
            SQLNODEIDX  Arguments;          /* VALUES, NO_SQLNODE */

            /* The following elements are set by SemanticCheck(): */
            UWORD       Id;                 /* Scaler function id          */
            UWORD       Interval;           /* Interval for TIMESTAMPADD   */
                                            /*   and TIMESTAMPDIFF         */
            STRINGIDX   Value;              /* Value used to evaluate      */
                                            /*   expressions               */
            UDWORD      DistinctOffset;     /* The offset the column is in */
                                            /*   in the sort DISTINCT      */
                                            /*   record (one based).       */
            UDWORD      DistinctLength;     /* The length of the column in */
                                            /*   the sort DISTINCT record. */
            SQLNODEIDX  EnclosingStatement; /* SELECT, INSERT, DELETE,     */
                                            /*   UPDATE                    */
        } scalar;

        /* NODE_TYPE_AGGREGATE */
        struct {
            UWORD       Operator;           /* AGG_AVE, AGG_COUNT, */
                                            /*   AGG_MAX, AGG_MIN, AGG_SUM */
            SQLNODEIDX  Expression;         /* COLUMN, ALGEBRAIC, SCALAR, */
                                            /*   AGGREGATE, NUMERIC, */
                                            /*   STRING, PARAMETER, USER, */
                                            /*   NULL */

            /* The following elements are set by SemanticCheck(): */
            STRINGIDX   Value;              /* Column value used to        */
                                            /*   evaluate expressions      */
            UDWORD      Offset;             /* The offset the column is in */
                                            /*   in the sort record (one   */
                                            /*   based).                   */
            UDWORD      Length;             /* The length of the column in */
                                            /*   the sort record.          */
            UDWORD      DistinctOffset;     /* The offset the column is in */
                                            /*   in the sort DISTINCT      */
                                            /*   record (one based).       */
            UDWORD      DistinctLength;     /* The length of the column in */
                                            /*   the sort DISTINCT record. */
            SQLNODEIDX  EnclosingStatement; /* SELECT, INSERT, DELETE,     */
                                            /*   UPDATE                    */
            SQLNODEIDX  Next;               /* Rest of list of AGG         */
                                            /*   functions for the query   */
                                            /*   (this points to an        */
                                            /*   AGGREGATE or NO_SQLNODE)  */
            /* The following elements are set at execution time: */
            double      Count;              /* Number of records that had */
                                            /*   a non-NULL value          */
        } aggregate;

        /* NODE_TYPE_TABLE */
        struct {
            STRINGIDX   Name;               /* Offset into the string area */
                                            /*   for the name of the table */
			STRINGIDX	Qualifier;			/* Offset into the string area */
											/*   for the qulaifier of the table */
            STRINGIDX   Alias;              /* Offset into the string area */
                                            /*   for the name of the alias */
            SQLNODEIDX  OuterJoinFromTables;/* TABLES, NO_SQLNODE */
            SQLNODEIDX  OuterJoinPredicate; /* BOOLEAN, COMPARISON, */
                                            /*   NO_SQLNODE */

            /* The following elements are set by SemanticCheck(): */
            LPISAMTABLEDEF  Handle;         /* Table handle */

            /* The following elements are set by Optimize(): */
            UWORD           cRestrict;      /* The number of Restrict nodes */
            SQLNODEIDX      Restrict;       /* COMPARISON, NO_SQLNODE (if   */
                                            /*  this points to a comparison */
                                            /*  node, the node is somewhere */
                                            /*  in the predicate, and is in */
                                            /*  the form:                   */
                                            /*                              */
                                            /*     <column> <op> <constant> */
                                            /*                              */
                                            /*  where <column> is some      */
                                            /*  column of this table)       */
            UWORD           Sortsequence;   /* The relative position of     */
                                            /*  this table when sorting     */
            UWORD           Sortcount;      /* The number of sort columns   */
                                            /*  for this table              */
            SQLNODEIDX      Sortcolumns;    /* SORTCOLUMNS, NO_SQLNODE (the */
                                            /*  first in the list of sort   */
                                            /*  columns for this table)     */

            /* The following elements are set at execution time: */
            BOOL            AllNull;        /* Use NULL as value for all   */
                                            /*   columns in current row    */
            BOOL            Rewound;        /* Is table positioned before  */
                                            /*   first record?             */
        } table;

        /* NODE_TYPE_COLUMN */
        struct {
            STRINGIDX   Tablealias;         /* Offset into the string area */
                                            /*   for the name of the alias */
            STRINGIDX   Column;             /* Offset into the string area */
                                            /*   for the name of the column */
			STRINGIDX	Qualifier;			/* Offset into the string area */
											/*   for the name of the       */
											/*   qualifier                 */
			BOOL		MatchedAlias;		/* indicates if the TableAlias */
											/* refers to a table name or an*/
											/* alias.					   */
			SQLNODEIDX	TableIndex;			/* index of table node to which*/
											/* column belongs			   */
											/* This renders the info above */
											/* redundant.                  */


            /* The following elements are set by SemanticCheck(): */
            SQLNODEIDX  Table;              /* TABLE, NO_SQLNODE.  Table   */ 
                                            /*   of the column.  If        */
                                            /*   NO_SQLNODE, the column is */
                                            /*   in sort record.           */
            SWORD       Id;                 /* Ordinal position of column  */
            STRINGIDX   Value;              /* Column value used to        */
                                            /*   evaluate expressions      */
            BOOL        InSortRecord;       /* Is this column in the sort  */
                                            /*   record?                   */
            UDWORD      Offset;             /* The offset the column is in */
                                            /*   in the sort record (one   */
                                            /*   based).                   */
            UDWORD      Length;             /* The length of the column if */
                                            /*   it is in the sort record. */
            UDWORD      DistinctOffset;     /* The offset the column is in */
                                            /*   in the sort DISTINCT      */
                                            /*   record (one based).       */
            UDWORD      DistinctLength;     /* The length of the column in */
                                            /*   the sort DISTINCT record. */
            SQLNODEIDX  EnclosingStatement; /* SELECT, INSERT, DELETE,     */
                                            /*   UPDATE                    */
        } column;

        /* NODE_TYPE_STRING */
        struct {
            STRINGIDX   Value;              /* Offset into the string area */
                                            /*   for the string */
        } string;

        /* NODE_TYPE_NUMERIC */
        struct {
			double		Value;
            STRINGIDX   Numeric;
        } numeric;

        /* NODE_TYPE_PARAMETER */
        struct {
            UWORD       Id;                 /* Ordinal position of parameter */
            SQLNODEIDX  Next;               /* Rest of list of parameters for */
                                            /*   the query (this points to a */
                                            /*   PARAMETER or NO_SQLNODE) */

            /* The following elements are set by SemanticCheck(): */
            STRINGIDX   Value;              /* Parameter value used to  */
                                            /*   evaluate expressions */
            
            /* The following elements are set at execution time: */
            BOOL        AtExec;             /* Value to be provided by */
                                            /*   ParamData()/PutData() */
        } parameter;

        /* NODE_TYPE_USER */
        
        /* NODE_TYPE_NULL */

        /* NODE_TYPE_DATE */
        struct {
            DATE_STRUCT Value;
        } date;

        /* NODE_TYPE_TIME */
        struct {
            TIME_STRUCT Value;
        } time;

        /* NODE_TYPE_TIMESTAMP */
        struct {
            TIMESTAMP_STRUCT Value;
        } timestamp;
    } node;
}       SQLNODE,
        FAR * LPSQLNODE;

#define LPSQLTREE LPSQLNODE

#define NODE_TYPE_NONE            0
#define NODE_TYPE_ROOT            1
#define NODE_TYPE_CREATE          2
#define NODE_TYPE_DROP            3
#define NODE_TYPE_SELECT          4
#define NODE_TYPE_INSERT          5
#define NODE_TYPE_DELETE          6
#define NODE_TYPE_UPDATE          7
#define NODE_TYPE_PASSTHROUGH     8
#define NODE_TYPE_TABLES          9
#define NODE_TYPE_VALUES         10
#define NODE_TYPE_COLUMNS        11
#define NODE_TYPE_SORTCOLUMNS    12
#define NODE_TYPE_GROUPBYCOLUMNS 13
#define NODE_TYPE_UPDATEVALUES   14
#define NODE_TYPE_CREATECOLS     15
#define NODE_TYPE_BOOLEAN        16
#define NODE_TYPE_COMPARISON     17
#define NODE_TYPE_ALGEBRAIC      18
#define NODE_TYPE_AGGREGATE      19
#define NODE_TYPE_TABLE          20
#define NODE_TYPE_COLUMN         21
#define NODE_TYPE_STRING         22
#define NODE_TYPE_NUMERIC        23
#define NODE_TYPE_PARAMETER      24
#define NODE_TYPE_USER           25
#define NODE_TYPE_NULL           26
#define NODE_TYPE_DATE           27
#define NODE_TYPE_TIME           28
#define NODE_TYPE_TIMESTAMP      29
#define NODE_TYPE_CREATEINDEX    30
#define NODE_TYPE_DROPINDEX      31
#define NODE_TYPE_SCALAR         32

//Class used to re-convert WHERE predicate back into character string
class PredicateParser
{
private:
	LPSQLTREE FAR *lplpSql;
	LPISAMTABLEDEF lpISAMTableDef;
	BOOL fError;
	BOOL fSupportLIKEs;

	//Generates string for a comparision expression
	void GenerateComparisonString(char* lpLeftString, char* lpRightString, UWORD wOperator, UWORD wSelectModifier, char** lpOutputStr);
	
	//Generates string for a boolean expression
	void GenerateBooleanString(char* lpLeftString, char* lpRightString, UWORD wOperator, char** lpOutputStr);

	//Generates string for an aggregate expression
	void GenerateAggregateString(char* lpLeftString, UWORD wOperator, char** lpOutputStr);

	//Generates string for an algebraic expression
	void GenerateAlgebraicString(char* lpLeftString, char* lpRightString, UWORD wOperator, char** lpOutputStr);

	//Builds a column reference
	void GenerateColumnRef(LPSQLNODE lpSqlNode, char ** lpOutputStr, BOOL fIsSQL89);

public:

	//Generates WHERE predicate string from SQLNODETREE
	void GeneratePredicateString(LPSQLNODE lpSqlNode, char** lpOutputStr, BOOL fIsSQL89 = TRUE);

	//Builds GROUP BY statement
	void GenerateGroupByString(LPSQLNODE lpSqlNode, char ** lpOutputStr, BOOL fIsSQL89);

	//Builds ORDER BY statement
	void GenerateOrderByString(LPSQLNODE lpSqlNode, char ** lpOutputStr, BOOL fIsSQL89);


//	PredicateParser(LPSQLTREE FAR *lplpTheSql, SQLNODEIDX  iPredicate)	
//				{lplpSql = lplpTheSql; Predicate = iPredicate;}

	PredicateParser(LPSQLTREE FAR *lplpTheSql, LPISAMTABLEDEF lpISAMTblDef, BOOL fLIKEs = TRUE)	
				{lplpSql = lplpTheSql; lpISAMTableDef = lpISAMTblDef; fError = FALSE; fSupportLIKEs = fLIKEs;}
	~PredicateParser()	{;}
};

class PassthroughLookupTable
{
private:
	char tableAlias [MAX_QUALIFIER_NAME_LENGTH + 1];
	char columnName [MAX_COLUMN_NAME_LENGTH + 1];

public:

	BOOL	SetTableAlias(char* tblAlias);
	char*	GetTableAlias()		{return tableAlias;}

	BOOL	SetColumnName(char* columName);
	char*	GetColumnName()		{return columnName;}

	PassthroughLookupTable();
};

void TidyupPassthroughMap(CMapWordToPtr* passthroughMap);


class VirtualInstanceInfo
{
public:

	//each element in the CMapStringToPtr is keyed on
	//TableAlias.ColumnName
	long cElements; //number of elements in this array
	long cCycle;	//value change cycle for instances

	VirtualInstanceInfo();
	~VirtualInstanceInfo();
};


class VirtualInstanceManager
{
private:

	CMapStringToPtr* virtualInfo;

	char* ConstructKey(LPCTSTR TableAlias, LPCTSTR ColumnName);

	IWbemClassObject* GetWbemObject(CBString& myTableAlias, IWbemClassObject* myInstance);

public:

	long currentInstance; //zero-based index
	long cNumberOfInstances;

	void AddColumnInstance(LPCTSTR TableAlias, LPCTSTR ColumnName, VirtualInstanceInfo* col);

	long GetArrayIndex(LPCTSTR TableAlias, LPCTSTR ColumnName, long instanceNum);

//	void Testy();

	void Load(CMapWordToPtr* passthroughMap, IWbemClassObject* myInstance);

	BOOL GetVariantValue(CBString& myTableAlias, CBString& myColumnName, IWbemClassObject* myInstance, VARIANT FAR* myVal);


	VirtualInstanceManager();
	~VirtualInstanceManager();

};


class TableColumnList
{
public:
	SQLNODEIDX	idxColumnName;		//column info
	SQLNODEIDX	idxTableAlias;		//table alias for column
	LPISAMTABLEDEF lpISAMTableDef;	//table info
	TableColumnList* Next;			//Next item in list

	TableColumnList(SQLNODEIDX idx, SQLNODEIDX idxAlias, LPISAMTABLEDEF lpTableDef)
								{idxColumnName = idx; idxTableAlias = idxAlias; lpISAMTableDef = lpTableDef; Next = NULL;}
	~TableColumnList()			{delete Next;}
};

#define WQL_SINGLE_TABLE	1
#define WQL_MULTI_TABLE		2

class TableColumnInfo
{
private:
	LPSQLTREE FAR *lplpSql;
	LPSQLTREE FAR * lplpSqlNode;
	BOOL fIsValid;
	ULONG theMode;
	STRINGIDX idxTableQualifer;
	BOOL fDistinct;
	BOOL fHasScalarFunction;
	BOOL fIsSelectStar;
	BOOL m_aggregateExists;

	void Analize(LPSQLNODE lpNode);

	void StringConcat(char** resultString, char* myStr);

//	void AddJoin(_bstr_t & tableList, SQLNODEIDX joinidx);

	void AddJoinPredicate(char** tableList, SQLNODEIDX predicateidx);

public:

	TableColumnList* lpList;

	void BuildTableList(char** tableList, BOOL &fIsSQL89, SQLNODEIDX idx = NO_SQLNODE);

	//Check if there is zero or one column/table entires in list
	//This is used to check for COUNT(*)
	BOOL IsZeroOrOneList();

	//Have any aggregate functions been detected
	BOOL HasAggregateFunctions()		{return m_aggregateExists;}

	//Is       SELECT DISTINCT select-list FROM .....
	BOOL IsDistinct()			{return fDistinct;}

	//Is       SELECT * FROM ...
	BOOL IsSelectStar()			{return fIsSelectStar;}

	//Was table column info parsed successfully
	BOOL IsValid()			{return fIsValid;}

	//Indicate if query contains scalar function
	BOOL HasScalarFunction()	{return fHasScalarFunction;}

	//Builds a select list for the chosen table
	void BuildSelectList(LPISAMTABLEDEF lpTableDef, char** lpSelectListStr, BOOL fIsSQL89 = TRUE, CMapWordToPtr** ppPassthroughMap = NULL);

	//Builds whole WQL statement
	void BuildFullWQL(char** lpWQLStr, CMapWordToPtr** ppPassthroughMap = NULL);

	STRINGIDX GetTableQualifier()	{return idxTableQualifer;}

	//Indicates if at least one column in the specified table 
	//is refernced in the SQL statement
	BOOL IsTableReferenced(LPISAMTABLEDEF lpTableDef);

	TableColumnInfo(LPSQLTREE FAR *lplpTheSql, LPSQLTREE FAR * lpSqlN, ULONG mode = WQL_SINGLE_TABLE);
	~TableColumnInfo()							{delete lpList;}

};


#define DATETIME_FORMAT_LEN		21
#define DATETIME_DATE_LEN		8
#define DATETIME_TIME_LEN		6
#define DATETIME_YEAR_LEN		4
#define DATETIME_MONTH_LEN		2
#define DATETIME_DAY_LEN		2
#define DATETIME_HOUR_LEN		2
#define DATETIME_MIN_LEN		2
#define DATETIME_SEC_LEN		2
#define DATETIME_MICROSEC_LEN	6

class DateTimeParser
{
private:
	BOOL fIsValid;
	BOOL fValidDate;
	BOOL fValidTime;

	BOOL fIsaTimestamp;
	BOOL fIsaDate;
	BOOL fIsaTime;

	ULONG m_year;
	ULONG m_month;
	ULONG m_day;

	ULONG m_hour;
	ULONG m_min;
	ULONG m_sec;

	ULONG m_microSec;

	char dateTimeBuff[DATETIME_FORMAT_LEN + 1];
	char tempBuff[DATETIME_MICROSEC_LEN + 1];

	BOOL IsNumber(char bChar);
	void FetchField(char* lpStr, WORD wFieldLen, ULONG &wValue);
	void ValidateFields();
	
public:

	BOOL IsValid()						{return fIsValid;}

	BOOL IsTimestamp()					{return fIsaTimestamp;}
	BOOL IsDate()						{return fIsaDate;}
	BOOL IsTime()						{return fIsaTime;}

	ULONG GetYear()						{return m_year;}
	ULONG GetMonth()					{return m_month;}
	ULONG GetDay()						{return m_day;}
	ULONG GetHour()						{return m_hour;}
	ULONG GetMin()						{return m_min;}
	ULONG GetSec()						{return m_sec;}
	ULONG GetMicroSec()					{return m_microSec;}

	DateTimeParser(BSTR dateTimeStr);
	~DateTimeParser()					{;}
};

/***************************************************************************/
#define ToNode(lpSql, idx)      (&((lpSql)[idx]))
#define ToString(lpSql, idx)    (&((lpSql)->node.root.lpStringArea[idx]))
/***************************************************************************/
RETCODE INTFUNC Parse(LPSTMT, LPISAM, LPUSTR, SDWORD, LPSQLTREE FAR *);
SQLNODEIDX INTFUNC AllocateNode(LPSQLTREE FAR *, UWORD);
STRINGIDX INTFUNC AllocateSpace(LPSQLTREE FAR *, SWORD);
STRINGIDX INTFUNC AllocateString(LPSQLTREE FAR *, LPUSTR);
void INTFUNC FreeTree(LPSQLTREE);
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\options.cpp ===
/***************************************************************************/
/* OPTIONS.C                                                               */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"

#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"

/***************************************************************************/

RETCODE SQL_API SQLSetConnectOption(
    HDBC    hdbc,
    UWORD   fOption,
    UDWORD  vParam)
{
    LPDBC lpdbc;
    LPSTMT lpstmt;
    SWORD  err;

    /* Get connection handle */
    lpdbc = (LPDBC) hdbc;
    lpdbc->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpdbc, "SQLSetConnectOption");

    /* Set the option value */
    switch (fOption) {
    case SQL_ACCESS_MODE:
        break;
    case SQL_AUTOCOMMIT:

	if (lpdbc->lpISAM->fTxnCapable == SQL_TC_NONE) {
        	if (vParam != SQL_AUTOCOMMIT_ON)
            	lpdbc->errcode = ERR_NOTCAPABLE;
	}
        else {
            switch (vParam) {
            case SQL_AUTOCOMMIT_ON:
                if (!(lpdbc->fAutoCommitTxn)) {
                    err = SQLTransact(SQL_NULL_HENV, (HDBC)lpdbc, SQL_COMMIT);
                    if ((err != SQL_SUCCESS)&&(err != SQL_SUCCESS_WITH_INFO))
                        return err;
                    lpdbc->fAutoCommitTxn = TRUE;
                }
                break;
            case SQL_AUTOCOMMIT_OFF:
                lpdbc->fAutoCommitTxn = FALSE;
                break;
            default:
                lpdbc->errcode = ERR_NOTCAPABLE;
                break;
            }
        }
        break;
    case SQL_CURRENT_QUALIFIER:
		// check that the namespace exists on the connection
		CNamespace* pa;
		if (lpdbc->lpISAM->pNamespaceMap->Lookup ((LPSTR)vParam, 
												  (CObject*&)pa))
		{
			if (!ISAMSetDatabase (lpdbc->lpISAM, (LPUSTR) vParam))
				lpdbc->errcode = ERR_INVALIDQUALIFIER;
		}
		else
		{
			lpdbc->errcode = ERR_INVALIDQUALIFIER;
		}
        break;
    case SQL_LOGIN_TIMEOUT:
        if (vParam != 0)
            lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_ODBC_CURSORS:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_OPT_TRACE:
        if (vParam != SQL_OPT_TRACE_OFF)
            lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_OPT_TRACEFILE:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_PACKET_SIZE:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_QUIET_MODE:
        if ((HWND) vParam != NULL)
            lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_TRANSLATE_DLL:
        if ((LPSTR) vParam != NULL)
            lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_TRANSLATE_OPTION:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_TXN_ISOLATION:
        if (lpdbc->lpISAM->fTxnCapable == SQL_TC_NONE)
            lpdbc->errcode = ERR_NOTCAPABLE;
        else if (lpdbc->fTxnIsolation != (SDWORD) vParam) {

            /* If transaction in progress, fail */
            for (lpstmt = lpdbc->lpstmts;
                 lpstmt != NULL;
                 lpstmt = lpstmt->lpNext) {
                if (lpstmt->fISAMTxnStarted) {
                    lpdbc->errcode = ERR_TXNINPROGRESS;
                    return SQL_ERROR;
                }
            }

            /* Set the isolation mode */
            lpdbc->errcode = ISAMSetTxnIsolation(lpdbc->lpISAM, vParam); 
            if (lpdbc->errcode != NO_ISAM_ERR)
                return SQL_ERROR;

            /* Save our own copy of the new state */
            lpdbc->fTxnIsolation = vParam;
            lpdbc->errcode = ERR_SUCCESS;
        }
        break;

    /* (the following are statement options) */
    case SQL_ASYNC_ENABLE:
        if (vParam != SQL_ASYNC_ENABLE_OFF)
            lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_BIND_TYPE:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_CONCURRENCY:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_CURSOR_TYPE:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_KEYSET_SIZE:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_MAX_LENGTH:
        if (vParam != 0)
            lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_MAX_ROWS:
        if (vParam != 0)
            lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_NOSCAN:
        if (vParam != SQL_NOSCAN_OFF)
            lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_QUERY_TIMEOUT:
        if (vParam != 0)
            lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_RETRIEVE_DATA:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_ROWSET_SIZE:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_SIMULATE_CURSOR:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_USE_BOOKMARKS:
        if (vParam != SQL_UB_OFF)
            lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    default:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    }

    if (lpdbc->errcode != ERR_SUCCESS)
        return SQL_ERROR;
    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLSetStmtOption(
    HSTMT   hstmt,
    UWORD   fOption,
    UDWORD  vParam)
{
    LPSTMT lpstmt;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpstmt, "SQLSetStmtOption");

    /* Error if bad option */

    /* Set the option value */
    switch (fOption) {
    case SQL_ASYNC_ENABLE:
		{
			switch (vParam)
			{
			case SQL_ASYNC_ENABLE_OFF:
			case SQL_ASYNC_ENABLE_ON:
				lpstmt->fSyncMode = vParam;
				break;
			default:
				lpstmt->errcode = ERR_NOTCAPABLE;
				break;
			}
		}
        break;   
    case SQL_BIND_TYPE:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_CONCURRENCY:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_CURSOR_TYPE:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_KEYSET_SIZE:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_MAX_LENGTH:
        if (vParam != SQL_ASYNC_ENABLE_OFF)
            lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_MAX_ROWS:
        if (vParam != 0)
            lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_NOSCAN:
        if (vParam != SQL_NOSCAN_OFF)
            lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_QUERY_TIMEOUT:
        if (vParam != 0)
            lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_RETRIEVE_DATA:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_ROWSET_SIZE:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_SIMULATE_CURSOR:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_USE_BOOKMARKS:
        if (vParam != SQL_UB_OFF)
            lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    default:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    }
    
    if (lpstmt->errcode != ERR_SUCCESS)
        return SQL_ERROR;
    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLGetConnectOption(
    HDBC    hdbc,
    UWORD   fOption,
    PTR     pvParam)
{
    LPDBC lpdbc;

    /* Get connection handle */
    lpdbc = (LPDBC) hdbc;
    lpdbc->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpdbc, "SQLGetConnectOption");

    /* Return the option value */
    switch (fOption) {
    case SQL_ACCESS_MODE:
        *((SDWORD FAR *) pvParam) = SQL_MODE_READ_WRITE;
        break;
    case SQL_AUTOCOMMIT:
        if (lpdbc->fAutoCommitTxn)
            *((SDWORD FAR *) pvParam) = SQL_AUTOCOMMIT_ON;
        else
            *((SDWORD FAR *) pvParam) = SQL_AUTOCOMMIT_OFF;
        break;
    case SQL_CURRENT_QUALIFIER:
        s_lstrcpy((LPSTR) pvParam, ISAMDatabase(lpdbc->lpISAM));
        break;
    case SQL_LOGIN_TIMEOUT:
        *((SDWORD FAR *) pvParam) = 0;
        break;
    case SQL_ODBC_CURSORS:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_OPT_TRACE:
        *((SDWORD FAR *) pvParam) = SQL_OPT_TRACE_OFF;
        break;
    case SQL_OPT_TRACEFILE:
        lstrcpy((LPSTR) pvParam, "");
        break;
    case SQL_PACKET_SIZE:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_QUIET_MODE:
        *((SDWORD FAR *) pvParam) = (SDWORD) NULL;
        break;
    case SQL_TRANSLATE_DLL:
        lstrcpy((LPSTR) pvParam, "");
        break;
    case SQL_TRANSLATE_OPTION:
        *((SDWORD FAR *) pvParam) = 0;
        break;
    case SQL_TXN_ISOLATION:
        if (lpdbc->lpISAM->fTxnCapable != SQL_TC_NONE)
            *((SDWORD FAR *) pvParam) = lpdbc->fTxnIsolation;
        else
            lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    default:
        lpdbc->errcode = ERR_NOTCAPABLE;
        break;
    }
    
    if (lpdbc->errcode != ERR_SUCCESS)
        return SQL_ERROR;
    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLGetStmtOption(
    HSTMT   hstmt,
    UWORD   fOption,
    PTR     pvParam)
{
    LPSTMT lpstmt;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;


	MyImpersonator im (lpstmt, "SQLGetStmtOption");

    /* Get the option value */
    switch (fOption) {
    case SQL_ASYNC_ENABLE:
        *((SDWORD FAR *) pvParam) = lpstmt->fSyncMode;
        break;
    case SQL_BIND_TYPE:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_CONCURRENCY:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_CURSOR_TYPE:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_KEYSET_SIZE:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_MAX_LENGTH:
        *((SDWORD FAR *) pvParam) = 0;
        break;
    case SQL_MAX_ROWS:
        *((SDWORD FAR *) pvParam) = 0;
        break;
    case SQL_NOSCAN:
        *((SDWORD FAR *) pvParam) = SQL_NOSCAN_OFF;
        break;
    case SQL_QUERY_TIMEOUT:
        *((SDWORD FAR *) pvParam) = 0;
        break;
    case SQL_RETRIEVE_DATA:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_ROWSET_SIZE:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_SIMULATE_CURSOR:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_USE_BOOKMARKS:
		lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_GET_BOOKMARK:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    case SQL_ROW_NUMBER:
        *((SDWORD FAR *) pvParam) = 0;
        break;
    default:
        lpstmt->errcode = ERR_NOTCAPABLE;
        break;
    }
    
    if (lpstmt->errcode != ERR_SUCCESS)
        return SQL_ERROR;
    return SQL_SUCCESS;
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\parse.cpp ===
//NEW ONE
/***************************************************************************/
/* PARSE.C                                                                 */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"
#include <comdef.h>  //for _bstr_t

/***************************************************************************/
/* Notes:                                                                  */
/*                                                                         */
/* PARSE.C contains the code that changes a SQL query (as a character      */
/* string) and converts it to a tree that represents the query.            */
/*                                                                         */
/* The parse tree is actually an array of nodes.  Initially it contains    */
/* SQLNODE_ALLOC nodes, but it is expanded if additional nodes are needed. */
/* The root node of the tree is always the ROOT_SQLNODE'th element of this */
/* array.                                                                  */
/*                                                                         */
/* String values (such as table names, literal string values, etc.) are    */
/* not stored directly in a node.  Instead, they are stored in a separate  */
/* string area and an index to the string is stored in the parse tree      */
/* node.  This is done to keep the parse tree nodes from getting too big.  */
/* Initially the string area is STRING_ALLOC bytslong, but it is expanded  */
/* is additional room is needed.                                           */
/*                                                                         */
/* As mentioned above, both the parse tree and string area may be expanded.*/
/* Because of this, it is not possible for a node to have hard pointers to */
/* child nodes or strings.  To accomodate this problem, SQLNODEIDX and     */
/* STRINGIDX values are stored instead.  The ToNode() and ToString() macros*/
/* convert these indexes to pointers.                                      */
/*                                                                         */
/* The parser is recursive descent parser built entirely in C.  To modify  */
/* the grammar, all you need to do is change the code in this module (tools*/
/* such as YACC and LEX are not used).  To best understand the code, start */
/* by looking at routine Parse() (at the end of this module).              */
/*                                                                         */
/* ShowSemantic() in TRACE.C can be used to dump a parse tree to the       */
/* debug monitor.                                                          */
/*                                                                         */
/***************************************************************************/
/* Forward references */

RETCODE INTFUNC ParseBoolean(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken);

RETCODE INTFUNC ParseExpression(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken);

RETCODE INTFUNC ParseSelect(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken);

/***************************************************************************/
/* Keywords */

LPUSTR lpszKeywords[] = {
        (LPUSTR) "ALL",
        (LPUSTR) "ALTER", //Dr. DeeBee does not support this
        (LPUSTR) "AND",
        (LPUSTR) "ANY",
        (LPUSTR) "AS",
        (LPUSTR) "ASC",
        (LPUSTR) "AVG",
        (LPUSTR) "BY",
        (LPUSTR) "COUNT",
        (LPUSTR) "CREATE",
        (LPUSTR) "DELETE",
        (LPUSTR) "DESC",
        (LPUSTR) "DISTINCT",
        (LPUSTR) "DROP",
        (LPUSTR) "EXISTS",
        (LPUSTR) "GRANT", //Dr. DeeBee does not support this
        (LPUSTR) "FROM",
        (LPUSTR) "GROUP",
        (LPUSTR) "HAVING",
        (LPUSTR) "IN",
        (LPUSTR) "INDEX",
        (LPUSTR) "INSERT",
        (LPUSTR) "INTO",
        (LPUSTR) "IS",
        (LPUSTR) "JOIN",
        (LPUSTR) "LEFT",
        (LPUSTR) "LIKE",
        (LPUSTR) "MAX",
        (LPUSTR) "MIN",
        (LPUSTR) "NOT",
        (LPUSTR) "NULL",
        (LPUSTR) "ON",
        (LPUSTR) "OR",
        (LPUSTR) "ORDER",
        (LPUSTR) "REVOKE", //Dr. DeeBee does not support this
        (LPUSTR) "OUTER",
        (LPUSTR) "SELECT",
        (LPUSTR) "SET",
        (LPUSTR) "SQL",
        (LPUSTR) "SUM",
        (LPUSTR) "TABLE",
        (LPUSTR) "UNIQUE",
        (LPUSTR) "UPDATE",
        (LPUSTR) "USER",
        (LPUSTR) "VALUES",
        (LPUSTR) "WHERE",
        NULL };

/***************************************************************************/
/* Token types */

#define TOKEN_TYPE_NONE       0
#define TOKEN_TYPE_SYMBOL     1
#define TOKEN_TYPE_NUMBER     2
#define TOKEN_TYPE_STRING     3
#define TOKEN_TYPE_IDENTIFIER 4
#define TOKEN_TYPE_KEYWORD    5
#define TOKEN_TYPE_ESCAPE     6

/***************************************************************************/

PassthroughLookupTable::PassthroughLookupTable()
{
	tableAlias[0] = 0;
	columnName[0] = 0;
}

BOOL PassthroughLookupTable::SetTableAlias(char* tblAlias)
{
	tableAlias[0] = 0;
	
	if (tblAlias)
	{
		if (strlen(tblAlias) <= MAX_QUALIFIER_NAME_LENGTH)
		{
			strcpy(tableAlias, tblAlias);
		}
		else
		{
			//Truncation
			return FALSE;
		}
	}
	return TRUE;
}

BOOL PassthroughLookupTable::SetColumnName(char* columName)
{
	columnName[0] = 0;
	
	if (columName)
	{
		if (strlen(columName) <= MAX_COLUMN_NAME_LENGTH)
		{
			strcpy(columnName, columName);
		}
		else
		{
			//Truncation
			return FALSE;
		}
	}
	return TRUE;
}

VirtualInstanceInfo::VirtualInstanceInfo()
{
	cElements = 0;
	cCycle = 1;
}

VirtualInstanceInfo::~VirtualInstanceInfo()
{
}

VirtualInstanceManager::VirtualInstanceManager()
{
	virtualInfo = new CMapStringToPtr();
	currentInstance = 0; 
	cNumberOfInstances = 0;
}

VirtualInstanceManager::~VirtualInstanceManager()
{
	//Tidy up VirtualInfo
	if (!virtualInfo->IsEmpty())
	{
		for(POSITION pos = virtualInfo->GetStartPosition(); pos != NULL; )
		{
			CString key; //not used
			VirtualInstanceInfo* pa = NULL;
			virtualInfo->GetNextAssoc( pos, key, (void*&)pa );

			if (pa)
				delete pa;
		}	
	}
	delete (virtualInfo);
		virtualInfo = NULL;
}

void VirtualInstanceManager::AddColumnInstance(LPCTSTR TableAlias, LPCTSTR ColumnName, VirtualInstanceInfo* col)
{
	//First check if new element contains any elements
	long newElements = col->cElements;

	if (! newElements)
		return;


	//Multiply call previous cycles counts by this number
	if (!virtualInfo->IsEmpty())
	{
		for(POSITION pos = virtualInfo->GetStartPosition(); pos != NULL; )
		{
			CString key; //not used
			VirtualInstanceInfo* pa = NULL;
			virtualInfo->GetNextAssoc( pos, key, (void*&)pa );

			if (pa)
			{
				pa->cCycle = pa->cCycle * newElements;
			}

		}	
	}

	//First contruct the key	
	char* tempbuff = ConstructKey(TableAlias, ColumnName);
	_bstr_t mapKey(tempbuff);
	delete tempbuff;
	

	//Add element
	virtualInfo->SetAt( (LPCTSTR)mapKey, col);

	//Update the instance count
	if (cNumberOfInstances)
	{
		cNumberOfInstances = cNumberOfInstances * newElements;
	}
	else
	{
		cNumberOfInstances = newElements;
	}
}


void VirtualInstanceManager::Load(CMapWordToPtr* passthroughMap, IWbemClassObject* myInstance)
{
	//Cycle through each column in the passthrough table
	//and fetch its value from the IWbemClassObject instance
	if (passthroughMap && !(passthroughMap->IsEmpty()))
	{
		for(POSITION pos = passthroughMap->GetStartPosition(); pos != NULL; )
		{
			WORD key = 0; //not used
			PassthroughLookupTable* pltable = NULL;
			passthroughMap->GetNextAssoc( pos, key, (void*&)pltable );

			//Get TableAlias and ColumnName
			CBString myTableAlias;
			CBString myColumnName;
			myTableAlias.AddString(pltable->GetTableAlias(), FALSE);
			myColumnName.AddString(pltable->GetColumnName(), FALSE);

			//Get the variant value
			VARIANT myVal;
//SAI ADDED no need to init			VariantInit(&myVal);
			BOOL gotVarValue = GetVariantValue(myTableAlias, myColumnName, myInstance, &myVal);
			
			{
			//We don't care if this is an array of strings or not
			//as we are not asking for any values, we just want to 
			//know the array size
			BSTR_SafeArray myArray(&myVal);

			//If this is an array type with at least one element
			if ( myArray.IsValid() )
			{
				if ( myArray.Count() )
				{
					VirtualInstanceInfo* myInfo = new VirtualInstanceInfo();
					myInfo->cElements = myArray.Count();

					//Add to manager
					AddColumnInstance(_bstr_t(myTableAlias.GetString()), _bstr_t(myColumnName.GetString()), myInfo);
				}
			}

			}

			if (gotVarValue)
				VariantClear(&myVal);
		}		
	}
}


BOOL VirtualInstanceManager::GetVariantValue(CBString& myTableAlias, CBString& myColumnName, IWbemClassObject* myInstance, VARIANT FAR* myVal)
{
//	VariantInit(myVal);

	//First we need to get the correctIWbemClassObject for the column value
	IWbemClassObject* correctWbemObject = myInstance;


	//We begin by checking if this is an __Generic class
	//if so we need to fetch the embedded object 
	BOOL fIs__Generic = FALSE;

	VARIANT grVariant;
//SAI ADDED no need 	VariantInit(&grVariant);
	CBString classBSTR(WBEMDR32_L_CLASS, FALSE);
	if (FAILED(myInstance->Get(classBSTR.GetString(), 0, &grVariant, NULL, NULL)))
	{
		return FALSE;
	}

	//Compare with __Generic
	if (_wcsicmp(grVariant.bstrVal, L"__Generic") == 0)
	{
		fIs__Generic = TRUE;
		//(4)
		correctWbemObject = GetWbemObject(myTableAlias, myInstance);
	}

	VariantClear(&grVariant);

	//Get the ColumnValue
	if (FAILED(correctWbemObject->Get(myColumnName.GetString(), 0, myVal, NULL, 0) ))
	{
		//(4)
		if (fIs__Generic)
			correctWbemObject->Release();

		return FALSE;
	}

	if (fIs__Generic)
	{
		//(4)
		correctWbemObject->Release();
	}

	return TRUE;
}

IWbemClassObject* VirtualInstanceManager::GetWbemObject(CBString& myTableAlias, IWbemClassObject* myInstance)
{
	//Get the property type and value
	CIMTYPE vType;
	VARIANT pVal;
//SAI ADDED no need to init	VariantInit(&pVal);

	if ( SUCCEEDED(myInstance->Get(myTableAlias.GetString(), 0, &pVal, &vType, 0)) )
	{
		//We are looking for embedded objects
		if (vType == CIM_OBJECT)
		{

			IWbemClassObject* myEmbeddedObj = NULL;

			IUnknown* myUnk = pVal.punkVal;
			myUnk->QueryInterface(IID_IWbemClassObject, (void**)&myEmbeddedObj);

			VariantClear(&pVal);

			return myEmbeddedObj;
		}

		VariantClear(&pVal);
	}
	

	//error
	return NULL;
}

char* VirtualInstanceManager::ConstructKey(LPCTSTR TableAlias, LPCTSTR ColumnName)
{
	_bstr_t mapKey2("");


	//Make key in upper case
	CString myUpperCaseTbl(TableAlias);

	if (! myUpperCaseTbl.IsEmpty())
		myUpperCaseTbl.MakeUpper();
	_bstr_t myTblAlias(myUpperCaseTbl);

	CString myUpperCaseCol(ColumnName);
	if (! myUpperCaseCol.IsEmpty())
		myUpperCaseCol.MakeUpper();
	_bstr_t myColName(myUpperCaseCol);

	if ( myTblAlias.length() )
		mapKey2 += (LPCTSTR)myTblAlias;

	mapKey2+= ".";

	if ( myColName.length() )
		mapKey2 += (LPCTSTR)myColName;

	long len = mapKey2.length();
	char* buffer = new char[len + 1];
	buffer[0] = 0;
	wcstombs(buffer, mapKey2, len);
	buffer[len] = 0;
	return buffer;
//	return (LPCTSTR)mapKey;
}

long VirtualInstanceManager::GetArrayIndex(LPCTSTR TableAlias, LPCTSTR ColumnName, long instanceNum)
{
	long index = -1;

	//First construct key for lookup map
	char* tempbuff = ConstructKey(TableAlias, ColumnName);
	_bstr_t mapKey(tempbuff);
	delete tempbuff;

	VirtualInstanceInfo* myInfo = NULL;
	if ( virtualInfo->Lookup((LPCTSTR)mapKey, (void*&)myInfo) )
	{
		//Calculate index for given instance 
		//(Note: instance number is zero based)
		long cCycle = myInfo->cCycle;

		index = ( (instanceNum) / (myInfo->cCycle) );

		index = index % (myInfo->cElements);
	}

	return index;
}

/*
void VirtualInstanceManager::Testy()
{
	//Testing 
	VirtualInstanceInfo* myInfo = NULL;
		
	//TableA
	myInfo = new VirtualInstanceInfo();
	myInfo->cElements = 2;
	AddColumnInstance(_bstr_t("t1"), _bstr_t("TableA"), myInfo);

	//TableB
	myInfo = new VirtualInstanceInfo();
	myInfo->cElements = 3;
	AddColumnInstance(_bstr_t("t2"), _bstr_t("TableB"), myInfo);

	//TableC
	myInfo = new VirtualInstanceInfo();
	myInfo->cElements = 2;
	AddColumnInstance(_bstr_t("t3"), _bstr_t("TableC"), myInfo);


	//Now fetch the index's for instance 0
	long myindexA = 0;
	long myindexB = 0;
	long myindexC = 0;
	
	myindexA = GetArrayIndex(_bstr_t("t1"), _bstr_t("TableA"), 0);
	myindexB = GetArrayIndex(_bstr_t("t2"), _bstr_t("TableB"), 0);
	myindexC = GetArrayIndex(_bstr_t("t3"), _bstr_t("TableC"), 0);

	myindexA = GetArrayIndex(_bstr_t("t1"), _bstr_t("TableA"), 5);
	myindexB = GetArrayIndex(_bstr_t("t2"), _bstr_t("TableB"), 5);
	myindexC = GetArrayIndex(_bstr_t("t3"), _bstr_t("TableC"), 5);


	myindexA = GetArrayIndex(_bstr_t("t1"), _bstr_t("TableA"), 6);
	myindexB = GetArrayIndex(_bstr_t("t2"), _bstr_t("TableB"), 6);
	myindexC = GetArrayIndex(_bstr_t("t3"), _bstr_t("TableC"), 6);

	myindexA = GetArrayIndex(_bstr_t("t1"), _bstr_t("TableA"), 11);
	myindexB = GetArrayIndex(_bstr_t("t2"), _bstr_t("TableB"), 11);
	myindexC = GetArrayIndex(_bstr_t("t3"), _bstr_t("TableC"), 11);

}
*/
/***************************************************************************/

SQLNODEIDX INTFUNC AllocateNode(LPSQLTREE FAR *lplpSql, UWORD sqlNodeType)

/* Allocates a new node for the parse tree.                               */
/*                                                                        */
/* If there is an available node, the index of that node is returned.     */
/* Otherwise the array is expanded and the index of one of the newly      */
/* created nodes is returned.                                             */
/*                                                                        */
/* lplpSql points to the node array.  Its value may change.               */

{
    HGLOBAL hParseArray;
    HGLOBAL hOldParseArray;
    LPSQLTREE lpSql;

    /* Is there space available? */
    lpSql = *lplpSql;
    if ((lpSql->node.root.iParseArray + 1) >= lpSql->node.root.cParseArray) {

        /* No.  Allocate more space */
        hOldParseArray = lpSql->node.root.hParseArray;
        lpSql->node.root.hParseArray = NULL;
        GlobalUnlock(hOldParseArray);
        hParseArray = GlobalReAlloc(hOldParseArray,
                      sizeof(SQLNODE) * (SQLNODE_ALLOC + lpSql->node.root.cParseArray),
                      GMEM_MOVEABLE);
        if (hParseArray == NULL) {
            GlobalFree(hOldParseArray);
            return NO_SQLNODE;
        }
        lpSql = (LPSQLTREE) GlobalLock(hParseArray);
        if (lpSql == NULL) {
            GlobalFree(hParseArray);
            return NO_SQLNODE;
        }
        *lplpSql = lpSql;

        /* Update the root node */
        lpSql->node.root.hParseArray = hParseArray;
        lpSql->node.root.cParseArray += (SQLNODE_ALLOC);
    }

    /* Return the next node */
    (lpSql->node.root.iParseArray)++;

    /* Initialize the node */
    lpSql[lpSql->node.root.iParseArray].sqlNodeType = sqlNodeType;
    lpSql[lpSql->node.root.iParseArray].sqlDataType = TYPE_UNKNOWN;
    lpSql[lpSql->node.root.iParseArray].sqlSqlType = SQL_TYPE_NULL;
    lpSql[lpSql->node.root.iParseArray].sqlPrecision = 0;
    lpSql[lpSql->node.root.iParseArray].sqlScale = NO_SCALE;
    lpSql[lpSql->node.root.iParseArray].value.String = NULL;
    lpSql[lpSql->node.root.iParseArray].value.Double = 0.0;
    lpSql[lpSql->node.root.iParseArray].value.Date.year = 0;
    lpSql[lpSql->node.root.iParseArray].value.Date.month = 0;
    lpSql[lpSql->node.root.iParseArray].value.Date.day = 0;
    lpSql[lpSql->node.root.iParseArray].value.Time.hour = 0;
    lpSql[lpSql->node.root.iParseArray].value.Time.minute = 0;
    lpSql[lpSql->node.root.iParseArray].value.Time.second = 0;
    lpSql[lpSql->node.root.iParseArray].value.Timestamp.year = 0;
    lpSql[lpSql->node.root.iParseArray].value.Timestamp.month = 0;
    lpSql[lpSql->node.root.iParseArray].value.Timestamp.day = 0;
    lpSql[lpSql->node.root.iParseArray].value.Timestamp.hour = 0;
    lpSql[lpSql->node.root.iParseArray].value.Timestamp.minute = 0;
    lpSql[lpSql->node.root.iParseArray].value.Timestamp.second = 0;
    lpSql[lpSql->node.root.iParseArray].value.Timestamp.fraction = 0;
    lpSql[lpSql->node.root.iParseArray].value.Binary = NULL;
    lpSql[lpSql->node.root.iParseArray].sqlIsNull = TRUE;

    return lpSql->node.root.iParseArray;
}
/***************************************************************************/

STRINGIDX INTFUNC AllocateSpace(LPSQLTREE FAR *lplpSql, SWORD cbSize)

/* Allocates space from the string area of parse tree.                    */
/*                                                                        */
/* If there is room, the index of the string is returned.  Otherwise the  */
/* string area is expanded and the index of the newly created string      */
/* is returned.  If the string area cannot be expanded, NO_STRING is      */
/* returned.                                                              */
/*                                                                        */
/* lpSql points to the node array.  Its value may change.  cbSize is      */
/* the number of bytes needed.                                            */

{
    HGLOBAL hStringArea;
    LPUSTR lpstr;
    LPSQLTREE lpSql;

    /* First time? */
    lpSql = *lplpSql;
    if (lpSql->node.root.hStringArea == NULL) {

        /* Yes. Allocate initial space */
        hStringArea = GlobalAlloc(GMEM_MOVEABLE, STRING_ALLOC);
        if (hStringArea == NULL)
            return NO_STRING;
        lpstr = (LPUSTR) GlobalLock(hStringArea);
        if (lpstr == NULL) {
            GlobalFree(hStringArea);
            return NO_STRING;
        }

        /* Update the root node */
        lpSql->node.root.hStringArea = hStringArea;
        lpSql->node.root.lpStringArea = lpstr;
        lpSql->node.root.cbStringArea = STRING_ALLOC;
        lpSql->node.root.ibStringArea = -1;
    }

    /* Is there enough space available? */
    while ((lpSql->node.root.ibStringArea + cbSize) >= lpSql->node.root.cbStringArea) {

        /* No.  Allocate more space */
        GlobalUnlock(lpSql->node.root.hStringArea);
        hStringArea = GlobalReAlloc(lpSql->node.root.hStringArea,
                      STRING_ALLOC + lpSql->node.root.cbStringArea, GMEM_MOVEABLE);
        if (hStringArea == NULL) {
            GlobalFree(lpSql->node.root.hStringArea);
            lpSql->node.root.hStringArea = NULL;
            return NO_STRING;
        }
        lpstr = (LPUSTR) GlobalLock(hStringArea);
        if (lpstr == NULL) {
            GlobalFree(hStringArea);
            lpSql->node.root.hStringArea = NULL;
            return NO_STRING;
        }

        /* Update the root node */
        lpSql->node.root.hStringArea = hStringArea;
        lpSql->node.root.lpStringArea = lpstr;
        lpSql->node.root.cbStringArea += (STRING_ALLOC);
    }

    /* Return the next node */
    lpSql->node.root.ibStringArea += (cbSize);
    return (lpSql->node.root.ibStringArea - cbSize + 1);
}
/***************************************************************************/

STRINGIDX INTFUNC AllocateString(LPSQLTREE FAR *lplpSql, LPUSTR lpszStr)

/* Allocates a string from the string area of parse tree.                  */
/*                                                                         */
/* If there is room, the index of the string is returned.  Otherwise the   */
/* string area is expanded and the index of the newly created string       */
/* is returned.  If the string area cannot be expanded, NO_STRING is       */
/* returned.                                                               */
/*                                                                         */
/* lpSql points to the node array.  Its value may change.                  */

{
    STRINGIDX idx;

    idx = AllocateSpace(lplpSql, (SWORD) (s_lstrlen(lpszStr) + 1));
    if (idx == NO_STRING)
        return NO_STRING;
    s_lstrcpy(ToString(*lplpSql, idx), lpszStr);
    return idx;
}
/***************************************************************************/

void INTFUNC FreeTree(LPSQLTREE lpSql)
/* Deallocates a parse tree */
{
    HGLOBAL hParseArray;

    /* If nothing to do, just return */
    if (lpSql == NULL)
        return;

    /* Free semantic information */
    FreeTreeSemantic(lpSql, ROOT_SQLNODE);

    /* Deallocate the string area */
    if (lpSql->node.root.hStringArea != NULL) {
        GlobalUnlock(lpSql->node.root.hStringArea);
        GlobalFree(lpSql->node.root.hStringArea);
    }

    /* Deallocate the parse array */
    hParseArray = lpSql->node.root.hParseArray;
    if (hParseArray != NULL) {
        GlobalUnlock(hParseArray);
        GlobalFree(hParseArray);
    }
}

/***************************************************************************/
/***************************************************************************/

UWORD INTFUNC KeywordOrIdentifier(LPUSTR lpToken)

/* Determines if token is a keyword or an identifier */

{
    LPUSTR FAR *lpKeyword;

    lpKeyword = lpszKeywords;
    while (*lpKeyword != NULL) {
        if (!s_lstrcmpi(lpToken, *lpKeyword))
            return TOKEN_TYPE_KEYWORD;
        lpKeyword++;
    }
    return TOKEN_TYPE_IDENTIFIER;
}

/***************************************************************************/

RETCODE INTFUNC GetToken(LPSTMT lpstmt, LPUSTR lpFrom, SDWORD cbFrom,
                      LPUSTR lpToken, UWORD FAR *pfType,
                      LPUSTR FAR *lpRemainder, SDWORD FAR *pcbRemainder)

/* Retrives a token from input string, and returns the token and a pointer */
/* to the remainder of the input string.  lpToken is assumed to be at      */
/* least (MAX_TOKEN_SIZE + 1) bytes long.                                  */

{
    int len;
    BOOL foundDecimalPoint;
    BOOL foundExponent;
    LPUSTR lpTo;

    /* Remove leading blanks */
    while ((cbFrom != 0) &&
           ((*lpFrom == ' ') ||
            (*lpFrom == '\012') ||
            (*lpFrom == '\015') ||
            (*lpFrom == '\011'))) {
        lpFrom++;
        cbFrom--;
    }

    /* Leave if no more */
    lpTo = lpToken;
    if (cbFrom == 0) {
        *lpTo = '\0';
        *lpRemainder = lpFrom;
        *pcbRemainder = cbFrom;
        *pfType = TOKEN_TYPE_NONE;
        return ERR_SUCCESS;
    }

    /* What kind of token? */
    switch (*lpFrom) {

    /* End of input */
    case '\0':
        *lpTo = '\0';
        *lpRemainder = lpFrom;
        *pcbRemainder = cbFrom;
        *pfType = TOKEN_TYPE_NONE;
        return ERR_SUCCESS;

    /* Single character tokens */
    case '(':
    case ')':
    case '=':
    case '?':
    case '*':
    case ',':
    case '+':
    case '/':
    case '{':
    case '}':

        *lpTo = *lpFrom;
        lpTo++;
        lpFrom++;
        cbFrom--;
        *lpTo = '\0';
        *lpRemainder = lpFrom;
        *pcbRemainder = cbFrom;
        *pfType = TOKEN_TYPE_SYMBOL;
        return ERR_SUCCESS;

    /* - or -- */
    case '-':
        *lpTo = *lpFrom;
        lpTo++;
        lpFrom++;
        cbFrom--;
        if ((cbFrom != 0) && (*lpFrom == '-')) {
            *lpTo = *lpFrom;
            lpTo++;
            lpFrom++;
            cbFrom--;
        }
        *lpTo = '\0';
        *lpRemainder = lpFrom;
        *pcbRemainder = cbFrom;
        *pfType = TOKEN_TYPE_SYMBOL;
        return ERR_SUCCESS;

    /* < or <= or <> */
    case '<':
        *lpTo = *lpFrom;
        lpTo++;
        lpFrom++;
        cbFrom--;
        if ((cbFrom != 0) && ((*lpFrom == '=')  || (*lpFrom == '>'))) {
            *lpTo = *lpFrom;
            lpTo++;
            lpFrom++;
            cbFrom--;
        }
        *lpTo = '\0';
        *lpRemainder = lpFrom;
        *pcbRemainder = cbFrom;
        *pfType = TOKEN_TYPE_SYMBOL;
        return ERR_SUCCESS;

    /* > or >= */
    case '>':
        *lpTo = *lpFrom;
        lpTo++;
        lpFrom++;
        cbFrom--;
        if ((cbFrom != 0) && (*lpFrom == '=')) {
            *lpTo = *lpFrom;
            lpTo++;
            lpFrom++;
            cbFrom--;
        }
        *lpTo = '\0';
        *lpRemainder = lpFrom;
        *pcbRemainder = cbFrom;
        *pfType = TOKEN_TYPE_SYMBOL;
        return ERR_SUCCESS;

    /* Numbers */
    case '.':
        if (cbFrom == 1) {
            *lpTo = *lpFrom;
            lpTo++;
            lpFrom++;
            cbFrom--;
            *lpTo = '\0';
            *lpRemainder = lpFrom;
            *pcbRemainder = cbFrom;
            *pfType = TOKEN_TYPE_SYMBOL;
            return ERR_SUCCESS;
        }
        switch (*(lpFrom+1)) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            break;
        default:
            *lpTo = *lpFrom;
            lpTo++;
            lpFrom++;
            cbFrom--;
            *lpTo = '\0';
            *lpRemainder = lpFrom;
            *pcbRemainder = cbFrom;
            *pfType = TOKEN_TYPE_SYMBOL;
            return ERR_SUCCESS;
        }
        /* **** DROP DOWN TO NEXT CASE **** */

    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        /* **** CONTROL MAY COME HERE FROM PREVIOUS CASE **** */

        len = 0;
        foundDecimalPoint = FALSE;
        foundExponent = FALSE;
        while (TRUE) {
            if (cbFrom == 0) {
                *lpTo = '\0';
                *lpRemainder = lpFrom;
                *pcbRemainder = cbFrom;
                *pfType = TOKEN_TYPE_NUMBER;
                return ERR_SUCCESS;
            }
            switch (*lpFrom) {
            case '.':
                if (foundDecimalPoint || foundExponent) {
                    *lpTo = '\0';
                    s_lstrcpy(lpstmt->szError, lpToken);
                    return ERR_MALFORMEDNUMBER;
                }
                foundDecimalPoint = TRUE;
                /* **** DROP DOWN TO NEXT CASE **** */

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                /* **** CONTROL MAY COME HERE FROM PREVIOUS CASE **** */
                break;
            case 'e':
            case 'E':
                if (foundExponent) {
                    *lpTo = '\0';
                    s_lstrcpy(lpstmt->szError, lpToken);
                    return ERR_MALFORMEDNUMBER;
                }
                foundExponent = TRUE;
                if ((cbFrom > 1) && ((*(lpFrom+1) == '+') ||
                                     (*(lpFrom+1) == '-'))) {
                    if (len >= MAX_TOKEN_SIZE) {
                        *lpTo = '\0';
                        s_lstrcpy(lpstmt->szError, lpToken);
                        return ERR_ELEMENTTOOBIG;
                    }
                    len++;
                    *lpTo = *lpFrom;
                    lpTo++;
                    lpFrom++;
                    cbFrom--;
                }
                if (cbFrom < 2) {
                    *lpTo = '\0';
                    s_lstrcpy(lpstmt->szError, lpToken);
                    return ERR_MALFORMEDNUMBER;
                }
                break;
            default:
                *lpTo = '\0';
                *lpRemainder = lpFrom;
                *pcbRemainder = cbFrom;
                *pfType = TOKEN_TYPE_NUMBER;
                return ERR_SUCCESS;
            }
            if (len >= MAX_TOKEN_SIZE) {
                *lpTo = '\0';
                s_lstrcpy(lpstmt->szError, lpToken);
                return ERR_ELEMENTTOOBIG;
            }
            len++;

            *lpTo = *lpFrom;
            lpTo++;
            lpFrom++;
            cbFrom--;
        }
        break; /* Control should never get here */

    /* Character literals */
    case '\'':
        lpFrom++;
        cbFrom--;
        len = 0;
        while (TRUE) {

            if (cbFrom == 0)
                return ERR_UNEXPECTEDEND;

            switch (*lpFrom) {
            case '\0':
                return ERR_UNEXPECTEDEND;

            case '\'':
                lpFrom++;
                cbFrom--;
                if ((cbFrom == 0) || (*lpFrom != '\'')) {
                    *lpTo = '\0';
                    *lpRemainder = lpFrom;
                    *pcbRemainder = cbFrom;
                    *pfType = TOKEN_TYPE_STRING;
                    return ERR_SUCCESS;
                }
                /* **** DROP DOWN TO NEXT CASE **** */

            default:
                /* **** CONTROL MAY COME HERE FROM PREVIOUS CASE **** */
                break;
            }
            if (len >= MAX_TOKEN_SIZE) {
                *lpTo = '\0';
                s_lstrcpy(lpstmt->szError, lpToken);
                return ERR_ELEMENTTOOBIG;
            }
            len++;

            *lpTo = *lpFrom;
            lpTo++;
            lpFrom++;
            cbFrom--;
        }
        break; /* Control should never get here */

    /* Quoted identifiers */
    case '"':
        len = 0;
        lpFrom++;
        cbFrom--;
        while (TRUE) {

            if (cbFrom == 0)
                return ERR_UNEXPECTEDEND;

            switch (*lpFrom) {
            case '\0':
                return ERR_UNEXPECTEDEND;

            case '"':
                lpFrom++;
                cbFrom--;
                *lpTo = '\0';
                *lpRemainder = lpFrom;
                *pcbRemainder = cbFrom;
                *pfType = TOKEN_TYPE_IDENTIFIER;
                return ERR_SUCCESS;

            default:
                break;
            }
            if (len >= MAX_TOKEN_SIZE) {
                *lpTo = '\0';
                s_lstrcpy(lpstmt->szError, lpToken);
                return ERR_ELEMENTTOOBIG;
            }
            len++;

            *lpTo = *lpFrom;
            lpTo++;
            lpFrom++;
            cbFrom--;
        }
        break; /* Control should never get here */

    /* Other identifiers (and keywords) */
    default:
        len = 0;
        while (TRUE) {
            if (cbFrom == 0) {
                *lpTo = '\0';
                *lpRemainder = lpFrom;
                *pcbRemainder = cbFrom;
                *pfType = KeywordOrIdentifier(lpToken);
                return ERR_SUCCESS;
            }

            switch (*lpFrom) {
            case ' ':
            case '\012':
            case '\015':
            case '\011':
            case '\0':
            case '(':
            case ')':
            case '=':
            case '?':
            case '*':
            case ',':
            case '.':
            case '<':
            case '>':
            case '-':
            case '+':
            case '/':
            case '{':
            case '}':
                *lpTo = '\0';
                *lpRemainder = lpFrom;
                *pcbRemainder = cbFrom;
                *pfType = KeywordOrIdentifier(lpToken);
                return ERR_SUCCESS;

            default:
                break;
            }
            if (len >= MAX_TOKEN_SIZE) {
                *lpTo = '\0';
                s_lstrcpy(lpstmt->szError, lpToken);
                return ERR_ELEMENTTOOBIG;
            }
            len++;

            *lpTo = *lpFrom;
            lpTo++;
            lpFrom++;
            cbFrom--;
        }
        break; /* Control should never get here */
    }
    /* Control never gets here */
}

/***************************************************************************/

RETCODE INTFUNC GetEscape(LPSTMT lpstmt, LPUSTR lpFrom, SDWORD cbFrom,
                      LPUSTR lpToken, LPUSTR FAR *lpRemainder,
                      SDWORD FAR *pcbRemainder)

/* Retrives an escape sequence from input string, and returns it as */
/* a token and returns a pointer to the remainder of the input string. */  
/* lpToken is assumed to be at least (MAX_TOKEN_SIZE + 1) bytes long. */

{
    int len;
    LPUSTR lpTo;

    /* Remove leading blanks */
    while ((cbFrom != 0) &&
           ((*lpFrom == ' ') ||
            (*lpFrom == '\012') ||
            (*lpFrom == '\015') ||
            (*lpFrom == '\011'))) {
        lpFrom++;
        cbFrom--;
    }

    /* Error if no more */
    lpTo = lpToken;
    if (cbFrom == 0) {
        *lpTo = '\0';
        *lpRemainder = lpFrom;
        *pcbRemainder = cbFrom;
        return ERR_UNEXPECTEDEND;
    }

    /* What kind of escape? */
    switch (*lpFrom) {

    /* Shorthand sequences */
    case '{':

        /* Get sequence */
        len = 0;
        while (TRUE) {
            if (cbFrom == 0)
                return ERR_UNEXPECTEDEND;

            /* End of seqeuence? */
            if (*lpFrom == '}') {

                /* Yes.  Return it */
                *lpTo = *lpFrom;
                lpTo++;
                lpFrom++;
                cbFrom--;

                *lpTo = '\0';
                *lpRemainder = lpFrom;
                *pcbRemainder = cbFrom;
                return ERR_SUCCESS;
            }

            if (len >= MAX_TOKEN_SIZE) {
                *lpTo = '\0';
                s_lstrcpy(lpstmt->szError, lpToken);
                return ERR_ELEMENTTOOBIG;
            }
            len++;

            *lpTo = *lpFrom;
            lpTo++;
            lpFrom++;
            cbFrom--;
        }
        break;

    /* Escape sequences */
    case '-':
        if ((cbFrom > 1) && (*(lpFrom+1) == '-')) {

            /* Get starting hyphen */
            *lpTo = *lpFrom;
            lpTo++;
            lpFrom++;
            cbFrom--;

            /* Get rest of sequence */
            len = 0;
            while (TRUE) {
                if (cbFrom == 0)
                    return ERR_UNEXPECTEDEND;

                /* End of seqeuence? */
                if ((*lpFrom == '-') && (cbFrom > 1) && (*(lpFrom+1) == '-')) {

                    /* Yes.  Return it */
                    *lpTo = *lpFrom;
                    lpTo++;
                    lpFrom++;
                    cbFrom--;

                    *lpTo = *lpFrom;
                    lpTo++;
                    lpFrom++;
                    cbFrom--;

                    *lpTo = '\0';
                    *lpRemainder = lpFrom;
                    *pcbRemainder = cbFrom;
                    return ERR_SUCCESS;
                }

                if (len >= MAX_TOKEN_SIZE-1) {
                    *lpTo = '\0';
                    s_lstrcpy(lpstmt->szError, lpToken);
                    return ERR_ELEMENTTOOBIG;
                }
                len++;

                *lpTo = *lpFrom;
                lpTo++;
                lpFrom++;
                cbFrom--;
            }
        }
        else
            return ERR_UNEXPECTEDEND;
    
    default:
        s_lstrcpy(lpstmt->szError, "<escape-sequence>");
        return ERR_EXPECTEDOTHER;
    }
    /* Control never gets here */
}

/***************************************************************************/

RETCODE INTFUNC GetSymbol(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                          SDWORD FAR *pcbSqlStr, LPSTR lpszSymbol,
                          LPUSTR lpszToken)

/* Retrives a symbol from the input stream.  If lpszSymbol is not null, */
/* ERR_EXPECTEDOTHER is returned if the token found is not lpszSymbol.  */

{
    UWORD     fType;
    RETCODE    err;
    
    /* Get Identifier */
    err = GetToken(lpstmt, *lplpszSqlStr, *pcbSqlStr, lpszToken, &fType,
                  lplpszSqlStr, pcbSqlStr);
    if (err != ERR_SUCCESS)
        return err;
    if (fType != TOKEN_TYPE_SYMBOL) {
        if (lpszSymbol != NULL)
            s_lstrcpy(lpstmt->szError, lpszSymbol);
        else
            s_lstrcpy(lpstmt->szError, "<symbol>");
        return ERR_EXPECTEDOTHER;
    }

    /* Check value */
    if (lpszSymbol != NULL) {
        if (s_lstrcmpi(lpszSymbol, lpszToken)) {
            s_lstrcpy(lpstmt->szError, lpszSymbol);
            return ERR_EXPECTEDOTHER;
        }
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC GetInteger(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                           SDWORD FAR *pcbSqlStr, UDWORD FAR *pudValue,
                           LPUSTR lpszToken)

/* Retrives an integer number from the input stream.  The number is */
/* returned in both pudValue and lpszToken */

{
    UWORD     fType;
    RETCODE   err;
    
    /* Get Identifier */
    err = GetToken(lpstmt, *lplpszSqlStr, *pcbSqlStr, lpszToken, &fType,
                  lplpszSqlStr, pcbSqlStr);
    if (err != ERR_SUCCESS)
        return err;
    if (fType != TOKEN_TYPE_NUMBER) {
        s_lstrcpy(lpstmt->szError, lpszToken);
        return ERR_MALFORMEDNUMBER;
    }

    *pudValue = 0;
    while (*lpszToken) {
        switch (*lpszToken) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
           *pudValue = ((*pudValue) * 10) + (*lpszToken - '0');
            break;
        default:
            s_lstrcpy(lpstmt->szError, lpszToken);
            return ERR_MALFORMEDNUMBER;
        }
        lpszToken++;
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC GetNumber(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                          SDWORD FAR *pcbSqlStr, double FAR *lpDouble,
                          LPUSTR lpszToken, SWORD FAR *lpDatatype,
                          SWORD FAR *lpScale)

/* Retrives a real number from the input stream.  The number is returned */  
/* in both lpDouble and lpszToken */

{
    UWORD     fType;
    LPUSTR    lpChar;
    BOOL      neg;
    RETCODE   err;
    UCHAR     szTempToken[MAX_TOKEN_SIZE + 1];
    BOOL      negExponent;
    SWORD     exponent;
    SWORD     iScale;
    double    scaleFactor;
    
    /* Get Identifier */
    err = GetToken(lpstmt, *lplpszSqlStr, *pcbSqlStr, lpszToken, &fType,
                  lplpszSqlStr, pcbSqlStr);
    if (err != ERR_SUCCESS)
        return err;

    /* Figure out if value is negative */
    if ((fType == TOKEN_TYPE_SYMBOL) && (!s_lstrcmpi("-", lpszToken))) {
        neg = TRUE;
        err = GetToken(lpstmt, *lplpszSqlStr, *pcbSqlStr, lpszToken, &fType,
                  lplpszSqlStr, pcbSqlStr);
        if (err != ERR_SUCCESS)
            return err;
    }
    else if ((fType == TOKEN_TYPE_SYMBOL) && (!s_lstrcmpi("+", lpszToken))) {
        neg = FALSE;
        err = GetToken(lpstmt, *lplpszSqlStr, *pcbSqlStr, lpszToken, &fType,
                  lplpszSqlStr, pcbSqlStr);
        if (err != ERR_SUCCESS)
            return err;
    }
    else
        neg = FALSE;

    /* Error if no number */
    if (fType != TOKEN_TYPE_NUMBER) {
        s_lstrcpy(lpstmt->szError, "<number>");
        return ERR_EXPECTEDOTHER;
    }

    /* Error if number is too big */
    if (s_lstrlen(lpszToken) >= MAX_TOKEN_SIZE) {
        s_lstrcpy(lpstmt->szError, lpszToken);
        return ERR_MALFORMEDNUMBER;
    }

    /* Convert the number from a text string.  At the same time, figure */
    /* out its datatype */
    negExponent = FALSE;
    exponent = 0;
    *lpDouble = 0.0;
    lpChar = lpszToken;
    *lpDatatype = TYPE_INTEGER;
    *lpScale = 0;
    while (*lpChar != '\0') {
        switch (*lpChar) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':

            /* Add the digit into the result */
            switch (*lpDatatype) {
            case TYPE_DOUBLE:
                exponent = (exponent * 10) + (*lpChar - '0');
                break;
            case TYPE_NUMERIC:
                *lpDouble = (*lpDouble * 10.0) + (*lpChar - '0');
                (*lpScale)++;
                break;
            case TYPE_INTEGER:
                *lpDouble = (*lpDouble * 10.0) + (*lpChar - '0');
                break;
            case TYPE_CHAR:
            case TYPE_BINARY:
            case TYPE_DATE:
            case TYPE_TIME:
            case TYPE_TIMESTAMP:
            default:
                return ERR_INTERNAL;
            }
            break;
        case '.':

            /* If a decimal point, this is a numeric value */
            if (*lpDatatype != TYPE_INTEGER) {
                s_lstrcpy(lpstmt->szError, lpszToken);
                return ERR_MALFORMEDNUMBER;
            }
            *lpDatatype = TYPE_NUMERIC;
            break;

        case 'e':
        case 'E':

            /* If an E, this is a double value */
            *lpDatatype = TYPE_DOUBLE;

            /* Get sign of exponent */
            if (*(lpChar+1) == '-') {
                negExponent = TRUE;
                lpChar++;
            }
            else if (*(lpChar+1) == '+') {
                lpChar++;
            }
            break;
        default:
            s_lstrcpy(lpstmt->szError, lpszToken);
            return ERR_MALFORMEDNUMBER;
        }
        lpChar++;
    }

    /* If scale of a numeric value is zero, remove trailing decimal point */
    if ((*lpDatatype == TYPE_NUMERIC) && (*lpScale == 0)) {
        lpszToken[s_lstrlen(lpszToken)-1] = '\0';
        *lpDatatype = TYPE_INTEGER;
    }

    /* Return the number as a string */
    if (neg) {
        s_lstrcpy(szTempToken, lpszToken);
        s_lstrcpy(lpszToken, "-");
        s_lstrcat(lpszToken, szTempToken);
    }

    /* Adjust for scale */
    iScale = -(*lpScale);
    if (negExponent)
        iScale -= (exponent);
    else
        iScale += (exponent);

    scaleFactor = 1.0;
    while (iScale > 0) {
        scaleFactor = scaleFactor * 10.0;
        iScale--;
    }
    *lpDouble = *lpDouble * scaleFactor;

    scaleFactor = 1.0;
    while (iScale < 0) {
        scaleFactor = scaleFactor * 10.0;
        iScale++;
    }
    *lpDouble = *lpDouble / scaleFactor;

    /* Adjust for sign */
    if (neg)
        *lpDouble = -(*lpDouble);

    /* Adjust scale */
    if (*lpDatatype == TYPE_DOUBLE)
        *lpScale = NO_SCALE;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC GetIdent(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSTR lpszIdent,
                      LPUSTR lpszToken)

/* Retrives an identifier from the input stream.  The value is returned.   */

{
    UWORD     fType;
    LPUSTR    lpFrom;
    SDWORD    cbFrom;
    RETCODE   err;
    
    /* Remove leading blanks */
    lpFrom = *lplpszSqlStr;
    cbFrom = *pcbSqlStr;
    while ((cbFrom != 0) &&
           ((*lpFrom == ' ') ||
            (*lpFrom == '\012') ||
            (*lpFrom == '\015') ||
            (*lpFrom == '\011'))) {
        lpFrom++;
        cbFrom--;
    }
    if (cbFrom == 0)
        return ERR_UNEXPECTEDEND;
    if (*lpFrom == '"') {
        if (lpszIdent != NULL)
            s_lstrcpy(lpstmt->szError, lpszIdent);
        else
            s_lstrcpy(lpstmt->szError, "<keyword>");
        return ERR_EXPECTEDOTHER;
    }
    
    /* Get Identifier */
    err = GetToken(lpstmt, *lplpszSqlStr, *pcbSqlStr, lpszToken, &fType,
                  lplpszSqlStr, pcbSqlStr);
    if (err != ERR_SUCCESS)
        return err;
    if ((fType != TOKEN_TYPE_IDENTIFIER) && (fType != TOKEN_TYPE_KEYWORD)) {
         if (lpszIdent != NULL)
             s_lstrcpy(lpstmt->szError, lpszIdent);
         else
             s_lstrcpy(lpstmt->szError, "<identifier>");
        return ERR_EXPECTEDOTHER;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC GetIdentifier(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      STRINGIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives an identifier from the input stream and puts it into the       */
/* string area.  The value is also returned.                               */

{
    UWORD     fType;
    RETCODE   err;
    
    /* Get Identifier */
    err = GetToken(lpstmt, *lplpszSqlStr, *pcbSqlStr, lpszToken, &fType,
                  lplpszSqlStr, pcbSqlStr);
    if (err != ERR_SUCCESS)
        return err;
    if (fType != TOKEN_TYPE_IDENTIFIER) {
        s_lstrcpy(lpstmt->szError, "<identifier>");
        return ERR_EXPECTEDOTHER;
    }

    /* Put value into the string area */
    *lpIdx = AllocateString(lplpSql, lpszToken);
    if (*lpIdx == NO_STRING)
        return ERR_MEMALLOCFAIL;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC GetKeyword(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                           SDWORD FAR *pcbSqlStr, LPSTR lpszKeyword,
                           LPUSTR lpszToken)

/* Retrives a keyword from the input stream.  If lpszKeyword is not null, */
/* ERR_EXPECTEDOTHER is returned if the token found is not lpszKeyword.   */

{
    UWORD     fType;
    LPUSTR    lpFrom;
    SDWORD    cbFrom;
    RETCODE   err;
    
    /* Remove leading blanks */
    lpFrom = *lplpszSqlStr;
    cbFrom = *pcbSqlStr;
    while ((cbFrom != 0) &&
           ((*lpFrom == ' ') ||
            (*lpFrom == '\012') ||
            (*lpFrom == '\015') ||
            (*lpFrom == '\011'))) {
        lpFrom++;
        cbFrom--;
    }
    if (cbFrom == 0)
        return ERR_UNEXPECTEDEND;
    if (*lpFrom == '"') {
        if (lpszKeyword != NULL)
            s_lstrcpy(lpstmt->szError, lpszKeyword);
        else
            s_lstrcpy(lpstmt->szError, "<keyword>");
        return ERR_EXPECTEDOTHER;
    }
    
    /* Get Identifier */
    err = GetToken(lpstmt, *lplpszSqlStr, *pcbSqlStr, lpszToken, &fType,
                  lplpszSqlStr, pcbSqlStr);
    if (err != ERR_SUCCESS)
        return err;
    if (fType != TOKEN_TYPE_KEYWORD) {
        if (lpszKeyword != NULL)
            s_lstrcpy(lpstmt->szError, lpszKeyword);
        else
            s_lstrcpy(lpstmt->szError, "<keyword>");
        return ERR_EXPECTEDOTHER;
    }

    /* Check value */
    if (lpszKeyword != NULL) {
        if (s_lstrcmpi(lpszKeyword, lpszToken)) {
            s_lstrcpy(lpstmt->szError, lpszKeyword);
            return ERR_EXPECTEDOTHER;
        }
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC GetString(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      STRINGIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a string from the input stream and puts it into the string */
/* area.  The value is also returned.                                  */

{
    UWORD     fType;
    RETCODE   err;
    
    /* Get Identifier */
    err = GetToken(lpstmt, *lplpszSqlStr, *pcbSqlStr, lpszToken, &fType,
                  lplpszSqlStr, pcbSqlStr);
    if (err != ERR_SUCCESS)
        return err;
    if (fType != TOKEN_TYPE_STRING) {
        s_lstrcpy(lpstmt->szError, "<string>");
        return ERR_EXPECTEDOTHER;
    }

    /* Put value into the string area */
    *lpIdx = AllocateString(lplpSql, lpszToken);
    if (*lpIdx == NO_STRING)
        return ERR_MEMALLOCFAIL;

    return ERR_SUCCESS;
}
/***************************************************************************/
/***************************************************************************/

RETCODE INTFUNC ParseTable(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a tablename from the input stream and creates a               */
/* NODE_TYPE_TABLE node                                                   */
/*                                                                        */
/*    table ::= tablename                                                 */

{
    RETCODE    err;
    LPSQLNODE  lpSqlNode;
    STRINGIDX  idxName;
    STRINGIDX  idxQualifier;

    /* Get the tablename */
    err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxName, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    LPUSTR old_lpszSqlStr = *lplpszSqlStr;
    SDWORD old_cbSqlStr = *pcbSqlStr;

    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ".", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  unqualified table name */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        idxQualifier = NO_STRING;
    }
    else {

        /* Get the real table name */
        idxQualifier = idxName;
        err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                            &idxName, lpszToken);
        if (err != ERR_SUCCESS) {

            /* This must be a simple table name. */	// seems a bit dgy, see ParseColRef
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            idxName = idxQualifier;
            idxQualifier = NO_STRING;
        }
	}

    /* Create the TABLE node */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_TABLE);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdx);
    lpSqlNode->node.table.Name = idxName;
    lpSqlNode->node.table.Qualifier = idxQualifier;
    lpSqlNode->node.table.Alias = NO_STRING;
    lpSqlNode->node.table.OuterJoinFromTables = NO_SQLNODE;
    lpSqlNode->node.table.OuterJoinPredicate = NO_SQLNODE;
    lpSqlNode->node.table.Handle = NULL;
    lpSqlNode->node.table.cRestrict = 0;
    lpSqlNode->node.table.Restrict = NO_SQLNODE;
    lpSqlNode->node.table.Sortsequence = 0;
    lpSqlNode->node.table.Sortcount = 0;
    lpSqlNode->node.table.Sortcolumns = NO_SQLNODE;
    lpSqlNode->node.table.AllNull = FALSE;
    lpSqlNode->node.table.Rewound = TRUE;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseTableref(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a table reference from the input stream and creates a          */
/* NODE_TYPE_TABLE node                                                    */
/*                                                                         */
/*    tableref ::= table aliasname | table                                 */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    STRINGIDX  idxAlias;

    /* Get the table */
    err = ParseTable(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, lpIdx,
                     lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Alias given? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxAlias,
                        lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  No alias given */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        idxAlias = NO_STRING;
    }
    else {

        /* Yes.  Save the alias */
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.table.Alias = idxAlias;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseOJ(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdxLeft, SQLNODEIDX FAR *lpIdxRight,
                      LPUSTR lpszToken)

/* Retrives an outer join from the input stream and creates two            */
/* NODE_TYPE_TABLES nodes which are linked together.                       */
/*                                                                         */
/*   oj := tableref LEFT OUTER JOIN tableref ON boolean |                  */
/*         tableref LEFT OUTER JOIN oj ON boolean                          */

{
    RETCODE    err;
    SQLNODEIDX idxTableLeft;
    SQLNODEIDX idxTableRight;
    SQLNODEIDX idxTablesRight;
    SQLNODEIDX idxPredicate;
    LPSQLNODE  lpSqlNode;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;

    /* Get left table */
    err = ParseTableref(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                            &idxTableLeft, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get LEFT OUTER JOIN keywords */
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "LEFT", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "OUTER", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "JOIN", lpszToken);
    if (err != ERR_SUCCESS)
        return err;
    
    /* Get nested outer join */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = ParseOJ(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                      &idxTablesRight, lpIdxRight, lpszToken);
    if (err == ERR_SUCCESS) {
        lpSqlNode = ToNode(*lplpSql, idxTablesRight);
        idxTableRight = lpSqlNode->node.tables.Table;
    }
    else {

        /* Not a nested outer join.  Just get right table */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = ParseTableref(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                            &idxTableRight, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the TABLES node for the right table */
        idxTablesRight = AllocateNode(lplpSql, NODE_TYPE_TABLES);
        if (idxTablesRight == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, idxTablesRight);
        lpSqlNode->node.tables.Table = idxTableRight;
        lpSqlNode->node.tables.Next = NO_SQLNODE;
        *lpIdxRight = idxTablesRight;
    }

    /* Get ON keyword */
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "ON", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get condition */
    err = ParseBoolean(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                           &idxPredicate, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Create the TABLES node for the left table */
    *lpIdxLeft = AllocateNode(lplpSql, NODE_TYPE_TABLES);
    if (*lpIdxLeft == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdxLeft);
    lpSqlNode->node.tables.Table = idxTableLeft;
    lpSqlNode->node.tables.Next = idxTablesRight;

    /* Put in outer join information into the right table node */
    lpSqlNode = ToNode(*lplpSql, idxTableRight);
    lpSqlNode->node.table.OuterJoinFromTables = *lpIdxLeft;
    lpSqlNode->node.table.OuterJoinPredicate = idxPredicate;

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseOuterJoin(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdxLeft, SQLNODEIDX FAR *lpIdxRight,
                      LPUSTR lpszToken)

/* Retrives an outer join from the input stream and creates two            */
/* NODE_TYPE_TABLES nodes which are linked together.                       */
/*                                                                         */
/*   ojshorthand := { OJ oj }                                              */
/*   ojescape := --*(VENDOR(MICROSOFT),PRODUCT(ODBC) OJ oj)*--             */
/*   outerjoin ::= ojescape | ojshorthand                                  */

{
    RETCODE    err;
    BOOL       fShorthand;

    /* Get starting symbol */
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Shorthand? */
    if (s_lstrcmpi(lpszToken, "{")) {

        /* No.  Not a shorthand */
        fShorthand = FALSE;

        /* If not an escape clause, error */
        if (s_lstrcmpi(lpszToken, "--")) {
            s_lstrcpy(lpstmt->szError, "--");
            return ERR_EXPECTEDOTHER;
        }

        /* Get the rest of the starting sequence */
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

		err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "*", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetIdent(lpstmt, lplpszSqlStr, pcbSqlStr, "vendor", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetIdent(lpstmt, lplpszSqlStr, pcbSqlStr, "Microsoft", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ",", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetIdent(lpstmt, lplpszSqlStr, pcbSqlStr, "product", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetIdent(lpstmt, lplpszSqlStr, pcbSqlStr, "ODBC", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }
    else
        fShorthand = TRUE;

    /* Get OJ keyword */
    err = GetIdent(lpstmt, lplpszSqlStr, pcbSqlStr, "oj", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get outer join tables and condition */
    err = ParseOJ(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                      lpIdxLeft, lpIdxRight, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get closing bracket */
    if (!fShorthand) {
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "*", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
		err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "--", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }
    else {
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "}", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseTablelist(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a list of tablenames from the input stream and creates a       */
/* NODE_TYPE_TABLES node                                                   */
/*                                                                         */
/*   tablelistitem ::= tableref | outerjoin                                */
/*   tablelist ::= tablelistitem , tablelist | tablelistitem               */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxTables;
    SQLNODEIDX idxTable;
    SQLNODEIDX idxRight;
    BOOL       fOuterJoin;

    /* Outerjoin? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = ParseOuterJoin(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, lpIdx,
                         &idxRight, lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  Table reference? */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = ParseTableref(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                            &idxTable, lpszToken);
        if (err != ERR_SUCCESS)
            return err;
        fOuterJoin = FALSE;
    }
    else
        fOuterJoin = TRUE;

    /* Is there a comma? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ",", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  This is the last one */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        idxTables = NO_SQLNODE;
    }
    else {

        /* Yes.  Get the rest of the list */
        err = ParseTablelist(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                     &idxTables, lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }

    /* Outer join? */
    if (!fOuterJoin) {

        /* No.  Create the TABLES node */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_TABLES);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.tables.Table = idxTable;
        lpSqlNode->node.tables.Next = idxTables;
    }
    else {

        /* Yes.  Link right side to the rest of the list */
        if (idxTables != NO_SQLNODE) {
            lpSqlNode = ToNode(*lplpSql, idxRight);
            lpSqlNode->node.tables.Next = idxTables;
        }
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseColref(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a pattern from the input stream and creates a                 */
/* NODE_TYPE_COLUMN node                                                  */
/*                                                                        */
/*    colref ::= aliasname . columnname | columnname                      */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    STRINGIDX  idxColumn = NO_STRING;
    STRINGIDX  idxAlias = NO_STRING;
    STRINGIDX  idxQualifier = NO_STRING;

    /* Get the columnname */
    err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxColumn, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Qualified column name? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ".", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  Simple column name */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        idxAlias = NO_STRING;
        idxQualifier = NO_STRING;
    }
    else {

        /* Get the real columnname */
        idxAlias = idxColumn;
        err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                            &idxColumn, lpszToken);
        if (err != ERR_SUCCESS) {

            /* This must be a simple column name. */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            idxColumn = idxAlias;
            idxAlias = NO_STRING;
            idxQualifier = NO_STRING;
        }
		else
		{
			old_lpszSqlStr = *lplpszSqlStr;
			old_cbSqlStr = *pcbSqlStr; 
			err = GetSymbol (lpstmt, lplpszSqlStr, pcbSqlStr, ".", lpszToken);
			if (err != ERR_SUCCESS)
			{
		        /* No.  No qualifier. */
				*lplpszSqlStr = old_lpszSqlStr;
				*pcbSqlStr = old_cbSqlStr;
				idxQualifier = NO_STRING;
			}
			else
			{
				idxQualifier = idxAlias;
				idxAlias = idxColumn;
				err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
									&idxColumn, lpszToken);
				if (err != ERR_SUCCESS) {

					/* This must be a simple column name. */
					*lplpszSqlStr = old_lpszSqlStr;
					*pcbSqlStr = old_cbSqlStr;
					idxColumn = idxAlias;
					idxAlias = idxQualifier;
					idxQualifier = NO_STRING;
				}

			}
        }
    }

    /* Create the COLUMN node */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_COLUMN);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdx);
    lpSqlNode->node.column.Tablealias = idxAlias;
    lpSqlNode->node.column.Column = idxColumn;
    lpSqlNode->node.column.Qualifier = idxQualifier;
    
    /* These will be filled in by SemanticCheck() */
    lpSqlNode->node.column.TableIndex = NO_SQLNODE;  
    lpSqlNode->node.column.MatchedAlias = FALSE;
    lpSqlNode->node.column.Table = NO_SQLNODE;
    lpSqlNode->node.column.Id = -1;
    lpSqlNode->node.column.Value = NO_STRING;
    lpSqlNode->node.column.InSortRecord = FALSE;
    lpSqlNode->node.column.Offset = 0;
    lpSqlNode->node.column.Length = 0;
    lpSqlNode->node.column.DistinctOffset = 0;
    lpSqlNode->node.column.DistinctLength = 0;
    lpSqlNode->node.column.EnclosingStatement = NO_SQLNODE;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseOrderbyterm(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, BOOL FAR *lpfDescending,
                      LPUSTR lpszToken)

/* Retrives a sort order from the input stream and creates a              */
/* NODE_TYPE_COLUMN or NODE_TYPE_NUMERIC node                             */
/*                                                                        */
/*    orderbyterm ::= colref asc | integer asc                            */
/*    asc ::=  | ASC | DESC                                               */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    UDWORD     udInteger;

    /* Integer specified? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetInteger(lpstmt, lplpszSqlStr, pcbSqlStr, &udInteger,
                         lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  Get column reference instead */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = ParseColref(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, lpIdx,
                              lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }
    else {

        /* Yes.  Return it */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_NUMERIC);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->sqlDataType = TYPE_INTEGER;
        lpSqlNode->sqlSqlType = SQL_INTEGER;
        lpSqlNode->sqlPrecision = 10;
        lpSqlNode->sqlScale = 0;
        lpSqlNode->node.numeric.Value = udInteger;
        lpSqlNode->node.numeric.Numeric = AllocateString(lplpSql, lpszToken);
        if (lpSqlNode->node.numeric.Numeric == NO_STRING)
            return ERR_MEMALLOCFAIL;
    }

    /* Get ASC or DESC */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
    if (err != ERR_SUCCESS) {
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        *lpfDescending = FALSE;
    }
    else if (!s_lstrcmpi(lpszToken, "ASC")) {
        *lpfDescending = FALSE;
    }
    else if (!s_lstrcmpi(lpszToken, "DESC")) {
        *lpfDescending = TRUE;
    }
    else {
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        *lpfDescending = FALSE;
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseOrderbyterms(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a sort order from the input stream and creates a              */
/* NODE_TYPE_SORTCOLUMNS node                                             */
/*                                                                        */
/*    orderbyterms ::= orderbyterm | orderbyterm , orderbyterms           */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    BOOL       fDescending;
    SQLNODEIDX idxColumn;
    SQLNODEIDX idxSortcolumns;
    SQLNODEIDX idxSortcolumnsPrev;

    /* Get list of nodes */
    idxSortcolumnsPrev = NO_SQLNODE;
    while (TRUE) {

        /* Get orderby column */
        err = ParseOrderbyterm(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                           &idxColumn, &fDescending, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the SORTCOLUMNS node */
        idxSortcolumns = AllocateNode(lplpSql, NODE_TYPE_SORTCOLUMNS);
        if (idxSortcolumns == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, idxSortcolumns);
        lpSqlNode->node.sortcolumns.Column = idxColumn;
        lpSqlNode->node.sortcolumns.Descending = fDescending;
        lpSqlNode->node.sortcolumns.Next = NO_SQLNODE;

        /* Put node on list */
        if (idxSortcolumnsPrev != NO_SQLNODE) {
            lpSqlNode = ToNode(*lplpSql, idxSortcolumnsPrev);
            lpSqlNode->node.sortcolumns.Next = idxSortcolumns;
        }
        else 
            *lpIdx = idxSortcolumns;
        idxSortcolumnsPrev = idxSortcolumns;

        /* Is there a comma? */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ",", lpszToken);
        if (err != ERR_SUCCESS) {

            /* No.  This is the last orderby column */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            break;
        }
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseOrderby(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a sort order from the input stream and creates a              */
/* NODE_TYPE_SORTCOLUMNS or NULL node                                     */
/*                                                                        */
/*    orderby ::= | ORDER BY orderbyterms                                 */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;

    /* Is there an "ORDER BY"? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "ORDER", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No. Return null */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        *lpIdx = NO_SQLNODE;
    }
    else {

        /* Yes.  Get keyword */
        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "BY", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Get orderby column */
        err = ParseOrderbyterms(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                                lpIdx, lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseGroupbyterms(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a sort order from the input stream and creates a              */
/* NODE_TYPE_SORTCOLUMNS node                                             */
/*                                                                        */
/*    groupbyterms ::= colref | colref , groupbyterms                     */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxColumn;
    SQLNODEIDX idxGroupbycolumns;
    SQLNODEIDX idxGroupbycolumnsPrev;

    /* Get list of nodes */
    idxGroupbycolumnsPrev = NO_SQLNODE;
    while (TRUE) {

        /* Get column reference */
        err = ParseColref(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                           &idxColumn, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the GROUPBYCOLUMNS node */
        idxGroupbycolumns = AllocateNode(lplpSql, NODE_TYPE_GROUPBYCOLUMNS);
        if (idxGroupbycolumns == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, idxGroupbycolumns);
        lpSqlNode->node.groupbycolumns.Column = idxColumn;
        lpSqlNode->node.groupbycolumns.Next = NO_SQLNODE;

        /* Put node on list */
        if (idxGroupbycolumnsPrev != NO_SQLNODE) {
            lpSqlNode = ToNode(*lplpSql, idxGroupbycolumnsPrev);
            lpSqlNode->node.groupbycolumns.Next = idxGroupbycolumns;
        }
        else
            *lpIdx = idxGroupbycolumns;
        idxGroupbycolumnsPrev = idxGroupbycolumns;

        /* Is there a comma? */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ",", lpszToken);
        if (err != ERR_SUCCESS) {

            /* No.  This is the last groupbyby column */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            break;
        }
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseGroupby(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a sort order from the input stream and creates a              */
/* NODE_TYPE_GROUPBYCOLUMNS or NULL node                                  */
/*                                                                        */
/*    groupby ::= | GROUP BY groupbyterms                                 */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;

    /* Is there an "GROUP BY"? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "GROUP", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No. Return null */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        *lpIdx = NO_SQLNODE;
    }
    else {

        /* Yes.  Get keyword */
        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "BY", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Get grooupby columns */
        err = ParseGroupbyterms(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                                lpIdx, lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseSimpleterm(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a term from the input stream and creates a NODE_TYPE_STRING,   */
/* NODE_TYPE_NUMERIC, NODE_TYPE_PARAMETER, NODE_TYPE_USER, NODE_TYPE_DATE, */ 
/* NODE_TYPE_TIME, or NODE_TYPE_TIMESTAMP node.                            */
/*                                                                         */
/*  simpleterm ::= string | realnumber | ? | USER | date | time | timestamp */
{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    STRINGIDX  idxString;
    LPSQLNODE  lpSqlNode;
    double     dbl;
    SQLNODEIDX idxParameter;
    UWORD      parameterId;
    SWORD      datatype;
    SWORD      scale;
    DATE_STRUCT date;
    TIME_STRUCT time;
    TIMESTAMP_STRUCT timestamp;

    /* Is it a string? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetString(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxString, lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  Is it a parameter */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "?", lpszToken);
        if (err != ERR_SUCCESS) {

            /* No.  Is it USER? */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "USER",
                             lpszToken);
            if (err != ERR_SUCCESS) {

                /* No. Is it a realnumber? */
                *lplpszSqlStr = old_lpszSqlStr;
                *pcbSqlStr = old_cbSqlStr;
                err = GetNumber(lpstmt, lplpszSqlStr, pcbSqlStr, &dbl,
                                lpszToken, &datatype, &scale);
                if (err != ERR_SUCCESS) {

                    /* No. Is it an escape sequence? */
                    *lplpszSqlStr = old_lpszSqlStr;
                    *pcbSqlStr = old_cbSqlStr;
                    err = GetEscape(lpstmt, *lplpszSqlStr, *pcbSqlStr,
                                 lpszToken, lplpszSqlStr, pcbSqlStr);
                    if (err != ERR_SUCCESS) {
                        if (err == ERR_EXPECTEDOTHER)
                            s_lstrcpy(lpstmt->szError, "<simpleterm>");
                        return err;
                    }

                    /* It is an escape sequence.  A date? */
                    if (!CharToDate(lpszToken, SQL_NTS, &date)) {

                        /* Make date node */
                        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_DATE);
                        if (*lpIdx == NO_SQLNODE)
                            return ERR_MEMALLOCFAIL;
                        lpSqlNode = ToNode(*lplpSql, *lpIdx);
                        lpSqlNode->node.date.Value = date;
                    }

                    /* A time? */
                    else if (!CharToTime(lpszToken, SQL_NTS, &time)) {

                        /* Make time node */
                        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_TIME);
                        if (*lpIdx == NO_SQLNODE)
                            return ERR_MEMALLOCFAIL;
                        lpSqlNode = ToNode(*lplpSql, *lpIdx);
                        lpSqlNode->node.time.Value = time;
                    }

                    /* A timestamp? */
                    else if (!CharToTimestamp(lpszToken, SQL_NTS, &timestamp)) {

                        /* Make timestamp node */
                        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_TIMESTAMP);
                        if (*lpIdx == NO_SQLNODE)
                            return ERR_MEMALLOCFAIL;
                        lpSqlNode = ToNode(*lplpSql, *lpIdx);
                        lpSqlNode->node.timestamp.Value = timestamp;
                    }

                    else {
                        s_lstrcpy(lpstmt->szError, lpszToken);
                        return ERR_BADESCAPE;
                    }
                }
                else {
                    /* Make numeric node */
                    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_NUMERIC);
                    if (*lpIdx == NO_SQLNODE)
                        return ERR_MEMALLOCFAIL;
                    lpSqlNode = ToNode(*lplpSql, *lpIdx);
                    if ((s_lstrlen(lpszToken) >= 10) &&
                                        (datatype == TYPE_INTEGER)) {
                        datatype = TYPE_DOUBLE;
                        scale = NO_SCALE;
                    }
                    switch (datatype) {
                    case TYPE_DOUBLE:
                        lpSqlNode->sqlDataType = TYPE_DOUBLE;
                        lpSqlNode->sqlSqlType = SQL_DOUBLE;
                        lpSqlNode->sqlPrecision = 15;
                        lpSqlNode->sqlScale = NO_SCALE;
                        break;
                    case TYPE_INTEGER:
                        lpSqlNode->sqlDataType = TYPE_INTEGER;
                        lpSqlNode->sqlSqlType = SQL_INTEGER;
                        lpSqlNode->sqlPrecision = 10;
                        lpSqlNode->sqlScale = 0;
                        break;
                    case TYPE_NUMERIC:
                        lpSqlNode->sqlDataType = TYPE_NUMERIC;
                        lpSqlNode->sqlSqlType = SQL_DECIMAL;
                        if (*lpszToken != '-')
                            lpSqlNode->sqlPrecision = s_lstrlen(lpszToken)-1;
                        else
                            lpSqlNode->sqlPrecision = s_lstrlen(lpszToken)-2;
                        lpSqlNode->sqlScale = scale;
                        BCDNormalize(lpszToken, s_lstrlen(lpszToken),
                                     lpszToken, s_lstrlen(lpszToken) + 1,
                                     lpSqlNode->sqlPrecision,
                                     lpSqlNode->sqlScale);
                        break;
                    case TYPE_CHAR:
                    case TYPE_BINARY:
                    case TYPE_DATE:
                    case TYPE_TIME:
                    case TYPE_TIMESTAMP:
                    default:
                        return ERR_INTERNAL;
                    }
                    lpSqlNode->node.numeric.Numeric = AllocateSpace(lplpSql,
                                (SWORD) (s_lstrlen(lpszToken) + 2));
                                /* The extra space is to allow negation of */
                                /* this value in SEMANTIC.C */
                    if (lpSqlNode->node.numeric.Numeric == NO_STRING)
                        return ERR_MEMALLOCFAIL;
                    s_lstrcpy(ToString(*lplpSql, lpSqlNode->node.numeric.Numeric),
                                     lpszToken);
                    lpSqlNode->node.numeric.Value = dbl;
                }
            }
            else {

                /* Yes.  Make USER node */
                *lpIdx = AllocateNode(lplpSql, NODE_TYPE_USER);
                if (*lpIdx == NO_SQLNODE)
                    return ERR_MEMALLOCFAIL;
            }
        }
        else {

            /* Yes.  Make PARAMETER node */
            *lpIdx = AllocateNode(lplpSql, NODE_TYPE_PARAMETER);
            if (*lpIdx == NO_SQLNODE)
                return ERR_MEMALLOCFAIL;

            /* First parameter? */
            idxParameter = (*lplpSql)->node.root.parameters;
            if (idxParameter == NO_SQLNODE) {

                /* Yes.  Initialize list of parameters */
                (*lplpSql)->node.root.parameters = *lpIdx;
                lpSqlNode = ToNode(*lplpSql, *lpIdx);
                lpSqlNode->node.parameter.Id = 1;
            }
            else {

                /* No. Get last element of parameter list */
                while (TRUE) {
                    lpSqlNode = ToNode(*lplpSql, idxParameter);
                    idxParameter = lpSqlNode->node.parameter.Next;
                    if (idxParameter == NO_SQLNODE)
                        break;
                }

                /* Put node on list */
                lpSqlNode->node.parameter.Next = *lpIdx;

                /* Determine id of parameter */
                parameterId = lpSqlNode->node.parameter.Id + 1;
                lpSqlNode = ToNode(*lplpSql, *lpIdx);
                lpSqlNode->node.parameter.Id = parameterId;
            }
            lpSqlNode->node.parameter.Next = NO_SQLNODE;
            lpSqlNode->node.parameter.Value = NO_STRING;
            lpSqlNode->node.parameter.AtExec = FALSE;
        }
    }
    else {

        /* Yes.  Make STRING node */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_STRING);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.string.Value = idxString;
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseAggterm(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a term from the input stream and creates a NODE_TYPE_AGGREGATE */
/* node.                                                                   */
/*                                                                         */
/*   aggterm ::= COUNT ( * ) | AVG ( expression ) | MAX ( expression ) |   */
/*               MIN ( expression ) | SUM ( expression )                   */
{
    RETCODE    err;
    UWORD      op;
    SQLNODEIDX idxExpression;
    LPSQLNODE  lpSqlNode;

    /* Get starting keyword */
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    //double check for aggregate functions not supported
    if (lpszToken && !s_lstrcmpi(lpszToken, "LEN"))
    {
        return ERR_LEN_NOTSUPP;
    }

    /* Convert it to an aggregate operator */
    if (!s_lstrcmpi(lpszToken, "COUNT"))
        op = AGG_COUNT;
    else if (!s_lstrcmpi(lpszToken, "AVG"))
        op = AGG_AVG;
    else if (!s_lstrcmpi(lpszToken, "MAX"))
        op = AGG_MAX;
    else if (!s_lstrcmpi(lpszToken, "MIN"))
        op = AGG_MIN;
    else if (!s_lstrcmpi(lpszToken, "SUM"))
        op = AGG_SUM;
    else {
        s_lstrcpy(lpstmt->szError, "COUNT, AVG, MAX, MIN, or SUM");
        return ERR_EXPECTEDOTHER;
    }

    /* Get opening paren */
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Based on type of operator... */
    switch(op) {
    case AGG_COUNT:

        /* Get * */
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "*", lpszToken);
        if (err != ERR_SUCCESS)
            return ERR_COUNT_NOTSUPP;
        idxExpression = NO_SQLNODE;
        break;

    case AGG_AVG:
    case AGG_MAX:
    case AGG_MIN:
    case AGG_SUM:

        /* Get expression */
        err = ParseExpression(lpstmt, lplpszSqlStr, pcbSqlStr,
                              lplpSql, &idxExpression, lpszToken);
        if (err != ERR_SUCCESS)
            return err;
        break;

    default:
        return ERR_INTERNAL;
    }

    /* Get closing paren */
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Make AGGREGATE node */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_AGGREGATE);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdx);
    lpSqlNode->node.aggregate.Operator = op;
    lpSqlNode->node.aggregate.Expression = idxExpression;
    lpSqlNode->node.aggregate.Value = NO_STRING;
    lpSqlNode->node.aggregate.Offset = 0;
    lpSqlNode->node.aggregate.Length = 0;
    lpSqlNode->node.aggregate.DistinctOffset = 0;
    lpSqlNode->node.aggregate.DistinctLength = 0;
    lpSqlNode->node.aggregate.EnclosingStatement = NO_SQLNODE;
    lpSqlNode->node.aggregate.Next = NO_SQLNODE;
    lpSqlNode->node.aggregate.Count = 0.0;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseValuelist(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a list of expressions from the input stream and creates a      */
/* NODE_TYPE_VALUES node                                                   */
/*                                                                         */
/* valuelist ::= expression , valuelist | expression | NULL , valuelist |  */
/*               NULL                                                      */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxValues;
    SQLNODEIDX idxValue;
    SQLNODEIDX idxValuesPrev;

    /* Get list of nodes */
    idxValuesPrev = NO_SQLNODE;
    while (TRUE) {

        /* NULL specified? */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "NULL", lpszToken);
        if (err != ERR_SUCCESS) {
    
            /* No.  Get expression */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            err = ParseExpression(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                                  &idxValue, lpszToken);
            if (err != ERR_SUCCESS)
                return err;
        }
        else {

            /* Yes.  Create a NULL node */
            idxValue = AllocateNode(lplpSql, NODE_TYPE_NULL);
            if (idxValue == NO_SQLNODE)
                return ERR_MEMALLOCFAIL;
        }

        /* Create the VALUES node */
        idxValues = AllocateNode(lplpSql, NODE_TYPE_VALUES);
        if (idxValues == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, idxValues);
        lpSqlNode->node.values.Value = idxValue;
        lpSqlNode->node.values.Alias = NO_STRING;
        lpSqlNode->node.values.Next = NO_SQLNODE;

        /* Put node on list */
        if (idxValuesPrev != NO_SQLNODE) {
            lpSqlNode = ToNode(*lplpSql, idxValuesPrev);
            lpSqlNode->node.values.Next = idxValues;
        }
        else
            *lpIdx = idxValues;
        idxValuesPrev = idxValues;

        /* Is there a comma? */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ",", lpszToken);
        if (err != ERR_SUCCESS) {

            /* No.  This is the last value */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            break;
        }
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseScalar(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives ascalar reference from the input stream and creates a          */
/* NODE_TYPE_SCALE node.                                                   */
/*                                                                         */
/*   fn := functionname ( valuelist ) | functionname ( )                   */
/*   scalarshorthand := { FN fn }                                          */
/*   scalarescape := --*(VENDOR(MICROSOFT),PRODUCT(ODBC) FN fn)*--         */
/*   scalar ::= scalarescape | scalarshorthand                             */
{
    RETCODE    err;
    BOOL       fShorthand;
    STRINGIDX  idxFunction;
    SQLNODEIDX idxValues;
    LPSQLNODE  lpSqlNode;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;

    /* Get starting symbol */
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Shorthand? */
    if (s_lstrcmpi(lpszToken, "{")) {

        /* No.  Not a shorthand */
        fShorthand = FALSE;

        /* If not an escape clause, error */
        if (s_lstrcmpi(lpszToken, "--")) {
            s_lstrcpy(lpstmt->szError, "--");
            return ERR_EXPECTEDOTHER;
        }

        /* Get the rest of the starting sequence */
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
        
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "*", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetIdent(lpstmt, lplpszSqlStr, pcbSqlStr, "vendor", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetIdent(lpstmt, lplpszSqlStr, pcbSqlStr, "Microsoft", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ",", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetIdent(lpstmt, lplpszSqlStr, pcbSqlStr, "product", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetIdent(lpstmt, lplpszSqlStr, pcbSqlStr, "ODBC", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }
    else
        fShorthand = TRUE;

    /* Get FN keyword */
    err = GetIdent(lpstmt, lplpszSqlStr, pcbSqlStr, "fn", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get function name */
    err = GetIdent(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
    if (err != ERR_SUCCESS)
        return err;
    idxFunction = AllocateString(lplpSql, lpszToken);
    if (idxFunction == NO_STRING)
        return ERR_MEMALLOCFAIL;

    /* Get arguments (if any) */
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
    if (err != ERR_SUCCESS)
        return err;
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = ParseValuelist(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                         &idxValues, lpszToken);
    if (err != ERR_SUCCESS) {
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        idxValues = NO_SQLNODE;
    }
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get closing bracket */
    if (!fShorthand) {
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "*", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "--", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }
    else {
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "}", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }

    /* Create the SCALAR node  */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_SCALAR);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdx);
    lpSqlNode->node.scalar.Function = idxFunction;
    lpSqlNode->node.scalar.Arguments = idxValues;
    lpSqlNode->node.scalar.Id = 0;
    lpSqlNode->node.scalar.Interval = 0;
    lpSqlNode->node.scalar.Value = NO_STRING;
    lpSqlNode->node.scalar.DistinctOffset = 0;
    lpSqlNode->node.scalar.DistinctLength = 0;
    lpSqlNode->node.scalar.EnclosingStatement = NO_SQLNODE;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseTerm(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a term from the input stream and creates a NODE_TYPE_COLUMN,   */
/* NODE_TYPE_ALGEBRAIC, NODE_TYPE_AGGREGATE, NODE_TYPE_STRING,             */
/* NODE_TYPE_NUMERIC, NODE_TYPE_PARAMETER, NODE_TYPE_USER, NODE_TYPE_DATE, */ 
/* NODE_TYPE_TIME, or NODE_TYPE_TIMESTAMP node.                            */
/*                                                                         */
/*   term ::= ( expression ) | colref | simpleterm | aggterm | scalar      */
{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;

    /* Is it a simpleterm? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = ParseSimpleterm(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, lpIdx,
                          lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  Is it an aggregate function? */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = ParseAggterm(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, lpIdx,
                          lpszToken);

        //Return straight away if error was due to 
        //non-support of certain aggregate functions
        if ( (err == ERR_LEN_NOTSUPP) || (err == ERR_COUNT_NOTSUPP) )
            return err;

        if (err != ERR_SUCCESS) {

            /* No.  Is it ( expression )? */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
            if (err != ERR_SUCCESS) {

                /* No.  Is it a column reference? */
                *lplpszSqlStr = old_lpszSqlStr;
                *pcbSqlStr = old_cbSqlStr;
                err = ParseColref(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                              lpIdx, lpszToken);
                if (err != ERR_SUCCESS) {

                    /* No.  Is it a scalar? */
                    *lplpszSqlStr = old_lpszSqlStr;
                    *pcbSqlStr = old_cbSqlStr;
                    err = ParseScalar(lpstmt, lplpszSqlStr, pcbSqlStr,
                                      lplpSql, lpIdx, lpszToken);
                    if (err != ERR_SUCCESS) {
                        s_lstrcpy(lpstmt->szError, "<identifier>");
                        return ERR_EXPECTEDOTHER;
                    }
                }
            }
            else {

                /* Yes.  Get expression */
                err = ParseExpression(lpstmt, lplpszSqlStr, pcbSqlStr,
                                      lplpSql, lpIdx, lpszToken);
                if (err != ERR_SUCCESS)
                    return err;

                /* Get terminating ")" */
                err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")",
                                lpszToken);

		//Do a double check for the unsupported BETWEEN function
		if (lpszToken && !s_lstrcmpi(lpszToken, "BETWEEN"))
		{
			return ERR_BETWEEN_NOTSUPP;
		}

                if (err != ERR_SUCCESS)
                    return err;
            }
        }
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseNeg(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives an algebraic expression from the input stream and creates a   */
/* NODE_TYPE_ALGEBRAIC node                                               */
/*                                                                        */
/*    neg ::= term | + term | - term                                      */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxChild;
    UWORD      op;

    /* Get + or - */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
    if (err != ERR_SUCCESS) {
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        op = OP_NONE;
    }
    else {
        if (!s_lstrcmpi(lpszToken, "-"))
            op = OP_NEG;
        else if (!s_lstrcmpi(lpszToken, "+"))
            op = OP_NONE;
        else {
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            op = OP_NONE;
        }
    }

    /* Get term */
    err = ParseTerm(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxChild,
                    lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Return node */
    if (op == OP_NONE) {
        *lpIdx = idxChild;
    }
    else {
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_ALGEBRAIC);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.algebraic.Operator = OP_NEG;
        lpSqlNode->node.algebraic.Left = idxChild;
        lpSqlNode->node.algebraic.Right = NO_SQLNODE;
        lpSqlNode->node.algebraic.Value = NO_STRING;
        lpSqlNode->node.algebraic.WorkBuffer1 = NO_STRING;
        lpSqlNode->node.algebraic.WorkBuffer2 = NO_STRING;
        lpSqlNode->node.algebraic.WorkBuffer3 = NO_STRING;
        lpSqlNode->node.algebraic.DistinctOffset = 0;
        lpSqlNode->node.algebraic.DistinctLength = 0;
        lpSqlNode->node.algebraic.EnclosingStatement = NO_SQLNODE;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseTimes(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives an algebraic expression from the input stream and creates a   */
/* NODE_TYPE_ALGEBRAIC node                                               */
/*                                                                        */
/*    times ::= times * neg | times / neg | neg                           */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxLeft;
    SQLNODEIDX idxRight;
    SQLNODEIDX idxNew;
    UWORD      op;

   /* Get start of expression */
    err = ParseNeg(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxLeft,
                   lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get the rest of the expression */
    while (TRUE) {

        /* Get * or / */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
        if (err != ERR_SUCCESS) {
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            *lpIdx = idxLeft;
            break;
        }
        else {
            if ( (!s_lstrcmpi(lpszToken, "*")) &&
				( (*pcbSqlStr == 0) || (*(*lplpszSqlStr) != ')' ) ) )
                op = OP_TIMES;
            else if (!s_lstrcmpi(lpszToken, "/"))
                op = OP_DIVIDEDBY;
            else {
                *lplpszSqlStr = old_lpszSqlStr;
                *pcbSqlStr = old_cbSqlStr;
                *lpIdx = idxLeft;
                break;
            }
        }

        /* Get right side */
        err = ParseNeg(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxRight,
                       lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Make two halves into a node */
        idxNew = AllocateNode(lplpSql, NODE_TYPE_ALGEBRAIC);
        if (idxNew == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, idxNew);
        lpSqlNode->node.algebraic.Operator = op;
        lpSqlNode->node.algebraic.Left = idxLeft;
        lpSqlNode->node.algebraic.Right = idxRight;
        lpSqlNode->node.algebraic.Value = NO_STRING;
        lpSqlNode->node.algebraic.WorkBuffer1 = NO_STRING;
        lpSqlNode->node.algebraic.WorkBuffer2 = NO_STRING;
        lpSqlNode->node.algebraic.WorkBuffer3 = NO_STRING;
        lpSqlNode->node.algebraic.DistinctOffset = 0;
        lpSqlNode->node.algebraic.DistinctLength = 0;
        lpSqlNode->node.algebraic.EnclosingStatement = NO_SQLNODE;

        /* Get ready for next iteration */
        idxLeft = idxNew;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseExpression(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives an algebraic expression from the input stream and creates a    */
/* NODE_TYPE_ALGEBRAIC node                                                */
/*                                                                         */
/*    expression ::= expression + times | expression - times | times       */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxLeft;
    SQLNODEIDX idxRight;
    SQLNODEIDX idxNew;
    UWORD      op;

   /* Get start of expression */
    err = ParseTimes(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxLeft,
                     lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get the rest of the expression */
    while (TRUE) {

        /* Get + or - */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
        if (err != ERR_SUCCESS) {
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            *lpIdx = idxLeft;
            break;
        }
        else {
            if (!s_lstrcmpi(lpszToken, "-"))
                op = OP_MINUS;
            else if (!s_lstrcmpi(lpszToken, "+"))
                op = OP_PLUS;
            else {
                *lplpszSqlStr = old_lpszSqlStr;
                *pcbSqlStr = old_cbSqlStr;
                *lpIdx = idxLeft;
                break;
            }
        }

        /* Get right side */
        err = ParseTimes(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxRight,
                         lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Make two halves into a node */
        idxNew = AllocateNode(lplpSql, NODE_TYPE_ALGEBRAIC);
        if (idxNew == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, idxNew);
        lpSqlNode->node.algebraic.Operator = op;
        lpSqlNode->node.algebraic.Left = idxLeft;
        lpSqlNode->node.algebraic.Right = idxRight;
        lpSqlNode->node.algebraic.Value = NO_STRING;
        lpSqlNode->node.algebraic.WorkBuffer1 = NO_STRING;
        lpSqlNode->node.algebraic.WorkBuffer2 = NO_STRING;
        lpSqlNode->node.algebraic.WorkBuffer3 = NO_STRING;
        lpSqlNode->node.algebraic.DistinctOffset = 0;
        lpSqlNode->node.algebraic.DistinctLength = 0;
        lpSqlNode->node.algebraic.EnclosingStatement = NO_SQLNODE;

        /* Get ready for next iteration */
        idxLeft = idxNew;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParsePattern(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a pattern from the input stream and creates a                 */
/* NODE_TYPE_STRING, NODE_TYPE_PARAMETER, or NODE_TYPE_USER node          */
/*                                                                        */
/*    pattern ::= string | ? | USER                                       */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    STRINGIDX  idxString;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxParameter;
    UWORD      parameterId;

    /* Is it a string? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetString(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxString, lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  Is it a parameter */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "?", lpszToken);
        if (err != ERR_SUCCESS) {

            /* No.  Is it USER? */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "USER",
                             lpszToken);
            if (err != ERR_SUCCESS) {

                /* No. Error */
                return err;
            }
            else {

                /* Yes.  Make USER node */
                *lpIdx = AllocateNode(lplpSql, NODE_TYPE_USER);
                if (*lpIdx == NO_SQLNODE)
                    return ERR_MEMALLOCFAIL;
            }
        }
        else {

            /* Yes.  Make PARAMETER node */
            *lpIdx = AllocateNode(lplpSql, NODE_TYPE_PARAMETER);
            if (*lpIdx == NO_SQLNODE)
                return ERR_MEMALLOCFAIL;

            /* First parameter? */
            idxParameter = (*lplpSql)->node.root.parameters;
            if (idxParameter == NO_SQLNODE) {

                /* Yes.  Initialize list of parameters */
                (*lplpSql)->node.root.parameters = *lpIdx;
                lpSqlNode = ToNode(*lplpSql, *lpIdx);
                lpSqlNode->node.parameter.Id = 1;
            }
            else {

                /* No. Get last element of parameter list */
                while (TRUE) {
                    lpSqlNode = ToNode(*lplpSql, idxParameter);
                    idxParameter = lpSqlNode->node.parameter.Next;
                    if (idxParameter == NO_SQLNODE)
                        break;
                }

                /* Put node on list */
                lpSqlNode->node.parameter.Next = *lpIdx;

                /* Determine id of parameter */
                parameterId = lpSqlNode->node.parameter.Id + 1;
                lpSqlNode = ToNode(*lplpSql, *lpIdx);
                lpSqlNode->node.parameter.Id = parameterId;
            }
            lpSqlNode->node.parameter.Next = NO_SQLNODE;
            lpSqlNode->node.parameter.Value = NO_STRING;
            lpSqlNode->node.parameter.AtExec = FALSE;
        }
    
    }
    else {

        /* Yes.  Make STRING node */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_STRING);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.string.Value = idxString;
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseComparison(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a comparison expression from the input stream and creates a    */
/* NODE_TYPE_COMPARISON node                                               */
/*                                                                         */
/*    comparison ::= ( boolean ) | colref IS NULL | colref IS NOT NULL |   */
/*         expression LIKE pattern | expression NOT LIKE pattern |         */
/*         expression IN ( valuelist ) | expression NOT IN ( valuelist ) | */
/*         expression op expression | EXISTS ( SELECT select ) |           */
/*         expression op selectop ( SELECT select ) |                      */
/*         expression IN ( SELECT select ) |                               */
/*         expression NOT IN ( SELECT select )                             */
/*    op ::= > | >= | < | <= | = | <>                                      */
/*    selectop ::=  | ALL | ANY                                            */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxLeft;
    SQLNODEIDX idxRight;
    UWORD      op;
    UWORD      selectModifier;

    /* Is there a "("? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
    if (err == ERR_SUCCESS) {

        /* Yes. Return boolean */
        err = ParseBoolean(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, lpIdx,
                           lpszToken);

        /* Make sure closing ")" is there */
        if (err == ERR_SUCCESS)
            err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
    }
    if (err != ERR_SUCCESS) {

        /* Look for EXISTS predicate */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "EXISTS",
                             lpszToken);
        if (err == ERR_SUCCESS) {

            /* Found it.  Get opening "(" */
            err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
            if (err != ERR_SUCCESS)
                return err;

            /* Found it.  Get opening "SELECT" */
            err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "SELECT",
                             lpszToken);
            if (err != ERR_SUCCESS)
                return err;

            /* Get the sub-select */
            err = ParseSelect(lpstmt, lplpszSqlStr, pcbSqlStr,
                                          lplpSql, &idxLeft, lpszToken);
            if (err != ERR_SUCCESS)
                return err;

            /* Check for trailing ")" */
            err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
            if (err != ERR_SUCCESS)
                return err;

            /* Return EXISTS condition */
            op = OP_EXISTS;
            idxRight = NO_SQLNODE;
            selectModifier = SELECT_EXISTS;
        }
        else {

            /* Get left child */
            selectModifier = SELECT_NOTSELECT;
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            err = ParseExpression(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                                  &idxLeft, lpszToken);
            if (err != ERR_SUCCESS)
                return err;

            /* Is left child a column reference? */
            lpSqlNode = ToNode(*lplpSql, idxLeft);
            if (lpSqlNode->sqlNodeType == NODE_TYPE_COLUMN) {

                /* Is this an "IS NULL" or "IS NOT NULL"? */
                old_lpszSqlStr = *lplpszSqlStr;
                old_cbSqlStr = *pcbSqlStr;
                err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "IS",
                                 lpszToken);
                if (err == ERR_SUCCESS) {

                    /* Yes.  See which of the two it is */
                    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, NULL,
                                     lpszToken);
                    if (err != ERR_SUCCESS)
                        return err;

                    if (!s_lstrcmpi(lpszToken, "NOT")) {
                        op = OP_NE;
                        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr,
                                         NULL, lpszToken);
                        if (err != ERR_SUCCESS)
                            return err;
                    }
                    else
                        op = OP_EQ;

                    /* Error if missing keyword */
                    if (s_lstrcmpi(lpszToken, "NULL")) {
                        s_lstrcpy(lpstmt->szError, "NULL");
                        return ERR_EXPECTEDOTHER;
                    }

                    /* Create the value to compare it to */
                    idxRight = AllocateNode(lplpSql, NODE_TYPE_NULL);
                    if (idxRight == NO_SQLNODE)
                        return ERR_MEMALLOCFAIL;
                }
                else {

                    /* No. Set flag */
                    *lplpszSqlStr = old_lpszSqlStr;
                    *pcbSqlStr = old_cbSqlStr;
                    op = OP_NONE;
                }
            }
            else
                op = OP_NONE;

            /* Have we gotten the operator yet? */
            if (op == OP_NONE) {

                /* No.  Get it now. */
                old_lpszSqlStr = *lplpszSqlStr;
                old_cbSqlStr = *pcbSqlStr;
                err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, NULL,
                                lpszToken);

                /* Is the operator >, >=, <, <=, =, or <> ? */
                if (err == ERR_SUCCESS) {
                
                    /* Yes.  Figure out which one */
                    if (!s_lstrcmpi(lpszToken, ">"))
                        op = OP_GT;
                    else if (!s_lstrcmpi(lpszToken, ">="))
                        op = OP_GE;
                    else if (!s_lstrcmpi(lpszToken, "<"))
                        op = OP_LT;
                    else if (!s_lstrcmpi(lpszToken, "<="))
                        op = OP_LE;
                    else if (!s_lstrcmpi(lpszToken, "="))
                        op = OP_EQ;
                    else if (!s_lstrcmpi(lpszToken, "<>"))
                        op = OP_NE;
                    else {
                        s_lstrcpy(lpstmt->szError, "=, <>, <, <=, >, or >=");
                        return ERR_EXPECTEDOTHER;
                    }

                    /* ALL or ANY specified? */
                    old_lpszSqlStr = *lplpszSqlStr;
                    old_cbSqlStr = *pcbSqlStr;
                    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "ALL",
                                     lpszToken);
                    if (err != ERR_SUCCESS) {
                        *lplpszSqlStr = old_lpszSqlStr;
                        *pcbSqlStr = old_cbSqlStr;
                        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr,
                                         "ANY", lpszToken);
                        if (err != ERR_SUCCESS) {
                            *lplpszSqlStr = old_lpszSqlStr;
                            *pcbSqlStr = old_cbSqlStr;
                        }
                        else {
                            selectModifier = SELECT_ANY;
                        }
                    }
                    else {
                        selectModifier = SELECT_ALL;
                    }

                    /* Nested sub-select? */
                    old_lpszSqlStr = *lplpszSqlStr;
                    old_cbSqlStr = *pcbSqlStr;
                    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(",
                                    lpszToken);
                    if (err == ERR_SUCCESS) {
                        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr,
                                         "SELECT", lpszToken);
                        if (err == ERR_SUCCESS) {

                            /* Yes.  Get the sub-select */
                            err = ParseSelect(lpstmt, lplpszSqlStr, pcbSqlStr,
                                          lplpSql, &idxRight, lpszToken);
                            if (err != ERR_SUCCESS)
                                return err;

                            /* Check for trailing ")" */
                            err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr,
                                            ")", lpszToken);
                            if (err != ERR_SUCCESS)
                                return err;

                            /* Set selectModifier if not already set */
                            if (selectModifier == SELECT_NOTSELECT)
                                selectModifier = SELECT_ONE;
                        }
                        else {
                            *lplpszSqlStr = old_lpszSqlStr;
                            *pcbSqlStr = old_cbSqlStr;
                        }
                    }
                    else {
                        *lplpszSqlStr = old_lpszSqlStr;
                        *pcbSqlStr = old_cbSqlStr;
                    }
                
                    /* Get right child if not a nested sub-select */
                    if (selectModifier == SELECT_NOTSELECT) {
                        if (err != ERR_SUCCESS) {
                            err = ParseExpression(lpstmt, lplpszSqlStr,
                                   pcbSqlStr, lplpSql, &idxRight, lpszToken);
                            if (err != ERR_SUCCESS)
                                return err;
                        }
                    }
                }
                else {

                    /* No.  Maybe it is IN, NOT IN, LIKE, or NOT LIKE?  Get */ 
                    /* the keyword */
                    *lplpszSqlStr = old_lpszSqlStr;
                    *pcbSqlStr = old_cbSqlStr;
                    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, NULL,
                                     lpszToken);
                    if (err != ERR_SUCCESS)
                        return err;

                    /* Is the operator "NOT LIKE" or "NOT IN"? */
                    if (!s_lstrcmpi(lpszToken, "NOT")) {

                        /* Yes.  Figure out which one */
                        old_lpszSqlStr = *lplpszSqlStr;
                        old_cbSqlStr = *pcbSqlStr;
                        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr,
                                         "LIKE", lpszToken);
                        if (err != ERR_SUCCESS) {
                            *lplpszSqlStr = old_lpszSqlStr;
                            *pcbSqlStr = old_cbSqlStr;
                            err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr,
                                             "IN", lpszToken);
                            if (err != ERR_SUCCESS)
                                return err;
                            op = OP_NOTIN;
                        }
                        else
                            op = OP_NOTLIKE;
                    }

                    /* Is the operator "LIKE"? */
                    else if (!s_lstrcmpi(lpszToken, "LIKE")) {

                        /* Yes.  Operator is LIKE */
                        op = OP_LIKE;
                    }

                    /* Is the operator "IN"? */
                    else if (!s_lstrcmpi(lpszToken, "IN")) {

                        /* Yes.  Operator is IN */
                        op = OP_IN;
                    }
                    else {
                        s_lstrcpy(lpstmt->szError, "IN, NOT IN, LIKE, or NOT LIKE");
                        return ERR_EXPECTEDOTHER;
                    }

                    /* Get right argument */
                    switch (op) {
                    case OP_IN:
                    case OP_NOTIN:

                        /* Get opening paren */
                        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(",
                                          lpszToken);
                        if (err != ERR_SUCCESS)
                            return err;

                        /* Nested sub-select? */
                        old_lpszSqlStr = *lplpszSqlStr;
                        old_cbSqlStr = *pcbSqlStr;
                        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr,
                                         "SELECT", lpszToken);
                        if (err == ERR_SUCCESS) {

                            /* Yes.  Get the sub-select */
                            err = ParseSelect(lpstmt, lplpszSqlStr, pcbSqlStr,
                                      lplpSql, &idxRight, lpszToken);
                            if (err != ERR_SUCCESS)
                                return err;
                        }
                        else {

                            /* No.  Get valuelist */
                            *lplpszSqlStr = old_lpszSqlStr;
                            *pcbSqlStr = old_cbSqlStr;
                            err = ParseValuelist(lpstmt, lplpszSqlStr,
                                    pcbSqlStr, lplpSql, &idxRight, lpszToken);
                            if (err != ERR_SUCCESS)
                                return err;
                        }

                        /* Get closing paren */
                        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")",
                                      lpszToken);
                        if (err != ERR_SUCCESS)
                            return err;

                        break;

                    case OP_LIKE:
                    case OP_NOTLIKE:

                        /* Get pattern */
                        err = ParsePattern(lpstmt, lplpszSqlStr, pcbSqlStr,
                                           lplpSql, &idxRight, lpszToken);
                        if (err != ERR_SUCCESS)
                            return err;
                        break;

                    default:
                        return ERR_INTERNAL;
                    }
                }
            }
        }

        /* Create the COMPARISON node */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_COMPARISON);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.comparison.Operator = op;
        lpSqlNode->node.comparison.SelectModifier = selectModifier;
        lpSqlNode->node.comparison.Left = idxLeft;
        lpSqlNode->node.comparison.Right = idxRight;
        lpSqlNode->node.comparison.fSelectivity = 0;
        lpSqlNode->node.comparison.NextRestrict = NO_SQLNODE;
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseNot(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a NOT expression from the input stream and creates a           */
/* NODE_TYPE_BOOLEAN node                                                  */
/*                                                                         */
/* not ::= comparison | NOT comparison                                     */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxChild;

    /* Is there a "NOT"? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "NOT", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No. Return left child */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = ParseComparison(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, lpIdx,
                              lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }
    else {

        /* Yes.  Get right child */
        err = ParseComparison(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                              &idxChild, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the BOOLEAN node */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_BOOLEAN);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.boolean.Operator = OP_NOT;
        lpSqlNode->node.boolean.Left = idxChild;
        lpSqlNode->node.boolean.Right = NO_SQLNODE;
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseAnd(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives an AND expression from the input stream and creates a          */
/* NODE_TYPE_BOOLEAN node                                                  */
/*                                                                         */
/* and ::= not | not AND and                                               */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxLeft;
    SQLNODEIDX idxRight;

    /* Get left child */
    err = ParseNot(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxLeft,
                   lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Is there an "AND"? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "AND", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No. Return left child */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        *lpIdx = idxLeft;
    }
    else {

        /* Yes.  Get right child */
        err = ParseAnd(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxRight,
                              lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the BOOLEAN node */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_BOOLEAN);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.boolean.Operator = OP_AND;
        lpSqlNode->node.boolean.Left = idxLeft;
        lpSqlNode->node.boolean.Right = idxRight;
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseBoolean(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                             SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                             SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives an OR expression from the input stream and creates a           */
/* NODE_TYPE_BOOLEAN node                                                  */
/*                                                                         */
/* boolean ::= and | and OR boolean                                        */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxLeft;
    SQLNODEIDX idxRight;

    /* Get left child */
    err = ParseAnd(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxLeft,
                   lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Is there an "OR"? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "OR", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No. Return left child */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        *lpIdx = idxLeft;
    }
    else {

        /* Yes.  Get right child */
        err = ParseBoolean(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                           &idxRight, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the BOOLEAN node */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_BOOLEAN);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.boolean.Operator = OP_OR;
        lpSqlNode->node.boolean.Left = idxLeft;
        lpSqlNode->node.boolean.Right = idxRight;
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseWhere(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives an WHERE expression from the input stream and creates a        */
/* NODE_TYPE_BOOLEAN node                                                  */
/*                                                                         */
/* where ::=  | WHERE boolean                                              */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;

    /* Is there a "WHERE"? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "WHERE", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No. Return null */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        *lpIdx = NO_SQLNODE;
    }
    else {

        /* Yes.  Return boolean */
        err = ParseBoolean(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                           lpIdx, lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseHaving(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a HAVING expression from the input stream and creates a        */
/* NODE_TYPE_BOOLEAN node                                                  */
/*                                                                         */
/* having ::=  | HAVING boolean                                            */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;

    /* Is there a "HAVING"? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "HAVING", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No. Return null */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        *lpIdx = NO_SQLNODE;
    }
    else {

        /* Yes.  Return boolean */
        err = ParseBoolean(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                           lpIdx, lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseSelectlist(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a list of expressions from the input stream and creates a      */
/* NODE_TYPE_VALUES node                                                   */
/*                                                                         */
/* selectlist ::= selectlistitem , selectlist | selectlistitem             */
/* selectlistitem ::= expression | expression alias | aliasname . * | expression AS alias  */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxValues;
    SQLNODEIDX idxValue;
    STRINGIDX  idxAlias;
    SQLNODEIDX idxValuesPrev;

    /* Get list ofnodes */
    idxValuesPrev = NO_SQLNODE;
    while (TRUE) {

		/* Look for aliasname.* */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        idxValue = NO_SQLNODE;
        err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxAlias, lpszToken);
        if (err == ERR_SUCCESS) {
            err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ".", lpszToken);
            if (err == ERR_SUCCESS) {
                err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "*",
                                lpszToken);
            }
        }

		/* Find it? */
        if (err != ERR_SUCCESS) {

			/* Get expression */
			*lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
			err = ParseExpression(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
								  &idxValue, lpszToken);
			if (err != ERR_SUCCESS)
				return err;

			/* Is there an alias */
			old_lpszSqlStr = *lplpszSqlStr;
			old_cbSqlStr = *pcbSqlStr;
			err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "AS", lpszToken);
			if (err != ERR_SUCCESS) {
				*lplpszSqlStr = old_lpszSqlStr;
				*pcbSqlStr = old_cbSqlStr;
				err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
									&idxAlias, lpszToken);
				if (err != ERR_SUCCESS) {
					*lplpszSqlStr = old_lpszSqlStr;
					*pcbSqlStr = old_cbSqlStr;
					idxAlias = NO_STRING;
				}
			}
			else {
				err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
									&idxAlias, lpszToken);
				if (err != ERR_SUCCESS)
					return err;
			}

		}

        /* Create the VALUES node */
        idxValues = AllocateNode(lplpSql, NODE_TYPE_VALUES);
        if (idxValues == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, idxValues);
        lpSqlNode->node.values.Value = idxValue;
        lpSqlNode->node.values.Alias = idxAlias;
        lpSqlNode->node.values.Next = NO_SQLNODE;

        /* Put node on list */
        if (idxValuesPrev != NO_SQLNODE) {
            lpSqlNode = ToNode(*lplpSql, idxValuesPrev);
            lpSqlNode->node.values.Next = idxValues;
        }
        else
            *lpIdx = idxValues;
        idxValuesPrev = idxValues;

        /* Is there a comma? */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ",", lpszToken);
        if (err != ERR_SUCCESS) {

            /* No.  This is the last value */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            break;
        }
    }

    return ERR_SUCCESS;
}
/***************************************************************************/
RETCODE INTFUNC ParseSelectcols(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, BOOL FAR *lpfDistinct,
                      LPUSTR lpszToken)

/* Retrives a select list from the input stream and creates a              */
/* NODE_TYPE_VALUES node                                                   */
/*                                                                         */
/* selectcols ::= selectallcols * | selectallcols selectlist               */
/* selectallcols ::=  | ALL | DISTINCT                                     */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;

    /* See if ALL or DISTINCT is specified */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
    if (err == ERR_SUCCESS) {
        if (!s_lstrcmpi(lpszToken, "ALL"))
            *lpfDistinct = FALSE;
        else if (!s_lstrcmpi(lpszToken, "DISTINCT"))
            *lpfDistinct = TRUE;
        else {
            *lpfDistinct = FALSE;
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
        }
    }
    else {
        *lpfDistinct = FALSE;
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
    }

    /* Is '*' is specified? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "*", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  Get list of values */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = ParseSelectlist(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                              lpIdx, lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }
    else {
        *lpIdx = NO_SQLNODE;
    }
 
    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseColumn(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives an unqualified columnname from the input stream and creates a  */
/* NODE_TYPE_COLUMN node                                                   */
/*                                                                         */
/* column ::= columnname                                                   */

{
    LPSQLNODE lpSqlNode;
    STRINGIDX idxColumn;
    RETCODE err;

    /* Get the columnname */
    err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxColumn, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Create the COLUMN node */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_COLUMN);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdx);
    lpSqlNode->node.column.Tablealias = NO_STRING;
    lpSqlNode->node.column.Column = idxColumn;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseColumnlist(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a list of columnnames from the input stream and creates a      */
/* NODE_TYPE_COLUMNS node                                                  */
/*                                                                         */
/* columnlist ::= column , columnlist | column                             */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxColumns;
    SQLNODEIDX idxColumn;
    SQLNODEIDX idxColumnsPrev;

    /* Get list of nodes */
    idxColumnsPrev = NO_SQLNODE;
    while (TRUE) {

        /* Get columnname */
        err = ParseColumn(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                          &idxColumn, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the COLUMNS node */
        idxColumns = AllocateNode(lplpSql, NODE_TYPE_COLUMNS);
        if (idxColumns == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, idxColumns);
        lpSqlNode->node.columns.Column = idxColumn;
        lpSqlNode->node.columns.Next = NO_SQLNODE;

        /* Put node on list */
        if (idxColumnsPrev != NO_SQLNODE) {
            lpSqlNode = ToNode(*lplpSql, idxColumnsPrev);
            lpSqlNode->node.columns.Next = idxColumns;
        }
        else
            *lpIdx = idxColumns;
        idxColumnsPrev = idxColumns;

        /* Is there a comma? */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ",", lpszToken);
        if (err != ERR_SUCCESS) {

            /* No.  This is the last one */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            break;
        }
    }
    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseInsertvals(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdxColumns,
                      SQLNODEIDX FAR *lpIdxValues, LPUSTR lpszToken)

/* Retrives an INSERT statement from the input stream and creates a        */
/* NODE_TYPE_COLUMNS node and a NODE_TYPE_VALUES node                      */
/*                                                                         */
/* insertvals ::= ( columnlist ) VALUES ( valuelist ) |                    */
/*                ( columnlist ) VALUES ( SELECT select ) |                */
/*                VALUES ( valuelist ) | VALUES ( SELECT select )          */

{
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    RETCODE err;

    /* Is there a column list? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  Send null node back */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        *lpIdxColumns = NO_SQLNODE;
    }
    else {

        /* Yes.  Get the list */
        err = ParseColumnlist(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                          lpIdxColumns, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Error if no ending ')' */
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }

    /* Make sure keyword is given */
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "VALUES", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Error if no starting '(' */
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Sub-select? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "SELECT", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No.  Get the value list */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = ParseValuelist(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                             lpIdxValues, lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }
    else {

        /* Yes.  Get SELECT */
        err = ParseSelect(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                             lpIdxValues, lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }

    /* Error if no ending ')' */
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseSet(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives an update expressions from the input stream and creates a      */
/* NODE_TYPE_UPDATEVALUES node                                             */
/*                                                                         */
/* set ::= column = NULL | column = expression                             */

{
    LPSQLNODE lpSqlNode;
    SQLNODEIDX idxColumn;
    SQLNODEIDX idxValue;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    RETCODE err;

    /* Get the column name */
    err = ParseColumn(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxColumn,
                          lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get the '=' sign */
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "=", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* NULL specified? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "NULL", lpszToken);
    if (err != ERR_SUCCESS) {
    
        /* No.  Get value */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = ParseExpression(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                              &idxValue, lpszToken);
        if (err != ERR_SUCCESS)
            return err;
    }
    else {

        /* Yes.  Create a NULL node */
        idxValue = AllocateNode(lplpSql, NODE_TYPE_NULL);
        if (idxValue == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
    }

    /* Create the UPDATEVALUES node */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_UPDATEVALUES);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdx);
    lpSqlNode->node.updatevalues.Column = idxColumn;
    lpSqlNode->node.updatevalues.Value = idxValue;
    lpSqlNode->node.updatevalues.Next = NO_SQLNODE;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseSetlist(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a list of update expressions from the input stream and creates */
/* a NODE_TYPE_UPDATEVALUES node                                           */
/*                                                                         */
/* setlist ::= set , setlist | set                                         */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxUpdateValues;
    SQLNODEIDX idxUpdateValuesPrev;

    /* Get list of nodes */
    idxUpdateValuesPrev = NO_SQLNODE;
    while (TRUE) {

        /* Get update expression */
        err = ParseSet(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                       &idxUpdateValues, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Put node on list */
        if (idxUpdateValuesPrev != NO_SQLNODE) {
            lpSqlNode = ToNode(*lplpSql, idxUpdateValuesPrev);
            lpSqlNode->node.updatevalues.Next = idxUpdateValues;
        }
        else
            *lpIdx = idxUpdateValues;
        idxUpdateValuesPrev = idxUpdateValues;

        /* Is there a comma? */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ",", lpszToken);
        if (err != ERR_SUCCESS) {

            /* No.  This is the last update value */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            break;
        }
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseUpdate(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives an UPDATE statement from the input stream and creates a        */
/* NODE_TYPE_UPDATE node                                                   */
/*                                                                         */
/* update ::= table SET setlist where                                      */

{
    LPSQLNODE lpSqlNode;
    SQLNODEIDX idxTable;
    SQLNODEIDX idxUpdatevalues;
    SQLNODEIDX idxPredicate;
    RETCODE err;

    /* Get tablename */
    err = ParseTable(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxTable,
                     lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Make sure keyword is given */
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "SET", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get update values */
    err = ParseSetlist(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                          &idxUpdatevalues, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get predicate */
    err = ParseWhere(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxPredicate,
                          lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Create the UPDATE node */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_UPDATE);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdx);
    lpSqlNode->node.update.Table = idxTable;
    lpSqlNode->node.update.Updatevalues = idxUpdatevalues;
    lpSqlNode->node.update.Predicate = idxPredicate;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseInsert(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives an INSERT statement from the input stream and creates a        */
/* NODE_TYPE_INSERT node                                                   */
/*                                                                         */
/* insert ::= INTO table insertvals                                        */

{
    LPSQLNODE lpSqlNode;
    SQLNODEIDX idxTable;
    SQLNODEIDX idxColumns;
    SQLNODEIDX idxValues;
    RETCODE err;

    /* Make sure keyword is given */
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "INTO", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get table */
    err = ParseTable(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxTable,
                     lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get insert values */
    err = ParseInsertvals(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                          &idxColumns, &idxValues, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Create the INSERT node */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_INSERT);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdx);
    lpSqlNode->node.insert.Table = idxTable;
    lpSqlNode->node.insert.Columns = idxColumns;
    lpSqlNode->node.insert.Values = idxValues;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseDelete(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a DELETE statement from the input stream and creates a         */
/* NODE_TYPE_DELETE node                                                   */
/*                                                                         */
/* delete ::= FROM table where                                             */

{
    LPSQLNODE lpSqlNode;
    SQLNODEIDX idxTable;
    SQLNODEIDX idxPredicate;
    RETCODE err;

    /* Make sure "FROM" is specified */
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "FROM", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get table */
    err = ParseTable(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxTable,
                     lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get predicate */
    err = ParseWhere(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxPredicate,
                          lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Create the DELETE node */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_DELETE);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdx);
    lpSqlNode->node.delet.Table = idxTable;
    lpSqlNode->node.delet.Predicate = idxPredicate;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseSelect(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a SELECT statement from the input stream and creates a         */
/* NODE_TYPE_SELECT node                                                   */
/*                                                                         */
/* select ::= selectcols FROM tablelist where groupby having               */

{
    LPSQLNODE lpSqlNode;
    BOOL fDistinct;
    SQLNODEIDX idxValues;
    SQLNODEIDX idxTables;
    SQLNODEIDX idxPredicate;
    SQLNODEIDX idxGroupbycolumns;
    SQLNODEIDX idxHaving;
    RETCODE err;

    /* Get selection columns */
    err = ParseSelectcols(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                          &idxValues, &fDistinct, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Make sure "FROM" is specified */
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "FROM", lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get list of tables */
    err = ParseTablelist(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxTables,
                          lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get predicate */
    err = ParseWhere(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxPredicate,
                          lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get group by */
    err = ParseGroupby(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                       &idxGroupbycolumns, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get having */
    err = ParseHaving(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxHaving,
                          lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Create the SELECT node */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_SELECT);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdx);
    lpSqlNode->node.select.Distinct = fDistinct;
    lpSqlNode->node.select.Values = idxValues;
    lpSqlNode->node.select.Tables = idxTables;
    lpSqlNode->node.select.Predicate = idxPredicate;
    lpSqlNode->node.select.Groupbycolumns = idxGroupbycolumns;
    lpSqlNode->node.select.Having = idxHaving;
    lpSqlNode->node.select.Sortcolumns = NO_SQLNODE;
    lpSqlNode->node.select.SortDirective = NO_STRING;
    lpSqlNode->node.select.SortRecordsize = 0;
    lpSqlNode->node.select.SortBookmarks = 0;
    lpSqlNode->node.select.Aggregates = NO_SQLNODE;
    lpSqlNode->node.select.SortKeysize = 0;
    lpSqlNode->node.select.DistinctDirective = NO_STRING;
    lpSqlNode->node.select.DistinctRecordsize = 0;
    lpSqlNode->node.select.ImplicitGroupby = FALSE;
    lpSqlNode->node.select.EnclosingStatement = NO_SQLNODE;
    lpSqlNode->node.select.fPushdownSort = FALSE;
    lpSqlNode->node.select.fMSAccess = FALSE;
    lpSqlNode->node.select.RowCount = -1;
    lpSqlNode->node.select.CurrentRow = AFTER_LAST_ROW;
    lpSqlNode->node.select.SortfileName = NO_STRING;
    lpSqlNode->node.select.Sortfile = HFILE_ERROR;
    lpSqlNode->node.select.ReturningDistinct = FALSE;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseDrop(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a DROP TABLE statement from the input stream and creates a     */
/* NODE_TYPE_DROP node                                                     */
/*                                                                         */
/* drop ::= TABLE tablename | INDEX indexname                              */

{
    LPSQLNODE  lpSqlNode;
    STRINGIDX  idxIndexname;
    STRINGIDX  idxTablename;
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;

    /* Is an index being dropped? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "INDEX", lpszToken);
    if (err == ERR_SUCCESS) {

        /* Yes.  Get index name */
        err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxIndexname, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the DROPINDEX node */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_DROPINDEX);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.dropindex.Index = idxIndexname;
    }
    else {
    
        /* No.  Make sure a table is being dropped */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "TABLE", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Get the tablename */
        err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxTablename, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the DROP node */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_DROP);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.drop.Table = idxTablename;
   }
   return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseCreatecol(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a list of column defintiions from the input stream and creates */
/* a NODE_TYPE_CREATECOLS node                                             */
/*                                                                         */
/* createcol ::= columnname datatype | columnname datatype ( integer ) |   */
/*               columnname datatype ( integer , integer )                 */

{
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    STRINGIDX  idxName;
    STRINGIDX  idxType;
    UWORD      cParams;
    UDWORD     udParam1;
    UDWORD     udParam2;
    RETCODE    err;

    /* Get the columnname */
    err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxName, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get the type */
    err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxType, lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Are there any create parameters? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
    if (err != ERR_SUCCESS) {

        /* No. */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        cParams = 0;
        udParam1 = 0;
        udParam2 = 0;
    }
    else {

        /* Yes.  Get the first create param */
        cParams = 1;
        err = GetInteger(lpstmt, lplpszSqlStr, pcbSqlStr, &udParam1,
                         lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Get the next token */
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Is there a second create param */
        if (*lpszToken == ',') {

            /* Yes.  Get that one too */
            cParams = 2;
            err = GetInteger(lpstmt, lplpszSqlStr, pcbSqlStr, &udParam2,
                             lpszToken);
            if (err != ERR_SUCCESS)
                return err;

            /* Get the next token */
            err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
            if (err != ERR_SUCCESS)
                return err;
        }
        else
            udParam2 = 0;

        /* Error if terminating paren is missing */
        if (*lpszToken != ')') {
            s_lstrcpy(lpstmt->szError, ")");
            return ERR_EXPECTEDOTHER;
        }
    }

    /* Create the CREATECOLS node */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_CREATECOLS);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;
    lpSqlNode = ToNode(*lplpSql, *lpIdx);
    lpSqlNode->node.createcols.Name = idxName;
    lpSqlNode->node.createcols.Type = idxType;
    lpSqlNode->node.createcols.Params = cParams;
    lpSqlNode->node.createcols.Param1 = udParam1;
    lpSqlNode->node.createcols.Param2 = udParam2;
    lpSqlNode->node.createcols.Next = NO_SQLNODE;
    lpSqlNode->node.createcols.iSqlType = (UWORD) -1;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseCreatecols(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a list of column defintiions from the input stream and creates */
/* a NODE_TYPE_CREATECOLS node                                             */
/*                                                                         */
/* createcols ::= createcol , createcols | createcol                       */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    SQLNODEIDX idxCreateCols;
    SQLNODEIDX idxCreateColsPrev;

    /* Getlist of nodes */
    idxCreateColsPrev = NO_SQLNODE;
    while (TRUE) {

        /* Get create column */
        err = ParseCreatecol(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                             &idxCreateCols, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Put node on list */
        if (idxCreateColsPrev != NO_SQLNODE) {
            lpSqlNode = ToNode(*lplpSql, idxCreateColsPrev);
            lpSqlNode->node.createcols.Next = idxCreateCols;
        }
        else
            *lpIdx = idxCreateCols;
        idxCreateColsPrev = idxCreateCols;

        /* Is there a comma? */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ",", lpszToken);
        if (err != ERR_SUCCESS) {

            /* No.  This is the last create column */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            break;
        }
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParseIndexcolumn(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, BOOL FAR *lpfDescending,
                      LPUSTR lpszToken)

/* Retrives anindex column name from the input stream and creates a       */
/* NODE_TYPE_COLUMN node                                                  */
/*                                                                        */
/*    indexcolumn ::= column asc                                          */
/*    asc ::=  | ASC | DESC                                               */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;

    /* Get column name */
    err = ParseColumn(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, lpIdx,
                      lpszToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Get ASC or DESC */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, NULL, lpszToken);
    if (err != ERR_SUCCESS) {
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        *lpfDescending = FALSE;
    }
    else if (!s_lstrcmpi(lpszToken, "ASC")) {
        *lpfDescending = FALSE;
    }
    else if (!s_lstrcmpi(lpszToken, "DESC")) {
        *lpfDescending = TRUE;
    }
    else {
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        *lpfDescending = FALSE;
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseIndexcolumns(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a column list from the input stream and creates a             */
/* NODE_TYPE_SORTCOLUMNS node                                             */
/*                                                                        */
/*    indexcolumns ::= indexcolumn | indexcolumn , indexcolumns           */

{
    RETCODE    err;
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    BOOL       fDescending;
    SQLNODEIDX idxColumn;
    SQLNODEIDX idxSortcolumns;
    SQLNODEIDX idxSortcolumnsPrev;

    /* Get list of nodes */
    idxSortcolumnsPrev = NO_SQLNODE;
    while (TRUE) {

        /* Get indexcolumn column */
        err = ParseIndexcolumn(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                           &idxColumn, &fDescending, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the SORTCOLUMNS node */
        idxSortcolumns = AllocateNode(lplpSql, NODE_TYPE_SORTCOLUMNS);
        if (idxSortcolumns == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, idxSortcolumns);
        lpSqlNode->node.sortcolumns.Column = idxColumn;
        lpSqlNode->node.sortcolumns.Descending = fDescending;
        lpSqlNode->node.sortcolumns.Next = NO_SQLNODE;

        /* Put node on list */
        if (idxSortcolumnsPrev != NO_SQLNODE) {
            lpSqlNode = ToNode(*lplpSql, idxSortcolumnsPrev);
            lpSqlNode->node.sortcolumns.Next = idxSortcolumns;
        }
        else 
            *lpIdx = idxSortcolumns;
        idxSortcolumnsPrev = idxSortcolumns;

        /* Is there a comma? */
        old_lpszSqlStr = *lplpszSqlStr;
        old_cbSqlStr = *pcbSqlStr;
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ",", lpszToken);
        if (err != ERR_SUCCESS) {

            /* No.  This is the last indexcolumn */
            *lplpszSqlStr = old_lpszSqlStr;
            *pcbSqlStr = old_cbSqlStr;
            break;
        }
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ParseCreate(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a CREATE TABLE statement from the input stream and creates a   */
/* NODE_TYPE_CREATE or NODE_TYPE_CREATEINDEX node                          */
/*                                                                         */
/* create ::= TABLE tablename ( createcols ) |                             */
/*            INDEX indexname ON table ( indexcolumns )                    */
{
    LPUSTR     old_lpszSqlStr;
    SDWORD     old_cbSqlStr;
    LPSQLNODE  lpSqlNode;
    STRINGIDX  idxIndexname;
    RETCODE    err;
    STRINGIDX  idxTablename;
    SQLNODEIDX idxTable;
    SQLNODEIDX idxColumns;
    BOOL       fUnique;

    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "UNIQUE",
                     lpszToken);
    if (err == ERR_SUCCESS) {
        fUnique = TRUE;
    }
    else {
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        fUnique = FALSE;
    }

    /* Is an index being created? */
    old_lpszSqlStr = *lplpszSqlStr;
    old_cbSqlStr = *pcbSqlStr;
    err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "INDEX", lpszToken);
    if (err == ERR_SUCCESS) {

        /* Get index name */
        err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxIndexname, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Make sure "ON" is specified */
        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "ON", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Get the table */
        err = ParseTable(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql, &idxTable,
                     lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Get opening paren for column list */
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Get indexcolumns */
        err = ParseIndexcolumns(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                          &idxColumns, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Get closing paren for column list */
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the CREATEINDEX node */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_CREATEINDEX);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.createindex.Index = idxIndexname;
        lpSqlNode->node.createindex.Table = idxTable;
        lpSqlNode->node.createindex.Columns = idxColumns;
        lpSqlNode->node.createindex.Unique = fUnique;
    }
    else {
    
        /* No.  Make sure a table is being created */
        *lplpszSqlStr = old_lpszSqlStr;
        *pcbSqlStr = old_cbSqlStr;
        err = GetKeyword(lpstmt, lplpszSqlStr, pcbSqlStr, "TABLE", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

		/* Error if UNIQUE specified */
        if (fUnique) {
            s_lstrcpy(lpstmt->szError, "UNIQUE");
            return ERR_EXPECTEDOTHER;
        }

        /* Get the tablename */
        err = GetIdentifier(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                        &idxTablename, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Get opening paren for column descriptions */
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, "(", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Get the columnlist */
        err = ParseCreatecols(lpstmt, lplpszSqlStr, pcbSqlStr, lplpSql,
                     &idxColumns, lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Get closing paren for column descriptions */
        err = GetSymbol(lpstmt, lplpszSqlStr, pcbSqlStr, ")", lpszToken);
        if (err != ERR_SUCCESS)
            return err;

        /* Create the CREATE node */
        *lpIdx = AllocateNode(lplpSql, NODE_TYPE_CREATE);
        if (*lpIdx == NO_SQLNODE)
            return ERR_MEMALLOCFAIL;
        lpSqlNode = ToNode(*lplpSql, *lpIdx);
        lpSqlNode->node.create.Table = idxTablename;
        lpSqlNode->node.create.Columns = idxColumns;
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ParsePassthrough(LPSTMT lpstmt, LPUSTR FAR *lplpszSqlStr,
                      SDWORD FAR *pcbSqlStr, LPSQLTREE FAR *lplpSql,
                      SQLNODEIDX FAR *lpIdx, LPUSTR lpszToken)

/* Retrives a "SQL" statement from the input stream and creates a          */
/* NODE_TYPE_PASSTHROUGH node                                              */
/*                                                                         */
/* passthrough ::=                                                         */

{
    /* Create the PASSTHROUGH node */
    *lpIdx = AllocateNode(lplpSql, NODE_TYPE_PASSTHROUGH);
    if (*lpIdx == NO_SQLNODE)
        return ERR_MEMALLOCFAIL;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC Parse(LPSTMT lpstmt, LPISAM lpISAM, LPUSTR lpszSqlStr,
                      SDWORD cbSqlStr, LPSQLTREE FAR *lplpSql)

/* Parses an SQL statement and returns a parse tree.  The parse tree is    */
/* stored in an array of nodes.  The root of the tree is in node 0.        */
/* String values (such as table names) are not stored in the parse tree,   */
/* instead they are stored in a "string area".  The parse tree array is    */
/* returned in lplpSql.  A pointer to the "string area" is returned in the */
/* root of the parse tree.  The user must call FreeTree() to deallocate    */
/* the space pointed to by lplpSql.                                        */
/*                                                                         */
/* statement ::= CREATE create | DROP drop | SELECT select orderby |       */ 
/*               INSERT insert | DELETE delete | UPDATE update | SQL       */

{
    LPSQLTREE lpSql;
    HGLOBAL hParseArray;
    UCHAR szToken[MAX_TOKEN_SIZE + 1];
    RETCODE err;
    SQLNODEIDX idxRoot;
    UWORD     fType;
    SQLNODEIDX idxSortcolumns;

    /* Get first token */
    err = GetKeyword(lpstmt, &lpszSqlStr, &cbSqlStr, NULL, szToken);
    if (err != ERR_SUCCESS)
        return err;

    /* Allocate initial space */
    hParseArray = GlobalAlloc(GMEM_MOVEABLE,
                                  sizeof(SQLNODE) * SQLNODE_ALLOC);
    if (hParseArray == NULL)
        return ERR_MEMALLOCFAIL;
    lpSql = (LPSQLTREE) GlobalLock(hParseArray);
    if (lpSql == NULL) {
        GlobalFree(hParseArray);
        return ERR_MEMALLOCFAIL;
    }

    /* Initialize the root node */
    lpSql->sqlNodeType = NODE_TYPE_ROOT;
    lpSql->node.root.lpISAM = lpISAM;
    lpSql->node.root.hParseArray = hParseArray;
    lpSql->node.root.cParseArray = SQLNODE_ALLOC;
    lpSql->node.root.iParseArray = 0;
    lpSql->node.root.hStringArea = NULL;
    lpSql->node.root.lpStringArea = NULL;
    lpSql->node.root.cbStringArea = 0;
    lpSql->node.root.ibStringArea = -1;
    lpSql->node.root.sql = NO_SQLNODE;
    lpSql->node.root.parameters = NO_SQLNODE;
    lpSql->node.root.passthroughParams = FALSE;

    /* Parse statement */
    if (!s_lstrcmpi(szToken, "CREATE")) {
        err = ERR_CREATE_NOTSUPP;
//        err = ParseCreate(lpstmt, &lpszSqlStr, &cbSqlStr, &lpSql, &idxRoot,
//                          szToken);
    }
    else if (!s_lstrcmpi(szToken, "DROP")) {
        err = ERR_DROP_NOTSUPP;
//        err = ParseDrop(lpstmt, &lpszSqlStr, &cbSqlStr, &lpSql, &idxRoot,
//                        szToken);
    }
    else if (!s_lstrcmpi(szToken, "SELECT")) {
        err = ParseSelect(lpstmt, &lpszSqlStr, &cbSqlStr, &lpSql, &idxRoot,
                          szToken);
        if (err == ERR_SUCCESS) {
            err = ParseOrderby(lpstmt, &lpszSqlStr, &cbSqlStr, &lpSql,
                               &idxSortcolumns, szToken);
            if (idxSortcolumns != NO_SQLNODE) {
                ToNode(lpSql, idxRoot)->node.select.Sortcolumns =
                                                            idxSortcolumns;
            }
        }
    }
    else if (!s_lstrcmpi(szToken, "INSERT")) {
        err = ERR_INSERT_NOTSUPP;
//        err = ParseInsert(lpstmt, &lpszSqlStr, &cbSqlStr, &lpSql, &idxRoot,
//                          szToken);
    }
    else if (!s_lstrcmpi(szToken, "DELETE")) {
        err = ERR_DELETE_NOTSUPP;
//        err = ParseDelete(lpstmt, &lpszSqlStr, &cbSqlStr, &lpSql, &idxRoot,
//                          szToken);
    }
    else if (!s_lstrcmpi(szToken, "UPDATE")) {
        err = ERR_UPDATE_NOTSUPP;
//        err = ParseUpdate(lpstmt, &lpszSqlStr, &cbSqlStr, &lpSql, &idxRoot,
//                          szToken);
    }
    else if (!s_lstrcmpi(szToken, "SQL")) {
		//Sai Wong
//      err = ERR_NOTSUPPORTED;
        err = ParsePassthrough(lpstmt, &lpszSqlStr, &cbSqlStr, &lpSql,
                               &idxRoot, szToken);
    }
	else if (!lstrcmpi((char*)szToken, "ALTER")) {
		//Dr. DeeBee Driver does not cater for this command
		  err = ERR_ALTER_NOTSUPP;
    }
	else if (!lstrcmpi((char*)szToken, "GRANT")) {
		//Dr. DeeBee Driver does not cater for this command
		  err = ERR_GRANT_NOTSUPP;
    }
	else if (!lstrcmpi((char*)szToken, "REVOKE")) {
		//Dr. DeeBee Driver does not cater for this command
		  err = ERR_REVOKE_NOTSUPP;
    }
    else {
        s_lstrcpy(lpstmt->szError, "CREATE, DROP, SELECT, INSERT, UPDATE, or DELETE");
        err = ERR_EXPECTEDOTHER;
    }
    if (err != ERR_SUCCESS) {
        FreeTree(lpSql);
        return err;
    }

    /* Error if any unused tokens */
    err = GetToken(lpstmt, lpszSqlStr, cbSqlStr, szToken, &fType,
                  &lpszSqlStr, &cbSqlStr);
    if (err != ERR_SUCCESS) {
        FreeTree(lpSql);
        return err;
    }
    if (fType != TOKEN_TYPE_NONE) {
        FreeTree(lpSql);
        s_lstrcpy(lpstmt->szError, szToken);
        return ERR_UNEXPECTEDTOKEN;
    }

    /* Fill in the root node */
    lpSql->node.root.sql = idxRoot;

    *lplpSql = lpSql;
    return ERR_SUCCESS;
}

/***************************************************************************/

//Generates string for a comparision expression
//The input parameters are the left and right values to compare and
//the comparision operator
void PredicateParser :: GenerateComparisonString(char* lpLeftString, char* lpRightString, UWORD wOperator, UWORD wSelectModifier, char** lpOutputStr)
{
	*lpOutputStr = NULL;

	//Check for valid parameters
	if ( !lpLeftString || !lpRightString)
		return;

	//Lengths of strings
	ULONG cLeftLen = lstrlen(lpLeftString);
	ULONG cRightLen = lstrlen(lpRightString);
	ULONG cOperatorLen = 0;

	char* selectop = NULL;

	//OK get the operator string
	char* lpOperatorStr = NULL;
	switch (wOperator)
	{
	case OP_EQ:
		lpOperatorStr = "=";
		break;
	case OP_NE:
		lpOperatorStr = "<>";
		break;
	case OP_LE:
		lpOperatorStr = "<=";
		break;
	case OP_LT:
		lpOperatorStr = "<";
		break;
	case OP_GE:
		lpOperatorStr = ">=";
		break;
	case OP_GT:
		lpOperatorStr = ">";
		break;
	case OP_LIKE:
		lpOperatorStr = "LIKE";
		break;
	case OP_NOTLIKE:
		lpOperatorStr = "NOT LIKE";
		break;
	case OP_IN:
		lpOperatorStr = "IN";
		break;
	case OP_NOTIN:
		lpOperatorStr = "NOT IN";
		break;
	default:
		//error
		return;
		break;
	}

	if (lpOperatorStr)
		cOperatorLen = lstrlen (lpOperatorStr);

	//Double check for sub-select
	if ( (wSelectModifier == SELECT_ALL) || (wSelectModifier == SELECT_ANY) )
	{
		if ( (wOperator != OP_IN) && (wOperator != OP_NOTIN) )
		{
			switch (wSelectModifier)
			{
			case SELECT_ALL:
				selectop = "ALL";
				cOperatorLen += 5;
				break;
			case SELECT_ANY:
				selectop = "ANY";
				cOperatorLen += 5;
				break;
			default:
				break;
			}
		}
	}


	//Generate output string in the format 
	//   ( left operator right )
	(*lpOutputStr) = new char [cLeftLen + cRightLen + cOperatorLen + 5];
	(*lpOutputStr)[0] = 0;

	if (selectop)
	{
		sprintf (*lpOutputStr, "(%s %s %s %s)", lpLeftString, lpOperatorStr, selectop, lpRightString);
	}
	else
	{
		sprintf (*lpOutputStr, "(%s %s %s)", lpLeftString, lpOperatorStr, lpRightString);
	}
}

//Generates string for a boolean expression
//The input parameters are the left and right values of the boolean and
//the boolean operator
void PredicateParser :: GenerateBooleanString(char* lpLeftString, char* lpRightString, UWORD wOperator, char** lpOutputStr)
{
	*lpOutputStr = NULL;

	//Check for valid parameters
	if ( !lpLeftString || !lpRightString)
		return;

	//Lengths of strings
	ULONG cLeftLen = lstrlen(lpLeftString);
	ULONG cRightLen = lstrlen(lpRightString);
	ULONG cOperatorLen = 0;

	//OK get the operator string
	char* lpOperatorStr = NULL;
	switch (wOperator)
	{
	case OP_NOT:
		lpOperatorStr = "NOT";
		break;
	case OP_AND:
		lpOperatorStr = "AND";
		break;
	case OP_OR:
		lpOperatorStr = "OR";
		break;
	default:
		//error
		return;
		break;
	}

	if (lpOperatorStr)
		cOperatorLen = lstrlen (lpOperatorStr);

	//Generate output string
	if (wOperator != OP_NOT)
	{
		//Format of output string
		//   ( left operator right )
		(*lpOutputStr) = new char [cLeftLen + cRightLen + cOperatorLen + 5];
		(*lpOutputStr)[0] = 0;
		sprintf (*lpOutputStr, "(%s %s %s)", lpLeftString, lpOperatorStr, lpRightString);
	}
	else
	{
		//Format of output string
		//   ( operator left )
		(*lpOutputStr) = new char [cLeftLen + cOperatorLen + 4];
		(*lpOutputStr)[0] = 0;
		sprintf (*lpOutputStr, "(%s %s)", lpOperatorStr, lpLeftString);
	}
}

//Generates string for an aggregate expression
//The input parameters are the expression and
//the operator
void PredicateParser :: GenerateAggregateString(char* lpLeftString, UWORD wOperator, char** lpOutputStr)
{
	*lpOutputStr = NULL;

	//Check for valid parameters
	if ( !lpLeftString)
		return;

	//Lengths of strings
	ULONG cLeftLen = lstrlen(lpLeftString);
	ULONG cOperatorLen = 0;

	//OK get the operator string
	char* lpOperatorStr = NULL;
	switch (wOperator)
	{
	case AGG_AVG:
		lpOperatorStr = "AVG";
		break;
	case AGG_COUNT:
		lpOperatorStr = "COUNT";
		break;
	case AGG_MAX:
		lpOperatorStr = "MAX";
		break;
	case AGG_MIN:
		lpOperatorStr = "MIN";
		break;
	case AGG_SUM:
		lpOperatorStr = "SUM";
		break;
	default:
		//error
		return;
		break;
	}

	if (lpOperatorStr)
		cOperatorLen = lstrlen (lpOperatorStr);

	//Generate output string in the format 
	//   operator(left)
	(*lpOutputStr) = new char [cLeftLen + cOperatorLen + 3];
	(*lpOutputStr)[0] = 0;
	sprintf (*lpOutputStr, "%s(%s)", lpOperatorStr, lpLeftString);
}

//Generates string for a algebraic expression
//The input parameters are the left and right values and
//the algebraic operator
void PredicateParser :: GenerateAlgebraicString(char* lpLeftString, char* lpRightString, UWORD wOperator, char** lpOutputStr)
{
	*lpOutputStr = NULL;

	//Check for valid parameters
	if ( !lpLeftString)
		return;

	//Lengths of strings
	ULONG cLeftLen = lstrlen(lpLeftString);
	ULONG cRightLen = lstrlen(lpRightString);
	ULONG cOperatorLen = 0;

	//OK get the operator string
	char* lpOperatorStr = NULL;
	switch (wOperator)
	{
	case OP_PLUS:
	case OP_NONE:
		lpOperatorStr = "+";
		break;
	case OP_MINUS:
	case OP_NEG:
		lpOperatorStr = "-";
		break;
	case OP_TIMES:
		lpOperatorStr = "*";
		break;
	case OP_DIVIDEDBY:
		lpOperatorStr = "/";
		break;
	default:
		//error
		return;
		break;
	}

	if (lpOperatorStr)
		cOperatorLen = lstrlen (lpOperatorStr);

	//Generate output string in the format
	
	if (wOperator != OP_NEG)
	{
		if (!cRightLen)
			//error
			return;

		//   (left operator right)
		(*lpOutputStr) = new char [cLeftLen + cRightLen + cOperatorLen + 5];
		(*lpOutputStr)[0] = 0;
		sprintf (*lpOutputStr, "(%s %s %s)", lpLeftString, lpOperatorStr, lpRightString);
	}
	else
	{
		//   (operator left)
		(*lpOutputStr) = new char [cLeftLen + cOperatorLen + 4];
		(*lpOutputStr)[0] = 0;
		sprintf (*lpOutputStr, "(%s %s)", lpOperatorStr, lpLeftString);
	}
}

//Generates WHERE predicate string from NODE tree
void PredicateParser :: GeneratePredicateString(LPSQLNODE lpSqlNode, char ** lpOutputStr, BOOL fIsSQL89)
{
	*lpOutputStr = NULL;

	char* lpLeftString = NULL;
	char* lpRightString = NULL;

	//Now find out what type of node we have reached
	switch (lpSqlNode->sqlNodeType)
	{
	case NODE_TYPE_BOOLEAN:
	{
		//Get the predicate string for the left node
		GeneratePredicateString(ToNode(*lplpSql,lpSqlNode->node.boolean.Left), &lpLeftString, fIsSQL89);

		//Get the predicate string for the right node, if it exists
		if (lpSqlNode->node.boolean.Right != NO_SQLNODE)
		{
			GeneratePredicateString(ToNode(*lplpSql,lpSqlNode->node.boolean.Right), &lpRightString, fIsSQL89);
		}
		else
		{
			//return a blank dummy string
			char* lpTemp = "<blank>";
			lpRightString = new char [lstrlen(lpTemp) + 1];
			lpRightString[0] = 0;
			lstrcpy(lpRightString, lpTemp);
		}
		//If both the left and the right string are non-NULL generate the
		//boolean string, else just return the string which is non-null
		UWORD wOperator = lpSqlNode->node.boolean.Operator;
		if (lpLeftString && lpRightString)
		{
			//Generate comparison string
			GenerateBooleanString(lpLeftString, lpRightString, wOperator, lpOutputStr);
			
			//Tidy up
			delete lpLeftString;
			delete lpRightString;
		}
		else
		{
			if (wOperator != OP_OR)
			{
				if (lpLeftString)
				{
					//Must be non-NULL
					(*lpOutputStr) = lpLeftString;
				}
				else
				{
					//Can be non-NULL or NULL
					(*lpOutputStr) = lpRightString;
				}
			}
			else
			{
				(*lpOutputStr) = NULL;
			}
		}
	}
		break;
	case NODE_TYPE_SELECT:
	{
		//Sub-SELECT statement
		char* fullWQL = NULL;
		TableColumnInfo subSelect (lplpSql, &lpSqlNode, WQL_MULTI_TABLE);
		subSelect.BuildFullWQL(&fullWQL);
		*lpOutputStr = fullWQL;

		if (fullWQL)
		{
			int wqlLen = lstrlen(fullWQL);
			char* modStr = new char [2 + wqlLen + 1];
			modStr[0] = 0;
			sprintf (modStr, "(%s)", fullWQL);
			*lpOutputStr = modStr;
			delete fullWQL;
		}
	}
		break;
	case NODE_TYPE_COMPARISON:
	{
		//Get the predicate string for the left node
		GeneratePredicateString(ToNode(*lplpSql,lpSqlNode->node.comparison.Left), &lpLeftString, fIsSQL89);

		//Get the predicate string for the right node
		GeneratePredicateString(ToNode(*lplpSql,lpSqlNode->node.comparison.Right), &lpRightString, fIsSQL89);

		//If both the left and the right string are non-NULL generate the
		//comparison string, else return error

		UWORD wSelectModifier = lpSqlNode->node.comparison.SelectModifier;

		if (lpLeftString && lpRightString)
		{
			//Generate comparison string
			UWORD wOperator = lpSqlNode->node.comparison.Operator;	

			//For the ALPHA drop we disable HMM Level 1 optimazation for 
			//SQL queries which contain "LIKE" or "NOT LIKE" with wildcards
			BOOL fError = FALSE;

			if (!fSupportLIKEs)
			{
				if ( (wOperator == OP_LIKE) || (wOperator == OP_NOTLIKE) )
				{
					(*lpOutputStr) = NULL;
					fError = TRUE;
/*
					//Check for wildcards etc ...  "%" or "_"
					char* pt = lpRightString;
					long i = 0;
					
					while (pt[i] && !fError)
					{
						switch (pt[i])
						{
						case '%':
							{
								//Wilcard detected, abort
								(*lpOutputStr) = NULL;
								fError = TRUE;
							}
							break;
						case '_':
							{
								//Check if it has been escaped
								if (i && (pt[i - 1] == '\\'))
								{
									//OK
								}
								else
								{
									(*lpOutputStr) = NULL;
									fError = TRUE;
								}
							}
							break;
						default:
							break;
						}
						i++;
					}
*/
				}
			}

			if (!fError)
				GenerateComparisonString(lpLeftString, lpRightString, wOperator, wSelectModifier, lpOutputStr);		
		}
		else
		{

			//Check for sub select

			if ( lpLeftString && (wSelectModifier == SELECT_EXISTS) )
			{
				fError = FALSE;
				int selectLen = lstrlen (lpLeftString);
				(*lpOutputStr) = new char [7 + selectLen + 1];
				(*lpOutputStr)[0] = 0;
				sprintf (*lpOutputStr, "EXISTS %s", lpLeftString);
			}
			else
			{
				//error
				(*lpOutputStr) = NULL;
			}
		}

		//Tidy up
		delete lpLeftString;
		delete lpRightString;

	}
		break;
	case NODE_TYPE_SCALAR:
	{
		//WQL does not support scalar functions
		char* myString = ",SomeScalarFunctionThatWQLDoesNotSupport";
		ULONG len = lstrlen(myString);
		(*lpOutputStr) = new char [len + 1];
		(*lpOutputStr)[0] = 0;
		lstrcpy(*lpOutputStr, myString);
	}
		break;
	case NODE_TYPE_AGGREGATE:
	{
		//Get the predicate string for the expression node
		GeneratePredicateString(ToNode(*lplpSql,lpSqlNode->node.aggregate.Expression), &lpLeftString, fIsSQL89);

		//If the left string is non-NULL generate the
		//aggregate string, else return error
		if (lpLeftString)
		{
			//Generate aggregate string
			UWORD wOperator = lpSqlNode->node.aggregate.Operator;
			GenerateAggregateString(lpLeftString, wOperator, lpOutputStr);	
		}
		else
		{
			//error
			(*lpOutputStr) = NULL;
		}

		//Tidy up
		delete lpLeftString;
	}
		break;
	case NODE_TYPE_ALGEBRAIC:
	{
		//Get the predicate string for the left node
		GeneratePredicateString(ToNode(*lplpSql,lpSqlNode->node.algebraic.Left), &lpLeftString, fIsSQL89);

		//Get the predicate string for the right node
		if (lpSqlNode->node.algebraic.Right != NO_SQLNODE)
			GeneratePredicateString(ToNode(*lplpSql,lpSqlNode->node.algebraic.Right), &lpRightString, fIsSQL89);
		else
			lpRightString = NULL;

		//If the left string is non-NULL generate the
		//comparison string, else return error
		if (lpLeftString)
		{
			//Generate algebraic string
			UWORD wOperator = lpSqlNode->node.algebraic.Operator;
			GenerateAlgebraicString(lpLeftString, lpRightString, wOperator, lpOutputStr);	
		}
		else
		{
			//error
			(*lpOutputStr) = NULL;
		}

		//Tidy up
		delete lpLeftString;
		delete lpRightString;
	}
		break;
	case NODE_TYPE_COLUMN:
	{
		//Return a copy of the column name
		char* lpTemp  = (LPSTR) ToString(*lplpSql, lpSqlNode->node.column.Column);
		char* lpAlias = NULL;
		SQLNODEIDX  idxTblAlias	= lpSqlNode->node.column.Tablealias;
		
		if (idxTblAlias != NO_STRING)
		{
			lpAlias = (LPSTR) ToString(*lplpSql, idxTblAlias);
		}

		//Sai new
		SQLNODEIDX	idxTbl = lpSqlNode->node.column.Table;
		LPSQLNODE   myTableNode = ToNode(*lplpSql,idxTbl);		
		LPISAMTABLEDEF lpTDef = NULL;
		
		if (idxTbl != NO_SQLNODE)
			lpTDef = myTableNode->node.table.Handle;

		//Sai Wong Here
//		if (lpISAMTableDef == lpSqlNode->node.table.Handle)
		if ((!lpISAMTableDef) || (lpISAMTableDef == lpTDef))
		{
			ULONG len = lstrlen(lpTemp);

			if (lpAlias && !fIsSQL89)
			{
				len += lstrlen(lpAlias) + 1;
			}

			(*lpOutputStr) = new char [len + 1];
			(*lpOutputStr)[0] = 0;

			if (lpAlias && !fIsSQL89)
			{
				sprintf(*lpOutputStr, "%s.%s",lpAlias, lpTemp);
			}
			else
			{
				lstrcpy(*lpOutputStr, lpTemp);
			}
		}
		else
		{
			//no match with desired table so return NULL
			(*lpOutputStr) = NULL;
		}	
		
	}
		break;
	case NODE_TYPE_STRING:
	{
		//Return a copy of the String in the format shown below
		//           'string'
		char* lpTemp  = (LPSTR)ToString(*lplpSql, lpSqlNode->node.string.Value);
		(*lpOutputStr) = new char [lstrlen(lpTemp) + 3];
		(*lpOutputStr)[0] = 0;
		sprintf (*lpOutputStr, "'%s'", lpTemp);
	}
		break;
	case NODE_TYPE_TIMESTAMP:
	{
		//Return a copy of the Timestamp in UTC format shown below
		//           'yyyymmddhhmmss.000000+000'
		TIMESTAMP_STRUCT lpTimestamp  = lpSqlNode->node.timestamp.Value;
		(*lpOutputStr) = new char [DATETIME_FORMAT_LEN + 4 + 1 + 2];
		(*lpOutputStr)[0] = 0;
		sprintf (*lpOutputStr, "'%04d%02u%02u%02u%02u%02u.%06d+000'", 
			lpTimestamp.year, lpTimestamp.month, lpTimestamp.day,
             lpTimestamp.hour, lpTimestamp.minute, lpTimestamp.second,
             lpTimestamp.fraction);
	}
		break;
	case NODE_TYPE_VALUES:
	{		
		
		SQLNODEIDX idxValue = lpSqlNode->node.values.Value;
		SQLNODEIDX idxValues = lpSqlNode->node.values.Next;
		LPSQLNODE  lpSqlNextNode;

		ULONG cLenLeft = 0;
		ULONG cLenOutput = 0;
		ULONG cLenBuff = 0;
	
		*lpOutputStr = NULL;
		
		BOOL firstTime = TRUE;
		BOOL fEndOfList = FALSE;
		char* buff = NULL;
		do
		{
			//Get next value in valuelist
			GeneratePredicateString(ToNode(*lplpSql,idxValue), &lpLeftString, fIsSQL89);

			//Add to list
			cLenOutput = (*lpOutputStr) ? lstrlen (*lpOutputStr) : 0;
			cLenLeft = lpLeftString ? lstrlen (lpLeftString) : 0;
			cLenBuff = cLenOutput + cLenLeft;

			//Check for errors
			if (cLenLeft == 0)
			{
				//error
				delete (*lpOutputStr);
				*lpOutputStr = NULL;
				return;
			}

			buff = new char [cLenBuff + 2];
			buff[0] = 0;
			if (firstTime)
			{	
				sprintf (buff, "(%s", lpLeftString);
			}
			else
			{
				sprintf (buff, "%s,%s", *lpOutputStr, lpLeftString);
			}

			//Update output string and tidy up
			delete (*lpOutputStr);
			delete lpLeftString;
			*lpOutputStr = buff;

			//Increment for next loop
			if (idxValues != NO_SQLNODE)
			{
				lpSqlNextNode = ToNode(*lplpSql,idxValues);
				idxValue = lpSqlNextNode->node.values.Value;
				idxValues = lpSqlNextNode->node.values.Next;
			}
			else
			{
				fEndOfList = TRUE;
			}
			
			firstTime = FALSE;
		} 
		while (!fEndOfList);
			
		//Now add closing bracket
		cLenOutput = lstrlen (*lpOutputStr);
		buff = new char [cLenOutput + 2];
		buff[0] = 0;
		sprintf(buff, "%s)", *lpOutputStr);
		delete (*lpOutputStr);
		*lpOutputStr = buff;
	}
		break;
	case NODE_TYPE_NUMERIC:
	{
		//Return a copy of the number (as a string)
		char* lpTemp = (LPSTR) ToString(*lplpSql, lpSqlNode->node.numeric.Numeric);
		(*lpOutputStr) = new char [lstrlen(lpTemp) + 1];
		(*lpOutputStr)[0] = 0;
		lstrcpy(*lpOutputStr, lpTemp);
	}
		break;
	case NODE_TYPE_PARAMETER:
		break;
	case NODE_TYPE_USER:
	{
		char* lpTemp = "USER";
		(*lpOutputStr) = new char [lstrlen(lpTemp) + 1];
		(*lpOutputStr)[0] = 0;
		lstrcpy(*lpOutputStr, lpTemp);
	}
		break;
	case NODE_TYPE_NULL:
	{
		char* lpTemp = "NULL";
		(*lpOutputStr) = new char [lstrlen(lpTemp) + 1];
		(*lpOutputStr)[0] = 0;
		lstrcpy(*lpOutputStr, lpTemp);
	}
		break;
	default:
	{
		//Error, could not recognize node
		fError = TRUE;
		*lpOutputStr = NULL;
	}
		break;
	}

	//If an error occured return a NULL output string
	if (fError)
	{
		if (*lpOutputStr)
			delete (*lpOutputStr);

		(*lpOutputStr) = NULL;
	}
}

//Generates ORDER BY string from NODE tree
void PredicateParser :: GenerateOrderByString(LPSQLNODE lpSqlNode, char ** lpOutputStr, BOOL fIsSQL89)
{
	BOOL fContinue = TRUE;
	BOOL fFirst = TRUE;
	LPSQLNODE newNode = NULL;
	while (fContinue)
	{
		char* columnRef = NULL;
		LPSQLNODE   myNode = ToNode(*lplpSql,lpSqlNode->node.sortcolumns.Column);
		BOOL fDescending = lpSqlNode->node.sortcolumns.Descending;

		ULONG len3 = 0;
		char* sortOrder = "";

		if (fDescending)
		{
			sortOrder = " DESC";
			len3 = lstrlen(sortOrder);
		}

		GenerateColumnRef(myNode, &columnRef, fIsSQL89);

		if (columnRef)
		{
			ULONG len1 = s_lstrlen(*lpOutputStr);

			if (!fFirst)
			{
				//add a comma separator and column ref
				ULONG len2 = s_lstrlen(columnRef) + 1;
				char* buffer = new char [len1 + len2 + len3 + 1];
				buffer[0] = 0;

				//Add new column to end of list
				if (len3)
					sprintf (buffer, "%s,%s%s", *lpOutputStr, columnRef, sortOrder);
				else
					sprintf (buffer, "%s,%s", *lpOutputStr, columnRef);

				delete (*lpOutputStr);
				delete columnRef;
				*lpOutputStr = buffer;
			}
			else
			{
				//add column ref
				if (len3)
				{
					ULONG len2 = s_lstrlen(columnRef);
					char* buffer = new char [len2 + len3 + 1];
					buffer[0] = 0;
					sprintf (buffer, "%s%s", columnRef, sortOrder);
					delete columnRef;
					*lpOutputStr = buffer;
				}
				else
				{
					*lpOutputStr = columnRef;
				}
			}
			
			fFirst = FALSE;
		}

		//Check next node
		if (lpSqlNode->node.sortcolumns.Next != NO_SQLNODE)
		{
			newNode = ToNode(*lplpSql,lpSqlNode->node.sortcolumns.Next);
			lpSqlNode = newNode;
		}
		else
		{
			fContinue = FALSE;
		}
	}
}


//Generates GROUP BY string from NODE tree
void PredicateParser :: GenerateGroupByString(LPSQLNODE lpSqlNode, char ** lpOutputStr, BOOL fIsSQL89)
{
	BOOL fContinue = TRUE;
	BOOL fFirst = TRUE;
	LPSQLNODE newNode = NULL;
	while (fContinue)
	{
		char* columnRef = NULL;
		LPSQLNODE   myNode = ToNode(*lplpSql,lpSqlNode->node.groupbycolumns.Column);
		GenerateColumnRef(myNode, &columnRef, fIsSQL89);

		if (columnRef)
		{
			ULONG len1 = s_lstrlen(*lpOutputStr);

			if (!fFirst)
			{
				//add a comma separator and column ref
				ULONG len2 = s_lstrlen(columnRef) + 1;
				char* buffer = new char [len1 + len2 + 1];
				buffer[0] = 0;

				//Add new column to head of list
				sprintf (buffer, "%s,%s", columnRef, *lpOutputStr);
				delete (*lpOutputStr);
				delete columnRef;
				*lpOutputStr = buffer;
			}
			else
			{
				//add column ref
				*lpOutputStr = columnRef;
			}
			
			fFirst = FALSE;
		}

		//Check next node
		if (lpSqlNode->node.groupbycolumns.Next != NO_SQLNODE)
		{
			newNode = ToNode(*lplpSql,lpSqlNode->node.groupbycolumns.Next);
			lpSqlNode = newNode;
		}
		else
		{
			fContinue = FALSE;
		}
	}
}

void PredicateParser :: GenerateColumnRef(LPSQLNODE lpSqlNode, char ** lpOutputStr, BOOL fIsSQL89)
{
	*lpOutputStr = NULL;

	//Now find out what type of node we have reached
	switch (lpSqlNode->sqlNodeType)
	{
	case NODE_TYPE_COLUMN:
	{
		//Return a copy of the column name
		char* lpTemp  = (LPSTR) ToString(*lplpSql, lpSqlNode->node.column.Column);
		char* lpAlias = NULL;
		SQLNODEIDX  idxTblAlias	= lpSqlNode->node.column.Tablealias;
		
		if (idxTblAlias != NO_STRING)
		{
			lpAlias = (LPSTR) ToString(*lplpSql, idxTblAlias);
		}


		ULONG len = lstrlen(lpTemp);

		if (lpAlias && !fIsSQL89)
		{
			len += lstrlen(lpAlias) + 1;
		}

		(*lpOutputStr) = new char [len + 1];
		(*lpOutputStr)[0] = 0;

		if (lpAlias && !fIsSQL89)
		{
			sprintf(*lpOutputStr, "%s.%s",lpAlias, lpTemp);
		}
		else
		{
			lstrcpy(*lpOutputStr, lpTemp);
		}
	}
		break;
	case NODE_TYPE_NUMERIC:
	{
		SQLNODEIDX numIdx = lpSqlNode->node.numeric.Numeric;

		char* lpTemp  = NULL;

		if (numIdx != NO_STRING)
		{
			lpTemp = (LPSTR) ToString(*lplpSql, numIdx);

			ULONG len = lstrlen(lpTemp);
			(*lpOutputStr) = new char [len + 1];
			(*lpOutputStr)[0] = 0;
			lstrcpy(*lpOutputStr, lpTemp);
		}
	};
		break;
	default:
		break;
	}
}

//constructor for class to store column/table info for a SQL statement
TableColumnInfo :: TableColumnInfo(LPSQLTREE FAR *lplpTheSql, LPSQLTREE FAR * lpSqlN, ULONG mode)
{
	//Initialize
	lplpSql = lplpTheSql;
	lplpSqlNode = lpSqlN;
	lpList = NULL;
	fIsValid = TRUE;
	theMode = mode;
	idxTableQualifer = NO_STRING;
	fHasScalarFunction = FALSE;
	m_aggregateExists = FALSE;
	fDistinct = FALSE;

	//Create the table/column list from SQL statement

	//Check if it is SELECT * FROM ....
	fIsSelectStar = ( (*lplpSqlNode)->node.select.Values == NO_SQLNODE ) ? TRUE : FALSE;

	//Can't support SQL passthrough for SELECT * as the parse tree
	//does not contain any column names
	//[Please use SELECT <list of columns>]
	if ( (*lplpSqlNode)->node.select.Values == NO_SQLNODE)
	{
		fIsValid = FALSE;
		return;
	}

	//Look in the following sub-trees

	//(1) select-list
	LPSQLNODE lpSearchNode;
	if (!fIsSelectStar)
	{
		lpSearchNode = ToNode(*lplpSql, (*lplpSqlNode)->node.select.Values);
		Analize(lpSearchNode);
	}

	//(1b) SQL-92 ON predicate
	{
		SQLNODEIDX idxTheTables = (*lplpSqlNode)->node.select.Tables;
		LPSQLNODE tableNode = ToNode(*lplpSql,idxTheTables);

		BOOL fContinue = TRUE;
		while (fContinue)
		{
			SQLNODEIDX tableIdx = tableNode->node.tables.Table;
			LPSQLNODE singleTable = ToNode(*lplpSql,tableIdx);

			SQLNODEIDX predicateidx = singleTable->node.table.OuterJoinPredicate;

			if (predicateidx != NO_SQLNODE)
			{
				LPSQLNODE predicateNode = ToNode(*lplpSql,predicateidx);
				Analize(predicateNode);
			}

			if (tableNode->node.tables.Next == NO_STRING)
			{
				fContinue = FALSE;
			}
			else
			{
				tableNode = ToNode(*lplpSql,tableNode->node.tables.Next);
			}
		}
	}

	//Check if DISTINCT
	fDistinct = (*lplpSqlNode)->node.select.Distinct;

	//For multi table passthrough, return now
	if (mode == WQL_MULTI_TABLE)
	{
		return;
	}

	//(2) WHERE
	if ( (*lplpSqlNode)->node.select.Predicate != NO_SQLNODE)
	{
		lpSearchNode = ToNode(*lplpSql, (*lplpSqlNode)->node.select.Predicate);
		Analize(lpSearchNode);
	}

	//(3) GROUP BY
	BOOL fGroupbyDefined = FALSE;
	if ( (*lplpSqlNode)->node.select.Groupbycolumns != NO_SQLNODE)
	{
		lpSearchNode = ToNode(*lplpSql, (*lplpSqlNode)->node.select.Groupbycolumns);
		Analize(lpSearchNode);

		//as our implementation of GROUP BY requires that all the columns
		//be specified they is no need to imvestigate the ORDER BY node.
		//Also if no SORT BY columns are defined the node is set to an undefined value anyway
		fGroupbyDefined = TRUE;
	}

	//(4) HAVING
	if ( (*lplpSqlNode)->node.select.Having != NO_SQLNODE)
	{
		lpSearchNode = ToNode(*lplpSql, (*lplpSqlNode)->node.select.Having);
		Analize(lpSearchNode);
	}

	//(5) ORDER BY
	if ( (!fGroupbyDefined) && (*lplpSqlNode)->node.select.Sortcolumns != NO_SQLNODE)
	{
		lpSearchNode = ToNode(*lplpSql, (*lplpSqlNode)->node.select.Sortcolumns);
		Analize(lpSearchNode);
	}
}

//Analizes parse tree and generates TableColumn list
void TableColumnInfo :: Analize(LPSQLNODE lpSqlNode)
{
	//Now find out what type of node we have reached
	switch (lpSqlNode->sqlNodeType)
	{
	case NODE_TYPE_BOOLEAN:
	{
		//Analize the left node
		Analize(ToNode(*lplpSql,lpSqlNode->node.boolean.Left));

		//Analize the right node, if it exists
		if (lpSqlNode->node.boolean.Right != NO_SQLNODE)
		{
			Analize(ToNode(*lplpSql,lpSqlNode->node.boolean.Right));
		}
	}
		break;
	case NODE_TYPE_COMPARISON:
	{
		//Analize the left node
		Analize(ToNode(*lplpSql,lpSqlNode->node.comparison.Left));

		//Analize the right node
		Analize(ToNode(*lplpSql,lpSqlNode->node.comparison.Right));
	}
		break;
	case NODE_TYPE_VALUES:
	{
		//Analize the value node
		Analize(ToNode(*lplpSql,lpSqlNode->node.values.Value));

		//Analize the next node
		if (lpSqlNode->node.values.Next != NO_SQLNODE)
		{
			Analize(ToNode(*lplpSql,lpSqlNode->node.values.Next));
		}
	}
		break;
	case NODE_TYPE_AGGREGATE:
	{
		//Analize the left node
		Analize(ToNode(*lplpSql,lpSqlNode->node.aggregate.Expression));
		m_aggregateExists = TRUE;
	}
		break;
	case NODE_TYPE_ALGEBRAIC:
	{
		//Analize the left node
		Analize(ToNode(*lplpSql,lpSqlNode->node.algebraic.Left));

		//Analize the right node
		if (lpSqlNode->node.algebraic.Right != NO_SQLNODE)
			Analize(ToNode(*lplpSql,lpSqlNode->node.algebraic.Right));
	}
		break;
	case NODE_TYPE_SCALAR:
	{
		//WQL cannot support scalar functions so we must
		//flag this special case
		fHasScalarFunction = TRUE;

		//Analize the value list
		Analize(ToNode(*lplpSql,lpSqlNode->node.scalar.Arguments));
	}
	break;

	case NODE_TYPE_SORTCOLUMNS:
	{
		LPSQLNODE myNode = lpSqlNode;

		SQLNODEIDX orderbyidx = myNode->node.sortcolumns.Column;

		while (orderbyidx != NO_SQLNODE)
		{
			//Analize the first column
			Analize(ToNode(*lplpSql,orderbyidx));

			SQLNODEIDX next_idx = myNode->node.sortcolumns.Next;
			
			if (next_idx != NO_SQLNODE)
			{
				//update to point to next sortcolumn node
				myNode = ToNode(*lplpSql, next_idx);

				orderbyidx = myNode->node.sortcolumns.Column;
			}
			else
			{
				orderbyidx = NO_SQLNODE;
			}
		}
	}
	break;

	case NODE_TYPE_COLUMN:
	{
		//Generate a node for the Column/Table list

		SQLNODEIDX	idxCol		= lpSqlNode->node.column.Column;
		SQLNODEIDX  idxTblAlias	= lpSqlNode->node.column.Tablealias;
		SQLNODEIDX	idxTbl		= lpSqlNode->node.column.Table;
		LPSQLNODE   myTableNode = ToNode(*lplpSql,idxTbl);

		//SAI
		LPISAMTABLEDEF lpTDef = NULL;

		if (idxTbl != NO_SQLNODE)
			lpTDef = myTableNode->node.table.Handle;

		//First check if it already exists in list
		BOOL found = FALSE;
		TableColumnList* ptr = lpList;
		while (!found && ptr)
		{
			//Get column names
			char* lpTemp1 = (LPSTR) ToString(*lplpSql, idxCol);
			char* lpTemp2 = (LPSTR) ToString(*lplpSql, ptr->idxColumnName);

			if ( (strcmp(lpTemp1, lpTemp2) == 0) && (lpTDef == ptr->lpISAMTableDef) )
			{
				//This could potentially be a match
				if (lpTDef)
				{
					found = TRUE;
				}
				else
				{
					//Multi-table passthrough SQL checks
					//Check Table aliases
					if ( (idxTblAlias != NO_STRING) && (ptr->idxTableAlias != NO_STRING))
					{
						char* lpAlias1 = (LPSTR) ToString(*lplpSql, idxTblAlias);
						char* lpAlias2 = (LPSTR) ToString(*lplpSql, ptr->idxTableAlias);

						if (_stricmp(lpAlias1, lpAlias2) == 0)
						{
							found = TRUE;
						}
					}
				}
			}
			ptr = ptr->Next;
		}

		if (found)
			return;

		//Not in existing list, so add
		TableColumnList* newNode = new TableColumnList(idxCol, idxTblAlias, lpTDef);

		//Append new node to HEAD of existing list, if it exists
		if (lpList)
		{
			//List already exists
			newNode->Next = lpList;
			lpList = newNode;
		}
		else
		{
			//List does not exist, so new node becomes list
			lpList = newNode;
		}

	}
		break;
	case NODE_TYPE_STRING:
	case NODE_TYPE_NUMERIC:
	case NODE_TYPE_PARAMETER:
	case NODE_TYPE_USER:
	case NODE_TYPE_NULL:
	default:
		break;
	}
}

void TableColumnInfo :: BuildFullWQL(char** lpWQLStr, CMapWordToPtr** ppPassthroughMap)
{
	//SELECT
	StringConcat(lpWQLStr, "SELECT ");

	//Get the table list first to find out if we are 
	//SQL-89 or SQL-92
	char* tableList = NULL;
	BOOL fIsSQL89 = TRUE;
	BuildTableList(&tableList, fIsSQL89);

	//Looking for distinct entries ?
	if (IsDistinct())
	{
		StringConcat(lpWQLStr, " DISTINCT ");
	}

/*
	//Don't do this as we cannot support SELECT * for SQL passthrough
	//[as the parse tree does not know the column names]
	// and we will have problems with the virtual table mapping if
	//the table has array data types

	//this will cause the SQL passthrough query to fail
	//and we will go the non-passthrough route ...

	//Check if this is SELECT * FROM ...
	if (IsSelectStar())
	{
		StringConcat(lpWQLStr, " * ");
	}
*/	

	//Get the select list
	char* selectList = NULL;
	BuildSelectList(NULL, &selectList, fIsSQL89, ppPassthroughMap);
	StringConcat(lpWQLStr, selectList);
	delete selectList;

	//Check for any scalar functions
	if ( HasScalarFunction() )
	{
		StringConcat(lpWQLStr, ",SomeScalarFunctionThatWQLDoesNotSupport");
	}

	//FROM
	StringConcat(lpWQLStr, " FROM ");

	//Get table list (with LEFT OUTER JOIN and ON predicate)
//	char* tableList = NULL;
//	BOOL fIsSQL89 = TRUE;
//	BuildTableList(&tableList, fIsSQL89);
	StringConcat(lpWQLStr, tableList);
	delete tableList;

	//Get WHERE predicate
	SQLNODEIDX whereidx = (*lplpSqlNode)->node.select.Predicate;
	PredicateParser theParser (lplpSql, NULL);
	if (whereidx != NO_SQLNODE)
	{
		LPSQLNODE lpPredicateNode = ToNode(*lplpSql, whereidx); 
		
		char* wherePredicate = NULL;
		theParser.GeneratePredicateString(lpPredicateNode, &wherePredicate, fIsSQL89);
		if (wherePredicate)
		{
			StringConcat(lpWQLStr, " WHERE ");
			StringConcat(lpWQLStr, wherePredicate);
			delete wherePredicate;
		}
	}

	//Get GROUP BY
	SQLNODEIDX groupbyidx = (*lplpSqlNode)->node.select.Groupbycolumns;

	if (groupbyidx != NO_SQLNODE)
	{
		LPSQLNODE groupbyNode = ToNode(*lplpSql, groupbyidx); 
		char* groupByStr = NULL;
		theParser.GenerateGroupByString(groupbyNode, &groupByStr, fIsSQL89);
		if (groupByStr)
		{
			StringConcat(lpWQLStr, " GROUP BY ");
			StringConcat(lpWQLStr, groupByStr);
			delete groupByStr;
		}
	}

	//Get HAVING
	SQLNODEIDX havingidx = (*lplpSqlNode)->node.select.Having;

	if (havingidx != NO_SQLNODE)
	{
		LPSQLNODE lpPredicateNode = ToNode(*lplpSql, havingidx);
		
		char* HavingPredicate = NULL;
		theParser.GeneratePredicateString(lpPredicateNode, &HavingPredicate, fIsSQL89);
		if (HavingPredicate)
		{
			StringConcat(lpWQLStr, " HAVING ");
			StringConcat(lpWQLStr, HavingPredicate);
			delete HavingPredicate;
		}
	}

	//Get ORDER BY
	SQLNODEIDX orderbyidx = (*lplpSqlNode)->node.select.Sortcolumns;

	if (orderbyidx != NO_SQLNODE)
	{
		LPSQLNODE orderbyNode = ToNode(*lplpSql, orderbyidx); 
		char* orderByStr = NULL;
		theParser.GenerateOrderByString(orderbyNode, &orderByStr, fIsSQL89);
		if (orderByStr)
		{
			StringConcat(lpWQLStr, " ORDER BY ");
			StringConcat(lpWQLStr, orderByStr);
			delete orderByStr;
		}
	}

}

void TableColumnInfo :: StringConcat(char** resultString, char* myStr)
{
	if (myStr)
	{
		ULONG len = s_lstrlen(myStr);

		ULONG oldLen = 0;
		
		if (resultString && *resultString)
			oldLen = s_lstrlen(*resultString);

		char* buffer = new char [oldLen + len + 1];
		buffer[0] = 0;

		if (oldLen)
		{
			sprintf (buffer, "%s%s", *resultString, myStr);
		}
		else
		{
			s_lstrcpy(buffer, myStr);
		}

		//delete old string
		if (resultString && *resultString)
			delete (*resultString);

		//replace with new string
		*resultString = buffer;
	}
}


//Info related to nodes of LEFT OUTER JOIN statement
class JoinInfo
{
public:

	_bstr_t		tableName;
	_bstr_t		tableAlias;
	
	_bstr_t		predicate;

	JoinInfo()						{;}
	~JoinInfo()						{;}

};


void TableColumnInfo :: BuildTableList(char** tableList, BOOL &fIsSQL89, SQLNODEIDX idx)
{
	//We will build 2 different table lists in the 
	//SQL-89 and SQL-92 formats.
	//We will discard the SQL-89 format if we find either
	//(i)   SQL-92 JOINS
	//(ii)  Multiple tables
	//(iii) Sub-SELECTs

	//tableList will start with the SQL-89 string

	BOOL fFirst = TRUE;
	BOOL noJoinTables = TRUE;
	fIsSQL89 = TRUE;
	SQLNODEIDX	idxTables = 1; 

	//Constrcut maps for Table/Alias and predicates
	CMapWordToPtr* tableAliasMap = new CMapWordToPtr(); //1 based map
	WORD tableAliasCount = 0;	

	CMapWordToPtr* predicateMap = new CMapWordToPtr(); //1 based map
	WORD predicateCount = 0;

	char* lpSQL92 = NULL;

	LPSQLNODE tableNode;
				
	if (idx == NO_SQLNODE)
	{
		SQLNODEIDX idxTheTables = (*lplpSqlNode)->node.select.Tables;
		tableNode = ToNode(*lplpSql,idxTheTables);
	}
	else
	{
		tableNode = ToNode(*lplpSql,idx);
	}


	BOOL fContinue = TRUE;
	while (fContinue)
	{
		SQLNODEIDX tableIdx = tableNode->node.tables.Table;
		LPSQLNODE singleTable = ToNode(*lplpSql,tableIdx);

		char* aliasStr = NULL;
		
		if (singleTable->node.table.Alias != NO_STRING)
		{
			aliasStr = (LPSTR) ToString(*lplpSql, singleTable->node.table.Alias);     //e.g. t1
		}
		char* tableStr = NULL;
		
		if (singleTable->node.table.Name != NO_STRING)
		{
			tableStr = (LPSTR) ToString(*lplpSql, singleTable->node.table.Name);      //e.g. Table1
		}

		//This is when we add multi-namespace queries
		if (idxTableQualifer == NO_STRING)
			idxTableQualifer = singleTable->node.table.Qualifier;

		//Check for outer join
		SQLNODEIDX joinidx = singleTable->node.table.OuterJoinFromTables; //NODE_TYPE_TABLES

		if (joinidx != NO_SQLNODE)
		{
//			StringConcat(&lpSQL92, " LEFT OUTER JOIN ");
			noJoinTables = FALSE;
			fIsSQL89 = FALSE;
		}

			
		//Add <table> <alias> 
		if (idx == NO_SQLNODE)
		{

			//Add info to tableAliasMap
			JoinInfo* myTableAlias = new JoinInfo();


			if (tableStr)
			{
//				if (fIsSQL89)
//					StringConcat(tableList, tableStr);

//				StringConcat(&lpSQL92, tableStr);

				myTableAlias->tableName = tableStr;
			}

			if (aliasStr)
			{
//				StringConcat(&lpSQL92, " ");
//				StringConcat(&lpSQL92, aliasStr);
//				StringConcat(&lpSQL92, " ");

				myTableAlias->tableAlias = aliasStr;
			}

			//Add to map 
			tableAliasMap->SetAt(++tableAliasCount, (void*)myTableAlias);
		}


		SQLNODEIDX predicateidx = singleTable->node.table.OuterJoinPredicate;

		if (predicateidx != NO_SQLNODE)
		{
			fIsSQL89 = FALSE;
			char* myPredicate = NULL;
			AddJoinPredicate(&myPredicate, predicateidx);
//			AddJoinPredicate(&lpSQL92, predicateidx);


			JoinInfo* myPredicateInfo = new JoinInfo();
			myPredicateInfo->predicate = myPredicate;
			delete myPredicate;

			//Add to map
			predicateMap->SetAt(++predicateCount, (void*)myPredicateInfo);
		}

		//Check if there is another table in the table list
		if (tableNode->node.tables.Next == NO_STRING)
		{
			fContinue = FALSE;
		}
		else
		{
			tableNode = ToNode(*lplpSql,tableNode->node.tables.Next);

			//New
			fIsSQL89 = FALSE;
/*
			//Add a comma to separate table list
			if ((!fFirst) && (idx == NO_SQLNODE) && (noJoinTables))
			{
//				StringConcat(&lpSQL92, ",");
				fIsSQL89 = FALSE;
			}
*/
		}

		fFirst = FALSE;
	}
/*
	//Are we going to use SQL-89 or SQL-92 ?
	if (!fIsSQL89)
	{
		delete *tableList;
		*tableList = lpSQL92;
	}
	else
	{
		delete lpSQL92;
	}
*/

	//Now build the table list
	_bstr_t myTableList;
	_bstr_t myFullTableDecl;
	BOOL fFirstOuterJoin = TRUE;

	//Note: Some providers will return an error if you supply
	//a table alias on a single table WQL query.
	//we should check for this and remove the table alias from
	//the table list
	BOOL fSingleTableDetected = TRUE;
	if ( tableAliasCount > 1 )
	{
		fSingleTableDetected = FALSE;
	}
	

	//Add a table
	JoinInfo* myJoinData = NULL;
	tableAliasMap->Lookup(tableAliasCount--, (void*&)myJoinData);

	myTableList = myJoinData->tableName;

	if ( myJoinData->tableAlias.length() && !fSingleTableDetected )
	{
		myTableList += " " + myJoinData->tableAlias;
	}

	//Are there any predicates
	if (predicateCount)
	{
		while (predicateCount)
		{
			if (fFirstOuterJoin)
			{
				//LEFT OUTER JOIN (add to right side)
				myFullTableDecl = " LEFT OUTER JOIN ";
				myFullTableDecl += myTableList;
				myTableList = myFullTableDecl;
			}
			else
			{
				//RIGHT OUTER JOIN (add to left side)
				myTableList += " RIGHT OUTER JOIN ";
			}

			//Add next table
			myJoinData = NULL;
			tableAliasMap->Lookup(tableAliasCount--, (void*&)myJoinData);

			myFullTableDecl = myJoinData->tableName;
//			myTableList += myJoinData->tableName;

			if ( myJoinData->tableAlias.length() )
			{
				myFullTableDecl += " " + myJoinData->tableAlias;
			}

			if (fFirstOuterJoin)
			{
				//Add table to left side
				myFullTableDecl += myTableList;
				myTableList = myFullTableDecl;
			}
			else
			{
				//Add table to right side
				myTableList += " " + myFullTableDecl;
			}

			fFirstOuterJoin = FALSE;

			//Add predicate to end
			myJoinData = NULL;
			predicateMap->Lookup(predicateCount--, (void*&)myJoinData);
		
			if ( myJoinData->predicate.length() )
			{
				myTableList += " " + myJoinData->predicate;
			}
		}

	}
	else
	{
		//Simple Table list
		while (tableAliasCount)
		{
			//Add next table
			myJoinData = NULL;
			tableAliasMap->Lookup(tableAliasCount--, (void*&)myJoinData);

			myTableList += ", " + myJoinData->tableName;

			if ( myJoinData->tableAlias.length() )
			{
				myTableList += " " + myJoinData->tableAlias;
			}
		}
	}

	//Convert myTableList to string
	long length = myTableList.length();
	*tableList = new char [length + 1];
	(*tableList)[0] = 0;
	wcstombs(*tableList, (wchar_t*)myTableList, length);
	(*tableList)[length] = 0;

	//Tidy up
	if (tableAliasMap && !(tableAliasMap->IsEmpty()))
	{
		for(POSITION pos = tableAliasMap->GetStartPosition(); pos != NULL; )
		{
			WORD key = 0; //not used
			JoinInfo* pa = NULL;
			tableAliasMap->GetNextAssoc( pos, key, (void*&)pa );

			if (pa)
				delete pa;
		}
	}
	delete (tableAliasMap);


	if (predicateMap && !(predicateMap->IsEmpty()))
	{
		for(POSITION pos = predicateMap->GetStartPosition(); pos != NULL; )
		{
			WORD key = 0; //not used
			JoinInfo* pa = NULL;
			predicateMap->GetNextAssoc( pos, key, (void*&)pa );

			if (pa)
				delete pa;
		}	
	}
	delete (predicateMap);
}

/*
void TableColumnInfo :: AddJoin(_bstr_t & tableList, SQLNODEIDX joinidx)
{
	BOOL fContinue = TRUE;
	LPSQLNODE tableNode = tableNode = ToNode(*lplpSql,joinidx);

	while (fContinue)
	{
		SQLNODEIDX tableIdx = tableNode->node.tables.Table;
		LPSQLNODE singleTable = ToNode(*lplpSql,tableIdx);

		char* aliasStr = NULL;
		
		if (singleTable->node.table.Alias != NO_STRING)
		{
			aliasStr = (LPSTR) ToString(*lplpSql, singleTable->node.table.Alias);     //e.g. t1
		}
		char* tableStr = NULL;
		
		if (singleTable->node.table.Name != NO_STRING)
		{
			tableStr = (LPSTR) ToString(*lplpSql, singleTable->node.table.Name);      //e.g. Table1
		}

		//Add LEFT OUTER JOIN <table> <alias> 
		if (tableStr)
		{
			tableList += " LEFT OUTER JOIN ";
			tableList += tableStr;
		}

		if (aliasStr)
		{
			tableList += " ";
			tableList += aliasStr;
			tableList += " ";
		}

		if (tableNode->node.tables.Next == NO_STRING)
		{
			fContinue = FALSE;
		}
		else
		{
			tableNode = ToNode(*lplpSql,tableNode->node.tables.Next);
		}
	}
}
*/

void TableColumnInfo :: AddJoinPredicate(char** tableList, SQLNODEIDX predicateidx)
{
	LPSQLNODE lpPredicateNode = ToNode(*lplpSql, predicateidx); 
	PredicateParser theParser (lplpSql, NULL);
	
	char* buffer = NULL;
	theParser.GeneratePredicateString(lpPredicateNode, &buffer, FALSE);

	//Did we find a predicate
	if (buffer)
	{
		StringConcat(tableList, " ON ");
		StringConcat(tableList, buffer);
	}
	delete buffer;
}

void TableColumnInfo :: BuildSelectList(LPISAMTABLEDEF lpTableDef, char** lpSelectListStr, BOOL fIsSQL89, CMapWordToPtr** ppPassthroughMap)
{
	*lpSelectListStr = NULL;
	//Scan through list checking for nodes which match same LPISAMTABLEDEF
	TableColumnList* ptr =lpList;

	//For testing
	CMapWordToPtr* passthroughMap = NULL;
	
	if (ppPassthroughMap)
		passthroughMap = new CMapWordToPtr();

	WORD passthroughkey = 0; //zero based index

	while (ptr)
	{
		if ( (theMode == WQL_MULTI_TABLE) || (lpTableDef == ptr->lpISAMTableDef) )
		{
			//Found a match, add to output select list
			char* lpTemp = (LPSTR) ToString(*lplpSql, ptr->idxColumnName);
			ULONG cColumnLen = lstrlen (lpTemp);
			ULONG cOutputLen = (*lpSelectListStr) ? lstrlen(*lpSelectListStr) : 0;

			//Get the qualifier (for WQL_MULTI_TABLE)
			char* lpTemp2 = NULL;
			ULONG cColumnLen2 = 0;
			
			if ( (ptr->idxTableAlias != NO_STRING) && !fIsSQL89)
			{
				lpTemp2 = (LPSTR) ToString(*lplpSql, ptr->idxTableAlias);
				cColumnLen2 = lstrlen (lpTemp2) + 1; //extra 1 for the dot
			}


			if (passthroughMap)
			{
				//Setup Passthrough Element
				PassthroughLookupTable* mapElement = new PassthroughLookupTable();
				mapElement->SetTableAlias(lpTemp2);
				mapElement->SetColumnName(lpTemp);

				//Add to Passthrough Map
				passthroughMap->SetAt(passthroughkey++, (void*)mapElement);
			}

			if (*lpSelectListStr)
			{
				char* newStr = new char [cColumnLen2 + cColumnLen + cOutputLen + 2];
				newStr[0] = 0;

				if ( (theMode == WQL_MULTI_TABLE) && (cColumnLen2 > 0) )
				{
					//Add new entries to head of list
					sprintf (newStr, "%s.%s,%s", lpTemp2, lpTemp, *lpSelectListStr);
				}
				else
				{
					sprintf (newStr, "%s,%s", *lpSelectListStr, lpTemp);
				}
				delete *lpSelectListStr;
				*lpSelectListStr = newStr;
			}
			else
			{
				*lpSelectListStr = new char [cColumnLen2 + cColumnLen + 1];
				(*lpSelectListStr)[0] = 0;

				if ( (theMode == WQL_MULTI_TABLE) && (cColumnLen2 > 0) )
				{
					sprintf (*lpSelectListStr, "%s.%s", lpTemp2, lpTemp);
				}
				else
				{
					lstrcpy (*lpSelectListStr, lpTemp);
				}
			}
		}

		ptr = ptr->Next;
	}

	if (ppPassthroughMap)
	{
		//The order in the passthrough map is WRONG
		//columns were added in reverse order
		//we need to re-read the columns out and add back in correct order
		CMapWordToPtr* passthroughMapNEW = new CMapWordToPtr();

		PassthroughLookupTable* passthroughElement = NULL;

		WORD myCount = (WORD) passthroughMap->GetCount();

		for (WORD loop = 0; loop < myCount; loop++)
		{
			BOOL status = passthroughMap->Lookup(loop, (void*&)passthroughElement);

			if (status)
			{
				WORD NewIndex = myCount - 1 - loop;

				//For test purposes only
//				char* newColumnName = passthroughElement->GetColumnName();
//				char* newAlias		= passthroughElement->GetTableAlias();

				//Add to new passthrough map
				passthroughMapNEW->SetAt(NewIndex, (void*)passthroughElement);
			}
		}
		*ppPassthroughMap = passthroughMapNEW;
		delete passthroughMap;
	}
}

void TidyupPassthroughMap(CMapWordToPtr* passthroughMap)
{
	//Test tidy up PassthroughMap
	if (passthroughMap && !(passthroughMap->IsEmpty()))
	{
		for(POSITION pos = passthroughMap->GetStartPosition(); pos != NULL; )
		{
			WORD key = 0; //not used
			PassthroughLookupTable* pa = NULL;
			passthroughMap->GetNextAssoc( pos, key, (void*&)pa );

			if (pa)
				delete pa;
		}
		//delete passthroughMap;
		//passthroughMap = NULL;
	}

	//SAI ADDED
	delete passthroughMap;
	passthroughMap = NULL;
}

BOOL TableColumnInfo :: IsTableReferenced(LPISAMTABLEDEF lpTableDef)
{
	BOOL fStatus = FALSE;

	TableColumnList* ptr =lpList;

	while (!fStatus && ptr)
	{
		if (lpTableDef == ptr->lpISAMTableDef)
		{
			fStatus = TRUE;
		}

		ptr = ptr->Next;
	}
	
	return fStatus;
}

BOOL TableColumnInfo :: IsZeroOrOneList()
{
	if ( (lpList == NULL) || (lpList->Next == NULL) )
		return TRUE;
	else
		return FALSE;
}

DateTimeParser ::DateTimeParser(BSTR dateTimeStr)
{
	//Initialize
	m_year = 0;
	m_month = 0;
	m_day = 0;
	m_hour = 0;
	m_min = 0;
	m_sec = 0;
	m_microSec = 0;
	fIsValid = TRUE; //Indicates if dataTime string is valid

	

	//Make a copy of the string
	dateTimeBuff[0] = 0;
	strcpy(dateTimeBuff, "00000000000000.000000");
//	if ( dateTimeStr && ( wcslen(dateTimeStr) >= DATETIME_FORMAT_LEN) )
	
	long lLength = wcslen(dateTimeStr);
	if ( dateTimeStr && lLength )
	{
		//Copy string into buffer
		if (lLength > DATETIME_FORMAT_LEN)
			lLength = DATETIME_FORMAT_LEN;

		wcstombs(dateTimeBuff, dateTimeStr, lLength);
		dateTimeBuff[DATETIME_FORMAT_LEN] = 0;

		//Now check each of the fields in the string
		ValidateFields();
	}
	else
	{
		//error in dateTime string
		fIsValid = FALSE;
	}
}

BOOL DateTimeParser :: IsNumber(char bChar)
{
	if ( (bChar >= '0') && (bChar <= '9'))
		return TRUE;

	return FALSE;
}

void DateTimeParser :: FetchField(char* lpStr, WORD wFieldLen, ULONG &wValue)
{
	tempBuff[0] = 0;
	strncpy (tempBuff, lpStr, wFieldLen);
	tempBuff[wFieldLen] = 0;
	wValue = atoi(tempBuff);
}

void DateTimeParser :: ValidateFields()
{
	//The dateTime string can represent a date, time or timestamp
	//We need to identify which one it represents and that each 
	//field is valid	
	char* ptr = dateTimeBuff;

	//The format of the datetime string is as follows
	//      YYYYMMDDHHMMSS.VVVVVV

	//Check if the date fields are set
	fValidDate = TRUE;
	for (UWORD cIndex = 0; cIndex < DATETIME_DATE_LEN; cIndex++)
	{
		if ( ! IsNumber(dateTimeBuff[cIndex]) )
			fValidDate = FALSE;
	}

	//If there is a valid date get the fields
	if (fValidDate)
	{
		//Copy the year
		FetchField(ptr, DATETIME_YEAR_LEN, m_year);

		//Copy the month
		ptr += DATETIME_YEAR_LEN;
		FetchField(ptr, DATETIME_MONTH_LEN, m_month);

		//Copy the day
		ptr += DATETIME_MONTH_LEN;
		FetchField(ptr, DATETIME_DAY_LEN, m_day);
	}

	ptr = dateTimeBuff + DATETIME_YEAR_LEN + DATETIME_MONTH_LEN + DATETIME_DAY_LEN;
	fValidTime = TRUE;
	for (cIndex = 0; cIndex < DATETIME_TIME_LEN; cIndex++)
	{
		if ( ! IsNumber(ptr[cIndex]) )
			fValidTime = FALSE;
	}

	//If there is a valid time get the fields
	if (fValidTime)
	{
		//Copy the hour
		FetchField(ptr, DATETIME_HOUR_LEN, m_hour);

		//Copy the min
		ptr += DATETIME_HOUR_LEN;
		FetchField(ptr, DATETIME_MIN_LEN, m_min);

		//Copy the sec
		ptr += DATETIME_MIN_LEN;
		FetchField(ptr, DATETIME_SEC_LEN, m_sec);
	}
	
	//Set pointer to start of microseconds (just past the '.' character)
	ptr = dateTimeBuff + DATETIME_YEAR_LEN + DATETIME_MONTH_LEN + DATETIME_DAY_LEN
		+ DATETIME_HOUR_LEN + DATETIME_MIN_LEN + DATETIME_SEC_LEN + 1;

	//Now we get the number of micro seconds
	FetchField(ptr, DATETIME_MICROSEC_LEN, m_microSec);

	//analyse what datetime string represents
	fIsaTimestamp = FALSE;
	fIsaDate = FALSE;
	fIsaTime = FALSE;

	if ( !fValidDate && !fValidTime)
	{
		fIsValid = FALSE;
	}
	else
	{
		if (fValidDate)
		{
			//This must represent a date or timestamp
			if (fValidTime)
			{
				//This represents a timestamp
				fIsaTimestamp = TRUE;
				fIsaDate = TRUE;
				fIsaTime = TRUE;
			}
			else
			{
				//this represents a date
				fIsaDate = TRUE;
			}
		}
		else
		{
			//This must represent a Time
			fIsaTime = TRUE;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wbemdr32.rc
//
#define ISAM_MEMALLOCFAIL               8
#define ISAM_PROVIDERFAIL               9
#define ISAM_NS_OVERMAX                 10
#define ISAM_NS_LISTFAIL                11
#define ISAM_NS_QUALMISSING             12
#define ISAM_TABLELISTFAIL              13
#define ISAM_TABLENAMEFAIL              14
#define ISAM_TABLEFAIL                  15
#define IDD_DIALOG_CONNECTION           101
#define IDB_BITMAP1                     104
#define IDB_BITMAP2                     105
#define IDD_DIALOG_BROWSE               105
#define IDB_BITMAP3                     106
#define IDI_ICON1                       106
#define IDB_BITMAP4                     107
#define IDI_ICON2                       108
#define IDB_MASK                        109
#define IDI_ICON3                       110
#define IDI_ICON4                       111
#define IDR_TOOLBAR1                    113
#define IDC_TREE1                       1000
#define IDC_TREE2                       1001
#define IDC_BUTTON_ADD                  1002
#define IDC_REMOVE                      1003
#define IDC_EDIT_USER_NAME              1004
#define IDC_EDIT_PSWD                   1005
#define IDC_STATIC_USER_NAME            1006
#define IDC_STATIC_GRP1                 1007
#define IDC_CHECK_DEEPCOPY              1008
#define IDC_BUTTON_BROWSE               1009
#define IDC_LIST1                       1010
#define IDC_BACK                        1011
#define IDC_BACKBUTTON                  1012
#define IDC_LISTBUTTON                  1013
#define IDC_DETAILBUTTON                1014
#define IDC_BROWSE_EDIT                 1015
#define IDC_CHECK1                      1017
#define IDC_MESSAGE                     1018
#define IDC_REFRESH_BUTTON              1019
#define IDC_EDIT_AUTH                   1020
#define IDC_RADIO_DEFAULT               1021
#define IDC_RADIO_NTLM                  1022
#define IDC_RADIO_WBEM                  1023
#define IDC_EDIT_LOCALE                 1024
#define IDC_STATIC_AUTH                 1025
#define IDC_CHECK_IMPERSONATE           1026
#define IDC_CHECK_PASSTHROUGHONLY       1027
#define IDC_STATIC_INTPREMPTYPWD	1028
#define IDC_RADIO_NULL                  1029
#define IDC_RADIO_BLANK                 1030
#define ERR_INVALIDQUALIFIER            1154
#define ERR_INSUFF_BUFFER               1155
#define ERR_INVALID_TIMESTAMP           1156
#define ERR_INVALID_DATE                1157
#define ERR_INVALID_TIME                1158
#define ERR_INVALID_INTEGER             1159
#define ERR_CREATE_NOTSUPP              1160
#define ERR_DROP_NOTSUPP                1161
#define ERR_INSERT_NOTSUPP              1162
#define ERR_DELETE_NOTSUPP              1163
#define ERR_UPDATE_NOTSUPP              1164
#define ERR_ALTER_NOTSUPP               1165
#define ERR_GRANT_NOTSUPP               1166
#define ERR_REVOKE_NOTSUPP              1167
#define ERR_LEN_NOTSUPP                 1168
#define ERR_COUNT_NOTSUPP               1169
#define ERR_BETWEEN_NOTSUPP             1170
#define ERR_PASSTGHONLY_NOTSUPP         1171
#define ERR_WBEM_SPECIFIC               1172
#define STR_PREVIOUS                    5102
#define STR_LIST_VIEW                   5103
#define STR_REPORT_VIEW                 5104
#define STR_PLEASE_REFRESH              5105
#define STR_FAILED_WBEM_CONN            5106
#define STR_CONNECT                     5107
#define STR_REFRESH                     5108
#define IDC_HELP_BUTTON                 5109
#define STR_EXECQUERY                   5110
#define ID_BUTTON40001                  40001
#define IDC_STATIC_PSWD                 -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\prepare.cpp ===
/***************************************************************************/
/* PREPARE.C                                                               */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"

#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"

/***************************************************************************/

RETCODE SQL_API SQLAllocStmt(
    HDBC      hdbc,
    HSTMT FAR *phstmt)
{
    LPDBC   lpdbc;
    LPSTMT  lpstmt;
    HGLOBAL hstmt;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Get connection handle */
    lpdbc = (LPDBC) hdbc;
    lpdbc->errcode = ERR_SUCCESS;

    /* Allocate memory for the statement */
    hstmt = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (STMT));
    if (hstmt == NULL || (lpstmt = (LPSTMT)GlobalLock (hstmt)) == NULL) {
        
        if (hstmt)
            GlobalFree(hstmt);

        lpdbc->errcode = ERR_MEMALLOCFAIL;
        *phstmt = SQL_NULL_HSTMT;
        return SQL_ERROR;
    }

    /* Put statement on the list of statements for the connection */
    lpstmt->lpNext = lpdbc->lpstmts;
    lpdbc->lpstmts = lpstmt;

    /* Initialize the statement handle */
    lpstmt->lpdbc = lpdbc;
    lpstmt->errcode = ERR_SUCCESS;
    ((char*)lpstmt->szError)[0] = 0;
    ((char*)lpstmt->szISAMError)[0] = 0;
    ((char*)lpstmt->szCursor)[0] = 0;
    lpstmt->fStmtType = STMT_TYPE_NONE;
    lpstmt->fStmtSubtype = STMT_SUBTYPE_NONE;
    lpstmt->irow = AFTER_LAST_ROW;
    lpstmt->fSqlType = 0;
    lpstmt->lpISAMTableList = NULL;
    ((char*)lpstmt->szTableName)[0] = 0;
	lpstmt->lpISAMQualifierList = NULL;
	((char*)lpstmt->szQualifierName)[0] = 0;
	((char*)lpstmt->szTableType)[0] = 0;
	lpstmt->fSyncMode = SQL_ASYNC_ENABLE_OFF; //default value
    lpstmt->lpISAMTableDef = NULL;
    lpstmt->lpKeyInfo = NULL;
    lpstmt->lpSqlStmt = NULL;
    lpstmt->fPreparedSql = FALSE;
    lpstmt->lpISAMStatement = NULL;
    lpstmt->fNeedData = FALSE;
    lpstmt->idxParameter = NO_SQLNODE;
    lpstmt->cbParameterOffset = -1;
    lpstmt->icol = NO_COLUMN;
    lpstmt->cRowCount = -1;
    lpstmt->cbOffset = 0;
    lpstmt->fISAMTxnStarted = FALSE;
    lpstmt->fDMLTxn = FALSE;

    /* So far no bound columns */
    lpstmt->lpBound = NULL;

    /* So far no parameters */
    lpstmt->lpParameter = NULL;

    /* Return the statement handle */
    *phstmt = (HSTMT FAR *) lpstmt;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLFreeStmt(
    HSTMT     hstmt,
    UWORD     fOption)
{
    LPSTMT      lpstmt;
    LPSTMT      lpstmtPrev;
    LPBOUND     lpBound;
    LPPARAMETER lpParameter;
    RETCODE     err;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;
    
    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

//	ODBCTRACE(_T("\nWBEM ODBC Driver : SQLFreeStmt\n"));
//	MyImpersonator im (lpstmt);

    /* Do the operation */
    switch (fOption) {
    case SQL_CLOSE:

        /* End the transaction if need be */
        if ((lpstmt->fStmtType == STMT_TYPE_SELECT) &&
                      (lpstmt->lpdbc->lpISAM->fTxnCapable != SQL_TC_NONE) &&
                                             lpstmt->lpdbc->fAutoCommitTxn) {
            err = SQLTransact(SQL_NULL_HENV, (HDBC)lpstmt->lpdbc, SQL_COMMIT);
            if ((err != SQL_SUCCESS) && (err != SQL_SUCCESS_WITH_INFO)) {
                lpstmt->errcode = lpstmt->lpdbc->errcode;
                s_lstrcpy(lpstmt->szISAMError, lpstmt->lpdbc->szISAMError);
                return err;
            }
        }

        /* Terminate the active statement */
        lpstmt->fStmtType = STMT_TYPE_NONE;
        lpstmt->fStmtSubtype = STMT_SUBTYPE_NONE;
        lpstmt->irow = AFTER_LAST_ROW;
        lpstmt->fSqlType = 0;
        if (lpstmt->lpISAMTableList != NULL) {
            ISAMFreeTableList(lpstmt->lpISAMTableList);
            lpstmt->lpISAMTableList = NULL;
        }
		if (lpstmt->lpISAMQualifierList != NULL) {
            ISAMFreeQualifierList(lpstmt->lpISAMQualifierList);
            lpstmt->lpISAMQualifierList = NULL;
        }
        (lpstmt->szTableName)[0] = 0;
		(lpstmt->szTableType)[0] = 0;
		(lpstmt->szQualifierName)[0] = 0;
        if (lpstmt->lpISAMTableDef != NULL) {
            ISAMCloseTable(lpstmt->lpISAMTableDef);
            lpstmt->lpISAMTableDef = NULL;
        }
        (lpstmt->szColumnName)[0] = 0;
        if (lpstmt->lpKeyInfo != NULL) {
            GlobalUnlock (GlobalPtrHandle(lpstmt->lpKeyInfo));
            GlobalFree (GlobalPtrHandle(lpstmt->lpKeyInfo));
        }
        if ((lpstmt->lpSqlStmt != NULL) && !(lpstmt->fPreparedSql)) {
            FreeTree(lpstmt->lpSqlStmt);
            lpstmt->lpSqlStmt = NULL;
            lpstmt->fPreparedSql = FALSE;
            if (lpstmt->lpISAMStatement != NULL) {
                ISAMFreeStatement(lpstmt->lpISAMStatement);
                lpstmt->lpISAMStatement = NULL;
            }
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;

        lpstmt->icol = NO_COLUMN;
        lpstmt->cbOffset = 0;
        break;

    case SQL_DROP:

        /* Terminate the active statement */
        err = SQLFreeStmt(hstmt, SQL_CLOSE);
        if ((err != SQL_SUCCESS) && (err != SQL_SUCCESS_WITH_INFO)) {
            lpstmt->fStmtType = STMT_TYPE_NONE;
            err = SQLTransact(SQL_NULL_HENV, (HDBC)lpstmt->lpdbc, SQL_ROLLBACK);
            SQLFreeStmt(hstmt, SQL_CLOSE);
        }
        if (lpstmt->lpSqlStmt != NULL) {
            FreeTree(lpstmt->lpSqlStmt);
            lpstmt->lpSqlStmt = NULL;
            lpstmt->fPreparedSql = FALSE;
            if (lpstmt->lpISAMStatement != NULL) {
                ISAMFreeStatement(lpstmt->lpISAMStatement);
                lpstmt->lpISAMStatement = NULL;
            }
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;
        lpstmt->cRowCount = -1;

        /*/ Unbind everything */
        SQLFreeStmt(hstmt, SQL_UNBIND);

        /* Reset the parameters */
        SQLFreeStmt(hstmt, SQL_RESET_PARAMS);

        /* Take statement off of list of statements for the connection */
        if (lpstmt->lpdbc->lpstmts == lpstmt) {
            lpstmt->lpdbc->lpstmts = lpstmt->lpNext;
        }
        else {
            lpstmtPrev = lpstmt->lpdbc->lpstmts;
            while (lpstmtPrev->lpNext != lpstmt)
                lpstmtPrev = lpstmtPrev->lpNext;
            lpstmtPrev->lpNext = lpstmt->lpNext;
        }

        /* Dealloate the memory */
        GlobalUnlock (GlobalPtrHandle(hstmt));
        GlobalFree (GlobalPtrHandle(hstmt));
        break;

    case SQL_UNBIND:

        /* Remove all the bindings */
        while (lpstmt->lpBound != NULL) {
            lpBound = lpstmt->lpBound->lpNext;
            GlobalUnlock (GlobalPtrHandle(lpstmt->lpBound));
            GlobalFree (GlobalPtrHandle(lpstmt->lpBound));
            lpstmt->lpBound = lpBound;
        }
        break;

    case SQL_RESET_PARAMS:

        /* It is not possible to reset the parameters while setting them */
        if (lpstmt->fNeedData) {
            lpstmt->errcode = ERR_CURSORSTATE;
            return SQL_ERROR;
        }

        /* Reset all the parameters */
        while (lpstmt->lpParameter != NULL) {
            lpParameter = lpstmt->lpParameter->lpNext;
            GlobalUnlock (GlobalPtrHandle(lpstmt->lpParameter));
            GlobalFree (GlobalPtrHandle(lpstmt->lpParameter));
            lpstmt->lpParameter = lpParameter;
        }
        break;
    }

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLPrepare(
    HSTMT     hstmt,
    UCHAR FAR *szSqlStr,
    SDWORD    cbSqlStr)
{
    LPSTMT     lpstmt;
    LPSQLNODE  lpSqlNode;
    UCHAR      szCursorname[MAX_CURSOR_NAME_LENGTH];
    int        i;
    UCHAR      szSimpleSql[21 + MAX_TABLE_NAME_LENGTH + 1];
    UWORD      parameterCount;
    SQLNODEIDX idxParameter;
    SQLNODEIDX idxParameterPrev;
    UWORD      id;

#define MAX(a, b) ((a) > (b) ? (a) : (b))

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	CString myInputString;
	myInputString.Format("\nWBEM ODBC Driver :SQLPrepare :\nszSqlStr = %s\ncbSqlStr = %ld\n",
							szSqlStr, cbSqlStr);
	ODBCTRACE(myInputString);

    MyImpersonator im (lpstmt,"SQLPrepare");

    /* Error if in the middle of a statement already */
    if (lpstmt->fStmtType != STMT_TYPE_NONE) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }
    if (lpstmt->fNeedData) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    /* Free previously prepared statement if any */
    if (lpstmt->lpSqlStmt != NULL) {        
        FreeTree(lpstmt->lpSqlStmt);
        lpstmt->lpSqlStmt = NULL;
        lpstmt->fPreparedSql = FALSE;
        if (lpstmt->lpISAMStatement != NULL) {
            ISAMFreeStatement(lpstmt->lpISAMStatement);
            lpstmt->lpISAMStatement = NULL;
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;
        lpstmt->cRowCount = -1;
    }

    /* Count of rows is not available */
    lpstmt->cRowCount = -1;

    /* Try passing the statement down to the ISAM layer */
    if (cbSqlStr == SQL_NTS)
	{
		if (szSqlStr)
			cbSqlStr = s_lstrlen((char*)szSqlStr);
		else
			cbSqlStr = 0;
	}
	szSimpleSql[0] = 0;
    s_lstrcpy(szSimpleSql, "SELECT * FROM \"");
    lpstmt->errcode = ISAMPrepare(lpstmt->lpdbc->lpISAM, szSqlStr, cbSqlStr,
                               &(lpstmt->lpISAMStatement), (LPUSTR) (szSimpleSql + 15),
                               &parameterCount, lpstmt);
    if (lpstmt->errcode == ISAM_NOTSUPPORTED) 
	{
		//Check if we are in passthrough only mode
		if (lpstmt->lpdbc->lpISAM->fPassthroughOnly)
		{
			ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
			return SQL_ERROR;
		}
		else
		{
			lpstmt->lpISAMStatement = NULL;
			parameterCount = 0;
		}
    }
    else if (lpstmt->errcode != NO_ISAM_ERR) {
        ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
        return SQL_ERROR;
    }
    else
        lpstmt->fISAMTxnStarted = TRUE;


    /* Was the SQL passthrough rejected or is it returning a result set? */
    if ((lpstmt->errcode == ISAM_NOTSUPPORTED) ||
                  (s_lstrlen((szSimpleSql + 15)) != 0)) {

        /* Yes.  Parse the statement */
        if (lpstmt->errcode == ISAM_NOTSUPPORTED) {
            lpstmt->errcode = Parse(lpstmt, lpstmt->lpdbc->lpISAM, (LPUSTR)szSqlStr,
                                cbSqlStr, &(lpstmt->lpSqlStmt));
        }
        else {
            s_lstrcat(szSimpleSql, "\"");

			//NEW
			//Sai Wong - removed this Parse as it has already been 
			//done in ISAMPrepare

			//Changed again
			//Parse SELECT * from WBEMDR32VirtualTable
            lpstmt->errcode = Parse(lpstmt, lpstmt->lpdbc->lpISAM,
                     szSimpleSql, s_lstrlen(szSimpleSql), &(lpstmt->lpSqlStmt));
        }
        if (lpstmt->errcode != SQL_SUCCESS) {
            if (lpstmt->lpISAMStatement != NULL) {
                ISAMFreeStatement(lpstmt->lpISAMStatement);
                lpstmt->lpISAMStatement = NULL;
            }
            return SQL_ERROR;
        }
        
        /* Semanticize the parsed statement */
        lpstmt->errcode = SemanticCheck(lpstmt, &(lpstmt->lpSqlStmt),
              ROOT_SQLNODE, FALSE, ISAMCaseSensitive(lpstmt->lpdbc->lpISAM),
              NO_SQLNODE, NO_SQLNODE);
        if (lpstmt->errcode != SQL_SUCCESS) {
            FreeTree(lpstmt->lpSqlStmt);
            lpstmt->lpSqlStmt = NULL;
            if (lpstmt->lpISAMStatement != NULL) {
                ISAMFreeStatement(lpstmt->lpISAMStatement);
                lpstmt->lpISAMStatement = NULL;
            }
            return SQL_ERROR;
        }

        /* Optimize execution */
        lpstmt->errcode = Optimize(lpstmt->lpSqlStmt,
                     ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE)->node.root.sql,
                     ISAMCaseSensitive(lpstmt->lpdbc->lpISAM));
        if (lpstmt->errcode != SQL_SUCCESS) {
            FreeTree(lpstmt->lpSqlStmt);
            lpstmt->lpSqlStmt = NULL;
            if (lpstmt->lpISAMStatement != NULL) {
                ISAMFreeStatement(lpstmt->lpISAMStatement);
                lpstmt->lpISAMStatement = NULL;
            }
            return SQL_ERROR;
        }
#if ISAM_TRACE
        ShowSemantic(lpstmt->lpSqlStmt, ROOT_SQLNODE, 0);
#endif
    }
    else {

#ifdef IMPLTMT_PASSTHROUGH
		//No nothing
#else
        /* No.  Create a PASSTHROUGH parse tree */
        lpstmt->errcode = Parse(lpstmt, lpstmt->lpdbc->lpISAM, (LPUSTR) "SQL",
                                3, &(lpstmt->lpSqlStmt));
        if (lpstmt->errcode != SQL_SUCCESS) {
            ISAMFreeStatement(lpstmt->lpISAMStatement);
            lpstmt->lpISAMStatement = NULL;
            return SQL_ERROR;
        }
#endif
    }

    /* Are there pass through parameters? */
    if (parameterCount != 0) {

        /* Yes.  Create them */
        idxParameterPrev = NO_SQLNODE;
        for (id = 1; id <= parameterCount; id++) {

            /* Create the next parameter */
            idxParameter = AllocateNode(&(lpstmt->lpSqlStmt),
                                        NODE_TYPE_PARAMETER);
            if (idxParameter == NO_SQLNODE) {
                FreeTree(lpstmt->lpSqlStmt);
                lpstmt->lpSqlStmt = NULL;
                ISAMFreeStatement(lpstmt->lpISAMStatement);
                lpstmt->lpISAMStatement = NULL;
                lpstmt->errcode = ERR_MEMALLOCFAIL;
                return SQL_ERROR;
            }
            lpSqlNode = ToNode(lpstmt->lpSqlStmt, idxParameter);
            lpSqlNode->node.parameter.Id = id;
            lpSqlNode->node.parameter.Next = NO_SQLNODE;
            lpSqlNode->node.parameter.Value = NO_STRING;
            lpSqlNode->node.parameter.AtExec = FALSE;

            /* Put it on the list */
            if (idxParameterPrev == NO_SQLNODE) {
                lpSqlNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
                lpSqlNode->node.root.parameters = idxParameter;
                lpSqlNode->node.root.passthroughParams = TRUE;
            }
            else {
                lpSqlNode = ToNode(lpstmt->lpSqlStmt, idxParameterPrev);
                lpSqlNode->node.parameter.Next = idxParameter;
            }
            idxParameterPrev = idxParameter;

            /* Semantic check the newly created parameter */
            lpstmt->errcode = SemanticCheck(lpstmt, &(lpstmt->lpSqlStmt),
               idxParameter, FALSE, ISAMCaseSensitive(lpstmt->lpdbc->lpISAM),
               NO_SQLNODE, NO_SQLNODE);
            if (lpstmt->errcode != SQL_SUCCESS) {
                FreeTree(lpstmt->lpSqlStmt);
                lpstmt->lpSqlStmt = NULL;
                ISAMFreeStatement(lpstmt->lpISAMStatement);
                lpstmt->lpISAMStatement = NULL;
                return SQL_ERROR;
            }

            /* All passthrough parameters are strings */
	    lpSqlNode = ToNode(lpstmt->lpSqlStmt, idxParameter);
            lpSqlNode->sqlDataType = TYPE_CHAR;
            lpSqlNode->sqlSqlType = SQL_VARCHAR;
            lpSqlNode->sqlPrecision = MAX_CHAR_LITERAL_LENGTH;
            lpSqlNode->sqlScale = NO_SCALE;
        }
    }

    /* Allocate space for the parameters */
    lpSqlNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
    for (idxParameter = lpSqlNode->node.root.parameters;
         idxParameter != NO_SQLNODE;
         idxParameter = lpSqlNode->node.parameter.Next) {

        /* Get parameter node */
        lpSqlNode = ToNode(lpstmt->lpSqlStmt, idxParameter);

        /* Allocate space for the parameter value */
        switch (lpSqlNode->sqlDataType) {
        case TYPE_DOUBLE:
            lpSqlNode->node.parameter.Value = NO_STRING;
            break;
        case TYPE_NUMERIC:
            lpSqlNode->node.parameter.Value = AllocateSpace(&(lpstmt->lpSqlStmt),
                                    (SWORD)(lpSqlNode->sqlPrecision + 2 + 1));
            if (lpSqlNode->node.parameter.Value == NO_STRING) {
                FreeTree(lpstmt->lpSqlStmt);
                lpstmt->lpSqlStmt = NULL;
                if (lpstmt->lpISAMStatement != NULL) {
                    ISAMFreeStatement(lpstmt->lpISAMStatement);
                    lpstmt->lpISAMStatement = NULL;
                }
                lpstmt->errcode = ERR_MEMALLOCFAIL;
                return SQL_ERROR;
            }
            break;
        case TYPE_INTEGER:
            lpSqlNode->node.parameter.Value = NO_STRING;
            break;
        case TYPE_CHAR:
            lpSqlNode->node.parameter.Value = AllocateSpace(&(lpstmt->lpSqlStmt),
                                      MAX_CHAR_LITERAL_LENGTH+1);
            if (lpSqlNode->node.parameter.Value == NO_STRING) {
                FreeTree(lpstmt->lpSqlStmt);
                lpstmt->lpSqlStmt = NULL;
                if (lpstmt->lpISAMStatement != NULL) {
                    ISAMFreeStatement(lpstmt->lpISAMStatement);
                    lpstmt->lpISAMStatement = NULL;
                }
                lpstmt->errcode = ERR_MEMALLOCFAIL;
                return SQL_ERROR;
            }
            break;
        case TYPE_BINARY:
            lpSqlNode->node.parameter.Value = AllocateSpace(&(lpstmt->lpSqlStmt),
                                MAX_BINARY_LITERAL_LENGTH + sizeof(SDWORD));
            if (lpSqlNode->node.parameter.Value == NO_STRING) {
                FreeTree(lpstmt->lpSqlStmt);
                lpstmt->lpSqlStmt = NULL;
                if (lpstmt->lpISAMStatement != NULL) {
                    ISAMFreeStatement(lpstmt->lpISAMStatement);
                    lpstmt->lpISAMStatement = NULL;
                }
                lpstmt->errcode = ERR_MEMALLOCFAIL;
                return SQL_ERROR;
            }
            break;
        case TYPE_DATE:
            lpSqlNode->node.parameter.Value = NO_STRING;
            break;
        case TYPE_TIME:
            lpSqlNode->node.parameter.Value = NO_STRING;
            break;
        case TYPE_TIMESTAMP:
            lpSqlNode->node.parameter.Value = NO_STRING;
            break;
        case TYPE_UNKNOWN:
            /* Error if '?' used in a select list */
            if (parameterCount == 0)
                lpstmt->errcode = ERR_PARAMINSELECT;
            else
                lpstmt->errcode = ERR_INTERNAL;
            return SQL_ERROR;
        default:
            lpstmt->errcode = ERR_NOTSUPPORTED;
            return SQL_ERROR;
        }
    }

    /* Was a SELECT statement preprared? */
    lpSqlNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
    lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.root.sql);
    if (lpSqlNode->sqlNodeType == NODE_TYPE_SELECT) {

        /* Yes.  Is a cursor name needed? */
        if (s_lstrlen(lpstmt->szCursor) == 0) {

            /* Yes.  Assign one */
            for (i=0; TRUE; i++) {
                wsprintf((LPSTR)szCursorname, "CUR%05d", (SWORD)i);
                if (SQLSetCursorName(hstmt, (LPUSTR) szCursorname, SQL_NTS) ==
                                                            SQL_SUCCESS)
                    break;
            }
        }
    }

    /* Mark the statement as from SQLPrepare() */
    lpstmt->fPreparedSql = TRUE;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLBindParameter(
    HSTMT      hstmt,
    UWORD      ipar,
    SWORD      fParamType,
    SWORD      fCType,
    SWORD      fSqlType,
    UDWORD     cbColDef,
    SWORD      ibScale,
    PTR        rgbValue,
    SDWORD     cbValueMax,
    SDWORD FAR *pcbValue)
{
    LPSTMT      lpstmt;
    LPPARAMETER lpParameter;
    HGLOBAL     hParameter;
    LPSQLTYPE   lpSqlType;
    UWORD       i;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpstmt, "SQLBindParameter");

    /* Error if in the middle of a statement already */
    if (lpstmt->fNeedData) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    /* If SQL_C_DEFAULT was specified as the type, figure out the real type */
    if (fCType == SQL_C_DEFAULT) {
        switch (fSqlType) {
        case SQL_CHAR:
        case SQL_VARCHAR:
        case SQL_LONGVARCHAR:
            fCType = SQL_C_CHAR;
            break;
        case SQL_BIGINT:
        case SQL_DECIMAL:
        case SQL_NUMERIC:
            fCType = SQL_C_CHAR;
            break;
        case SQL_DOUBLE:
        case SQL_FLOAT:
            fCType = SQL_C_DOUBLE;
            break;
        case SQL_BIT:
            fCType = SQL_C_BIT;
            break;
        case SQL_REAL:
            fCType = SQL_C_FLOAT;
            break;
        case SQL_INTEGER:
            fCType = SQL_C_LONG;
            break;
        case SQL_SMALLINT:
            fCType = SQL_C_SHORT;
            break;
        case SQL_TINYINT:
            fCType = SQL_C_TINYINT;
            break;
        case SQL_DATE:
            fCType = SQL_C_DATE;
            break;
        case SQL_TIME:
            fCType = SQL_C_TIME;
            break;
        case SQL_TIMESTAMP:
            fCType = SQL_C_TIMESTAMP;
            break;
        case SQL_BINARY:
        case SQL_VARBINARY:
        case SQL_LONGVARBINARY:
            fCType = SQL_C_BINARY;
            break;
        default:
            lpstmt->errcode = ERR_NOTSUPPORTED;
            return SQL_ERROR;
        }
    }

    /* If C type is SQL_C_TINYINT, figure out if it is signed or unsigned */
    if (fCType == SQL_C_TINYINT) {
        lpSqlType = NULL;
        for (i = 0; i < lpstmt->lpdbc->lpISAM->cSQLTypes; i++) {
            if (lpstmt->lpdbc->lpISAM->SQLTypes[i].type == SQL_TINYINT) {
                lpSqlType = &(lpstmt->lpdbc->lpISAM->SQLTypes[i]);
                break;
            }
        }
        if (lpSqlType == NULL)
            fCType = SQL_C_STINYINT;
        else if (lpSqlType->unsignedAttribute == TRUE)
            fCType = SQL_C_UTINYINT;
        else
            fCType = SQL_C_STINYINT;
    }

    /* If C type is SQL_C_SHORT, figure out if it is signed or unsigned */
    if (fCType == SQL_C_SHORT) {
        lpSqlType = NULL;
        for (i = 0; i < lpstmt->lpdbc->lpISAM->cSQLTypes; i++) {
            if (lpstmt->lpdbc->lpISAM->SQLTypes[i].type == SQL_SMALLINT) {
                lpSqlType = &(lpstmt->lpdbc->lpISAM->SQLTypes[i]);
                break;
            }
        }
        if (lpSqlType == NULL)
            fCType = SQL_C_SSHORT;
        else if (lpSqlType->unsignedAttribute == TRUE)
            fCType = SQL_C_USHORT;
        else
            fCType = SQL_C_SSHORT;
    }

    /* If C type is SQL_C_LONG, figure out if it is signed or unsigned */
    if (fCType == SQL_C_LONG) {
        lpSqlType = NULL;
        for (i = 0; i < lpstmt->lpdbc->lpISAM->cSQLTypes; i++) {
            if (lpstmt->lpdbc->lpISAM->SQLTypes[i].type == SQL_INTEGER) {
                lpSqlType = &(lpstmt->lpdbc->lpISAM->SQLTypes[i]);
                break;
            }
        }
        if (lpSqlType == NULL)
            fCType = SQL_C_SLONG;
        else if (lpSqlType->unsignedAttribute == TRUE)
            fCType = SQL_C_ULONG;
        else
            fCType = SQL_C_SLONG;
    }
    
    /* Ignore output parameters */
    if (fParamType == SQL_PARAM_OUTPUT)
        return SQL_SUCCESS;

    /* Find the parameter is on the list */
    lpParameter = lpstmt->lpParameter;
    while (lpParameter != NULL) {
        if (lpParameter->ipar == ipar)
            break;
        lpParameter = lpParameter->lpNext;
    }

    /* No.  Was it on the list? */
    if (lpParameter == NULL) {

        /* No.  Make an entry for it */
        hParameter = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (PARAMETER));
        if (hParameter == NULL || (lpParameter = (LPPARAMETER)GlobalLock (hParameter)) == NULL) {
            
            if (hParameter)
                GlobalFree(hParameter);

            lpstmt->errcode = ERR_MEMALLOCFAIL;
            return SQL_ERROR;
        }
        lpParameter->lpNext = lpstmt->lpParameter;
        lpstmt->lpParameter = lpParameter;
        lpParameter->ipar = ipar;
    }

    /* Save the bound description */
    lpParameter->fCType =   fCType;
    lpParameter->rgbValue = rgbValue;
    lpParameter->pcbValue = pcbValue;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLDescribeParam(
    HSTMT      hstmt,
    UWORD      ipar,
    SWORD  FAR *pfSqlType,
    UDWORD FAR *pcbColDef,
    SWORD  FAR *pibScale,
    SWORD  FAR *pfNullable)
{
    LPSTMT  lpstmt;

    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/

RETCODE SQL_API SQLParamOptions(
    HSTMT      hstmt,
    UDWORD     crow,
    UDWORD FAR *pirow)
{
    LPSTMT  lpstmt;

    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/

RETCODE SQL_API SQLNumParams(
    HSTMT      hstmt,
    SWORD  FAR *pcpar)
{
    LPSTMT  lpstmt;

    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/

RETCODE SQL_API SQLSetScrollOptions(
    HSTMT      hstmt,
    UWORD      fConcurrency,
    SDWORD  crowKeyset,
    UWORD      crowRowset)
{
    LPSTMT  lpstmt;

    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/

RETCODE SQL_API SQLSetCursorName(
    HSTMT     hstmt,
    UCHAR FAR *szCursor,
    SWORD     cbCursor)
{
    SWORD     cbIn;
    LPSTMT    lpstmt;
    UCHAR     szCursorname[MAX_CURSOR_NAME_LENGTH];
    LPSTMT    lpstmtOther;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpstmt, "SQLSetCursorName");

    /* Get length of cursor name */
    if (cbCursor == SQL_NTS)
        cbIn = (SWORD) s_lstrlen(szCursor);
    else
        cbIn = cbCursor;

    if ((cbIn <= 0) || (cbIn >= MAX_CURSOR_NAME_LENGTH)) {
        lpstmt->errcode = ERR_INVALIDCURSORNAME;
        return SQL_ERROR;
    }

    /* Make a null terminated copy of the cursor name */
    _fmemcpy(szCursorname, szCursor, cbIn);
    szCursorname[cbIn] = '\0';

    /* Make sure name is not already in use */
    for (lpstmtOther = lpstmt->lpdbc->lpstmts;
         lpstmtOther != NULL;
         lpstmtOther = lpstmtOther->lpNext) {
        if (lpstmtOther != lpstmt) {
            if (!s_lstrcmpi(lpstmtOther->szCursor, szCursorname)) {
                lpstmt->errcode = ERR_CURSORNAMEINUSE;
                return SQL_ERROR;
            }
        }
    }

    /* Save cursor name */
    s_lstrcpy(lpstmt->szCursor, szCursorname);

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLGetCursorName(
    HSTMT     hstmt,
    UCHAR FAR *szCursor,
    SWORD     cbCursorMax,
    SWORD FAR *pcbCursor)
{
    LPSTMT    lpstmt;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpstmt, "SQLGetCursorName");

    /* Return cursor name */
    lpstmt->errcode = ReturnString(szCursor, cbCursorMax,
                                   pcbCursor, (LPUSTR)lpstmt->szCursor);
    if (lpstmt->errcode == ERR_DATATRUNCATED)
        return SQL_SUCCESS_WITH_INFO;

    return SQL_SUCCESS;
}
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\scalar.h ===
/***************************************************************************/
/* SCALAR.H                                                                */
/* Copyright (C) 1997 SYWARE Inc., All rights reserved                     */
/***************************************************************************/
RETCODE INTFUNC ScalarCheck(LPSTMT lpstmt, LPSQLTREE FAR *lplpSql,
       SQLNODEIDX idxNode, BOOL fIsGroupby, BOOL fCaseSensitive,
       SQLNODEIDX idxNodeTableOuterJoinFromTables,
       SQLNODEIDX idxEnclosingStatement);
RETCODE INTFUNC EvaluateScalar(LPSTMT lpstmt, LPSQLNODE lpSqlNode);
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\results.cpp ===
/***************************************************************************/
/* RESULTS.C                                                               */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"

#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"

/***************************************************************************/
BOOL INTFUNC GetUnsignedAttribute(LPSTMT lpstmt, SWORD fSqlType)
{
    UWORD i;

    for (i = 0; i < lpstmt->lpdbc->lpISAM->cSQLTypes; i++) {
        if (lpstmt->lpdbc->lpISAM->SQLTypes[i].type == fSqlType) {
            if (lpstmt->lpdbc->lpISAM->SQLTypes[i].unsignedAttribute == -1)
                return FALSE;
            else
                return lpstmt->lpdbc->lpISAM->SQLTypes[i].unsignedAttribute;
        }
    }
    return FALSE;
}
/***************************************************************************/

RETCODE SQL_API SQLNumResultCols(
    HSTMT     hstmt,
    SWORD FAR *pccol)
{
    RETCODE rc;
    SDWORD ccol;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im ( (LPSTMT)hstmt, "SQLNumResultCols" );

    /* Find the number of columns */
    rc = SQL_SUCCESS;
    if (pccol != NULL) {
        rc = SQLColAttributes(hstmt, 0, SQL_COLUMN_COUNT, NULL,
              0, NULL, &ccol);
        if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO))
            return rc;
        *pccol = (SWORD) ccol;
    }
    return rc;
}

/***************************************************************************/

RETCODE SQL_API SQLDescribeCol(
    HSTMT      hstmt,
    UWORD      icol,
    UCHAR  FAR *szColName,
    SWORD      cbColNameMax,
    SWORD  FAR *pcbColName,
    SWORD  FAR *pfSqlType,
    UDWORD FAR *pcbColDef,
    SWORD  FAR *pibScale,
    SWORD  FAR *pfNullable)
{
    RETCODE rc;
    SDWORD fDesc;
    LPSTMT  lpstmt;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;


	MyImpersonator im (lpstmt, "SQLDecribeCol");

    /* Get each piece of information (get the column name last so that */
    /* if there is a truncation warning it will not get lost).         */
    rc = SQL_SUCCESS;

    if (pfSqlType != NULL) {
        rc = SQLColAttributes(hstmt, icol, SQL_COLUMN_TYPE, NULL,
                              0, NULL, &fDesc);
        if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO))
            return rc;
        *pfSqlType = (SWORD) fDesc;
    }

    if (pcbColDef != NULL) {
        rc = SQLColAttributes(hstmt, icol, SQL_COLUMN_PRECISION, NULL,
                              0, NULL, &fDesc);
        if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO))
            return rc;
        *pcbColDef = (UDWORD) fDesc;

		//Added by Sai Wong
		if ( (SDWORD)fDesc == SQL_NO_TOTAL)
		{
			*pcbColDef = 0;
		}
    }

    if (pibScale != NULL) {
        rc = SQLColAttributes(hstmt, icol, SQL_COLUMN_SCALE, NULL,
                              0, NULL, &fDesc);
        if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO))
            return rc;
        *pibScale = (SWORD) fDesc;
    }

    if (pfNullable != NULL) {
        rc = SQLColAttributes(hstmt, icol, SQL_COLUMN_NULLABLE, NULL,
                              0, NULL, &fDesc);
        if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO))
            return rc;
        *pfNullable = (SWORD) fDesc;
    }

    if ((szColName != NULL) || (pcbColName)) {
        rc = SQLColAttributes(hstmt, icol, SQL_COLUMN_NAME, szColName,
                               cbColNameMax, pcbColName, NULL);
        if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO))
            return rc;
    }

    return rc;
}

/***************************************************************************/

RETCODE SQL_API SQLColAttributes(
    HSTMT      hstmt,
    UWORD      icol,
    UWORD      fDescType,
    PTR        rgbDesc,
    SWORD      cbDescMax,
    SWORD  FAR *pcbDesc,
    SDWORD FAR *pfDesc)
{
    LPSTMT      lpstmt;
    UINT        fStmtType;
    LPSQLNODE   lpSqlNode;
    RETCODE     rc;
    UWORD       count;
    LPSQLTYPE   lpSqlType;
    STRINGIDX   idxAlias;
    UWORD       i;
    LPSQLNODE   lpSqlNodeTable;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpstmt, "SQLColAttributes");

    /* Get the statement type */
    fStmtType = lpstmt->fStmtType;
    
    /* Is there a prepared statement? */
    if (fStmtType == STMT_TYPE_NONE) {
        if (lpstmt->lpSqlStmt != NULL) {
        
            /* Yes.  Determine the statement type */
            lpSqlNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
            lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.root.sql);
            switch (lpSqlNode->sqlNodeType) {
            case NODE_TYPE_SELECT:
                fStmtType = STMT_TYPE_SELECT;
                break;
            case NODE_TYPE_INSERT:
            case NODE_TYPE_DELETE:
            case NODE_TYPE_UPDATE:
            case NODE_TYPE_CREATE:
            case NODE_TYPE_DROP:
            case NODE_TYPE_CREATEINDEX:
            case NODE_TYPE_DROPINDEX:
            case NODE_TYPE_PASSTHROUGH:
                /* Update statements have no results */
                if (fDescType != SQL_COLUMN_COUNT) {
                    lpstmt->errcode = ERR_INVALIDCOLUMNID;
                    return SQL_ERROR;
                }
                if (pfDesc != NULL)
                    *pfDesc = 0;
                return SQL_SUCCESS;
            default:
                lpstmt->errcode = ERR_INTERNAL;
                return SQL_ERROR;
            }
        }
    }
    
    /* Get the attribute */
    switch (fStmtType) { 

    case STMT_TYPE_NONE:
        if (fDescType != SQL_COLUMN_COUNT) {
            lpstmt->errcode = ERR_CURSORSTATE;
            return SQL_ERROR;
        }
        if (pfDesc != NULL)
            *pfDesc = 0;
        break;

    /* Look these answer up in the colAttributes table */
    case STMT_TYPE_TABLES:
    case STMT_TYPE_COLUMNS:
    case STMT_TYPE_STATISTICS:
    case STMT_TYPE_SPECIALCOLUMNS:
    case STMT_TYPE_TYPEINFO:
    case STMT_TYPE_PRIMARYKEYS:
    case STMT_TYPE_FOREIGNKEYS:

        /* Just want the number of columns? */
        if (fDescType == SQL_COLUMN_COUNT) {
            if (pfDesc != NULL)
                *pfDesc = colAttributes[lpstmt->fStmtType][0].count;
        }
        else if (icol > colAttributes[lpstmt->fStmtType][0].count) {
            lpstmt->errcode = ERR_INVALIDCOLUMNID;
            return SQL_ERROR;
        }
        else {
            switch (fDescType) {
            case SQL_COLUMN_COUNT:
                if (pfDesc != NULL)
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].count;
                break;
            case SQL_COLUMN_AUTO_INCREMENT:
                if (pfDesc != NULL)
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].autoIncrement;
                break;
            case SQL_COLUMN_CASE_SENSITIVE:
                if (pfDesc != NULL) {
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].caseSensitive;
                    if (*pfDesc == -2)
                        *pfDesc = ISAMCaseSensitive(lpstmt->lpdbc->lpISAM);
                }
                break;
            case SQL_COLUMN_DISPLAY_SIZE:
                if (pfDesc != NULL)
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].displaySize;
                break;
            case SQL_COLUMN_LABEL:
                lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc,
                              colAttributes[lpstmt->fStmtType][icol].label);
                if (lpstmt->errcode == ERR_DATATRUNCATED)
                    return SQL_SUCCESS_WITH_INFO;
                break;
            case SQL_COLUMN_LENGTH:
                if (pfDesc != NULL)
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].length;
                break;
            case SQL_COLUMN_MONEY:
                if (pfDesc != NULL)
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].money;
                break;
            case SQL_COLUMN_NAME:
                lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc,
                                colAttributes[lpstmt->fStmtType][icol].name);
                if (lpstmt->errcode == ERR_DATATRUNCATED)
                    return SQL_SUCCESS_WITH_INFO;
                break;
            case SQL_COLUMN_NULLABLE:
                if (pfDesc != NULL)
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].nullable;
                break;
            case SQL_COLUMN_OWNER_NAME:
                lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc,
                           colAttributes[lpstmt->fStmtType][icol].ownerName);
                if (lpstmt->errcode == ERR_DATATRUNCATED)
                    return SQL_SUCCESS_WITH_INFO;
                break;
            case SQL_COLUMN_PRECISION:
                if (pfDesc != NULL)
                    *pfDesc = (SDWORD)
                colAttributes[lpstmt->fStmtType][icol].precision;
                break;
            case SQL_COLUMN_QUALIFIER_NAME:
                lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc,
                       colAttributes[lpstmt->fStmtType][icol].qualifierName);
                if (lpstmt->errcode == ERR_DATATRUNCATED)
                    return SQL_SUCCESS_WITH_INFO;
                break;
            case SQL_COLUMN_SCALE:
                if (pfDesc != NULL)
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].scale;
                break;
            case SQL_COLUMN_SEARCHABLE:
                if (pfDesc != NULL)
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].columnSearchable;
                break;
            case SQL_COLUMN_TABLE_NAME:
                lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc,
                           colAttributes[lpstmt->fStmtType][icol].tableName);
                if (lpstmt->errcode == ERR_DATATRUNCATED)
                    return SQL_SUCCESS_WITH_INFO;
                break;
            case SQL_COLUMN_TYPE:
                if (pfDesc != NULL)
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].type;
                break;
            case SQL_COLUMN_TYPE_NAME:
                lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc,
                           (LPUSTR) colAttributes[lpstmt->fStmtType][icol].typeName);
                if (lpstmt->errcode == ERR_DATATRUNCATED)
                    return SQL_SUCCESS_WITH_INFO;
                break;
            case SQL_COLUMN_UNSIGNED:
                if (pfDesc != NULL)
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].unsignedAttribute;
                break;
            case SQL_COLUMN_UPDATABLE:
                if (pfDesc != NULL)
                    *pfDesc = colAttributes[lpstmt->fStmtType][icol].updatable;
                break;
            default:
                lpstmt->errcode = ERR_NOTSUPPORTED;
                return SQL_ERROR;
            }
        }
        break;

    case STMT_TYPE_SELECT:
        
        /* Get the list of columns */
        lpSqlNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
        lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.root.sql);

        /* Handle the special case when there are no columns */
        if (lpSqlNode->node.select.Values == NO_SQLNODE) {
            if (fDescType != SQL_COLUMN_COUNT) {
                lpstmt->errcode = ERR_INVALIDCOLUMNID;
                return SQL_ERROR;
            }
            else {
                if (pfDesc != NULL)
                    *pfDesc = 0;
                return SQL_SUCCESS;
            }
        }

        /* Find the desired column */
        lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.select.Values);
        for (count = 1;
             (count != icol) || (fDescType == SQL_COLUMN_COUNT);
             count++) {
            if (lpSqlNode->node.values.Next == NO_SQLNODE) {
                if (fDescType != SQL_COLUMN_COUNT) {
                    lpstmt->errcode = ERR_INVALIDCOLUMNID;
                    return SQL_ERROR;
                }
                break;
            }
            lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.values.Next);
        }

        /* Column count? */
        if (fDescType != SQL_COLUMN_COUNT) {

            /* No.  Save alias (if any) for later */
            idxAlias = lpSqlNode->node.values.Alias;

            /* No.  Get the column node */
            lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.values.Value);

            /* Column reference? */
            if (lpSqlNode->sqlNodeType == NODE_TYPE_COLUMN) {

                /* Yes.  Get the column definition */
		lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt,
                                         lpSqlNode->node.column.Table);
		ClassColumnInfoBase* cInfoBase = lpSqlNodeTable->node.table.Handle->pColumnInfo;

		if ( !cInfoBase->IsValid() )
		{
			lpstmt->errcode = ERR_ISAM;
                    	return SQL_ERROR;
		}

				
		if ( !cInfoBase->GetDataTypeInfo(lpSqlNode->node.column.Id, lpSqlType) || (!lpSqlType) )
		{
			lpstmt->errcode = ERR_ISAM;
                    	return SQL_ERROR;
		}
            }
            else {
                /* No.  Get the descriptor of the datatype */
                lpSqlType = NULL;
                for (i = 0; i < lpstmt->lpdbc->lpISAM->cSQLTypes; i++) {
                    if (lpstmt->lpdbc->lpISAM->SQLTypes[i].type ==
                                                   lpSqlNode->sqlSqlType) {
                        lpSqlType = &(lpstmt->lpdbc->lpISAM->SQLTypes[i]);
                        break;
                    }
                }
                if (lpSqlType == NULL) {
                    lpstmt->errcode = ERR_ISAM;
                    return SQL_ERROR;
                }
            }
        }

        /* Get the data */
        switch (fDescType) {
        case SQL_COLUMN_AUTO_INCREMENT:
            if (pfDesc != NULL) {
                if (lpSqlType->autoincrement == -1)
                    *pfDesc = FALSE;
                else
                    *pfDesc = lpSqlType->autoincrement;
            }
            break;
        
        case SQL_COLUMN_CASE_SENSITIVE:
            if (pfDesc != NULL)
                *pfDesc = lpSqlType->caseSensitive;
            break;
            
        case SQL_COLUMN_COUNT:
            if (pfDesc != NULL)
                *pfDesc = count;
            break;
        
        case SQL_COLUMN_DISPLAY_SIZE:
            if (pfDesc == NULL)
                break;
            switch (lpSqlType->type) {
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_LONGVARCHAR:
                *pfDesc = lpSqlNode->sqlPrecision;
                break;
            case SQL_DECIMAL:
            case SQL_NUMERIC:
                *pfDesc = lpSqlNode->sqlPrecision + 2;
                break;
            case SQL_BIT:
                *pfDesc = 1;
                break;
            case SQL_TINYINT:
                if (lpSqlType->unsignedAttribute == TRUE)
                    *pfDesc = 3;
                else
                    *pfDesc = 4;
                break;
            case SQL_SMALLINT:
                if (lpSqlType->unsignedAttribute == TRUE)
                    *pfDesc = 5;
                else
                    *pfDesc = 6;
                break;
            case SQL_INTEGER:
                if (lpSqlType->unsignedAttribute == TRUE)
                    *pfDesc = 10;
                else
                    *pfDesc = 11;
                break;
            case SQL_BIGINT:
                if (lpSqlType->unsignedAttribute == TRUE)
                    *pfDesc = lpSqlNode->sqlPrecision;
                else
                    *pfDesc = lpSqlNode->sqlPrecision + 1;
                break;
            case SQL_REAL:
                *pfDesc = 13;
                break;
            case SQL_FLOAT:
            case SQL_DOUBLE:
                *pfDesc = 22;
                break;
            case SQL_DATE:
                *pfDesc = 10;
                break;
            case SQL_TIME:
                *pfDesc = 8;
                break;
            case SQL_TIMESTAMP:
                if (TIMESTAMP_SCALE > 0)
                    *pfDesc = 20 + TIMESTAMP_SCALE;
                else
                    *pfDesc = 19;
                break;
            case SQL_BINARY:
            case SQL_VARBINARY:
            case SQL_LONGVARBINARY:
                *pfDesc = lpSqlNode->sqlPrecision * 2;
                break;
            default:
                lpstmt->errcode = ERR_NOTSUPPORTED;
                return SQL_ERROR;
            }
            break;
            
        case SQL_COLUMN_LABEL:
            rc = SQLColAttributes(hstmt, icol, SQL_COLUMN_NAME, rgbDesc,
                                  cbDescMax, pcbDesc, pfDesc);
            if (rc != SQL_SUCCESS)
                return rc;
            break;
        
        case SQL_COLUMN_LENGTH:
            if (pfDesc == NULL)
                break;
            switch (lpSqlType->type) {
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_LONGVARCHAR:
                *pfDesc = lpSqlNode->sqlPrecision;
                break;
            case SQL_DECIMAL:
            case SQL_NUMERIC:
                *pfDesc = lpSqlNode->sqlPrecision + 2;
                break;
            case SQL_BIT:
                *pfDesc = 1;
                break;
            case SQL_TINYINT:
                *pfDesc = 1;
                break;
            case SQL_SMALLINT:
                *pfDesc = 2;
                break;
            case SQL_INTEGER:
                *pfDesc = 4;
                break;
            case SQL_BIGINT:
                if (lpSqlType->unsignedAttribute == TRUE)
                    *pfDesc = lpSqlNode->sqlPrecision;
                else
                    *pfDesc = lpSqlNode->sqlPrecision + 1;
                break;
            case SQL_REAL:
                *pfDesc = 4;
                break;
            case SQL_FLOAT:
            case SQL_DOUBLE:
                *pfDesc = 8;
                break;
            case SQL_DATE:
                *pfDesc = 6;
                break;
            case SQL_TIME:
                *pfDesc = 6;
                break;
            case SQL_TIMESTAMP:
                *pfDesc = 16;
                break;
            case SQL_BINARY:
            case SQL_VARBINARY:
            case SQL_LONGVARBINARY:
                *pfDesc = lpSqlNode->sqlPrecision;
                break;
            default:
                lpstmt->errcode = ERR_NOTSUPPORTED;
                return SQL_ERROR;
            }
            break;
            
        case SQL_COLUMN_MONEY:
            if (pfDesc != NULL)
                *pfDesc = lpSqlType->money;
            break;
        
        case SQL_COLUMN_NAME:
            if (idxAlias != NO_STRING) {
                lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc,
                                      ToString(lpstmt->lpSqlStmt, idxAlias));
                if (lpstmt->errcode == ERR_DATATRUNCATED)
                    return SQL_SUCCESS_WITH_INFO;
                else if (lpstmt->errcode != ERR_SUCCESS)
                    return SQL_ERROR;
            }
            else if (lpSqlNode->sqlNodeType == NODE_TYPE_COLUMN) {
                lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc,
                                         ToString(lpstmt->lpSqlStmt,
                                                  lpSqlNode->node.column.Column));
                if (lpstmt->errcode == ERR_DATATRUNCATED)
                    return SQL_SUCCESS_WITH_INFO;
                else if (lpstmt->errcode != ERR_SUCCESS)
                    return SQL_ERROR;
            }
            else {
                if ((rgbDesc != NULL) && (cbDescMax > 0))
                    s_lstrcpy(rgbDesc, "");
                if (pcbDesc != NULL)
                    *pcbDesc = 0;
            }
            break;
        
        case SQL_COLUMN_NULLABLE:
            if (pfDesc != NULL) {
//                if (lpSqlNode->sqlNodeType == NODE_TYPE_COLUMN)
//					*pfDesc = FALSE;
//               else
                    *pfDesc = lpSqlType->nullable;
            }
            break;

        case SQL_COLUMN_OWNER_NAME:
            lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc, (LPUSTR) "");
            if (lpstmt->errcode == ERR_DATATRUNCATED)
                return SQL_SUCCESS_WITH_INFO;
            else if (lpstmt->errcode != ERR_SUCCESS)
                return SQL_ERROR;
            break; 
            
        case SQL_COLUMN_PRECISION:
            if (pfDesc == NULL)
                break;
            switch (lpSqlType->type) {
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_LONGVARCHAR:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_BINARY:
            case SQL_VARBINARY:
            case SQL_LONGVARBINARY:
                *pfDesc = lpSqlNode->sqlPrecision;
                break;
            case SQL_BIT:
                *pfDesc = 1;
                break;
            case SQL_TINYINT:
                *pfDesc = 3;
                break;
            case SQL_SMALLINT:
                *pfDesc = 5;
                break;
            case SQL_INTEGER:
                *pfDesc = 10;
                break;
            case SQL_REAL:
                *pfDesc = 7;
                break;
            case SQL_FLOAT:
            case SQL_DOUBLE:
                *pfDesc = 15;
                break;
            case SQL_DATE:
                *pfDesc = 10;
                break;
            case SQL_TIME:
                *pfDesc = 8;
                break;
            case SQL_TIMESTAMP:
                if (TIMESTAMP_SCALE > 0)
                    *pfDesc = 20 + TIMESTAMP_SCALE;
                else
                    *pfDesc = 19;
                break;
            default:
                lpstmt->errcode = ERR_NOTSUPPORTED;
                return SQL_ERROR;
            }
            break;

        case SQL_COLUMN_QUALIFIER_NAME:
            lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc, (LPUSTR) "");
            if (lpstmt->errcode == ERR_DATATRUNCATED)
                return SQL_SUCCESS_WITH_INFO;
            else if (lpstmt->errcode != ERR_SUCCESS)
                return SQL_ERROR;
            break; 
        
        case SQL_COLUMN_SCALE:
            if (pfDesc != NULL) {
                if (lpSqlNode->sqlScale != NO_SCALE)
                    *pfDesc = lpSqlNode->sqlScale;
                else
                    *pfDesc = 0;
            }
            break; 
        
        case SQL_COLUMN_SEARCHABLE:
            if (pfDesc != NULL)
                *pfDesc = lpSqlType->searchable;
            break; 
        
        case SQL_COLUMN_TABLE_NAME:
            if (lpSqlNode->sqlNodeType == NODE_TYPE_COLUMN) {
                lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc,
                                    ToString(lpstmt->lpSqlStmt,
                                             lpSqlNode->node.column.Tablealias));
                if (lpstmt->errcode == ERR_DATATRUNCATED)
                    return SQL_SUCCESS_WITH_INFO;
                else if (lpstmt->errcode != ERR_SUCCESS)
                    return SQL_ERROR;
            }
            else {
                if ((rgbDesc != NULL) && (cbDescMax > 0))
                    s_lstrcpy(rgbDesc, "");
                if (pcbDesc != NULL)
                    *pcbDesc = 0;
            }
            break; 
        
        case SQL_COLUMN_TYPE:
            if (pfDesc != NULL)
                *pfDesc = lpSqlType->type;
            break;
            
        case SQL_COLUMN_TYPE_NAME:
            lpstmt->errcode = ReturnString(rgbDesc, cbDescMax, pcbDesc,
                                              lpSqlType->name);
            if (lpstmt->errcode == ERR_DATATRUNCATED)
                return SQL_SUCCESS_WITH_INFO;
            else if (lpstmt->errcode != ERR_SUCCESS)
                return SQL_ERROR;
            break; 
        
        case SQL_COLUMN_UNSIGNED:
            if (pfDesc != NULL) {
                if (lpSqlType->unsignedAttribute == -1)
                    *pfDesc = TRUE;
                else
                    *pfDesc = lpSqlType->unsignedAttribute;
            }
            break;
        
        case SQL_COLUMN_UPDATABLE:
            if (pfDesc != NULL)
                *pfDesc = SQL_ATTR_READWRITE_UNKNOWN;
            break; 

        default:
            lpstmt->errcode = ERR_NOTSUPPORTED;
            return SQL_ERROR;
        }
        break;
    }
    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLBindCol(
    HSTMT      hstmt,
    UWORD      icol,
    SWORD      fCType,
    PTR        rgbValue,
    SDWORD     cbValueMax,
    SDWORD FAR *pcbValue)
{
    LPSTMT  lpstmt;
    LPBOUND lpBound;
    LPBOUND lpBoundPrev;
    HGLOBAL hBound;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpstmt, "SQLBindCol");

    /* Find the binding is on the list */
    lpBoundPrev = NULL;
    lpBound = lpstmt->lpBound;
    while (lpBound != NULL) {
        if (lpBound->icol == icol)
            break;
        lpBoundPrev = lpBound;
        lpBound = lpBound->lpNext;
    }

    /* Removing the binding? */
    if (rgbValue == NULL) {

        /* Yes.  Was it on the list? */
        if (lpBound != NULL) {

            /* Yes.  Take it off the list */
            if (lpBoundPrev != NULL)
                lpBoundPrev->lpNext = lpBound->lpNext;
            else
                lpstmt->lpBound = lpBound->lpNext;
             GlobalUnlock (GlobalPtrHandle(lpBound));
            GlobalFree (GlobalPtrHandle(lpBound));
        }
    }
    else {

        /* No.  Was it on the list? */
        if (lpBound == NULL) {

            /* No.  Make an entry for it */
            hBound = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (BOUND));
            if (hBound == NULL || (lpBound = (LPBOUND)GlobalLock (hBound)) == NULL) {
                
                if (hBound)
                    GlobalFree(hBound);

                lpstmt->errcode = ERR_MEMALLOCFAIL;
                return SQL_ERROR;
            }
            lpBound->lpNext = lpstmt->lpBound;
            lpstmt->lpBound = lpBound;
            lpBound->icol = icol;
        }

        /* Save the bound description */
        lpBound->fCType =  fCType;
        lpBound->rgbValue = rgbValue;
        lpBound->cbValueMax = cbValueMax;
        lpBound->pcbValue = pcbValue;
    }

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLFetch(
    HSTMT   hstmt)
{
    LPSTMT     lpstmt;
    LPBOUND    lpBound;
    RETCODE    rc;
    RETCODE    errcode;
    LPSQLNODE  lpSqlNode;
    SWORD      err;
    UWORD      index;
    SDWORD     count;
    HGLOBAL    hKeyInfo;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpstmt, "SQLFetch");

    /* Which table? */
    switch (lpstmt->fStmtType) { 

    case STMT_TYPE_NONE:
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;

    /* SQLTables() result... */
    case STMT_TYPE_TABLES:
	{
        /* Error if after the last row */
        if (lpstmt->irow == AFTER_LAST_ROW)
            return SQL_NO_DATA_FOUND;

        /* Point at next row */
        if (lpstmt->irow == BEFORE_FIRST_ROW)
            lpstmt->irow = 0;
        else
            lpstmt->irow++;

        /* Does caller want all the tables or all the table types. */
        switch (lpstmt->fStmtSubtype) 
		{
        case STMT_SUBTYPE_TABLES_TABLES:
		{

            /* All the tables.  If no qualifying tables, return EOT */
            if (lpstmt->lpISAMTableList == NULL) 
			{
                lpstmt->irow = AFTER_LAST_ROW;
                return SQL_NO_DATA_FOUND;
            }

		
			//Find out if we should perform next command
			//synchronously or asynchronously
			UDWORD fSyncMode = SQL_ASYNC_ENABLE_OFF;
			SQLGetStmtOption(lpstmt, SQL_ASYNC_ENABLE, &fSyncMode);


            /* Get next table name */
            err = ISAMGetNextTableName(fSyncMode, lpstmt->lpISAMTableList,
                                       (LPUSTR)lpstmt->szTableName, (LPUSTR)lpstmt->szTableType);

            if (err == ISAM_EOF) 
	    {

                if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                     lpstmt->fISAMTxnStarted = TRUE;

                lpstmt->irow = AFTER_LAST_ROW;
                return SQL_NO_DATA_FOUND;
            }
			else if (err == ISAM_STILL_EXECUTING)
			{
				return SQL_STILL_EXECUTING;
			}
            else if (err != NO_ISAM_ERR) 
			{
                lpstmt->errcode = err;
                ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
                                    (LPUSTR)lpstmt->szISAMError);
                lpstmt->irow = AFTER_LAST_ROW;
                return SQL_ERROR;
            }
            if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                lpstmt->fISAMTxnStarted = TRUE;
		}
            break;

        case STMT_SUBTYPE_TABLES_TYPES:
		{
			(lpstmt->szTableType)[0] = 0;
			switch (lpstmt->irow)
			{
			case 0:
					strcpy( (char*)lpstmt->szTableType, "TABLE");
				break;
			case 1:
					strcpy( (char*)lpstmt->szTableType, "SYSTEM TABLE");
				break;
			default:
				{
					//EOF
					lpstmt->irow = AFTER_LAST_ROW;
					return SQL_NO_DATA_FOUND;
				}
				break;
			}
		}
            break;

		case STMT_SUBTYPE_TABLES_QUALIFIERS:
		{
            
            if (lpstmt->lpISAMQualifierList == NULL) 
			{
                lpstmt->irow = AFTER_LAST_ROW;
                return SQL_NO_DATA_FOUND;
            }

			//Find out if we should perform next command
			//synchronously or asynchronously
			UDWORD fSyncMode = SQL_ASYNC_ENABLE_OFF;
			SQLGetStmtOption(lpstmt, SQL_ASYNC_ENABLE, &fSyncMode);
            /* Get next qualifier name */
            err = ISAMGetNextQualifierName(fSyncMode, lpstmt->lpISAMQualifierList,
                                       (LPUSTR)lpstmt->szQualifierName);
            if (err == ISAM_EOF) 
			{
                lpstmt->irow = AFTER_LAST_ROW;
                return SQL_NO_DATA_FOUND;
            }
			else if (err == ISAM_STILL_EXECUTING)
			{
				return SQL_STILL_EXECUTING;
			}
            else if (err != NO_ISAM_ERR) 
			{
                lpstmt->errcode = err;
                ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
                                    (LPUSTR)lpstmt->szISAMError);
                lpstmt->irow = AFTER_LAST_ROW;
                return SQL_ERROR;
            }
		}
            break;

		case STMT_SUBTYPE_TABLES_OWNERS:
		{
			/* The table ownders.  Has it been returned yet? */
            if (lpstmt->irow != 0) 
			{

                /* Yes.  EOT */
                lpstmt->irow = AFTER_LAST_ROW;
                return SQL_NO_DATA_FOUND;
            }
		}
            break;


        }
        break;
	}
    /* SQLColumns() result... */
    case STMT_TYPE_COLUMNS:
	{
        /* Error if after the last row */
        if (lpstmt->irow == AFTER_LAST_ROW)
            return SQL_NO_DATA_FOUND;

        /* If no qualifying tables, EOT */
        if (lpstmt->lpISAMTableList == NULL) {
            lpstmt->irow = AFTER_LAST_ROW;
            return SQL_NO_DATA_FOUND;
        }
        
        /* Point at next row */
        if (lpstmt->irow == BEFORE_FIRST_ROW)
            lpstmt->irow = 0;
        else
            lpstmt->irow++;

        /* Loop until a column is found */
        while (TRUE) {

            /* If no more columns in the current table... */

			//We need to find out the number of columns in table

			//Find out if we should perform next command
			//synchronously or asynchronously
			UDWORD fSyncMode = SQL_ASYNC_ENABLE_OFF;
			SQLGetStmtOption(lpstmt, SQL_ASYNC_ENABLE, &fSyncMode);


			BOOL fTableDefChange = TRUE;
			UWORD cNumberOfColsInCurrentTable = 0;
			while (  (lpstmt->lpISAMTableDef == NULL) ||
					 ( fTableDefChange && (cNumberOfColsInCurrentTable = GetNumberOfColumnsInTable(lpstmt->lpISAMTableDef) ) && (UWORD)lpstmt->irow >= cNumberOfColsInCurrentTable ) ||
					 ( (UWORD)lpstmt->irow >= cNumberOfColsInCurrentTable) 
					)
			{
                /* Go to next table (if any) */
                err = ISAMGetNextTableName(fSyncMode, lpstmt->lpISAMTableList,
                                           (LPUSTR)lpstmt->szTableName, (LPUSTR)lpstmt->szTableType);
				fTableDefChange = TRUE;
                if (err == ISAM_EOF) {
                    if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                        lpstmt->fISAMTxnStarted = TRUE;

                    lpstmt->irow = AFTER_LAST_ROW;
                    return SQL_NO_DATA_FOUND;
                }
				else if (err == ISAM_STILL_EXECUTING)
				{
					return SQL_STILL_EXECUTING;
				}
                else if (err != NO_ISAM_ERR) {
                    lpstmt->errcode = err;
                    ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
                                        (LPUSTR)lpstmt->szISAMError);
                    lpstmt->irow = AFTER_LAST_ROW;
                    return SQL_ERROR;
                }
                if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                    lpstmt->fISAMTxnStarted = TRUE;

                /* Get the definition of the table */
                if (lpstmt->lpISAMTableDef != NULL) {
                    ISAMCloseTable(lpstmt->lpISAMTableDef);
                    lpstmt->lpISAMTableDef = NULL;
                }

			
                if (NO_ISAM_ERR != ISAMOpenTable(lpstmt->lpdbc->lpISAM,
                       (LPUSTR)lpstmt->lpISAMTableList->lpQualifierName, 
					   lpstmt->lpISAMTableList->cbQualifierName,
					   (LPUSTR)lpstmt->szTableName, TRUE, &(lpstmt->lpISAMTableDef)))
                    lpstmt->lpISAMTableDef = NULL;
				else if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
							lpstmt->fISAMTxnStarted = TRUE;


                /* Get first column of that table */
                lpstmt->irow = 0;
            }

			//Out of While ..loop, so we must have check TABLEDEF at least once
			fTableDefChange = FALSE;

            /* Does this column name match the pattern supplied? */

			//Remember, we may have a DIFFERENT TABLEDEF !!!

			ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

			if ( !cInfoBase->IsValid() )
			{
				lpstmt->irow = AFTER_LAST_ROW;
                return SQL_NO_DATA_FOUND;
			}

			char pColumnName [MAX_COLUMN_NAME_LENGTH+1];
			if ( FAILED(cInfoBase->GetColumnName(lpstmt->irow, pColumnName)) )
			{
				lpstmt->irow = AFTER_LAST_ROW;
                return SQL_NO_DATA_FOUND;
			}

			//Check if this column type is support
			//if not we skip this column
			if (ISAMGetColumnType(lpstmt->lpISAMTableDef, (UWORD) lpstmt->irow) )
			{
				//Check that column name matches search pattern 
				if ( (PatternMatch(TRUE, (LPUSTR)pColumnName, SQL_NTS, 
						(LPUSTR)lpstmt->szColumnName, SQL_NTS, 
						ISAMCaseSensitive(lpstmt->lpdbc->lpISAM)) ) )
				{
					//Ignore any 'lazy' columns
					BOOL fIsLazy = FALSE;
					cInfoBase->IsLazy(lpstmt->irow, fIsLazy);

					//Check if we want to show system properties
					if (lpstmt->lpISAMTableDef->lpISAM->fSysProps && !fIsLazy)
					{
						//We want to show system properties, so continue
						/* Yes.  Return this column */
						break;
					}
					else
					{
						//We don't want to show system properties
						if (_strnicmp("__", pColumnName, 2) && !fIsLazy)
						{
							//Not a system property
							/* Yes.  Return this column */
							break;
						}
					}
					
				}
			}

            /* Try the next row */
            lpstmt->irow++;
        }
	}
        break;

    /* SQLStatistics() result... */
    case STMT_TYPE_STATISTICS:
	{
        /* Error if after the last row */
        if (lpstmt->irow == AFTER_LAST_ROW)
            return SQL_NO_DATA_FOUND;

        /* Was a table found? */
        if (lpstmt->lpISAMTableDef == NULL) {

            /* No. EOT */
            lpstmt->irow = AFTER_LAST_ROW;
            return SQL_NO_DATA_FOUND;
        }

        /* Point at next row */
        if (lpstmt->irow == BEFORE_FIRST_ROW)
            lpstmt->irow = 0;
        else
            lpstmt->irow++;

        /* Get number of key columns */
        count = 0;

		ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

		if ( !cInfoBase->IsValid() )
		{
            lpstmt->irow = AFTER_LAST_ROW;
            return SQL_NO_DATA_FOUND;
		}

		UWORD cNumberOfCols = cInfoBase->GetNumberOfColumns();
		BOOL fIsKey = FALSE;
		for (index = 0; index < cNumberOfCols; index++)
		{
			if (SUCCEEDED(cInfoBase->GetKey(index, fIsKey)) && fIsKey)
				count++;
		}

        /* Has the table or key component been returned yet? */
        if (lpstmt->irow > count) {

            /* Yes.  EOT */
            lpstmt->irow = AFTER_LAST_ROW;
            return SQL_NO_DATA_FOUND;
        }

	}
        break;

    /* SQLSpecialColumns() result... */
    case STMT_TYPE_SPECIALCOLUMNS:
	{
        /* Error if after the last row */
        if (lpstmt->irow == AFTER_LAST_ROW)
            return SQL_NO_DATA_FOUND;

        /* Was a table found? */
        if (lpstmt->lpISAMTableDef == NULL) {

            /* No. EOT */
            lpstmt->irow = AFTER_LAST_ROW;
            return SQL_NO_DATA_FOUND;
        }

        /* Point at next row */
        if (lpstmt->irow == BEFORE_FIRST_ROW)
            lpstmt->irow = 0;
        else
            lpstmt->irow++;

        /* Get number of key columns */
        count = 0;

		ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

		if ( !cInfoBase->IsValid() )
		{
            lpstmt->irow = AFTER_LAST_ROW;
            return SQL_NO_DATA_FOUND;
		}

		UWORD cNumberOfCols = cInfoBase->GetNumberOfColumns();
		BOOL fIsKey = FALSE;
		for (index = 0; index < cNumberOfCols; index++)
		{
			if (SUCCEEDED(cInfoBase->GetKey(index, fIsKey)) && fIsKey)
				count++;
		}

        /* Has the key component been returned yet? */
        if (lpstmt->irow >= count) {

            /* Yes.  EOT */
            lpstmt->irow = AFTER_LAST_ROW;
            return SQL_NO_DATA_FOUND;
        }
	}
        break;

    /* SQLGetTypeInfo() */
    case STMT_TYPE_TYPEINFO:
	{
        /* Error if after the last row */
        if (lpstmt->irow == AFTER_LAST_ROW)
            return SQL_NO_DATA_FOUND;

        /* Find next qualifying type */
        while (TRUE) {

            /* Point at next row */
            if (lpstmt->irow == BEFORE_FIRST_ROW)
                lpstmt->irow = 0;
            else
                lpstmt->irow++;

            /* Error if no more */
            if (lpstmt->irow >= (SDWORD) lpstmt->lpdbc->lpISAM->cSQLTypes) {
                lpstmt->irow = AFTER_LAST_ROW;
                return SQL_NO_DATA_FOUND;
            }

            /* If this one is supported and matches it, use it */
            if (lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].supported &&
                ((lpstmt->fSqlType == SQL_ALL_TYPES) ||
                 (lpstmt->fSqlType ==
                          lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].type)))
                break;
        }
	}
        break;

    /* SQLPrimaryKeys() */
    case STMT_TYPE_PRIMARYKEYS:
	{
        /* Error if after the last row */
        if (lpstmt->irow == AFTER_LAST_ROW)
            return SQL_NO_DATA_FOUND;

        /* Was a table found? */
        if (lpstmt->lpISAMTableDef == NULL) {

            /* No. EOT */
            lpstmt->irow = AFTER_LAST_ROW;
            return SQL_NO_DATA_FOUND;
        }

        /* Point at next row */
        if (lpstmt->irow == BEFORE_FIRST_ROW)
            lpstmt->irow = 0;
        else
            lpstmt->irow++;

        /* Get number of key columns */
        count = 0;

		ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

		if ( !cInfoBase->IsValid() )
		{
				lpstmt->irow = AFTER_LAST_ROW;
				return SQL_NO_DATA_FOUND;
		}

		UWORD cNumberOfCols = cInfoBase->GetNumberOfColumns();
		BOOL fIsKey = FALSE;
		for (index = 0; index < cNumberOfCols; index++)
		{
			if (SUCCEEDED(cInfoBase->GetKey(index, fIsKey)) && fIsKey)
				count++;
		}

        /* Has the key component been returned yet? */
        if (lpstmt->irow >= count) {

            /* Yes.  EOT */
            lpstmt->irow = AFTER_LAST_ROW;
            return SQL_NO_DATA_FOUND;
        }
	}
        break;

    /* SQLForeignKeys() */
    case STMT_TYPE_FOREIGNKEYS:
	{
        /* Error if after the last row */
        if (lpstmt->irow == AFTER_LAST_ROW)
            return SQL_NO_DATA_FOUND;

        /* If before first row, allocate space for key information */
        if (lpstmt->irow == BEFORE_FIRST_ROW) {
            hKeyInfo = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (KEYINFO));
            if (hKeyInfo == NULL || (lpstmt->lpKeyInfo =
                                 (LPKEYINFO)GlobalLock (hKeyInfo)) == NULL) {
                if (hKeyInfo)
                    GlobalFree(hKeyInfo);

                lpstmt->errcode = ERR_MEMALLOCFAIL;
                return SQL_ERROR;
            }
            s_lstrcpy(lpstmt->lpKeyInfo->szPrimaryKeyName, "");
            s_lstrcpy(lpstmt->lpKeyInfo->szForeignKeyName, "");
            lpstmt->lpKeyInfo->iKeyColumns = 0;
            lpstmt->lpKeyInfo->cKeyColumns = 0;
            lpstmt->lpKeyInfo->fForeignKeyUpdateRule = -1;
            lpstmt->lpKeyInfo->fForeignKeyDeleteRule = -1;
        }

        /* If need information for next foreign key, retrieve it */
        while (lpstmt->lpKeyInfo->iKeyColumns ==
                                            lpstmt->lpKeyInfo->cKeyColumns) {
            switch (lpstmt->fStmtSubtype) {
            case STMT_SUBTYPE_FOREIGNKEYS_SINGLE:
                if (lpstmt->irow != BEFORE_FIRST_ROW) {
                    lpstmt->irow = AFTER_LAST_ROW;
                    return SQL_NO_DATA_FOUND;
                }
                break;
            case STMT_SUBTYPE_FOREIGNKEYS_MULTIPLE_FK_TABLES:
			{
                if (lpstmt->lpISAMTableList == NULL) {
                    lpstmt->irow = AFTER_LAST_ROW;
                    return SQL_NO_DATA_FOUND;
                }

				//Find out if we should perform next command
				//synchronously or asynchronously
				UDWORD fSyncMode = SQL_ASYNC_ENABLE_OFF;
				SQLGetStmtOption(lpstmt, SQL_ASYNC_ENABLE, &fSyncMode);


                err = ISAMGetNextTableName(fSyncMode, lpstmt->lpISAMTableList,
                                           (LPUSTR)lpstmt->szTableName, (LPUSTR)lpstmt->szTableType);
                if (err == ISAM_EOF) {
                    if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                        lpstmt->fISAMTxnStarted = TRUE;
                    lpstmt->irow = AFTER_LAST_ROW;
                    return SQL_NO_DATA_FOUND;
                }
                else if (err != NO_ISAM_ERR) {
                    lpstmt->errcode = err;
                    ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
                                        lpstmt->szISAMError);
                    lpstmt->irow = AFTER_LAST_ROW;
                    return SQL_ERROR;
                }
                if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                    lpstmt->fISAMTxnStarted = TRUE;
			}
                break;
            case STMT_SUBTYPE_FOREIGNKEYS_MULTIPLE_PK_TABLES:
			{
                if (lpstmt->lpISAMTableList == NULL) {
                    lpstmt->irow = AFTER_LAST_ROW;
                    return SQL_NO_DATA_FOUND;
                }

				//Find out if we should perform next command
				//synchronously or asynchronously
				UDWORD fSyncMode = SQL_ASYNC_ENABLE_OFF;
				SQLGetStmtOption(lpstmt, SQL_ASYNC_ENABLE, &fSyncMode);

                err = ISAMGetNextTableName(fSyncMode, lpstmt->lpISAMTableList,
                                           lpstmt->szPkTableName, (LPUSTR)lpstmt->szTableType);
                if (err == ISAM_EOF) {
                    if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                        lpstmt->fISAMTxnStarted = TRUE;
                    lpstmt->irow = AFTER_LAST_ROW;
                    return SQL_NO_DATA_FOUND;
                }
                else if (err != NO_ISAM_ERR) {
                    lpstmt->errcode = err;
                    ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
                                        lpstmt->szISAMError);
                    lpstmt->irow = AFTER_LAST_ROW;
                    return SQL_ERROR;
                }
                if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                    lpstmt->fISAMTxnStarted = TRUE;

				/* Get the foriegn key information */    
				err = ISAMForeignKey(lpstmt->lpdbc->lpISAM,
									lpstmt->szPkTableName, lpstmt->szTableName,
									lpstmt->lpKeyInfo->szPrimaryKeyName,
									lpstmt->lpKeyInfo->szForeignKeyName,
									&(lpstmt->lpKeyInfo->fForeignKeyUpdateRule),
									&(lpstmt->lpKeyInfo->fForeignKeyDeleteRule),
									&(lpstmt->lpKeyInfo->cKeyColumns),
									lpstmt->lpKeyInfo->PrimaryKeyColumns,
									lpstmt->lpKeyInfo->ForeignKeyColumns);
				if (err == ISAM_EOF) {
					if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
						lpstmt->fISAMTxnStarted = TRUE;
					if (lpstmt->fStmtSubtype == STMT_SUBTYPE_FOREIGNKEYS_SINGLE) {
						lpstmt->irow = AFTER_LAST_ROW;
						return SQL_NO_DATA_FOUND;
					}
					lpstmt->lpKeyInfo->cKeyColumns = 0;
				}
				else if (err != NO_ISAM_ERR) {
					lpstmt->errcode = err;
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
											lpstmt->szISAMError);
					lpstmt->irow = AFTER_LAST_ROW;
					return SQL_ERROR;
				}
				if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
					lpstmt->fISAMTxnStarted = TRUE;
				lpstmt->lpKeyInfo->iKeyColumns = 0;
			

				/* Point at next row of data to return */
				(lpstmt->lpKeyInfo->iKeyColumns)++;
				if (lpstmt->irow == BEFORE_FIRST_ROW)
					lpstmt->irow = 0;
				else
					lpstmt->irow++;
			}

			break;
			}
		}
		}
		break;
    /* SELECT statement... */
    case STMT_TYPE_SELECT:

        /* Get the select statement */
        lpSqlNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
        lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.root.sql);

        /* Error parameters are still needed */
        if ((lpstmt->idxParameter != NO_SQLNODE) || lpstmt->fNeedData) {
            lpstmt->errcode = ERR_CURSORSTATE;
            return SQL_ERROR;
        }

        /* Fetch the next row */
        lpstmt->errcode = FetchRow(lpstmt, lpSqlNode);
        if (lpstmt->errcode == ERR_NODATAFOUND)
            return SQL_NO_DATA_FOUND;
        else if (lpstmt->errcode != ERR_SUCCESS)
            return SQL_ERROR;

        break;
	}

    /* Get the bound columns */
    errcode = ERR_SUCCESS;
    for (lpBound = lpstmt->lpBound; lpBound != NULL; lpBound = lpBound->lpNext) {
        rc = SQLGetData(hstmt, lpBound->icol, lpBound->fCType,
                  lpBound->rgbValue, lpBound->cbValueMax, lpBound->pcbValue);
        if (rc == SQL_SUCCESS_WITH_INFO)
            errcode = lpstmt->errcode;
        else if (rc != SQL_SUCCESS)
            return rc;
    }

	/* So far no column read */
	lpstmt->icol = NO_COLUMN;
    lpstmt->cbOffset = 0;

    if (errcode != ERR_SUCCESS) {
        lpstmt->errcode = errcode;
        return SQL_SUCCESS_WITH_INFO;
    }

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLGetData(
    HSTMT      hstmt,
    UWORD      icol,
    SWORD      fCType,
    PTR        rgbValue,
    SDWORD     cbValueMax,
    SDWORD FAR *pcbValue)
{
    LPSTMT     lpstmt;
    SWORD      sValue;
    UDWORD     udValue;
    SWORD      fSqlTypeIn;
    PTR        rgbValueIn;
    SDWORD     cbValueIn;
    LPSQLTYPE  lpSqlType;
    LPSQLNODE  lpSqlNode;
    LPSQLNODE  lpSqlNodeValues;
    SQLNODEIDX idxSqlNodeValues;
    UWORD      column;
    SWORD      err;
    SDWORD     cbValue;
    UWORD      index;
    long       intval;
//    UWORD      i;
    LPSQLNODE  lpSqlNodeTable;
    BOOL       fReturningDistinct;


	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;
	
//	ODBCTRACE(_T("\nWBEM ODBC Driver : ENTERING SQLGetData\n"));

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	MyImpersonator im (lpstmt, "SQLGetData");
/*
	//SAI REPLACE
//	if ( (icol == 1) && (cbValueMax == 201) )
	{
		char* pTemp = (char*) rgbValue;
		pTemp[0] = 0;
		lstrcpy(pTemp, "This is a long test dummy string to check for memory leaks");
//		lstrcpy(pTemp, "This is a long test dummy string to check for memory leaksThis is a long test dummy string to check for memory leaksThis is a long test dummy string to check for memory leaksThis is a long test dummy string to check for memory leaksThis is a long test dummy string to check for memory leaksThis is a long test dummy string to check for memory leaksThis is a long test dummy string to check for memory leaksThis is a long test dummy string to check for memory leaksThis is a long test dummy string to check for memory leaksThis is a long test dummy string to check for memory leaks");
		*pcbValue = 58;
//		*pcbValue = 580;
		ODBCTRACE("\n***** REACHED HERE *****\n");
		return SQL_SUCCESS;
	}
*/
    /* Which table? */
    switch (lpstmt->fStmtType) { 
    
    case STMT_TYPE_NONE:
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;

    /* SQLTables() result... */
    case STMT_TYPE_TABLES:
	{
        /* Error if not on a row */
        if ((lpstmt->irow == BEFORE_FIRST_ROW) ||
                                         (lpstmt->irow == AFTER_LAST_ROW)) {
            lpstmt->errcode = ERR_CURSORSTATE;
            return SQL_ERROR;
        }

        /* Return requested column */
        switch (icol) {
        case TABLE_QUALIFIER:
			switch (lpstmt->fStmtSubtype)
			{
			case STMT_SUBTYPE_TABLES_QUALIFIERS:
			case STMT_SUBTYPE_TABLES_TABLES:
				fSqlTypeIn = SQL_CHAR;
                rgbValueIn = (LPSTR) (lpstmt->szQualifierName);
                cbValueIn = SQL_NTS;
				break;
			default:
				fSqlTypeIn = SQL_CHAR;
				rgbValueIn = NULL;
				cbValueIn = SQL_NULL_DATA;
				break;
			}
            break;
        case TABLE_OWNER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case TABLE_NAME:

            /* Return either the table name or 'NULL' if just getting the */
            /* table types                                                */
            switch (lpstmt->fStmtSubtype) 
			{
            case STMT_SUBTYPE_TABLES_TABLES:
                fSqlTypeIn = SQL_CHAR;
                rgbValueIn = (LPSTR) (lpstmt->szTableName);
                cbValueIn = SQL_NTS;
                break;
            default:
                fSqlTypeIn = SQL_CHAR;
                rgbValueIn = NULL;
                cbValueIn = SQL_NULL_DATA;
                break;
            }
            break;
        case TABLE_TYPE:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = (LPSTR) (lpstmt->szTableType);
            cbValueIn = SQL_NTS;
            break;
        case TABLE_REMARKS:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
		case TABLE_ATTRIBUTES:
		{
			fSqlTypeIn = SQL_CHAR;
			SDWORD cbBytesCopied = 0;
			rgbValueIn = NULL;
			cbValueIn = SQL_NULL_DATA;

			/* No.  Figure out how long szTableQualifier really is */
			SWORD cbTableQualifier = (SWORD) TrueSize((LPUSTR)lpstmt->szQualifierName, SQL_NTS,
									MAX_QUALIFIER_NAME_LENGTH);

			LPSTR szConstqualifier = (LPSTR)lpstmt->szQualifierName;

			//If no table qualifier is specified then use the 'current' database
			if (!cbTableQualifier)
			{
				szConstqualifier = (char*) lpstmt->lpdbc->lpISAM->szDatabase;

				cbTableQualifier = (SWORD) TrueSize((LPUSTR)szConstqualifier, SQL_NTS,
									MAX_QUALIFIER_NAME_LENGTH);
			}


			if ( ISAMOpenTable(lpstmt->lpdbc->lpISAM, (LPUSTR)szConstqualifier, cbTableQualifier,
							(LPUSTR) lpstmt->szTableName,
						TRUE, &(lpstmt->lpISAMTableDef) ) == NO_ISAM_ERR)
			{
				ISAMGetTableAttr(lpstmt->lpISAMTableDef, (char*) rgbValue, cbValueMax, cbBytesCopied);
				rgbValueIn = (char*) rgbValue;
				cbValueIn = cbBytesCopied;

				ISAMCloseTable(lpstmt->lpISAMTableDef);
				lpstmt->lpISAMTableDef = NULL;
			}			 
		}
			break;
        default:
            lpstmt->errcode = ERR_INVALIDCOLUMNID;
            return SQL_ERROR;
        }

        /* Reset offset if first read of this column */
        if (lpstmt->icol != icol) {
            lpstmt->icol = icol;
            lpstmt->cbOffset = 0;
        }

        /* Convert the results to the requested type */
        lpstmt->errcode = ConvertSqlToC(fSqlTypeIn, 
		GetUnsignedAttribute(lpstmt, fSqlTypeIn), rgbValueIn,
                cbValueIn, &(lpstmt->cbOffset), fCType, rgbValue, cbValueMax,
                pcbValue);
        if (lpstmt->errcode == ERR_DATATRUNCATED)
            return SQL_SUCCESS_WITH_INFO;
        else if (lpstmt->errcode != ERR_SUCCESS)
            return SQL_ERROR;
        break;
	}
    /* SQLColumns()... */
    case STMT_TYPE_COLUMNS:
	{
        /* Error if not on a row */
        if ((lpstmt->irow == BEFORE_FIRST_ROW) ||
                                         (lpstmt->irow == AFTER_LAST_ROW)) {
            lpstmt->errcode = ERR_CURSORSTATE;
            return SQL_ERROR;
        }

        /* Get pointer to definition of the type of the column */
        lpSqlType = ISAMGetColumnType(lpstmt->lpISAMTableDef,
                                      (UWORD) lpstmt->irow);
        if (lpSqlType == NULL) {
            lpstmt->errcode = ERR_ISAM;
            return SQL_ERROR;
        }

		char szcolName [MAX_COLUMN_NAME_LENGTH + 1];

        /* Return the requested column */
        switch (icol) {
        case COLUMN_QUALIFIER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case COLUMN_OWNER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case COLUMN_TABLE:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = (LPSTR) (lpstmt->szTableName);
            cbValueIn = SQL_NTS;
            break;
        case COLUMN_NAME:
		{
            fSqlTypeIn = SQL_CHAR;

			ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

			if ( !cInfoBase->IsValid() )
			{
                return SQL_ERROR;
			}

			rgbValueIn = szcolName;
			
			if ( FAILED(cInfoBase->GetColumnName(lpstmt->irow, (char*)rgbValueIn)) )
			{
                return SQL_ERROR;
			}

            cbValueIn = SQL_NTS;
		}
            break;
        case COLUMN_TYPE:
            fSqlTypeIn = SQL_SMALLINT;
            rgbValueIn = &(lpSqlType->type);
            cbValueIn = 2;
            break;
        case COLUMN_TYPENAME:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = lpSqlType->name;
            cbValueIn = SQL_NTS;
            break;
        case COLUMN_PRECISION:
            fSqlTypeIn = SQL_INTEGER;
            switch (lpSqlType->type) {
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_LONGVARCHAR:
            case SQL_BINARY:
            case SQL_VARBINARY:
            case SQL_LONGVARBINARY:
			case SQL_DOUBLE:
			{
				ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

				if ( !cInfoBase->IsValid() )
				{
					return SQL_ERROR;
				}

				if ( !cInfoBase->GetPrecision(lpstmt->irow, udValue) )
				{
					return SQL_ERROR;
				}
            }
				break;
            case SQL_TINYINT:
                udValue = 3;
                break;
            case SQL_SMALLINT:
                udValue = 5;
                break;
            case SQL_INTEGER:
                udValue = 10;
                break;
            case SQL_REAL:
                udValue = 7;
                break;
            case SQL_FLOAT:
//            case SQL_DOUBLE:
                udValue = 15;
                break;
            case SQL_BIT:
                udValue = 1;
                break;
            case SQL_DATE:
                udValue = 10;
                break;
            case SQL_TIME:
                udValue = 8;
                break;
            case SQL_TIMESTAMP:
                if (TIMESTAMP_SCALE > 0)
                    udValue = 20 + TIMESTAMP_SCALE;
                else
                    udValue = 19;
                break;
            default:
                udValue = 0;
                break;
            }
            rgbValueIn = &udValue;
            cbValueIn = 4;
            break;
        case COLUMN_LENGTH:
            fSqlTypeIn = SQL_INTEGER;
            switch (lpSqlType->type) {
            case SQL_DECIMAL:
            case SQL_NUMERIC:
			{
				ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

				if ( !cInfoBase->IsValid() )
				{
					return SQL_ERROR;
				}

				if ( !cInfoBase->GetPrecision(lpstmt->irow, udValue) )
				{
					return SQL_ERROR;
				}

				udValue = udValue + 2;
			}
                break;
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_LONGVARCHAR:
            case SQL_BINARY:
            case SQL_VARBINARY:
            case SQL_LONGVARBINARY:
			{
				ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

				if ( !cInfoBase->IsValid() )
				{
					return SQL_ERROR;
				}

				if ( !cInfoBase->GetPrecision(lpstmt->irow, udValue) )
				{
					return SQL_ERROR;
				}
			}
                break;
            case SQL_TINYINT:
                udValue = 1;
                break;
            case SQL_SMALLINT:
                udValue = 2;
                break;
            case SQL_INTEGER:
                udValue = 4;
                break;
            case SQL_BIGINT:
			{
				ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

				if ( !cInfoBase->IsValid() )
				{
					return SQL_ERROR;
				}

				if ( !cInfoBase->GetPrecision(lpstmt->irow, udValue) )
				{
					return SQL_ERROR;
				}
				
				if ( ! lpSqlType->unsignedAttribute)
					udValue = udValue + 1;
			}
                break;
            case SQL_REAL:
                udValue = 4;
                break;
            case SQL_FLOAT:
            case SQL_DOUBLE:
                udValue = 8;
                break;
            case SQL_BIT:
                udValue = 1;
                break;
            case SQL_DATE:
                udValue = 6;
                break;
            case SQL_TIME:
                udValue = 6;
                break;
            case SQL_TIMESTAMP:
                udValue = 16;
                break;
            default:
                udValue = 0;
                break;
            }
            rgbValueIn = &udValue;
            cbValueIn = 4;
            break;
        case COLUMN_SCALE:
		{
            fSqlTypeIn = SQL_SMALLINT;

			ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

			if ( !cInfoBase->IsValid() )
			{
				return SQL_ERROR;
			}

			SWORD wScaleVal = 0;
			if ( !cInfoBase->GetScale(lpstmt->irow, wScaleVal) )
			{
				return SQL_ERROR;
			}
			else
			{
				udValue = wScaleVal;
			}
			rgbValueIn = &udValue;
            cbValueIn = 2;
		}
            break;
        case COLUMN_RADIX:
            fSqlTypeIn = SQL_SMALLINT;
            switch (lpSqlType->type) {
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_BIGINT:
            case SQL_REAL:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                sValue = 10;
                rgbValueIn = &sValue;
                cbValueIn = 2;
                break;
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_LONGVARCHAR:
            case SQL_BIT:
            case SQL_BINARY:
            case SQL_VARBINARY:
            case SQL_LONGVARBINARY:
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
            default:
                rgbValueIn = NULL;
                cbValueIn = SQL_NULL_DATA;
                break;
            }
            break;
        case COLUMN_NULLABLE:
		{
            fSqlTypeIn = SQL_SMALLINT;

			ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

			if ( !cInfoBase->IsValid() )
			{
				return SQL_ERROR;
			}

			if ( !cInfoBase->IsNullable(lpstmt->irow, sValue) )
			{
				return SQL_ERROR;
			}

			rgbValueIn = &sValue;

            cbValueIn = 2;
		}
            break;
        case COLUMN_REMARKS:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
		case COLUMN_ATTRIBUTES:
		{
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;

			fSqlTypeIn = SQL_CHAR;
			ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

			if ( !cInfoBase->IsValid() )
			{
                return SQL_ERROR;
			}
			
			if ( FAILED(cInfoBase->GetColumnAttr(lpstmt->irow, (char*)rgbValue, cbValueMax, cbValueIn)) )
			{
				return SQL_ERROR;
			}
			rgbValueIn = rgbValue;
		}
			break;
        default:
            lpstmt->errcode = ERR_INVALIDCOLUMNID;
            return SQL_ERROR;
        }

        /* Reset offset if first read of this column */
        if (lpstmt->icol != icol) {
            lpstmt->icol = icol;
            lpstmt->cbOffset = 0;
        }

        /* Convert the results to the requested type */
        lpstmt->errcode = ConvertSqlToC(fSqlTypeIn, 
                GetUnsignedAttribute(lpstmt, fSqlTypeIn), rgbValueIn,
                cbValueIn, &(lpstmt->cbOffset), fCType, rgbValue, cbValueMax,
                pcbValue);
        if (lpstmt->errcode == ERR_DATATRUNCATED)
            return SQL_SUCCESS_WITH_INFO;
        else if (lpstmt->errcode != ERR_SUCCESS)
            return SQL_ERROR;
        break;
	}
    /* SQLStatistics()... */
    case STMT_TYPE_STATISTICS:
	{
        /* Error if not on a row */
        if ((lpstmt->irow == BEFORE_FIRST_ROW) ||
                                         (lpstmt->irow == AFTER_LAST_ROW)) {
            lpstmt->errcode = ERR_CURSORSTATE;
            return SQL_ERROR;
        }
    
        /* Return the requested column */
        switch (icol) {
        case STATISTIC_QUALIFIER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = (LPSTR) (lpstmt->szQualifierName);
            cbValueIn = SQL_NTS;
            break;
        case STATISTIC_OWNER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = (LPSTR) "";
            cbValueIn = SQL_NTS;
            break;
        case STATISTIC_NAME:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = (LPSTR) (lpstmt->lpISAMTableDef->szTableName);
            cbValueIn = SQL_NTS;
            break;
        case STATISTIC_NONUNIQUE:
            if (lpstmt->irow == 0) {
                fSqlTypeIn = SQL_SMALLINT;
                rgbValueIn = NULL;
                cbValueIn = SQL_NULL_DATA;
            }
            else {
                fSqlTypeIn = SQL_SMALLINT;
                sValue = FALSE;
                rgbValueIn = &sValue;
                cbValueIn = 2;
            }
            break;
        case STATISTIC_INDEXQUALIFIER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case STATISTIC_INDEXNAME:
            if (lpstmt->irow == 0) {
                fSqlTypeIn = SQL_CHAR;
                rgbValueIn = NULL;
                cbValueIn = SQL_NULL_DATA;
            }
            else {
                fSqlTypeIn = SQL_CHAR;
                rgbValueIn = (LPSTR) "KEY";
                cbValueIn = SQL_NTS;
            }
            break;
        case STATISTIC_TYPE:
            if (lpstmt->irow == 0) {
                fSqlTypeIn = SQL_SMALLINT;
                sValue = SQL_TABLE_STAT;
                rgbValueIn = &sValue;
                cbValueIn = 2;
            }
            else {
                fSqlTypeIn = SQL_SMALLINT;
                sValue = SQL_INDEX_OTHER;
                rgbValueIn = &sValue;
                cbValueIn = 2;
            }
            break;
        case STATISTIC_SEQININDEX:
            if (lpstmt->irow == 0) {
                fSqlTypeIn = SQL_SMALLINT;
                rgbValueIn = NULL;
                cbValueIn = SQL_NULL_DATA;
            }
            else {
                fSqlTypeIn = SQL_SMALLINT;
                sValue = (SWORD) lpstmt->irow;
                rgbValueIn = &sValue;
                cbValueIn = 2;
            }
            break;
        case STATISTIC_COLUMNNAME:
            if (lpstmt->irow == 0) {
                fSqlTypeIn = SQL_CHAR;
                rgbValueIn = NULL;
                cbValueIn = SQL_NULL_DATA;
            }
            else {
                /* Find the description of the column.  For each column... */
                rgbValueIn = NULL;

				ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

				if ( !cInfoBase->IsValid() )
				{
					return SQL_ERROR;
				}
				
				UWORD cNumberOfCols = cInfoBase->GetNumberOfColumns();
				char pColumnName [MAX_COLUMN_NAME_LENGTH+1];
				BOOL fIsKey = FALSE;
				for (index = 0;index < cNumberOfCols;index++) 
				{
					if ( FAILED(cInfoBase->GetColumnName(index, pColumnName)) )
					{
						return SQL_ERROR;
					}

                    /* Is this column a component of the key? */
					cInfoBase->GetKey(index, fIsKey);

                    if (fIsKey) 
					{
							/* Yes.  Is this the component we want? */
                        
                            /* Yes.  Save pointer to column name */
                            fSqlTypeIn = SQL_CHAR;
							((char*)rgbValue)[0] = 0;
                            lstrcpy ((char*)rgbValue, pColumnName);
							rgbValueIn = (char*)rgbValue;
                            cbValueIn = SQL_NTS;
                            break;
                        }

                    }
                    if (rgbValueIn == NULL) {
                        lpstmt->errcode = ERR_ISAM;
                        return SQL_ERROR;
					}
                }
           
            break;
        case STATISTIC_COLLATION:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case STATISTIC_CARDINALITY:
            fSqlTypeIn = SQL_INTEGER;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case STATISTIC_PAGES:
            fSqlTypeIn = SQL_INTEGER;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case STATISTIC_FILTERCONDITION:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        default:
            lpstmt->errcode = ERR_INVALIDCOLUMNID;
            return SQL_ERROR;
        }

        /* Reset offset if first read of this column */
        if (lpstmt->icol != icol) {
            lpstmt->icol = icol;
            lpstmt->cbOffset = 0;
        }

        /* Convert the results to the requested type */
        lpstmt->errcode = ConvertSqlToC(fSqlTypeIn, 
                GetUnsignedAttribute(lpstmt, fSqlTypeIn), rgbValueIn,
                cbValueIn, &(lpstmt->cbOffset), fCType, rgbValue, cbValueMax,
                pcbValue);
        if (lpstmt->errcode == ERR_DATATRUNCATED)
            return SQL_SUCCESS_WITH_INFO;
        else if (lpstmt->errcode != ERR_SUCCESS)
            return SQL_ERROR;
	}
        break;

    /* SQLSpecialColumns()... */
    case STMT_TYPE_SPECIALCOLUMNS:
	{

        /* Error if not on a row */
        if ((lpstmt->irow == BEFORE_FIRST_ROW) ||
                                         (lpstmt->irow == AFTER_LAST_ROW)) {
            lpstmt->errcode = ERR_CURSORSTATE;
            return SQL_ERROR;
        }

        /* Find the description of the column.  For each column... */
		lpstmt->errcode = ERR_ISAM;
		ClassColumnInfoBase* cInfoBase = lpstmt->lpISAMTableDef->pColumnInfo;

		if ( !cInfoBase->IsValid() )
		{
			return SQL_ERROR;
		}
		
		UWORD cNumberOfCols = cInfoBase->GetNumberOfColumns();

		char pColumnName [MAX_COLUMN_NAME_LENGTH+1];
		BOOL fIsKey = FALSE;
        for (index = 0; index < cNumberOfCols; index++) 
		{
			if ( FAILED(cInfoBase->GetColumnName(index, pColumnName)) )
			{
				lpstmt->errcode = ERR_ISAM;
				return SQL_ERROR;
			}

            /* Is this column a component of the key? */
			cInfoBase->GetKey(index, fIsKey);

            if (fIsKey) 
			{
                /* Yes.  Save index to column */
                lpstmt->errcode = ERR_SUCCESS;
                break;
			}

		}


		if (lpstmt->errcode == ERR_ISAM)
			return SQL_ERROR;

		/* Get pointer to definition of the type of the column */
		if ( (!cInfoBase->GetDataTypeInfo(index, lpSqlType)) || (lpSqlType == NULL) ) 
		{
			lpstmt->errcode = ERR_ISAM;
			return SQL_ERROR;
		}

		/* Return the requested column */
		switch (icol) {
		case SPECIALCOLUMN_SCOPE:
			fSqlTypeIn = SQL_SMALLINT;
			sValue = SQL_SCOPE_SESSION;
			rgbValueIn = &sValue;
			cbValueIn = 2;
			break;
		case SPECIALCOLUMN_NAME:
			fSqlTypeIn = SQL_CHAR;
			((char*)rgbValue)[0] = 0;
			lstrcpy((char*)rgbValue, pColumnName);
			rgbValueIn = (char*)rgbValue;
			cbValueIn = SQL_NTS;
			break;
		case SPECIALCOLUMN_TYPE:
			fSqlTypeIn = SQL_SMALLINT;
			rgbValueIn = &(lpSqlType->type);
			cbValueIn = 2;
			break;
		case SPECIALCOLUMN_TYPENAME:
			fSqlTypeIn = SQL_CHAR;
			rgbValueIn = lpSqlType->name;
			cbValueIn = SQL_NTS;
			break;
		case SPECIALCOLUMN_PRECISION:
			fSqlTypeIn = SQL_INTEGER;
			switch (lpSqlType->type) {
			case SQL_DECIMAL:
			case SQL_NUMERIC:
			case SQL_BIGINT:
			case SQL_CHAR:
			case SQL_VARCHAR:
			case SQL_LONGVARCHAR:
			case SQL_BINARY:
			case SQL_VARBINARY:
			case SQL_LONGVARBINARY:
				cInfoBase->GetPrecision(index, udValue);
				break;
			case SQL_TINYINT:
				udValue = 3;
				break;
			case SQL_SMALLINT:
				udValue = 5;
				break;
			case SQL_INTEGER:
				udValue = 10;
				break;
			case SQL_REAL:
				udValue = 7;
				break;
			case SQL_FLOAT:
			case SQL_DOUBLE:
				udValue = 15;
				break;
			case SQL_BIT:
				udValue = 1;
				break;
			case SQL_DATE:
				udValue = 10;
				break;
			case SQL_TIME:
				udValue = 8;
				break;
			case SQL_TIMESTAMP:
				if (TIMESTAMP_SCALE > 0)
					udValue = 20 + TIMESTAMP_SCALE;
				else
					udValue = 19;
				break;
			default:
				udValue = 0;
				break;
			}
			rgbValueIn = &udValue;
			cbValueIn = 4;
			break;
		case SPECIALCOLUMN_LENGTH:
			fSqlTypeIn = SQL_INTEGER;
			switch (lpSqlType->type) {
			case SQL_DECIMAL:
			case SQL_NUMERIC:
			{
				cInfoBase->GetPrecision(index, udValue);
				udValue = udValue + 2;
			}
				break;
			case SQL_CHAR:
			case SQL_VARCHAR:
			case SQL_LONGVARCHAR:
			case SQL_BINARY:
			case SQL_VARBINARY:
			case SQL_LONGVARBINARY:
				cInfoBase->GetPrecision(index, udValue);
				break;
			case SQL_TINYINT:
				udValue = 1;
				break;
			case SQL_SMALLINT:
				udValue = 2;
				break;
			case SQL_INTEGER:
				udValue = 4;
				break;
			case SQL_BIGINT:
			{
				cInfoBase->GetPrecision(index, udValue);

				if ( !lpSqlType->unsignedAttribute )
					udValue = udValue + 1;
			}
				break;
			case SQL_REAL:
				udValue = 4;
				break;
			case SQL_FLOAT:
			case SQL_DOUBLE:
				udValue = 8;
				break;
			case SQL_BIT:
				udValue = 1;
				break;
			case SQL_DATE:
				udValue = 6;
				break;
			case SQL_TIME:
				udValue = 6;
				break;
			case SQL_TIMESTAMP:
				udValue = 16;
				break;
			default:
				udValue = 0;
				break;
			}
			rgbValueIn = &udValue;
			cbValueIn = 4;
			break;
		case SPECIALCOLUMN_SCALE:
		{
			fSqlTypeIn = SQL_SMALLINT;
			cInfoBase->GetScale(index, sValue);
			rgbValueIn = &sValue;
			cbValueIn = 2;
		}
			break;
		case SPECIALCOLUMN_PSEUDOCOLUMN:
			fSqlTypeIn = SQL_SMALLINT;
			sValue = SQL_PC_UNKNOWN;
			rgbValueIn = &sValue;
			cbValueIn = 2;
			break;
		default:
			lpstmt->errcode = ERR_INVALIDCOLUMNID;
			return SQL_ERROR;
		}

		/* Reset offset if first read of this column */
		if (lpstmt->icol != icol) {
			lpstmt->icol = icol;
			lpstmt->cbOffset = 0;
		}

		/* Convert the results to the requested type */
		lpstmt->errcode = ConvertSqlToC(fSqlTypeIn, 
				GetUnsignedAttribute(lpstmt, fSqlTypeIn), rgbValueIn,
				cbValueIn, &(lpstmt->cbOffset), fCType, rgbValue, cbValueMax,
				pcbValue);
		if (lpstmt->errcode == ERR_DATATRUNCATED)
			return SQL_SUCCESS_WITH_INFO;
		else if (lpstmt->errcode != ERR_SUCCESS)
			return SQL_ERROR;
		break;
	}
    /* SQLGetTypeInfo()... */
    case STMT_TYPE_TYPEINFO:

        /* Error if not on a row */
        if ((lpstmt->irow == BEFORE_FIRST_ROW) ||
                                         (lpstmt->irow == AFTER_LAST_ROW)) {
            lpstmt->errcode = ERR_CURSORSTATE;
            return SQL_ERROR;
        }

        /* Return the requested column */
        switch (icol) {
        case TYPEINFO_NAME:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].name;
            cbValueIn = SQL_NTS;
            break;
        case TYPEINFO_TYPE:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].type;
            rgbValueIn = &sValue;
            cbValueIn = 2;
            break;
        case TYPEINFO_PRECISION:
            fSqlTypeIn = SQL_INTEGER;
            udValue = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].precision;
            rgbValueIn = &udValue;
            cbValueIn = 4;
            break;
        case TYPEINFO_PREFIX:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].prefix;
            if (rgbValueIn != NULL)
                cbValueIn = SQL_NTS;
            else
                cbValueIn = SQL_NULL_DATA;
            break;
        case TYPEINFO_SUFFIX:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].suffix;
            if (rgbValueIn != NULL)
                cbValueIn = SQL_NTS;
            else
                cbValueIn = SQL_NULL_DATA;
            break;
        case TYPEINFO_PARAMS:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].params;
            if (rgbValueIn != NULL)
                cbValueIn = SQL_NTS;
            else
                cbValueIn = SQL_NULL_DATA;
            break;
        case TYPEINFO_NULLABLE:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].nullable;
            rgbValueIn = &sValue;
            cbValueIn = 2;
            break;
        case TYPEINFO_CASESENSITIVE:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].caseSensitive;
            rgbValueIn = &sValue;
            cbValueIn = 2;
            break;
        case TYPEINFO_SEARCHABLE:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].searchable;
            rgbValueIn = &sValue;
            cbValueIn = 2;
            break;
        case TYPEINFO_UNSIGNED:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].unsignedAttribute;
            rgbValueIn = &sValue;
            if (sValue != -1)
                cbValueIn = 2;
            else
                cbValueIn = SQL_NULL_DATA;
            break;
        case TYPEINFO_MONEY:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].money;
            rgbValueIn = &sValue;
            cbValueIn = 2;
            break;
        case TYPEINFO_AUTOINCREMENT:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].autoincrement;
            rgbValueIn = &sValue;
            if (sValue != -1)
                cbValueIn = 2;
            else
                cbValueIn = SQL_NULL_DATA;
            break;
        case TYPEINFO_LOCALNAME:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].localName;
            if (rgbValueIn != NULL)
                cbValueIn = SQL_NTS;
            else
                cbValueIn = SQL_NULL_DATA;
            break;
        case TYPEINFO_MINSCALE:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].minscale;
            rgbValueIn = &sValue;
            if (sValue != -1)
                cbValueIn = 2;
            else
                cbValueIn = SQL_NULL_DATA;
            break;
        case TYPEINFO_MAXSCALE:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = lpstmt->lpdbc->lpISAM->SQLTypes[lpstmt->irow].maxscale;
            rgbValueIn = &sValue;
            if (sValue != -1)
                cbValueIn = 2;
            else
                cbValueIn = SQL_NULL_DATA;
            break;
        default:
            lpstmt->errcode = ERR_INVALIDCOLUMNID;
            return SQL_ERROR;
        }

        /* Reset offset if first read of this column */
        if (lpstmt->icol != icol) {
            lpstmt->icol = icol;
            lpstmt->cbOffset = 0;
        }

        /* Convert the results to the requested type */
        lpstmt->errcode = ConvertSqlToC(fSqlTypeIn,
                GetUnsignedAttribute(lpstmt, fSqlTypeIn), rgbValueIn,
                cbValueIn, &(lpstmt->cbOffset), fCType, rgbValue, cbValueMax,
                pcbValue);
        if (lpstmt->errcode == ERR_DATATRUNCATED)
            return SQL_SUCCESS_WITH_INFO;
        else if (lpstmt->errcode != ERR_SUCCESS)
            return SQL_ERROR;
       break;  

    /* SQLPrimaryKeys()... */
    case STMT_TYPE_PRIMARYKEYS:

        /* Error if not on a row */
        if ((lpstmt->irow == BEFORE_FIRST_ROW) ||
                                         (lpstmt->irow == AFTER_LAST_ROW)) {
            lpstmt->errcode = ERR_CURSORSTATE;
            return SQL_ERROR;
        }

        /* Return the requested column */
        switch (icol) {
        case PRIMARYKEY_QUALIFIER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case PRIMARYKEY_OWNER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case PRIMARYKEY_TABLE:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = (LPSTR) (lpstmt->lpISAMTableDef->szTableName);
            cbValueIn = SQL_NTS;
            break;
        case PRIMARYKEY_COLUMN:
            /* Find the description of the column.  For each column... */
            return SQL_ERROR;
            break;
        case PRIMARYKEY_KEYSEQ:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = (SWORD) (lpstmt->irow + 1);
            rgbValueIn = &sValue;
            cbValueIn = 2;
            break;
        case PRIMARYKEY_NAME:
            fSqlTypeIn = SQL_CHAR;
            if (s_lstrlen(lpstmt->lpISAMTableDef->szPrimaryKeyName) != 0) {
                rgbValueIn = lpstmt->lpISAMTableDef->szPrimaryKeyName;
                cbValueIn = SQL_NTS;
            }
            else {
                rgbValueIn = NULL;
                cbValueIn = SQL_NULL_DATA;
            }
            break;
        default:
            lpstmt->errcode = ERR_INVALIDCOLUMNID;
            return SQL_ERROR;
        }

        /* Reset offset if first read of this column */
        if (lpstmt->icol != icol) {
            lpstmt->icol = icol;
            lpstmt->cbOffset = 0;
        }

        /* Convert the results to the requested type */
        lpstmt->errcode = ConvertSqlToC(fSqlTypeIn,
                GetUnsignedAttribute(lpstmt, fSqlTypeIn), rgbValueIn,
                cbValueIn, &(lpstmt->cbOffset), fCType, rgbValue, cbValueMax,
                pcbValue);
        if (lpstmt->errcode == ERR_DATATRUNCATED)
            return SQL_SUCCESS_WITH_INFO;
        else if (lpstmt->errcode != ERR_SUCCESS)
            return SQL_ERROR;
       break;   

    /* SQLForeignKeys()... */
    case STMT_TYPE_FOREIGNKEYS:

        /* Error if not on a row */
        if ((lpstmt->irow == BEFORE_FIRST_ROW) ||
                                         (lpstmt->irow == AFTER_LAST_ROW)) {
            lpstmt->errcode = ERR_CURSORSTATE;
            return SQL_ERROR;
        }

        /* Return the requested column */
        switch (icol) {
        case FOREIGNKEY_PKQUALIFIER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case FOREIGNKEY_PKOWNER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case FOREIGNKEY_PKTABLE:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = lpstmt->szPkTableName;
            cbValueIn = SQL_NTS;
            break;
        case FOREIGNKEY_PKCOLUMN:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = lpstmt->lpKeyInfo->PrimaryKeyColumns[
                                    lpstmt->lpKeyInfo->iKeyColumns-1];
            cbValueIn = SQL_NTS;
            break;
        case FOREIGNKEY_FKQUALIFIER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case FOREIGNKEY_FKOWNER:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = NULL;
            cbValueIn = SQL_NULL_DATA;
            break;
        case FOREIGNKEY_FKTABLE:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = lpstmt->szTableName;
            cbValueIn = SQL_NTS;
            break;
        case FOREIGNKEY_FKCOLUMN:
            fSqlTypeIn = SQL_CHAR;
            rgbValueIn = lpstmt->lpKeyInfo->ForeignKeyColumns[
                                    lpstmt->lpKeyInfo->iKeyColumns-1];
            cbValueIn = SQL_NTS;
            break;
        case FOREIGNKEY_KEYSEQ:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = (SWORD) lpstmt->lpKeyInfo->iKeyColumns;
            rgbValueIn = &sValue;
            cbValueIn = 2;
            break;
        case FOREIGNKEY_UPDATERULE:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = lpstmt->lpKeyInfo->fForeignKeyUpdateRule;
            rgbValueIn = &sValue;
            if (lpstmt->lpKeyInfo->fForeignKeyUpdateRule != -1)
                cbValueIn = 2;
            else
                cbValueIn = SQL_NULL_DATA;
            break;
        case FOREIGNKEY_DELETERULE:
            fSqlTypeIn = SQL_SMALLINT;
            sValue = lpstmt->lpKeyInfo->fForeignKeyDeleteRule;
            rgbValueIn = &sValue;
            if (lpstmt->lpKeyInfo->fForeignKeyDeleteRule != -1)
                cbValueIn = 2;
            else
                cbValueIn = SQL_NULL_DATA;
            break;
        case FOREIGNKEY_FKNAME:
            fSqlTypeIn = SQL_CHAR;
            if (s_lstrlen(lpstmt->lpKeyInfo->szForeignKeyName) != 0) {
                rgbValueIn = lpstmt->lpKeyInfo->szForeignKeyName;
                cbValueIn = SQL_NTS;
            }
            else {
                rgbValueIn = NULL;
                cbValueIn = SQL_NULL_DATA;
            }
            break;
        case FOREIGNKEY_PKNAME:
            fSqlTypeIn = SQL_CHAR;
            if (s_lstrlen(lpstmt->lpKeyInfo->szPrimaryKeyName) != 0) {
                rgbValueIn = lpstmt->lpKeyInfo->szPrimaryKeyName;
                cbValueIn = SQL_NTS;
            }
            else {
                rgbValueIn = NULL;
                cbValueIn = SQL_NULL_DATA;
            }
            break;
        default:
            lpstmt->errcode = ERR_INVALIDCOLUMNID;
            return SQL_ERROR;
        }

        /* Reset offset if first read of this column */
        if (lpstmt->icol != icol) {
            lpstmt->icol = icol;
            lpstmt->cbOffset = 0;
        }

        /* Convert the results to the requested type */
        lpstmt->errcode = ConvertSqlToC(fSqlTypeIn,
                GetUnsignedAttribute(lpstmt, fSqlTypeIn), rgbValueIn,
                cbValueIn, &(lpstmt->cbOffset), fCType, rgbValue, cbValueMax,
                pcbValue);
        if (lpstmt->errcode == ERR_DATATRUNCATED)
            return SQL_SUCCESS_WITH_INFO;
        else if (lpstmt->errcode != ERR_SUCCESS)
            return SQL_ERROR;
       break;   
 
    /* SELECT statement */
    case STMT_TYPE_SELECT:
	{

        /* Error if not on a row */
        lpSqlNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
        lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.root.sql);
        if ((lpSqlNode->node.select.CurrentRow == BEFORE_FIRST_ROW) ||
                     (lpSqlNode->node.select.CurrentRow == AFTER_LAST_ROW)) {
            lpstmt->errcode = ERR_CURSORSTATE;
            return SQL_ERROR;
        }
        fReturningDistinct = lpSqlNode->node.select.ReturningDistinct;

		//This was added to fix an MS Access bug
		if ( (fCType == SQL_C_DEFAULT) || (fCType == SQL_C_LONG) || (fCType == SQL_C_SHORT) || (fCType == SQL_C_TINYINT) )
		{
			SWORD pcbBytesRet = 0;
			SDWORD pfDummy = 0;
			UCHAR szColType [MAX_COLUMN_NAME_LENGTH+1];
			szColType[0] = 0;


			SQLColAttributes(hstmt, icol, SQL_COLUMN_TYPE_NAME, szColType, MAX_COLUMN_NAME_LENGTH,
				&pcbBytesRet, &pfDummy);
			//test data
//			strcpy((char*)szColType, "SMALL_STRING");
//			pcbBytesRet = 12;

			LPSQLTYPE lpSqlType = GetType2(szColType);
			if (lpSqlType == 0) 
			{
					lpstmt->errcode = ERR_ISAM;
					return SQL_ERROR;
			};

			if ( (lpSqlType->unsignedAttribute == -1) || (lpSqlType->unsignedAttribute == TRUE) )
			{
				switch (fCType)
				{
				case SQL_C_DEFAULT:
				{
					switch (lpSqlType->type)
					{
					case SQL_TINYINT:
						fCType = SQL_C_UTINYINT;
						break;
					case SQL_SMALLINT:
						fCType = SQL_C_USHORT;
						break;
					case SQL_INTEGER:
						fCType = SQL_C_ULONG;
						break;
					default:
						break;
					}
				}
					break;
				case SQL_C_LONG:
					fCType = SQL_C_ULONG;
					break;
				case SQL_C_SHORT:
					fCType = SQL_C_USHORT;
					break;
				case SQL_C_TINYINT:
					fCType = SQL_C_UTINYINT;
					break;
				default:
					break;
				}
			}
		}
        /* Get the VALUE node corresponding to the column number. */
		idxSqlNodeValues = lpSqlNode->node.select.Values;
        for (column = 1; column <= icol; column++) {
            if (idxSqlNodeValues == NO_SQLNODE) {
                lpstmt->errcode = ERR_INVALIDCOLUMNID;
                return SQL_ERROR;
            }
            lpSqlNodeValues = ToNode(lpstmt->lpSqlStmt, idxSqlNodeValues);
            idxSqlNodeValues = lpSqlNodeValues->node.values.Next; 
        }
        lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNodeValues->node.values.Value);

        /* Reset offset if first read of this column */
        if (lpstmt->icol != icol) {
            lpstmt->icol = icol;
            lpstmt->cbOffset = 0;
        }

        /* Is this a COLUMN node for a character (binary) column that is */
        /* to be read into a character (binary) buffer?                  */
        if ((lpSqlNode->sqlNodeType == NODE_TYPE_COLUMN) &&
            (((lpSqlNode->sqlDataType == TYPE_CHAR) &&
              (fCType == SQL_C_CHAR)) || 
             ((lpSqlNode->sqlDataType == TYPE_BINARY) &&
              (fCType == SQL_C_BINARY))) &&
            (!(lpSqlNode->node.column.InSortRecord)) &&
            (!(fReturningDistinct)) ) {

            /* Yes.  Get the character data */

	    lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt,
                                         lpSqlNode->node.column.Table);
            if (!(lpSqlNodeTable->node.table.AllNull)) {

            err = ISAMGetData(lpSqlNodeTable->node.table.Handle,
                              lpSqlNode->node.column.Id, lpstmt->cbOffset,
                              fCType, rgbValue, cbValueMax, &cbValue);
                if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                    lpstmt->fISAMTxnStarted = TRUE;
            }
            else {
                if ((fCType == SQL_C_CHAR) && (rgbValue != NULL) &&
                                                           (cbValueMax > 0))
                    s_lstrcpy(rgbValue, "");
                err = NO_ISAM_ERR;
                cbValue = SQL_NULL_DATA;
            }
            if (err == ISAM_TRUNCATION)
                lpstmt->errcode = ERR_DATATRUNCATED;
            else if (err != NO_ISAM_ERR) {
                lpstmt->errcode = err;
                ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
                                    (LPUSTR)lpstmt->szISAMError);
                return SQL_ERROR;
            }
	
            /* Return the size */
            if (pcbValue != NULL)
                *pcbValue = cbValue;

//			CString myOutput1;
//			myOutput1.Format(_T("\nWBEM ODBC Driver : SQLGetData POS=1 pcbValue = %ld\n"), *pcbValue);
//			ODBCTRACE(myOutput1);

            /* Fix the offset */
            if (cbValue >= cbValueMax) {
                if (fCType == SQL_C_CHAR)
				{
                    if (cbValueMax > 0)
                        lpstmt->cbOffset += (cbValueMax-1);
				}
                else
                    lpstmt->cbOffset += (cbValueMax);
            }
            else if (cbValue > 0)
                lpstmt->cbOffset += (cbValue);
			
            /* Return warning if data was truncated */
            if (lpstmt->errcode == ERR_DATATRUNCATED)
                return SQL_SUCCESS_WITH_INFO;
        }

        /* Is this a COLUMN node for a character column that is */
        /* to be read into a binary buffer?                     */
        else if ((lpSqlNode->sqlNodeType == NODE_TYPE_COLUMN) &&
                 (lpSqlNode->sqlDataType == TYPE_CHAR) &&
                 (fCType == SQL_C_BINARY) &&
                 (!(lpSqlNode->node.column.InSortRecord)) &&
                 (!(fReturningDistinct)) ) {

            /* Yes.  Get the character data */
            lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt,
                                         lpSqlNode->node.column.Table);
            if (!(lpSqlNodeTable->node.table.AllNull)) {

            err = ISAMGetData(lpSqlNodeTable->node.table.Handle,
                              lpSqlNode->node.column.Id, lpstmt->cbOffset,
                              SQL_C_CHAR, rgbValue, cbValueMax, &cbValue);
                if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                    lpstmt->fISAMTxnStarted = TRUE;
            }
            else {
                err = NO_ISAM_ERR;
                cbValue = SQL_NULL_DATA;
            }
            if (err == ISAM_TRUNCATION)
                lpstmt->errcode = ERR_DATATRUNCATED;
            else if (err != NO_ISAM_ERR) {
                lpstmt->errcode = err;
                ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
                                    (LPUSTR)lpstmt->szISAMError);
                return SQL_ERROR;
            }

            /* Return the size */
            if (pcbValue != NULL)
                *pcbValue = cbValue;

//			CString myOutput2;
//			myOutput2.Format(_T("\nWBEM ODBC Driver : SQLGetData POS=2 pcbValue = %ld\n"), *pcbValue);
//			ODBCTRACE(myOutput2);

            /* Fix the offset */
            if (cbValue >= cbValueMax)
                lpstmt->cbOffset += (cbValueMax);
            else if (cbValue > 0)
                lpstmt->cbOffset += (cbValue);

            /* Return warning if data was truncated */
            if (lpstmt->errcode == ERR_DATATRUNCATED)
                return SQL_SUCCESS_WITH_INFO;
        }
        /* Is this a COLUMN node for a binary column that is    */
        /* to be read into a character buffer?                  */
        else if ((lpSqlNode->sqlNodeType == NODE_TYPE_COLUMN) &&
                 (lpSqlNode->sqlDataType == TYPE_BINARY) &&
                 (fCType == SQL_C_CHAR) &&
                 (!(lpSqlNode->node.column.InSortRecord)) &&
                 (!(fReturningDistinct)) ) {

            /* Yes.  Get the character data */
            lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt,
                                         lpSqlNode->node.column.Table);
            if (!(lpSqlNodeTable->node.table.AllNull)) {

            err = ISAMGetData(lpSqlNodeTable->node.table.Handle,
                              lpSqlNode->node.column.Id, lpstmt->cbOffset,
                              fCType, rgbValue, cbValueMax, &cbValue);
                if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                    lpstmt->fISAMTxnStarted = TRUE;
            }
            else {
                if ((rgbValue != NULL) && (cbValueMax > 0))
                    s_lstrcpy(rgbValue, "");
                err = NO_ISAM_ERR;
                cbValue = SQL_NULL_DATA;
            }
            if (err == ISAM_TRUNCATION)
                lpstmt->errcode = ERR_DATATRUNCATED;
            else if (err != NO_ISAM_ERR) {
                lpstmt->errcode = err;
                ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
                                    (LPUSTR)lpstmt->szISAMError);
                return SQL_ERROR;
            }

            /* Return the size */
            if (pcbValue != NULL)
                *pcbValue = cbValue;

//			CString myOutput3;
//			myOutput3.Format(_T("\nWBEM ODBC Driver : SQLGetData POS=3 pcbValue = %ld\n"), *pcbValue);
//			ODBCTRACE(myOutput3);

            /* Fix the offset */
            if (cbValue >= cbValueMax)
			{
                if (cbValueMax > 0)
                    lpstmt->cbOffset += (cbValueMax-1);
			}
            else if (cbValue > 0)
                lpstmt->cbOffset += (cbValue);

            /* Return warning if data was truncated */
            if (lpstmt->errcode == ERR_DATATRUNCATED)
                return SQL_SUCCESS_WITH_INFO;
        }
        else {

            /* No.  Evaluate the VALUE node. */
            err = EvaluateExpression(lpstmt, lpSqlNode);
            if (err != ERR_SUCCESS) {
                lpstmt->errcode = err;
                return SQL_ERROR;
            }

            /* Is the value NULL? */
            if (lpSqlNode->sqlIsNull) {

                /* Yes.  Return NULL */
                if (pcbValue != NULL)
                    *pcbValue = SQL_NULL_DATA;
            }
            else {

                /* No.  Copy the value from the node to the output buffer. */
                switch (lpSqlNode->sqlDataType) {
                case TYPE_DOUBLE:
                case TYPE_NUMERIC:
                case TYPE_INTEGER:
         
                    /* SQL_C_DEFAULT or SQL_C_BINARY specified? */
                    if ((fCType == SQL_C_DEFAULT)||(fCType == SQL_C_BINARY)) {

                        /* Yes. Get the descriptor of datatype of value */
						
					//Get type information about the column
					SWORD pcbBytesRet = 0;
					SDWORD pfDummy = 0;
					UCHAR szColType [MAX_COLUMN_NAME_LENGTH+1];
					szColType[0] = 0;
					SQLColAttributes(hstmt, icol, SQL_COLUMN_TYPE_NAME, szColType, MAX_COLUMN_NAME_LENGTH,
									&pcbBytesRet, &pfDummy); 
					lpSqlType = GetType2(szColType);

  //                      lpSqlType = GetType(lpSqlNode->sqlSqlType);
                        if (lpSqlType == NULL) {
                            lpstmt->errcode = ERR_ISAM;
                            return SQL_ERROR;
                        }

                        /* Determine the C Type the value */
                        switch (lpSqlType->type) {
                        case SQL_CHAR:
                        case SQL_VARCHAR:
                        case SQL_LONGVARCHAR:
                            fCType = SQL_C_CHAR;
                            break;
                        case SQL_BIGINT:
                            fCType = SQL_C_CHAR;
                            break;
                        case SQL_DECIMAL:
                        case SQL_NUMERIC:
                            fCType = SQL_C_CHAR;
                            break;
                        case SQL_DOUBLE:
                        case SQL_FLOAT:
                            fCType = SQL_C_DOUBLE;
                            break;
                        case SQL_BIT:
                            fCType = SQL_C_BIT;
                            break;
                        case SQL_REAL:
                            fCType = SQL_C_FLOAT;
                            break;
                        case SQL_INTEGER:
                            if (lpSqlType->unsignedAttribute == TRUE)
                                fCType = SQL_C_ULONG;
                            else
                                fCType = SQL_C_SLONG;
                            break;
                        case SQL_SMALLINT:
                            if (lpSqlType->unsignedAttribute == TRUE)
                                fCType = SQL_C_USHORT;
                            else
                                fCType = SQL_C_SSHORT;
                            break;
                        case SQL_TINYINT:
                            if (lpSqlType->unsignedAttribute == TRUE)
                                fCType = SQL_C_UTINYINT;
                            else
                                fCType = SQL_C_STINYINT;
                            break;
                        case SQL_DATE:
                        case SQL_TIME:
                        case SQL_TIMESTAMP:
                            lpstmt->errcode = ERR_NOTSUPPORTED;
                            return SQL_ERROR;
                        case SQL_BINARY:
                        case SQL_VARBINARY:
                        case SQL_LONGVARBINARY:
                            fCType = SQL_C_BINARY;
                            break;
                        default:
                            lpstmt->errcode = ERR_NOTSUPPORTED;
                            return SQL_ERROR;
                        }
                    }

                    /* Get the value */
                    switch (lpSqlNode->sqlDataType) {
                    case TYPE_DOUBLE:
					{
                        lpstmt->errcode = ConvertSqlToC(SQL_DOUBLE,
                               GetUnsignedAttribute(lpstmt, SQL_DOUBLE),
                               &(lpSqlNode->value.Double), sizeof(double),
                               &(lpstmt->cbOffset), fCType, rgbValue,
                               cbValueMax, pcbValue);

//						CString myOutput4;
//						myOutput4.Format(_T("\nWBEM ODBC Driver : SQLGetData POS=4 pcbValue = %ld\n"), *pcbValue);
//						ODBCTRACE(myOutput4);
					}
                        break;

                    case TYPE_INTEGER:
					{
						//We have already made sure value is stored in double
						//as the appropriate signed or un-signed value
						BOOL fIsUnsigned = (lpSqlNode->value.Double > 0) ? TRUE : FALSE;

                        intval = (long) lpSqlNode->value.Double;
                        lpstmt->errcode = ConvertSqlToC(SQL_INTEGER,
    //                           GetUnsignedAttribute(lpstmt, SQL_INTEGER),
							   fIsUnsigned,
                               &intval, sizeof(long), &(lpstmt->cbOffset),
                               fCType, rgbValue, cbValueMax, pcbValue);

//						CString myOutput5;
//						myOutput5.Format(_T("\nWBEM ODBC Driver : SQLGetData POS=5 pcbValue = %ld\n"), *pcbValue);
//						ODBCTRACE(myOutput5);
					}
                        break;

                    case TYPE_NUMERIC:
					{
                        if (s_lstrlen(lpSqlNode->value.String) != 0) {
                            lpstmt->errcode = ConvertSqlToC(SQL_CHAR,
                               GetUnsignedAttribute(lpstmt, SQL_CHAR),
                               lpSqlNode->value.String,
                               s_lstrlen(lpSqlNode->value.String),
                               &(lpstmt->cbOffset), fCType, rgbValue,
                               cbValueMax, pcbValue);

//						CString myOutput6;
//						myOutput6.Format(_T("\nWBEM ODBC Driver : SQLGetData POS=6 pcbValue = %ld\n"), *pcbValue);
//						ODBCTRACE(myOutput6);
                        }
                        else {
                            lpstmt->errcode = ConvertSqlToC(SQL_CHAR,
                               GetUnsignedAttribute(lpstmt, SQL_CHAR),
                               "0", 1, &(lpstmt->cbOffset), fCType, rgbValue,
                               cbValueMax, pcbValue);

//							CString myOutput7;
//							myOutput7.Format(_T("\nWBEM ODBC Driver : SQLGetData POS=7 pcbValue = %ld\n"), *pcbValue);
//							ODBCTRACE(myOutput7);
                        }
					}
                        break;
                    case TYPE_CHAR:
                    case TYPE_DATE:
                    case TYPE_TIME:
                    case TYPE_TIMESTAMP:
                    case TYPE_BINARY:
                    default:
                        lpstmt->errcode = ERR_INTERNAL;
                        break;
                    }
                    if (lpstmt->errcode == ERR_DATATRUNCATED)
                        return SQL_SUCCESS_WITH_INFO;
                    else if (lpstmt->errcode != ERR_SUCCESS)
                        return SQL_ERROR;
                    break;
    
                case TYPE_CHAR:
				{
                    lpstmt->errcode = ConvertSqlToC(SQL_CHAR,
                               GetUnsignedAttribute(lpstmt, SQL_CHAR),
                               lpSqlNode->value.String,
                               s_lstrlen(lpSqlNode->value.String),
                               &(lpstmt->cbOffset), fCType, rgbValue,
                                cbValueMax, pcbValue);

//					CString myOutput8;
//					myOutput8.Format(_T("\nWBEM ODBC Driver : SQLGetData POS=8 pcbValue = %ld\n"), *pcbValue);
//					ODBCTRACE(myOutput8);

                    if (lpstmt->errcode == ERR_DATATRUNCATED)
                        return SQL_SUCCESS_WITH_INFO;
                    else if (lpstmt->errcode != ERR_SUCCESS)
                        return SQL_ERROR;
				}
                    break;
    
                case TYPE_DATE:
                    lpstmt->errcode = ConvertSqlToC(SQL_DATE,
                               GetUnsignedAttribute(lpstmt, SQL_DATE),
                               &(lpSqlNode->value.Date), sizeof(DATE_STRUCT),
                               &(lpstmt->cbOffset), fCType, rgbValue,
                               cbValueMax, pcbValue);
                    if (lpstmt->errcode == ERR_DATATRUNCATED)
                        return SQL_SUCCESS_WITH_INFO;
                    else if (lpstmt->errcode != ERR_SUCCESS)
                        return SQL_ERROR;
                    break;
    
                case TYPE_TIME:
                    lpstmt->errcode = ConvertSqlToC(SQL_TIME,
                               GetUnsignedAttribute(lpstmt, SQL_TIME),
                               &(lpSqlNode->value.Time), sizeof(TIME_STRUCT),
                               &(lpstmt->cbOffset), fCType, rgbValue,
                               cbValueMax, pcbValue);
                    if (lpstmt->errcode == ERR_DATATRUNCATED)
                        return SQL_SUCCESS_WITH_INFO;
                    else if (lpstmt->errcode != ERR_SUCCESS)
                        return SQL_ERROR;
                    break;
    
                case TYPE_TIMESTAMP:
                    lpstmt->errcode = ConvertSqlToC(SQL_TIMESTAMP,
                               GetUnsignedAttribute(lpstmt, SQL_TIMESTAMP),
                               &(lpSqlNode->value.Timestamp),
                               sizeof(TIMESTAMP_STRUCT), &(lpstmt->cbOffset),
                               fCType, rgbValue, cbValueMax, pcbValue);
                    if (lpstmt->errcode == ERR_DATATRUNCATED)
                        return SQL_SUCCESS_WITH_INFO;
                    else if (lpstmt->errcode != ERR_SUCCESS)
                        return SQL_ERROR;
                    break;
    
                case TYPE_BINARY:
				{
                    lpstmt->errcode = ConvertSqlToC(SQL_BINARY,
                               GetUnsignedAttribute(lpstmt, SQL_BINARY),
                               BINARY_DATA(lpSqlNode->value.Binary),
                               BINARY_LENGTH(lpSqlNode->value.Binary),
                               &(lpstmt->cbOffset), fCType, rgbValue,
                               cbValueMax, pcbValue);

//					CString myOutput9;
//					myOutput9.Format(_T("\nWBEM ODBC Driver : SQLGetData POS=9 pcbValue = %ld\n"), *pcbValue);
//					ODBCTRACE(myOutput9);

                    if (lpstmt->errcode == ERR_DATATRUNCATED)
                        return SQL_SUCCESS_WITH_INFO;
                    else if (lpstmt->errcode != ERR_SUCCESS)
                        return SQL_ERROR;
				}
                    break;
    
                default:
                    lpstmt->errcode = ERR_NOTSUPPORTED;
                    return SQL_ERROR;
                }
            }
			}
		}
			break;
	}

//	CString myOutput;
//	myOutput.Format(_T("\nWBEM ODBC Driver : EXITING SQLGetData pcbValue = %ld\n"), *pcbValue);
//	ODBCTRACE(myOutput);

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLMoreResults(
    HSTMT   hstmt)
{
    LPSTMT  lpstmt;
    RETCODE err;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpstmt, "SQLMoreResults");

    /* There is never a second result set */
    err = SQLFreeStmt(hstmt, SQL_CLOSE);
    if ((err != SQL_SUCCESS) && (err != SQL_SUCCESS_WITH_INFO))
        return err;
    return SQL_NO_DATA_FOUND;
}

/***************************************************************************/

RETCODE SQL_API SQLRowCount(
    HSTMT      hstmt,
    SDWORD FAR *pcrow)
{
    LPSTMT  lpstmt;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Return row count */
    if (pcrow != NULL)
        *pcrow = lpstmt->cRowCount;
    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLSetPos(
    HSTMT   hstmt,
    UWORD   irow,
    UWORD   fOption,
    UWORD   fLock)
{
    LPSTMT  lpstmt;

    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/

RETCODE SQL_API SQLExtendedFetch(
    HSTMT      hstmt,
    UWORD      fFetchType,
    SDWORD     irow,
    UDWORD FAR *pcrow,
    UWORD  FAR *rgfRowStatus)
{
    LPSTMT  lpstmt;

    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/

RETCODE SQL_API SQLError(
    HENV        henv,
    HDBC        hdbc,
    HSTMT       hstmt,
    UCHAR  FAR *szSqlState,
    SDWORD FAR *pfNativeError,
    UCHAR  FAR *szErrorMsg,
    SWORD      cbErrorMsgMax,
    SWORD  FAR *pcbErrorMsg)
{
    LPENV      lpenv;
    LPDBC      lpdbc;
    LPSTMT     lpstmt;
    RETCODE    errcode;
    LPUSTR      lpstr;
    UCHAR      szTemplate[MAX_ERROR_LENGTH+1];
    UCHAR      szError[MAX_ERROR_LENGTH+1];
    LPUSTR      lpszISAMError;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	//Initialize
	szTemplate[0] = 0;
	szError[0] = 0;

    /* If a HSTMT is specified, get error from HSTMT */
    if (hstmt != SQL_NULL_HSTMT) {
        lpstmt = (LPSTMT) hstmt;
        errcode = lpstmt->errcode;
        lpszISAMError = (LPUSTR)lpstmt->szISAMError;
        lpstmt->errcode = ERR_SUCCESS;
        lpstr = (LPUSTR)lpstmt->szError;
    }

    /* Otherwise if a HDBC is specified, get error from HDBC */
    else if (hdbc != SQL_NULL_HDBC) {
        lpdbc = (LPDBC) hdbc;
        errcode = lpdbc->errcode;
        lpszISAMError = (LPUSTR)lpdbc->szISAMError;
        lpdbc->errcode = ERR_SUCCESS;
        lpstr = NULL;
    }

    /* Otherwise if a HENV is specified, get error from HENV */
    else if (henv != SQL_NULL_HENV) {
        lpenv = (LPENV) henv;
        errcode = lpenv->errcode;
        lpszISAMError = (LPUSTR)lpenv->szISAMError;
        lpenv->errcode = ERR_SUCCESS;
        lpstr = NULL;
    }

    /* Otherwise error */
    else
        return SQL_INVALID_HANDLE;

    /* Return our internal error code */
    if (pfNativeError != NULL)
        *pfNativeError = errcode;

    /* Success code? */
    if (errcode == ERR_SUCCESS) {

        /* Yes.  No message to return */
        LoadString(s_hModule, errcode, (LPSTR)szError, MAX_ERROR_LENGTH+1);
        szError[SQL_SQLSTATE_SIZE] = '\0';
        if (szSqlState != NULL)
            s_lstrcpy(szSqlState, szError);
        ReturnString(szErrorMsg, cbErrorMsgMax, pcbErrorMsg,
                           (LPUSTR) (szError + SQL_SQLSTATE_SIZE + 1));
        return SQL_NO_DATA_FOUND;
    }

    /* Load in error string */
    if (errcode <= LAST_ISAM_ERROR_CODE)
        s_lstrcpy(szTemplate, lpszISAMError);
    else
        LoadString(s_hModule, errcode, (LPSTR)szTemplate, MAX_ERROR_LENGTH+1);
    szTemplate[SQL_SQLSTATE_SIZE] = '\0';

    /* Return state */
    if (szSqlState != NULL)
	{
		szSqlState[0] = 0;
        s_lstrcpy(szSqlState, szTemplate);
	}

    /* Return error message */
	LPSTR lpTmp = (LPSTR)(szTemplate + SQL_SQLSTATE_SIZE + 1);
    wsprintf((LPSTR)szError, lpTmp, lpstr);
    errcode = ReturnString(szErrorMsg, cbErrorMsgMax, pcbErrorMsg, (LPUSTR)szError);
    if (errcode == ERR_DATATRUNCATED)
        return SQL_SUCCESS_WITH_INFO;
    
    return SQL_SUCCESS;
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\scalar.cpp ===
/***************************************************************************/
/* SCALAR.CPP                                                                */
/* Copyright (C) 1997 SYWARE Inc., All rights reserved                     */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"
#include <math.h>
#include <stdlib.h>
#ifndef WIN32
#include <signal.h>
#include <setjmp.h>
#include <float.h>
#endif
#include <time.h>

#ifndef WIN32
#ifdef __cplusplus
#define _JBLEN  9
#ifndef _JMP_BUF_DEFINED
typedef  int  jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif 
#define setjmp  _setjmp
extern "C" {
int  __cdecl _setjmp(jmp_buf);
void __cdecl longjmp(jmp_buf, int);
}
#endif

jmp_buf scalarExceptionMark;
#endif

#define MAX_SCALAR_ARGS 4

typedef struct  tagSCALARFUNC {
    LPUSTR     name;            /* Name of the scalar function */
    SWORD      dataType;        /* Data type returned (TYPE_*) */
    SWORD      sqlType;         /* Sql type returned (SQL_*) (use SQL_* of */
                                /*   first argument if SQL_TYPE_NULL) */
    SDWORD     precision;       /* Precision (use precision of first */
                                /*   argument if 0) */
    SWORD      scale;           /* Scale if sqlType is SQL_DECIMAL */
                                /*   or SQL_NUMERIC (use scale of first */
                                /*   argument if precision is 0 */
    UWORD      argCount;        /* Number of argments */
    SWORD      argType[MAX_SCALAR_ARGS]; /* Data typeof each arg (TYPE_*) */
}          SCALARFUNC,
    FAR *LPSCALARFUNC;

#define SCALAR_ASCII                     0
#define SCALAR_CHAR                      1
#define SCALAR_CONCAT                    2
#define SCALAR_DIFFERENCE                3
#define SCALAR_INSERT                    4
#define SCALAR_LCASE                     5
#define SCALAR_LEFT                      6
#define SCALAR_LENGTH                    7
#define SCALAR_LOCATE                    8
#define SCALAR_LOCATE_START              9
#define SCALAR_LTRIM                    10
#define SCALAR_REPEAT                   11
#define SCALAR_REPLACE                  12
#define SCALAR_RIGHT                    13
#define SCALAR_RTRIM                    14
#define SCALAR_SOUNDEX                  15
#define SCALAR_SPACE                    16
#define SCALAR_SUBSTRING                17
#define SCALAR_UCASE                    18
#define SCALAR_ABS_DOUBLE               19
#define SCALAR_ABS_NUMERIC              20
#define SCALAR_ABS_INTEGER              21
#define SCALAR_ACOS                     22
#define SCALAR_ASIN                     23
#define SCALAR_ATAN                     24
#define SCALAR_ATAN2                    25
#define SCALAR_CEILING_DOUBLE           26
#define SCALAR_CEILING_NUMERIC          27
#define SCALAR_CEILING_INTEGER          28
#define SCALAR_COS                      29
#define SCALAR_COT                      30
#define SCALAR_DEGREES_DOUBLE           31
#define SCALAR_DEGREES_NUMERIC          32
#define SCALAR_DEGREES_INTEGER          33
#define SCALAR_EXP                      34
#define SCALAR_FLOOR_DOUBLE             35
#define SCALAR_FLOOR_NUMERIC            36
#define SCALAR_FLOOR_INTEGER            37
#define SCALAR_LOG                      38
#define SCALAR_LOG10                    39
#define SCALAR_MOD                      40
#define SCALAR_PI                       41
#define SCALAR_POWER_DOUBLE             42
#define SCALAR_POWER_NUMERIC            43
#define SCALAR_POWER_INTEGER            44
#define SCALAR_RADIANS_DOUBLE           45
#define SCALAR_RADIANS_NUMERIC          46
#define SCALAR_RADIANS_INTEGER          47
#define SCALAR_RAND                     48
#define SCALAR_RAND_SEED_DOUBLE         49
#define SCALAR_RAND_SEED_NUMERIC        50
#define SCALAR_RAND_SEED_INTEGER        51
#define SCALAR_ROUND_DOUBLE             52
#define SCALAR_ROUND_NUMERIC            53
#define SCALAR_ROUND_INTEGER            54
#define SCALAR_SIGN_DOUBLE              55
#define SCALAR_SIGN_NUMERIC             56
#define SCALAR_SIGN_INTEGER             57
#define SCALAR_SIN                      58
#define SCALAR_SQRT                     59
#define SCALAR_TAN                      60
#define SCALAR_TRUNCATE_DOUBLE          61
#define SCALAR_TRUNCATE_NUMERIC         62
#define SCALAR_TRUNCATE_INTEGER         63
#define SCALAR_CURDATE                  64
#define SCALAR_CURTIME                  65
#define SCALAR_DAYNAME                  66
#define SCALAR_DAYOFMONTH_CHAR          67
#define SCALAR_DAYOFMONTH_DATE          68
#define SCALAR_DAYOFMONTH_TIMESTAMP     69
#define SCALAR_DAYOFWEEK                70
#define SCALAR_DAYOFYEAR                71
#define SCALAR_HOUR_CHAR                72
#define SCALAR_HOUR_TIME                73
#define SCALAR_HOUR_TIMESTAMP           74
#define SCALAR_MINUTE_CHAR              75
#define SCALAR_MINUTE_TIME              76
#define SCALAR_MINUTE_TIMESTAMP         77
#define SCALAR_MONTH_CHAR               78
#define SCALAR_MONTH_DATE               79
#define SCALAR_MONTH_TIMESTAMP          80
#define SCALAR_MONTHNAME_CHAR           81
#define SCALAR_MONTHNAME_DATE           82
#define SCALAR_MONTHNAME_TIMESTAMP      83
#define SCALAR_NOW                      84
#define SCALAR_QUARTER_CHAR             85
#define SCALAR_QUARTER_DATE             86
#define SCALAR_QUARTER_TIMESTAMP        87
#define SCALAR_SECOND_CHAR              88
#define SCALAR_SECOND_TIME              89
#define SCALAR_SECOND_TIMESTAMP         90
#define SCALAR_TIMESTAMPADD             91
#define SCALAR_TIMESTAMPDIFF            92
#define SCALAR_WEEK                     93
#define SCALAR_YEAR_CHAR                94
#define SCALAR_YEAR_DATE                95
#define SCALAR_YEAR_TIMESTAMP           96
#define SCALAR_DATABASE                 97
#define SCALAR_IFNULL                   98
#define SCALAR_USER                     99
#define SCALAR_CONVERT                 100

/* Seed value for SCALAR_RAND_* functions */
static long new_seed = 1;

SCALARFUNC scalarFuncs[] = {

    /* SCALAR_ASCII */
    {
    /* name         */ (LPUSTR) "ASCII",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_CHAR */
    {
    /* name         */ (LPUSTR) "CHAR",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ 1,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_INTEGER }
    },

    /* SCALAR_CONCAT */
    {
    /* name         */ (LPUSTR) "CONCAT",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_CHAR, TYPE_CHAR }
    },

    /* SCALAR_DIFFERENCE */
    {
    /* name         */ (LPUSTR) "DIFFERENCE",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_INTEGER,
    /* precision    */ 10,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_CHAR, TYPE_CHAR }
    },

    /* SCALAR_INSERT_INTEGER */
    {
    /* name         */ (LPUSTR) "INSERT",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ MAX_CHAR_LITERAL_LENGTH,
    /* scale        */ 0,
    /* argCount     */ 4,
    /* argType[]    */ { TYPE_CHAR, TYPE_INTEGER, TYPE_INTEGER, TYPE_CHAR }
    },

    /* SCALAR_LCASE */
    {
    /* name         */ (LPUSTR) "LCASE",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },
    
    /* SCALAR_LEFT */
    {
    /* name         */ (LPUSTR) "LEFT",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_CHAR, TYPE_INTEGER }
    },
    
    /* SCALAR_LENGTH */
    {
    /* name         */ (LPUSTR) "LENGTH",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_SMALLINT,
    /* precision    */ 5,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_LOCATE */
    {
    /* name         */ (LPUSTR) "LOCATE",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_SMALLINT,
    /* precision    */ 5,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_CHAR, TYPE_CHAR }
    },

    /* SCALAR_LOCATE_START */
    {
    /* name         */ (LPUSTR) "LOCATE",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_SMALLINT,
    /* precision    */ 5,
    /* scale        */ 0,
    /* argCount     */ 3,
    /* argType[]    */ { TYPE_CHAR, TYPE_CHAR, TYPE_INTEGER }
    },

    /* SCALAR_LTRIM */
    {
    /* name         */ (LPUSTR) "LTRIM",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_REPEAT */
    {
    /* name         */ (LPUSTR) "REPEAT",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ MAX_CHAR_LITERAL_LENGTH,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_CHAR, TYPE_INTEGER }
    },

    /* SCALAR_REPLACE */
    {
    /* name         */ (LPUSTR) "REPLACE",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ MAX_CHAR_LITERAL_LENGTH,
    /* scale        */ 0,
    /* argCount     */ 3,
    /* argType[]    */ { TYPE_CHAR, TYPE_CHAR, TYPE_CHAR }
    },

    /* SCALAR_RIGHT */
    {
    /* name         */ (LPUSTR) "RIGHT",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_CHAR, TYPE_INTEGER }
    },

    /* SCALAR_RTRIM */
    {
    /* name         */ (LPUSTR) "RTRIM",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_SOUNDEX */
    {
    /* name         */ (LPUSTR) "SOUNDEX",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ MAX_CHAR_LITERAL_LENGTH,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_SPACE */
    {
    /* name         */ (LPUSTR) "SPACE",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ MAX_CHAR_LITERAL_LENGTH,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_INTEGER }
    },

    /* SCALAR_SUBSTRING */
    {
    /* name         */ (LPUSTR) "SUBSTRING",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 3,
    /* argType[]    */ { TYPE_CHAR, TYPE_INTEGER, TYPE_INTEGER }
    },

    /* SCALAR_UCASE */
    {
    /* name         */ (LPUSTR) "UCASE",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_ABS_DOUBLE */
    {
    /* name         */ (LPUSTR) "ABS",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_ABS_NUMERIC */
    {
    /* name         */ (LPUSTR) "ABS",
    /* dataType     */ TYPE_NUMERIC,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_NUMERIC }
    },

    /* SCALAR_ABS_INTEGER */
    {
    /* name         */ (LPUSTR) "ABS",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_INTEGER }
    },

    /* SCALAR_ACOS */
    {
    /* name         */ (LPUSTR) "ACOS",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_ASIN */
    {
    /* name         */ (LPUSTR) "ASIN",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_ATAN */
    {
    /* name         */ (LPUSTR) "ATAN",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_ATAN2 */
    {
    /* name         */ (LPUSTR) "ATAN2",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_DOUBLE, TYPE_DOUBLE }
    },

    /* SCALAR_CEILING_DOUBLE */
    {
    /* name         */ (LPUSTR) "CEILING",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_CEILING_NUMERIC */
    {
    /* name         */ (LPUSTR) "CEILING",
    /* dataType     */ TYPE_NUMERIC,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_NUMERIC }
    },

    /* SCALAR_CEILING_INTEGER */
    {
    /* name         */ (LPUSTR) "CEILING",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_INTEGER }
    },

    /* SCALAR_COS */
    {
    /* name         */ (LPUSTR) "COS",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_COT */
    {
    /* name         */ (LPUSTR) "COT",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_DEGREES_DOUBLE */
    {
    /* name         */ (LPUSTR) "DEGREES",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_DEGREES_NUMERIC */
    {
    /* name         */ (LPUSTR) "DEGREES",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_NUMERIC }
    },

    /* SCALAR_DEGREES_INTEGER */
    {
    /* name         */ (LPUSTR) "DEGREES",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_INTEGER }
    },

    /* SCALAR_EXP */
    {
    /* name         */ (LPUSTR) "EXP",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_FLOOR_DOUBLE */
    {
    /* name         */ (LPUSTR) "FLOOR",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_FLOOR_NUMERIC */
    {
    /* name         */ (LPUSTR) "FLOOR",
    /* dataType     */ TYPE_NUMERIC,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_NUMERIC }
    },

    /* SCALAR_FLOOR_INTEGER */
    {
    /* name         */ (LPUSTR) "FLOOR",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_INTEGER }
    },

    /* SCALAR_LOG */
    {
    /* name         */ (LPUSTR) "LOG",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_LOG10 */
    {
    /* name         */ (LPUSTR) "LOG10",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_MOD */
    {
    /* name         */ (LPUSTR) "MOD",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_INTEGER, TYPE_INTEGER }
    },

    /* SCALAR_PI */
    {
    /* name         */ (LPUSTR) "PI",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 0
    },

    /* SCALAR_POWER_DOUBLE */
    {
    /* name         */ (LPUSTR) "POWER",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_DOUBLE, TYPE_INTEGER }
    },

    /* SCALAR_POWER_NUMERIC */
    {
    /* name         */ (LPUSTR) "POWER",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_NUMERIC, TYPE_INTEGER }
    },

    /* SCALAR_POWER_INTEGER */
    {
    /* name         */ (LPUSTR) "POWER",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_INTEGER, TYPE_INTEGER }
    },

    /* SCALAR_RADIANS_DOUBLE */
    {
    /* name         */ (LPUSTR) "RADIANS",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_RADIANS_NUMERIC */
    {
    /* name         */ (LPUSTR) "RADIANS",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_NUMERIC }
    },

    /* SCALAR_RADIANS_INTEGER */
    {
    /* name         */ (LPUSTR) "RADIANS",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_INTEGER }
    },

    /* SCALAR_RAND */
    {
    /* name         */ (LPUSTR) "RAND",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 0
    },

    /* SCALAR_RAND_SEED_DOUBLE */
    {
    /* name         */ (LPUSTR) "RAND",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_RAND_SEED_NUMERIC */
    {
    /* name         */ (LPUSTR) "RAND",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_NUMERIC }
    },

    /* SCALAR_RAND_SEED_INTEGER */
    {
    /* name         */ (LPUSTR) "RAND",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_INTEGER }
    },

    /* SCALAR_ROUND_DOUBLE */
    {
    /* name         */ (LPUSTR) "ROUND",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_DOUBLE, TYPE_INTEGER }
    },

    /* SCALAR_ROUND_NUMERIC */
    {
    /* name         */ (LPUSTR) "ROUND",
    /* dataType     */ TYPE_NUMERIC,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_NUMERIC, TYPE_INTEGER  }
    },

    /* SCALAR_ROUND_INTEGER */
    {
    /* name         */ (LPUSTR) "ROUND",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_INTEGER, TYPE_INTEGER  }
    },

    /* SCALAR_SIGN_DOUBLE */
    {
    /* name         */ (LPUSTR) "SIGN",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_SIGN_NUMERIC */
    {
    /* name         */ (LPUSTR) "SIGN",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_NUMERIC }
    },

    /* SCALAR_SIGN_INTEGER */
    {
    /* name         */ (LPUSTR) "SIGN",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_INTEGER }
    },

    /* SCALAR_SIN */
    {
    /* name         */ (LPUSTR) "SIN",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_SQRT */
    {
    /* name         */ (LPUSTR) "SQRT",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_TAN */
    {
    /* name         */ (LPUSTR) "TAN",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_DOUBLE,
    /* precision    */ 15,
    /* scale        */ NO_SCALE,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DOUBLE }
    },

    /* SCALAR_TRUNCATE_DOUBLE */
    {
    /* name         */ (LPUSTR) "TRUNCATE",
    /* dataType     */ TYPE_DOUBLE,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_DOUBLE, TYPE_INTEGER }
    },

    /* SCALAR_TRUNCATE_NUMERIC */
    {
    /* name         */ (LPUSTR) "TRUNCATE",
    /* dataType     */ TYPE_NUMERIC,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_NUMERIC, TYPE_INTEGER }
    },

    /* SCALAR_TRUNCATE_INTEGER */
    {
    /* name         */ (LPUSTR) "TRUNCATE",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_INTEGER, TYPE_INTEGER }
    },

    /* SCALAR_CURDATE */
    {
    /* name         */ (LPUSTR) "CURDATE",
    /* dataType     */ TYPE_DATE,
    /* sqlType      */ SQL_TIMESTAMP, //SQL_DATE,
    /* precision    */ 10,
    /* scale        */ NO_SCALE,
    /* argCount     */ 0
    },

    /* SCALAR_CURTIME */
    {
    /* name         */ (LPUSTR) "CURTIME",
    /* dataType     */ TYPE_TIME,
    /* sqlType      */ SQL_TIMESTAMP, //SQL_TIME,
    /* precision    */ 8,
    /* scale        */ NO_SCALE,
    /* argCount     */ 0
    },

    /* SCALAR_DAYNAME */
    {
    /* name         */ (LPUSTR) "DAYNAME",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ MAX_CHAR_LITERAL_LENGTH,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_UNKNOWN }
    },

    /* SCALAR_DAYOFMONTH_CHAR */
    {
    /* name         */ (LPUSTR) "DAYOFMONTH",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_DAYOFMONTH_DATE */
    {
    /* name         */ (LPUSTR) "DAYOFMONTH",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DATE }
    },

    /* SCALAR_DAYOFMONTH_TIMESTAMP */
    {
    /* name         */ (LPUSTR) "DAYOFMONTH",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_TIMESTAMP }
    },

    /* SCALAR_DAYOFWEEK */
    {
    /* name         */ (LPUSTR) "DAYOFWEEK",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_UNKNOWN }
    },

    /* SCALAR_DAYOFYEAR */
    {
    /* name         */ (LPUSTR) "DAYOFYEAR",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_SMALLINT,
    /* precision    */ 5,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_UNKNOWN }
    },

    /* SCALAR_HOUR_CHAR */
    {
    /* name         */ (LPUSTR) "HOUR",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_HOUR_TIME */
    {
    /* name         */ (LPUSTR) "HOUR",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_TIME }
    },

    /* SCALAR_HOUR_TIMESTAMP */
    {
    /* name         */ (LPUSTR) "HOUR",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_TIMESTAMP }
    },

    /* SCALAR_MINUTE_CHAR */
    {
    /* name         */ (LPUSTR) "MINUTE",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_MINUTE_TIME */
    {
    /* name         */ (LPUSTR) "MINUTE",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_TIME }
    },

    /* SCALAR_MINUTE_TIMESTAMP */
    {
    /* name         */ (LPUSTR) "MINUTE",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_TIMESTAMP }
    },

    /* SCALAR_MONTH_CHAR */
    {
    /* name         */ (LPUSTR) "MONTH",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_MONTH_DATE */
    {
    /* name         */ (LPUSTR) "MONTH",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DATE }
    },

    /* SCALAR_MONTH_TIMESTAMP */
    {
    /* name         */ (LPUSTR) "MONTH",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_TIMESTAMP }
    },

    /* SCALAR_MONTHNAME_CHAR */
    {
    /* name         */ (LPUSTR) "MONTHNAME",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ MAX_CHAR_LITERAL_LENGTH,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_MONTHNAME_DATE */
    {
    /* name         */ (LPUSTR) "MONTHNAME",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ MAX_CHAR_LITERAL_LENGTH,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DATE }
    },

    /* SCALAR_MONTHNAME_TIMESTAMP */
    {
    /* name         */ (LPUSTR) "MONTHNAME",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ MAX_CHAR_LITERAL_LENGTH,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_TIMESTAMP }
    },

    /* SCALAR_NOW */
    {
    /* name         */ (LPUSTR) "NOW",
    /* dataType     */ TYPE_TIMESTAMP,
    /* sqlType      */ SQL_TIMESTAMP,
#if TIMESTAMP_SCALE
    /* precision    */ 20 + TIMESTAMP_SCALE,
#else
    /* precision    */ 19,
#endif
    /* scale        */ TIMESTAMP_SCALE,
    /* argCount     */ 0
    },

    /* SCALAR_QUARTER_CHAR */
    {
    /* name         */ (LPUSTR) "QUARTER",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_QUARTER_DATE */
    {
    /* name         */ (LPUSTR) "QUARTER",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DATE }
    },

    /* SCALAR_QUARTER_TIMESTAMP */
    {
    /* name         */ (LPUSTR) "QUARTER",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_TIMESTAMP }
    },

    /* SCALAR_SECOND_CHAR */
    {
    /* name         */ (LPUSTR) "SECOND",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_SECOND_TIME */
    {
    /* name         */ (LPUSTR) "SECOND",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_TIME }
    },

    /* SCALAR_SECOND_TIMESTAMP */
    {
    /* name         */ (LPUSTR) "SECOND",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_TIMESTAMP }
    },

    /* SCALAR_TIMESTAMPADD */
    {
    /* name         */ (LPUSTR) "TIMESTAMPADD",
    /* dataType     */ TYPE_TIMESTAMP,
    /* sqlType      */ SQL_TIMESTAMP,
#if TIMESTAMP_SCALE
    /* precision    */ 20 + TIMESTAMP_SCALE,
#else
    /* precision    */ 19,
#endif
    /* scale        */ TIMESTAMP_SCALE,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_INTEGER, TYPE_UNKNOWN }
    },

    /* SCALAR_TIMESTAMPDIFF */
    {
    /* name         */ (LPUSTR) "TIMESTAMPDIFF",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_INTEGER,
    /* precision    */ 10,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_UNKNOWN, TYPE_UNKNOWN }
    },

    /* SCALAR_WEEK */
    {
    /* name         */ (LPUSTR) "WEEK",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_TINYINT,
    /* precision    */ 3,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_UNKNOWN }
    },

    /* SCALAR_YEAR_CHAR */
    {
    /* name         */ (LPUSTR) "YEAR",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_INTEGER,
    /* precision    */ 10,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_CHAR }
    },

    /* SCALAR_YEAR_DATE */
    {
    /* name         */ (LPUSTR) "YEAR",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_INTEGER,
    /* precision    */ 10,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_DATE }
    },

    /* SCALAR_YEAR_TIMESTAMP */
    {
    /* name         */ (LPUSTR) "YEAR",
    /* dataType     */ TYPE_INTEGER,
    /* sqlType      */ SQL_INTEGER,
    /* precision    */ 10,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_TIMESTAMP }
    },

    /* SCALAR_DATABASE */
    {
    /* name         */ (LPUSTR) "DATABASE",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ MAX_DATABASE_NAME_LENGTH,
    /* scale        */ 0,
    /* argCount     */ 0
    },

    /* SCALAR_IFNULL */
    {
    /* name         */ (LPUSTR) "IFNULL",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 2,
    /* argType[]    */ { TYPE_UNKNOWN, TYPE_UNKNOWN }
    },

    /* SCALAR_USER */
    {
    /* name         */ (LPUSTR) "USER",
    /* dataType     */ TYPE_CHAR,
    /* sqlType      */ SQL_VARCHAR,
    /* precision    */ MAX_USER_NAME_LENGTH,
    /* scale        */ 0,
    /* argCount     */ 0
    },

    /* SCALAR_CONVERT */
    {
    /* name         */ (LPUSTR) "CONVERT",
    /* dataType     */ TYPE_UNKNOWN,
    /* sqlType      */ SQL_TYPE_NULL,
    /* precision    */ 0,
    /* scale        */ 0,
    /* argCount     */ 1,
    /* argType[]    */ { TYPE_UNKNOWN }
    },

    { (LPUSTR) "" }
};

#define SQL_TSI_SECOND       1
#define SQL_TSI_MINUTE       2
#define SQL_TSI_HOUR         3
#define SQL_TSI_DAY          4
#define SQL_TSI_WEEK         5
#define SQL_TSI_MONTH        6
#define SQL_TSI_QUARTER      7
#define SQL_TSI_YEAR         8

#define SECONDS_PER_MINUTE (60L)
#define SECONDS_PER_HOUR (60L * 60L)
#define SECONDS_PER_DAY (60L * 60L * 24L)
#define SECONDS_PER_WEEK (60L * 60L * 24L * 7L)
#define MONTHS_PER_YEAR (12)
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define PI 3.14159265358979323846264338327950288419716939937510

#define BIT_LOW_D        (          0.0)
#define BIT_HIGH_D       (          1.0)
#define STINY_LOW_D      (       -128.0)
#define STINY_HIGH_D     (        127.0)
#define UTINY_LOW_D      (          0.0)
#define UTINY_HIGH_D     (        255.0)
#define SSHORT_LOW_D     (     -32768.0)
#define SSHORT_HIGH_D    (      32767.0)
#define USHORT_LOW_D     (          0.0)
#define USHORT_HIGH_D    (      65535.0)
#define SLONG_LOW_D      (-2147483648.0)
#define SLONG_HIGH_D     ( 2147483647.0)
#define ULONG_LOW_D      (          0.0)
#define ULONG_HIGH_D     ( 4294967296.0)
#define FLOAT_LOW_D      (      -3.4E38)
#define FLOAT_HIGH_D     (       3.4E38)
#define DOUBLE_LOW_D     (     -1.7E308)
#define DOUBLE_HIGH_D    (      1.7E308)

/***************************************************************************/
SWORD ScalarIfNullType(LPSQLNODE lpSqlNodeLeft, LPSQLNODE lpSqlNodeRight,
                       LPSQLNODE lpSqlNode)
{
    /* Error if type not compatible? */
    if (!((lpSqlNodeLeft->sqlDataType == lpSqlNodeRight->sqlDataType) ||
          ((lpSqlNodeLeft->sqlDataType == TYPE_DOUBLE) &&
                           (lpSqlNodeRight->sqlDataType == TYPE_NUMERIC)) ||
          ((lpSqlNodeLeft->sqlDataType == TYPE_DOUBLE) &&
                           (lpSqlNodeRight->sqlDataType == TYPE_INTEGER)) ||
          ((lpSqlNodeLeft->sqlDataType == TYPE_NUMERIC) &&
                           (lpSqlNodeRight->sqlDataType == TYPE_DOUBLE)) ||
          ((lpSqlNodeLeft->sqlDataType == TYPE_NUMERIC) &&
                           (lpSqlNodeRight->sqlDataType == TYPE_INTEGER)) ||
          ((lpSqlNodeLeft->sqlDataType == TYPE_INTEGER) &&
                           (lpSqlNodeRight->sqlDataType == TYPE_DOUBLE)) ||
          ((lpSqlNodeLeft->sqlDataType == TYPE_INTEGER) &&
                           (lpSqlNodeRight->sqlDataType == TYPE_NUMERIC))))
        return ERR_SCALARBADARG;


    /* Figure out resultant type */
    if ((lpSqlNodeLeft->sqlDataType == TYPE_NUMERIC) &&
                             (lpSqlNodeRight->sqlDataType == TYPE_DOUBLE))
        lpSqlNode->sqlDataType = TYPE_DOUBLE;
    else if ((lpSqlNodeLeft->sqlDataType == TYPE_INTEGER) &&
                             (lpSqlNodeRight->sqlDataType == TYPE_DOUBLE))
        lpSqlNode->sqlDataType = TYPE_DOUBLE;
    else if ((lpSqlNodeLeft->sqlDataType == TYPE_INTEGER) &&
                             (lpSqlNodeRight->sqlDataType == TYPE_NUMERIC))
        lpSqlNode->sqlDataType = TYPE_NUMERIC;
    else
        lpSqlNode->sqlDataType = lpSqlNodeLeft->sqlDataType;

    /* Figure out resultant SQL type, precision, and scale */
    switch (lpSqlNodeLeft->sqlSqlType) {
    case SQL_DOUBLE:
        lpSqlNode->sqlSqlType = SQL_DOUBLE;
        lpSqlNode->sqlPrecision = 15;
        lpSqlNode->sqlScale = NO_SCALE;
        break;
    case SQL_FLOAT:
        if (lpSqlNodeRight->sqlSqlType == SQL_DOUBLE)
            lpSqlNode->sqlSqlType = SQL_DOUBLE;
        else
            lpSqlNode->sqlSqlType = SQL_FLOAT;
        lpSqlNode->sqlPrecision = 15;
        lpSqlNode->sqlScale = NO_SCALE;
        break;
    case SQL_REAL:
        if (lpSqlNodeRight->sqlSqlType == SQL_DOUBLE) {
            lpSqlNode->sqlSqlType = SQL_DOUBLE;
            lpSqlNode->sqlPrecision = 15;
        }
        else if (lpSqlNodeRight->sqlSqlType == SQL_FLOAT) {
            lpSqlNode->sqlSqlType = SQL_FLOAT;
            lpSqlNode->sqlPrecision = 15;
        }
        else {
            lpSqlNode->sqlSqlType = SQL_REAL;
            lpSqlNode->sqlPrecision = 7;
        }
        lpSqlNode->sqlScale = NO_SCALE;
        break;
    case SQL_DECIMAL:
    case SQL_NUMERIC:
    case SQL_BIGINT:
    case SQL_INTEGER:
    case SQL_SMALLINT:
    case SQL_TINYINT:
    case SQL_BIT:
        switch (lpSqlNodeRight->sqlSqlType) {
        case SQL_DOUBLE:
        case SQL_FLOAT:
        case SQL_REAL:
            lpSqlNode->sqlSqlType = lpSqlNodeRight->sqlSqlType;
            lpSqlNode->sqlPrecision = lpSqlNodeRight->sqlPrecision;
            lpSqlNode->sqlScale = NO_SCALE;
            break;
        case SQL_DECIMAL:
        case SQL_NUMERIC:
        case SQL_BIGINT:
        case SQL_INTEGER:
        case SQL_SMALLINT:
        case SQL_TINYINT:
        case SQL_BIT:
            if ((lpSqlNodeRight->sqlSqlType == SQL_DECIMAL) ||
                (lpSqlNodeLeft->sqlSqlType == SQL_DECIMAL))
                lpSqlNode->sqlSqlType = SQL_DECIMAL;
            else if ((lpSqlNodeRight->sqlSqlType == SQL_NUMERIC) ||
                     (lpSqlNodeLeft->sqlSqlType == SQL_NUMERIC))
                lpSqlNode->sqlSqlType = SQL_NUMERIC;
            else if ((lpSqlNodeRight->sqlSqlType == SQL_BIGINT) ||
                     (lpSqlNodeLeft->sqlSqlType == SQL_BIGINT))
                lpSqlNode->sqlSqlType = SQL_BIGINT;
            else if ((lpSqlNodeRight->sqlSqlType == SQL_INTEGER) ||
                     (lpSqlNodeLeft->sqlSqlType == SQL_INTEGER))
                lpSqlNode->sqlSqlType = SQL_INTEGER;
            else if ((lpSqlNodeRight->sqlSqlType == SQL_SMALLINT) ||
                     (lpSqlNodeLeft->sqlSqlType == SQL_SMALLINT))
                lpSqlNode->sqlSqlType = SQL_SMALLINT;
            else if ((lpSqlNodeRight->sqlSqlType == SQL_TINYINT) ||
                     (lpSqlNodeLeft->sqlSqlType == SQL_TINYINT))
                lpSqlNode->sqlSqlType = SQL_TINYINT;
            else
                lpSqlNode->sqlSqlType = SQL_BIT;
            lpSqlNode->sqlScale = MAX(lpSqlNodeRight->sqlScale,
                                      lpSqlNodeLeft->sqlScale);
            lpSqlNode->sqlPrecision = lpSqlNode->sqlScale +
                 MAX(lpSqlNodeRight->sqlPrecision - lpSqlNodeRight->sqlScale,
                     lpSqlNodeLeft->sqlPrecision - lpSqlNodeLeft->sqlScale);
            break;
        case SQL_LONGVARCHAR:
        case SQL_VARCHAR:
        case SQL_CHAR:
        case SQL_LONGVARBINARY:
        case SQL_VARBINARY:
        case SQL_BINARY:
        case SQL_DATE:
        case SQL_TIME:
        case SQL_TIMESTAMP:
            return ERR_INTERNAL;
        default:
            return ERR_NOTSUPPORTED;
        }
        break;

    case SQL_LONGVARCHAR:
        return ERR_INTERNAL;
    case SQL_VARCHAR:
    case SQL_CHAR:
        if ((lpSqlNodeRight->sqlSqlType == SQL_VARCHAR) || 
            (lpSqlNodeLeft->sqlSqlType == SQL_VARCHAR))
            lpSqlNode->sqlSqlType = SQL_VARCHAR;
        else
            lpSqlNode->sqlSqlType = SQL_CHAR;
        lpSqlNode->sqlPrecision = MAX(lpSqlNodeRight->sqlPrecision,
                                      lpSqlNodeLeft->sqlPrecision);
        lpSqlNode->sqlScale = NO_SCALE;
        break;
    case SQL_LONGVARBINARY:
        return ERR_INTERNAL;
    case SQL_VARBINARY:
    case SQL_BINARY:
        if ((lpSqlNodeRight->sqlSqlType == SQL_VARBINARY) || 
            (lpSqlNodeLeft->sqlSqlType == SQL_VARBINARY))
            lpSqlNode->sqlSqlType = SQL_VARBINARY;
        else
            lpSqlNode->sqlSqlType = SQL_BINARY;
        lpSqlNode->sqlPrecision = MAX(lpSqlNodeRight->sqlPrecision,
                                      lpSqlNodeLeft->sqlPrecision);
        lpSqlNode->sqlScale = NO_SCALE;
        break;
    case SQL_DATE:
    case SQL_TIME:
    case SQL_TIMESTAMP:
        lpSqlNode->sqlSqlType = lpSqlNodeLeft->sqlSqlType;
        lpSqlNode->sqlPrecision = lpSqlNodeLeft->sqlPrecision;
        lpSqlNode->sqlScale = lpSqlNodeLeft->sqlScale;
        break;
    default:
        return ERR_NOTSUPPORTED;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/
RETCODE INTFUNC ScalarCheck(LPSTMT lpstmt, LPSQLTREE FAR *lplpSql,
       SQLNODEIDX idxNode, BOOL fIsGroupby, BOOL fCaseSensitive,
       SQLNODEIDX idxNodeTableOuterJoinFromTables,
       SQLNODEIDX idxEnclosingStatement)
{
    LPSQLNODE lpSqlNode;
    LPUSTR lpszFunction;
    SWORD err;
    UWORD idx;
    SQLNODEIDX idxValues;
    LPSQLNODE lpSqlNodeValues;
    LPSQLNODE lpSqlNodeValue;
    LPSQLNODE lpSqlNodeValue2;
    LPSCALARFUNC lpScalarFunc;
    SQLNODEIDX idxInterval;
    SQLNODEIDX idxType;
    LPUSTR lpstrInterval;
    LPUSTR lpstrType;

    /* Find first entry for the function */
    lpSqlNode = ToNode(*lplpSql, idxNode);
    lpSqlNode->node.scalar.Id = 0;
    lpszFunction = ToString(*lplpSql, lpSqlNode->node.scalar.Function);
    while (TRUE) {
        lpScalarFunc = &(scalarFuncs[lpSqlNode->node.scalar.Id]);
        if (s_lstrlen(lpScalarFunc->name) == 0) {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARNOTFOUND;
        }
        if (!s_lstrcmpi(lpszFunction, lpScalarFunc->name))
            break;
        (lpSqlNode->node.scalar.Id)++;
    }

    /* TIMESTAMPADD or TIMESTAMPDIFF function? */
    if ((lpSqlNode->node.scalar.Id == SCALAR_TIMESTAMPADD) ||
        (lpSqlNode->node.scalar.Id == SCALAR_TIMESTAMPDIFF)) {

        /* Yes.  Get the node with the name of the interval */
        idxInterval = lpSqlNode->node.scalar.Arguments;
        if (idxInterval == NO_SQLNODE) {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        }

        /* Point the node at the rest of the argument list */
        lpSqlNodeValues = ToNode(*lplpSql, idxInterval);
        lpSqlNode->node.scalar.Arguments = lpSqlNodeValues->node.values.Next;

        /* Look at the node specifying the interval */
        lpSqlNodeValue = ToNode(*lplpSql, lpSqlNodeValues->node.values.Value);
        if (lpSqlNodeValue->sqlNodeType != NODE_TYPE_COLUMN) {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        }
        if (lpSqlNodeValue->node.column.Tablealias != NO_STRING) {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        }
        lpstrInterval = ToString(*lplpSql, lpSqlNodeValue->node.column.Column);
        if (!s_lstrcmpi(lpstrInterval, "SQL_TSI_FRAC_SECOND"))
            return ERR_NOTSUPPORTED;
        else if (!s_lstrcmpi(lpstrInterval, "SQL_TSI_SECOND"))
            lpSqlNode->node.scalar.Interval = SQL_TSI_SECOND;
        else if (!s_lstrcmpi(lpstrInterval, "SQL_TSI_MINUTE"))
            lpSqlNode->node.scalar.Interval = SQL_TSI_MINUTE;
        else if (!s_lstrcmpi(lpstrInterval, "SQL_TSI_HOUR"))
            lpSqlNode->node.scalar.Interval = SQL_TSI_HOUR;
        else if (!s_lstrcmpi(lpstrInterval, "SQL_TSI_DAY"))
            lpSqlNode->node.scalar.Interval = SQL_TSI_DAY;
        else if (!s_lstrcmpi(lpstrInterval, "SQL_TSI_WEEK"))
            lpSqlNode->node.scalar.Interval = SQL_TSI_WEEK;
        else if (!s_lstrcmpi(lpstrInterval, "SQL_TSI_MONTH"))
            lpSqlNode->node.scalar.Interval = SQL_TSI_MONTH;
        else if (!s_lstrcmpi(lpstrInterval, "SQL_TSI_QUARTER"))
            lpSqlNode->node.scalar.Interval = SQL_TSI_QUARTER;
        else if (!s_lstrcmpi(lpstrInterval, "SQL_TSI_YEAR"))
            lpSqlNode->node.scalar.Interval = SQL_TSI_YEAR;
        else {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        }
    }

    /* CONVERT function? */
    else if (lpSqlNode->node.scalar.Id == SCALAR_CONVERT) {

        /* Yes.  Get the node with the name of the type */
        idxType = lpSqlNode->node.scalar.Arguments;
        if (idxType == NO_SQLNODE) {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        }
        lpSqlNodeValues = ToNode(*lplpSql, idxType);
        idxType = lpSqlNodeValues->node.values.Next;
        if (idxType == NO_SQLNODE) {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        }

        /* Take type name off the argument list */
        lpSqlNodeValues->node.values.Next = NO_SQLNODE;
        lpSqlNodeValues = ToNode(*lplpSql, idxType);
        if (lpSqlNodeValues->node.values.Next != NO_SQLNODE) {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        }

        /* Get the type name */
        lpSqlNodeValue = ToNode(*lplpSql, lpSqlNodeValues->node.values.Value);
        if (lpSqlNodeValue->sqlNodeType != NODE_TYPE_COLUMN) {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        }
        if (lpSqlNodeValue->node.column.Tablealias != NO_STRING) {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        }
        lpstrType = ToString(*lplpSql, lpSqlNodeValue->node.column.Column);
    }

    /* Semantic check the arguments */
    err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.scalar.Arguments,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);
    if (err != ERR_SUCCESS)
        return err;

    /* Look for correct entry for the function */
    while (TRUE) {

        /* See if datatypes of arguments match */
        idxValues = lpSqlNode->node.scalar.Arguments;
        err = ERR_SUCCESS;
        for (idx = 0; idx < lpScalarFunc->argCount; idx++) {

            /* Error if not enough arguments */
            if (idxValues == NO_SQLNODE) {
                err = ERR_SCALARBADARG;
                break;
            }

            /* Error if a parameter */
            lpSqlNodeValues = ToNode(*lplpSql, idxValues);
            lpSqlNodeValue = ToNode(*lplpSql,
                                    lpSqlNodeValues->node.values.Value);
            if (lpSqlNodeValue->sqlNodeType == NODE_TYPE_PARAMETER)
                return ERR_UNKNOWNTYPE;

            /* Error if NULL specified */
            if (lpSqlNodeValue->sqlNodeType == NODE_TYPE_NULL) {
                s_lstrcpy(lpstmt->szError, lpszFunction);
                return ERR_SCALARBADARG;
            }

            /* Error if long value specified */
            if ((lpSqlNodeValue->sqlSqlType == SQL_LONGVARCHAR) ||
                (lpSqlNodeValue->sqlSqlType == SQL_LONGVARBINARY)) {
                s_lstrcpy(lpstmt->szError, lpszFunction);
                return ERR_SCALARBADARG;
            }

            /* Check the argument type */
            if (lpScalarFunc->argType[idx] != TYPE_UNKNOWN) {
                if (lpSqlNodeValue->sqlDataType !=
                                                lpScalarFunc->argType[idx]) {
                    err = ERR_SCALARBADARG;
                    break;
                }
            }
        
            /* Check the next argument */
            idxValues = lpSqlNodeValues->node.values.Next;
        }

        /* If this entry matches, leave the loop. */
        if ((idxValues == NO_SQLNODE) && (err == ERR_SUCCESS))
            break;

        /* Point at the next function */
        (lpSqlNode->node.scalar.Id)++;

        /* If no more entries match this function name, error */
        lpScalarFunc = &(scalarFuncs[lpSqlNode->node.scalar.Id]);
        if (s_lstrcmpi(lpScalarFunc->name,
                     ToString(*lplpSql, lpSqlNode->node.scalar.Function))) {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        }
    }

    /* Get pointer to first argument */
    if (lpScalarFunc->argCount > 0) {
        lpSqlNodeValues = ToNode(*lplpSql, lpSqlNode->node.scalar.Arguments);
        lpSqlNodeValue = ToNode(*lplpSql, lpSqlNodeValues->node.values.Value);
    }
    else {
        lpSqlNodeValues = NULL;
        lpSqlNodeValue = NULL;
    }

    /* Convert function? */
    if (lpSqlNode->node.scalar.Id != SCALAR_CONVERT) {

        /* No.  Set data type, SQL type, precision, scale */
        lpSqlNode->sqlDataType = lpScalarFunc->dataType;
        lpSqlNode->sqlSqlType = lpScalarFunc->sqlType;
        lpSqlNode->sqlPrecision = lpScalarFunc->precision;
        lpSqlNode->sqlScale = lpScalarFunc->scale;

        /* Inherit SQL type, precision, scale as need be */
        if (lpSqlNode->sqlSqlType == SQL_TYPE_NULL)
            lpSqlNode->sqlSqlType = lpSqlNodeValue->sqlSqlType;
        if (lpSqlNode->sqlPrecision == 0) {
            lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
            lpSqlNode->sqlScale = lpSqlNodeValue->sqlScale;
        }
    }
    else {

        /* Yes.  Set up resultant type */
        if (!s_lstrcmpi(lpstrType, "SQL_BIGINT")) {
            lpSqlNode->sqlDataType = TYPE_NUMERIC;
            lpSqlNode->sqlSqlType = SQL_BIGINT;
            switch (lpSqlNodeValue->sqlDataType) {
            case TYPE_INTEGER:
            case TYPE_NUMERIC:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                break;
            case TYPE_DOUBLE:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                break;
            case TYPE_CHAR:
                lpSqlNode->sqlPrecision = 20;
                break;
            case TYPE_BINARY:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                break;
            case TYPE_TIME:
            case TYPE_DATE:
            case TYPE_TIMESTAMP:
                return ERR_NOTCONVERTABLE;
            default:
                return ERR_NOTSUPPORTED;
            }
            lpSqlNode->sqlScale = 0;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_BINARY") ||
                 !s_lstrcmpi(lpstrType, "SQL_VARBINARY")) {
            lpSqlNode->sqlDataType = TYPE_BINARY;
            if (!s_lstrcmpi(lpstrType, "SQL_BINARY"))
                lpSqlNode->sqlSqlType = SQL_BINARY;
            else
                lpSqlNode->sqlSqlType = SQL_VARBINARY;
            switch (lpSqlNodeValue->sqlSqlType) {
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
                if (lpSqlNodeValue->sqlScale == 0)
                    lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision+2;
                else
                    lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision+1;
                break;
            case SQL_TINYINT:
                lpSqlNode->sqlPrecision = sizeof(char);
                break;
            case SQL_SMALLINT:
                lpSqlNode->sqlPrecision = sizeof(short);
                break;
            case SQL_INTEGER:
                lpSqlNode->sqlPrecision = sizeof(long);
                break;
            case SQL_BIT:
                lpSqlNode->sqlPrecision = sizeof(unsigned char);
                break;
            case SQL_REAL:
                lpSqlNode->sqlPrecision = sizeof(float);
                break;
            case SQL_FLOAT:
            case SQL_DOUBLE:
                lpSqlNode->sqlPrecision = sizeof(double);
                break;
            case SQL_CHAR:
            case SQL_VARCHAR:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                break;
            case SQL_LONGVARCHAR:
                return ERR_NOTSUPPORTED;
            case SQL_BINARY:
            case SQL_VARBINARY:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                break;
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_DATE:
                lpSqlNode->sqlPrecision = sizeof(DATE_STRUCT);
                break;
            case SQL_TIME:
                lpSqlNode->sqlPrecision = sizeof(TIME_STRUCT);
                break;
            case SQL_TIMESTAMP:
                lpSqlNode->sqlPrecision = sizeof(TIMESTAMP_STRUCT);
                break;
            default:
                return ERR_NOTSUPPORTED;
            }
            lpSqlNode->sqlScale = NO_SCALE;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_BIT")) {
            lpSqlNode->sqlDataType = TYPE_INTEGER;
            lpSqlNode->sqlSqlType = SQL_BIT;
            lpSqlNode->sqlPrecision = 1;
            lpSqlNode->sqlScale = 0;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_CHAR") ||
                 !s_lstrcmpi(lpstrType, "SQL_VARCHAR")) {
            lpSqlNode->sqlDataType = TYPE_CHAR;
            if (!s_lstrcmpi(lpstrType, "SQL_CHAR"))
                lpSqlNode->sqlSqlType = SQL_CHAR;
            else
                lpSqlNode->sqlSqlType = SQL_VARCHAR;
            switch (lpSqlNodeValue->sqlSqlType) {
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
                if (lpSqlNodeValue->sqlScale == 0)
                    lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision+2;
                else
                    lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision+1;
                break;
            case SQL_TINYINT:
                lpSqlNode->sqlPrecision = 4;
                break;
            case SQL_SMALLINT:
                lpSqlNode->sqlPrecision = 6;
                break;
            case SQL_INTEGER:
                lpSqlNode->sqlPrecision = 11;
                break;
            case SQL_BIT:
                lpSqlNode->sqlPrecision = 1;
                break;
            case SQL_REAL:
                lpSqlNode->sqlPrecision = 13;
                break;
            case SQL_FLOAT:
            case SQL_DOUBLE:
                lpSqlNode->sqlPrecision = 22;
                break;
            case SQL_CHAR:
            case SQL_VARCHAR:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                break;
            case SQL_LONGVARCHAR:
                return ERR_NOTSUPPORTED;
            case SQL_BINARY:
            case SQL_VARBINARY:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision * 2;
                if (lpSqlNode->sqlPrecision >= MAX_CHAR_LITERAL_LENGTH)
                    lpSqlNode->sqlPrecision = MAX_CHAR_LITERAL_LENGTH;
                break;
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_DATE:
                lpSqlNode->sqlPrecision = 10;
                break;
            case SQL_TIME:
                lpSqlNode->sqlPrecision = 8;
                break;
            case SQL_TIMESTAMP:
                if (TIMESTAMP_SCALE > 0)
                    lpSqlNode->sqlPrecision = 20 + TIMESTAMP_SCALE;
                else
                    lpSqlNode->sqlPrecision = 19;
                break;
            default:
                return ERR_NOTSUPPORTED;
            }
            lpSqlNode->sqlScale = NO_SCALE;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_DATE")) {
            lpSqlNode->sqlDataType = TYPE_DATE;
            lpSqlNode->sqlSqlType = SQL_DATE;
            lpSqlNode->sqlPrecision = 10;
            lpSqlNode->sqlScale = NO_SCALE;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_DECIMAL")) {
            lpSqlNode->sqlDataType = TYPE_NUMERIC;
            lpSqlNode->sqlSqlType = SQL_DECIMAL;
            switch (lpSqlNodeValue->sqlDataType) {
            case TYPE_INTEGER:
            case TYPE_NUMERIC:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                lpSqlNode->sqlScale = lpSqlNodeValue->sqlScale;
                break;
            case TYPE_DOUBLE:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                lpSqlNode->sqlScale = 3;
                break;
            case TYPE_CHAR:
                lpSqlNode->sqlPrecision = 15;
                lpSqlNode->sqlScale = 3;
                break;
            case TYPE_BINARY:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                lpSqlNode->sqlScale = 3;
                break;
            case TYPE_TIME:
            case TYPE_DATE:
            case TYPE_TIMESTAMP:
                return ERR_NOTCONVERTABLE;
            default:
                return ERR_NOTSUPPORTED;
            }
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_DOUBLE")) {
            lpSqlNode->sqlDataType = TYPE_DOUBLE;
            lpSqlNode->sqlSqlType = SQL_DOUBLE;
            lpSqlNode->sqlPrecision = 15;
            lpSqlNode->sqlScale = NO_SCALE;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_FLOAT")) {
            lpSqlNode->sqlDataType = TYPE_DOUBLE;
            lpSqlNode->sqlSqlType = SQL_FLOAT;
            lpSqlNode->sqlPrecision = 15;
            lpSqlNode->sqlScale = NO_SCALE;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_INTEGER")) {
            lpSqlNode->sqlDataType = TYPE_INTEGER;
            lpSqlNode->sqlSqlType = SQL_INTEGER;
            lpSqlNode->sqlPrecision = 10;
            lpSqlNode->sqlScale = 0;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_LONGVARBINARY")) {
            return ERR_NOTSUPPORTED;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_LONGVARCHAR")) {
            return ERR_NOTSUPPORTED;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_NUMERIC")) {
            lpSqlNode->sqlDataType = TYPE_NUMERIC;
            lpSqlNode->sqlSqlType = SQL_NUMERIC;
            switch (lpSqlNodeValue->sqlDataType) {
            case TYPE_INTEGER:
            case TYPE_NUMERIC:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                lpSqlNode->sqlScale = lpSqlNodeValue->sqlScale;
                break;
            case TYPE_DOUBLE:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                lpSqlNode->sqlScale = 3;
                break;
            case TYPE_CHAR:
                lpSqlNode->sqlPrecision = 15;
                lpSqlNode->sqlScale = 3;
                break;
            case TYPE_BINARY:
                lpSqlNode->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                lpSqlNode->sqlScale = 3;
                break;
            case TYPE_TIME:
            case TYPE_DATE:
            case TYPE_TIMESTAMP:
                return ERR_NOTCONVERTABLE;
            default:
                return ERR_NOTSUPPORTED;
            }
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_REAL")) {
            lpSqlNode->sqlDataType = TYPE_DOUBLE;
            lpSqlNode->sqlSqlType = SQL_REAL;
            lpSqlNode->sqlPrecision = 7;
            lpSqlNode->sqlScale = NO_SCALE;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_SMALLINT")) {
            lpSqlNode->sqlDataType = TYPE_INTEGER;
            lpSqlNode->sqlSqlType = SQL_SMALLINT;
            lpSqlNode->sqlPrecision = 5;
            lpSqlNode->sqlScale = 0;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_TIME")) {
            lpSqlNode->sqlDataType = TYPE_TIME;
            lpSqlNode->sqlSqlType = SQL_TIME;
            lpSqlNode->sqlPrecision = 6;
            lpSqlNode->sqlScale = NO_SCALE;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_TIMESTAMP")) {
            lpSqlNode->sqlDataType = TYPE_TIMESTAMP;
            lpSqlNode->sqlSqlType = SQL_TIMESTAMP;
            if (TIMESTAMP_SCALE > 0)
                lpSqlNode->sqlPrecision = 20 + TIMESTAMP_SCALE;
            else
                lpSqlNode->sqlPrecision = 19;
            lpSqlNode->sqlScale = TIMESTAMP_SCALE;
        }
        else if (!s_lstrcmpi(lpstrType, "SQL_TINYINT")) {
            lpSqlNode->sqlDataType = TYPE_INTEGER;
            lpSqlNode->sqlSqlType = SQL_TINYINT;
            lpSqlNode->sqlPrecision = 3;
            lpSqlNode->sqlScale = 0;
        }
        else {
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        }
    }

    /* Adjust the resultant type information as need be */
    switch (lpSqlNode->node.scalar.Id) {
    case SCALAR_ASCII:
    case SCALAR_CHAR:
        break;
    case SCALAR_CONCAT:
        lpSqlNodeValues = ToNode(*lplpSql, lpSqlNodeValues->node.values.Next);
        lpSqlNodeValue = ToNode(*lplpSql, lpSqlNodeValues->node.values.Value);
        lpSqlNode->sqlPrecision += (lpSqlNodeValue->sqlPrecision);
        lpSqlNode->sqlPrecision = MIN(lpSqlNode->sqlPrecision,
                                           MAX_CHAR_LITERAL_LENGTH);
        break;
    case SCALAR_DIFFERENCE:
    case SCALAR_INSERT:
    case SCALAR_LCASE:
    case SCALAR_LEFT:
    case SCALAR_LENGTH:
    case SCALAR_LOCATE:
    case SCALAR_LOCATE_START:
    case SCALAR_LTRIM:
    case SCALAR_REPEAT:
    case SCALAR_REPLACE:
    case SCALAR_RIGHT:
    case SCALAR_RTRIM:
    case SCALAR_SOUNDEX:
    case SCALAR_SPACE:
    case SCALAR_SUBSTRING:
    case SCALAR_UCASE:
    case SCALAR_ABS_DOUBLE:
    case SCALAR_ABS_NUMERIC:
    case SCALAR_ABS_INTEGER:
    case SCALAR_ACOS:
    case SCALAR_ASIN:
    case SCALAR_ATAN:
    case SCALAR_ATAN2:
    case SCALAR_CEILING_DOUBLE:
    case SCALAR_CEILING_NUMERIC:
    case SCALAR_CEILING_INTEGER:
    case SCALAR_COS:
    case SCALAR_COT:
    case SCALAR_DEGREES_DOUBLE:
    case SCALAR_DEGREES_NUMERIC:
    case SCALAR_DEGREES_INTEGER:
    case SCALAR_EXP:
    case SCALAR_FLOOR_DOUBLE:
    case SCALAR_FLOOR_NUMERIC:
    case SCALAR_FLOOR_INTEGER:
    case SCALAR_LOG:
    case SCALAR_LOG10:
    case SCALAR_MOD:
    case SCALAR_PI:
    case SCALAR_POWER_DOUBLE:
    case SCALAR_POWER_NUMERIC:
    case SCALAR_POWER_INTEGER:
    case SCALAR_RADIANS_DOUBLE:
    case SCALAR_RADIANS_NUMERIC:
    case SCALAR_RADIANS_INTEGER:
    case SCALAR_RAND:
    case SCALAR_RAND_SEED_DOUBLE:
    case SCALAR_RAND_SEED_NUMERIC:
    case SCALAR_RAND_SEED_INTEGER:
    case SCALAR_ROUND_DOUBLE:
    case SCALAR_ROUND_NUMERIC:
    case SCALAR_ROUND_INTEGER:
    case SCALAR_SIGN_DOUBLE:
    case SCALAR_SIGN_NUMERIC:
    case SCALAR_SIGN_INTEGER:
    case SCALAR_SIN:
    case SCALAR_SQRT:
    case SCALAR_TAN:
    case SCALAR_TRUNCATE_DOUBLE:
    case SCALAR_TRUNCATE_NUMERIC:
    case SCALAR_TRUNCATE_INTEGER:
    case SCALAR_CURDATE:
    case SCALAR_CURTIME:
        break;
    case SCALAR_DAYNAME:
        switch (lpSqlNodeValue->sqlDataType) {
        case TYPE_CHAR:
        case TYPE_DATE:
        case TYPE_TIMESTAMP:
            break;
        case TYPE_TIME:
        case TYPE_DOUBLE:
        case TYPE_NUMERIC:
        case TYPE_INTEGER:
        case TYPE_BINARY:
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        default:
            return ERR_NOTSUPPORTED;
        }
        break;
    case SCALAR_DAYOFMONTH_CHAR:
    case SCALAR_DAYOFMONTH_DATE:
    case SCALAR_DAYOFMONTH_TIMESTAMP:
        break;
    case SCALAR_DAYOFWEEK:
        switch (lpSqlNodeValue->sqlDataType) {
        case TYPE_CHAR:
        case TYPE_DATE:
        case TYPE_TIMESTAMP:
            break;
        case TYPE_TIME:
        case TYPE_DOUBLE:
        case TYPE_NUMERIC:
        case TYPE_INTEGER:
        case TYPE_BINARY:
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        default:
            return ERR_NOTSUPPORTED;
        }
        break;
    case SCALAR_DAYOFYEAR:
        switch (lpSqlNodeValue->sqlDataType) {
        case TYPE_CHAR:
        case TYPE_DATE:
        case TYPE_TIMESTAMP:
            break;
        case TYPE_TIME:
        case TYPE_DOUBLE:
        case TYPE_NUMERIC:
        case TYPE_INTEGER:
        case TYPE_BINARY:
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        default:
            return ERR_NOTSUPPORTED;
        }
        break;
    case SCALAR_HOUR_CHAR:
    case SCALAR_HOUR_TIME:
    case SCALAR_HOUR_TIMESTAMP:
    case SCALAR_MINUTE_CHAR:
    case SCALAR_MINUTE_TIME:
    case SCALAR_MINUTE_TIMESTAMP:
    case SCALAR_MONTH_CHAR:
    case SCALAR_MONTH_DATE:
    case SCALAR_MONTH_TIMESTAMP:
    case SCALAR_MONTHNAME_CHAR:
    case SCALAR_MONTHNAME_DATE:
    case SCALAR_MONTHNAME_TIMESTAMP:
    case SCALAR_NOW:
    case SCALAR_QUARTER_CHAR:
    case SCALAR_QUARTER_DATE:
    case SCALAR_QUARTER_TIMESTAMP:
    case SCALAR_SECOND_CHAR:
    case SCALAR_SECOND_TIME:
    case SCALAR_SECOND_TIMESTAMP:
        break;
    case SCALAR_TIMESTAMPADD:
        lpSqlNodeValues = ToNode(*lplpSql, lpSqlNodeValues->node.values.Next);
        lpSqlNodeValue2 = ToNode(*lplpSql, lpSqlNodeValues->node.values.Value);
        switch (lpSqlNodeValue2->sqlDataType) {
        case TYPE_CHAR:
        case TYPE_DATE:
        case TYPE_TIME:
        case TYPE_TIMESTAMP:
            break;
        case TYPE_DOUBLE:
        case TYPE_NUMERIC:
        case TYPE_INTEGER:
        case TYPE_BINARY:
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        default:
            return ERR_NOTSUPPORTED;
        }
        break;
    case SCALAR_TIMESTAMPDIFF:
        switch (lpSqlNodeValue->sqlDataType) {
        case TYPE_CHAR:
        case TYPE_DATE:
        case TYPE_TIME:
        case TYPE_TIMESTAMP:
            break;
        case TYPE_DOUBLE:
        case TYPE_NUMERIC:
        case TYPE_INTEGER:
        case TYPE_BINARY:
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        default:
            return ERR_NOTSUPPORTED;
        }
        lpSqlNodeValues = ToNode(*lplpSql, lpSqlNodeValues->node.values.Next);
        lpSqlNodeValue2 = ToNode(*lplpSql, lpSqlNodeValues->node.values.Value);
        switch (lpSqlNodeValue2->sqlDataType) {
        case TYPE_CHAR:
        case TYPE_DATE:
        case TYPE_TIME:
        case TYPE_TIMESTAMP:
            break;
        case TYPE_DOUBLE:
        case TYPE_NUMERIC:
        case TYPE_INTEGER:
        case TYPE_BINARY:
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        default:
            return ERR_NOTSUPPORTED;
        }
        break;
    case SCALAR_WEEK:
        switch (lpSqlNodeValue->sqlDataType) {
        case TYPE_CHAR:
        case TYPE_DATE:
        case TYPE_TIMESTAMP:
            break;
        case TYPE_TIME:
        case TYPE_DOUBLE:
        case TYPE_NUMERIC:
        case TYPE_INTEGER:
        case TYPE_BINARY:
            s_lstrcpy(lpstmt->szError, lpszFunction);
            return ERR_SCALARBADARG;
        default:
            return ERR_NOTSUPPORTED;
        }
        break;
    case SCALAR_YEAR_CHAR:
    case SCALAR_YEAR_DATE:
    case SCALAR_YEAR_TIMESTAMP:
    case SCALAR_DATABASE:
        break;
    case SCALAR_IFNULL:
        lpSqlNodeValues = ToNode(*lplpSql, lpSqlNodeValues->node.values.Next);
        lpSqlNodeValue2 = ToNode(*lplpSql, lpSqlNodeValues->node.values.Value);
        err = ScalarIfNullType(lpSqlNodeValue, lpSqlNodeValue2, lpSqlNode);
        if (err != ERR_SUCCESS) {
            if (err == ERR_SCALARBADARG)
                s_lstrcpy(lpstmt->szError, lpszFunction);
            return err;
        }
        break;
    case SCALAR_USER:
        break;
    case SCALAR_CONVERT:
        break;
    }

    return ERR_SUCCESS;
}
/***************************************************************************/
SWORD INTFUNC StringLocate(LPUSTR lpstrSearchString, LPUSTR lpstrString,
                           SWORD start)
{
    SWORD lenString;
    SWORD lenSearchString;
    SWORD idx;

    /* Get the length of the strings */
    lenString = (SWORD) s_lstrlen(lpstrString);
    lenSearchString = (SWORD) s_lstrlen(lpstrSearchString);

    /* If the search string is no bigger than the string, and the starting */
    /* location is within the string... */
    if ((lenSearchString <= lenString) && (start <= lenString)) {

        /* Look at each possible starting location until string is found */
        for (start--; start < lenString - lenSearchString + 1; start++) {

            /* See if the strings are equal */
            for (idx = 0; idx < lenSearchString; idx++) {
                if (lpstrString[start+idx] != lpstrSearchString[idx])
                    break;
            }

            /* Are they equal? */
            if (idx == lenSearchString) {

                /* Yes.  Return it */
                return (start + 1);
                break;
            }
        }
    }

    /* Search string not found */
    return 0;
}
/***************************************************************************/
RETCODE INTFUNC MakeDate(LPSQLNODE lpSqlNode, struct tm *lpTs)
{
    DATE_STRUCT date;
    RETCODE err;

    switch(lpSqlNode->sqlDataType) {
    case TYPE_CHAR:
        err = CharToDate(lpSqlNode->value.String,
                         s_lstrlen(lpSqlNode->value.String), &date);
        if (err != ERR_SUCCESS)
            return err;
        break;
    case TYPE_DOUBLE:
    case TYPE_NUMERIC:
    case TYPE_INTEGER:
        return ERR_INTERNAL;
    case TYPE_DATE:
        date = lpSqlNode->value.Date;
        break;
    case TYPE_TIME:
        return ERR_INTERNAL;
    case TYPE_TIMESTAMP:
        date.month = lpSqlNode->value.Timestamp.month;
        date.day = lpSqlNode->value.Timestamp.day;
        date.year = lpSqlNode->value.Timestamp.year;
        break;
    case TYPE_BINARY:
        return ERR_INTERNAL;
    default:
        return ERR_NOTSUPPORTED;
    }
    lpTs->tm_mon = date.month - 1;
    lpTs->tm_mday = date.day;
    lpTs->tm_year = date.year - 1900;
    lpTs->tm_hour = 0;
    lpTs->tm_min = 0;
    lpTs->tm_sec = 0;
    lpTs->tm_isdst = 0;
    if (mktime(lpTs) == -1)
        return ERR_NOTCONVERTABLE;
    if (lpTs->tm_isdst != 0) {
        lpTs->tm_mon = date.month - 1;
        lpTs->tm_mday = date.day;
        lpTs->tm_year = date.year - 1900;
        lpTs->tm_hour = 0;
        lpTs->tm_min = 0;
        lpTs->tm_sec = 0;
        lpTs->tm_isdst = 1;
        if (mktime(lpTs) == -1)
            return ERR_NOTCONVERTABLE;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/
RETCODE INTFUNC MakeTimestamp(LPSQLNODE lpSqlNode, struct tm *lpTs,
                              time_t *lpT)
{
    TIMESTAMP_STRUCT timestamp;
    RETCODE err;

    switch(lpSqlNode->sqlDataType) {
    case TYPE_CHAR:
        err = CharToTimestamp(lpSqlNode->value.String,
                         s_lstrlen(lpSqlNode->value.String), &timestamp);
        if (err != ERR_SUCCESS)
            return err;
        break;
    case TYPE_DOUBLE:
    case TYPE_NUMERIC:
    case TYPE_INTEGER:
        return ERR_INTERNAL;
    case TYPE_DATE:
        timestamp.month = lpSqlNode->value.Date.month;
        timestamp.day = lpSqlNode->value.Date.day;
        timestamp.year = lpSqlNode->value.Date.year;
        timestamp.hour = 0;
        timestamp.minute = 0;
        timestamp.second = 0;
        timestamp.fraction = 0;
        break;
    case TYPE_TIME:
        time(lpT);
        lpTs = localtime(lpT);
        timestamp.month = lpTs->tm_mon + 1;
        timestamp.day = (UWORD) lpTs->tm_mday;
        timestamp.year = lpTs->tm_year + 1900;
        timestamp.hour = lpSqlNode->value.Time.hour;
        timestamp.minute = lpSqlNode->value.Time.minute;
        timestamp.second = lpSqlNode->value.Time.second;
        timestamp.fraction = 0;
        break;
    case TYPE_TIMESTAMP:
        timestamp = lpSqlNode->value.Timestamp;
        break;
    case TYPE_BINARY:
        return ERR_INTERNAL;
    default:
        return ERR_NOTSUPPORTED;
    }
    lpTs->tm_mon = timestamp.month - 1;
    lpTs->tm_mday = timestamp.day;
    lpTs->tm_year = timestamp.year - 1900;
    lpTs->tm_hour = timestamp.hour;
    lpTs->tm_min = timestamp.minute;
    lpTs->tm_sec = timestamp.second;
    lpTs->tm_isdst = 0;
    *lpT = mktime(lpTs);
    if (*lpT == -1)
        return ERR_NOTCONVERTABLE;
    if (lpTs->tm_isdst != 0) {
        lpTs->tm_mon = timestamp.month - 1;
        lpTs->tm_mday = timestamp.day;
        lpTs->tm_year = timestamp.year - 1900;
        lpTs->tm_hour = timestamp.hour;
        lpTs->tm_min = timestamp.minute;
        lpTs->tm_sec = timestamp.second;
        lpTs->tm_isdst = 1;
        *lpT = mktime(lpTs);
        if (*lpT == -1)
            return ERR_NOTCONVERTABLE;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/
#define MAXSOUNDEX 30

void INTFUNC soundex(LPUSTR in_str, LPUSTR out_str)
{
    UCHAR sdex[MAXSOUNDEX+1];
    const UCHAR soundex_table[] = "ABCDABCAACCLMMABCRCDABACAC";
                           /* ABCDEFGHIJKLMNOPQRSTUVWXYZ */

    UWORD val;
    UWORD inpos; 
    UWORD outpos; 
    UWORD inlength;
    UCHAR thischar;
    UCHAR lastchar;

      
    AnsiUpper((LPSTR) in_str);
    inpos = 0;
    outpos = 0;
    lastchar = '0';
    inlength = (UWORD) s_lstrlen(in_str);
    
    while ((inpos < inlength) && (outpos < MAXSOUNDEX)) {
        thischar = in_str[inpos];
        if ((thischar >= 'A') && (thischar <= 'Z')) {
            val = thischar - 'A';
            if (inpos == 0) {
                sdex[0] = thischar;
                inpos++;
                outpos++;
                lastchar = soundex_table[val];
                continue;
            }
        }
        else
            val = 0;
        thischar = soundex_table[val];
        if (lastchar == thischar) {
            inpos++;
            continue;
        }
        sdex[outpos] = thischar;
        outpos++;
        lastchar = thischar;
        inpos++;
    }
    sdex[outpos] = '\0';
    s_lstrcpy(out_str, sdex);
}

/***************************************************************************/

SDWORD INTFUNC soundexDifference(LPUSTR str1, LPUSTR str2)
{
    UCHAR sdex1[MAXSOUNDEX+1];
    UCHAR sdex2[MAXSOUNDEX+1];

    soundex(str1, sdex1);
    soundex(str2, sdex2);
    return (SDWORD) ((sdex1[0]-sdex2[0])*10000000 +
                     (sdex1[1]-sdex2[1])*100000 +
                     (sdex1[2]-sdex2[2])*1000 +
                     (sdex1[3]-sdex2[3])*10 +
                     s_lstrcmp(sdex1+4,sdex2+4));
}
/***************************************************************************/
RETCODE INTFUNC InternalEvaluateScalar(LPSTMT lpstmt, LPSQLNODE lpSqlNode)
{
    LPSCALARFUNC lpScalarFunc;
    UWORD idx;
    LPUSTR lpFrom;
    LPUSTR lpTo;
    UCHAR nibble;
    SQLNODEIDX idxValues;
    LPSQLNODE lpSqlNodeValues;
    LPSQLNODE lpSqlNodeValue[MAX_SCALAR_ARGS];
    LPSQLNODE lpSqlNodeReturnValue;
    RETCODE err;
    LPUSTR lpstr1;
    LPUSTR lpstr2;
    LPUSTR lpstr3;
    LPUSTR lpstr4;
    SWORD sw1;
    SWORD sw2;
    SWORD sw3;
    SWORD sw4;
    UCHAR szBuffer[MAX_CHAR_LITERAL_LENGTH+1];
    SWORD location;
    SWORD length;
    double dbl;
    double power;
    char chr;
    unsigned char uchr;
    long lng;
    short shrt;
    float flt;
    BOOL   fFractionalPart;
    SQLNODE sqlNode;
#ifdef WIN32
    struct tm ts;
    struct tm ts2;
    time_t t;
    time_t t2;
#else
    static struct tm ts;
    static struct tm ts2;
    static time_t t;
    static time_t t2;
#endif
    struct tm *lpTs;
    DATE_STRUCT sDate;
    TIME_STRUCT sTime;
    long seed1;
    long seed2;
    long seed3;

    /* For each argument... */
    lpScalarFunc = &(scalarFuncs[lpSqlNode->node.scalar.Id]);
    idxValues = lpSqlNode->node.scalar.Arguments;
    for (idx = 0; idx < lpScalarFunc->argCount; idx++) {

        /* Get value of the argument */
        lpSqlNodeValues = ToNode(lpstmt->lpSqlStmt, idxValues);
        lpSqlNodeValue[idx] = ToNode(lpstmt->lpSqlStmt,
                                    lpSqlNodeValues->node.values.Value);
        err = EvaluateExpression(lpstmt, lpSqlNodeValue[idx]);
        if (err != ERR_SUCCESS)
            return err;

        /* If argument is null, the result is null */
        if (lpSqlNode->node.scalar.Id != SCALAR_IFNULL) {
            if (lpSqlNodeValue[idx]->sqlIsNull) {
                lpSqlNode->sqlIsNull = TRUE;
                switch (lpSqlNode->sqlDataType) {
                case TYPE_DOUBLE:
                    lpSqlNode->value.Double = 0.0;
                    break;
                case TYPE_NUMERIC:
                    s_lstrcpy(lpSqlNode->value.String, "");
                    break;
                case TYPE_INTEGER:
                    lpSqlNode->value.Double = 0.0;
                    break;
                case TYPE_CHAR:
                    s_lstrcpy(lpSqlNode->value.String, "");
                    break;
                case TYPE_BINARY:
                    BINARY_LENGTH(lpSqlNode->value.Binary) = 0;
                    break;
                case TYPE_DATE:
                    lpSqlNode->value.Date.year = 0;
                    lpSqlNode->value.Date.month = 0;
                    lpSqlNode->value.Date.day = 0;
                    break;
                case TYPE_TIME:
                    lpSqlNode->value.Time.hour = 0;
                    lpSqlNode->value.Time.minute = 0;
                    lpSqlNode->value.Time.second = 0;
                    break;
                case TYPE_TIMESTAMP:
                    lpSqlNode->value.Timestamp.year = 0;
                    lpSqlNode->value.Timestamp.month = 0;
                    lpSqlNode->value.Timestamp.day = 0;
                    lpSqlNode->value.Timestamp.hour = 0;
                    lpSqlNode->value.Timestamp.minute = 0;
                    lpSqlNode->value.Timestamp.second = 0;
                    lpSqlNode->value.Timestamp.fraction = 0;
                    break;
                }
                return ERR_SUCCESS;
            } 
        }

        idxValues = lpSqlNodeValues->node.values.Next;
    }

    /* Do the function */
    lpSqlNode->sqlIsNull = FALSE;
    switch (lpSqlNode->node.scalar.Id) {
    case SCALAR_ASCII:
        lpSqlNode->value.Double =
                            (double) lpSqlNodeValue[0]->value.String[0];
        break;
    case SCALAR_CHAR:
        lpSqlNode->value.String[0] = (UCHAR) lpSqlNodeValue[0]->value.Double;
        lpSqlNode->value.String[1] = '\0';
        break;
    case SCALAR_CONCAT:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        lpstr2 = lpSqlNodeValue[1]->value.String;
        if ((s_lstrlen(lpstr1) + s_lstrlen(lpstr2)) > lpSqlNode->sqlPrecision)
            return ERR_CONCATOVERFLOW;
        s_lstrcpy(lpSqlNode->value.String, lpstr1);
        s_lstrcat(lpSqlNode->value.String, lpstr2);
        break;
    case SCALAR_DIFFERENCE:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        lpstr2 = lpSqlNodeValue[1]->value.String;
        lpSqlNode->value.Double = soundexDifference(lpstr1, lpstr2);
        break;
    case SCALAR_INSERT:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        sw2 = (SWORD) lpSqlNodeValue[1]->value.Double;
        sw3 = (SWORD) lpSqlNodeValue[2]->value.Double;
        lpstr4 = lpSqlNodeValue[3]->value.String;
        if ((sw2 < 0) || (sw3 < 0)) {
            s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
            return ERR_SCALARBADARG;
        }
        sw1 = (SWORD) s_lstrlen(lpstr1);
        if (sw1 < sw2) {
            s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
            return ERR_SCALARBADARG;
        }
        if (sw3 > (sw1 - sw2 + 1))
            sw3 = sw1 - sw2 + 1;
        sw4 = (SWORD) s_lstrlen(lpstr4);
        if ((sw1 - sw3 + sw4) > MAX_CHAR_LITERAL_LENGTH) {
            s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
            return ERR_SCALARBADARG;
        }
        s_lstrcpy(lpSqlNode->value.String, lpstr1);
        lpSqlNode->value.String[sw2-1] = '\0';
        s_lstrcat(lpSqlNode->value.String, lpstr4);
        s_lstrcat(lpSqlNode->value.String, lpstr1 + sw2 + sw3 - 1);
        break;
    case SCALAR_LCASE:
        s_lstrcpy(lpSqlNode->value.String, lpSqlNodeValue[0]->value.String);
        AnsiLower((LPSTR) lpSqlNode->value.String);
        break;
    case SCALAR_LEFT:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        sw2 = (SWORD) lpSqlNodeValue[1]->value.Double;
        if (sw2 < 0) {
            s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
            return ERR_SCALARBADARG;
        }
        s_lstrcpy(lpSqlNode->value.String, lpstr1);
        if (sw2 < s_lstrlen(lpstr1))
            lpSqlNode->value.String[sw2] = '\0';
        break;
    case SCALAR_LENGTH:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        sw1 = (SWORD) s_lstrlen(lpstr1);
        while ((sw1 > 0) && (lpstr1[sw1 - 1] == ' '))
            sw1--;
        lpSqlNode->value.Double = sw1;
        break;
    case SCALAR_LOCATE:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        lpstr2 = lpSqlNodeValue[1]->value.String;
        sw3 = 1;
        lpSqlNode->value.Double = StringLocate(lpstr1, lpstr2, 1);
        break;
    case SCALAR_LOCATE_START:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        lpstr2 = lpSqlNodeValue[1]->value.String;
        sw3 = (SWORD) lpSqlNodeValue[2]->value.Double;
        if (sw3 <= 0) {
            s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
            return ERR_SCALARBADARG;
        }
        lpSqlNode->value.Double = StringLocate(lpstr1, lpstr2, sw3);
        break;
    case SCALAR_LTRIM:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        sw1 = 0;
        while (lpstr1[sw1] == ' ')
            sw1++;
        s_lstrcpy(lpSqlNode->value.String, lpstr1 + sw1);
        break;
    case SCALAR_REPEAT:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        sw2 = (SWORD) lpSqlNodeValue[1]->value.Double;
        if ((sw2 < 0) || ((sw2 * s_lstrlen(lpstr1)) > MAX_CHAR_LITERAL_LENGTH)) {
            s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
            return ERR_SCALARBADARG;
        }
        s_lstrcpy(lpSqlNode->value.String, "");
        while (sw2 > 0) {
            s_lstrcat(lpSqlNode->value.String, lpstr1);
            sw2--;
        }
        break;
    case SCALAR_REPLACE:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        lpstr2 = lpSqlNodeValue[1]->value.String;
        lpstr3 = lpSqlNodeValue[2]->value.String;
        if (s_lstrlen(lpstr2) == 0) {
            s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
            return ERR_SCALARBADARG;
        }
        s_lstrcpy(lpSqlNode->value.String, lpstr1);
        if (!s_lstrcmp(lpstr2, lpstr3))
            break;
        while (TRUE) {
            location = StringLocate(lpstr2, lpSqlNode->value.String, 1);
            if (location == 0)
                break;
            if ((s_lstrlen(lpSqlNode->value.String) - s_lstrlen(lpstr2) +
                           s_lstrlen(lpstr3)) > MAX_CHAR_LITERAL_LENGTH) {
                s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
                return ERR_SCALARBADARG;
            }
            s_lstrcpy(szBuffer, lpSqlNode->value.String);
            lpSqlNode->value.String[location-1] = '\0';
            s_lstrcat(lpSqlNode->value.String, lpstr3);
            s_lstrcat(lpSqlNode->value.String,
                    szBuffer + location + s_lstrlen(lpstr2) - 1);
        }
        break;
    case SCALAR_RIGHT:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        sw2 = (SWORD) lpSqlNodeValue[1]->value.Double;
        if (sw2 < 0) {
            s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
            return ERR_SCALARBADARG;
        }
        if (sw2 > s_lstrlen(lpstr1))
            sw2 = (SWORD) s_lstrlen(lpstr1);
        s_lstrcpy(lpSqlNode->value.String, lpstr1 + s_lstrlen(lpstr1) - sw2);
        break;
    case SCALAR_RTRIM:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        s_lstrcpy(lpSqlNode->value.String, lpstr1);
        sw1 = (SWORD) s_lstrlen(lpSqlNode->value.String);
        while ((sw1 > 0) && (lpSqlNode->value.String[sw1-1] == ' ')) {
            sw1--;
        }
        lpSqlNode->value.String[sw1] = '\0';
        break;
    case SCALAR_SOUNDEX:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        soundex(lpstr1, lpSqlNode->value.String);
        break;
    case SCALAR_SPACE:
        sw1 = (SWORD) lpSqlNodeValue[0]->value.Double;
        if ((sw1 < 0) || (sw1 > MAX_CHAR_LITERAL_LENGTH)) {
            s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
            return ERR_SCALARBADARG;
        }
        s_lstrcpy(lpSqlNode->value.String, "");
        while (sw1 > 0) {
            s_lstrcat(lpSqlNode->value.String, " ");
            sw1--;
        }
        break;
    case SCALAR_SUBSTRING:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        sw2 = (SWORD) lpSqlNodeValue[1]->value.Double;
        sw3 = (SWORD) lpSqlNodeValue[2]->value.Double;
        if ((sw2 < 1) || (sw3 < 0)) {
            s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
            return ERR_SCALARBADARG;
        }
        sw1 = (SWORD) s_lstrlen(lpstr1);
        if (sw1 < sw2) {
            s_lstrcpy(lpstmt->szError, lpScalarFunc->name);
            return ERR_SCALARBADARG;
        }
        if (sw3 > (sw1 - sw2 + 1))
            sw3 = sw1 - sw2 + 1;
        s_lstrcpy(lpSqlNode->value.String, lpstr1 + sw2 - 1);
        lpSqlNode->value.String[sw3] = '\0';
        break;
    case SCALAR_UCASE:
        s_lstrcpy(lpSqlNode->value.String, lpSqlNodeValue[0]->value.String);
        AnsiUpper((LPSTR) lpSqlNode->value.String);
        break;
    case SCALAR_ABS_DOUBLE:
        if (lpSqlNodeValue[0]->value.Double >= 0.0)
            lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double;
        else
            lpSqlNode->value.Double = -(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_ABS_NUMERIC:
        if (*(lpSqlNodeValue[0]->value.String) != '-')
            s_lstrcpy(lpSqlNode->value.String,lpSqlNodeValue[0]->value.String);
        else
            s_lstrcpy(lpSqlNode->value.String,lpSqlNodeValue[0]->value.String+1);
        break;
    case SCALAR_ABS_INTEGER:
        if (lpSqlNodeValue[0]->value.Double >= 0.0)
            lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double;
        else
            lpSqlNode->value.Double = -(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_ACOS:
        lpSqlNode->value.Double = acos(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_ASIN:
        lpSqlNode->value.Double = asin(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_ATAN:
        lpSqlNode->value.Double = atan(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_ATAN2:
        lpSqlNode->value.Double = atan2(lpSqlNodeValue[0]->value.Double,
                                        lpSqlNodeValue[1]->value.Double);
        break;
    case SCALAR_CEILING_DOUBLE:
        lpSqlNode->value.Double = ceil(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_CEILING_NUMERIC:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        sw1 = (SWORD) s_lstrlen(lpstr1);
        fFractionalPart = FALSE;
        for (location = 0; location < sw1; location++) {
            if (lpstr1[location] == '.') {
                location++;
                break;
            }
        }
        for (; location < sw1; location++) {
            if (lpstr1[location] != '0') {
                fFractionalPart = TRUE;
                break;
            }
        }
        if (fFractionalPart && (lpSqlNode->value.String[0] != '-')) {
            sqlNode = *lpSqlNode;
            sqlNode.sqlDataType = TYPE_NUMERIC;
            sqlNode.sqlSqlType = SQL_NUMERIC;
            sqlNode.sqlPrecision = 1;
            sqlNode.sqlScale = 0;
            sqlNode.sqlIsNull = FALSE;
            s_lstrcpy(szBuffer, "1");
            sqlNode.value.String = szBuffer;
            BCDAlgebra(lpSqlNode, lpSqlNodeValue[0], OP_PLUS, &sqlNode,
                           NULL, NULL, NULL);
        }
        else {
            s_lstrcpy(lpSqlNode->value.String, lpSqlNodeValue[0]->value.String);
        }
        if (fFractionalPart) {
            for (location = 0; location < s_lstrlen(lpSqlNode->value.String);
                                                              location++) {
                if (lpSqlNode->value.String[location] == '.') {
                    location++;
                    break;
                }
            }
            for (; location < s_lstrlen(lpSqlNode->value.String); location++)
                lpSqlNode->value.String[location] = '0';
        }
        break;
    case SCALAR_CEILING_INTEGER:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double;
        break;
    case SCALAR_COS:
        lpSqlNode->value.Double = cos(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_COT:
        lpSqlNode->value.Double = tan(lpSqlNodeValue[0]->value.Double);
        if (lpSqlNode->value.Double == 0.0)
            return ERR_ZERODIVIDE;
        lpSqlNode->value.Double = 1.0 / lpSqlNode->value.Double;
        break;
    case SCALAR_DEGREES_DOUBLE:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double *
                   (360.0 / (2.0 * PI));
        break;
    case SCALAR_DEGREES_NUMERIC:
        CharToDouble(lpSqlNodeValue[0]->value.String,
                        s_lstrlen(lpSqlNodeValue[0]->value.String), FALSE,
                        DOUBLE_LOW_D, DOUBLE_HIGH_D, &dbl);
        lpSqlNode->value.Double = dbl * (360.0 / (2.0 * PI));
        break;
    case SCALAR_DEGREES_INTEGER:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double *
                   (360.0 / (2.0 * PI));
        break;
    case SCALAR_EXP:
        lpSqlNode->value.Double = exp(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_FLOOR_DOUBLE:
        lpSqlNode->value.Double = floor(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_FLOOR_NUMERIC:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        sw1 = (SWORD) s_lstrlen(lpstr1);
        fFractionalPart = FALSE;
        for (location = 0; location < sw1; location++) {
            if (lpstr1[location] == '.') {
                location++;
                break;
            }
        }
        for (; location < sw1; location++) {
            if (lpstr1[location] != '0') {
                fFractionalPart = TRUE;
                break;
            }
        }
        if (fFractionalPart && (lpSqlNode->value.String[0] == '-')) {
            sqlNode = *lpSqlNode;
            sqlNode.sqlDataType = TYPE_NUMERIC;
            sqlNode.sqlSqlType = SQL_NUMERIC;
            sqlNode.sqlPrecision = 1;
            sqlNode.sqlScale = 0;
            sqlNode.sqlIsNull = FALSE;
            s_lstrcpy(szBuffer, "1");
            sqlNode.value.String = szBuffer;
            BCDAlgebra(lpSqlNode, lpSqlNodeValue[0], OP_MINUS, &sqlNode,
                           NULL, NULL, NULL);
        }
        else {
            s_lstrcpy(lpSqlNode->value.String, lpSqlNodeValue[0]->value.String);
        }
        if (fFractionalPart) {
            for (location = 0; location < s_lstrlen(lpSqlNode->value.String);
                                                              location++) {
                if (lpSqlNode->value.String[location] == '.') {
                    location++;
                    break;
                }
            }
            for (; location < s_lstrlen(lpSqlNode->value.String); location++)
                lpSqlNode->value.String[location] = '0';
        }
        break;
    case SCALAR_FLOOR_INTEGER:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double;
        break;
    case SCALAR_LOG:
        lpSqlNode->value.Double = log(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_LOG10:
        lpSqlNode->value.Double = log10(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_MOD:
        if (lpSqlNodeValue[1]->value.Double == 0.0)
            return ERR_ZERODIVIDE;
        lpSqlNode->value.Double = ((SDWORD) lpSqlNodeValue[0]->value.Double)
                                % ((SDWORD) lpSqlNodeValue[1]->value.Double);
        break;
    case SCALAR_PI:
        lpSqlNode->value.Double = PI;
        break;
    case SCALAR_POWER_DOUBLE:
        lpSqlNode->value.Double = pow(lpSqlNodeValue[0]->value.Double,
                                    (long) lpSqlNodeValue[1]->value.Double);
        break;
    case SCALAR_POWER_NUMERIC:
        CharToDouble(lpSqlNodeValue[0]->value.String,
                        s_lstrlen(lpSqlNodeValue[0]->value.String), FALSE,
                        DOUBLE_LOW_D, DOUBLE_HIGH_D, &dbl);
        lpSqlNode->value.Double = pow(dbl,
                                    (long) lpSqlNodeValue[1]->value.Double);
        break;
    case SCALAR_POWER_INTEGER:
        lpSqlNode->value.Double = pow(lpSqlNodeValue[0]->value.Double,
                                    (long) lpSqlNodeValue[1]->value.Double);
        break;
    case SCALAR_RADIANS_DOUBLE:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double *
                   ((2.0 * PI) / 360.0);
        break;
    case SCALAR_RADIANS_NUMERIC:
        CharToDouble(lpSqlNodeValue[0]->value.String,
                        s_lstrlen(lpSqlNodeValue[0]->value.String), FALSE,
                        DOUBLE_LOW_D, DOUBLE_HIGH_D, &dbl);
        lpSqlNode->value.Double = dbl * ((2.0 * PI) / 360.0);
        break;
    case SCALAR_RADIANS_INTEGER:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double *
                   ((2.0 * PI) / 360.0);
        break;

    case SCALAR_RAND:
    case SCALAR_RAND_SEED_DOUBLE:
    case SCALAR_RAND_SEED_NUMERIC:
    case SCALAR_RAND_SEED_INTEGER:

        /* Get seed */
        switch (lpSqlNode->node.scalar.Id) {
        case SCALAR_RAND:
            break;
        case SCALAR_RAND_SEED_DOUBLE:
            if ((long) lpSqlNodeValue[0]->value.Double != 0)
                new_seed = (long) lpSqlNodeValue[0]->value.Double;
            break;
        case SCALAR_RAND_SEED_NUMERIC:
            CharToDouble(lpSqlNodeValue[0]->value.String,
                        s_lstrlen(lpSqlNodeValue[0]->value.String), FALSE,
                        DOUBLE_LOW_D, DOUBLE_HIGH_D, &dbl);
            if ((long) dbl != 0)
                new_seed = (long) dbl;
            break;
        case SCALAR_RAND_SEED_INTEGER:
            if ((long) lpSqlNodeValue[0]->value.Double != 0)
                new_seed = (long) lpSqlNodeValue[0]->value.Double;
            break;
        }

        /* Make a seed if need be */
        if (new_seed == 0)
            new_seed = time(NULL);

        /* First generator */
        seed1 = new_seed + 4;
        if (seed1 < 0)
            seed1 = -seed1;
        seed1 = (seed1 % 30000) + 1;
        seed1 = (171 * (seed1 % 177)) - (2 * (seed1 / 177));
        if (seed1 < 0)
            seed1 += (30269);

        /* Second generator */
        seed2 = new_seed + 10014;
        if (seed2 < 0)
            seed2 = -seed2;
        seed2 = (seed2 % 30000) + 1;
        seed2 = (172 * (seed2 % 176))- (2 * (seed2 / 176));
        if (seed2 < 0)
            seed2 += (30307);

        /* Third generator */
        seed3 = new_seed + 3017;
        if (seed3 < 0)
            seed3 = -seed3;
        seed3 = (seed3 % 30000) + 1;
        seed3 = (170 * (seed3 % 178)) - (2 * (seed3 / 178));
        if (seed3 < 0)
            seed3 += (30323);

        /* Compute value */
        dbl = (seed1 / 30269.0) + (seed2 / 30307.0) + (seed3 / 30323.0);
        dbl -= ((double) floor(dbl));
        new_seed = (long) (floor(dbl * ULONG_HIGH_D));
        if (new_seed == 0)
            new_seed = seed1 + seed2 + seed3;
        lpSqlNode->value.Double =  dbl;
        break;
    case SCALAR_ROUND_DOUBLE:
        power = pow(10, lpSqlNodeValue[1]->value.Double);
        lpSqlNode->value.Double =
              floor((lpSqlNodeValue[0]->value.Double * power) + 0.5) / power;
        break;
    case SCALAR_ROUND_NUMERIC:
        power = pow(10, lpSqlNodeValue[1]->value.Double);
        CharToDouble(lpSqlNodeValue[0]->value.String,
                        s_lstrlen(lpSqlNodeValue[0]->value.String), FALSE,
                        DOUBLE_LOW_D, DOUBLE_HIGH_D, &dbl);
        dbl = floor((dbl * power) + 0.5) / power;
        if (DoubleToChar(dbl, FALSE, lpSqlNode->value.String,
                                      1 + 2 + lpSqlNode->sqlPrecision))
            lpSqlNode->value.String[2 + lpSqlNode->sqlPrecision] = '\0';
        BCDNormalize(lpSqlNode->value.String,
                     s_lstrlen(lpSqlNode->value.String),
                     lpSqlNode->value.String,
                     1 + 2 + lpSqlNode->sqlPrecision,
                     lpSqlNode->sqlPrecision,
                     lpSqlNode->sqlScale);
        break;
    case SCALAR_ROUND_INTEGER:
        power = pow(10, lpSqlNodeValue[1]->value.Double);
        lpSqlNode->value.Double =
              floor((lpSqlNodeValue[0]->value.Double * power) + 0.5) / power;
        break;
    case SCALAR_SIGN_DOUBLE:
        if (lpSqlNodeValue[0]->value.Double > 0)
            lpSqlNode->value.Double = 1;
        else if (lpSqlNodeValue[0]->value.Double == 0)
            lpSqlNode->value.Double = 0;
        else
            lpSqlNode->value.Double = -1;
        break;
    case SCALAR_SIGN_NUMERIC:
        switch (lpSqlNodeValue[0]->value.String[0]) {
        case '\0':
            lpSqlNode->value.Double = 0;
            break;
        case '-':
            lpSqlNode->value.Double = -1;
            break;
        default:
            lpSqlNode->value.Double = 1;
            break;
        }
        break;
    case SCALAR_SIGN_INTEGER:
        if (lpSqlNodeValue[0]->value.Double > 0)
            lpSqlNode->value.Double = 1;
        else if (lpSqlNodeValue[0]->value.Double == 0)
            lpSqlNode->value.Double = 0;
        else
            lpSqlNode->value.Double = -1;
        break;        
    case SCALAR_SIN:
        lpSqlNode->value.Double = sin(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_SQRT:
        lpSqlNode->value.Double = sqrt(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_TAN:
        lpSqlNode->value.Double = tan(lpSqlNodeValue[0]->value.Double);
        break;
    case SCALAR_TRUNCATE_DOUBLE:
        power = pow(10, lpSqlNodeValue[1]->value.Double);
        lpSqlNode->value.Double =
                floor(lpSqlNodeValue[0]->value.Double * power) / power;
        break;
    case SCALAR_TRUNCATE_NUMERIC:
        power = pow(10, lpSqlNodeValue[1]->value.Double);
        CharToDouble(lpSqlNodeValue[0]->value.String,
                        s_lstrlen(lpSqlNodeValue[0]->value.String), FALSE,
                        DOUBLE_LOW_D, DOUBLE_HIGH_D, &dbl);
        dbl = floor(dbl * power) / power;
        if (DoubleToChar(dbl, FALSE, lpSqlNode->value.String,
                                      1 + 2 + lpSqlNode->sqlPrecision))
            lpSqlNode->value.String[2 + lpSqlNode->sqlPrecision] = '\0';
        BCDNormalize(lpSqlNode->value.String,
                     s_lstrlen(lpSqlNode->value.String),
                     lpSqlNode->value.String,
                     1 + 2 + lpSqlNode->sqlPrecision,
                     lpSqlNode->sqlPrecision,
                     lpSqlNode->sqlScale);
        break;
    case SCALAR_TRUNCATE_INTEGER:
        power = pow(10, lpSqlNodeValue[1]->value.Double);
        lpSqlNode->value.Double =
                floor(lpSqlNodeValue[0]->value.Double * power) / power;
        break;
    case SCALAR_CURDATE:
        time(&t);
        lpTs = localtime(&t);
        lpSqlNode->value.Date.month = lpTs->tm_mon + 1;
        lpSqlNode->value.Date.day = (UWORD) lpTs->tm_mday;
        lpSqlNode->value.Date.year = lpTs->tm_year + 1900;
        break;
    case SCALAR_CURTIME:
        time(&t);
        lpTs = localtime(&t);
        lpSqlNode->value.Time.hour = (UWORD) lpTs->tm_hour;
        lpSqlNode->value.Time.minute = (UWORD) lpTs->tm_min;
        lpSqlNode->value.Time.second = (UWORD) lpTs->tm_sec;
        break;
    case SCALAR_DAYNAME:
        err = MakeDate(lpSqlNodeValue[0], &ts);
        if (err != ERR_SUCCESS)
            return err;
        switch (ts.tm_wday) {
        case 0:
            LoadString(s_hModule, STR_SUNDAY, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 1:
            LoadString(s_hModule, STR_MONDAY, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 2:
            LoadString(s_hModule, STR_TUESDAY, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 3:
            LoadString(s_hModule, STR_WEDNESDAY, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 4:
            LoadString(s_hModule, STR_THURSDAY, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 5:
            LoadString(s_hModule, STR_FRIDAY, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 6:
            LoadString(s_hModule, STR_SATURDAY, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        }
        break;
    case SCALAR_DAYOFMONTH_CHAR:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        err = CharToDate(lpstr1, s_lstrlen(lpstr1), &sDate);
        if (err != ERR_SUCCESS)
            return err;
        lpSqlNode->value.Double = sDate.day;
        break;
    case SCALAR_DAYOFMONTH_DATE:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Date.day;
        break;
    case SCALAR_DAYOFMONTH_TIMESTAMP:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Timestamp.day;
        break;
    case SCALAR_DAYOFWEEK:
        err = MakeDate(lpSqlNodeValue[0], &ts);
        if (err != ERR_SUCCESS)
            return err;
        lpSqlNode->value.Double = ts.tm_wday + 1;
        break;
    case SCALAR_DAYOFYEAR:
        err = MakeDate(lpSqlNodeValue[0], &ts);
        if (err != ERR_SUCCESS)
            return err;
        lpSqlNode->value.Double = ts.tm_yday + 1;
        break;
    case SCALAR_HOUR_CHAR:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        err = CharToTime(lpstr1, s_lstrlen(lpstr1), &sTime);
        if (err != ERR_SUCCESS)
            return err;
        lpSqlNode->value.Double = sTime.hour;
        break;
    case SCALAR_HOUR_TIME:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Time.hour;
        break;
    case SCALAR_HOUR_TIMESTAMP:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Timestamp.hour;
        break;
    case SCALAR_MINUTE_CHAR:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        err = CharToTime(lpstr1, s_lstrlen(lpstr1), &sTime);
        if (err != ERR_SUCCESS)
            return err;
        lpSqlNode->value.Double = sTime.minute;
        break;
    case SCALAR_MINUTE_TIME:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Time.minute;
        break;
    case SCALAR_MINUTE_TIMESTAMP:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Timestamp.minute;
        break;
    case SCALAR_MONTH_CHAR:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        err = CharToDate(lpstr1, s_lstrlen(lpstr1), &sDate);
        if (err != ERR_SUCCESS)
            return err;
        lpSqlNode->value.Double = sDate.month;
        break;
    case SCALAR_MONTH_DATE:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Date.month;
        break;
    case SCALAR_MONTH_TIMESTAMP:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Timestamp.month;
        break;
    case SCALAR_MONTHNAME_CHAR:
    case SCALAR_MONTHNAME_DATE:
    case SCALAR_MONTHNAME_TIMESTAMP:
        switch (lpSqlNode->node.scalar.Id) {
        case SCALAR_MONTHNAME_CHAR:
            lpstr1 = lpSqlNodeValue[0]->value.String;
            err = CharToDate(lpstr1, s_lstrlen(lpstr1), &sDate);
            if (err != ERR_SUCCESS)
                return err;
            break;
        case SCALAR_MONTHNAME_DATE:
            sDate = lpSqlNodeValue[0]->value.Date;
            break;
        case SCALAR_MONTHNAME_TIMESTAMP:
            sDate.month = lpSqlNodeValue[0]->value.Timestamp.month;
            sDate.day = lpSqlNodeValue[0]->value.Timestamp.day;
            sDate.year = lpSqlNodeValue[0]->value.Timestamp.year;
            break;
        }
        switch (sDate.month) {
        case 1:
            LoadString(s_hModule, STR_JANUARY, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 2:
            LoadString(s_hModule, STR_FEBRUARY, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 3:
            LoadString(s_hModule, STR_MARCH, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 4:
            LoadString(s_hModule, STR_APRIL, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 5:
            LoadString(s_hModule, STR_MAY, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 6:
            LoadString(s_hModule, STR_JUNE, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 7:
            LoadString(s_hModule, STR_JULY, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 8:
            LoadString(s_hModule, STR_AUGUST, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 9:
            LoadString(s_hModule, STR_SEPTEMBER, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 10:
            LoadString(s_hModule, STR_OCTOBER, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 11:
            LoadString(s_hModule, STR_NOVEMBER, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        case 12:
            LoadString(s_hModule, STR_DECEMBER, (LPSTR) lpSqlNode->value.String,
                       MAX_CHAR_LITERAL_LENGTH+1);
            break;
        }
        break;
    case SCALAR_NOW:
        time(&t);
        lpTs = localtime(&t);
        lpSqlNode->value.Timestamp.month = lpTs->tm_mon + 1;
        lpSqlNode->value.Timestamp.day = (UWORD) lpTs->tm_mday;
        lpSqlNode->value.Timestamp.year = lpTs->tm_year + 1900;
        lpSqlNode->value.Timestamp.hour = (UWORD) lpTs->tm_hour;
        lpSqlNode->value.Timestamp.minute = (UWORD) lpTs->tm_min;
        lpSqlNode->value.Timestamp.second = (UWORD) lpTs->tm_sec;
        lpSqlNode->value.Timestamp.fraction = 0;
        break;
    case SCALAR_QUARTER_CHAR:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        err = CharToDate(lpstr1, s_lstrlen(lpstr1), &sDate);
        if (err != ERR_SUCCESS)
            return err;
        lpSqlNode->value.Double = ((sDate.month - 1) / 3) + 1;
        break;
    case SCALAR_QUARTER_DATE:
        lpSqlNode->value.Double =
                   ((lpSqlNodeValue[0]->value.Date.month - 1) / 3) + 1;
        break;
    case SCALAR_QUARTER_TIMESTAMP:
        lpSqlNode->value.Double =
                   ((lpSqlNodeValue[0]->value.Timestamp.month - 1) / 3) + 1;
        break;
    case SCALAR_SECOND_CHAR:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        err = CharToTime(lpstr1, s_lstrlen(lpstr1), &sTime);
        if (err != ERR_SUCCESS)
            return err;
        lpSqlNode->value.Double = sTime.second;
        break;
    case SCALAR_SECOND_TIME:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Time.second;
        break;
    case SCALAR_SECOND_TIMESTAMP:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Timestamp.second;
        break;
    case SCALAR_TIMESTAMPADD:
        sw1 = (SWORD) lpSqlNodeValue[0]->value.Double;
        err = MakeTimestamp(lpSqlNodeValue[1], &ts, &t);
        if (err != ERR_SUCCESS)
            return err;
        switch (lpSqlNode->node.scalar.Interval) {
        case SQL_TSI_SECOND:
            ts.tm_sec += (sw1);
            break;
        case SQL_TSI_MINUTE:
            ts.tm_min += (sw1);
            break;
        case SQL_TSI_HOUR:
            ts.tm_hour += (sw1);
            break;
        case SQL_TSI_DAY:
            ts.tm_mday += (sw1);
            break;
        case SQL_TSI_WEEK:
            ts.tm_mday += (sw1 * 7);
            break;
        case SQL_TSI_MONTH:
            ts.tm_mon += (sw1);
            break;
        case SQL_TSI_QUARTER:
            ts.tm_mon += (sw1 * 3);
            break;
        case SQL_TSI_YEAR:
            ts.tm_year += (sw1);
            break;
        default:
            return ERR_INTERNAL;
        }
        if (mktime(&ts) == -1)
            return ERR_NOTCONVERTABLE;
        lpSqlNode->value.Timestamp.month = ts.tm_mon + 1;
        lpSqlNode->value.Timestamp.day = (UWORD) ts.tm_mday;
        lpSqlNode->value.Timestamp.year = ts.tm_year + 1900;
        lpSqlNode->value.Timestamp.hour = (UWORD) ts.tm_hour;
        lpSqlNode->value.Timestamp.minute = (UWORD) ts.tm_min;
        lpSqlNode->value.Timestamp.second = (UWORD) ts.tm_sec;
        lpSqlNode->value.Timestamp.fraction = 0;
        break;
    case SCALAR_TIMESTAMPDIFF:
        err = MakeTimestamp(lpSqlNodeValue[0], &ts, &t);
        if (err != ERR_SUCCESS)
            return err;
        err = MakeTimestamp(lpSqlNodeValue[1], &ts2, &t2);
        if (err != ERR_SUCCESS)
            return err;
        switch (lpSqlNode->node.scalar.Interval) {
        case SQL_TSI_SECOND:
            lpSqlNode->value.Double = t2 - t;
            break;
        case SQL_TSI_MINUTE:
            lpSqlNode->value.Double = (t2 - t)/SECONDS_PER_MINUTE;
            break;
        case SQL_TSI_HOUR:
            lpSqlNode->value.Double = (t2 - t)/SECONDS_PER_HOUR;
            break;
        case SQL_TSI_DAY:
            lpSqlNode->value.Double = (t2 - t)/SECONDS_PER_DAY;
            break;
        case SQL_TSI_WEEK:
            lpSqlNode->value.Double = (t2 - t)/SECONDS_PER_WEEK;
            break;
        case SQL_TSI_MONTH:
            lpSqlNode->value.Double = (ts2.tm_mon - ts.tm_mon) +
                            (MONTHS_PER_YEAR * (ts2.tm_year - ts.tm_year));
            break;
        case SQL_TSI_QUARTER:
            lpSqlNode->value.Double = ((ts2.tm_mon - ts.tm_mon) +
                         (MONTHS_PER_YEAR * (ts2.tm_year - ts.tm_year))) / 3;
        case SQL_TSI_YEAR:
            lpSqlNode->value.Double = ts2.tm_year - ts.tm_year;
            break;
        default:
            return ERR_INTERNAL;
        }
        break;
    case SCALAR_WEEK:
        err = MakeDate(lpSqlNodeValue[0], &ts);
        if (err != ERR_SUCCESS)
            return err;
        while ((ts.tm_yday > 0) && (ts.tm_wday > 0)) {
            ts.tm_yday--;
            ts.tm_wday--;
        }
        lpSqlNode->value.Double = 1.0;
        while (ts.tm_yday > 6) {
            ts.tm_yday -= (7);
            lpSqlNode->value.Double += (1.0);
        }
        if (ts.tm_yday != 0)
            lpSqlNode->value.Double += (1.0);
        break;
    case SCALAR_YEAR_CHAR:
        lpstr1 = lpSqlNodeValue[0]->value.String;
        err = CharToDate(lpstr1, s_lstrlen(lpstr1), &sDate);
        if (err != ERR_SUCCESS)
            return err;
        lpSqlNode->value.Double = sDate.year;
        break;
    case SCALAR_YEAR_DATE:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Date.year;
        break;
    case SCALAR_YEAR_TIMESTAMP:
        lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Timestamp.year;
        break;
    case SCALAR_DATABASE:
        s_lstrcpy(lpSqlNode->value.String, ISAMDatabase(lpstmt->lpdbc->lpISAM));
        break;
    case SCALAR_IFNULL:
        if (lpSqlNodeValue[0]->sqlIsNull)
            lpSqlNodeReturnValue = lpSqlNodeValue[1];
        else
            lpSqlNodeReturnValue = lpSqlNodeValue[0];
        switch (lpSqlNode->sqlDataType) {
        case TYPE_DOUBLE:
            if (lpSqlNodeReturnValue->sqlIsNull) {
                lpSqlNode->sqlIsNull = TRUE;
                lpSqlNode->value.Double = 0.0;
            }
            else if (lpSqlNodeReturnValue->sqlDataType != TYPE_NUMERIC)
                lpSqlNode->value.Double = lpSqlNodeReturnValue->value.Double;
            else
                CharToDouble(lpSqlNodeReturnValue->value.String,
                     s_lstrlen(lpSqlNodeReturnValue->value.String), FALSE,
                     DOUBLE_LOW_D, DOUBLE_HIGH_D, &(lpSqlNode->value.Double));
            break;
        case TYPE_NUMERIC:
            if (lpSqlNodeReturnValue->sqlIsNull) {
                lpSqlNode->sqlIsNull = TRUE;
                s_lstrcpy(lpSqlNode->value.String, "");
            }
            else if (lpSqlNodeReturnValue->sqlDataType == TYPE_NUMERIC)
                s_lstrcpy(lpSqlNode->value.String,
                                        lpSqlNodeReturnValue->value.String);
            else {
                if (DoubleToChar(lpSqlNodeReturnValue->value.Double, FALSE,
                             lpSqlNode->value.String,
                             1 + 2 + lpSqlNode->sqlPrecision))
                    lpSqlNode->value.String[2 + lpSqlNode->sqlPrecision]='\0';
            }
            BCDNormalize(lpSqlNode->value.String,
                         s_lstrlen(lpSqlNode->value.String),
                         lpSqlNode->value.String,
                         1 + 2 + lpSqlNode->sqlPrecision,
                         lpSqlNode->sqlPrecision,
                         lpSqlNode->sqlScale);
            break;
        case TYPE_INTEGER:
            if (lpSqlNodeReturnValue->sqlIsNull) {
                lpSqlNode->sqlIsNull = TRUE;
                lpSqlNode->value.Double = 0.0;
            }
            else
                lpSqlNode->value.Double = lpSqlNodeReturnValue->value.Double;
            break;
        case TYPE_CHAR:
            if (lpSqlNodeReturnValue->sqlIsNull) {
                lpSqlNode->sqlIsNull = TRUE;
                s_lstrcpy(lpSqlNode->value.String, "");
            }
            else {
                s_lstrcpy(lpSqlNode->value.String,
                                       lpSqlNodeReturnValue->value.String);
                while ((lpSqlNode->sqlSqlType == SQL_CHAR) &&
                       (s_lstrlen(lpSqlNode->value.String) <
                                                 lpSqlNode->sqlPrecision))
                    s_lstrcat(lpSqlNode->value.String, " ");
            }
            break;
        case TYPE_BINARY:
            if (lpSqlNodeReturnValue->sqlIsNull) {
                lpSqlNode->sqlIsNull = TRUE;
                length = 0;
            }
            else {
                length = (SWORD)
                            BINARY_LENGTH(lpSqlNodeReturnValue->value.Binary);
            }
            _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                     BINARY_DATA(lpSqlNodeReturnValue->value.Binary),
                     length);
            while (!(lpSqlNodeReturnValue->sqlIsNull) &&
                   (lpSqlNode->sqlSqlType == SQL_BINARY) &&
                   (length < lpSqlNode->sqlPrecision)) {
                lpSqlNode->value.Binary[length] = 0;
                length++;
            }
            BINARY_LENGTH(lpSqlNode->value.Binary) = length;
            break;
        case TYPE_DATE:
            if (lpSqlNodeReturnValue->sqlIsNull) {
                lpSqlNode->sqlIsNull = TRUE;
                lpSqlNode->value.Date.year = 0;
                lpSqlNode->value.Date.month = 0;
                lpSqlNode->value.Date.day = 0;
            }
            else
                lpSqlNode->value.Date = lpSqlNodeReturnValue->value.Date;
            break;
        case TYPE_TIME:
            if (lpSqlNodeReturnValue->sqlIsNull) {
                lpSqlNode->sqlIsNull = TRUE;
                lpSqlNode->value.Time.hour = 0;
                lpSqlNode->value.Time.minute = 0;
                lpSqlNode->value.Time.second = 0;
            }
            else
                lpSqlNode->value.Time = lpSqlNodeReturnValue->value.Time;
            break;
        case TYPE_TIMESTAMP:
            if (lpSqlNodeReturnValue->sqlIsNull) {
                lpSqlNode->sqlIsNull = TRUE;
                lpSqlNode->value.Timestamp.year = 0;
                lpSqlNode->value.Timestamp.month = 0;
                lpSqlNode->value.Timestamp.day = 0;
                lpSqlNode->value.Timestamp.hour = 0;
                lpSqlNode->value.Timestamp.minute = 0;
                lpSqlNode->value.Timestamp.second = 0;
                lpSqlNode->value.Timestamp.fraction = 0;
            }
            else
                lpSqlNode->value.Timestamp = lpSqlNodeReturnValue->value.Timestamp;
            break;
        default:
            return ERR_INTERNAL;
        }
        break;
    case SCALAR_USER:
        s_lstrcpy(lpSqlNode->value.String, ISAMUser(lpstmt->lpdbc->lpISAM));
        break;
    case SCALAR_CONVERT:
        switch (lpSqlNode->sqlSqlType) {
        case SQL_CHAR:
        case SQL_VARCHAR:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
                s_lstrcpy(lpSqlNode->value.String,
                                  lpSqlNodeValue[0]->value.String);
                if ((lpSqlNode->sqlSqlType == SQL_VARCHAR) &&
                              (lpSqlNodeValue[0]->sqlSqlType == SQL_CHAR)) {
                    length = (SWORD) s_lstrlen(lpSqlNode->value.String);
                    while ((length > 0) &&
                           (lpSqlNode->value.String[length-1] == ' ')) {
                        lpSqlNode->value.String[length-1] = '\0';
                        length--;
                    }
                }
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_REAL:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                if (DoubleToChar(lpSqlNodeValue[0]->value.Double, TRUE,
                          lpSqlNode->value.String, lpSqlNode->sqlPrecision))
                    lpSqlNode->value.String[lpSqlNode->sqlPrecision-1] = '\0';
                break;
            case SQL_BINARY:
            case SQL_VARBINARY:

                /* Figure out how many nibbles (not bytes) to copy */
                length = (SWORD) (2 *
                       BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary));
                if (length > lpSqlNode->sqlPrecision)
                    return ERR_NOTCONVERTABLE;

                /* Copy the value */
                lpFrom = BINARY_DATA(lpSqlNodeValue[0]->value.Binary);
                lpTo = BINARY_DATA(lpSqlNode->value.Binary);
                for (idx = 0; idx < (UWORD) length; idx++) {

                    /* Get the next nibble */
                    nibble = *lpFrom;
                    if (((idx/2) * 2) == idx)
                        nibble = nibble >> 4;
                    else
                        lpFrom++;
                    nibble = nibble & 0x0F;

                    /* Convert it to a character */
                    if (nibble <= 9)
                        *lpTo = nibble + '0';
                    else
                        *lpTo = (nibble-10) + 'A';
                    lpTo++;
                }
                *lpTo = '\0';
                break;

            case SQL_DATE:
                DateToChar(&(lpSqlNodeValue[0]->value.Date),
                           lpSqlNode->value.String);
                break;
            case SQL_TIME:
                TimeToChar(&(lpSqlNodeValue[0]->value.Time),
                          lpSqlNode->value.String);
                break;
            case SQL_TIMESTAMP:
                TimestampToChar(&(lpSqlNodeValue[0]->value.Timestamp),
                          lpSqlNode->value.String);
                break;
            default:
                return ERR_NOTSUPPORTED;
            }

            if (lpSqlNode->sqlSqlType == SQL_CHAR)  {
                while (s_lstrlen(lpSqlNode->value.String) <
                                                     lpSqlNode->sqlPrecision)
                    s_lstrcat(lpSqlNode->value.String, " ");
            }
            break;
        case SQL_LONGVARCHAR:
        case SQL_LONGVARBINARY:
            return ERR_NOTSUPPORTED;
        case SQL_BIT:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
                err = CharToDouble(lpSqlNodeValue[0]->value.String,
                                   s_lstrlen(lpSqlNodeValue[0]->value.String),
                                   TRUE, BIT_LOW_D, BIT_HIGH_D,
                                   &(lpSqlNode->value.Double));
                if (err != ERR_SUCCESS) {
                    if (err == ERR_OUTOFRANGE)
                        return ERR_OUTOFRANGE;
                    else
                        return ERR_NOTCONVERTABLE;
                }
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_REAL:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double;
                if ((lpSqlNode->value.Double < BIT_LOW_D) ||
                    (lpSqlNode->value.Double > BIT_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_BINARY:
            case SQL_VARBINARY:
                if (BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary) !=
                                                       sizeof(unsigned char))
                        return ERR_NOTCONVERTABLE;
                lpSqlNode->value.Double = *((unsigned char far *)
                              BINARY_DATA(lpSqlNodeValue[0]->value.Binary));
                if ((lpSqlNode->value.Double < BIT_LOW_D) ||
                    (lpSqlNode->value.Double > BIT_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_NOTCONVERTABLE;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_TINYINT:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
                err = CharToDouble(lpSqlNodeValue[0]->value.String,
                                   s_lstrlen(lpSqlNodeValue[0]->value.String),
                                   TRUE, STINY_LOW_D, STINY_LOW_D,
                                   &(lpSqlNode->value.Double));
                if (err != ERR_SUCCESS) {
                    if (err == ERR_OUTOFRANGE)
                        return ERR_OUTOFRANGE;
                    else
                        return ERR_NOTCONVERTABLE;
                }
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_REAL:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double;
                if ((lpSqlNode->value.Double < STINY_LOW_D) ||
                    (lpSqlNode->value.Double > STINY_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_BINARY:
            case SQL_VARBINARY:
                if (BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary) !=
                                                               sizeof(char))
                        return ERR_NOTCONVERTABLE;
                lpSqlNode->value.Double = *((char far *)
                              BINARY_DATA(lpSqlNodeValue[0]->value.Binary));
                if ((lpSqlNode->value.Double < BIT_LOW_D) ||
                    (lpSqlNode->value.Double > BIT_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_NOTCONVERTABLE;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_SMALLINT:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
                err = CharToDouble(lpSqlNodeValue[0]->value.String,
                                   s_lstrlen(lpSqlNodeValue[0]->value.String),
                                   TRUE, SSHORT_LOW_D, SSHORT_HIGH_D,
                                   &(lpSqlNode->value.Double));
                if (err != ERR_SUCCESS) {
                    if (err == ERR_OUTOFRANGE)
                        return ERR_OUTOFRANGE;
                    else
                        return ERR_NOTCONVERTABLE;
                }
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_REAL:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double;
                if ((lpSqlNode->value.Double < SSHORT_LOW_D) ||
                    (lpSqlNode->value.Double > SSHORT_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_BINARY:
            case SQL_VARBINARY:
                if (BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary) !=
                                                               sizeof(short))
                        return ERR_NOTCONVERTABLE;
                lpSqlNode->value.Double = *((short far *)
                              BINARY_DATA(lpSqlNodeValue[0]->value.Binary));
                if ((lpSqlNode->value.Double < BIT_LOW_D) ||
                    (lpSqlNode->value.Double > BIT_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_NOTCONVERTABLE;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_INTEGER:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
                err = CharToDouble(lpSqlNodeValue[0]->value.String,
                                   s_lstrlen(lpSqlNodeValue[0]->value.String),
                                   TRUE, SLONG_LOW_D, SLONG_HIGH_D,
                                   &(lpSqlNode->value.Double));
                if (err != ERR_SUCCESS) {
                    if (err == ERR_OUTOFRANGE)
                        return ERR_OUTOFRANGE;
                    else
                        return ERR_NOTCONVERTABLE;
                }
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_REAL:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double;
                if ((lpSqlNode->value.Double < SLONG_LOW_D) ||
                    (lpSqlNode->value.Double > SLONG_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_BINARY:
            case SQL_VARBINARY:
                if (BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary) !=
                                                               sizeof(long))
                        return ERR_NOTCONVERTABLE;
                lpSqlNode->value.Double = *((long far *)
                              BINARY_DATA(lpSqlNodeValue[0]->value.Binary));
                if ((lpSqlNode->value.Double < BIT_LOW_D) ||
                    (lpSqlNode->value.Double > BIT_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_NOTCONVERTABLE;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_REAL:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
                err = CharToDouble(lpSqlNodeValue[0]->value.String,
                                   s_lstrlen(lpSqlNodeValue[0]->value.String),
                                   FALSE, FLOAT_LOW_D, FLOAT_HIGH_D,
                                   &(lpSqlNode->value.Double));
                if (err != ERR_SUCCESS) {
                    if (err == ERR_OUTOFRANGE)
                        return ERR_OUTOFRANGE;
                    else
                        return ERR_NOTCONVERTABLE;
                }
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_REAL:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double;
                if ((lpSqlNode->value.Double < FLOAT_LOW_D) ||
                    (lpSqlNode->value.Double > FLOAT_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_BINARY:
            case SQL_VARBINARY:
                if (BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary) !=
                                                               sizeof(float))
                        return ERR_NOTCONVERTABLE;
                lpSqlNode->value.Double = *((float far *)
                              BINARY_DATA(lpSqlNodeValue[0]->value.Binary));
                if ((lpSqlNode->value.Double < BIT_LOW_D) ||
                    (lpSqlNode->value.Double > BIT_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_NOTCONVERTABLE;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_FLOAT:
        case SQL_DOUBLE:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
                err = CharToDouble(lpSqlNodeValue[0]->value.String,
                                   s_lstrlen(lpSqlNodeValue[0]->value.String),
                                   FALSE, DOUBLE_LOW_D, DOUBLE_HIGH_D,
                                   &(lpSqlNode->value.Double));
                if (err != ERR_SUCCESS) {
                    if (err == ERR_OUTOFRANGE)
                        return ERR_OUTOFRANGE;
                    else
                        return ERR_NOTCONVERTABLE;
                }
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_REAL:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                lpSqlNode->value.Double = lpSqlNodeValue[0]->value.Double;
                if ((lpSqlNode->value.Double < DOUBLE_LOW_D) ||
                    (lpSqlNode->value.Double > DOUBLE_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_BINARY:
            case SQL_VARBINARY:
                if (BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary) !=
                                                              sizeof(double))
                        return ERR_NOTCONVERTABLE;
                lpSqlNode->value.Double = *((double far *)
                              BINARY_DATA(lpSqlNodeValue[0]->value.Binary));
                if ((lpSqlNode->value.Double < BIT_LOW_D) ||
                    (lpSqlNode->value.Double > BIT_HIGH_D))
                    return ERR_OUTOFRANGE;
                break;
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_NOTCONVERTABLE;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_DECIMAL:
        case SQL_NUMERIC:
        case SQL_BIGINT:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
                err = CharToDouble(lpSqlNodeValue[0]->value.String,
                                   s_lstrlen(lpSqlNodeValue[0]->value.String),
                                   FALSE, DOUBLE_LOW_D, DOUBLE_HIGH_D, &dbl);
                if (err != ERR_SUCCESS) {
                    if (err == ERR_OUTOFRANGE)
                        return ERR_OUTOFRANGE;
                    else
                        return ERR_NOTCONVERTABLE;
                }
                s_lstrcpy(lpSqlNode->value.String,
                                  lpSqlNodeValue[0]->value.String);
                break;
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
                s_lstrcpy(lpSqlNode->value.String,
                                  lpSqlNodeValue[0]->value.String);
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_REAL:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                if (DoubleToChar(lpSqlNodeValue[0]->value.Double, FALSE,
                             lpSqlNode->value.String,
                             lpSqlNode->sqlPrecision + 2 + 1))
                    lpSqlNode->value.String[2 + lpSqlNode->sqlPrecision]='\0';
                break;
            case SQL_BINARY:
            case SQL_VARBINARY:
                err = CharToDouble(
                              BINARY_DATA(lpSqlNodeValue[0]->value.Binary),
                              BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary),
                                   FALSE, DOUBLE_LOW_D, DOUBLE_HIGH_D, &dbl);
                if (err != ERR_SUCCESS) {
                    if (err == ERR_OUTOFRANGE)
                        return ERR_OUTOFRANGE;
                    else
                        return ERR_NOTCONVERTABLE;
                }
                _fmemcpy(lpSqlNode->value.String,
                         BINARY_DATA(lpSqlNodeValue[0]->value.Binary),
                     (SWORD) BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary));
                lpSqlNode->value.String[
                     BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary)] = '\0';
                break;
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_NOTCONVERTABLE;
            default:
                return ERR_NOTSUPPORTED;
            }
            err = BCDNormalize(lpSqlNode->value.String,
                         s_lstrlen(lpSqlNode->value.String),
                         lpSqlNode->value.String,
                         1 + 2 + lpSqlNode->sqlPrecision,
                         lpSqlNode->sqlPrecision,
                         lpSqlNode->sqlScale);
            if ((err != ERR_SUCCESS) && (err != ERR_DATATRUNCATED))
                return err;
            break;
        case SQL_BINARY:
        case SQL_VARBINARY:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
                _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                         lpSqlNodeValue[0]->value.String,
                         s_lstrlen(lpSqlNodeValue[0]->value.String));
                BINARY_LENGTH(lpSqlNode->value.Binary) =
                         s_lstrlen(lpSqlNodeValue[0]->value.String);
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
                uchr = (unsigned char) lpSqlNodeValue[0]->value.Double;
                _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                         &uchr, sizeof(unsigned char));
                BINARY_LENGTH(lpSqlNode->value.Binary) =
                         sizeof(unsigned char);
                break;
            case SQL_TINYINT:
                chr = (char) lpSqlNodeValue[0]->value.Double;
                _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                         &chr, sizeof(char));
                BINARY_LENGTH(lpSqlNode->value.Binary) = sizeof(char);
                break;
            case SQL_SMALLINT:
                shrt = (short) lpSqlNodeValue[0]->value.Double;
                _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                         &shrt, sizeof(short));
                BINARY_LENGTH(lpSqlNode->value.Binary) = sizeof(short);
                break;
            case SQL_INTEGER:
                lng = (long) lpSqlNodeValue[0]->value.Double;
                _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                         &lng, sizeof(long));
                BINARY_LENGTH(lpSqlNode->value.Binary) = sizeof(long);
                break;
            case SQL_REAL:
                flt = (float) lpSqlNodeValue[0]->value.Double;
                _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                         &flt, sizeof(float));
                BINARY_LENGTH(lpSqlNode->value.Binary) = sizeof(float);
                break;
            case SQL_FLOAT:
            case SQL_DOUBLE:
                _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                         &(lpSqlNodeValue[0]->value.Double), sizeof(double));
                BINARY_LENGTH(lpSqlNode->value.Binary) = sizeof(double);
                break;
            case SQL_BINARY:
            case SQL_VARBINARY:
                _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                         BINARY_DATA(lpSqlNodeValue[0]->value.Binary),
                     (SWORD) BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary));
                BINARY_LENGTH(lpSqlNode->value.Binary) =
                         BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary);
                break;
            case SQL_DATE:
                _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                      &(lpSqlNodeValue[0]->value.Date), sizeof(DATE_STRUCT));
                BINARY_LENGTH(lpSqlNode->value.Binary) = sizeof(DATE_STRUCT);
                break;
            case SQL_TIME:
                _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                      &(lpSqlNodeValue[0]->value.Time), sizeof(TIME_STRUCT));
                BINARY_LENGTH(lpSqlNode->value.Binary) = sizeof(TIME_STRUCT);
                break;
            case SQL_TIMESTAMP:
                _fmemcpy(BINARY_DATA(lpSqlNode->value.Binary),
                         &(lpSqlNodeValue[0]->value.Timestamp),
                         sizeof(TIMESTAMP_STRUCT));
                BINARY_LENGTH(lpSqlNode->value.Binary) =
                                         sizeof(TIMESTAMP_STRUCT);
                break;
            default:
                return ERR_NOTSUPPORTED;
            }
            if (lpSqlNode->sqlSqlType == SQL_BINARY) {
                while (BINARY_LENGTH(lpSqlNode->value.Binary) <
                                                  lpSqlNode->sqlPrecision) {
                    BINARY_DATA(lpSqlNode->value.Binary)
                            [BINARY_LENGTH(lpSqlNode->value.Binary)] = '\0';
                    BINARY_LENGTH(lpSqlNode->value.Binary) += (1);
                }
            }
            break;
        case SQL_DATE:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
                err = CharToDate(lpSqlNodeValue[0]->value.String,
                                   s_lstrlen(lpSqlNodeValue[0]->value.String),
                                   &(lpSqlNode->value.Date));
                if (err != ERR_SUCCESS)
                    return err;
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                return ERR_NOTCONVERTABLE;
            case SQL_BINARY:
            case SQL_VARBINARY:
                if (BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary) !=
                                                         sizeof(DATE_STRUCT))
                        return ERR_NOTCONVERTABLE;
                lpSqlNode->value.Date = *((DATE_STRUCT far *)
                              BINARY_DATA(lpSqlNodeValue[0]->value.Binary));
                break;
            case SQL_DATE:
                lpSqlNode->value.Date = lpSqlNodeValue[0]->value.Date;
                break;
            case SQL_TIME:
                return ERR_NOTCONVERTABLE;
            case SQL_TIMESTAMP:
                lpSqlNode->value.Date.year =
                                   lpSqlNodeValue[0]->value.Timestamp.year;
                lpSqlNode->value.Date.month =
                                   lpSqlNodeValue[0]->value.Timestamp.month;
                lpSqlNode->value.Date.day =
                                   lpSqlNodeValue[0]->value.Timestamp.day;
                break;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_TIME:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
                err = CharToTime(lpSqlNodeValue[0]->value.String,
                                   s_lstrlen(lpSqlNodeValue[0]->value.String),
                                   &(lpSqlNode->value.Time));
                if (err != ERR_SUCCESS)
                    return err;
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                return ERR_NOTCONVERTABLE;
            case SQL_BINARY:
            case SQL_VARBINARY:
                if (BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary) !=
                                                         sizeof(TIME_STRUCT))
                        return ERR_NOTCONVERTABLE;
                lpSqlNode->value.Time = *((TIME_STRUCT far *)
                              BINARY_DATA(lpSqlNodeValue[0]->value.Binary));
                break;
            case SQL_DATE:
                return ERR_NOTCONVERTABLE;
            case SQL_TIME:
                lpSqlNode->value.Time = lpSqlNodeValue[0]->value.Time;
                break;
            case SQL_TIMESTAMP:
                lpSqlNode->value.Time.hour =
                                   lpSqlNodeValue[0]->value.Timestamp.hour;
                lpSqlNode->value.Time.minute =
                                   lpSqlNodeValue[0]->value.Timestamp.minute;
                lpSqlNode->value.Time.second =
                                   lpSqlNodeValue[0]->value.Timestamp.second;
                break;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_TIMESTAMP:
            switch (lpSqlNodeValue[0]->sqlSqlType) {
            case SQL_CHAR:
            case SQL_VARCHAR:
                err = CharToTimestamp(lpSqlNodeValue[0]->value.String,
                                   s_lstrlen(lpSqlNodeValue[0]->value.String),
                                   &(lpSqlNode->value.Timestamp));
                if (err != ERR_SUCCESS)
                    return err;
                break;
            case SQL_LONGVARCHAR:
            case SQL_LONGVARBINARY:
                return ERR_NOTSUPPORTED;
            case SQL_BIT:
            case SQL_TINYINT:
            case SQL_SMALLINT:
            case SQL_INTEGER:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_FLOAT:
            case SQL_DOUBLE:
                return ERR_NOTCONVERTABLE;
            case SQL_BINARY:
            case SQL_VARBINARY:
                if (BINARY_LENGTH(lpSqlNodeValue[0]->value.Binary) !=
                                                   sizeof(TIMESTAMP_STRUCT))
                        return ERR_NOTCONVERTABLE;
                lpSqlNode->value.Timestamp = *((TIMESTAMP_STRUCT far *)
                              BINARY_DATA(lpSqlNodeValue[0]->value.Binary));
                break;
            case SQL_DATE:
                lpSqlNode->value.Timestamp.year =
                                   lpSqlNodeValue[0]->value.Date.year;
                lpSqlNode->value.Timestamp.month =
                                   lpSqlNodeValue[0]->value.Date.month;
                lpSqlNode->value.Timestamp.day =
                                   lpSqlNodeValue[0]->value.Date.day;
                lpSqlNode->value.Timestamp.hour = 0;
                lpSqlNode->value.Timestamp.minute = 0;
                lpSqlNode->value.Timestamp.second = 0;
                lpSqlNode->value.Timestamp.fraction = 0;
                break;
            case SQL_TIME:
                time(&t);
                lpTs = localtime(&t);
                lpSqlNode->value.Timestamp.year = lpTs->tm_year + 1900;
                lpSqlNode->value.Timestamp.month = lpTs->tm_mon + 1;
                lpSqlNode->value.Timestamp.day = (UWORD) lpTs->tm_mday;
                lpSqlNode->value.Timestamp.hour =
                                   lpSqlNodeValue[0]->value.Time.hour;
                lpSqlNode->value.Timestamp.minute =
                                   lpSqlNodeValue[0]->value.Time.minute;
                lpSqlNode->value.Timestamp.second =
                                   lpSqlNodeValue[0]->value.Time.second;
                lpSqlNode->value.Timestamp.fraction = 0;
                break;
            case SQL_TIMESTAMP:
                lpSqlNode->value.Timestamp =
                                   lpSqlNodeValue[0]->value.Timestamp;
                break;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        default:
            return ERR_NOTSUPPORTED;
        }
        break;
    default:
        return ERR_INTERNAL;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/
#ifndef WIN32
void ScalarExceptionHandler(int sig)
{
    _fpreset();
    longjmp(scalarExceptionMark, -1);
}
#endif
/***************************************************************************/
RETCODE INTFUNC EvaluateScalar(LPSTMT lpstmt, LPSQLNODE lpSqlNode)
{
    RETCODE err;
#ifndef WIN32
    void (__cdecl *func)(int);
    int jmpret;
#endif

#ifdef WIN32
    __try {
#else
    func = signal(SIGFPE, ScalarExceptionHandler);
    if (func != SIG_ERR)
        jmpret = setjmp(scalarExceptionMark);
    if ((func != SIG_ERR) && (jmpret == 0)) {
#endif

        err = InternalEvaluateScalar(lpstmt, lpSqlNode);
    }
#ifdef WIN32
    __except(EXCEPTION_EXECUTE_HANDLER) {
#else
    else {
#endif
        s_lstrcpy(lpstmt->szError, scalarFuncs[lpSqlNode->node.scalar.Id].name);
        err = ERR_SCALARBADARG;
    }

#ifndef WIN32
    /* Turn off exception handler */
    if (func != SIG_ERR)
        signal(SIGFPE, func);
#endif
    return err;
}
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\semantic.h ===
/***************************************************************************/
/* SEMANTIC.H                                                              */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/

RETCODE INTFUNC SemanticCheck(LPSTMT, LPSQLTREE FAR *, SQLNODEIDX,
                             BOOL, BOOL, SQLNODEIDX, SQLNODEIDX);
void INTFUNC FreeTreeSemantic(LPSQLTREE, SQLNODEIDX);

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\semantic.cpp ===
/***************************************************************************/
/* SEMANTIC.C                                                              */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"
/***************************************************************************/

RETCODE INTFUNC FindColumn(LPSTMT lpstmt,
                           LPSQLTREE lpSql,
                           BOOL fCaseSensitive,
                           LPSQLNODE lpSqlNodeColumn,
                           SQLNODEIDX idxTable,
						   STRINGIDX	idxQualifier)

/* Sees if the table identified by idxTable contains the column identifeid */
/* lpSqNodeColumn.  If it does, the semantic information for the column    */
/* is filled in.  Otherwise an error is returned.                         */

{
    LPSQLNODE   lpSqlNodeTable;
    LPISAMTABLEDEF  lpISAMTableDef;
    LPSTR       lpName;
    UWORD	index;
    LPUSTR       lpTableAlias;
    LPUSTR       lpColumnAlias;
    LPUSTR	lpTableName;
    BOOL matchedAlias = FALSE;
	BOOL fIsPassthroughTable = FALSE;

    /* Table/Column name given? */
    lpName = (LPSTR) ToString(lpSql, lpSqlNodeColumn->node.column.Column);
    lpSqlNodeTable = ToNode(lpSql, idxTable);

    if (lpSqlNodeColumn->node.column.Tablealias != NO_STRING) {

		// this can be either a tablename or an tablename alias

        /* Yes.  Make sure it matches */
		int found = FALSE;
		if (lpSqlNodeTable->node.table.Alias != NO_STRING && 
			lpSqlNodeColumn->node.column.Qualifier == NO_STRING)
		{
			//
			//Comparing Aliases
			//
			lpTableAlias = ToString(lpSql, lpSqlNodeTable->node.table.Alias);
			lpColumnAlias = ToString(lpSql, lpSqlNodeColumn->node.column.Tablealias);
			if (fCaseSensitive) { 
				if (!s_lstrcmp(lpTableAlias, lpColumnAlias)) {
					 found = TRUE;
				}
			}
			else {
				if (!s_lstrcmpi(lpTableAlias, lpColumnAlias)) {
					found = TRUE;
				}	
			}


			if (!found)
				return ERR_COLUMNNOTFOUND;
		}

		//
		//Not comparing Aliases
		//
		if (!found)  // try matching the  column qualifier + alias to the table qualifier + table name
		{
			lpTableAlias = ToString(lpSql, lpSqlNodeTable->node.table.Qualifier);
			lpColumnAlias = ToString(lpSql, lpSqlNodeColumn->node.column.Tablealias);

			char *pszNewQualifier = NULL;
			if (lpSqlNodeColumn->node.column.Qualifier != NO_STRING)
			{
				LPSTR lpColumnQualifier = (LPSTR) ToString (lpSql, lpSqlNodeColumn->node.column.Qualifier);
				
				if ( (strlen(lpColumnQualifier) >= 4) &&
					(_strnicmp("root", lpColumnQualifier, 4) == 0))
				{
					// absolute qualifier (no need to change)
					pszNewQualifier = new char [s_lstrlen (lpColumnAlias)+
												s_lstrlen (lpColumnQualifier) + 3];
					s_lstrcpy (pszNewQualifier, lpColumnQualifier);
					s_lstrcat (pszNewQualifier, ".");
					s_lstrcat (pszNewQualifier, lpColumnAlias); 
				}
				else
				{
					// concatenate the current namespace with the qualifier
					LPUSTR currQual = ISAMDatabase (lpSql->node.root.lpISAM);
					pszNewQualifier = new char [s_lstrlen (lpColumnAlias)+
												s_lstrlen (currQual) + 
												s_lstrlen (lpColumnQualifier) + 3 + 2];
					s_lstrcpy (pszNewQualifier, currQual);
					s_lstrcat (pszNewQualifier, "\\");
					s_lstrcat (pszNewQualifier, lpColumnQualifier);
					s_lstrcat (pszNewQualifier, ".");
					s_lstrcat (pszNewQualifier, lpColumnAlias);
				}
			}
			else
			{
				LPUSTR currQual = ISAMDatabase (lpSql->node.root.lpISAM);
				pszNewQualifier = new char [s_lstrlen (lpColumnAlias)+
											s_lstrlen (currQual)+ 2 + 1];
				s_lstrcpy (pszNewQualifier, currQual);
				s_lstrcat (pszNewQualifier, ".");
				s_lstrcat (pszNewQualifier, lpColumnAlias);
			}


			// get the table name and concatenate with the table qualifier
			// before the check
			lpTableName = ToString(lpSql, lpSqlNodeTable->node.table.Name);
			char *lpszFQTN = new char [s_lstrlen (lpTableName) + 
								       s_lstrlen (lpTableAlias) + 2 + 1];
			s_lstrcpy (lpszFQTN, lpTableAlias);
			s_lstrcat (lpszFQTN, ".");
			s_lstrcat (lpszFQTN, lpTableName);

			if (fCaseSensitive) { 
				if (!lstrcmp(lpszFQTN, pszNewQualifier)) {
					 found = TRUE;
				}
			}
			else {
				if (!lstrcmpi(lpszFQTN, pszNewQualifier)) {
					found = TRUE;
				}	
			}
			delete [] pszNewQualifier;
			delete lpszFQTN;
		}
		else
		{
			matchedAlias = TRUE;
		}

		//Check if this is the passthrough SQL table
		if (lpSqlNodeTable->node.table.Handle->fIsPassthroughSQL)
			found = TRUE;

		if (!found)
			return ERR_COLUMNNOTFOUND;

    }
   
    /* Search the table definition for a column with a matching name. */
    lpISAMTableDef = lpSqlNodeTable->node.table.Handle;

	BOOL fPassthroughSQLWithAlias = FALSE;
	LPSTR lpAlias = NULL;
		
	if ( (lpSqlNodeColumn->node.column.Tablealias != NO_STRING) && lpSqlNodeTable->node.table.Handle->fIsPassthroughSQL )	
	{
		lpAlias = (LPSTR) ToString(lpSql, lpSqlNodeColumn->node.column.Tablealias);
		
		if ( lpAlias && lstrlen(lpAlias) )
			fPassthroughSQLWithAlias = TRUE;
	}

	ClassColumnInfoBase* cInfoBase = lpISAMTableDef->pColumnInfo;

	if ( !cInfoBase->IsValid() )
	{
        return ERR_COLUMNNOTFOUND;
	}

	//Sai
	//The current column is lpName, if this is a system property
	//and SYSPROPS=FALSE then return an error
	if (lpISAMTableDef && lpISAMTableDef->lpISAM)
	{
		if ( ! lpISAMTableDef->lpISAM->fSysProps)
		{
			//we are not asking for system properties
			//so a system property should not be in the SELECT list
			if (_strnicmp("__", lpName, 2) == 0)
			{
				return ERR_COLUMNNOTFOUND;
			}
		}
	}

	UWORD cNumberOfCols = cInfoBase->GetNumberOfColumns();

	char pColumnName [MAX_COLUMN_NAME_LENGTH+1];
	char pColumnAlias [MAX_COLUMN_NAME_LENGTH+1];
	pColumnAlias[0] = 0;
	BOOL fMatch = FALSE;
	for (index = 0; index < cNumberOfCols; index++)
	{
		fMatch = FALSE;

		if ( FAILED(cInfoBase->GetColumnName(index, pColumnName, pColumnAlias)) )
		{
			return ERR_COLUMNNOTFOUND;
		}

		if (fCaseSensitive) 
		{
            if (!s_lstrcmp(lpName, pColumnName))
			{
				fMatch = TRUE;
 //               break;
			}
        }
        else 
		{
            if (!s_lstrcmpi(lpName, pColumnName))
			{
				fMatch = TRUE;
//                break;
			}
        }

		//Extra check for passthrough SQL
		if (fPassthroughSQLWithAlias && fMatch)
		{
			fMatch = FALSE;
			if (fCaseSensitive) 
			{
				if (!s_lstrcmp(lpAlias, pColumnAlias))
	                break;
			}
			else 
			{
				if (!s_lstrcmpi(lpAlias, pColumnAlias))
	                break;
			}
		}

		if (fMatch)
			break;
	}

#ifdef TESTING

	if (idxQualifier != NO_STRING)
	{
		char* lpTestQual = ToString(lpSql, lpSqlNodeTable->table.Qualifier);
		char* lpOrgQual = ToString(lpSql, idxQualifier);

		if (lpTestQual && lpOrgQual && strcmp(lpTestQual, lpOrgQual))
			return ERR_COLUMNNOTFOUND;
	}

#endif

	/* Error if not found */
	if (index == cNumberOfCols)
	{
        s_lstrcpy(lpstmt->szError, lpName);
        return ERR_COLUMNNOTFOUND; 
    }

    /* Set the table and column information in the column node. */
    lpSqlNodeColumn->node.column.Table = idxTable;
    lpSqlNodeColumn->node.column.Id = (UWORD) index;
    if (lpSqlNodeColumn->node.column.Tablealias == NO_STRING)
	{	
        lpSqlNodeColumn->node.column.Tablealias = lpSqlNodeTable->node.table.Name;
	}
	// to keep this consistent I'm going to put a flag in to say if it matched
	// a table name or an alias and put the qualifier in too
	lpSqlNodeColumn->node.column.MatchedAlias = matchedAlias;
	lpSqlNodeColumn->node.column.Qualifier = lpSqlNodeTable->node.table.Qualifier;
	// go further and set the column table reference to the table index.  In fact,
	// this is the best way of doing this.  Not sure why SYWARE didn't go this way
	// originally.  Probably as it ensured every table had an alias.  It really 
	// encapsualtes all the above info.
	lpSqlNodeColumn->node.column.TableIndex = idxTable; 

    /* Figure out type of data */
	cInfoBase->GetSQLType(index, lpSqlNodeColumn->sqlSqlType);

    switch (lpSqlNodeColumn->sqlSqlType) {
    case SQL_DECIMAL:
    case SQL_NUMERIC:
	{
        lpSqlNodeColumn->sqlDataType = TYPE_NUMERIC;
		UDWORD uwPrec = 0;
		cInfoBase->GetPrecision(index, uwPrec);
		lpSqlNodeColumn->sqlPrecision = (SWORD)uwPrec;
		cInfoBase->GetScale(index, lpSqlNodeColumn->sqlScale);
    }    
        break;
    case SQL_BIGINT:
	{
        lpSqlNodeColumn->sqlDataType = TYPE_NUMERIC;
		UDWORD uwPrec = 0;
		cInfoBase->GetPrecision(index, uwPrec);
		lpSqlNodeColumn->sqlPrecision = (SWORD)uwPrec;
        lpSqlNodeColumn->sqlScale = 0;
	}
        break;
    case SQL_TINYINT:
        lpSqlNodeColumn->sqlDataType = TYPE_INTEGER;
        lpSqlNodeColumn->sqlPrecision = 3;
        lpSqlNodeColumn->sqlScale = 0;
        break;
    case SQL_SMALLINT:
        lpSqlNodeColumn->sqlDataType = TYPE_INTEGER;
        lpSqlNodeColumn->sqlPrecision = 5;
        lpSqlNodeColumn->sqlScale = 0;
        break;
    case SQL_INTEGER:
        lpSqlNodeColumn->sqlDataType = TYPE_INTEGER;
        lpSqlNodeColumn->sqlPrecision = 10;
        lpSqlNodeColumn->sqlScale = 0;
        break;
    case SQL_BIT:
        lpSqlNodeColumn->sqlDataType = TYPE_INTEGER;
        lpSqlNodeColumn->sqlPrecision = 1;
        lpSqlNodeColumn->sqlScale = 0;
        break;
    case SQL_REAL:
        lpSqlNodeColumn->sqlDataType = TYPE_DOUBLE;
        lpSqlNodeColumn->sqlPrecision = 7;
        lpSqlNodeColumn->sqlScale = NO_SCALE;
        break;
    case SQL_FLOAT:
    case SQL_DOUBLE:
        lpSqlNodeColumn->sqlDataType = TYPE_DOUBLE;
        lpSqlNodeColumn->sqlPrecision = 15;
        lpSqlNodeColumn->sqlScale = NO_SCALE;
        break;
    case SQL_CHAR:
    case SQL_VARCHAR:
    case SQL_LONGVARCHAR:
	{
        lpSqlNodeColumn->sqlDataType = TYPE_CHAR;
		UDWORD uwPrec = 0;
		cInfoBase->GetPrecision(index, uwPrec);
		lpSqlNodeColumn->sqlPrecision = (SWORD)uwPrec;
		if (lpSqlNodeColumn->sqlPrecision > MAX_CHAR_LITERAL_LENGTH)
			lpSqlNodeColumn->sqlPrecision = MAX_CHAR_LITERAL_LENGTH;

        lpSqlNodeColumn->sqlScale = NO_SCALE;
	}
        break;
    case SQL_BINARY:
    case SQL_VARBINARY:
    case SQL_LONGVARBINARY:
	{
        lpSqlNodeColumn->sqlDataType = TYPE_BINARY;
		UDWORD uwPrec = 0;
		cInfoBase->GetPrecision(index, uwPrec);
		lpSqlNodeColumn->sqlPrecision = (SWORD)uwPrec;
        lpSqlNodeColumn->sqlScale = NO_SCALE;
	}
        break;
    case SQL_DATE:
        lpSqlNodeColumn->sqlDataType = TYPE_DATE;
        lpSqlNodeColumn->sqlPrecision = 10;
        lpSqlNodeColumn->sqlScale = NO_SCALE;
        break;
    case SQL_TIME:
        lpSqlNodeColumn->sqlDataType = TYPE_TIME;
        lpSqlNodeColumn->sqlPrecision = 8;
        lpSqlNodeColumn->sqlScale = NO_SCALE;
        break;
    case SQL_TIMESTAMP:
        lpSqlNodeColumn->sqlDataType = TYPE_TIMESTAMP;
        if (TIMESTAMP_SCALE > 0)
            lpSqlNodeColumn->sqlPrecision = 20 + TIMESTAMP_SCALE;
        else
            lpSqlNodeColumn->sqlPrecision = 19;
        lpSqlNodeColumn->sqlScale = TIMESTAMP_SCALE;
        break;
    default:
        return ERR_NOTSUPPORTED;
    }
    return ERR_SUCCESS;
}

/***************************************************************************/

void INTFUNC ErrorOpCode(LPSTMT lpstmt,
                         UWORD opCode)
/* Puts opcode in szError (as a string) */
{
    switch (opCode) {
    case OP_NONE:
        s_lstrcpy(lpstmt->szError, "<assignment>");
        break;
    case OP_EQ:
        s_lstrcpy(lpstmt->szError, "=");
        break;
    case OP_NE:
        s_lstrcpy(lpstmt->szError, "<>");
        break;
    case OP_LE:
        s_lstrcpy(lpstmt->szError, "<=");
        break;
    case OP_LT:
        s_lstrcpy(lpstmt->szError, "<");
        break;
    case OP_GE:
        s_lstrcpy(lpstmt->szError, ">=");
        break;
    case OP_GT:
        s_lstrcpy(lpstmt->szError, ">");
        break;
    case OP_IN:
        s_lstrcpy(lpstmt->szError, "IN");
        break;
    case OP_NOTIN:
        s_lstrcpy(lpstmt->szError, "NOT IN");
        break;
    case OP_LIKE:
        s_lstrcpy(lpstmt->szError, "LIKE");
        break;
    case OP_NOTLIKE:
        s_lstrcpy(lpstmt->szError, "NOT LIKE");
        break;
    case OP_NEG:
        s_lstrcpy(lpstmt->szError, "-");
        break;
    case OP_PLUS:
        s_lstrcpy(lpstmt->szError, "+");
        break;
    case OP_MINUS:
        s_lstrcpy(lpstmt->szError, "-");
        break;
    case OP_TIMES:
        s_lstrcpy(lpstmt->szError, "*");
        break;
    case OP_DIVIDEDBY:
        s_lstrcpy(lpstmt->szError, "/");
        break;
    case OP_NOT:
        s_lstrcpy(lpstmt->szError, "NOT");
        break;
    case OP_AND:
        s_lstrcpy(lpstmt->szError, "AND");
        break;
    case OP_OR:
        s_lstrcpy(lpstmt->szError, "OR");
        break;
    case OP_EXISTS:
        s_lstrcpy(lpstmt->szError, "EXISTS");
        break;
    default:
        s_lstrcpy(lpstmt->szError, "");
        break;
    }
}
/***************************************************************************/

void INTFUNC ErrorAggCode(LPSTMT lpstmt,
                         UWORD aggCode)
/* Puts aggreagate operator code in szError (as a string) */
{
    switch(aggCode) {
    case AGG_AVG:
        s_lstrcpy(lpstmt->szError, "AVG");
        break;
    case AGG_COUNT:
        s_lstrcpy(lpstmt->szError, "COUNT");
        break;
    case AGG_MAX:
        s_lstrcpy(lpstmt->szError, "MAX");
        break;
    case AGG_MIN:
        s_lstrcpy(lpstmt->szError, "MIN");
        break;
    case AGG_SUM:
        s_lstrcpy(lpstmt->szError, "SUM");
        break;
    default:
        s_lstrcpy(lpstmt->szError, "");
        break;
    }
}
/***************************************************************************/

RETCODE INTFUNC TypeCheck(LPSTMT lpstmt,
                          LPSQLTREE lpSql,
                          SQLNODEIDX idxLeft,
                          SQLNODEIDX idxRight,
                          UWORD opCode,
                          SWORD FAR *pfDataType,
                          SWORD FAR *pfSqlType,
                          SDWORD FAR *pPrecision,
                          SWORD FAR *pScale)

/* Checks to see if the types of the two children nodes are compatible. */
/* If the type of one of the children is unknown (because it was a      */
/* parameter or the value NULL), it set to the type of the other child. */

{
    LPSQLNODE lpSqlNodeLeft;
    LPSQLNODE lpSqlNodeRight;
    SWORD fDataTypeLeft;
    SWORD fSqlTypeLeft;
    SDWORD precisionLeft;
    SWORD scaleLeft;
    SWORD fDataTypeRight;
    SWORD fSqlTypeRight;
    SDWORD precisionRight;
    SWORD scaleRight;
    SWORD fDataType;
    SWORD fSqlType;
    SDWORD precision;
    SWORD scale;

#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))

    /* Get left type */
    if (idxLeft == NO_SQLNODE)
        return ERR_INTERNAL;
    lpSqlNodeLeft = ToNode(lpSql, idxLeft);
    fDataTypeLeft = lpSqlNodeLeft->sqlDataType;
    fSqlTypeLeft = lpSqlNodeLeft->sqlSqlType;
    precisionLeft = lpSqlNodeLeft->sqlPrecision;
    scaleLeft = lpSqlNodeLeft->sqlScale;

    /* Is there a right epxression? */
    if (idxRight != NO_SQLNODE) {

        /* Yes.  Get right type. */
        lpSqlNodeRight = ToNode(lpSql, idxRight);
        fDataTypeRight = lpSqlNodeRight->sqlDataType;
        fSqlTypeRight = lpSqlNodeRight->sqlSqlType;
        precisionRight = lpSqlNodeRight->sqlPrecision;
        scaleRight = lpSqlNodeRight->sqlScale;
    }
    else {

        /* No.  This must be an arithmetic negation operator.  Use left */
        /* type as the right type */
        if (opCode != OP_NEG)
            return ERR_INTERNAL;
        if (fDataTypeLeft == TYPE_UNKNOWN)
            return ERR_UNKNOWNTYPE;

        fDataTypeRight = fDataTypeLeft;
        fSqlTypeRight = fSqlTypeLeft;
        precisionRight = precisionLeft;
        scaleRight = scaleLeft;
    }

    /* Is left side unknown? */
    if (fDataTypeLeft == TYPE_UNKNOWN) {

        /* Yes.  Error if right side is unknown also */
        if (fDataTypeRight == TYPE_UNKNOWN)
            return ERR_UNKNOWNTYPE;

        /* If right side is string value, make sure opcode is legal */
        if (fDataTypeRight == TYPE_CHAR) {
            switch (opCode) {
            case OP_NONE:
            case OP_EQ:
            case OP_NE:
            case OP_LE:
            case OP_LT:
            case OP_GE:
            case OP_GT:
            case OP_IN:
            case OP_NOTIN:
            case OP_LIKE:
            case OP_NOTLIKE:
                break;
            case OP_NEG:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            case OP_PLUS:
                if (fSqlTypeRight == SQL_LONGVARCHAR) {
                    ErrorOpCode(lpstmt, opCode);
                    return ERR_INVALIDOPERAND;
                }
                break;
            case OP_MINUS:
            case OP_TIMES:
            case OP_DIVIDEDBY:
            case OP_NOT:
            case OP_AND:
            case OP_OR:
            case OP_EXISTS:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            }
        }

        /* If right side is date value, make sure opcode is legal */
        else if (fDataTypeRight == TYPE_DATE) {
            switch (opCode) {
            case OP_NONE:
            case OP_EQ:
            case OP_NE:
            case OP_LE:
            case OP_LT:
            case OP_GE:
            case OP_GT:
            case OP_IN:
            case OP_NOTIN:
                break;
            case OP_LIKE:
            case OP_NOTLIKE:
            case OP_NEG:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            case OP_PLUS:
            case OP_MINUS:
                break;
            case OP_TIMES:
            case OP_DIVIDEDBY:
            case OP_NOT:
            case OP_AND:
            case OP_OR:
            case OP_EXISTS:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            }
        }

        /* Adding to a date? */
        if ((fDataTypeRight == TYPE_DATE) && (opCode == OP_PLUS)) {

            /* Yes.  The left side must be integer */
            lpSqlNodeLeft->sqlDataType = TYPE_INTEGER;
            lpSqlNodeLeft->sqlSqlType = SQL_INTEGER;
            lpSqlNodeLeft->sqlPrecision = 10;
            lpSqlNodeLeft->sqlScale = 0;
        }
        else {
            /* No.  Use type from right as type for left */
            /* Note: This disallows ? from being a date in (? - 3) */
            /* Note: This disallows ? from being a date in (? + 3) */
            lpSqlNodeLeft->sqlDataType = fDataTypeRight;
            lpSqlNodeLeft->sqlSqlType = fSqlTypeRight;
            lpSqlNodeLeft->sqlPrecision = precisionRight;
            lpSqlNodeLeft->sqlScale = scaleRight;

            /* If string concatenation, adjust type and precision */
            if ((fDataTypeRight == TYPE_CHAR) && (opCode == OP_PLUS)) {
                lpSqlNodeLeft->sqlSqlType = SQL_VARCHAR;
                lpSqlNodeLeft->sqlPrecision = MAX_CHAR_LITERAL_LENGTH;
            }
        }

        /* Adding to a date? */
        if ((fDataTypeRight == TYPE_DATE) && (opCode == OP_PLUS)) {

            /* Yes.  The result type is a date */
            if (pfDataType != NULL)
                *pfDataType = lpSqlNodeRight->sqlDataType;
            if (pfSqlType != NULL)
                *pfSqlType = lpSqlNodeRight->sqlSqlType;
            if (pPrecision != NULL)
                *pPrecision = lpSqlNodeRight->sqlPrecision;
            if (pScale != NULL)
                *pScale = lpSqlNodeRight->sqlScale;
        }

        /* Calculating the differnce of two dates? */
        else if ((lpSqlNodeLeft->sqlDataType == TYPE_DATE) &&
                 (opCode == OP_MINUS)) {

            /* Yes.  The result type is integer */
            if (pfDataType != NULL)
                *pfDataType = TYPE_INTEGER;
            if (pfSqlType != NULL)
                *pfSqlType = SQL_INTEGER;
            if (pPrecision != NULL)
                *pPrecision = 10;
            if (pScale != NULL)
                *pScale = 0;
        }
        else {

            /* No.  The result type is the same as the left side */
            if (pfDataType != NULL)
                *pfDataType = lpSqlNodeLeft->sqlDataType;
            if (pfSqlType != NULL)
                *pfSqlType = lpSqlNodeLeft->sqlSqlType;
            if (pPrecision != NULL)
                *pPrecision = lpSqlNodeLeft->sqlPrecision;
            if (pScale != NULL)
                *pScale = lpSqlNodeLeft->sqlScale;
        }
    }

    /* Is right side unknown? */
    else if (fDataTypeRight == TYPE_UNKNOWN) {

        /* Yes.  If left side is string value, make sure opcode is legal */
        if (fDataTypeLeft == TYPE_CHAR) {
            switch (opCode) {
            case OP_NONE:
            case OP_EQ:
            case OP_NE:
            case OP_LE:
            case OP_LT:
            case OP_GE:
            case OP_GT:
            case OP_IN:
            case OP_NOTIN:
            case OP_LIKE:
            case OP_NOTLIKE:
                break;
            case OP_NEG:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            case OP_PLUS:
                if (fSqlTypeLeft == SQL_LONGVARCHAR) {
                    ErrorOpCode(lpstmt, opCode);
                    return ERR_INVALIDOPERAND;
                }
                break;
            case OP_MINUS:
            case OP_TIMES:
            case OP_DIVIDEDBY:
            case OP_NOT:
            case OP_AND:
            case OP_OR:
            case OP_EXISTS:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            }
        }

        /* If left side is date value, make sure opcode is legal */
        else if (fDataTypeLeft == TYPE_DATE) {
            switch (opCode) {
            case OP_NONE:
            case OP_EQ:
            case OP_NE:
            case OP_LE:
            case OP_LT:
            case OP_GE:
            case OP_GT:
            case OP_IN:
            case OP_NOTIN:
                break;
            case OP_LIKE:
            case OP_NOTLIKE:
            case OP_NEG:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            case OP_PLUS:
            case OP_MINUS:
                break;
            case OP_TIMES:
            case OP_DIVIDEDBY:
            case OP_NOT:
            case OP_AND:
            case OP_OR:
            case OP_EXISTS:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            }
        }

        /* Adding to a date? */
        if ((fDataTypeLeft == TYPE_DATE) && (opCode == OP_PLUS)) {

            /* Yes.  The right side must be integer */
            lpSqlNodeRight->sqlDataType = TYPE_INTEGER;
            lpSqlNodeRight->sqlSqlType = SQL_INTEGER;
            lpSqlNodeRight->sqlPrecision = 10;
            lpSqlNodeRight->sqlScale = 0;
        }
        else {
            /* No.  Use type from left as type for right */
            /* Note: This disallows ? from being a number in (<date> - ? ) */
            /* Note: This disallows ? from being a date in (<number> + ? ) */
            lpSqlNodeRight->sqlDataType = fDataTypeLeft;
            lpSqlNodeRight->sqlSqlType = fSqlTypeLeft;
            lpSqlNodeRight->sqlPrecision = precisionLeft;
            lpSqlNodeRight->sqlScale = scaleLeft;

            /* If string concatenation, adjust type and precision */
            if ((fDataTypeLeft == TYPE_CHAR) && (opCode == OP_PLUS)) {
                lpSqlNodeRight->sqlSqlType = SQL_VARCHAR;
                lpSqlNodeRight->sqlPrecision = MAX_CHAR_LITERAL_LENGTH;
            }
        }

        /* Adding to a date? */
        if ((fDataTypeLeft == TYPE_DATE) && (opCode == OP_PLUS)) {

            /* Yes.  The result type is a date */
            if (pfDataType != NULL)
                *pfDataType = TYPE_DATE;
            if (pfSqlType != NULL)
                *pfSqlType = SQL_DATE;
            if (pPrecision != NULL)
                *pPrecision = 10;
            if (pScale != NULL)
                *pScale = 0;
        }

        /* Calculating the difference of two dates? */
        else if ((fDataTypeLeft == TYPE_DATE) && (opCode == OP_MINUS)) {

            /* Yes.  The result type is integer */
            if (pfDataType != NULL)
                *pfDataType = TYPE_INTEGER;
            if (pfSqlType != NULL)
                *pfSqlType = SQL_INTEGER;
            if (pPrecision != NULL)
                *pPrecision = 10;
            if (pScale != NULL)
                *pScale = 0;
        }
        else {

            /* No.  The result type is the same as the right side */
            if (pfDataType != NULL)
                *pfDataType = lpSqlNodeRight->sqlDataType;
            if (pfSqlType != NULL)
                *pfSqlType = lpSqlNodeRight->sqlSqlType;
            if (pPrecision != NULL)
                *pPrecision = lpSqlNodeRight->sqlPrecision;
            if (pScale != NULL)
                *pScale = lpSqlNodeRight->sqlScale;
        }
    }

    /* Do types match? */
    else if ((fDataTypeLeft == fDataTypeRight) ||
             ((fDataTypeLeft == TYPE_DOUBLE) &&
                                  (fDataTypeRight == TYPE_NUMERIC)) ||
             ((fDataTypeLeft == TYPE_DOUBLE) &&
                                  (fDataTypeRight == TYPE_INTEGER)) ||
             ((fDataTypeLeft == TYPE_NUMERIC) &&
                                  (fDataTypeRight == TYPE_DOUBLE)) ||
             ((fDataTypeLeft == TYPE_NUMERIC) &&
                                  (fDataTypeRight == TYPE_INTEGER)) ||
             ((fDataTypeLeft == TYPE_INTEGER) &&
                                  (fDataTypeRight == TYPE_DOUBLE)) ||
             ((fDataTypeLeft == TYPE_INTEGER) &&
                                  (fDataTypeRight == TYPE_NUMERIC))) {

        /* Yes.  If left side is string value, make sure opcode is legal */
        if (fDataTypeLeft == TYPE_CHAR) {
            switch (opCode) {
            case OP_NONE:
            case OP_EQ:
            case OP_NE:
            case OP_LE:
            case OP_LT:
            case OP_GE:
            case OP_GT:
            case OP_IN:
            case OP_NOTIN:
            case OP_LIKE:
            case OP_NOTLIKE:
                break;
            case OP_NEG:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            case OP_PLUS:
                if ((fSqlTypeRight == SQL_LONGVARCHAR) ||
                                    (fSqlTypeLeft == SQL_LONGVARCHAR)) {
                    ErrorOpCode(lpstmt, opCode);
                    return ERR_INVALIDOPERAND;
				}
                break;
            case OP_MINUS:
            case OP_TIMES:
            case OP_DIVIDEDBY:
            case OP_NOT:
            case OP_AND:
            case OP_OR:
            case OP_EXISTS:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            }
        }

        /* If left side is date value, make sure opcode is legal */
        else if (fDataTypeLeft == TYPE_DATE) {
            switch (opCode) {
            case OP_NONE:
            case OP_EQ:
            case OP_NE:
            case OP_LE:
            case OP_LT:
            case OP_GE:
            case OP_GT:
            case OP_IN:
            case OP_NOTIN:
                break;
            case OP_LIKE:
            case OP_NOTLIKE:
            case OP_NEG:
            case OP_PLUS:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            case OP_MINUS:
                break;
            case OP_TIMES:
            case OP_DIVIDEDBY:
            case OP_NOT:
            case OP_AND:
            case OP_OR:
            case OP_EXISTS:
                ErrorOpCode(lpstmt, opCode);
                return ERR_INVALIDOPERAND;
            }
        }

        /* Figure out resultant type */
        if ((fDataTypeLeft == TYPE_NUMERIC) && (fDataTypeRight == TYPE_DOUBLE))
            fDataType = TYPE_DOUBLE;
        else if ((fDataTypeLeft == TYPE_INTEGER) && (fDataTypeRight == TYPE_DOUBLE))
            fDataType = TYPE_DOUBLE;
        else if ((fDataTypeLeft == TYPE_INTEGER) && (fDataTypeRight == TYPE_NUMERIC))
            fDataType = TYPE_NUMERIC;
        else
            fDataType = fDataTypeLeft;

        if (pfDataType != NULL)
            *pfDataType = fDataType;

        /* Figure out resultant SQL type, precision, and scale */
        switch (fSqlTypeLeft) {
        case SQL_DOUBLE:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_FLOAT:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeLeft;
                if (pPrecision != NULL)
                    *pPrecision = precisionLeft;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
            case SQL_CHAR:
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
            case SQL_BINARY:
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_FLOAT:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
                if (pfSqlType != NULL)
                   *pfSqlType = fSqlTypeLeft;
                if (pPrecision != NULL)
                    *pPrecision = precisionLeft;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
            case SQL_CHAR:
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
            case SQL_BINARY:
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_REAL:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_REAL:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeLeft;
                if (pPrecision != NULL)
                    *pPrecision = precisionLeft;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
            case SQL_CHAR:
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
            case SQL_BINARY:
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;

        case SQL_DECIMAL:
        case SQL_NUMERIC:
        case SQL_BIGINT:
        case SQL_INTEGER:
        case SQL_SMALLINT:
        case SQL_TINYINT:
        case SQL_BIT:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_REAL:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
                if ((fSqlTypeRight == SQL_DECIMAL) ||
                    (fSqlTypeLeft == SQL_DECIMAL))
                    fSqlType = SQL_DECIMAL;
                else if ((fSqlTypeRight == SQL_NUMERIC) ||
                         (fSqlTypeLeft == SQL_NUMERIC))
                    fSqlType = SQL_NUMERIC;
                else if ((fSqlTypeRight == SQL_BIGINT) ||
                         (fSqlTypeLeft == SQL_BIGINT))
                    fSqlType = SQL_BIGINT;
                else if ((fSqlTypeRight == SQL_INTEGER) ||
                         (fSqlTypeLeft == SQL_INTEGER))
                    fSqlType = SQL_INTEGER;
                else if ((fSqlTypeRight == SQL_SMALLINT) ||
                         (fSqlTypeLeft == SQL_SMALLINT))
                    fSqlType = SQL_SMALLINT;
                else if ((fSqlTypeRight == SQL_TINYINT) ||
                         (fSqlTypeLeft == SQL_TINYINT))
                    fSqlType = SQL_TINYINT;
                else
                    fSqlType = SQL_BIT;
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlType;
                switch (opCode) {
                case OP_NONE:
                case OP_EQ:
                case OP_NE:
                case OP_LE:
                case OP_LT:
                case OP_GE:
                case OP_GT:
                case OP_IN:
                case OP_NOTIN:
                    if (pPrecision != NULL)
                        *pPrecision = precisionLeft;
                    if (pScale != NULL)
                        *pScale = scaleLeft;
                    break;

                case OP_LIKE:
                case OP_NOTLIKE:
                    ErrorOpCode(lpstmt, opCode);
                    return ERR_INVALIDOPERAND;

                case OP_NEG:
                    if (pPrecision != NULL)
                        *pPrecision = precisionLeft;
                    if (pScale != NULL)
                        *pScale = scaleLeft;
                    break;
                case OP_PLUS:
                case OP_MINUS:
                    scale = MAX(scaleRight, scaleLeft);
                    switch (fSqlType) {
                    case SQL_DOUBLE:
                    case SQL_FLOAT:
                    case SQL_REAL:
                        return ERR_INTERNAL;
                    case SQL_DECIMAL:
                    case SQL_NUMERIC:
                    case SQL_BIGINT:
                        precision = scale + MAX(precisionRight - scaleRight,
                                              precisionLeft - scaleLeft) + 1;
                        break;
                    case SQL_INTEGER:
                        precision = 10;
                        break;
                    case SQL_SMALLINT:
                        precision = 5;
                        break;
                    case SQL_TINYINT:
                        precision = 3;
                        break;
                    case SQL_BIT:
                        precision = 1;
                        break;
                    case SQL_LONGVARCHAR:
                    case SQL_VARCHAR:
                    case SQL_CHAR:
                    case SQL_LONGVARBINARY:
                    case SQL_VARBINARY:
                    case SQL_BINARY:
                    case SQL_DATE:
                    case SQL_TIME:
                    case SQL_TIMESTAMP:
                        return ERR_INTERNAL;
                    default:
                        return ERR_NOTSUPPORTED;
                    }
                    if (pPrecision != NULL)
                        *pPrecision = precision;
                    if (pScale != NULL)
                        *pScale = scale;
                    break;
                case OP_TIMES:
                case OP_DIVIDEDBY:
                    scale = scaleRight + scaleLeft;
                    switch (fSqlType) {
                    case SQL_DOUBLE:
                    case SQL_FLOAT:
                    case SQL_REAL:
                        return ERR_INTERNAL;
                    case SQL_DECIMAL:
                    case SQL_NUMERIC:
                    case SQL_BIGINT:
                        precision = scale + (precisionRight - scaleRight) +
                                            (precisionLeft - scaleLeft);
                        break;
                    case SQL_INTEGER:
                        precision = 10;
                        break;
                    case SQL_SMALLINT:
                        precision = 5;
                        break;
                    case SQL_TINYINT:
                        precision = 3;
                        break;
                    case SQL_BIT:
                        precision = 1;
                        break;
                    case SQL_LONGVARCHAR:
                    case SQL_VARCHAR:
                    case SQL_CHAR:
                    case SQL_LONGVARBINARY:
                    case SQL_VARBINARY:
                    case SQL_BINARY:
                    case SQL_DATE:
                    case SQL_TIME:
                    case SQL_TIMESTAMP:
                        return ERR_INTERNAL;
                    default:
                        return ERR_NOTSUPPORTED;
                    }
                    if (pPrecision != NULL)
                        *pPrecision = precision;
                    if (pScale != NULL)
                        *pScale = scale;
                    break;
                case OP_NOT:
                case OP_AND:
                case OP_OR:
                case OP_EXISTS:
                    ErrorOpCode(lpstmt, opCode);
                    return ERR_INVALIDOPERAND;
                }
                break;
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
            case SQL_CHAR:
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
            case SQL_BINARY:
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;

        case SQL_LONGVARCHAR:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
                return ERR_INTERNAL;
            case SQL_LONGVARCHAR:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                 break;
            case SQL_VARCHAR:
            case SQL_CHAR:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeLeft;
                if (pPrecision != NULL) {
                    if (precisionLeft > precisionRight)
                        *pPrecision = precisionLeft;
                    else
                        *pPrecision = precisionRight;
                }
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
            case SQL_BINARY:
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_VARCHAR:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
                return ERR_INTERNAL;
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_CHAR:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeLeft;
                if (pPrecision != NULL)
                    *pPrecision = precisionLeft;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
            case SQL_BINARY:
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }

            /* Adjust precision for string concatenation operator */
            if ((opCode == OP_PLUS) && (pPrecision != NULL))
                *pPrecision = MIN(precisionRight + precisionLeft,
                                           MAX_CHAR_LITERAL_LENGTH);
            break;
        case SQL_CHAR:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
                return ERR_INTERNAL;
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
            case SQL_CHAR:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
            case SQL_BINARY:
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }

            /* Adjust precision for string concatenation operator */
            if ((opCode == OP_PLUS) && (pPrecision != NULL))
                *pPrecision = MIN(precisionRight + precisionLeft,
                                           MAX_CHAR_LITERAL_LENGTH);

            break;
        case SQL_LONGVARBINARY:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
            case SQL_CHAR:
                return ERR_INTERNAL;
            case SQL_LONGVARBINARY:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_VARBINARY:
            case SQL_BINARY:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeLeft;
                if (pPrecision != NULL)
                    *pPrecision = precisionLeft;
                if (pScale != NULL)
                   *pScale = NO_SCALE;
                break;
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_VARBINARY:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
            case SQL_CHAR:
                return ERR_INTERNAL;
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_BINARY:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeLeft;
                if (pPrecision != NULL)
                    *pPrecision = precisionLeft;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_BINARY:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
            case SQL_CHAR:
                return ERR_INTERNAL;
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
            case SQL_BINARY:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_DATE:
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_DATE:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
            case SQL_CHAR:
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
            case SQL_BINARY:
                 return ERR_INTERNAL;
            case SQL_DATE:
                switch (opCode) {
                case OP_NONE:
                case OP_EQ:
                case OP_NE:
                case OP_LE:
                case OP_LT:
                case OP_GE:
                case OP_GT:
                case OP_IN:
                case OP_NOTIN:
                    if (pfSqlType != NULL)
                        *pfSqlType = fSqlTypeLeft;
                    if (pPrecision != NULL)
                        *pPrecision = precisionLeft;
                    if (pScale != NULL)
                        *pScale = scaleLeft;
                    break;

                case OP_LIKE:
                case OP_NOTLIKE:
                case OP_NEG:
                case OP_PLUS:
                    ErrorOpCode(lpstmt, opCode);
                    return ERR_INVALIDOPERAND;

                case OP_MINUS:
                    if (pfDataType != NULL)
                        *pfDataType = TYPE_INTEGER;
                    if (pPrecision != NULL)
                        *pPrecision = 10;
                    if (pfSqlType != NULL)
                        *pfSqlType = SQL_INTEGER;
                    if (pScale != NULL)
                        *pScale = 0;
                    break;

                case OP_TIMES:
                case OP_DIVIDEDBY:
                case OP_NOT:
                case OP_AND:
                case OP_OR:
                case OP_EXISTS:
                    ErrorOpCode(lpstmt, opCode);
                    return ERR_INVALIDOPERAND;
                }
                break;
            case SQL_TIME:
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_TIME:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
            case SQL_CHAR:
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
            case SQL_BINARY:
            case SQL_DATE:
                return ERR_INTERNAL;
            case SQL_TIME:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = NO_SCALE;
                break;
            case SQL_TIMESTAMP:
                return ERR_INTERNAL;
            default:
                 return ERR_NOTSUPPORTED;
            }
            break;
        case SQL_TIMESTAMP:
            switch (fSqlTypeRight) {
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_REAL:
            case SQL_DECIMAL:
            case SQL_NUMERIC:
            case SQL_BIGINT:
            case SQL_INTEGER:
            case SQL_SMALLINT:
            case SQL_TINYINT:
            case SQL_BIT:
            case SQL_LONGVARCHAR:
            case SQL_VARCHAR:
            case SQL_CHAR:
            case SQL_LONGVARBINARY:
            case SQL_VARBINARY:
            case SQL_BINARY:
            case SQL_DATE:
            case SQL_TIME:
                return ERR_INTERNAL;
            case SQL_TIMESTAMP:
                if (pfSqlType != NULL)
                    *pfSqlType = fSqlTypeRight;
                if (pPrecision != NULL)
                    *pPrecision = precisionRight;
                if (pScale != NULL)
                    *pScale = TIMESTAMP_SCALE;
                break;
            default:
                return ERR_NOTSUPPORTED;
            }
            break;
        default:
            return ERR_NOTSUPPORTED;
        }
    }
    else if ((fDataTypeLeft == TYPE_DATE) &&
             ((fDataTypeRight == TYPE_DOUBLE) ||
              (fDataTypeRight == TYPE_NUMERIC) ||
              (fDataTypeRight == TYPE_INTEGER))) {
        switch (opCode) {
        case OP_NONE:
        case OP_EQ:
        case OP_NE:
        case OP_LE:
        case OP_LT:
        case OP_GE:
        case OP_GT:
        case OP_IN:
        case OP_NOTIN:
        case OP_LIKE:
        case OP_NOTLIKE:
        case OP_NEG:
            ErrorOpCode(lpstmt, opCode);
            return ERR_INVALIDOPERAND;

        case OP_PLUS:
        case OP_MINUS:
            if (pfDataType != NULL)
                *pfDataType = fDataTypeLeft;
            if (pfSqlType != NULL)
                *pfSqlType = fSqlTypeLeft;
            if (pPrecision != NULL)
                *pPrecision = precisionLeft;
            if (pScale != NULL)
                *pScale = scaleLeft;
            break;
        case OP_TIMES:
        case OP_DIVIDEDBY:
        case OP_NOT:
        case OP_AND:
        case OP_OR:
        case OP_EXISTS:
            ErrorOpCode(lpstmt, opCode);
            return ERR_INVALIDOPERAND;
        }
    }
    else if ((fDataTypeRight == TYPE_DATE) &&
             ((fDataTypeLeft == TYPE_DOUBLE) ||
              (fDataTypeLeft == TYPE_NUMERIC) ||
              (fDataTypeLeft == TYPE_INTEGER))) {
        switch (opCode) {
        case OP_NONE:
        case OP_EQ:
        case OP_NE:
        case OP_LE:
        case OP_LT:
        case OP_GE:
        case OP_GT:
        case OP_IN:
        case OP_NOTIN:
        case OP_LIKE:
        case OP_NOTLIKE:
        case OP_NEG:
            ErrorOpCode(lpstmt, opCode);
            return ERR_INVALIDOPERAND;

        case OP_PLUS:
            if (pfDataType != NULL)
                *pfDataType = fDataTypeRight;
            if (pfSqlType != NULL)
                *pfSqlType = fSqlTypeRight;
            if (pPrecision != NULL)
                *pPrecision = precisionRight;
            if (pScale != NULL)
                *pScale = scaleRight;
            break;

        case OP_MINUS:
        case OP_TIMES:
        case OP_DIVIDEDBY:
        case OP_NOT:
        case OP_AND:
        case OP_OR:
        case OP_EXISTS:
            ErrorOpCode(lpstmt, opCode);
            return ERR_INVALIDOPERAND;
        }
    }
    else {
        ErrorOpCode(lpstmt, opCode);
        return ERR_INVALIDOPERAND;
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

BOOL INTFUNC FindAggregate(LPSQLTREE lpSql, SQLNODEIDX idxNode)

/* Looks for the next aggregate function on a select list */
{
    LPSQLNODE lpSqlNode;

    if (idxNode == NO_SQLNODE)
        return FALSE;
    lpSqlNode = ToNode(lpSql, idxNode);
    switch (lpSqlNode->sqlNodeType) {
    case NODE_TYPE_NONE:
    case NODE_TYPE_ROOT:
    case NODE_TYPE_CREATE:
    case NODE_TYPE_DROP:
        return FALSE; /* Internal error */

    case NODE_TYPE_SELECT:
        return FALSE;

    case NODE_TYPE_INSERT:
    case NODE_TYPE_DELETE:
    case NODE_TYPE_UPDATE:
    case NODE_TYPE_CREATEINDEX:
    case NODE_TYPE_DROPINDEX:
    case NODE_TYPE_PASSTHROUGH:
    case NODE_TYPE_TABLES:
        return FALSE; /* Internal error */

    case NODE_TYPE_VALUES:
        while (TRUE) {
            if (FindAggregate(lpSql, lpSqlNode->node.values.Value))
                return TRUE;
            if (lpSqlNode->node.values.Next == NO_SQLNODE)
                return FALSE;
            lpSqlNode = ToNode(lpSql, lpSqlNode->node.values.Next);
        }

    case NODE_TYPE_COLUMNS:
    case NODE_TYPE_SORTCOLUMNS:
    case NODE_TYPE_GROUPBYCOLUMNS:
    case NODE_TYPE_UPDATEVALUES:
    case NODE_TYPE_CREATECOLS:
    case NODE_TYPE_BOOLEAN:
    case NODE_TYPE_COMPARISON:
        return FALSE; /* Internal error */

    case NODE_TYPE_ALGEBRAIC:
        if (FindAggregate(lpSql, lpSqlNode->node.algebraic.Left))
            return TRUE;
        return (FindAggregate(lpSql, lpSqlNode->node.algebraic.Right));

    case NODE_TYPE_SCALAR:
        return (FindAggregate(lpSql, lpSqlNode->node.scalar.Arguments));

    case NODE_TYPE_AGGREGATE:
        return TRUE;

    case NODE_TYPE_TABLE:
        return FALSE; /* Internal error */

    case NODE_TYPE_COLUMN:
    case NODE_TYPE_STRING:
    case NODE_TYPE_NUMERIC:
    case NODE_TYPE_PARAMETER:
    case NODE_TYPE_USER:
    case NODE_TYPE_NULL:
    case NODE_TYPE_DATE:
    case NODE_TYPE_TIME:
    case NODE_TYPE_TIMESTAMP:
        return FALSE;

    default:
        return FALSE; /* Internal error */
    }
}
/***************************************************************************/

RETCODE INTFUNC SelectCheck(LPSTMT lpstmt, LPSQLTREE FAR *lplpSql,
                            SQLNODEIDX idxNode, BOOL fCaseSensitive,
                            SQLNODEIDX idxEnclosingStatement)

/* Walks a SELECT parse tree, checks it for semantic correctness, and   */
/* fills in the semantic information.                                   */

{
    LPSQLNODE lpSqlNode;
    RETCODE err;
    UWORD count;
    UDWORD offset;
    BOOL fIsGroupby;

    if (idxNode == NO_SQLNODE)
        return ERR_SUCCESS;

    lpSqlNode = ToNode(*lplpSql, idxNode);

    /* Save pointer to enclosing statement */
    lpSqlNode->node.select.EnclosingStatement = idxEnclosingStatement;

    /* Check the list of tables */
    err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.select.Tables,
                            FALSE, fCaseSensitive, NO_SQLNODE, idxNode);
    if (err != ERR_SUCCESS)
        return err;

    /* Check the GROUP BY columns */
    err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.select.Groupbycolumns,
                            FALSE, fCaseSensitive, NO_SQLNODE, idxNode);
    if (err != ERR_SUCCESS)
        return err;

    /* Is there a GROUP BY clause? */
    count = 0;
    offset = 1;
    if (lpSqlNode->node.select.Groupbycolumns != NO_SQLNODE) {

        UDWORD length;
        SQLNODEIDX idxGroupbycolumns;
        LPSQLNODE  lpSqlNodeGroupbycolumns;
        LPSQLNODE  lpSqlNodeColumn;

        /* Yes.  Error if SELECT * */
        if (lpSqlNode->node.select.Values == NO_SQLNODE)
            return ERR_NOSELECTSTAR;

        /* Figure out offset and length of each column when it */
        /* is in the sort file */
        idxGroupbycolumns = lpSqlNode->node.select.Groupbycolumns;
        while (idxGroupbycolumns != NO_SQLNODE) {

            /* Add this column to the count */
            count++;

            /* Error if too many columns */
            if (count > MAX_COLUMNS_IN_GROUP_BY)
                return ERR_GROUPBYTOOLARGE;

            /* Save column offset */
            lpSqlNodeGroupbycolumns = ToNode(*lplpSql, idxGroupbycolumns);
            lpSqlNodeColumn = ToNode(*lplpSql,
                             lpSqlNodeGroupbycolumns->node.groupbycolumns.Column);
            lpSqlNodeColumn->node.column.Offset = offset;

            /* Get length of the column */
            switch (lpSqlNodeColumn->sqlDataType) {
            case TYPE_DOUBLE:
                length = sizeof(double);
                break;

            case TYPE_NUMERIC:
                length = 2 + lpSqlNodeColumn->sqlPrecision;
                break;

            case TYPE_INTEGER:
                length = sizeof(double);
                break;

            case TYPE_CHAR:
                length = lpSqlNodeColumn->sqlPrecision;
                if (length > MAX_CHAR_LITERAL_LENGTH) {
                    s_lstrcpy((char*)lpstmt->szError,
                          ToString(*lplpSql, lpSqlNodeColumn->node.column.Column));
                    return ERR_CANTGROUPBYONTHIS;
                }
                break;

            case TYPE_BINARY:
                s_lstrcpy((char*)lpstmt->szError,
                         ToString(*lplpSql, lpSqlNodeColumn->node.column.Column));
                return ERR_CANTGROUPBYONTHIS;

            case TYPE_DATE:
                length = 10;
                break;

            case TYPE_TIME:
                length = 8;
                break;

            case TYPE_TIMESTAMP:
                if (TIMESTAMP_SCALE > 0)
                    length = 20 + TIMESTAMP_SCALE;
                else
                    length = 19;
                break;

            default:
                s_lstrcpy((char*)lpstmt->szError,
                         ToString(*lplpSql, lpSqlNodeColumn->node.column.Column));
                return ERR_CANTGROUPBYONTHIS;
            }

            /* Put length of the column column description */
            lpSqlNodeColumn->node.column.Length = length;

            /* Go to next column */
            offset += (length);
            offset++;    /* for the IS NULL flag */
            idxGroupbycolumns = lpSqlNodeGroupbycolumns->node.groupbycolumns.Next;
        }

        /* Set flag */
        fIsGroupby = TRUE;
    }
    else {

        /* No.  Are there any aggregates in the select list? */
        if (!FindAggregate(*lplpSql, lpSqlNode->node.select.Values)) {

            /* No.  Error if there is a HAVING clause */
            if (lpSqlNode->node.select.Having != NO_SQLNODE)
                return ERR_NOGROUPBY;

            /* Set flag */
            fIsGroupby = FALSE;
        }
        else {

            /* Yes.  Set flags */
            lpSqlNode->node.select.ImplicitGroupby = TRUE;
            fIsGroupby = TRUE;
        }
    }

	/* SELECT * ? */
    if (lpSqlNode->node.select.Values == NO_SQLNODE) {

        SQLNODEIDX idxTables;
        LPSQLNODE  lpSqlNodeTables;
        SQLNODEIDX idxTable;
        LPSQLNODE  lpSqlNodeTable;
//        STRINGIDX  idxAlias;
        LPISAMTABLEDEF lpTableHandle;
        SQLNODEIDX idxValues;
        LPSQLNODE  lpSqlNodeValues;
        SQLNODEIDX idxValuesPrev;
        LPSQLNODE  lpSqlNodeValuesPrev;
        SQLNODEIDX idxColumn;
        LPSQLNODE  lpSqlNodeColumn;
        SWORD      idx;

        /* Yes.  Loop though all the tables in the table list */
        idxValuesPrev = NO_SQLNODE;
        idxTables = lpSqlNode->node.select.Tables;
        while (idxTables != NO_SQLNODE) {

            /* Get pointer to the next table */
            lpSqlNodeTables = ToNode(*lplpSql, idxTables);
            idxTables = lpSqlNodeTables->node.tables.Next;

            /* Get pointer to this table */
            idxTable = lpSqlNodeTables->node.tables.Table;
            lpSqlNodeTable = ToNode(*lplpSql, idxTable);

            /* Loop through all the columns of this table */
            lpTableHandle = lpSqlNodeTable->node.table.Handle;

			ClassColumnInfoBase* cInfoBase = lpTableHandle->pColumnInfo;

			LPISAM myISAM = lpTableHandle->lpISAM;

			if ( !cInfoBase->IsValid() )
			{
				return ERR_COLUMNNOTFOUND;
			}

			//Store able alias before allocating memory
			//in order to avoid bug
			STRINGIDX idxTheAlias = lpSqlNodeTable->node.table.Alias;
			STRINGIDX idxTheQual = lpSqlNodeTable->node.table.Qualifier;


			UWORD cNumberOfCols = cInfoBase->GetNumberOfColumns();

			char pColumnName [MAX_COLUMN_NAME_LENGTH+1];

			//Sai added - fetch the  column alias 
			//only filled in if using passthrough SQL, ignored otherwise
			char pAliasName [MAX_COLUMN_NAME_LENGTH+1];
			pAliasName[0] = 0;
			
			for (idx = 0; idx < (SWORD) cNumberOfCols; idx++) 
			{
				if ( FAILED(cInfoBase->GetColumnName(idx, pColumnName, pAliasName)) )
				{
					return ERR_COLUMNNOTFOUND;
				}

				//Ignore any OLEMS specific columns which we want to hide
				if (myISAM && !(myISAM->fSysProps))
				{
					if (_strnicmp("__", pColumnName, 2) == 0)
					{
						continue;
					}
				}

				//Ignore any 'lazy' columns
				BOOL fIsLazy = FALSE;
				if ( cInfoBase->IsLazy(idx, fIsLazy) )
				{
					if (fIsLazy)
					{
						continue;
					}
				}

				//Check if this column type is support
				//if not we skip this column
				if (! ISAMGetColumnType(lpTableHandle, (UWORD) idx) )
				{
					continue;
				}

                /* Create a node for this column */
                idxColumn = AllocateNode(lplpSql, NODE_TYPE_COLUMN);
                if (idxColumn == NO_SQLNODE)
                    return ERR_MEMALLOCFAIL;

				//Get new pointers
                lpSqlNodeColumn = ToNode(*lplpSql, idxColumn);
				lpSqlNodeTable = ToNode(*lplpSql, idxTable);

				lpSqlNodeColumn->node.column.Tablealias = idxTheAlias;

				if (lpSqlNodeTable->node.table.Alias != NO_STRING)
				{
					lpSqlNodeColumn->node.column.MatchedAlias = TRUE;
				}
				else
				{
					lpSqlNodeColumn->node.column.MatchedAlias = FALSE;
				}

                lpSqlNodeColumn->node.column.TableIndex = idxTable;
				lpSqlNodeColumn->node.column.Qualifier = idxTheQual;

                lpSqlNodeColumn->node.column.Column = AllocateString(lplpSql,
							(LPUSTR)pColumnName);

				//New - for identical column names when using passthrough SQL
				if ( pAliasName && lstrlen(pAliasName) )
				{
					lpSqlNodeColumn->node.column.Tablealias = AllocateString(lplpSql,
							(LPUSTR)pAliasName); 
				}

				//To avoid bug recalc lpSqlNodeColumn
				lpSqlNodeColumn = ToNode(*lplpSql, idxColumn);


                if (lpSqlNodeColumn->node.column.Column == NO_STRING)
                    return ERR_MEMALLOCFAIL;
                lpSqlNodeColumn->node.table.Handle = NULL;
                lpSqlNodeColumn->node.column.Id = -1;
                lpSqlNodeColumn->node.column.Value = NO_STRING;
                lpSqlNodeColumn->node.column.InSortRecord = FALSE;
                lpSqlNodeColumn->node.column.Offset = 0;
                lpSqlNodeColumn->node.column.Length = 0;
                lpSqlNodeColumn->node.column.DistinctOffset = 0;
                lpSqlNodeColumn->node.column.DistinctLength = 0;
                lpSqlNodeColumn->node.column.EnclosingStatement = NO_SQLNODE;

                /* Put it on the list */
                idxValues = AllocateNode(lplpSql, NODE_TYPE_VALUES);
                if (idxValues == NO_SQLNODE)
                    return ERR_MEMALLOCFAIL;
                lpSqlNodeValues = ToNode(*lplpSql, idxValues);
                lpSqlNodeValues->node.values.Value = idxColumn;
                lpSqlNodeValues->node.values.Alias = NO_STRING;
                lpSqlNodeValues->node.values.Next = NO_SQLNODE;

                if (idxValuesPrev == NO_SQLNODE) {
                    lpSqlNode = ToNode(*lplpSql, idxNode);
                    lpSqlNode->node.select.Values = idxValues;
                }
                else {
                    lpSqlNodeValuesPrev = ToNode(*lplpSql, idxValuesPrev);
                    lpSqlNodeValuesPrev->node.values.Next = idxValues;
                }
                idxValuesPrev = idxValues;
            }

        }
        lpSqlNode = ToNode(*lplpSql, idxNode);
    }


	/* SELECT aliasname.* ? */
    {
        SQLNODEIDX idxValuesPrev;
        SQLNODEIDX idxValues;
        LPSQLNODE  lpSqlNodeValues;
        SQLNODEIDX idxTables;
        LPSQLNODE  lpSqlNodeTables;
        SQLNODEIDX idxTable;
        LPSQLNODE  lpSqlNodeTable;
        LPUSTR     lpTableAlias;
        LPUSTR     lpValuesAlias;
        LPSQLNODE  lpSqlNodeValuesPrev;
        LPISAMTABLEDEF lpTableHandle;
        SQLNODEIDX idxColumn;
        LPSQLNODE  lpSqlNodeColumn;
        SWORD      idx;
        STRINGIDX  idxAlias;
        SQLNODEIDX idxValuesNew;

        /* Yes.  Loop though all the nodes in the select list */
        idxValuesPrev = NO_SQLNODE;
        idxValues = lpSqlNode->node.select.Values;
        while (idxValues != NO_SQLNODE) {

            /* Get pointer to the values node */
            lpSqlNodeValues = ToNode(*lplpSql, idxValues);

            /* Is this a <table>.* node? */
            if (lpSqlNodeValues->node.values.Value != NO_SQLNODE) {

                /* No.  Go to next entry */
                idxValuesPrev = idxValues;
                idxValues = lpSqlNodeValues->node.values.Next;
                continue;
            }
            idxValues = lpSqlNodeValues->node.values.Next;

            /* Find the table */
            lpValuesAlias = ToString(*lplpSql,
                                     lpSqlNodeValues->node.values.Alias);
            idxTables = lpSqlNode->node.select.Tables;

			//First pass : check alias's
            while (idxTables != NO_SQLNODE) {

                /* Get pointer to the table */
                lpSqlNodeTables = ToNode(*lplpSql, idxTables);
                
                /* Get pointer to this table */
                idxTable = lpSqlNodeTables->node.tables.Table;
                lpSqlNodeTable = ToNode(*lplpSql, idxTable);

                /* Get Alias of this table */
                idxAlias = lpSqlNodeTable->node.table.Alias;
                
                /* Leave loop if it matches */
                lpTableAlias = ToString(*lplpSql, idxAlias);
                if (fCaseSensitive) { 
                    if (!s_lstrcmp(lpTableAlias, lpValuesAlias)) 
                        break;
                }
                else {
                    if (!s_lstrcmpi(lpTableAlias, lpValuesAlias))
                        break;
                }

                /* It does not match.  Try next table */
                idxTables = lpSqlNodeTables->node.tables.Next;
            }

			//second pass : table name
			if (idxTables == NO_SQLNODE) {

				idxTables = lpSqlNode->node.select.Tables;
				while (idxTables != NO_SQLNODE) {

					/* Get pointer to the table */
					lpSqlNodeTables = ToNode(*lplpSql, idxTables);
                
					/* Get pointer to this table */
					idxTable = lpSqlNodeTables->node.tables.Table;
					lpSqlNodeTable = ToNode(*lplpSql, idxTable);

					/* Get Alias of this table */
					idxAlias = lpSqlNodeTable->node.table.Name;
                
					/* Leave loop if it matches */
					lpTableAlias = ToString(*lplpSql, idxAlias);
					if (fCaseSensitive) { 
						if (!s_lstrcmp(lpTableAlias, lpValuesAlias))
						{
							lpSqlNodeTable->node.table.Alias = idxAlias;
							break;
						}
					}
					else {
						if (!s_lstrcmpi(lpTableAlias, lpValuesAlias))
						{
							lpSqlNodeTable->node.table.Alias = idxAlias;
							break;
						}
					}

					/* It does not match.  Try next table */
					idxTables = lpSqlNodeTables->node.tables.Next;
				}

			}

            /* Error if not tables match */
            if (idxTables == NO_SQLNODE) {
                 s_lstrcpy(lpstmt->szError, lpValuesAlias);
                 return ERR_TABLENOTFOUND;
            }

            /* Remove the <table>.* node */
            if (idxValuesPrev == NO_SQLNODE)
                lpSqlNode->node.select.Values = idxValues;
            else {
                lpSqlNodeValuesPrev = ToNode(*lplpSql, idxValuesPrev);
                lpSqlNodeValuesPrev->node.values.Next = idxValues;
            }

            /* Loop through all the columns of the table */
            lpTableHandle = lpSqlNodeTable->node.table.Handle;

			ClassColumnInfoBase* cInfoBase = lpTableHandle->pColumnInfo;

			LPISAM myISAM = lpTableHandle->lpISAM;

			if ( !cInfoBase->IsValid() )
			{
				return ERR_COLUMNNOTFOUND;
			}

			//Store able alias before allocating memory
			//in order to avoid bug
			STRINGIDX idxTheAlias = lpSqlNodeTable->node.table.Alias;
			STRINGIDX idxTheQual = lpSqlNodeTable->node.table.Qualifier;


			UWORD cNumberOfCols = cInfoBase->GetNumberOfColumns();

			char pColumnName [MAX_COLUMN_NAME_LENGTH+1];

			//Sai added - fetch the  column alias 
			//only filled in if using passthrough SQL, ignored otherwise
			char pAliasName [MAX_COLUMN_NAME_LENGTH+1];
			pAliasName[0] = 0;

            for (idx = 0; idx < (SWORD) cNumberOfCols; idx++) {


				if ( FAILED(cInfoBase->GetColumnName(idx, pColumnName, pAliasName)) )
				{
					return ERR_COLUMNNOTFOUND;
				}

				//Ignore any OLEMS specific columns which we want to hide
				if (myISAM && !(myISAM->fSysProps))
				{
					if (_strnicmp("__", pColumnName, 2) == 0)
					{
						continue;
					}
				}

				//Ignore any 'lazy' columns
				BOOL fIsLazy = FALSE;
				if ( cInfoBase->IsLazy(idx, fIsLazy) )
				{
					if (fIsLazy)
					{
						continue;
					}
				}

				//Check if this column type is support
				//if not we skip this column
				if (! ISAMGetColumnType(lpTableHandle, (UWORD) idx) )
				{
					continue;
				}

                /* Create a node for this column */
                idxColumn = AllocateNode(lplpSql, NODE_TYPE_COLUMN);

                if (idxColumn == NO_SQLNODE)
                    return ERR_MEMALLOCFAIL;

				//Get new pointers
                lpSqlNodeColumn = ToNode(*lplpSql, idxColumn);
				lpSqlNodeTable = ToNode(*lplpSql, idxTable);

                lpSqlNodeColumn->node.column.Tablealias = idxAlias;
                lpSqlNodeColumn->node.column.Column = AllocateString(lplpSql,
                            (LPUSTR)pColumnName);
                if (lpSqlNodeColumn->node.column.Column == NO_STRING)
                    return ERR_MEMALLOCFAIL;

				if (lpSqlNodeTable->node.table.Alias != NO_STRING)
				{
					lpSqlNodeColumn->node.column.MatchedAlias = TRUE;
				}
				else
				{
					lpSqlNodeColumn->node.column.MatchedAlias = FALSE;
				}


				//New - for identical column names when using passthrough SQL
				if ( pAliasName && lstrlen(pAliasName) )
				{
					lpSqlNodeColumn->node.column.Tablealias = AllocateString(lplpSql,
							(LPUSTR)pAliasName); 
				}

				//To avoid bug recalc lpSqlNodeColumn
				lpSqlNodeColumn = ToNode(*lplpSql, idxColumn);


				lpSqlNodeColumn->node.column.TableIndex = idxTable;
				lpSqlNodeColumn->node.column.Qualifier = NO_STRING; //idxTheQual;
				lpSqlNodeColumn->node.table.Handle = NULL;

                lpSqlNodeColumn->node.column.Table = NO_SQLNODE;
                lpSqlNodeColumn->node.column.Id = -1;
                lpSqlNodeColumn->node.column.Value = NO_STRING;
                lpSqlNodeColumn->node.column.InSortRecord = FALSE;
                lpSqlNodeColumn->node.column.Offset = 0;
                lpSqlNodeColumn->node.column.Length = 0;
                lpSqlNodeColumn->node.column.DistinctOffset = 0;
                lpSqlNodeColumn->node.column.DistinctLength = 0;
                lpSqlNodeColumn->node.column.EnclosingStatement = NO_SQLNODE;

                /* Put it on the list */
                idxValuesNew = AllocateNode(lplpSql, NODE_TYPE_VALUES);
                if (idxValuesNew == NO_SQLNODE)
                    return ERR_MEMALLOCFAIL;

                lpSqlNodeValues = ToNode(*lplpSql, idxValuesNew);
                lpSqlNodeValues->node.values.Value = idxColumn;
                lpSqlNodeValues->node.values.Alias = NO_STRING;
                lpSqlNodeValues->node.values.Next = idxValues;

                if (idxValuesPrev == NO_SQLNODE) {
                    lpSqlNode = ToNode(*lplpSql, idxNode);
                    lpSqlNode->node.select.Values = idxValuesNew;
                }
                else {
                    lpSqlNodeValuesPrev = ToNode(*lplpSql, idxValuesPrev);
                    lpSqlNodeValuesPrev->node.values.Next = idxValuesNew;
                }
                idxValuesPrev = idxValuesNew;
            }
        }
        lpSqlNode = ToNode(*lplpSql, idxNode);
    }

    /* Check the ORDER BY columns */
    err = SemanticCheck(lpstmt, lplpSql,lpSqlNode->node.select.Sortcolumns,
                         fIsGroupby, fCaseSensitive, NO_SQLNODE, idxNode);
    if (err != ERR_SUCCESS)
        return err;

    /* Check that each group by column is on sort list (and put it   */
    /* there if it is not already there so the sort directive will */
    /* be constructed correctly)... */
    {
        SQLNODEIDX idxGroupbycolumns;
        LPSQLNODE  lpSqlNodeGroupbycolumns;
        LPSQLNODE  lpSqlNodeColumnGroupby;
        SQLNODEIDX idxSortcolumns;
        SQLNODEIDX idxSortcolumnsPrev;
        LPSQLNODE  lpSqlNodeSortcolumns;
        LPSQLNODE  lpSqlNodeColumnSort;
        SQLNODEIDX idxColumn;
        SQLNODEIDX idxTableGroupby;
//        LPUSTR     lpszTableGroupby;
        LPUSTR      lpszColumnGroupby;
        SQLNODEIDX idxTableSort;
//        LPUSTR     lpszTableSort;
        LPUSTR      lpszColumnSort;

        idxGroupbycolumns = lpSqlNode->node.select.Groupbycolumns;
        while (idxGroupbycolumns != NO_SQLNODE) {

            /* Get this group by column */
            lpSqlNodeGroupbycolumns = ToNode(*lplpSql, idxGroupbycolumns);
            lpSqlNodeColumnGroupby = ToNode(*lplpSql,
                        lpSqlNodeGroupbycolumns->node.groupbycolumns.Column);

            /* Get column name and table name of the group by column */
            idxTableGroupby =  lpSqlNodeColumnGroupby->node.column.TableIndex;
            lpszColumnGroupby = ToString(*lplpSql,
                             lpSqlNodeColumnGroupby->node.column.Column);

            /* Look for this column on the sort list.  For each */
            /* column in the sort list... */
            idxSortcolumns = lpSqlNode->node.select.Sortcolumns;
            idxSortcolumnsPrev = NO_SQLNODE;
            while (idxSortcolumns != NO_SQLNODE) {

                /* Get next element on the sort list */
                lpSqlNodeSortcolumns = ToNode(*lplpSql, idxSortcolumns);
                lpSqlNodeColumnSort = ToNode(*lplpSql,
                             lpSqlNodeSortcolumns->node.sortcolumns.Column);

                /* Is it a column reference? */
                if (lpSqlNodeColumnSort->sqlNodeType == NODE_TYPE_COLUMN) {

                    /* Yes.  Get column name and table name of sort column */
                    idxTableSort = lpSqlNodeColumnSort->node.column.TableIndex;
                    lpszColumnSort = ToString(*lplpSql,
                             lpSqlNodeColumnSort->node.column.Column);

                    /* Leave if this sort column is the group by column */
					if (idxTableSort == idxTableGroupby)
					{
						if (fCaseSensitive) {
//							if (!s_lstrcmp(lpszTableSort, lpszTableGroupby) &&
//                          				!s_lstrcmp(lpszColumnSort, lpszColumnGroupby))
							if ( !s_lstrcmp(lpszColumnSort, lpszColumnGroupby) )
								break;
						}
						else {
//                        				if (!s_lstrcmpi(lpszTableSort, lpszTableGroupby) &&
//                            					!s_lstrcmpi(lpszColumnSort, lpszColumnGroupby))
							if ( !s_lstrcmpi(lpszColumnSort, lpszColumnGroupby) )
								break;
						}
					}
                }

                /* Get next sort column */
                idxSortcolumnsPrev = idxSortcolumns;
                idxSortcolumns = lpSqlNodeSortcolumns->node.sortcolumns.Next;
            }

            /* Was group by columnn found in the sort list? */
            if (idxSortcolumns == NO_SQLNODE) {

                /* No.  A new entry will be needed.  Create a node for */ 
                /* the column */
                idxColumn = AllocateNode(lplpSql, NODE_TYPE_COLUMN);
                if (idxColumn == NO_SQLNODE)
                    return ERR_MEMALLOCFAIL;
                lpSqlNodeColumnSort = ToNode(*lplpSql, idxColumn);

                /* Recalculate these pointers since the Alloc above */
                /* may have moved them */
				/* addeed th enext line */
				lpSqlNodeGroupbycolumns = ToNode (*lplpSql, idxGroupbycolumns);
                lpSqlNodeColumnGroupby = ToNode(*lplpSql,
                            lpSqlNodeGroupbycolumns->node.groupbycolumns.Column);

                /* Fill in the node */
                lpSqlNodeColumnSort->node.column.Tablealias =
                                lpSqlNodeColumnGroupby->node.column.Tablealias;
                lpSqlNodeColumnSort->node.column.Column =
                                lpSqlNodeColumnGroupby->node.column.Column;
                lpSqlNodeColumnSort->node.column.Qualifier =
                                lpSqlNodeColumnGroupby->node.column.Qualifier;
                lpSqlNodeColumnSort->node.column.TableIndex =
                                lpSqlNodeColumnGroupby->node.column.TableIndex;
                lpSqlNodeColumnSort->node.column.MatchedAlias =
                                lpSqlNodeColumnGroupby->node.column.MatchedAlias;

                lpSqlNodeColumnSort->node.column.Table = NO_SQLNODE;
                lpSqlNodeColumnSort->node.column.Id = -1;
                lpSqlNodeColumnSort->node.column.Value = NO_STRING;
                lpSqlNodeColumnSort->node.column.InSortRecord = FALSE;
                lpSqlNodeColumnSort->node.column.Offset = 0;
                lpSqlNodeColumnSort->node.column.Length = 0;
                lpSqlNodeColumnSort->node.column.DistinctOffset = 0;
                lpSqlNodeColumnSort->node.column.DistinctLength = 0;
                lpSqlNodeColumnSort->node.column.EnclosingStatement = NO_SQLNODE;

                /* Create sort list element */
                idxSortcolumns = AllocateNode(lplpSql,
                                                   NODE_TYPE_SORTCOLUMNS);
                if (idxSortcolumns == NO_SQLNODE)
                    return ERR_MEMALLOCFAIL;
                lpSqlNodeSortcolumns = ToNode(*lplpSql, idxSortcolumns);
                lpSqlNodeSortcolumns->node.sortcolumns.Column = idxColumn;
                lpSqlNodeSortcolumns->node.sortcolumns.Descending = FALSE;
                lpSqlNodeSortcolumns->node.sortcolumns.Next = NO_SQLNODE;

                /* Recalculate these pointers since the Alloc above */
                /* may have moved them */
                lpSqlNodeGroupbycolumns =
                                        ToNode(*lplpSql, idxGroupbycolumns);
                lpSqlNode = ToNode(*lplpSql, idxNode);

                /* Put it on the sort list */
                if (idxSortcolumnsPrev == NO_SQLNODE)
                    lpSqlNode->node.select.Sortcolumns = idxSortcolumns;
                else {
                    lpSqlNodeSortcolumns =
                                     ToNode(*lplpSql, idxSortcolumnsPrev);
                    lpSqlNodeSortcolumns->node.sortcolumns.Next =
                                                     idxSortcolumns;
                }

                /* Semantic check the newly created nodes */
                  err = SemanticCheck(lpstmt, lplpSql, idxSortcolumns,
                         fIsGroupby, fCaseSensitive, NO_SQLNODE, idxNode);
            }

            /* Look at next group by column */
            idxGroupbycolumns =
                        lpSqlNodeGroupbycolumns->node.groupbycolumns.Next;
        }
    }

    /* Check the select list */
      err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.select.Values,
                       fIsGroupby, fCaseSensitive, NO_SQLNODE, idxNode);
    if (err != ERR_SUCCESS)
        return err;

    /* Check the WHERE clause */
    err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.select.Predicate,
                            FALSE, fCaseSensitive, NO_SQLNODE, idxNode);
    if (err != ERR_SUCCESS)
        return err;

    /* Check the HAVING clause */
    err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.select.Having,
                         fIsGroupby, fCaseSensitive, NO_SQLNODE, idxNode);
    if (err != ERR_SUCCESS)
        return err;

    /* Build the sorting directive and determine the overall key size. */
    /* At the same time check to make sure that there are not too many */
    /* columns in ORDER BY and that character or binary keys are not   */
    /* too big.                                                        */
    if (lpSqlNode->node.select.Sortcolumns != NO_SQLNODE) {

        SQLNODEIDX idxSortcolumns;
        LPSQLNODE  lpSqlNodeSortcolumns;
        LPSQLNODE  lpSqlNodeColumn;
        UDWORD length;
        SQLNODEIDX idxTables;
        LPSQLNODE  lpSqlNodeTables;
#define NUM_LEN 5
        UCHAR      szSortDirective[10 + NUM_LEN +
                            (MAX_COLUMNS_IN_ORDER_BY * (6 + (2 * NUM_LEN)))
                            + 3 + MAX_PATHNAME_SIZE];
		szSortDirective[0] = 0;
        SQLNODEIDX idxAggregate;
        LPSQLNODE  lpSqlNodeAggregate;

        /* For each sort column... */
        s_lstrcpy(szSortDirective, "S(");
        idxSortcolumns = lpSqlNode->node.select.Sortcolumns;
        while (idxSortcolumns != NO_SQLNODE) {

            /* Is this node on the group by list ? */
            lpSqlNodeSortcolumns = ToNode(*lplpSql, idxSortcolumns);
            lpSqlNodeColumn = ToNode(*lplpSql,
                             lpSqlNodeSortcolumns->node.sortcolumns.Column);
            if ((lpSqlNode->node.select.Groupbycolumns == NO_SQLNODE) || 
                (lpSqlNodeColumn->sqlNodeType != NODE_TYPE_COLUMN)) {

                /* No.  Add this sort column to the count */
                count++;

                /* Error if too many sort columns */
                if (count > MAX_COLUMNS_IN_ORDER_BY)
                    return ERR_ORDERBYTOOLARGE;

                /* Get length of the column. */
                switch (lpSqlNodeColumn->sqlDataType) {
                case TYPE_DOUBLE:
                    length = sizeof(double);
                    break;

                case TYPE_NUMERIC:
                    length = 2 + lpSqlNodeColumn->sqlPrecision;
                    break;

                case TYPE_INTEGER:
                    length = sizeof(double);
                    break;

                case TYPE_CHAR:
                    length = lpSqlNodeColumn->sqlPrecision;
                    if (length > MAX_CHAR_LITERAL_LENGTH) {
                        if (lpSqlNodeColumn->sqlNodeType == NODE_TYPE_COLUMN)
                            s_lstrcpy(lpstmt->szError,
                          ToString(*lplpSql, lpSqlNodeColumn->node.column.Column));
                        else
                            s_lstrcpy(lpstmt->szError, "<expression>");
                        return ERR_CANTORDERBYONTHIS;
                    }
                    break;

                case TYPE_BINARY:
                    length = lpSqlNodeColumn->sqlPrecision;
                    if (length > MAX_BINARY_LITERAL_LENGTH) {
                        if (lpSqlNodeColumn->sqlNodeType == NODE_TYPE_COLUMN)
                            s_lstrcpy((char*)lpstmt->szError,
                          ToString(*lplpSql, lpSqlNodeColumn->node.column.Column));
                        else
                            s_lstrcpy(lpstmt->szError, "<expression>");
                        return ERR_CANTORDERBYONTHIS;
                    }
                    break;

                case TYPE_DATE:
                    length = 10;
                    break;

                case TYPE_TIME:
                    length = 8;
                    break;

                case TYPE_TIMESTAMP:
                    if (TIMESTAMP_SCALE > 0)
                        length = 20 + TIMESTAMP_SCALE;
                    else
                        length = 19;
                    break;

                default:
                    if (lpSqlNodeColumn->sqlNodeType == NODE_TYPE_COLUMN)
                        s_lstrcpy(lpstmt->szError,
                          ToString(*lplpSql, lpSqlNodeColumn->node.column.Column));
                    else
                        s_lstrcpy((char*)lpstmt->szError, "<expression>");
                    return ERR_CANTORDERBYONTHIS;
                }

                /* Put offset of the key column in the sort directive */
                wsprintf((LPSTR) (szSortDirective + s_lstrlen((LPSTR)szSortDirective)),
                             "%lu,", offset);

                /* Adjust offset */
                offset += (length);
                offset++;    /* for the IS NULL flag */
            }
            else {
                /* Yes.  Get length */
                length = lpSqlNodeColumn->node.column.Length;

                /* Put offset of the key column in the sort directive */
                wsprintf((LPSTR)(szSortDirective + s_lstrlen((LPSTR)szSortDirective)),
                             "%lu,", lpSqlNodeColumn->node.column.Offset);
            }

            /* Put length of the key column in the sort directive */
            wsprintf((LPSTR)(szSortDirective + s_lstrlen((LPSTR)szSortDirective)),
                             "%lu,", length);

            /* Put type of the key column in the sort directive */
            switch (lpSqlNodeColumn->sqlDataType) {
            case TYPE_DOUBLE:
                s_lstrcat((LPSTR)szSortDirective, "E,");
                break;

            case TYPE_NUMERIC:
                s_lstrcat((LPSTR)szSortDirective, "N,");
                break;

            case TYPE_INTEGER:
                s_lstrcat((LPSTR)szSortDirective, "E,");
                break;

            case TYPE_CHAR:
            case TYPE_BINARY:
            case TYPE_DATE:
            case TYPE_TIME:
            case TYPE_TIMESTAMP:
                s_lstrcat((LPSTR)szSortDirective, "C,");
                break;

            default:
                return ERR_INTERNAL;
            }

            /* Put direction of the key column in the sort directive */
            if (lpSqlNodeSortcolumns->node.sortcolumns.Descending)
                s_lstrcat((char*)szSortDirective, "D");
            else
                s_lstrcat((char*)szSortDirective, "A");

            /* Go to next sort column */
            idxSortcolumns = lpSqlNodeSortcolumns->node.sortcolumns.Next;
            if (idxSortcolumns != NO_SQLNODE)
                s_lstrcat((char*)szSortDirective, ",");
        }

        /* Save the sort key size */
        lpSqlNode->node.select.SortKeysize = offset-1;

        /* Is there a GROUP BY statement? */
        if ((lpSqlNode->node.select.Groupbycolumns == NO_SQLNODE) &&
            (!lpSqlNode->node.select.ImplicitGroupby)) {

            /* No. Save offset of the bookmark */
            lpSqlNode->node.select.SortBookmarks = offset;

            /* For each table in table list, add bookmark size to offset */
            idxTables = lpSqlNode->node.select.Tables;
            while (idxTables != NO_SQLNODE) {

                /* Update offset */
                offset += (sizeof(ISAMBOOKMARK));

                /* Get pointer to the next table */
                lpSqlNodeTables = ToNode(*lplpSql, idxTables);
                idxTables = lpSqlNodeTables->node.tables.Next;
            }
        }
        else {

            /* Yes.  Calculate the offset of each aggregate field */
            idxAggregate = lpSqlNode->node.select.Aggregates;
            while (idxAggregate != NO_SQLNODE) {

                /* Save offset of the aggregate */
                lpSqlNodeAggregate = ToNode(*lplpSql, idxAggregate);
                lpSqlNodeAggregate->node.aggregate.Offset = offset;

                /* Update offset */
                offset += (lpSqlNodeAggregate->node.aggregate.Length + 1);

                /* Get pointer to the next aggregate */
                idxAggregate = lpSqlNodeAggregate->node.aggregate.Next;
            }
        }
        offset--;
        s_lstrcat((char*)szSortDirective, ")");

        /* Put record size into sort directive */
        s_lstrcat((char*)szSortDirective, "F(FIX,");
        wsprintf((LPSTR)(szSortDirective + s_lstrlen((char*)szSortDirective)),
                             "%lu", offset);
        lstrcat((char*)szSortDirective, ")");

        /* Put in work drive */    
        s_lstrcat(szSortDirective, "W(");
#ifdef WIN32
        if (!GetTempPath(MAX_PATHNAME_SIZE+1, (LPSTR)
                         szSortDirective + s_lstrlen(szSortDirective)))
            return ERR_SORT;
        if (szSortDirective[s_lstrlen(szSortDirective)-1] != '\\')
            s_lstrcat(szSortDirective, "\\");
#else
        GetTempFileName(NULL, "LEM", 0, (LPSTR) szSortDirective +
                                                s_lstrlen(szSortDirective));
        while (szSortDirective[s_lstrlen(szSortDirective)-1] != '\\')
            szSortDirective[s_lstrlen(szSortDirective)-1] = '\0';
#endif
        s_lstrcat(szSortDirective, ")");

        /* Save the directive */
        lpSqlNode->node.select.SortDirective = AllocateString(lplpSql,
                                                (LPUSTR)szSortDirective);
        if (lpSqlNode->node.select.SortDirective == NO_STRING)
            return ERR_MEMALLOCFAIL;

        /* Save the sort record size */
        lpSqlNode->node.select.SortRecordsize = offset;
    }

    /* If there is no group by list originally but there is a group by */
    /* list now, there was an aggregate in the select list.  Calculate */
    /* the offset of each aggregate field */
    if (lpSqlNode->node.select.ImplicitGroupby) {

        SQLNODEIDX idxAggregate;
        LPSQLNODE  lpSqlNodeAggregate;

        idxAggregate = lpSqlNode->node.select.Aggregates;
        while (idxAggregate != NO_SQLNODE) {

            /* Save offset of the aggregate */
            lpSqlNodeAggregate = ToNode(*lplpSql, idxAggregate);
            lpSqlNodeAggregate->node.aggregate.Offset = offset;

            /* Update offset */
            offset += (lpSqlNodeAggregate->node.aggregate.Length + 1);

            /* Get pointer to the next aggregate */
            idxAggregate = lpSqlNodeAggregate->node.aggregate.Next;
        }
        
        /* Adjust the offset */
        offset--;

        /* Save the sort record size */
        lpSqlNode->node.select.SortRecordsize = offset;
    }

    /* Build the sorting directive for SELECT DISTINCT and determine the */
    /* overall key size.  At the same time check to make sure that there */
    /* are not too many columns in ORDER BY and that character or binary */
    /* keys are not too big.                                             */
    if (lpSqlNode->node.select.Distinct) {

        SQLNODEIDX idxValues;
        LPSQLNODE  lpSqlNodeValues;
        LPSQLNODE  lpSqlNodeExpression;
        UDWORD     length;
#define NUM_LEN 5
        UCHAR      szSortDirective[19 + (4 * NUM_LEN) +
                            (MAX_COLUMNS_IN_ORDER_BY * (6 + (2 * NUM_LEN)))
                            + 3 + MAX_PATHNAME_SIZE];

        /* For each sort column... */
        count = 0;
        offset = NUM_LEN + 1;
        s_lstrcpy(szSortDirective, "S(");
        idxValues = lpSqlNode->node.select.Values;
        while (idxValues != NO_SQLNODE) {

            /* Is this node of interest? */
            lpSqlNodeValues = ToNode(*lplpSql, idxValues);
            lpSqlNodeExpression = ToNode(*lplpSql,
                             lpSqlNodeValues->node.values.Value);
            switch (lpSqlNodeExpression->sqlNodeType) {
            case NODE_TYPE_COLUMN:
            case NODE_TYPE_AGGREGATE:
            case NODE_TYPE_ALGEBRAIC:
            case NODE_TYPE_SCALAR:

                /* Yes.  Add this sort column to the count */
                count++;

                /* Error if too many sort columns */
                if (count > MAX_COLUMNS_IN_ORDER_BY)
                    return ERR_ORDERBYTOOLARGE;

                /* Get length of the column. */
                switch (lpSqlNodeExpression->sqlDataType) {
                case TYPE_DOUBLE:
                    length = sizeof(double);
                    break;

                case TYPE_NUMERIC:
                    length = 2 + lpSqlNodeExpression->sqlPrecision;
                    break;

                case TYPE_INTEGER:
                    length = sizeof(double);
                    break;

                case TYPE_CHAR:
                    length = lpSqlNodeExpression->sqlPrecision;
                    if (length > MAX_CHAR_LITERAL_LENGTH) {
                        if (lpSqlNodeExpression->sqlNodeType == NODE_TYPE_COLUMN)
                            s_lstrcpy((char*)lpstmt->szError,
                          ToString(*lplpSql, lpSqlNodeExpression->node.column.Column));
                        else
                            s_lstrcpy((char*)lpstmt->szError, "<expression>");
                        return ERR_CANTORDERBYONTHIS;
                    }
                    break;

                case TYPE_BINARY:
                    length = lpSqlNodeExpression->sqlPrecision;
                    if (length > MAX_BINARY_LITERAL_LENGTH) {
                        if (lpSqlNodeExpression->sqlNodeType == NODE_TYPE_COLUMN)
                            s_lstrcpy((char*)lpstmt->szError,
                          ToString(*lplpSql, lpSqlNodeExpression->node.column.Column));
                        else
                            s_lstrcpy((char*)lpstmt->szError, "<expression>");
                        return ERR_CANTORDERBYONTHIS;
                    }
                    break;

                case TYPE_DATE:
                    length = 10;
                    break;

                case TYPE_TIME:
                    length = 8;
                    break;

                case TYPE_TIMESTAMP:
                    if (TIMESTAMP_SCALE > 0)
                        length = 20 + TIMESTAMP_SCALE;
                    else
                        length = 19;
                    break;

                default:
                    if (lpSqlNodeExpression->sqlNodeType == NODE_TYPE_COLUMN)
                        s_lstrcpy((char*)lpstmt->szError,
                          ToString(*lplpSql, lpSqlNodeExpression->node.column.Column));
                    else
                        s_lstrcpy((char*)lpstmt->szError, "<expression>");
                    return ERR_CANTORDERBYONTHIS;
                }

                /* Put offset of the key column in the sort directive */
                wsprintf((LPSTR)(szSortDirective + s_lstrlen((char*)szSortDirective)),
                             "%lu,", offset);

                /* Save offset and length */
                switch (lpSqlNodeExpression->sqlNodeType) {
                case NODE_TYPE_COLUMN:
                    lpSqlNodeExpression->node.column.DistinctOffset = offset;
                    lpSqlNodeExpression->node.column.DistinctLength = length;
                    break;
                case NODE_TYPE_AGGREGATE:
                    lpSqlNodeExpression->node.aggregate.DistinctOffset = offset;
                    lpSqlNodeExpression->node.aggregate.DistinctLength = length;
                    break;
                case NODE_TYPE_ALGEBRAIC:
                    lpSqlNodeExpression->node.algebraic.DistinctOffset = offset;
                    lpSqlNodeExpression->node.algebraic.DistinctLength = length;
                    break;
                case NODE_TYPE_SCALAR:
                    lpSqlNodeExpression->node.scalar.DistinctOffset = offset;
                    lpSqlNodeExpression->node.scalar.DistinctLength = length;
                    break;
                default:
                    return ERR_INTERNAL;
                }

                /* Adjust offset */
                offset += (length);
                offset++;    /* for the IS NULL flag */

                /* Put length of the key column in the sort directive */
                wsprintf((LPSTR)(szSortDirective + s_lstrlen((char*)szSortDirective)),
                             "%lu,", length);

                /* Put type of the key column in the sort directive */
                switch (lpSqlNodeExpression->sqlDataType) {
                case TYPE_DOUBLE:
                    s_lstrcat(szSortDirective, "E,");
                    break;

                case TYPE_NUMERIC:
                    s_lstrcat(szSortDirective, "N,");
                    break;

                case TYPE_INTEGER:
                    s_lstrcat(szSortDirective, "E,");
                    break;

                case TYPE_CHAR:
                case TYPE_BINARY:
                case TYPE_DATE:
                case TYPE_TIME:
                case TYPE_TIMESTAMP:
                    s_lstrcat(szSortDirective, "C,");
                    break;

                default:
                    return ERR_INTERNAL;
                }

                /* Put direction of the key column in the sort directive */
                s_lstrcat(szSortDirective, "A");

                break;

            case NODE_TYPE_STRING:
            case NODE_TYPE_NUMERIC:
            case NODE_TYPE_PARAMETER:
            case NODE_TYPE_USER:
            case NODE_TYPE_NULL:
            case NODE_TYPE_DATE:
            case NODE_TYPE_TIME:
            case NODE_TYPE_TIMESTAMP:
                break;

            case NODE_TYPE_CREATE:
            case NODE_TYPE_DROP:
            case NODE_TYPE_SELECT:
            case NODE_TYPE_INSERT:
            case NODE_TYPE_DELETE:
            case NODE_TYPE_UPDATE:
            case NODE_TYPE_CREATEINDEX:
            case NODE_TYPE_DROPINDEX: 
            case NODE_TYPE_PASSTHROUGH:
            case NODE_TYPE_TABLES:
            case NODE_TYPE_VALUES:
            case NODE_TYPE_COLUMNS:
            case NODE_TYPE_SORTCOLUMNS:
            case NODE_TYPE_GROUPBYCOLUMNS:
            case NODE_TYPE_UPDATEVALUES:
            case NODE_TYPE_CREATECOLS:
            case NODE_TYPE_BOOLEAN:
            case NODE_TYPE_COMPARISON:
            case NODE_TYPE_TABLE:
            default:
                return ERR_INTERNAL;
            }

            /* Go to next sort column */
            idxValues = lpSqlNodeValues->node.values.Next;
            if (idxValues != NO_SQLNODE)
                s_lstrcat(szSortDirective, ",");
        }
        offset--;

        /* If no fields in sort record, put a constant in */
        if (offset == NUM_LEN) {
            offset = 3;
            s_lstrcat(szSortDirective, "1,3,C,A");
        }
        s_lstrcat(szSortDirective, ")");

        /* Put duplicate removal into sort directive */
        s_lstrcat(szSortDirective, "DUPO(B");
        wsprintf((LPSTR) szSortDirective + s_lstrlen(szSortDirective),
                             "%lu", offset);
        s_lstrcat(szSortDirective, ",");
        wsprintf((LPSTR) szSortDirective + s_lstrlen(szSortDirective),
                             "%u", (WORD) NUM_LEN+1);
        s_lstrcat(szSortDirective, ",");
        wsprintf((LPSTR) szSortDirective + s_lstrlen(szSortDirective),
                             "%lu", offset - NUM_LEN);
        s_lstrcat(szSortDirective, ")");

        /* Put record size into sort directive */
        s_lstrcat(szSortDirective, "F(FIX,");
        wsprintf((LPSTR) szSortDirective + s_lstrlen(szSortDirective),
                             "%lu", offset);
        s_lstrcat(szSortDirective, ")");

        /* Put in work drive */    
        s_lstrcat(szSortDirective, "W(");
#ifdef WIN32
        if (!GetTempPath(MAX_PATHNAME_SIZE+1, (LPSTR)
                         szSortDirective + s_lstrlen(szSortDirective)))
            return ERR_SORT;
        if (szSortDirective[s_lstrlen(szSortDirective)-1] != '\\')
            s_lstrcat(szSortDirective, "\\");
#else
        GetTempFileName(NULL, "LEM", 0, (LPSTR) szSortDirective +
                                            + s_lstrlen(szSortDirective));
        while (szSortDirective[s_lstrlen(szSortDirective)-1] != '\\')
            szSortDirective[s_lstrlen(szSortDirective)-1] = '\0';
#endif
        s_lstrcat(szSortDirective, ")");

        /* Save the directive */
        lpSqlNode->node.select.DistinctDirective = AllocateString(lplpSql,
                                                szSortDirective);
        if (lpSqlNode->node.select.DistinctDirective == NO_STRING)
            return ERR_MEMALLOCFAIL;

        /* Save the sort record size */
        lpSqlNode->node.select.DistinctRecordsize = offset;
    }

    /* Allocate space for the sortfile name if need be */
    if ((lpSqlNode->node.select.Distinct) ||
        (lpSqlNode->node.select.ImplicitGroupby) ||
        (lpSqlNode->node.select.Groupbycolumns != NO_SQLNODE) ||
        (lpSqlNode->node.select.Sortcolumns != NO_SQLNODE)) {
        lpSqlNode->node.select.SortfileName = AllocateSpace(lplpSql,
                                          MAX_PATHNAME_SIZE+1);
        if (lpSqlNode->node.select.SortfileName == NO_STRING)
            return ERR_MEMALLOCFAIL;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC SemanticCheck(LPSTMT lpstmt, LPSQLTREE FAR *lplpSql,
       SQLNODEIDX idxNode, BOOL fIsGroupby, BOOL fCaseSensitive,
       SQLNODEIDX idxNodeTableOuterJoinFromTables,
       SQLNODEIDX idxEnclosingStatement)

/* Walks a parse tree, checks it for semantic correctness, and fills in */
/* the semantic information.                                            */

{
    LPSQLNODE lpSqlNode;
    RETCODE err;
    LPUSTR ptr;

    if (idxNode == NO_SQLNODE)
        return ERR_SUCCESS;

    lpSqlNode = ToNode(*lplpSql, idxNode);
    err = ERR_SUCCESS;
    switch (lpSqlNode->sqlNodeType) {
    case NODE_TYPE_NONE:
        break;

    case NODE_TYPE_ROOT:

        /* Check the statement */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.root.sql,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);
        if (err != ERR_SUCCESS)
            return err;
        break;

    case NODE_TYPE_CREATE:

        /* Make sure table name is not too long */
        ptr = ToString(*lplpSql, lpSqlNode->node.create.Table);
        if (s_lstrlen(ptr) > ISAMMaxTableNameLength(lpstmt->lpdbc->lpISAM)) {
            s_lstrcpy(lpstmt->szError, ptr);
            return ERR_INVALIDTABLENAME;
        }

        /* Check the new column definitions */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.create.Columns,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables, idxNode);
        if (err != ERR_SUCCESS)
            return err;
        break;

    case NODE_TYPE_DROP:

        /* Make sure table name is not too long */
        ptr = ToString(*lplpSql, lpSqlNode->node.drop.Table);
        if (s_lstrlen(ptr) > ISAMMaxTableNameLength(lpstmt->lpdbc->lpISAM)) {
            s_lstrcpy(lpstmt->szError, ptr);
            return ERR_INVALIDTABLENAME;
        }
        break;

    case NODE_TYPE_SELECT:
        err = SelectCheck(lpstmt, lplpSql, idxNode, fCaseSensitive,
                          idxEnclosingStatement);
        break;

    case NODE_TYPE_INSERT:
	{
        /* Check the table */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.insert.Table,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables, idxNode);
        if (err != ERR_SUCCESS)
            return err;

        /* Is there a column list? */
        if (lpSqlNode->node.insert.Columns == NO_SQLNODE) {

            LPSQLNODE  lpSqlNodeTable;
            STRINGIDX  idxAlias;
            LPISAMTABLEDEF lpTableHandle;
            SQLNODEIDX idxColumns;
            LPSQLNODE  lpSqlNodeColumns;
            SQLNODEIDX idxColumnsPrev;
            LPSQLNODE  lpSqlNodeColumnsPrev;
            SQLNODEIDX idxColumn;
            LPSQLNODE  lpSqlNodeColumn;
            SWORD      idx;

            /* No.  Get node Alias of this table */
            lpSqlNodeTable = ToNode(*lplpSql, lpSqlNode->node.insert.Table);
            idxAlias = lpSqlNodeTable->node.table.Alias;
                
            /* Loop through all the columns of this table */
            lpTableHandle = lpSqlNodeTable->node.table.Handle;
            idxColumnsPrev = NO_SQLNODE;

			ClassColumnInfoBase* cInfoBase = lpTableHandle->pColumnInfo;

			if ( !cInfoBase->IsValid() )
			{
				return ERR_COLUMNNOTFOUND;
			}

			UWORD cNumberOfCols = cInfoBase->GetNumberOfColumns();

			char pColumnName [MAX_COLUMN_NAME_LENGTH+1];

			for (idx = 0; idx < (SWORD) cNumberOfCols; idx++)
			{
				if ( FAILED(cInfoBase->GetColumnName(idx, pColumnName)) )
				{
					return ERR_COLUMNNOTFOUND;
				}

                /* Create a node for this column */
                idxColumn = AllocateNode(lplpSql, NODE_TYPE_COLUMN);
                if (idxColumn == NO_SQLNODE)
                    return ERR_MEMALLOCFAIL;
                lpSqlNodeColumn = ToNode(*lplpSql, idxColumn);
                lpSqlNodeColumn->node.column.Tablealias = idxAlias;
                lpSqlNodeColumn->node.column.Column = AllocateString(lplpSql,
						(LPUSTR)pColumnName);
                if (lpSqlNodeColumn->node.column.Column == NO_STRING)
                    return ERR_MEMALLOCFAIL;
                lpSqlNodeColumn->node.column.Table =
                                                lpSqlNode->node.insert.Table;
                lpSqlNodeColumn->node.column.Id = idx;
                lpSqlNodeColumn->node.column.Value = NO_STRING;
                lpSqlNodeColumn->node.column.InSortRecord = FALSE;
                lpSqlNodeColumn->node.column.Offset = 0;
                lpSqlNodeColumn->node.column.Length = 0;
                lpSqlNodeColumn->node.column.DistinctOffset = 0;
                lpSqlNodeColumn->node.column.DistinctLength = 0;
                lpSqlNodeColumn->node.column.EnclosingStatement = NO_SQLNODE;


                /* Put it on the list */
                idxColumns = AllocateNode(lplpSql, NODE_TYPE_COLUMNS);
                if (idxColumns == NO_SQLNODE)
                    return ERR_MEMALLOCFAIL;
                lpSqlNodeColumns = ToNode(*lplpSql, idxColumns);
                lpSqlNodeColumns->node.columns.Column = idxColumn;
                lpSqlNodeColumns->node.columns.Next = NO_SQLNODE;

                if (idxColumnsPrev == NO_SQLNODE) {
                    lpSqlNode = ToNode(*lplpSql, idxNode);
                    lpSqlNode->node.insert.Columns = idxColumns;
                }
                else {
                    lpSqlNodeColumnsPrev = ToNode(*lplpSql, idxColumnsPrev);
                    lpSqlNodeColumnsPrev->node.columns.Next = idxColumns;
                }
                idxColumnsPrev = idxColumns;
                lpSqlNode = ToNode(*lplpSql, idxNode);
            }
            lpSqlNode = ToNode(*lplpSql, idxNode);
        }

        /* Check the column list */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.insert.Columns,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables, idxNode);
        if (err != ERR_SUCCESS)
            return err;

        /* Check the value list */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.insert.Values,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables, idxNode);
        if (err != ERR_SUCCESS)
            return err;

        /* Look at each value */
        {
            SQLNODEIDX idxValues;
            LPSQLNODE  lpSqlNodeValues;
            LPSQLNODE  lpSqlNodeValue;
            SQLNODEIDX idxColumns;
            LPSQLNODE  lpSqlNodeColumns;
            LPSQLNODE  lpSqlNodeSelect;

            /* Get list of insert values */
            lpSqlNodeSelect = ToNode(*lplpSql, lpSqlNode->node.insert.Values);
            if (lpSqlNodeSelect->sqlNodeType == NODE_TYPE_SELECT)
                idxValues = lpSqlNodeSelect->node.select.Values;
            else
                idxValues = lpSqlNode->node.insert.Values;

            /* For each value... */
            idxColumns = lpSqlNode->node.insert.Columns;
            while (idxValues != NO_SQLNODE) {

                /* Error if no more columns */
                if (idxColumns == NO_SQLNODE)
                    return ERR_UNEQUALINSCOLS;

                /* Get the value */
                lpSqlNodeValues = ToNode(*lplpSql, idxValues);
                lpSqlNodeValue = ToNode(*lplpSql, lpSqlNodeValues->node.values.Value);

                /* Get the column the value is for */
                lpSqlNodeColumns = ToNode(*lplpSql, idxColumns);

                /* Sub-select? */
                if (lpSqlNodeSelect->sqlNodeType != NODE_TYPE_SELECT) {

                    /* No.  Make sure the value is NUMERIC, STRING,    */
                    /* PARAMETER, USER, NULL, DATE, TIME, or TIMESTAMP */
                switch (lpSqlNodeValue->sqlNodeType) {

                case NODE_TYPE_ALGEBRAIC:
                case NODE_TYPE_SCALAR:
                case NODE_TYPE_AGGREGATE:
				case NODE_TYPE_COLUMN:
                    return ERR_INVALIDINSVAL;

                case NODE_TYPE_PARAMETER:
                case NODE_TYPE_NULL:
                case NODE_TYPE_NUMERIC:
                case NODE_TYPE_STRING:
                case NODE_TYPE_USER:
                case NODE_TYPE_DATE:
                case NODE_TYPE_TIME:
                case NODE_TYPE_TIMESTAMP:
                    break;

                default:
                    return ERR_INTERNAL;
                }
			}

                /* Make sure value is of the proper type */
                err = TypeCheck(lpstmt, *lplpSql,
                               lpSqlNodeColumns->node.columns.Column,
                               lpSqlNodeValues->node.values.Value, OP_NONE,
                               NULL, NULL, NULL, NULL);
                if (err != ERR_SUCCESS)
                    return err;

                /* Look at next element */
                idxValues = lpSqlNodeValues->node.values.Next;
                idxColumns = lpSqlNodeColumns->node.columns.Next;
            }

            /* Error if extra columns */
            if (idxColumns != NO_SQLNODE)
                return ERR_UNEQUALINSCOLS;
        }
	}
        break;
    case NODE_TYPE_DELETE:

        /* Check the table */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.delet.Table,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables, idxNode);
        if (err != ERR_SUCCESS)
            return err;

        /* Check the predicate */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.delet.Predicate,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables, idxNode);
        if (err != ERR_SUCCESS)
            return err;

        break;

    case NODE_TYPE_UPDATE:

        /* Check the table */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.update.Table,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables, idxNode);
        if (err != ERR_SUCCESS)
            return err;

        /* Check the update values */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.update.Updatevalues,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables, idxNode);
        if (err != ERR_SUCCESS)
            return err;

        /* Check the predicate */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.update.Predicate,
                            fIsGroupby, fCaseSensitive,
							idxNodeTableOuterJoinFromTables, idxNode);
        if (err != ERR_SUCCESS)
            return err;

        break;

    case NODE_TYPE_CREATEINDEX:

        {
            SQLNODEIDX idxSortcolumns;
            LPSQLNODE  lpSqlNodeSortcolumns;
            UWORD       count;
            
            /* Make sure index name is not too long */
            ptr = ToString(*lplpSql, lpSqlNode->node.createindex.Index);
            if (s_lstrlen(ptr) > MAX_INDEX_NAME_LENGTH) {
                s_lstrcpy(lpstmt->szError, ptr);
                return ERR_INVALIDINDEXNAME;
            }

            /* Check the table */
            err = SemanticCheck(lpstmt, lplpSql,
                            lpSqlNode->node.createindex.Table,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables, idxNode);
            if (err != ERR_SUCCESS)
                return err;

            /* Check the list of columns */
            err = SemanticCheck(lpstmt, lplpSql,
                            lpSqlNode->node.createindex.Columns,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables, idxNode);
            if (err != ERR_SUCCESS)
                return err;

            /* Make sure there aren't too many columns */
            idxSortcolumns = lpSqlNode->node.createindex.Columns;
            count = 0;
            while (idxSortcolumns != NO_SQLNODE) {
                lpSqlNodeSortcolumns =
                                   ToNode(lpstmt->lpSqlStmt, idxSortcolumns);
                count++;
                idxSortcolumns = lpSqlNodeSortcolumns->node.sortcolumns.Next;
            }
            if (count > MAX_COLUMNS_IN_INDEX) {
                return ERR_TOOMANYINDEXCOLS;
            }
         }
        break;

    case NODE_TYPE_DROPINDEX:
        /* Make sure index name is not too long */
        ptr = ToString(*lplpSql, lpSqlNode->node.dropindex.Index);
        if (s_lstrlen(ptr) > MAX_INDEX_NAME_LENGTH) {
            s_lstrcpy(lpstmt->szError, ptr);
            return ERR_INVALIDINDEXNAME;
        }

        break;

    case NODE_TYPE_PASSTHROUGH:
        s_lstrcpy((LPSTR)lpstmt->szError, "CREATE, DROP, SELECT, INSERT, UPDATE, or DELETE");
        return ERR_EXPECTEDOTHER;

    case NODE_TYPE_TABLES:

        /* Check the table */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.tables.Table,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);
        if (err != ERR_SUCCESS)
            return err;

        /* Check the rest of the list */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.tables.Next,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);
        if (err != ERR_SUCCESS)
            return err;

        /* Error if any correlation name reused */
        {
            LPUSTR      lpstrAlias;
            SQLNODEIDX idxTables;
            LPSQLNODE  lpSqlNodeTables;
            LPSQLNODE  lpSqlNodeTable;

            /* Get the alias for this table */
            lpSqlNodeTable = ToNode(*lplpSql, lpSqlNode->node.tables.Table);

			if (lpSqlNodeTable->node.table.Alias	!= NO_STRING)
			{
				lpstrAlias = ToString(*lplpSql, lpSqlNodeTable->node.table.Alias);


				/* For each table on the rest of the list */
				idxTables = lpSqlNode->node.tables.Next;
				while (idxTables != NO_SQLNODE) {

					/* Get pointer to table node */
					lpSqlNodeTables = ToNode(*lplpSql, idxTables);
					lpSqlNodeTable = ToNode(*lplpSql, lpSqlNodeTables->node.tables.Table);

					/* Error if its name is the same */
					if (lpSqlNodeTable->node.table.Alias	!= NO_STRING)
					{
						if (fCaseSensitive) {
							if (!s_lstrcmp(lpstrAlias,
								  ToString(*lplpSql, lpSqlNodeTable->node.table.Alias))) {
								s_lstrcpy((char*)lpstmt->szError, lpstrAlias);
								return ERR_ALIASINUSE;
							}
						}
						else {
							if (!s_lstrcmpi(lpstrAlias,
								  ToString(*lplpSql, lpSqlNodeTable->node.table.Alias))) {
								s_lstrcpy((char*)lpstmt->szError, lpstrAlias);
								return ERR_ALIASINUSE;
							}
						}
					}

                /* Go to next element */
					idxTables = lpSqlNodeTables->node.tables.Next;
				}
			}
        
	{
            LPSQLNODE  lpSqlNodeTable;

            /* Check the outer join predicate (if any) */
            lpSqlNodeTable = ToNode(*lplpSql, lpSqlNode->node.tables.Table);
            err = SemanticCheck(lpstmt, lplpSql,
                            lpSqlNodeTable->node.table.OuterJoinPredicate,
                            FALSE, fCaseSensitive,
                            lpSqlNodeTable->node.table.OuterJoinFromTables,
                            idxEnclosingStatement);
            if (err != ERR_SUCCESS)
                return err;
        }

        }
        break;

    case NODE_TYPE_VALUES:

        while (TRUE) {

            /* Check this value */
            err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.values.Value,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);

        if (err != ERR_SUCCESS)
            return err;

        /* Check the rest of the list */
            if (lpSqlNode->node.values.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(*lplpSql, lpSqlNode->node.values.Next);
        }
        break;

    case NODE_TYPE_COLUMNS:

        while (TRUE) {

            /* Check this column */
            err = SemanticCheck(lpstmt, lplpSql,
                            lpSqlNode->node.columns.Column,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);
        if (err != ERR_SUCCESS)
            return err;

        /* Check the rest of the list */
        if (lpSqlNode->node.columns.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(*lplpSql, lpSqlNode->node.columns.Next);
        }
        lpSqlNode = ToNode(*lplpSql, idxNode);

        /* Error if any column on list more than once */
        {
            LPUSTR      lpstrName;
            SQLNODEIDX idxColumns;
            LPSQLNODE  lpSqlNodeColumns;
            LPSQLNODE  lpSqlNodeColumn;

            /* Get the name for this column */
            lpSqlNodeColumn = ToNode(*lplpSql, lpSqlNode->node.columns.Column);
            lpstrName = ToString(*lplpSql, lpSqlNodeColumn->node.column.Column);

            /* For each column on the rest of the list */
            idxColumns = lpSqlNode->node.columns.Next;
            while (idxColumns != NO_SQLNODE) {

                /* Get pointer to table node */
                lpSqlNodeColumns = ToNode(*lplpSql, idxColumns);
                lpSqlNodeColumn = ToNode(*lplpSql, lpSqlNodeColumns->node.columns.Column);

                /* Error if its name is the same */
                if (fCaseSensitive) {
                    if (!s_lstrcmp(lpstrName,
                        ToString(*lplpSql, lpSqlNodeColumn->node.column.Column))) {
                        s_lstrcpy(lpstmt->szError, lpstrName);
                        return ERR_COLUMNONLIST;
                    }
                }
                else {
                    if (!s_lstrcmpi(lpstrName,
                        ToString(*lplpSql, lpSqlNodeColumn->node.column.Column))) {
                        s_lstrcpy(lpstmt->szError, lpstrName);
                        return ERR_COLUMNONLIST;
                    }
                }

                /* Go to next element */
                idxColumns = lpSqlNodeColumns->node.columns.Next;
            }
        }
        break;

    case NODE_TYPE_SORTCOLUMNS:
        while (TRUE) {
            LPSQLNODE  lpSqlNodeSort;
            LPSQLNODE  lpSqlNodeStmt;
            SQLNODEIDX idxValues;
            SWORD      count;
            LPSQLNODE  lpSqlNodeValues;
            LPSQLNODE  lpSqlNodeColumn;

            /* Check this column */
            err = SemanticCheck(lpstmt,
                                lplpSql,lpSqlNode->node.sortcolumns.Column,
                                fIsGroupby, fCaseSensitive,
                                idxNodeTableOuterJoinFromTables,
                                idxEnclosingStatement);
            if (err != ERR_SUCCESS)
                return err;

            /* Was an ordinal position in the select list given as sort? */
            lpSqlNodeSort = ToNode(*lplpSql, lpSqlNode->node.sortcolumns.Column);
            if (lpSqlNodeSort->sqlNodeType == NODE_TYPE_NUMERIC) {

                /* No.  Get the select list */
                lpSqlNodeStmt = ToNode(*lplpSql, idxEnclosingStatement);
                if (lpSqlNodeStmt->sqlNodeType != NODE_TYPE_SELECT)
                    return ERR_INTERNAL;

                /* Find the element in the select list */
                idxValues = lpSqlNodeStmt->node.select.Values;
                count = 1;
                while (TRUE) {
                    if (idxValues == NO_SQLNODE)
                        return ERR_ORDINALTOOLARGE;
                    lpSqlNodeValues = ToNode(*lplpSql, idxValues);
                    if (count == (SWORD) lpSqlNodeSort->node.numeric.Value)
                        break;
                    idxValues = lpSqlNodeValues->node.values.Next;
                    count++;
                }
                lpSqlNodeColumn = ToNode(*lplpSql,
                                         lpSqlNodeValues->node.values.Value);

                /* Error if a column reference was not given */
                if (lpSqlNodeColumn->sqlNodeType != NODE_TYPE_COLUMN)
                    return ERR_ORDERBYCOLUMNONLY;

                /* Convert the sort node to a column reference */
                lpSqlNodeSort->sqlNodeType = NODE_TYPE_COLUMN;
                lpSqlNodeSort->sqlDataType = TYPE_UNKNOWN;
                lpSqlNodeSort->sqlSqlType = SQL_TYPE_NULL;
                lpSqlNodeSort->sqlPrecision = 0;
                lpSqlNodeSort->sqlScale = NO_SCALE;
                lpSqlNodeSort->value.String = NULL;
                lpSqlNodeSort->value.Double = 0.0;
                lpSqlNodeSort->value.Date.year = 0;
                lpSqlNodeSort->value.Date.month = 0;
                lpSqlNodeSort->value.Date.day = 0;
                lpSqlNodeSort->value.Time.hour = 0;
                lpSqlNodeSort->value.Time.minute = 0;
                lpSqlNodeSort->value.Time.second = 0;
                lpSqlNodeSort->value.Timestamp.year = 0;
                lpSqlNodeSort->value.Timestamp.month = 0;
                lpSqlNodeSort->value.Timestamp.day = 0;
                lpSqlNodeSort->value.Timestamp.hour = 0;
                lpSqlNodeSort->value.Timestamp.minute = 0;
                lpSqlNodeSort->value.Timestamp.second = 0;
                lpSqlNodeSort->value.Timestamp.fraction = 0;
                lpSqlNodeSort->value.Binary = NULL;
                lpSqlNodeSort->sqlIsNull = TRUE;
                lpSqlNodeSort->node.column.Tablealias = lpSqlNodeColumn->node.column.Tablealias;
                lpSqlNodeSort->node.column.Qualifier = lpSqlNodeColumn->node.column.Qualifier;
                lpSqlNodeSort->node.column.MatchedAlias = lpSqlNodeColumn->node.column.MatchedAlias;
                lpSqlNodeSort->node.column.Column = lpSqlNodeColumn->node.column.Column;
                lpSqlNodeSort->node.column.TableIndex = lpSqlNodeColumn->node.column.TableIndex;
//                lpSqlNodeSort->node.table.Handle = NULL;
                lpSqlNodeSort->node.column.Id = -1;
                lpSqlNodeSort->node.column.Value = NO_STRING;
                lpSqlNodeSort->node.column.InSortRecord = FALSE;
                lpSqlNodeSort->node.column.Offset = 0;
                lpSqlNodeSort->node.column.Length = 0;
                lpSqlNodeSort->node.column.DistinctOffset = 0;
                lpSqlNodeSort->node.column.DistinctLength = 0;
                lpSqlNodeSort->node.column.EnclosingStatement = NO_SQLNODE;

                /* Semantic check the newly created node */
                err = SemanticCheck(lpstmt, lplpSql,
                              lpSqlNode->node.sortcolumns.Column,
                              fIsGroupby, fCaseSensitive,
                              idxNodeTableOuterJoinFromTables,
                              idxEnclosingStatement);
                if (err != ERR_SUCCESS)
                    return err;
            }

            /* Check the rest of the list */
            if (lpSqlNode->node.sortcolumns.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(*lplpSql, lpSqlNode->node.sortcolumns.Next);
        }
        break;

    case NODE_TYPE_GROUPBYCOLUMNS:
        while (TRUE) {

        /* Check this column */
            err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.groupbycolumns.Column,
                                fIsGroupby, fCaseSensitive,
                                idxNodeTableOuterJoinFromTables,
                                idxEnclosingStatement);
        if (err != ERR_SUCCESS)
            return err;

        /* Check the rest of the list */
            if (lpSqlNode->node.groupbycolumns.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(*lplpSql, lpSqlNode->node.groupbycolumns.Next);
        }
        break;

    case NODE_TYPE_UPDATEVALUES:

        while (TRUE) {
        /* Check this column */
            err = SemanticCheck(lpstmt, lplpSql,
                                lpSqlNode->node.updatevalues.Column, fIsGroupby,
                                fCaseSensitive,
                                idxNodeTableOuterJoinFromTables,
                                idxEnclosingStatement);
        if (err != ERR_SUCCESS)
            return err;

        /* Check the value being assigned to the column */
            err = SemanticCheck(lpstmt, lplpSql,
                                lpSqlNode->node.updatevalues.Value, fIsGroupby,
                                fCaseSensitive,
                                idxNodeTableOuterJoinFromTables,
                                idxEnclosingStatement);
        if (err != ERR_SUCCESS)
            return err;

        /* Error if value has incompatible type */
        err = TypeCheck(lpstmt, *lplpSql, lpSqlNode->node.updatevalues.Column,
                     lpSqlNode->node.updatevalues.Value, OP_NONE, NULL, NULL,
                     NULL, NULL); 
        if (err != ERR_SUCCESS)
            return err;

        /* Check the rest of the list */
            if (lpSqlNode->node.updatevalues.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(*lplpSql, lpSqlNode->node.updatevalues.Next);
        }
        break;

    case NODE_TYPE_CREATECOLS:

        while (TRUE) {
            UWORD count;
            UWORD idx;

            /* Make sure column name is not too long */
            ptr = ToString(*lplpSql, lpSqlNode->node.createcols.Name);
            if (s_lstrlen(ptr)>ISAMMaxColumnNameLength(lpstmt->lpdbc->lpISAM)) {
                s_lstrcpy(lpstmt->szError, ptr);
                return ERR_INVALIDCOLNAME;
            }

            /* Find data type */
            ptr = ToString(*lplpSql, lpSqlNode->node.createcols.Type);
            for (idx = 0; idx < lpstmt->lpdbc->lpISAM->cSQLTypes; idx++) {
                if (lpstmt->lpdbc->lpISAM->SQLTypes[idx].supported &&
                    !s_lstrcmpi(lpstmt->lpdbc->lpISAM->SQLTypes[idx].name, ptr))
                    break;
            }
            if (idx >= lpstmt->lpdbc->lpISAM->cSQLTypes) {
                s_lstrcpy(lpstmt->szError, ptr);
                return ERR_NOSUCHTYPE;
            }
            lpSqlNode->node.createcols.iSqlType = idx;

            /* Count the number of create parameters */
            count = 0;
            ptr = lpstmt->lpdbc->lpISAM->SQLTypes[idx].params;
            if (ptr != NULL) {
                count = 1;
                for (; *ptr; ptr++) {
                    if (*ptr == ',')
                        count++;
                }
            }

            /* Error if wrong number of parameters */
            if (count != lpSqlNode->node.createcols.Params) {
                s_lstrcpy((char*)lpstmt->szError,
                              ToString(*lplpSql, lpSqlNode->node.createcols.Type));
                return ERR_BADPARAMCOUNT;
            }


        /* Check next one on list */
        if (lpSqlNode->node.createcols.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(*lplpSql, lpSqlNode->node.createcols.Next);
        }

        break;

    case NODE_TYPE_BOOLEAN:

        while (TRUE) {

        /* Check left child */
            err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.boolean.Left,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);

        if (err != ERR_SUCCESS)
            return err;

        /* The result is always a boolean */
        lpSqlNode->sqlDataType = TYPE_INTEGER;
        lpSqlNode->sqlSqlType = SQL_BIT;
        lpSqlNode->sqlPrecision = 1;
        lpSqlNode->sqlScale = 0;

            /* Leave loop if no right child */
            if (lpSqlNode->node.boolean.Right == NO_SQLNODE)
                break;

            /* Is right child a NODE_TYPE_BOOLEAN node? */
            if (ToNode(*lplpSql, lpSqlNode->node.boolean.Right)->sqlNodeType !=
                                               NODE_TYPE_BOOLEAN) {

                /* No.  Semantic check that and leave the loop */
                err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.boolean.Right,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);
                if (err != ERR_SUCCESS)
                    return err;
                break;
            }

            /* Semantic check the right node on next iteration of the loop */
            lpSqlNode = ToNode(*lplpSql, lpSqlNode->node.boolean.Right);
        }

        break;

    case NODE_TYPE_COMPARISON:

        /* Check left child */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.comparison.Left,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);
        if (err != ERR_SUCCESS)
            return err;

        /* Check right child */
        err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.comparison.Right,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);
        if (err != ERR_SUCCESS)
            return err;

       /* Is this an IN or NOT IN comparison against a sub-select? */
        if (((lpSqlNode->node.comparison.Operator == OP_IN) ||
             (lpSqlNode->node.comparison.Operator == OP_NOTIN)) &&
            (ToNode(*lplpSql, lpSqlNode->node.comparison.Right)->sqlNodeType
                                                     == NODE_TYPE_SELECT)) {

            /* Yes.  Convert it to a regular comparison */
            if (lpSqlNode->node.comparison.Operator == OP_IN) {
                lpSqlNode->node.comparison.Operator = OP_EQ;
                lpSqlNode->node.comparison.SelectModifier = SELECT_ANY;
            }
            else if (lpSqlNode->node.comparison.Operator == OP_NOTIN) {
                lpSqlNode->node.comparison.Operator = OP_NE;
                lpSqlNode->node.comparison.SelectModifier = SELECT_ALL;
            }
        }

        /* Is this an EXISTS operation ? */
        if (lpSqlNode->node.comparison.Operator == OP_EXISTS) {

            /* Yes.  Nothing else to do */
            ;
        }

        /* Is this an IN or NOT IN comparison? */
        else if ((lpSqlNode->node.comparison.Operator != OP_IN) &&
                 (lpSqlNode->node.comparison.Operator != OP_NOTIN)) {

            /* No.  Is the right child NODE_TYPE_SELECT? */
            switch (lpSqlNode->node.comparison.SelectModifier) {
            case SELECT_NOTSELECT:
                break;
            case SELECT_ALL:
            case SELECT_ANY:
            case SELECT_ONE:
                {
                    LPSQLNODE lpSqlNodeSelect;
                    LPSQLNODE lpSqlNodeValues;
                    LPSQLNODE lpSqlNodeValue;

                    /* Yes.  Get the select list */
                    lpSqlNodeSelect = ToNode(*lplpSql,
                                       lpSqlNode->node.comparison.Right);
                    lpSqlNodeValues = ToNode(*lplpSql,
                                       lpSqlNodeSelect->node.select.Values);

                    /* If more than one value on the list, error */
                    if (lpSqlNodeValues->node.values.Next != NO_SQLNODE)
                        return ERR_MULTICOLUMNSELECT;

                    /* If long value, error */
                    lpSqlNodeValue = ToNode(*lplpSql,
                                       lpSqlNodeValues->node.values.Value);
                    if ((lpSqlNodeValue->sqlSqlType == SQL_LONGVARCHAR)  || 
                        (lpSqlNodeValue->sqlSqlType == SQL_LONGVARBINARY)) {
                        ErrorOpCode(lpstmt,
                                    lpSqlNode->node.comparison.Operator);
                        return ERR_INVALIDOPERAND;
                    }
                    
                    /* Set the type of the value returned by the sub-query */
                    lpSqlNodeSelect->sqlDataType  = lpSqlNodeValue->sqlDataType;
                    lpSqlNodeSelect->sqlSqlType   = lpSqlNodeValue->sqlSqlType;
                    lpSqlNodeSelect->sqlPrecision = lpSqlNodeValue->sqlPrecision;
                    lpSqlNodeSelect->sqlScale     = lpSqlNodeValue->sqlScale;
                }
                break;

            case SELECT_EXISTS:
            default:
                return ERR_INTERNAL;
            }

            /* Error if incompatible types */
            err = TypeCheck(lpstmt, *lplpSql, lpSqlNode->node.comparison.Left,
                        lpSqlNode->node.comparison.Right,
                        lpSqlNode->node.comparison.Operator,
                        &(lpSqlNode->sqlDataType), &(lpSqlNode->sqlSqlType),
                        &(lpSqlNode->sqlPrecision), &(lpSqlNode->sqlScale));
            if (err != ERR_SUCCESS)
                return err;

            /* Error if "LIKE" or "NOT LIKE" used for non-char data */
            if ((lpSqlNode->sqlDataType != TYPE_CHAR) &&
                ((lpSqlNode->node.comparison.Operator == OP_LIKE) ||
                 (lpSqlNode->node.comparison.Operator == OP_NOTLIKE))) {
                ErrorOpCode(lpstmt, lpSqlNode->node.comparison.Operator);
                return ERR_INVALIDOPERAND;
            }

            /* Error if binary data */
            if (lpSqlNode->sqlDataType == TYPE_BINARY) {
                if (((lpSqlNode->node.comparison.Operator != OP_EQ) &&
                     (lpSqlNode->node.comparison.Operator != OP_NE)) ||
                    (lpSqlNode->sqlPrecision > MAX_BINARY_LITERAL_LENGTH)) {
                    ErrorOpCode(lpstmt, lpSqlNode->node.comparison.Operator);
                    return ERR_INVALIDOPERAND;
                }
            }
        }
        else {

            /* Yes.  Look at each value */
            SQLNODEIDX idxValues;
            LPSQLNODE  lpSqlNodeValues;
            LPSQLNODE  lpSqlNodeValue;

            /* For each value... */
            idxValues = lpSqlNode->node.comparison.Right;
            while (idxValues != NO_SQLNODE) {

                /* Get the value */
                lpSqlNodeValues = ToNode(*lplpSql, idxValues);
                lpSqlNodeValue = ToNode(*lplpSql, lpSqlNodeValues->node.values.Value);

                /* Make sure the value is NUMERIC, STRING, */
                /* PARAMETER, USER, DATE, TIME, or TIMESTAMP    */
                switch (lpSqlNodeValue->sqlNodeType) {

                case NODE_TYPE_ALGEBRAIC:
                case NODE_TYPE_SCALAR:
                case NODE_TYPE_AGGREGATE:
				case NODE_TYPE_COLUMN:
                    return ERR_INVALIDINVAL;

                case NODE_TYPE_PARAMETER:
                case NODE_TYPE_NUMERIC:
                case NODE_TYPE_STRING:
                case NODE_TYPE_USER:
                case NODE_TYPE_DATE:
                case NODE_TYPE_TIME:
                case NODE_TYPE_TIMESTAMP:

                    /* Make sure value is of the proper type */
                    err = TypeCheck(lpstmt, *lplpSql,
                                    lpSqlNode->node.comparison.Left,
                                    lpSqlNodeValues->node.values.Value,
                                    lpSqlNode->node.comparison.Operator,
                                    &(lpSqlNode->sqlDataType),
                                    &(lpSqlNode->sqlSqlType),
                                    &(lpSqlNode->sqlPrecision),
                                    &(lpSqlNode->sqlScale));
                    if (err != ERR_SUCCESS)
                        return err;
                    break;
                case NODE_TYPE_NULL:
                    return ERR_INVALIDINVAL;
                default:
                    return ERR_INTERNAL;
                }

                /* Look at next element */
                idxValues = lpSqlNodeValues->node.values.Next;
            }
        }

        /* The result is always a boolean */
        lpSqlNode->sqlDataType = TYPE_INTEGER;
        lpSqlNode->sqlSqlType = SQL_BIT;
        lpSqlNode->sqlPrecision = 1;
        lpSqlNode->sqlScale = 0;

        break;

    case NODE_TYPE_ALGEBRAIC:

        /* Save pointer to enclosing statement */
        lpSqlNode->node.algebraic.EnclosingStatement = idxEnclosingStatement;

        {
            LPSQLNODE   lpSqlNodeLeft;
            LPUSTR       lpszToken;
            UCHAR       szTempToken[MAX_TOKEN_SIZE + 1];

            /* Check left child */
            err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.algebraic.Left,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);
            if (err != ERR_SUCCESS)
                return err;

            /* Check right child */
            err = SemanticCheck(lpstmt, lplpSql, lpSqlNode->node.algebraic.Right,
                            fIsGroupby, fCaseSensitive,
                            idxNodeTableOuterJoinFromTables,
                            idxEnclosingStatement);
            if (err != ERR_SUCCESS)
                return err;

            /* Check data type compatibility */
            err = TypeCheck(lpstmt, *lplpSql, lpSqlNode->node.algebraic.Left,
                        lpSqlNode->node.algebraic.Right,
                        lpSqlNode->node.algebraic.Operator,
                        &(lpSqlNode->sqlDataType), &(lpSqlNode->sqlSqlType),
                        &(lpSqlNode->sqlPrecision), &(lpSqlNode->sqlScale)); 
            if (err != ERR_SUCCESS)
                return err;

            /* Allocate space for the column value and make sure the */
            /* result is numeric, date, or string */
            switch (lpSqlNode->sqlDataType) {
            case TYPE_DOUBLE:
            case TYPE_INTEGER:
                break;
            case TYPE_NUMERIC:
                lpSqlNode->node.algebraic.Value = AllocateSpace(lplpSql,
                              (SWORD) (1 + 2 + lpSqlNode->sqlPrecision));
                if (lpSqlNode->node.algebraic.Value == NO_STRING)
                    return ERR_MEMALLOCFAIL;
                if (lpSqlNode->node.algebraic.Operator == OP_TIMES) {
                    lpSqlNode->node.algebraic.WorkBuffer1 = AllocateSpace(lplpSql,
                              (SWORD) (1 + 2 + lpSqlNode->sqlPrecision));
                    if (lpSqlNode->node.algebraic.WorkBuffer1 == NO_STRING)
                        return ERR_MEMALLOCFAIL;
                }
                else if (lpSqlNode->node.algebraic.Operator == OP_DIVIDEDBY) {
                    lpSqlNode->node.algebraic.WorkBuffer1 = AllocateSpace(lplpSql,
                              (SWORD) (1 + 2 + lpSqlNode->sqlPrecision));
                    if (lpSqlNode->node.algebraic.WorkBuffer1 == NO_STRING)
                        return ERR_MEMALLOCFAIL;
                    lpSqlNode->node.algebraic.WorkBuffer2 = AllocateSpace(lplpSql,
                              (SWORD) (1 + 2 + lpSqlNode->sqlPrecision));
                    if (lpSqlNode->node.algebraic.WorkBuffer2 == NO_STRING)
                        return ERR_MEMALLOCFAIL;
                    lpSqlNode->node.algebraic.WorkBuffer3 = AllocateSpace(lplpSql,
                              (SWORD) (1 + 2 + lpSqlNode->sqlPrecision));
                    if (lpSqlNode->node.algebraic.WorkBuffer3 == NO_STRING)
                        return ERR_MEMALLOCFAIL;
                }
                break;
            case TYPE_CHAR:
                lpSqlNode->node.algebraic.Value = AllocateSpace(lplpSql,
                              (SWORD) (1 + lpSqlNode->sqlPrecision));
                if (lpSqlNode->node.algebraic.Value == NO_STRING)
                    return ERR_MEMALLOCFAIL;
                break;
            case TYPE_BINARY:
                ErrorOpCode(lpstmt, lpSqlNode->node.algebraic.Operator);
                return ERR_INVALIDOPERAND;
            case TYPE_DATE:
                break;
            case TYPE_TIME:
            case TYPE_TIMESTAMP:
                ErrorOpCode(lpstmt, lpSqlNode->node.algebraic.Operator);
                return ERR_INVALIDOPERAND;
            default:
                return ERR_NOTSUPPORTED;
            }

            /* If this is just negation of a numeric value, collapse the */
            /* two nodes into one */
            lpSqlNodeLeft = ToNode(*lplpSql, lpSqlNode->node.algebraic.Left);
            if ((lpSqlNode->node.algebraic.Operator == OP_NEG) &&
                (lpSqlNodeLeft->sqlNodeType == NODE_TYPE_NUMERIC)) {
                *lpSqlNode = *lpSqlNodeLeft;
                lpSqlNode->node.numeric.Value = -(lpSqlNode->node.numeric.Value);
                lpszToken = ToString(*lplpSql, lpSqlNode->node.numeric.Numeric);
                if (*lpszToken != '-') {
                    s_lstrcpy((char*)szTempToken, lpszToken);
                    s_lstrcpy(lpszToken, "-");
                    s_lstrcat(lpszToken, (char*)szTempToken);
                    BCDNormalize(lpszToken, s_lstrlen(lpszToken),
                                 lpszToken, s_lstrlen(lpszToken) + 1,
                                 lpSqlNode->sqlPrecision,
                                 lpSqlNode->sqlScale);
                }
                else {
                    s_lstrcpy((char*)szTempToken, lpszToken);
                    s_lstrcpy(lpszToken, (char*) (szTempToken+1));
                }
            }
        }
        break;

    case NODE_TYPE_SCALAR:

        /* Save pointer to enclosing statement */
        lpSqlNode->node.scalar.EnclosingStatement = idxEnclosingStatement;

        /* Check the node */
        err = ScalarCheck(lpstmt, lplpSql, idxNode, fIsGroupby,
                      fCaseSensitive, idxNodeTableOuterJoinFromTables,
                      idxEnclosingStatement);
        if (err != ERR_SUCCESS)
            return err;

        /* Allocate space as need be */
        switch (lpSqlNode->sqlDataType) {
        case TYPE_DOUBLE:
            break;
        case TYPE_NUMERIC:
            lpSqlNode->node.scalar.Value = AllocateSpace(lplpSql,
                              (SWORD) (1 + 2 + lpSqlNode->sqlPrecision));
            if (lpSqlNode->node.scalar.Value == NO_STRING)
                return ERR_MEMALLOCFAIL;
            break;
        case TYPE_INTEGER:
            break;
        case TYPE_CHAR:
            lpSqlNode->node.scalar.Value = AllocateSpace(lplpSql,
                              (SWORD) (1 + lpSqlNode->sqlPrecision));
            if (lpSqlNode->node.scalar.Value == NO_STRING)
                return ERR_MEMALLOCFAIL;
            break;
        case TYPE_BINARY:
            lpSqlNode->node.scalar.Value = AllocateSpace(lplpSql,
                         (SWORD) (sizeof(SDWORD) + lpSqlNode->sqlPrecision));
            if (lpSqlNode->node.scalar.Value == NO_STRING)
                return ERR_MEMALLOCFAIL;
            break;
        case TYPE_DATE:
            break;
        case TYPE_TIME:
            break;
        case TYPE_TIMESTAMP:
            break;
        default:
            return ERR_NOTSUPPORTED;
        }
        break;

    case NODE_TYPE_AGGREGATE:

        /* Save pointer to enclosing statement */
        lpSqlNode->node.aggregate.EnclosingStatement = idxEnclosingStatement;

        {
            LPSQLNODE   lpSqlNodeExpression;
            LPSQLNODE   lpSqlNodeSelect;
            LPSQLNODE   lpSqlNodeAggregate;
            SQLNODEIDX  idxAggregate;

            /* Error if no group by */
            if (!fIsGroupby) {
                ErrorAggCode(lpstmt, lpSqlNode->node.aggregate.Operator);
                return ERR_AGGNOTALLOWED;
            }

            /* Check expression */
            err = SemanticCheck(lpstmt, lplpSql,
                                lpSqlNode->node.aggregate.Expression,
                                FALSE, fCaseSensitive,
                                idxNodeTableOuterJoinFromTables,
                                idxEnclosingStatement);
            if (err != ERR_SUCCESS)
                return err;

            /* Figure out type of result */
            if (lpSqlNode->node.aggregate.Operator != AGG_COUNT)
                lpSqlNodeExpression =
                          ToNode(*lplpSql, lpSqlNode->node.aggregate.Expression);
            switch(lpSqlNode->node.aggregate.Operator) {
            case AGG_AVG:
                switch (lpSqlNodeExpression->sqlDataType) {
                case TYPE_DOUBLE:
                case TYPE_NUMERIC:
                case TYPE_INTEGER:
                    lpSqlNode->sqlDataType = TYPE_DOUBLE;
                    lpSqlNode->sqlSqlType = SQL_DOUBLE;
                    lpSqlNode->sqlPrecision = 15;
                    lpSqlNode->sqlScale = NO_SCALE;
                    break;
                case TYPE_CHAR:
                case TYPE_DATE:
                case TYPE_TIME:
                case TYPE_TIMESTAMP:
                case TYPE_BINARY:
                    ErrorAggCode(lpstmt, lpSqlNode->node.aggregate.Operator);
                    return ERR_INVALIDOPERAND;
                default:
                    return ERR_NOTSUPPORTED;
                }
                break;
            case AGG_COUNT:
                lpSqlNode->sqlDataType = TYPE_INTEGER;
                lpSqlNode->sqlSqlType = SQL_INTEGER;
                lpSqlNode->sqlPrecision = 10;
                lpSqlNode->sqlScale = 0;
                break;
            case AGG_MAX:
            case AGG_MIN:
                switch (lpSqlNodeExpression->sqlDataType) {
                case TYPE_DOUBLE:
                case TYPE_NUMERIC:
                case TYPE_INTEGER:
                case TYPE_CHAR:
                case TYPE_DATE:
                case TYPE_TIME:
                case TYPE_TIMESTAMP:
                    lpSqlNode->sqlDataType = lpSqlNodeExpression->sqlDataType;
                    lpSqlNode->sqlSqlType = lpSqlNodeExpression->sqlSqlType;
                    lpSqlNode->sqlPrecision = lpSqlNodeExpression->sqlPrecision;
                    lpSqlNode->sqlScale = lpSqlNodeExpression->sqlScale;
                    break;
                case TYPE_BINARY:
                    ErrorAggCode(lpstmt, lpSqlNode->node.aggregate.Operator);
                    return ERR_INVALIDOPERAND;
                default:
                    return ERR_NOTSUPPORTED;
                }
                break;
            case AGG_SUM:
                switch (lpSqlNodeExpression->sqlDataType) {
                case TYPE_DOUBLE:
                case TYPE_NUMERIC:
                case TYPE_INTEGER:
                    lpSqlNode->sqlDataType = lpSqlNodeExpression->sqlDataType;
                    lpSqlNode->sqlSqlType = lpSqlNodeExpression->sqlSqlType;
                    lpSqlNode->sqlPrecision = lpSqlNodeExpression->sqlPrecision;
                    lpSqlNode->sqlScale = lpSqlNodeExpression->sqlScale;
                    break;
                case TYPE_CHAR:
                case TYPE_DATE:
                case TYPE_TIME:
                case TYPE_TIMESTAMP:
                case TYPE_BINARY:
                    ErrorAggCode(lpstmt, lpSqlNode->node.aggregate.Operator);
                    return ERR_INVALIDOPERAND;
                default:
                    return ERR_NOTSUPPORTED;
                }
                break;
            default:
                return ERR_INTERNAL;
            }

            /* Allocate space for the aggregate value */
            switch (lpSqlNode->sqlDataType) {
            case TYPE_DOUBLE:
                lpSqlNode->node.aggregate.Length = sizeof(double);
                break;
            case TYPE_NUMERIC:
                switch (lpSqlNode->sqlSqlType) {
                case SQL_NUMERIC:
                case SQL_DECIMAL:
                    lpSqlNode->node.aggregate.Length =
                                lpSqlNodeExpression->sqlPrecision + 2;
                    break;
                case SQL_BIGINT:
                    lpSqlNode->node.aggregate.Length =
                                lpSqlNodeExpression->sqlPrecision + 1;
                    break;
                case SQL_TINYINT:
                case SQL_SMALLINT:
                case SQL_INTEGER:
                case SQL_BIT:
                case SQL_REAL:
                case SQL_FLOAT:
                case SQL_DOUBLE:
                case SQL_CHAR:
                case SQL_VARCHAR:
                case SQL_LONGVARCHAR:
                case SQL_BINARY:
                case SQL_VARBINARY:
                case SQL_LONGVARBINARY:
                case SQL_DATE:
                case SQL_TIME:
                case SQL_TIMESTAMP:
                default:
                    return ERR_INTERNAL;
                }
                lpSqlNode->node.aggregate.Value =
                         AllocateSpace(lplpSql, (SWORD)
                                        (lpSqlNode->node.aggregate.Length + 1));
                if (lpSqlNode->node.aggregate.Value == NO_STRING)
                    return ERR_MEMALLOCFAIL;
                break;
            case TYPE_INTEGER:
                lpSqlNode->node.aggregate.Length = sizeof(double);
                break;
            case TYPE_CHAR:
                lpSqlNode->node.aggregate.Length =
                                    lpSqlNodeExpression->sqlPrecision;
                lpSqlNode->node.aggregate.Value =
                         AllocateSpace(lplpSql, (SWORD)
                                        (lpSqlNode->node.aggregate.Length + 1));
                if (lpSqlNode->node.aggregate.Value == NO_STRING)
                    return ERR_MEMALLOCFAIL;
                break;
            case TYPE_DATE:
                lpSqlNode->node.aggregate.Length = 10;
                break;
            case TYPE_TIME:
                lpSqlNode->node.aggregate.Length = 8;
                break;
            case TYPE_TIMESTAMP:
                if (TIMESTAMP_SCALE > 0)
                    lpSqlNode->node.aggregate.Length = 20 + TIMESTAMP_SCALE;
                else
                    lpSqlNode->node.aggregate.Length = 19;
                break;
            case TYPE_BINARY:
                return ERR_INTERNAL;
            default:
                return ERR_NOTSUPPORTED;
            }

            /* Get SELECT statement node */
            lpSqlNodeSelect = ToNode(*lplpSql, idxEnclosingStatement);
            if (lpSqlNodeSelect->sqlNodeType != NODE_TYPE_SELECT)
                return ERR_INTERNAL;

            /* Add to list of AGG functions in the select node */
            lpSqlNodeAggregate = NULL;
            idxAggregate = lpSqlNodeSelect->node.select.Aggregates;
            while (idxAggregate != NO_SQLNODE) {
                lpSqlNodeAggregate = ToNode(*lplpSql, idxAggregate);
                idxAggregate = lpSqlNodeAggregate->node.aggregate.Next;
            }
            if (lpSqlNodeAggregate != NULL)
                lpSqlNodeAggregate->node.aggregate.Next = idxNode;
            else
                lpSqlNodeSelect->node.select.Aggregates = idxNode;
        }
        break;

    case NODE_TYPE_TABLE:
        {
            LPSQLNODE   lpSqlNodeRoot;
            LPSQLNODE   lpSqlNodeStmt;
            BOOL        fReadOnly;
			char		tableNameBuff [MAX_TABLE_NAME_LENGTH + 1];
            
            /* Make sure table name is not too long */
            ptr = ToString(*lplpSql, lpSqlNode->node.table.Name);
            if (s_lstrlen(ptr) > ISAMMaxTableNameLength(lpstmt->lpdbc->lpISAM)){
                s_lstrcpy(lpstmt->szError, ptr);
                return ERR_INVALIDTABLENAME;
            }
			else
			{
				//Copy table name
				tableNameBuff[0] = 0;
				s_lstrcpy (tableNameBuff, ptr);
			}

            /* Figure out if write access is needed */
            lpSqlNodeStmt = ToNode(*lplpSql, idxEnclosingStatement);
            switch (lpSqlNodeStmt->sqlNodeType) {
            case NODE_TYPE_SELECT:
                fReadOnly = TRUE;
                break;
            case NODE_TYPE_INSERT:
                fReadOnly = FALSE;
                break;
            case NODE_TYPE_UPDATE:
                fReadOnly = FALSE;
                break;
            case NODE_TYPE_DELETE:
                fReadOnly = FALSE;
                break;
            case NODE_TYPE_CREATEINDEX:
                fReadOnly = FALSE;
                break;
            case NODE_TYPE_DROPINDEX:
                fReadOnly = FALSE;
                break;
            default:
                return ERR_INTERNAL;
            }

			/* resolve qualifier */

			if (lpSqlNode->node.table.Qualifier != NO_STRING)
			{
 				LPSTR pQual = (LPSTR) ToString(*lplpSql, lpSqlNode->node.table.Qualifier);
				if (lstrlen(pQual) > ISAMMaxTableNameLength(lpstmt->lpdbc->lpISAM)) {
					s_lstrcpy((char*)lpstmt->szError, ptr);
					return ERR_INVALIDTABLENAME;
				}


				if ( (lstrlen(pQual) >= 4) && (_strnicmp("root", pQual, 4) == 0) )
				{
					// absolute qualifier [starts with 'root'] (no need to change)
				}
				else
				{
					// concatenate the current namespace with the qualifier
					LPUSTR currQual = ISAMDatabase (lpstmt->lpdbc->lpISAM);
					char * pszNewQualifier = new char [strlen (pQual)+
							s_lstrlen (currQual)+2+1];
					s_lstrcpy (pszNewQualifier, currQual);
					s_lstrcat (pszNewQualifier, "\\");
					s_lstrcat (pszNewQualifier, pQual);
					lpSqlNode->node.table.Qualifier = AllocateString (lplpSql, (LPUSTR)pszNewQualifier);
					delete [] pszNewQualifier;
				}
			}
			else
			{
				// the current namespace is the qualifier
				LPUSTR currQual = ISAMDatabase (lpstmt->lpdbc->lpISAM);
				lpSqlNode->node.table.Qualifier = AllocateString (lplpSql, (LPUSTR)currQual);
			}
			
#ifdef TESTING
		//Create extra test class with dummy values for testing
//		IMosProvider* pDummyProv = ISAMGetGatewayServer(lpstmt->lpdbc->lpISAM);
//		CreateClassAndInstance(pDummyProv);
#endif

            /* Open the table */
            LPUSTR pQual = ToString(*lplpSql, lpSqlNode->node.table.Qualifier);
			lpSqlNodeRoot = ToNode(*lplpSql, ROOT_SQLNODE);


			//If this the special Passthrough SQL table ?
			char* virTbl = WBEMDR32_VIRTUAL_TABLE2;
			if (s_lstrcmp(tableNameBuff, virTbl) == 0)
			{
				//Yes this is the Passthrough SQL table
				err = ISAMOpenTable(lpSqlNodeRoot->node.root.lpISAM, 
									(LPUSTR) pQual, (SWORD) s_lstrlen (pQual),
									(LPUSTR) tableNameBuff, fReadOnly,
									&(lpSqlNode->node.table.Handle),
									lpstmt);
			}
			else
			{
				//No normal table
				err = ISAMOpenTable(lpSqlNodeRoot->node.root.lpISAM, 
									(LPUSTR) pQual, (SWORD) s_lstrlen (pQual),
									(LPUSTR) tableNameBuff, fReadOnly,
									&(lpSqlNode->node.table.Handle));
			}
            if (err != NO_ISAM_ERR) {
                lpSqlNode->node.table.Handle = NULL;
                ISAMGetErrorMessage(lpSqlNodeRoot->node.root.lpISAM,
                                    (LPUSTR)lpstmt->szISAMError);
                return err;
            }
            if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                lpstmt->fISAMTxnStarted = TRUE;
            err = ERR_SUCCESS;
        }
        break;

    case NODE_TYPE_COLUMN: 

        /* Save pointer to enclosing statement */
        lpSqlNode->node.column.EnclosingStatement = idxEnclosingStatement;

		//Sai Wong table column info

        /* Is this column node in an outer join predicate? */
        if (idxNodeTableOuterJoinFromTables == NO_SQLNODE) {

            /* No.  Resolve it against the table lists */
            LPSQLNODE   lpSqlNodeStmt;
            LPSQLNODE   lpSqlNodeTables; 
            SQLNODEIDX  idxTables;
            SQLNODEIDX  idxStatement;
            STRINGIDX   idxOriginalAlias;
            STRINGIDX   idxAlias;
            BOOL        fFoundMatch;
			STRINGIDX	idxQualifier, idxOriginalQualifier;

            /* No.  Search up all the enclosing statements for the column */
            idxStatement = idxEnclosingStatement;
            while (idxStatement != NO_SQLNODE) {
            
            /* Get node of the statement */
            lpSqlNodeStmt = ToNode(*lplpSql, idxStatement);
			
            /* Resolve column */
            switch (lpSqlNodeStmt->sqlNodeType) {
            case NODE_TYPE_SELECT:

                /* Save the table alias and qualifier specified */
                idxAlias = lpSqlNode->node.column.Tablealias;
				idxOriginalAlias = lpSqlNode->node.column.Tablealias;
				idxQualifier = idxOriginalQualifier = lpSqlNode->node.column.Qualifier;


                /* Look through the list of tables */
                fFoundMatch = FALSE;
                err = ERR_COLUMNNOTFOUND;
                for (idxTables = lpSqlNodeStmt->node.select.Tables;
                     idxTables != NO_SQLNODE;
                     idxTables = lpSqlNodeTables->node.tables.Next) {

                    /* Is the column in this table? */
                    lpSqlNodeTables = ToNode(*lplpSql, idxTables);
                    err = FindColumn(lpstmt, *lplpSql, fCaseSensitive,
                                  lpSqlNode, lpSqlNodeTables->node.tables.Table, idxQualifier);


					if (err == ERR_SUCCESS)
					{
                        /* Yes.  Error if column also in another table */

                        if (fFoundMatch) {

                            s_lstrcpy((char*)lpstmt->szError,
                                ToString(*lplpSql, lpSqlNode->node.column.Column));
                            return ERR_COLUMNFOUND;
                        }

						fFoundMatch = TRUE;

                        
                        /* If a table alias was specified for column, */
                        /* there is no need to check the other tables       */
						/* I'm going to remove this check as there is the  */ 
						/* possibility of a clash between an alias-qualified*/
						/* name and a namespace qualified name.  This clash */
						/* is not picked up during the semantic check of the*/
						/* table list									    */
                        //if (idxOriginalAlias != NO_STRING)
                        //    break;


						/* Save the alias of the table found */
						idxAlias = lpSqlNode->node.column.Tablealias;
						idxQualifier = lpSqlNode->node.column.Qualifier;
           
						/* Restore the original alias and keep looking */
						//Added by Sai Wong
						lpSqlNode->node.column.Tablealias = idxOriginalAlias; //NO_STRING;
						lpSqlNode->node.column.Qualifier  = idxOriginalQualifier;
                     }
                        else if (err != ERR_COLUMNNOTFOUND)
                            return err;
                }

                    /* Restore the alias found */
                    lpSqlNode->node.column.Tablealias = idxAlias;
                    lpSqlNode->node.column.Qualifier = idxQualifier;

                    /* Was the column found in this statement? */
                    if (fFoundMatch)
                        err = ERR_SUCCESS;
                    else
                        err = ERR_COLUMNNOTFOUND;


                break;

            case NODE_TYPE_INSERT:
                    if (idxStatement == idxEnclosingStatement)
                        err = FindColumn(lpstmt, *lplpSql, fCaseSensitive,
                                lpSqlNode, lpSqlNodeStmt->node.insert.Table,
								NO_STRING);
                    else
                        err = ERR_COLUMNNOTFOUND;
                break;
            case NODE_TYPE_UPDATE:
                err = FindColumn(lpstmt, *lplpSql, fCaseSensitive, lpSqlNode,
                                 lpSqlNodeStmt->node.update.Table, NO_STRING);
                break;
            case NODE_TYPE_DELETE:
                err = FindColumn(lpstmt, *lplpSql, fCaseSensitive, lpSqlNode,
                                 lpSqlNodeStmt->node.delet.Table, NO_STRING);
                break;
            case NODE_TYPE_CREATEINDEX:
                 err = FindColumn(lpstmt, *lplpSql, fCaseSensitive, lpSqlNode,
                                     lpSqlNodeStmt->node.createindex.Table, NO_STRING);
                 break;
            default:
                return ERR_INTERNAL;
            }
                            if ((err != ERR_SUCCESS) && (err != ERR_COLUMNNOTFOUND))
                    return err;

                /* If the column was found in this statement, use it */
                if (err == ERR_SUCCESS)
                    break;

                /* Try looking in the enclosing statement (if any) */
                if (lpSqlNodeStmt->sqlNodeType != NODE_TYPE_SELECT)
                    break;
                idxStatement = lpSqlNodeStmt->node.select.EnclosingStatement;
            }

            /* If column not found, error */
            if (err == ERR_COLUMNNOTFOUND) {
                 s_lstrcpy(lpstmt->szError,
                          ToString(*lplpSql, lpSqlNode->node.column.Column));
                 return ERR_COLUMNNOTFOUND;
            }
        }
        else {

            /* Yes.  Resolve it against the table lists */
            STRINGIDX   idxAlias;
            STRINGIDX   idxOriginalAlias;
            BOOL        fFoundMatch;
            SQLNODEIDX  idxTables;
            LPSQLNODE   lpSqlNodeTables;
            SQLNODEIDX  idxTable;
            LPSQLNODE   lpSqlNodeTable;
			STRINGIDX	idxQualifier, idxOriginalQualifier;

            /* Save the table alias specified */
            idxAlias = lpSqlNode->node.column.Tablealias;
            idxOriginalAlias = lpSqlNode->node.column.Tablealias;
			idxQualifier = idxOriginalQualifier = lpSqlNode->node.column.Qualifier;

            /* Is the column in a table in the outer join expression? */
            idxTables = idxNodeTableOuterJoinFromTables;
            lpSqlNodeTables = ToNode(*lplpSql, idxTables);
            idxTable = lpSqlNodeTables->node.tables.Table;
            fFoundMatch = FALSE;
            while (TRUE) {

                /* Is it in this table? */
                err = FindColumn(lpstmt, *lplpSql, fCaseSensitive,
                                 lpSqlNode, idxTable, lpSqlNodeTables->node.column.Qualifier);
                if (err == ERR_SUCCESS) {

                    /* Yes.  Error if it matches another table too */
                    if (fFoundMatch) {
                        s_lstrcpy(lpstmt->szError,
                         ToString(*lplpSql, lpSqlNode->node.column.Column));
                        return ERR_COLUMNFOUND;
                    }

                    /* Set flag */
                    fFoundMatch = TRUE;

                    /* Save the alias of the table found */
                    idxAlias = lpSqlNode->node.column.Tablealias;
					idxQualifier = lpSqlNode->node.column.Qualifier;

                    /* Restore the original alias if need be */
					//Added by Sai Wong
//                  if (idxOriginalAlias == NO_STRING)
                        lpSqlNode->node.column.Tablealias = idxOriginalAlias; //NO_STRING;
						lpSqlNode->node.column.Qualifier  = idxOriginalQualifier;
                }
                else if (err != ERR_COLUMNNOTFOUND)
                    return err;

                /* Look in next table on list */
                idxTables = lpSqlNodeTables->node.tables.Next;
                if (idxTables == NO_SQLNODE)
                    break;
                lpSqlNodeTables = ToNode(*lplpSql, idxTables);
                idxTable = lpSqlNodeTables->node.tables.Table;
                lpSqlNodeTable = ToNode(*lplpSql, idxTable);

                /* If this table is not in the outer-join, stop looking */
                if (lpSqlNodeTable->node.table.OuterJoinFromTables ==
                                            NO_SQLNODE)
                    break;
            }

            /* Error if column was not found */
            if (!fFoundMatch) {
                s_lstrcpy(lpstmt->szError,
                             ToString(*lplpSql, lpSqlNode->node.column.Column));
                return ERR_COLUMNNOTFOUND;
            }

            /* Restore the alias found */
            lpSqlNode->node.column.Tablealias = idxAlias;
			lpSqlNode->node.column.Qualifier = idxQualifier;

            err = ERR_SUCCESS;
        }


        /* Does the column have to be a group by column? */
        if (fIsGroupby) {

            LPUSTR       lpszColumn;
            LPUSTR       lpszTable;
            LPSQLNODE   lpSqlNodeStmt;
            SQLNODEIDX  idxGroupbycolumns;
            LPSQLNODE   lpSqlNodeGroupbycolumns;
            LPSQLNODE   lpSqlNodeColumnGroupby;
            LPUSTR       lpszColumnGroupby;
            LPUSTR       lpszTableGroupby;
            BOOL        fMatch;

            /* Yes.  Get the name of the column and table */
            lpszColumn = ToString(*lplpSql, lpSqlNode->node.column.Column);
            lpszTable = ToString(*lplpSql, lpSqlNode->node.column.Tablealias);

            /* Get list of group by columns */
            lpSqlNodeStmt = ToNode(*lplpSql, idxEnclosingStatement);
            if (lpSqlNodeStmt->sqlNodeType != NODE_TYPE_SELECT)
                return ERR_INTERNAL;
            idxGroupbycolumns = lpSqlNodeStmt->node.select.Groupbycolumns;
            
	    /* Error if implicit group by */
            if (lpSqlNodeStmt->node.select.ImplicitGroupby) {
                s_lstrcpy(lpstmt->szError,
                             ToString(*lplpSql, lpSqlNode->node.column.Column));
                return ERR_COLUMNNOTFOUND;
            }


            /* Find the column in the group by lists */
            while (TRUE) {

                /* Get this group by column */
                lpSqlNodeGroupbycolumns = ToNode(*lplpSql, idxGroupbycolumns);
                if (lpSqlNodeGroupbycolumns->node.groupbycolumns.Column !=
                                                          NO_SQLNODE) {
                    lpSqlNodeColumnGroupby = ToNode(*lplpSql,
                        lpSqlNodeGroupbycolumns->node.groupbycolumns.Column);

                    /* Get column name and table name of the group by column */
                    lpszTableGroupby = ToString(*lplpSql,
                             lpSqlNodeColumnGroupby->node.column.Tablealias);
                    lpszColumnGroupby = ToString(*lplpSql,
                             lpSqlNodeColumnGroupby->node.column.Column);
                
                    /* Do the column name match? */
                    fMatch = FALSE;
                    if (fCaseSensitive) { 
                        if (!s_lstrcmp(lpszColumnGroupby, lpszColumn) &&
                            !s_lstrcmp(lpszTableGroupby, lpszTable))
                            fMatch = TRUE;
                    }
                    else {
                        if (!s_lstrcmpi(lpszColumnGroupby, lpszColumn) &&
                            !s_lstrcmpi(lpszTableGroupby, lpszTable))
                            fMatch = TRUE;
                    }
                }
                else
                    fMatch = FALSE;

                /* Does this column match a group by column? */
                if (fMatch) {

                    /* Yes.  Fill in semantic information for the column */
                    lpSqlNode->node.column.InSortRecord = TRUE;
                    lpSqlNode->node.column.Offset =
                               lpSqlNodeColumnGroupby->node.column.Offset;
                    lpSqlNode->node.column.Length =
                               lpSqlNodeColumnGroupby->node.column.Length;
                    lpSqlNode->node.column.DistinctOffset =
                               lpSqlNodeColumnGroupby->node.column.DistinctOffset;
                    lpSqlNode->node.column.DistinctLength =
                               lpSqlNodeColumnGroupby->node.column.DistinctLength;
                    break;
                }

                /* Not  found yet.  Check next column */
                idxGroupbycolumns =
                              lpSqlNodeGroupbycolumns->node.groupbycolumns.Next;

                /* Error if column not found */
                if (idxGroupbycolumns == NO_SQLNODE) {
                    s_lstrcpy((char*)lpstmt->szError,
                             ToString(*lplpSql, lpSqlNode->node.column.Column));
                    return ERR_COLUMNNOTFOUND;
                }
            }
        }

        /* Allocate space for the column value */
        switch (lpSqlNode->sqlDataType) {
        case TYPE_DOUBLE:
            break;
        case TYPE_NUMERIC:
            lpSqlNode->node.column.Value = AllocateSpace(lplpSql,
                              (SWORD) (1 + 2 + lpSqlNode->sqlPrecision));
            if (lpSqlNode->node.column.Value == NO_STRING)
                return ERR_MEMALLOCFAIL;
            break;
        case TYPE_INTEGER:
            break;
        case TYPE_CHAR:
            lpSqlNode->node.column.Value = AllocateSpace(lplpSql,
                              (SWORD) (1 + lpSqlNode->sqlPrecision));
            if (lpSqlNode->node.column.Value == NO_STRING)
                return ERR_MEMALLOCFAIL;
            break;
        case TYPE_BINARY:
            lpSqlNode->node.column.Value = AllocateSpace(lplpSql,
                         (SWORD) (sizeof(SDWORD) + lpSqlNode->sqlPrecision));
            if (lpSqlNode->node.column.Value == NO_STRING)
                return ERR_MEMALLOCFAIL;
            break;
        case TYPE_DATE:
            break;
        case TYPE_TIME:
            break;
        case TYPE_TIMESTAMP:
            break;
        default:
            return ERR_NOTSUPPORTED;
        }
        break;

    case NODE_TYPE_STRING:
        lpSqlNode->sqlDataType = TYPE_CHAR;
        lpSqlNode->sqlSqlType = SQL_VARCHAR;
        ptr = ToString(*lplpSql, lpSqlNode->node.string.Value);
        lpSqlNode->sqlPrecision = s_lstrlen(ptr);
        lpSqlNode->sqlScale = NO_SCALE;
        break;
    
    case NODE_TYPE_NUMERIC:
        if (lpSqlNode->sqlDataType == TYPE_UNKNOWN) {
            lpSqlNode->sqlDataType = TYPE_DOUBLE;
            lpSqlNode->sqlSqlType = SQL_DOUBLE;
            lpSqlNode->sqlPrecision = 15;
            lpSqlNode->sqlScale = NO_SCALE;
        }
        break;
    
    case NODE_TYPE_PARAMETER:
        lpSqlNode->sqlDataType = TYPE_UNKNOWN;
        lpSqlNode->sqlSqlType = SQL_TYPE_NULL;
        lpSqlNode->sqlPrecision = 0;
        lpSqlNode->sqlScale = NO_SCALE;
        break;
    
    case NODE_TYPE_USER:
        lpSqlNode->sqlDataType = TYPE_CHAR;
        lpSqlNode->sqlSqlType = SQL_VARCHAR;
        lpSqlNode->sqlPrecision = s_lstrlen(
               ISAMUser(ToNode(*lplpSql, ROOT_SQLNODE)->node.root.lpISAM));
        lpSqlNode->sqlScale = NO_SCALE;
        break;
    
    case NODE_TYPE_NULL:
        lpSqlNode->sqlDataType = TYPE_UNKNOWN;
        lpSqlNode->sqlSqlType = SQL_TYPE_NULL;
        lpSqlNode->sqlPrecision = 0;
        lpSqlNode->sqlScale = NO_SCALE;
        break;
    
    case NODE_TYPE_DATE:
        lpSqlNode->sqlDataType = TYPE_DATE;
        if (lpSqlNode->sqlSqlType == SQL_TYPE_NULL) {
            lpSqlNode->sqlSqlType = SQL_DATE;
            lpSqlNode->sqlPrecision = 10;
            lpSqlNode->sqlScale = NO_SCALE;
        }
        break;
    
    case NODE_TYPE_TIME:
        lpSqlNode->sqlDataType = TYPE_TIME;
        if (lpSqlNode->sqlSqlType == SQL_TYPE_NULL) {
            lpSqlNode->sqlSqlType = SQL_TIME;
            lpSqlNode->sqlPrecision = 8;
            lpSqlNode->sqlScale = NO_SCALE;
        }
        break;
    
    case NODE_TYPE_TIMESTAMP:
        lpSqlNode->sqlDataType = TYPE_TIMESTAMP;
        if (lpSqlNode->sqlSqlType == SQL_TYPE_NULL) {
            lpSqlNode->sqlSqlType = SQL_TIMESTAMP;
            if (TIMESTAMP_SCALE != 0)
                lpSqlNode->sqlPrecision = 20 + TIMESTAMP_SCALE;
            else
                lpSqlNode->sqlPrecision = 19;
            lpSqlNode->sqlScale = TIMESTAMP_SCALE;
        }
        break;
    
    default:
        return ERR_INTERNAL;
    }
    return err;
}

/***************************************************************************/

void INTFUNC FreeTreeSemantic(LPSQLTREE lpSql, SQLNODEIDX idxNode)

/* Deallocates semantic information in a parse tree */

{
    LPSQLNODE lpSqlNode;
    SQLNODEIDX idxParameter;
    SQLNODEIDX idxParameterNext;

    if (idxNode == NO_SQLNODE)
        return;
    lpSqlNode = ToNode(lpSql, idxNode);
    switch (lpSqlNode->sqlNodeType) {
    case NODE_TYPE_NONE:
        break;

    case NODE_TYPE_ROOT:
        FreeTreeSemantic(lpSql, lpSqlNode->node.root.sql);
        if (lpSqlNode->node.root.passthroughParams) {
            idxParameter = lpSqlNode->node.root.parameters;
            while (idxParameter != NO_SQLNODE) {
                lpSqlNode = ToNode(lpSql, idxParameter);
                idxParameterNext = lpSqlNode->node.parameter.Next;
                FreeTreeSemantic(lpSql, idxParameter);
                idxParameter = idxParameterNext;
            }
        }
        break;

    case NODE_TYPE_CREATE:
        FreeTreeSemantic(lpSql, lpSqlNode->node.create.Columns);
        break;

    case NODE_TYPE_DROP:
        break;

    case NODE_TYPE_SELECT:
        FreeTreeSemantic(lpSql, lpSqlNode->node.select.Values);
        FreeTreeSemantic(lpSql, lpSqlNode->node.select.Tables);
        FreeTreeSemantic(lpSql, lpSqlNode->node.select.Predicate);
        FreeTreeSemantic(lpSql, lpSqlNode->node.select.Groupbycolumns);
        FreeTreeSemantic(lpSql, lpSqlNode->node.select.Sortcolumns);
        if (lpSqlNode->node.select.Sortfile != HFILE_ERROR) {
            LPUSTR lpszSortfile;
            _lclose(lpSqlNode->node.select.Sortfile);
            lpSqlNode->node.select.Sortfile = HFILE_ERROR;
            lpszSortfile = ToString(lpSql,
                        lpSqlNode->node.select.SortfileName);
            DeleteFile((LPCSTR) lpszSortfile);
            s_lstrcpy(lpszSortfile, "");
        }
        break;

    case NODE_TYPE_INSERT:
        FreeTreeSemantic(lpSql, lpSqlNode->node.insert.Table);
        FreeTreeSemantic(lpSql, lpSqlNode->node.insert.Columns);
        FreeTreeSemantic(lpSql, lpSqlNode->node.insert.Values);
        break;

    case NODE_TYPE_DELETE:
        FreeTreeSemantic(lpSql, lpSqlNode->node.delet.Table);
        FreeTreeSemantic(lpSql, lpSqlNode->node.delet.Predicate);
        break;

    case NODE_TYPE_UPDATE:
        FreeTreeSemantic(lpSql, lpSqlNode->node.update.Table);
        FreeTreeSemantic(lpSql, lpSqlNode->node.update.Updatevalues);
        FreeTreeSemantic(lpSql, lpSqlNode->node.update.Predicate);
        break;

    case NODE_TYPE_CREATEINDEX:
        FreeTreeSemantic(lpSql, lpSqlNode->node.createindex.Table);
        FreeTreeSemantic(lpSql, lpSqlNode->node.createindex.Columns);
        break;

    case NODE_TYPE_DROPINDEX:
        break;

    case NODE_TYPE_PASSTHROUGH:
        break;

    case NODE_TYPE_TABLES:
        FreeTreeSemantic(lpSql, lpSqlNode->node.tables.Table);
        FreeTreeSemantic(lpSql, lpSqlNode->node.tables.Next);
        break;

    case NODE_TYPE_VALUES:
        while (TRUE) {
            FreeTreeSemantic(lpSql, lpSqlNode->node.values.Value);
            if (lpSqlNode->node.values.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(lpSql, lpSqlNode->node.values.Next);
        }
        break;

    case NODE_TYPE_COLUMNS:
        while (TRUE) {
            FreeTreeSemantic(lpSql, lpSqlNode->node.columns.Column);
            if (lpSqlNode->node.columns.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(lpSql, lpSqlNode->node.columns.Next);
        }
        break;

    case NODE_TYPE_SORTCOLUMNS:
        while (TRUE) {
            FreeTreeSemantic(lpSql, lpSqlNode->node.sortcolumns.Column);
            if (lpSqlNode->node.sortcolumns.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(lpSql, lpSqlNode->node.sortcolumns.Next);
        }
        break;

    case NODE_TYPE_GROUPBYCOLUMNS:
        while (TRUE) {
            FreeTreeSemantic(lpSql, lpSqlNode->node.groupbycolumns.Column);
            if (lpSqlNode->node.groupbycolumns.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(lpSql, lpSqlNode->node.groupbycolumns.Next);
        }
        break;

    case NODE_TYPE_UPDATEVALUES:
        while (TRUE) {
            FreeTreeSemantic(lpSql, lpSqlNode->node.updatevalues.Column);
            FreeTreeSemantic(lpSql, lpSqlNode->node.updatevalues.Value);
            if (lpSqlNode->node.updatevalues.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(lpSql, lpSqlNode->node.updatevalues.Next);
        }
        break;

    case NODE_TYPE_CREATECOLS:
        while (TRUE) {
            if (lpSqlNode->node.createcols.Next == NO_SQLNODE)
                break;
            lpSqlNode = ToNode(lpSql, lpSqlNode->node.createcols.Next);
        }
        break;

    case NODE_TYPE_BOOLEAN:
        FreeTreeSemantic(lpSql, lpSqlNode->node.boolean.Left);
        FreeTreeSemantic(lpSql, lpSqlNode->node.boolean.Right);
        break;

    case NODE_TYPE_COMPARISON:
        FreeTreeSemantic(lpSql, lpSqlNode->node.comparison.Left);
        FreeTreeSemantic(lpSql, lpSqlNode->node.comparison.Right);
        break;

    case NODE_TYPE_ALGEBRAIC:
        FreeTreeSemantic(lpSql, lpSqlNode->node.algebraic.Left);
        FreeTreeSemantic(lpSql, lpSqlNode->node.algebraic.Right);
        break;

    case NODE_TYPE_SCALAR:
        FreeTreeSemantic(lpSql, lpSqlNode->node.scalar.Arguments);
        break;

    case NODE_TYPE_AGGREGATE:
        FreeTreeSemantic(lpSql, lpSqlNode->node.aggregate.Expression);
        break;

    case NODE_TYPE_TABLE:
        if (lpSqlNode->node.table.Handle != NULL) {
            ISAMCloseTable(lpSqlNode->node.table.Handle);
            lpSqlNode->node.table.Handle = NULL;
        }
        FreeTreeSemantic(lpSql, lpSqlNode->node.table.OuterJoinPredicate);
        break;

    case NODE_TYPE_COLUMN:
        break;

    case NODE_TYPE_STRING:
        break;

    case NODE_TYPE_NUMERIC:
        break;

    case NODE_TYPE_PARAMETER:
        break;
   
    case NODE_TYPE_USER:
        break;
   
    case NODE_TYPE_NULL:
        break;
   
    case NODE_TYPE_DATE:
        break;

    case NODE_TYPE_TIME:
        break;

    case NODE_TYPE_TIMESTAMP:
        break;

    default:
        break;
    }
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  SNMPDR.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\sort.cpp ===
/***************************************************************************/
/* SORT.CPP                                                                 */
/* Copyright (C) 1995-97 SYWARE Inc., All rights reserved                  */
/***************************************************************************/

// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"
/***************************************************************************/
#define SORT_MAX_FIELDS 20

typedef struct  tagSORT_SECTION {
    UWORD left;
    UWORD right;
} SORT_SECTION, FAR * SORT_SECTIONS;
        
typedef struct  tagSORT_KEY {
    UWORD offset;
    UWORD length;
    UCHAR type;
    BOOL  descending;
} SORT_KEY;

typedef struct  tagSORT_DATA {
    UWORD dupKeyLen;   /* Length of duplicate key (0 if no dup removal) */
    UWORD dupKeyStart; /* Zero-based offset of duplicate key */
    SORT_KEY key[SORT_MAX_FIELDS];
    UWORD keyCount;
    UWORD recordSize;
    UDWORD recordStart;
    UWORD recordCount;
    UWORD bufferRecordCount;
    LPSTR dataBuffer;
} SORT_DATA;

/***************************************************************************/

BOOL INTFUNC SortKeyCompare(SORT_DATA FAR *sortData, LPSTR leftRecordPtr,
                                     LPSTR rightRecordPtr)

/* Is the key of the left greater than or equal the key of the right? */

{
    SORT_KEY FAR *keyComponent;
    UWORD idx;
    LPSTR leftValuePtr;
    LPSTR rightValuePtr;
    int compare;
    UWORD leftDecimalPos;
    UWORD rightDecimalPos;

    /* Compare each key component */
    keyComponent = sortData->key;
    for (idx = 0; idx < sortData->keyCount; idx++) {

        /* Point at the values */
        leftValuePtr = leftRecordPtr + keyComponent->offset;
        rightValuePtr = rightRecordPtr + keyComponent->offset;

        /* Compare the values */
        switch (keyComponent->type) {
        case 'E':
            if ((*((double FAR *) leftValuePtr)) <
                                  (*((double FAR *) rightValuePtr)))
                compare = -1;
            else if ((*((double FAR *) leftValuePtr)) >
                                  (*((double FAR *) rightValuePtr)))
                compare = 1;   
            else
                compare = 0;
            break;
        case 'N':
            if (*rightValuePtr != '-') {
                if (*leftValuePtr != '-') {
                    for (leftDecimalPos = 0;
                         leftDecimalPos < keyComponent->length;
                         leftDecimalPos++) {
                       if ((*leftValuePtr == '.') || (*leftValuePtr == ' '))
                           break;
                       leftValuePtr++;
                    }
                    for (rightDecimalPos = 0;
                         rightDecimalPos < keyComponent->length;
                         rightDecimalPos++) {
                       if ((*rightValuePtr == '.') || (*rightValuePtr == ' '))
                           break;
                       rightValuePtr++;
                    }
                    if (leftDecimalPos > rightDecimalPos)
                        compare = 1;
                    else if (leftDecimalPos < rightDecimalPos)
                        compare = -1;
                    else {
                        leftValuePtr = leftRecordPtr + keyComponent->offset;
                        rightValuePtr = rightRecordPtr + keyComponent->offset;
                        compare = _fmemcmp(leftValuePtr, rightValuePtr,
                                        keyComponent->length);
                    }
                }
                else {
                    compare = -1;
                }
            }
            else {
                if (*leftValuePtr != '-') {
                    compare = 1;
                }
                else {
                    for (leftDecimalPos = 0;
                         leftDecimalPos < keyComponent->length;
                         leftDecimalPos++) {
                       if ((*leftValuePtr == '.') || (*leftValuePtr == ' '))
                           break;
                       leftValuePtr++;
                    }
                    for (rightDecimalPos = 0;
                         rightDecimalPos < keyComponent->length;
                         rightDecimalPos++) {
                       if ((*rightValuePtr == '.') || (*rightValuePtr == ' '))
                           break;
                       rightValuePtr++;
                    }
                    if (leftDecimalPos > rightDecimalPos)
                        compare = 1;
                    else if (leftDecimalPos < rightDecimalPos)
                        compare = -1;
                    else {
                        leftValuePtr = leftRecordPtr + keyComponent->offset;
                        rightValuePtr = rightRecordPtr + keyComponent->offset;
                        compare = _fmemcmp(leftValuePtr, rightValuePtr,
                                        keyComponent->length);
                    }
                    compare = -(compare);
                }
            }
            break;
        case 'C':
            compare = _fmemcmp(leftValuePtr, rightValuePtr,
                               keyComponent->length);
            break;
        }

        /* Adjust for ascending/descending */
        if (keyComponent->descending)
            compare = -compare;

        /* Return result */
        if (compare < 0)
            return FALSE;
        if (compare > 0)
            return TRUE;

        /* Look at next component */
        keyComponent++;
    }
    return TRUE;
}
/***************************************************************************/
RETCODE INTFUNC SortInstructions(LPSTR lpszInstructions,
                              SORT_DATA FAR *sortData)

/* Parse the instruction string.  The instruction string is in the form:    */
/*                                                                          */
/*   instuction_string ::= item | item instruction_string                   */
/*                                                                          */
/*   item ::= sort_item | fix_item | workdrive_item | dupout_item           */
/*                                                                          */
/*   sort_item ::= S(sort_list)                                             */
/*                                                                          */
/*   sort_list ::= sort_list_item | sort_list_item,sort_list                */
/*                                                                          */
/*   sort_list_item ::= offset,length,type,ascending_or_descending          */
/*                                                                          */
/*   offset ::= << 1-based record offset of sort key component >>           */
/*                                                                          */
/*   length ::= << length of sort key component >>                          */
/*                                                                          */
/*   type ::= type_double | type_number | type_character | type_binary      */
/*                                                                          */
/*   type_double ::= E                                                      */
/*                                                                          */
/*   type_ascii_numeric ::= N                                               */
/*                                                                          */
/*   type_character ::= C                                                   */
/*                                                                          */
/*   type_binary ::= W                                                      */
/*                                                                          */
/*   ascending_or_descending := ascending | descending                      */
/*                                                                          */
/*   ascending := A                                                         */
/*                                                                          */
/*   descending := D                                                        */
/*                                                                          */
/*   fix_item ::= F(FIX,recordsize)                                         */
/*                                                                          */
/*   recordsize ::= << size of the records in the sort file in bytes >>     */
/*                                                                          */
/*   workdrive_item ::= W(workdirive)                                       */
/*                                                                          */
/*   workdrive ::= << pathname of directory to hold temporary files >>      */
/*                                                                          */
/*   dupout_item ::= DUPO(Bdupout_buffer,dupout_offset,dupout_length)       */
/*                                                                          */
/*   dupout_buffer ::= << size of buffer to use during duplicate removal >> */
/*                                                                          */
/*   dupout_offset ::= << 1-based record offset of duplicate removal key >> */
/*                                                                          */
/*   dupout_length ::= << length duplicate removal key >>                   */
/*                                                                          */
/*      Notes: (1) If the sort key item is ascii_numeric, it is a number    */
/*                 represented as an ASCII string.  All the numbers in the  */
/*                 file must have the same number of digits to the right of */
/*                 the decimal point.  If there are no digits to the right  */
/*                 of the decimal point, the decimal point is not required, */
/*                 but if one record has a decimal point, they all have to  */
/*                 have decimal points.                                     */
/*                                                                          */
/*             (2) The workdrive is assumed to include a trailing backslash */
/*                                                                          */
/*             (3) The instruction string may not have embedded white space */
/*                                                                          */
/* This parser assumes that the instruction string given adheres to the     */
/* syntax above.  If the instruction string given is malformed, the results */
/* are undefined.                                                           */
{
    /* Get sorting instructions */
    sortData->dupKeyLen = 0;
    sortData->dupKeyStart = 0;
    sortData->recordSize = 0;
    sortData->keyCount = 0;
    while (*lpszInstructions) {

        /* Get the command */
        switch (*lpszInstructions) {
        case 'S':

            /* Parse: S(offset,length,type,asc,offset,length,type,asc,...) */
            lpszInstructions++;          /* 'S' */
            do {
                
                if (sortData->keyCount >= SORT_MAX_FIELDS) {
                    return ERR_SORT;
                }

                lpszInstructions++;      /* '(' or ',' */

                sortData->key[sortData->keyCount].offset = 0;
                do {
                    sortData->key[sortData->keyCount].offset *= (10);
                    sortData->key[sortData->keyCount].offset +=
                                                  (*lpszInstructions - '0');
                    lpszInstructions++;  /* '0' .. '9' */
                } while (*lpszInstructions != ',');
                (sortData->key[sortData->keyCount].offset)--;
                lpszInstructions++;      /* ',' */

                sortData->key[sortData->keyCount].length = 0;
                do {
                    sortData->key[sortData->keyCount].length *= (10);
                    sortData->key[sortData->keyCount].length +=
                                                  (*lpszInstructions - '0');
                    lpszInstructions++;  /* '0' .. '9' */
                } while (*lpszInstructions != ',');
                lpszInstructions++;      /* ',' */

                sortData->key[sortData->keyCount].type = *lpszInstructions;
                if (sortData->key[sortData->keyCount].type == 'W')
                    sortData->key[sortData->keyCount].type = 'C';
                lpszInstructions++;      /* 'E', 'N', 'C', or 'W' */
                lpszInstructions++;      /* ',' */

                if (*lpszInstructions == 'A')
                    sortData->key[sortData->keyCount].descending = FALSE;
                else
                    sortData->key[sortData->keyCount].descending = TRUE;
                lpszInstructions++;      /* 'A' or 'D' */

                (sortData->keyCount)++;
            
            } while (*lpszInstructions != ')');
            break;

        case 'F':
            
            /* Parse: F(FIX,recsize) */
            do {
                lpszInstructions++;      /* "F(FIX" */
            } while (*lpszInstructions != ',');
            lpszInstructions++;          /* ',' */

            do {
                sortData->recordSize *= (10);
                sortData->recordSize += (*lpszInstructions - '0');
                lpszInstructions++;      /* '0' .. '9' */
            } while (*lpszInstructions != ')');
            break;

        case 'W':

            /* Parse: W(workdir) */
            do {
                lpszInstructions++;      /* "W(workdir" */
            } while (*lpszInstructions != ')');
            break;

        case 'D':

            /* Parse: DUPO(Bbuffer,offset,length) */
            do {
                lpszInstructions++;      /* "DUPO(Bbuffer" */
            } while (*lpszInstructions != ',');
            lpszInstructions++;          /* ',' */
                
            do {
                sortData->dupKeyStart *= (10);
                sortData->dupKeyStart += (*lpszInstructions - '0');
                lpszInstructions++;      /* '0' .. '9' */
            } while (*lpszInstructions != ',');
            (sortData->dupKeyStart)--;
            lpszInstructions++;          /* ',' */

            do {
                sortData->dupKeyLen *= (10);
                sortData->dupKeyLen += (*lpszInstructions - '0');
                lpszInstructions++;      /* '0' .. '9' */
            } while (*lpszInstructions != ')');
            break;

        default:
            break;
        }
        lpszInstructions++;
    }
    sortData->recordStart = 0;
    sortData->recordCount = 0;
    sortData->bufferRecordCount = 0;
    sortData->dataBuffer = NULL;
    return ERR_SUCCESS;
}

/***************************************************************************/

BOOL INTFUNC QuickSortKeyCompare(SORT_DATA FAR *sortData, UWORD left,
                                     UWORD right)

/* Is the key of the left greater than or equal the key of the right? */

{
    LPSTR leftRecordPtr;
    LPSTR rightRecordPtr;

    /* Handle boundry conditions */
    if (left == sortData->recordCount + 1)
        return TRUE;
    if (right == 0)
        return TRUE;
    if (left == 0)
        return FALSE;
    if (right == sortData->recordCount + 1)
        return FALSE;

    /* Point at the records */
    leftRecordPtr = &(sortData->dataBuffer[left * sortData->recordSize]);
    rightRecordPtr = &(sortData->dataBuffer[right * sortData->recordSize]);

    /* Compare the keys */
    return SortKeyCompare(sortData, leftRecordPtr, rightRecordPtr);
}
/***************************************************************************/

RETCODE INTFUNC SortFile(HFILE hfileIn, HFILE hfileOut,
                         SORT_DATA FAR *sortData)

/* Sort one bunch of records.  A 'bunch' contains records n to (n + m), */
/* where n is specified by sortData->recordStart, m is specified by */
/* sortData->recordCount */

{
    UWORD leftBound;
    UWORD rightBound;
    UWORD entryToPutInPosition;
    LONG filesize;
    HGLOBAL hSections;
    SORT_SECTIONS sections;
    UWORD sectionsCount;

    /* Read records to sort */
    if (_llseek(hfileIn, ((UDWORD) sortData->recordStart) *
                        ((UDWORD) sortData->recordSize), 0) == HFILE_ERROR) {
        return ERR_SORT;
    }
    filesize = sortData->recordCount * sortData->recordSize;
    if (_lread(hfileIn, &(sortData->dataBuffer[sortData->recordSize]),
                                                   (UINT) filesize)
                  != (UINT) filesize) {
        return ERR_SORT;
    }

    /* Allocate space for list of sections to sort */
    sectionsCount = 0;
    hSections = GlobalAlloc(GMEM_MOVEABLE,
                         sizeof(SORT_SECTION) * sortData->bufferRecordCount);
    if (hSections == NULL) {
        return ERR_SORT;
    }
    sections = (SORT_SECTIONS) GlobalLock(hSections);
    if (sections == NULL) {
        GlobalFree(hSections);
        return ERR_SORT;
    }

    /* Initialize list of sections to sort to contain the entire bunch */
    /* provided */
    sections[0].left = 1;
    sections[0].right = sortData->recordCount;
    if (sections[0].right > sections[0].left)
        (sectionsCount)++;

    /* While there are still sections of the buffer to sort... */
    while (sectionsCount > 0) {

        /* Remove the definition of this section off the list */
        (sectionsCount)--;

        /* (Q2) We are going to look for the ultimate location of the */
        /* left-most element in the section.  Call the left-most entry */
        /* the "entry to put in position".  Point the left and right */
        /* bounds to everything except the entry to put in position. */
        /* While we are looking for this ultimate location, we will swap */
        /* records so that all the entries to the left of the ultimate */
        /* location are less than or equal to the entry to put in position */
        /* and all the entries to the right of the ultimate location are */
        /* greater than or equal to the entry to put in position. */
        entryToPutInPosition = sections[sectionsCount].left;
        leftBound = sections[sectionsCount].left;
        rightBound = sections[sectionsCount].right + 1;
        while (TRUE) {

            /* (Q3) Skip over entries on the left side that are less than */
            /* the entry to put in position */
            while (TRUE) {
                leftBound++;
                if (QuickSortKeyCompare(sortData, leftBound,
                                                  entryToPutInPosition))
                    break;
            }

            /* (Q4) Skip over entries on the right side that are greater */
            /* than the entry to put in position */
            while (TRUE) {
                rightBound--;
                if (QuickSortKeyCompare(sortData, entryToPutInPosition,
                                          rightBound))
                    break;
            }

            /* (Q5) Leave this loop if we have found the ultimate location */
            /* for the entry to put in position */
            if (rightBound <= leftBound)
                break;

            /* (Q6) At this point, the entry at the right bound is less */
            /* than or equal to the entry to put in position and the */
            /* entry at the left bound is greater than or equal to the */
            /* entry to put in position.  Swap these two entries and keep */
            /* looking for ultimate place for the entry to put in position */
            _fmemcpy(sortData->dataBuffer,
                   &(sortData->dataBuffer[leftBound * sortData->recordSize]),
                   sortData->recordSize);
            _fmemcpy(&(sortData->dataBuffer[leftBound * sortData->recordSize]),
                   &(sortData->dataBuffer[rightBound * sortData->recordSize]),
                   sortData->recordSize);
            _fmemcpy(&(sortData->dataBuffer[rightBound * sortData->recordSize]),
                   sortData->dataBuffer,
                   sortData->recordSize);
        }

        /* (Q5) Put the entry to put in position into its ultimate location */
        if (entryToPutInPosition != rightBound) {
            _fmemcpy(sortData->dataBuffer,
                 &(sortData->dataBuffer[entryToPutInPosition * sortData->recordSize]),
                 sortData->recordSize);
            _fmemcpy(&(sortData->dataBuffer[entryToPutInPosition * sortData->recordSize]),
                 &(sortData->dataBuffer[rightBound * sortData->recordSize]),
                 sortData->recordSize);
            _fmemcpy(&(sortData->dataBuffer[rightBound * sortData->recordSize]),
                 sortData->dataBuffer,
                 sortData->recordSize);
        }

        /* (Q8) Put the right half of the section onto the list of sections */ 
        /* to sort (it will sorted eventually) */
        sections[sectionsCount].left = rightBound+1;
        /* sections[sectionsCount].right is already set from before */
        if (sections[sectionsCount].right > sections[sectionsCount].left)
            (sectionsCount)++;

        /* (Q7) Put the left half of the section onto the list of sections */
        /* to sort (it will sorted next) */
        sections[sectionsCount].left = entryToPutInPosition;
        sections[sectionsCount].right = rightBound-1;
        if (sections[sectionsCount].right > sections[sectionsCount].left)
            (sectionsCount)++;
    }
    GlobalUnlock(hSections);
    GlobalFree(hSections);

    /* Write the sorted records to the file */
    if (_llseek(hfileOut, ((UDWORD) sortData->recordStart) *
                        ((UDWORD) sortData->recordSize), 0) == HFILE_ERROR) {
        return ERR_SORT;
    }
    if (_lwrite(hfileOut, &(sortData->dataBuffer[sortData->recordSize]),
                                                   (UINT) filesize)
                  != (UINT) filesize) {
        return ERR_SORT;
    }

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC MergeFile(HFILE hfile, SORT_DATA FAR *sortData,
                          UDWORD recordCount)

/* Merge the sorted bunches in the file.  To do this, we merge the last */
/* bunch (the "Beta" records) with the second to last bunch (the "Alpha" */
/* records).  We then merge the last two bunches (the "Beta" records) with */
/* the third to last bunch (the "Alpha" records), etc. until the entire */
/* file is merged. */

{
    UDWORD bunchCount;
    UWORD bunchSize;
    UWORD lastBunchSize;
    HGLOBAL hAlphaBuffer;
    LPSTR alphaBuffer;
    UDWORD currentAlphaBunch;
    LPSTR alphaRecord;
    UWORD alphaCounter;
    HGLOBAL hBetaBuffer;
    LPSTR betaBuffer;
    UDWORD nextBetaBunch;
    LPSTR betaRecord;
    UWORD betaCounter;
    UDWORD nextOutputBunch;
    LPSTR outputRecord;
    UWORD outputCounter;

    /* Return if nothing to merge */
    if ((UDWORD) sortData->bufferRecordCount == recordCount)
        return ERR_SUCCESS;

    /* Figure out how many bunches there are */
    bunchCount = ((recordCount - 1) / sortData->bufferRecordCount) + 1;

    /* Figure out the size of a bunch */
    bunchSize = sortData->bufferRecordCount;

    /* Figure out how big last bunch is */
    lastBunchSize = (UWORD) (recordCount - ((bunchCount - 1) * bunchSize));

    /* Get a buffer to read records.  This buffer will be used for the */
    /* "Alpha" records (th second to last bunch on the first iteration, */
    /* the third to last bunch on the second iteration, etc.) */
    hAlphaBuffer = GlobalAlloc(GMEM_MOVEABLE,
                                   sortData->recordSize * bunchSize);
    if (hAlphaBuffer == NULL) {
        return ERR_SORT;
    }
    alphaBuffer = (LPSTR) GlobalLock(hAlphaBuffer);
    if (alphaBuffer == NULL) {
        GlobalFree(hAlphaBuffer);
        return ERR_SORT;
    }

    /* Get another buffer to read records.  This buffer will be used for */
    /* the "Beta" records (the last bunch on the first iteration, the */
    /* second to last and last bunch on the second iteration, etc.) */
    hBetaBuffer = GlobalAlloc(GMEM_MOVEABLE, sortData->recordSize*bunchSize);
    if (hBetaBuffer == NULL) {
        GlobalUnlock(hAlphaBuffer);
        GlobalFree(hAlphaBuffer);
        return ERR_SORT;
    }
    betaBuffer = (LPSTR) GlobalLock(hBetaBuffer);
    if (betaBuffer == NULL) {
        GlobalFree(hBetaBuffer);
        GlobalUnlock(hAlphaBuffer);
        GlobalFree(hAlphaBuffer);
        return ERR_SORT;
    }

    /* Point at the first alpha bunch */
    currentAlphaBunch = bunchCount - 1;

    /* Do the merge. */
    do {

        /* Read the next alpha bunch */
        if (_llseek(hfile, ((UDWORD) (currentAlphaBunch - 1)) *
                           ((UDWORD) (sortData->recordSize * bunchSize)),
                                                         0) == HFILE_ERROR) {
            GlobalUnlock(hBetaBuffer);
            GlobalFree(hBetaBuffer);
            GlobalUnlock(hAlphaBuffer);
            GlobalFree(hAlphaBuffer);
            return ERR_SORT;
        }
        alphaRecord = alphaBuffer;
        alphaCounter = bunchSize;
        if (_lread(hfile, alphaBuffer,
                   (UINT) (sortData->recordSize * alphaCounter)) !=
                             (UINT) (sortData->recordSize * alphaCounter)) {
            GlobalUnlock(hBetaBuffer);
            GlobalFree(hBetaBuffer);
            GlobalUnlock(hAlphaBuffer);
            GlobalFree(hAlphaBuffer);
            return ERR_SORT;
        }

        /* Point at the output buffer */
        nextOutputBunch = currentAlphaBunch;
        outputRecord = sortData->dataBuffer;
        outputCounter = 0;

        /* Merge the alpha records with the beta records */
        nextBetaBunch = currentAlphaBunch + 1;
        betaCounter = 0;
        while (alphaCounter > 0) {

            /* Do we need more beta records? */
            if (betaCounter == 0) {

                /* Yes.  Leave loop if no more records. */
                if (nextBetaBunch > bunchCount)
                    break;

                /* Position to the next bunch of beta records */
                if (_llseek(hfile, ((UDWORD) (nextBetaBunch - 1)) *
                               ((UDWORD) (sortData->recordSize * bunchSize)),
                                                     0) == HFILE_ERROR) {
                    GlobalUnlock(hBetaBuffer);
                    GlobalFree(hBetaBuffer);
                    GlobalUnlock(hAlphaBuffer);
                    GlobalFree(hAlphaBuffer);
                    return ERR_SORT;
                }

                /* Read in the next bunch of beta records */
                betaRecord = betaBuffer;
                if (nextBetaBunch != bunchCount)
                    betaCounter = bunchSize;
                else
                    betaCounter = lastBunchSize;
                if (_lread(hfile, betaBuffer,
                           (UINT) (sortData->recordSize * betaCounter)) !=
                             (UINT) (sortData->recordSize * betaCounter)) {
                    GlobalUnlock(hBetaBuffer);
                    GlobalFree(hBetaBuffer);
                    GlobalUnlock(hAlphaBuffer);
                    GlobalFree(hAlphaBuffer);
                    return ERR_SORT;
                }

                nextBetaBunch++;
            }

            /* If the output buffer is full, write it out */
            if (outputCounter == bunchSize) {

                if (_llseek(hfile, ((UDWORD) (nextOutputBunch - 1)) *
                             ((UDWORD) (sortData->recordSize * bunchSize)),
                                                     0) == HFILE_ERROR) {
                    GlobalUnlock(hBetaBuffer);
                    GlobalFree(hBetaBuffer);
                    GlobalUnlock(hAlphaBuffer);
                    GlobalFree(hAlphaBuffer);
                    return ERR_SORT;
                }

                if (_lwrite(hfile, sortData->dataBuffer,
                       (UINT) (sortData->recordSize * outputCounter)) !=
                             (UINT) (sortData->recordSize * outputCounter)) {
                    GlobalUnlock(hBetaBuffer);
                    GlobalFree(hBetaBuffer);
                    GlobalUnlock(hAlphaBuffer);
                    GlobalFree(hAlphaBuffer);
                    return ERR_SORT;
                }

                /* Point at next output buffer */
                nextOutputBunch++;
                outputRecord = sortData->dataBuffer;
                outputCounter = 0;
            }

            /* Which record is next, the one in the alpha buffer or the */
            /* one in the beta buffer */
            if (SortKeyCompare(sortData, betaRecord, alphaRecord)) {

                /* The one in the alpha buffer.  Put it into output buffer */
                _fmemcpy(outputRecord, alphaRecord, sortData->recordSize);
                
                /* Point at next alpha record */
                alphaCounter--;
                alphaRecord += sortData->recordSize;
            }
            else {

                /* The one in the beta buffer.  Put it into output buffer */
                _fmemcpy(outputRecord, betaRecord, sortData->recordSize);

                /* Point at next beta record */
                betaCounter--;
                betaRecord += sortData->recordSize;
            }

            /* Point at next output record */
            outputCounter++;
            outputRecord += sortData->recordSize;
        }

        /* Write the remining records in the output buffer */
        
        if (_llseek(hfile, ((UDWORD) (nextOutputBunch - 1)) *
                           ((UDWORD) (sortData->recordSize * bunchSize)),
                                                    0) == HFILE_ERROR) {
            GlobalUnlock(hBetaBuffer);
            GlobalFree(hBetaBuffer);
            GlobalUnlock(hAlphaBuffer);
            GlobalFree(hAlphaBuffer);
            return ERR_SORT;
        }

		if (outputCounter > 0) {

            if (_lwrite(hfile, sortData->dataBuffer,
                       (UINT) (sortData->recordSize * outputCounter)) !=
                             (UINT) (sortData->recordSize * outputCounter)) {
                GlobalUnlock(hBetaBuffer);
                GlobalFree(hBetaBuffer);
                GlobalUnlock(hAlphaBuffer);
                GlobalFree(hAlphaBuffer);
                return ERR_SORT;
            }
        }

        /* Any more records in the beta buffer? */
        if (betaCounter > 0) {

            if (_lwrite(hfile, betaRecord,
                       (UINT) (sortData->recordSize * betaCounter)) !=
                             (UINT) (sortData->recordSize * betaCounter)) {
                GlobalUnlock(hBetaBuffer);
                GlobalFree(hBetaBuffer);
                GlobalUnlock(hAlphaBuffer);
                GlobalFree(hAlphaBuffer);
                return ERR_SORT;
            }
        }

        /* Any more records in the alpha buffer? */
        if (alphaCounter > 0) {

            if (_lwrite(hfile, alphaRecord,
                       (UINT) (sortData->recordSize * alphaCounter)) !=
                             (UINT) (sortData->recordSize * alphaCounter)) {
                GlobalUnlock(hBetaBuffer);
                GlobalFree(hBetaBuffer);
                GlobalUnlock(hAlphaBuffer);
                GlobalFree(hAlphaBuffer);
                return ERR_SORT;
            }
        }

        /* Do the next bunch */
        currentAlphaBunch--;

    } while (currentAlphaBunch != 0);

    /* Clean up */
    GlobalUnlock(hBetaBuffer);
    GlobalFree(hBetaBuffer);
    GlobalUnlock(hAlphaBuffer);
    GlobalFree(hAlphaBuffer);

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC RemoveDups(HFILE hfileIn, HFILE hfileOut,
                       SORT_DATA FAR *sortData, UDWORD FAR *lpRecordCount)

/* Removes the duplicate records.  The number of input records is */
/* specified by *lpRecordCount, the number of resultant records is */
/* returned in *lpRecordCount also */
{
    LONG filesize;
    UWORD idx;
    LPSTR prevRecordPtr;
    LPSTR thisRecordPtr;
    LPSTR prevKeyPtr;
    LPSTR thisKeyPtr;
    UDWORD recordsRemaining;
    BOOL firstTime;

    /* Position at the start of the files */
    if (_llseek(hfileIn, 0, 0) == HFILE_ERROR) {
        return ERR_SORT;
    }
    if (_llseek(hfileOut, 0, 0) == HFILE_ERROR) {
        return ERR_SORT;
    }

    /* While there are still some records... */
    firstTime = TRUE;
    recordsRemaining = *lpRecordCount;
    while (recordsRemaining > 0) {

        /* Find out how many records to look through this iteration */
        if (recordsRemaining <= sortData->bufferRecordCount)
            sortData->recordCount = (UWORD) recordsRemaining;
        else
            sortData->recordCount = sortData->bufferRecordCount;
        recordsRemaining -= (sortData->recordCount);

        /* If this is the first iteration, read the first bunch of records */
        /* into the very beginning of the buffer.  Otherwise, read them */
        /* into the next record position in order to preserve the first */
        /* record in the buffer. */
        filesize = sortData->recordCount * sortData->recordSize;
        if (firstTime) {
            if (_lread(hfileIn, sortData->dataBuffer, (UINT) filesize) !=
                                                        (UINT) filesize) {
                return ERR_SORT;
            }

            /* If this is the first iteration, remove the record in the */
            /* first position from the count (it will be added back in */
            /* when we do the last bunch) */
            (sortData->recordCount)--;
            firstTime = FALSE;
        }
        else {
            if (_lread(hfileIn, &(sortData->dataBuffer[sortData->recordSize]),
                                    (UINT) filesize) != (UINT) filesize) {
                return ERR_SORT;
            }
        }
        
        /* Point at the records to process */
        prevRecordPtr = sortData->dataBuffer;
        prevKeyPtr = prevRecordPtr + sortData->dupKeyStart;
        thisRecordPtr = prevRecordPtr + sortData->recordSize;
        thisKeyPtr = prevKeyPtr + sortData->recordSize;

        /* For each record... */
        for (idx = 1; idx < sortData->recordCount+1; idx++) {

            /* Is the record a duplicate of the previous one? */
            if (_fmemcmp(prevKeyPtr, thisKeyPtr, sortData->dupKeyLen) == 0) {

                /* Yes.  Remove it */
                _fmemcpy(prevRecordPtr, thisRecordPtr,
                   sortData->recordSize * (sortData->recordCount - idx + 1));

                /* Reduce record count */
                (*lpRecordCount)--;
                sortData->recordCount--;
                idx--;
            }
            else {

                /* No.  Point at next record */
                prevRecordPtr = thisRecordPtr;
                thisRecordPtr += (sortData->recordSize);
                prevKeyPtr = thisKeyPtr;
                thisKeyPtr += (sortData->recordSize);
            }
        }

        /* If there are no more records, write all the records in the */
        /* buffer (this is where we add back the record removed from the */
        /* first bunch) */
        if (recordsRemaining == 0)
            (sortData->recordCount)++;

        /* Are there any records to write? */
        if (sortData->recordCount > 0) {

            /* Yes.  Write them out */
            filesize = (sortData->recordCount) * sortData->recordSize;
            if (_lwrite(hfileOut, sortData->dataBuffer, (UINT) filesize) !=
                                            (UINT) filesize) {
                return ERR_SORT;
            }
        }

        /* Move the last record to the beginning of the buffer for the */
        /* next iteration */
        if (recordsRemaining != 0) {
            _fmemcpy(sortData->dataBuffer, prevRecordPtr,
                                                 sortData->recordSize);
        }
    }

    /* Set the end of file mark in the output file */
    if (_lwrite(hfileOut, sortData->dataBuffer, 0) != 0) {
        return ERR_SORT;
    }

    return ERR_SUCCESS;
}
/***************************************************************************/
#ifdef WIN32
void s_1mains(char * szFilenameIn, char * szFilenameOut,
              char * lpszInstructions, long * lpRecordCount, int * lpErrcode)
#else
void far PASCAL s_1mains(LPSTR szFilenameIn, LPSTR szFilenameOut,
              LPSTR lpszInstructions, LPLONG lpRecordCount, LPINT lpErrcode)
#endif
{
    LONG filesize;
    HGLOBAL hDataBuffer;
    UDWORD recordCount;
    UDWORD recordsRemaining;
    SORT_DATA sortData;
    HFILE hfileIn;
    HFILE hfileOut;

    /* Get sorting instructions */
    *lpErrcode = SortInstructions(lpszInstructions, &sortData);
    if (*lpErrcode != ERR_SUCCESS)
        return;

    /* Open input file */
    hfileIn = _lopen(szFilenameIn, OF_READWRITE);
    if (hfileIn == HFILE_ERROR) {
        *lpErrcode = ERR_SORT;
        return;
    }

    /* Figure out how many records there are */
    filesize = _llseek(hfileIn, 0, 2);
    if (filesize == HFILE_ERROR) {
        _lclose(hfileIn);
        *lpErrcode = ERR_SORT;
        return;
    }
    recordCount = ((UDWORD) filesize) / sortData.recordSize;

    /* Error if any incomplete records */
    if ((recordCount * sortData.recordSize) != (UDWORD) filesize) {
        _lclose(hfileIn);
        *lpErrcode = ERR_SORT;
        return;
    }

    /* Get buffer to read records into */
    if (filesize > (65536 - sortData.recordSize))
        sortData.bufferRecordCount = (UWORD) ((65536 - sortData.recordSize) /
                                                     sortData.recordSize);
    else
        sortData.bufferRecordCount = (UWORD) recordCount;
    hDataBuffer = GlobalAlloc(GMEM_MOVEABLE,
                     sortData.recordSize * (sortData.bufferRecordCount+1));
    if (hDataBuffer == NULL) {
        _lclose(hfileIn);
        *lpErrcode = ERR_SORT;
        return;
    }
    sortData.dataBuffer = (LPSTR) GlobalLock(hDataBuffer);
    if (sortData.dataBuffer == NULL) {
        GlobalFree(hDataBuffer);
        _lclose(hfileIn);
        *lpErrcode = ERR_SORT;
        return;
    }

    /* Open output file */
    hfileOut = _lopen(szFilenameOut, OF_READWRITE);
    if (hfileOut == HFILE_ERROR) {
        _lclose(hfileIn);
        *lpErrcode = ERR_SORT;
        return;
    }

    /* Sort the file (sortData.bufferRecordCount records at a time) */
    *lpErrcode = ERR_SUCCESS;
    sortData.recordStart = 0;
    recordsRemaining = recordCount;
    while ((*lpErrcode == ERR_SUCCESS) && (recordsRemaining > 0)) {
        
        /* Find out how many records in the next bunch to sort */
        if (recordsRemaining <= sortData.bufferRecordCount)
            sortData.recordCount = (UWORD) recordsRemaining;
        else
            sortData.recordCount = sortData.bufferRecordCount;
        recordsRemaining -= (sortData.recordCount);

        /* Sort the next bunch of records */
        if (sortData.dupKeyLen == 0)
            *lpErrcode = SortFile(hfileIn, hfileOut, &sortData);
        else
            *lpErrcode = SortFile(hfileIn, hfileIn, &sortData);

        /* Point at next bunch of records */
        sortData.recordStart += (sortData.recordCount);
    }

    /* Merge the file */
    if (*lpErrcode == ERR_SUCCESS) {
        if (sortData.dupKeyLen == 0)
            *lpErrcode = MergeFile(hfileOut, &sortData, recordCount);
        else
            *lpErrcode = MergeFile(hfileIn, &sortData, recordCount);
    }

    /* Remove the duplicates */
    if ((*lpErrcode == ERR_SUCCESS) && (sortData.dupKeyLen != 0))
        *lpErrcode = RemoveDups(hfileIn, hfileOut, &sortData,
                                &recordCount);

    /* Clean up */
    _lclose(hfileOut);
    GlobalUnlock(hDataBuffer);
    GlobalFree(hDataBuffer);
    _lclose(hfileIn);

    /* Return final record count */
    *lpRecordCount = (LONG) recordCount;
    return;
}
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\util.cpp ===
/***************************************************************************/
/* UTIL.C                                                                  */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"
#include <stdio.h>
#include <time.h>
/***************************************************************************/
#define BIT_LOW_D        (          0.0)
#define BIT_HIGH_D       (          1.0)
#define STINY_LOW_D      (       -128.0)
#define STINY_HIGH_D     (        127.0)
#define UTINY_LOW_D      (          0.0)
#define UTINY_HIGH_D     (        255.0)
#define SSHORT_LOW_D     (     -32768.0)
#define SSHORT_HIGH_D    (      32767.0)
#define USHORT_LOW_D     (          0.0)
#define USHORT_HIGH_D    (      65535.0)
#define SLONG_LOW_D      (-2147483648.0)
#define SLONG_HIGH_D     ( 2147483647.0)
#define ULONG_LOW_D      (          0.0)
#define ULONG_HIGH_D     ( 4294967296.0)
#define FLOAT_LOW_D      (      -3.4E38)
#define FLOAT_HIGH_D     (       3.4E38)
#define DOUBLE_LOW_D     (     -1.7E308)
#define DOUBLE_HIGH_D    (      1.7E308)
#define BIT_LOW_I        (          0)
#define BIT_HIGH_I       (          1)
#define STINY_LOW_I      (       -128)
#define STINY_HIGH_I     (        127)
#define UTINY_LOW_I      (          0)
#define UTINY_HIGH_I     (        255)
#define SSHORT_LOW_I     (     -32768)
#define SSHORT_HIGH_I    (      32767)
#define USHORT_LOW_I     (          0)
#define USHORT_HIGH_I    (      65535)
#define SLONG_LOW_I      (-2147483648)
#define SLONG_HIGH_I     ( 2147483647)
#define ULONG_LOW_I      (          0)
#define ULONG_HIGH_I     ( 4294967295)
/***************************************************************************/

RETCODE INTFUNC CharToDouble (
        LPUSTR      lpChar,
        SDWORD     cbChar,
        BOOL       fIntegerOnly,
        double     dblLowBound,
        double     dblHighBound,
        double FAR *lpDouble)
{
    BOOL fNegative;
    SWORD iScale;
    RETCODE rc;
	BOOL fNegExp;
	SWORD iExponent;
	BOOL fFirstDigit;
	double scaleFactor;

    /* Deal with "bad" lengths */
    if (cbChar == SQL_NTS)
        cbChar = s_lstrlen(lpChar);
    if (cbChar < 0)
        cbChar = 0;

    /* Strip off leading blanks */
    while ((cbChar != 0) && (*lpChar == ' ')) {
        lpChar++;
        cbChar--;
    }

	/* Start looking for the number */
	fFirstDigit = TRUE;

    /* Get sign */
    if (cbChar != 0) {
        switch (*lpChar) {
        case '-':
            fNegative = TRUE;
            lpChar++;
            cbChar--;
			fFirstDigit = FALSE;
            break;
        case '+':
            fNegative = FALSE;
            lpChar++;
            cbChar--;
			fFirstDigit = FALSE;
            break;
        default:
            fNegative = FALSE;
            break;
        }
    }

    /* Error if empty */
//    if (cbChar == 0)
//        return ERR_ASSIGNMENTERROR;

    /* Get number */
    iScale = -1;
    *lpDouble = 0.0;
    rc = ERR_SUCCESS;
	fNegExp = FALSE;
	iExponent = 0;
    while ((cbChar != 0) && (*lpChar != ' ')) {
        switch (*lpChar) {
        case '0':
            *lpDouble = (*lpDouble * 10.0) + (*lpChar - '0');
            if (iScale != -1)
                iScale++;
			fFirstDigit = FALSE;
            break;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            *lpDouble = (*lpDouble * 10.0) + (*lpChar - '0');
            if (iScale != -1) {
                if (fIntegerOnly)
                    rc = ERR_DATATRUNCATED;
                iScale++;
            }
			fFirstDigit = FALSE;
            break;
        case '.':
            if (iScale != -1)
                return ERR_ASSIGNMENTERROR;
            iScale = 0;
			fFirstDigit = FALSE;
            break;
		case 'E':
		case 'e':
			if (fFirstDigit)
				return ERR_ASSIGNMENTERROR;
			lpChar++;
			cbChar--;
			if (cbChar == 0)
				return ERR_ASSIGNMENTERROR;
			switch (*lpChar)
			{
				case '-':
					fNegExp = TRUE;
					lpChar++;
					cbChar--;
					break;
				case '+':
					lpChar++;
					cbChar--;
					break;
				default:
					break;
			}
			if ((cbChar == 0) || (*lpChar == ' '))
				return ERR_ASSIGNMENTERROR;
			while ((cbChar != 0) && (*lpChar != ' '))
			{
				switch (*lpChar)
				{
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						iExponent = (iExponent * 10) + (*lpChar - '0');
						break;
					default:
						return ERR_ASSIGNMENTERROR;
				}
				lpChar++;
				cbChar--;
			}
			lpChar--;
			cbChar++;
			break;
        default:
            return ERR_ASSIGNMENTERROR;
        }
        lpChar++;
        cbChar--;
    }

    /* Strip off trailing blanks */
    while ((cbChar != 0) && (*lpChar == ' ')) {
        lpChar++;
        cbChar--;
    }

    /* Error if garbage at the end of the string */
    if (cbChar != 0)
        return ERR_ASSIGNMENTERROR;

    /* Adjust for scale */
	if (iScale == -1)
		iScale = 0;

	iScale = -iScale;
	if (fNegExp)
		iScale -= (iExponent);
	else
		iScale += (iExponent);


	scaleFactor = 1.0;
    while (iScale > 0) {
        scaleFactor = scaleFactor * 10.0;
        iScale--;
    }
	*lpDouble = *lpDouble * scaleFactor;

	
	scaleFactor = 1.0;
    while (iScale < 0) {
        scaleFactor = scaleFactor * 10.0;
        iScale++;
    }
	*lpDouble = *lpDouble / scaleFactor;

    /* Adjust for negative */
    if (fNegative)
      *lpDouble = -(*lpDouble);

    /* Error if out of range */
    if ((dblLowBound > *lpDouble) || (*lpDouble > dblHighBound))
        return ERR_OUTOFRANGE;

    return rc;
}

/***************************************************************************/

BOOL INTFUNC DoubleToChar (
        double    dbl,
		BOOL	  ScientificNotationOK,
        LPUSTR     lpChar,
        SDWORD    cbChar)
{
#ifdef WIN32
	UCHAR szBuffer[350];
#else
#ifdef _UNIX_
	UCHAR szBuffer[350];
#else
	static UCHAR szBuffer[350];
#endif
#endif

	LPUSTR ptr;
	szBuffer[0] = 0;
	sprintf ((char*)szBuffer, "%lf", dbl);
	ptr = szBuffer;
	while (*ptr != '\0')
	{
		if (*ptr == '.')
		{
			ptr = (szBuffer) + s_lstrlen(szBuffer) - 1;
			while (ptr > (LPUSTR)szBuffer)
			{
				if (*ptr == '.')
				{
					*ptr = '\0';
					break;
				}
				if (*ptr != '0')
					break;
				*ptr = '\0';
				ptr--;
			}
			break;
		}
		ptr++;
	}

	if (s_lstrlen((char*)szBuffer) < cbChar)
	{
		if (!s_lstrcmp((char*)szBuffer, "0") && (dbl != 0.0) && ScientificNotationOK)
		{
			sprintf((char*)szBuffer, "%lE", dbl);
			if (s_lstrlen((char*)szBuffer) >= cbChar)
				return DoubleToChar(dbl, FALSE, lpChar, cbChar);
		}
		s_lstrcpy(lpChar, (char*)szBuffer);
		return FALSE;
	}
	else if (ScientificNotationOK)
	{
		sprintf((char*)szBuffer, "%lE", dbl);
		if (s_lstrlen((char*)szBuffer) >= cbChar)
				return DoubleToChar(dbl, FALSE, lpChar, cbChar);
		lstrcpy((char*)lpChar, (char*)szBuffer);
		return FALSE;
	}
	else
	{
		_fmemcpy(lpChar, szBuffer, (SWORD) cbChar);
		return TRUE;
	}

}

/***************************************************************************/

RETCODE INTFUNC ReturnString (
        PTR        rgbValue,
        SWORD      cbValueMax,
        SWORD  FAR *pcbValue,
        LPCUSTR     lpstr)
{
    SWORD len;

    /* Get the length of the string */
    len = (SWORD) s_lstrlen(lpstr);

    /* Return length if need be */
    if (pcbValue != NULL)
        *pcbValue = len;

    /* Return string value if need be */
    if (rgbValue != NULL) {

        /* If string fits, just copy it */
        if (cbValueMax > len)
            s_lstrcpy((char*)rgbValue, lpstr);

        /* Otherwise truncate it to fit */
        else {
            if (cbValueMax > 0) {
                _fmemcpy(rgbValue, lpstr, cbValueMax);
                ((LPSTR)rgbValue)[cbValueMax-1] = '\0';
            }
            return ERR_DATATRUNCATED;
        }
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ReturnStringD (
        PTR        rgbValue,
        SDWORD     cbValueMax,
        SDWORD FAR *pcbValue,
        LPCUSTR     lpstr)
{
    SWORD len;

    /* Get the length of the string */
    len = (SWORD) s_lstrlen(lpstr);

    /* Return length if need be */
    if (pcbValue != NULL)
        *pcbValue = len;
    
    /* Return string value if need be */
    if (rgbValue != NULL) {
        
        /* If string fits, just copy it */
        if (cbValueMax > len)
            s_lstrcpy((char*)rgbValue, lpstr);

        /* Otherwise truncate it to fit */
        else {
            if (cbValueMax > 0) {
                _fmemcpy(rgbValue, lpstr, cbValueMax);
                ((LPSTR)rgbValue)[cbValueMax-1] = '\0';
            }
            return ERR_DATATRUNCATED;
        }
    }

    return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC ConvertSqlToC (
        SWORD      fSqlTypeIn,
        BOOL       fUnsignedAttributeIn,
        PTR        rgbValueIn,
        SDWORD     cbValueIn,
        SDWORD FAR *pcbOffset,
        SWORD      fCTypeOut,
        PTR        rgbValueOut,
        SDWORD     cbValueOutMax,
        SDWORD  FAR *pcbValueOut)
{
    SDWORD cbValue;
    BOOL fTruncated;
    RETCODE rc;
    UCHAR szBuffer[32];
    unsigned char  uchar;
    char           schar;
    unsigned short ushort;
    short          sshort;
    unsigned long  ulong;
    long           slong;
    double         dbl;
    float          flt;
    DATE_STRUCT    sDate;
    TIME_STRUCT    sTime;
    TIMESTAMP_STRUCT sTimestamp;
    DATE_STRUCT FAR *    lpDate;
    TIME_STRUCT FAR *    lpTime;
    TIMESTAMP_STRUCT FAR * lpTimestamp;
static time_t t;
    struct tm *ts;
    LPUSTR lpFrom;
    LPUSTR lpTo;
    SDWORD i;
    UCHAR nibble;

    /* If input is NULL, return NULL */
    if ((cbValueIn == SQL_NULL_DATA) || (rgbValueIn == NULL)) {

        /* Return NULL */
        if (pcbValueOut != NULL)
            *pcbValueOut = cbValueIn;

        /* If an rgbValueOut was given, put some reasonable value in it also */
        if ((rgbValueOut != NULL) && (cbValueIn == SQL_NULL_DATA)) {

            /* Convert SQL_C_DEFAULT to a real SQL_C_* type */
            if (SQL_C_DEFAULT == fCTypeOut) {
                switch (fSqlTypeIn) {
                case SQL_CHAR:
                case SQL_VARCHAR:
                case SQL_LONGVARCHAR:
                    fCTypeOut = SQL_C_CHAR;
                    break;
                case SQL_BIT:
                    fCTypeOut = SQL_C_BIT;
                    break;
                case SQL_TINYINT:
                    fCTypeOut = SQL_C_TINYINT;
                    break;
                case SQL_SMALLINT:
                    fCTypeOut = SQL_C_SHORT;
                    break;
                case SQL_INTEGER:
                    fCTypeOut = SQL_C_LONG;
                    break;
                case SQL_REAL:
                    fCTypeOut = SQL_C_FLOAT;
                    break;
                case SQL_DECIMAL:
                case SQL_NUMERIC:
                case SQL_BIGINT:
                    fCTypeOut = SQL_C_CHAR;
                    break;
                case SQL_FLOAT:
                case SQL_DOUBLE:
                    fCTypeOut = SQL_C_DOUBLE;
                    break;
                case SQL_BINARY:
                case SQL_VARBINARY:
                case SQL_LONGVARBINARY:
                    fCTypeOut = SQL_C_BINARY;
                    break;
                case SQL_DATE:
                    fCTypeOut = SQL_C_DATE;
                    break;
                case SQL_TIME:
                    fCTypeOut = SQL_C_TIME;
                    break;
                case SQL_TIMESTAMP:
                    fCTypeOut = SQL_C_TIMESTAMP;
                    break;
                default:
                    return ERR_NOTCAPABLE;
                }
            }

            /* Return a NULL value */
            switch (fCTypeOut) {
            case SQL_C_CHAR:
                if (cbValueOutMax > 0)
                    *((LPSTR) rgbValueOut) = '\0';
                break;
            case SQL_C_SHORT:
            case SQL_C_SSHORT:
            case SQL_C_USHORT:
                *((short far *) rgbValueOut) = 0;
                break;
            case SQL_C_LONG:
            case SQL_C_SLONG:
            case SQL_C_ULONG:
                *((long far *) rgbValueOut) = 0;
                break;
            case SQL_C_FLOAT:
                *((float far *) rgbValueOut) = (float) 0.0;
                break;
            case SQL_C_DOUBLE:
                *((double far *) rgbValueOut) = 0.0;
                break;
            case SQL_C_BIT:
                *((char far *) rgbValueOut) = 0;
                break;
            case SQL_C_TINYINT:
            case SQL_C_STINYINT:
            case SQL_C_UTINYINT:
                *((char far *) rgbValueOut) = 0;
                break;
            case SQL_C_BINARY:
                break;
            case SQL_C_DATE:
                ((DATE_STRUCT far *) rgbValueOut)->year = 0;
                ((DATE_STRUCT far *) rgbValueOut)->month = 0;
                ((DATE_STRUCT far *) rgbValueOut)->day = 0;
                break;
            case SQL_C_TIME:
                ((TIME_STRUCT far *) rgbValueOut)->hour = 0;
                ((TIME_STRUCT far *) rgbValueOut)->minute = 0;
                ((TIME_STRUCT far *) rgbValueOut)->second = 0;
                break;
            case SQL_C_TIMESTAMP:
                ((TIMESTAMP_STRUCT far *) rgbValueOut)->year = 0;
                ((TIMESTAMP_STRUCT far *) rgbValueOut)->month = 0;
                ((TIMESTAMP_STRUCT far *) rgbValueOut)->day = 0;
                ((TIMESTAMP_STRUCT far *) rgbValueOut)->hour = 0;
                ((TIMESTAMP_STRUCT far *) rgbValueOut)->minute = 0;
                ((TIMESTAMP_STRUCT far *) rgbValueOut)->second = 0;
                ((TIMESTAMP_STRUCT far *) rgbValueOut)->fraction = 0;
                break;
            default:
                return ERR_NOTCONVERTABLE;
            }
        }
        return ERR_SUCCESS;
    }

    /* Figure out if the type is signed or unsigned */
//    lpSqlType = GetType(fSqlTypeIn);
//    if (lpSqlType == NULL)
//        unsignedAttribute = FALSE;
//    else if (lpSqlType->unsignedAttribute == -1)
//        unsignedAttribute = FALSE;
//    else
//        unsignedAttribute = lpSqlType->unsignedAttribute;
//
//	//If signed column info is passed through used this
//	if (fIsSigned)
//		unsignedAttribute = -1;


    /* Convert the data */
    fTruncated = FALSE;
    switch (fSqlTypeIn) {
    case SQL_CHAR:
    case SQL_VARCHAR:
    case SQL_LONGVARCHAR:
    case SQL_DECIMAL:
    case SQL_NUMERIC:
    case SQL_BIGINT:

        switch (fCTypeOut) {
        case SQL_C_DEFAULT:
        case SQL_C_CHAR:

            /* Get length of input string */
            if (cbValueIn == SQL_NTS)
                cbValueIn = s_lstrlen((char*)rgbValueIn);
            else if (cbValueIn < 0)
                cbValueIn = 0;

            /* Figure out how many bytes to copy */
            cbValue = cbValueIn - *pcbOffset;
            if (cbValue >= cbValueOutMax) {
                cbValue = cbValueOutMax-1;
                fTruncated = TRUE;
            }

            /* Copy the string */
            if (rgbValueOut != NULL) {
                _fmemcpy(rgbValueOut, ((LPSTR) rgbValueIn) + *pcbOffset,
                         (SWORD) cbValue);

                    ((LPSTR) rgbValueOut)[cbValue] = '\0';
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = cbValueIn - *pcbOffset;

            /* Adjust offset */
            *pcbOffset += (cbValue);
            break;

        case SQL_C_SHORT:
        case SQL_C_SSHORT:
            rc = CharToDouble((LPUSTR)rgbValueIn, cbValueIn, TRUE, SSHORT_LOW_D,
                              SSHORT_HIGH_D, &dbl);
            if (rc == ERR_DATATRUNCATED)
                fTruncated = TRUE;
            else if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((short far *) rgbValueOut) = (short) dbl;
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_USHORT:
            rc = CharToDouble((LPUSTR)rgbValueIn, cbValueIn, TRUE, USHORT_LOW_D,
                              USHORT_HIGH_D, &dbl);
            if (rc == ERR_DATATRUNCATED)
                fTruncated = TRUE;
            else if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((unsigned short far *) rgbValueOut) = (unsigned short) dbl;
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_LONG:
        case SQL_C_SLONG:
            rc = CharToDouble((LPUSTR)rgbValueIn, cbValueIn, TRUE, SLONG_LOW_D,
                              SLONG_HIGH_D, &dbl);
            if (rc == ERR_DATATRUNCATED)
                fTruncated = TRUE;
            else if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((long far *) rgbValueOut) = (long) dbl;
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_ULONG:
            rc = CharToDouble((LPUSTR)rgbValueIn, cbValueIn, TRUE, ULONG_LOW_D,
                              ULONG_HIGH_D, &dbl);
            if (rc == ERR_DATATRUNCATED)
                fTruncated = TRUE;
            else if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((unsigned long far *) rgbValueOut) = (unsigned long) dbl;
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_FLOAT:
            rc = CharToDouble((LPUSTR)rgbValueIn, cbValueIn, FALSE, FLOAT_LOW_D,
                              FLOAT_HIGH_D, &dbl);
            if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((float far *) rgbValueOut) = (float) dbl;
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_DOUBLE:
            rc = CharToDouble((LPUSTR)rgbValueIn, cbValueIn, FALSE, DOUBLE_LOW_D,
                              DOUBLE_HIGH_D, &dbl);
            if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((double far *) rgbValueOut) = (double) dbl;
            if (pcbValueOut != NULL)
                *pcbValueOut = 8;
            break;

        case SQL_C_BIT:
            rc = CharToDouble((LPUSTR)rgbValueIn, cbValueIn, TRUE, BIT_LOW_D,
                              BIT_HIGH_D, &dbl);
            if (rc == ERR_DATATRUNCATED)
                fTruncated = TRUE;
            else if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((unsigned char far *) rgbValueOut) = (unsigned char) dbl;
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_TINYINT:
        case SQL_C_STINYINT:
            rc = CharToDouble((LPUSTR)rgbValueIn, cbValueIn, TRUE, STINY_LOW_D,
                              STINY_HIGH_D, &dbl);
            if (rc == ERR_DATATRUNCATED)
                fTruncated = TRUE;
            else if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((char far *) rgbValueOut) = (char) dbl;
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_UTINYINT:
            rc = CharToDouble((LPUSTR)rgbValueIn, cbValueIn, TRUE, UTINY_LOW_D,
                              UTINY_HIGH_D, &dbl);
            if (rc == ERR_DATATRUNCATED)
                fTruncated = TRUE;
            else if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((unsigned char far *) rgbValueOut) = (unsigned char) dbl;
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_DATE:
            rc = CharToDate((LPUSTR)rgbValueIn, cbValueIn, &sDate);
            if (rc == ERR_DATATRUNCATED)
                fTruncated = TRUE;
            else if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((DATE_STRUCT far *) rgbValueOut) = sDate;
            if (pcbValueOut != NULL)
                *pcbValueOut = 6;
            break;

        case SQL_C_TIME:
            rc = CharToTime((LPUSTR)rgbValueIn, cbValueIn, &sTime);
            if (rc == ERR_DATATRUNCATED)
                fTruncated = TRUE;
            else if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((TIME_STRUCT far *) rgbValueOut) = sTime;
            if (pcbValueOut != NULL)
                *pcbValueOut = 6;
            break;

        case SQL_C_TIMESTAMP:
            rc = CharToTimestamp((LPUSTR)rgbValueIn, cbValueIn, &sTimestamp);
            if (rc == ERR_DATATRUNCATED)
                fTruncated = TRUE;
            else if (rc != ERR_SUCCESS)
                return rc;
            if (rgbValueOut != NULL)
                *((TIMESTAMP_STRUCT far *) rgbValueOut) = sTimestamp;
            if (pcbValueOut != NULL)
                *pcbValueOut = 16;
            break;

        case SQL_C_BINARY:

            /* Get length of input string */
            if (cbValueIn == SQL_NTS)
                cbValueIn = s_lstrlen((char*)rgbValueIn);
            else if (cbValueIn < 0)
                cbValueIn = 0;

            /* Figure out how many bytes to copy */
            cbValue = cbValueIn - *pcbOffset;
            if (cbValue >= cbValueOutMax) {
                cbValue = cbValueOutMax;
                fTruncated = TRUE;
            }

            /* Copy the string */
            if (rgbValueOut != NULL) {
                _fmemcpy(rgbValueOut, ((LPSTR) rgbValueIn) + *pcbOffset,
                         (SWORD) cbValue);
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = cbValueIn - *pcbOffset;

            /* Adjust offset */
            *pcbOffset += (cbValue);
            break;

        default:
            return ERR_NOTCONVERTABLE;
        }
        break;

    case SQL_BIT:
        
        if (*((unsigned char far *) rgbValueIn))
            uchar = 1;
        else
            uchar = 0;
        
        switch (fCTypeOut) {
        case SQL_C_CHAR:

            if (uchar)
                return ConvertSqlToC(SQL_VARCHAR, FALSE, "1", 1,
                           pcbOffset, fCTypeOut, rgbValueOut, cbValueOutMax,
                           pcbValueOut);
            else
                return ConvertSqlToC(SQL_VARCHAR, FALSE, "0", 1,
                           pcbOffset, fCTypeOut, rgbValueOut, cbValueOutMax,
                           pcbValueOut);

        case SQL_C_SHORT:
        case SQL_C_SSHORT:
            if (rgbValueOut != NULL)
                *((short far *) rgbValueOut) = (short) uchar;
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_USHORT:
            if (rgbValueOut != NULL)
                *((unsigned short far *) rgbValueOut) = (unsigned short) uchar;
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_LONG:
        case SQL_C_SLONG:
            if (rgbValueOut != NULL)
                *((long far *) rgbValueOut) = (long) uchar;
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_ULONG:
            if (rgbValueOut != NULL)
                *((unsigned long far *) rgbValueOut) = (unsigned long) uchar;
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_FLOAT:
            if (rgbValueOut != NULL)
                *((float far *) rgbValueOut) = (float) uchar;
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_DOUBLE:
            if (rgbValueOut != NULL)
                *((double far *) rgbValueOut) = (double) uchar;
            if (pcbValueOut != NULL)
                *pcbValueOut = 8;
            break;

        case SQL_C_DEFAULT:
        case SQL_C_BIT:
            if (rgbValueOut != NULL)
                *((unsigned char far *) rgbValueOut) = (unsigned char) uchar;
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_TINYINT:
        case SQL_C_STINYINT:
            if (rgbValueOut != NULL)
                *((char far *) rgbValueOut) = (char) uchar;
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_UTINYINT:
            if (rgbValueOut != NULL)
                *((unsigned char far *) rgbValueOut) = (unsigned char) uchar;
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_DATE:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIME:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIMESTAMP:
            return ERR_NOTCONVERTABLE;

        case SQL_C_BINARY:
            if (rgbValueOut != NULL)
                *((unsigned char far *) rgbValueOut) = (unsigned char) uchar;
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        default:
            return ERR_NOTCONVERTABLE;
        }
        break;

    case SQL_TINYINT:

        if (fUnsignedAttributeIn)
            uchar = *((unsigned char far *) rgbValueIn);
        else
            schar = *((char far *) rgbValueIn);

        switch (fCTypeOut) {
        case SQL_C_CHAR:

            if (fUnsignedAttributeIn)
                wsprintf((LPSTR)szBuffer, "%u", (unsigned short) uchar);
            else
                wsprintf((LPSTR)szBuffer, "%d", (short) schar);

            return ConvertSqlToC(SQL_VARCHAR, FALSE, szBuffer, SQL_NTS,
                           pcbOffset, fCTypeOut, rgbValueOut, cbValueOutMax,
                           pcbValueOut);

        case SQL_C_SHORT:
        case SQL_C_SSHORT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((short far *) rgbValueOut) = (short) uchar;
                else
                    *((short far *) rgbValueOut) = (short) schar;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_USHORT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned short far *) rgbValueOut) = (unsigned short) uchar;
                else {
                    if (schar < USHORT_LOW_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned short far *) rgbValueOut) = (unsigned short) schar;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_LONG:
        case SQL_C_SLONG:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((long far *) rgbValueOut) = (long) uchar;
                else
                    *((long far *) rgbValueOut) = (long) schar;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_ULONG:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned long far *) rgbValueOut) = (unsigned long) uchar;
                else {
                    if (schar < ULONG_LOW_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned long far *) rgbValueOut) = (unsigned long) schar;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_FLOAT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((float far *) rgbValueOut) = (float) uchar;
                else
                    *((float far *) rgbValueOut) = (float) schar;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_DOUBLE:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((double far *) rgbValueOut) = (double) uchar;
                else
                    *((double far *) rgbValueOut) = (double) schar;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 8;
            break;

        case SQL_C_BIT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (uchar > BIT_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned char far *) rgbValueOut) = (unsigned char) uchar;
                }
                else {
                    if ((schar < BIT_LOW_I) || (schar > BIT_HIGH_I))
                        return ERR_OUTOFRANGE;
                    *((unsigned char far *) rgbValueOut) = (unsigned char) schar;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_TINYINT:
        case SQL_C_STINYINT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (uchar > STINY_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((char far *) rgbValueOut) = (char) uchar;
                }
                else
                    *((char far *) rgbValueOut) = (char) schar;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_UTINYINT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned char far *) rgbValueOut) = (unsigned char) uchar;
                else  {
                    if (schar < UTINY_LOW_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned char far *) rgbValueOut) = (unsigned char) schar;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_DEFAULT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned char far *) rgbValueOut) = (unsigned char) uchar;
                else
                    *((char far *) rgbValueOut) = (char) schar;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_DATE:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIME:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIMESTAMP:
            return ERR_NOTCONVERTABLE;

        case SQL_C_BINARY:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned char far *) rgbValueOut) = (unsigned char) uchar;
                else
                    *((char far *) rgbValueOut) = (char) schar;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        default:
            return ERR_NOTCONVERTABLE;
        }
        break;

    case SQL_SMALLINT:

        if (fUnsignedAttributeIn)
            ushort = *((unsigned short far *) rgbValueIn);
        else
            sshort = *((short far *) rgbValueIn);

        switch (fCTypeOut) {
        case SQL_C_CHAR:

            if (fUnsignedAttributeIn)
                wsprintf((LPSTR)szBuffer, "%u", (unsigned short) ushort);
            else
                wsprintf((LPSTR)szBuffer, "%d", (short) sshort);

            return ConvertSqlToC(SQL_VARCHAR, FALSE, szBuffer, SQL_NTS,
                           pcbOffset, fCTypeOut, rgbValueOut, cbValueOutMax,
                           pcbValueOut);

        case SQL_C_SHORT:
        case SQL_C_SSHORT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (ushort > SSHORT_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((short far *) rgbValueOut) = (short) ushort;
                }
                else
                    *((short far *) rgbValueOut) = (short) sshort;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_USHORT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned short far *) rgbValueOut) = (unsigned short) ushort;
                else {
                    if (sshort < USHORT_LOW_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned short far *) rgbValueOut) = (unsigned short) sshort;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_LONG:
        case SQL_C_SLONG:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((long far *) rgbValueOut) = (long) ushort;
                else
                    *((long far *) rgbValueOut) = (long) sshort;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_ULONG:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned long far *) rgbValueOut) = (unsigned long) ushort;
                else {
                    if (sshort < ULONG_LOW_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned long far *) rgbValueOut) = (unsigned long) sshort;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_FLOAT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((float far *) rgbValueOut) = (float) ushort;
                else
                    *((float far *) rgbValueOut) = (float) sshort;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_DOUBLE:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((double far *) rgbValueOut) = (double) ushort;
                else
                    *((double far *) rgbValueOut) = (double) sshort;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 8;
            break;

        case SQL_C_BIT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (ushort > BIT_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned char far *) rgbValueOut) = (unsigned char) ushort;
                }
                else {
                    if ((sshort < BIT_LOW_I) || (sshort > BIT_HIGH_I))
                        return ERR_OUTOFRANGE;
                    *((unsigned char far *) rgbValueOut) = (unsigned char) sshort;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_TINYINT:
        case SQL_C_STINYINT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (ushort > STINY_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((char far *) rgbValueOut) = (char) ushort;
                }
                else {
                    if ((sshort < STINY_LOW_I) || (sshort > STINY_HIGH_I))
                        return ERR_OUTOFRANGE;
                    *((char far *) rgbValueOut) = (char) sshort;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_UTINYINT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (ushort > UTINY_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned char far *) rgbValueOut) = (unsigned char) ushort;
                }
                else {
                    if ((sshort < UTINY_LOW_I) || (sshort > UTINY_HIGH_I))
                        return ERR_OUTOFRANGE;
                    *((unsigned char far *) rgbValueOut) = (unsigned char) sshort;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_DEFAULT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned short far *) rgbValueOut) = (unsigned short) ushort;
                else
                    *((short far *) rgbValueOut) = (short) sshort;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_DATE:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIME:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIMESTAMP:
            return ERR_NOTCONVERTABLE;

        case SQL_C_BINARY:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned short far *) rgbValueOut) = (unsigned short) ushort;
                else
                    *((short far *) rgbValueOut) = (short) sshort;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        default:
            return ERR_NOTCONVERTABLE;
        }
        break;

    case SQL_INTEGER:

        if (fUnsignedAttributeIn)
            ulong = *((unsigned long far *) rgbValueIn);
        else
            slong = *((long far *) rgbValueIn);

        switch (fCTypeOut) {
        case SQL_C_CHAR:

            if (fUnsignedAttributeIn)
                wsprintf((LPSTR)szBuffer, "%lu", (unsigned long) ulong);
            else
                wsprintf((LPSTR)szBuffer, "%ld", (long) slong);

            return ConvertSqlToC(SQL_VARCHAR, FALSE, szBuffer, SQL_NTS,
                           pcbOffset, fCTypeOut, rgbValueOut, cbValueOutMax,
                           pcbValueOut);

        case SQL_C_SHORT:
        case SQL_C_SSHORT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (ulong > SSHORT_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((short far *) rgbValueOut) = (short) ulong;
                }
                else {
                    if ((slong < SSHORT_LOW_I) || (slong > SSHORT_HIGH_I))
                        return ERR_OUTOFRANGE;
                    *((short far *) rgbValueOut) = (short) slong;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_USHORT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (ulong > USHORT_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned short far *) rgbValueOut) = (unsigned short) ulong;
                }
                else {
                    if ((slong < USHORT_LOW_I) || (slong > USHORT_HIGH_I))
                        return ERR_OUTOFRANGE;
                    *((unsigned short far *) rgbValueOut) = (unsigned short) slong;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_LONG:
        case SQL_C_SLONG:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (ulong > SLONG_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((long far *) rgbValueOut) = (long) ulong;
                }
                else
                    *((long far *) rgbValueOut) = (long) slong;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_ULONG:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned long far *) rgbValueOut) = (unsigned long) ulong;
                else {
                    if (slong < ULONG_LOW_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned long far *) rgbValueOut) = (unsigned long) slong;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_FLOAT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((float far *) rgbValueOut) = (float) ulong;
                else
                    *((float far *) rgbValueOut) = (float) slong;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_DOUBLE:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((double far *) rgbValueOut) = (double) ulong;
                else
                    *((double far *) rgbValueOut) = (double) slong;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 8;
            break;

        case SQL_C_BIT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (ulong > BIT_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned char far *) rgbValueOut) = (unsigned char) ulong;
                }
                else {
                    if ((slong < BIT_LOW_I) || (slong > BIT_HIGH_I))
                        return ERR_OUTOFRANGE;
                    *((unsigned char far *) rgbValueOut) = (unsigned char) slong;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_TINYINT:
        case SQL_C_STINYINT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (ulong > STINY_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((char far *) rgbValueOut) = (char) ulong;
                }
                else {
                    if ((slong < STINY_LOW_I) || (slong > STINY_HIGH_I))
                        return ERR_OUTOFRANGE;
                    *((char far *) rgbValueOut) = (char) slong;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_UTINYINT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn) {
                    if (ulong > UTINY_HIGH_I)
                        return ERR_OUTOFRANGE;
                    *((unsigned char far *) rgbValueOut) = (unsigned char) ulong;
                }
                else {
                    if ((slong < UTINY_LOW_I) || (slong > UTINY_HIGH_I))
                        return ERR_OUTOFRANGE;
                    *((unsigned char far *) rgbValueOut) = (unsigned char) slong;
                }
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_DEFAULT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned long far *) rgbValueOut) = (unsigned long) ulong;
                else
                    *((long far *) rgbValueOut) = (long) slong;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_DATE:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIME:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIMESTAMP:
            return ERR_NOTCONVERTABLE;

        case SQL_C_BINARY:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned long far *) rgbValueOut) = (unsigned long) ulong;
                else
                    *((long far *) rgbValueOut) = (long) slong;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        default:
            return ERR_NOTCONVERTABLE;
        }
        break;

    case SQL_REAL:
        
        flt = (*((float far *) rgbValueIn));
        switch (fCTypeOut) {
        case SQL_C_CHAR:
            if (rgbValueOut == NULL) {
                rgbValueOut = szBuffer;
                cbValueOutMax = sizeof(szBuffer);
            }
            fTruncated = DoubleToChar(flt, TRUE, (LPUSTR)rgbValueOut, cbValueOutMax);
            if (fTruncated)
                    ((LPSTR)rgbValueOut)[cbValueOutMax-1] = '\0';           

	    if (pcbValueOut != NULL) {
                if (!fTruncated)
                    *pcbValueOut = s_lstrlen((char*)rgbValueOut);
                else
                    *pcbValueOut = cbValueOutMax;
            }
            break;

        case SQL_C_SHORT:
        case SQL_C_SSHORT:
            if (rgbValueOut != NULL) {
                if ((flt < SSHORT_LOW_D) || (flt > SSHORT_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((short far *) rgbValueOut) = (short) flt;
                if (((float) *((short far *) rgbValueOut)) != flt)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_USHORT:
            if (rgbValueOut != NULL) {
                if ((flt < USHORT_LOW_D) || (flt > USHORT_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((unsigned short far *) rgbValueOut) = (unsigned short) flt;
                if (((float) *((unsigned short far *) rgbValueOut)) != flt)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_LONG:
        case SQL_C_SLONG:
            if (rgbValueOut != NULL) {
                if ((flt < SLONG_LOW_D) || (flt > SLONG_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((long far *) rgbValueOut) = (long) flt;
                if (((float) *((long far *) rgbValueOut)) != flt)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_ULONG:
            if (rgbValueOut != NULL) {
                if ((flt < ULONG_LOW_D) || (flt > ULONG_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((unsigned long far *) rgbValueOut) = (unsigned long) flt;
                if (((float) *((unsigned long far *) rgbValueOut)) != flt)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_FLOAT:
        case SQL_C_DEFAULT:
            if (rgbValueOut != NULL)
                *((float far *) rgbValueOut) = (float) flt;
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_DOUBLE:
            if (rgbValueOut != NULL)
                *((double far *) rgbValueOut) = (double) flt;
            if (pcbValueOut != NULL)
                *pcbValueOut = 8;
            break;

        case SQL_C_BIT:
            if (rgbValueOut != NULL) {
                if ((flt < BIT_LOW_D) || (flt > BIT_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((unsigned char far *) rgbValueOut) = (unsigned char) flt;
                if (((float) *((unsigned char far *) rgbValueOut)) != flt)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_TINYINT:
        case SQL_C_STINYINT:
            if (rgbValueOut != NULL) {
                if ((flt < STINY_LOW_D) || (flt > STINY_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((char far *) rgbValueOut) = (char) flt;
                if (((float) *((char far *) rgbValueOut)) != flt)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_UTINYINT:
            if (rgbValueOut != NULL) {
                if ((flt < UTINY_LOW_D) || (flt > UTINY_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((unsigned char far *) rgbValueOut) = (unsigned char) flt;
                if (((float) *((unsigned char far *) rgbValueOut)) != flt)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_DATE:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIME:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIMESTAMP:
            return ERR_NOTCONVERTABLE;

        case SQL_C_BINARY:
            if (rgbValueOut != NULL)
                *((float far *) rgbValueOut) = (float) flt;
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        default:
            return ERR_NOTCONVERTABLE;
        }
        break;

    case SQL_FLOAT:
    case SQL_DOUBLE:
        
        dbl = (*((double far *) rgbValueIn));
        switch (fCTypeOut) {
        case SQL_C_CHAR:
            if (rgbValueOut == NULL) {
                rgbValueOut = szBuffer;
                cbValueOutMax = sizeof(szBuffer);
            }
            fTruncated = DoubleToChar(dbl, TRUE, (LPUSTR)rgbValueOut, cbValueOutMax);
            if (fTruncated)
                    ((LPSTR)rgbValueOut)[cbValueOutMax-1] = '\0';            
            if (pcbValueOut != NULL) {
                if (!fTruncated)
                    *pcbValueOut = s_lstrlen((char*)rgbValueOut);
                else
                    *pcbValueOut = cbValueOutMax;
            }
            break;

        case SQL_C_SHORT:
        case SQL_C_SSHORT:
            if (rgbValueOut != NULL) {
                if ((dbl < SSHORT_LOW_D) || (dbl > SSHORT_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((short far *) rgbValueOut) = (short) dbl;
                if (((double) *((short far *) rgbValueOut)) != dbl)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_USHORT:
            if (rgbValueOut != NULL) {
                if ((dbl < USHORT_LOW_D) || (dbl > USHORT_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((unsigned short far *) rgbValueOut) = (unsigned short) dbl;
                if (((double) *((unsigned short far *) rgbValueOut)) != dbl)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_LONG:
        case SQL_C_SLONG:
            if (rgbValueOut != NULL) {
                if ((dbl < SLONG_LOW_D) || (dbl > SLONG_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((long far *) rgbValueOut) = (long) dbl;
                if (((double) *((long far *) rgbValueOut)) != dbl)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_ULONG:
            if (rgbValueOut != NULL) {
                if ((dbl < ULONG_LOW_D) || (dbl > ULONG_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((unsigned long far *) rgbValueOut) = (unsigned long) dbl;
                if (((double) *((unsigned long far *) rgbValueOut)) != dbl)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_FLOAT:
            if (rgbValueOut != NULL) {
                if ((dbl < FLOAT_LOW_D) || (dbl > FLOAT_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((float far *) rgbValueOut) = (float) dbl;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_DOUBLE:
        case SQL_C_DEFAULT:
            if (rgbValueOut != NULL)
                *((double far *) rgbValueOut) = (double) dbl;
            if (pcbValueOut != NULL)
                *pcbValueOut = 8;
            break;

        case SQL_C_BIT:
            if (rgbValueOut != NULL) {
                if ((dbl < BIT_LOW_D) || (dbl > BIT_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((unsigned char far *) rgbValueOut) = (unsigned char) dbl;
                if (((double) *((unsigned char far *) rgbValueOut)) != dbl)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_TINYINT:
        case SQL_C_STINYINT:
            if (rgbValueOut != NULL) {
                if ((dbl < STINY_LOW_D) || (dbl > STINY_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((char far *) rgbValueOut) = (char) dbl;
                if (((double) *((char far *) rgbValueOut)) != dbl)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_UTINYINT:
            if (rgbValueOut != NULL) {
                if ((dbl < UTINY_LOW_D) || (dbl > UTINY_HIGH_D))
                    return ERR_OUTOFRANGE;
                *((unsigned char far *) rgbValueOut) = (unsigned char) dbl;
                if (((double) *((unsigned char far *) rgbValueOut)) != dbl)
                    fTruncated = TRUE;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_DATE:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIME:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIMESTAMP:
            return ERR_NOTCONVERTABLE;

        case SQL_C_BINARY:
            if (rgbValueOut != NULL)
                *((double far *) rgbValueOut) = (double) dbl;
            if (pcbValueOut != NULL)
                *pcbValueOut = 8;
            break;

        default:
            return ERR_NOTCONVERTABLE;
        }
        break;

    case SQL_BINARY:
    case SQL_VARBINARY:
    case SQL_LONGVARBINARY:

        switch (fCTypeOut) {
        case SQL_C_CHAR:

            /* Get length of input */
            if (cbValueIn < 0)
                cbValueIn = 0;

            /* Figure out how many nibbles (not bytes) to copy */
            cbValue = (2 * cbValueIn) - *pcbOffset;
            if (cbValue >= cbValueOutMax) {
                cbValue = cbValueOutMax-1;
                fTruncated = TRUE;
            }

            /* Copy the value */
            lpFrom = (LPUSTR) rgbValueIn;
            lpTo = (LPUSTR) rgbValueOut;
            for (i = *pcbOffset; i < (*pcbOffset + cbValue); i++) {

                /* Get the next nibble */
                nibble = *lpFrom;
                if (((i/2) * 2) == i)
                    nibble = nibble >> 4;
                else
                    lpFrom++;
                nibble = nibble & 0x0F;

                /* Convert it to a character */
                if (nibble <= 9)
                    *lpTo = nibble + '0';
                else
                    *lpTo = (nibble-10) + 'A';
                lpTo++;
            }

            *lpTo = '\0';
            if (pcbValueOut != NULL)
                *pcbValueOut = (2 * cbValueIn) - *pcbOffset;

            /* Adjust offset */
            *pcbOffset += (cbValue);
            break;

        case SQL_C_SHORT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned short far *) rgbValueOut) =
                                     *((unsigned short far *) rgbValueIn);
                else
                    *((short far *) rgbValueOut) =
                                     *((short far *) rgbValueIn);
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_SSHORT:
            if (rgbValueOut != NULL)
                *((short far *) rgbValueOut) = *((short far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_USHORT:
            if (rgbValueOut != NULL)
                *((unsigned short far *) rgbValueOut) =
                                     *((unsigned short far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 2;
            break;

        case SQL_C_LONG:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned long far *) rgbValueOut) =
                                     *((unsigned long far *) rgbValueIn);
                else
                    *((long far *) rgbValueOut) =
                                     *((long far *) rgbValueIn);
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_SLONG:
            if (rgbValueOut != NULL)
                *((long far *) rgbValueOut) = *((long far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_ULONG:
            if (rgbValueOut != NULL)
                *((unsigned long far *) rgbValueOut) =
                                     *((unsigned long far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_FLOAT:
            if (rgbValueOut != NULL)
                *((float far *) rgbValueOut) = *((float far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 4;
            break;

        case SQL_C_DOUBLE:
            if (rgbValueOut != NULL)
                *((double far *) rgbValueOut) = *((double far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 8;
            break;

        case SQL_C_BIT:
            if (rgbValueOut != NULL)
                *((unsigned char far *) rgbValueOut) =
                                     *((unsigned char far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_TINYINT:
            if (rgbValueOut != NULL) {
                if (fUnsignedAttributeIn)
                    *((unsigned char far *) rgbValueOut) =
                                     *((unsigned char far *) rgbValueIn);
                else
                    *((char far *) rgbValueOut) =
                                     *((char far *) rgbValueIn);
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_STINYINT:
            if (rgbValueOut != NULL)
                *((char far *) rgbValueOut) = *((char far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_UTINYINT:
            if (rgbValueOut != NULL)
                *((unsigned char far *) rgbValueOut) =
                                     *((unsigned char far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 1;
            break;

        case SQL_C_DATE:
            if (rgbValueOut != NULL)
                *((DATE_STRUCT far *) rgbValueOut) =
                                      *((DATE_STRUCT far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 6;
            break;

        case SQL_C_TIME:
            if (rgbValueOut != NULL)
                *((TIME_STRUCT far *) rgbValueOut) =
                                      *((TIME_STRUCT far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 6;
            break;

        case SQL_C_TIMESTAMP:
            if (rgbValueOut != NULL)
                *((TIMESTAMP_STRUCT far *) rgbValueOut) =
                                      *((TIMESTAMP_STRUCT far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 16;
            break;

        case SQL_C_BINARY:
        case SQL_C_DEFAULT:
            /* Get length of input string */
            if (cbValueIn < 0)
                cbValueIn = 0;

            /* Figure out how many bytes to copy */
            cbValue = cbValueIn - *pcbOffset;
            if (cbValue > cbValueOutMax) {
                cbValue = cbValueOutMax;
                fTruncated = TRUE;
            }

            /* Copy the string */
            if (rgbValueOut != NULL) {
                _fmemcpy(rgbValueOut, ((LPSTR) rgbValueIn) + *pcbOffset,
                         (SWORD) cbValue);
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = cbValueIn - *pcbOffset;

            /* Adjust offset */
            *pcbOffset += (cbValue);
            break;

        default:
            return ERR_NOTCONVERTABLE;
        }
        break;

    case SQL_DATE:

        switch (fCTypeOut) {
        case SQL_C_CHAR:
            DateToChar((DATE_STRUCT far *) rgbValueIn, (LPUSTR)szBuffer);
            return ConvertSqlToC(SQL_VARCHAR, FALSE, szBuffer, SQL_NTS,
                           pcbOffset, fCTypeOut, rgbValueOut, cbValueOutMax,
                           pcbValueOut);

        case SQL_C_SHORT:
        case SQL_C_SSHORT:
        case SQL_C_USHORT:
        case SQL_C_LONG:
        case SQL_C_SLONG:
        case SQL_C_ULONG:
        case SQL_C_FLOAT:
        case SQL_C_DOUBLE:
        case SQL_C_BIT:
        case SQL_C_TINYINT:
        case SQL_C_STINYINT:
        case SQL_C_UTINYINT:
            return ERR_NOTCONVERTABLE;

        case SQL_C_DEFAULT:
        case SQL_C_DATE:
            if (rgbValueOut != NULL)
                *((DATE_STRUCT far *) rgbValueOut) =
                                          *((DATE_STRUCT far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 6;
            break;

        case SQL_C_TIME:
            return ERR_NOTCONVERTABLE;

        case SQL_C_TIMESTAMP:
            if (rgbValueOut != NULL) {
                lpTimestamp = (TIMESTAMP_STRUCT far *) rgbValueOut;
                lpDate = (DATE_STRUCT far *) rgbValueIn;
                lpTimestamp->year = lpDate->year;
                lpTimestamp->month = lpDate->month;
                lpTimestamp->day = lpDate->day;
                lpTimestamp->hour = 0;
                lpTimestamp->minute = 0;
                lpTimestamp->second = 0;
                lpTimestamp->fraction = 0;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 16;
            break;

        case SQL_C_BINARY:
            if (rgbValueOut != NULL)
                *((DATE_STRUCT far *) rgbValueOut) =
                                          *((DATE_STRUCT far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 6;
            break;

        default:
            return ERR_NOTCONVERTABLE;
        }
        break;

    case SQL_TIME:
        switch (fCTypeOut) {
        case SQL_C_CHAR:
            TimeToChar((TIME_STRUCT far *) rgbValueIn, (LPUSTR)szBuffer);
            return ConvertSqlToC(SQL_VARCHAR, FALSE, szBuffer, SQL_NTS,
                           pcbOffset, fCTypeOut, rgbValueOut, cbValueOutMax,
                           pcbValueOut);

        case SQL_C_SHORT:
        case SQL_C_SSHORT:
        case SQL_C_USHORT:
        case SQL_C_LONG:
        case SQL_C_SLONG:
        case SQL_C_ULONG:
        case SQL_C_FLOAT:
        case SQL_C_DOUBLE:
        case SQL_C_BIT:
        case SQL_C_TINYINT:
        case SQL_C_STINYINT:
        case SQL_C_UTINYINT:
            return ERR_NOTCONVERTABLE;

        case SQL_C_DATE:
            return ERR_NOTCONVERTABLE;

        case SQL_C_DEFAULT:
        case SQL_C_TIME:
            if (rgbValueOut != NULL)
                *((TIME_STRUCT far *) rgbValueOut) =
                                          *((TIME_STRUCT far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 6;
            break;

        case SQL_C_TIMESTAMP:
            if (rgbValueOut != NULL) {
                lpTimestamp = (TIMESTAMP_STRUCT far *) rgbValueOut;
                lpTime = (TIME_STRUCT far *) rgbValueIn;

                time(&t);
                ts = localtime(&t);

                lpTimestamp->year = ts->tm_year + 1900;
                lpTimestamp->month = ts->tm_mon + 1;
                lpTimestamp->day = (UWORD) ts->tm_mday;
                lpTimestamp->hour = lpTime->hour;
                lpTimestamp->minute = lpTime->minute;
                lpTimestamp->second = lpTime->second;
                lpTimestamp->fraction = 0;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 16;
            break;

        case SQL_C_BINARY:
            if (rgbValueOut != NULL)
                *((TIME_STRUCT far *) rgbValueOut) =
                                          *((TIME_STRUCT far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 6;
            break;

        default:
            return ERR_NOTCONVERTABLE;
        }
        break;

    case SQL_TIMESTAMP:
        switch (fCTypeOut) {
        case SQL_C_CHAR:
            TimestampToChar((TIMESTAMP_STRUCT far *) rgbValueIn, (LPUSTR)szBuffer);
            return ConvertSqlToC(SQL_VARCHAR, FALSE, szBuffer, SQL_NTS,
                           pcbOffset, fCTypeOut, rgbValueOut, cbValueOutMax,
                           pcbValueOut);

        case SQL_C_SHORT:
        case SQL_C_SSHORT:
        case SQL_C_USHORT:
        case SQL_C_LONG:
        case SQL_C_SLONG:
        case SQL_C_ULONG:
        case SQL_C_FLOAT:
        case SQL_C_DOUBLE:
        case SQL_C_BIT:
        case SQL_C_TINYINT:
        case SQL_C_STINYINT:
        case SQL_C_UTINYINT:
            return ERR_NOTCONVERTABLE;

        case SQL_C_DATE:
            if (rgbValueOut != NULL) {
                lpDate = (DATE_STRUCT far *) rgbValueOut;
                lpTimestamp = (TIMESTAMP_STRUCT far *) rgbValueIn;
                lpDate->year = lpTimestamp->year;
                lpDate->month = lpTimestamp->month;
                lpDate->day = lpTimestamp->day;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 6;
            break;

        case SQL_C_TIME:
            if (rgbValueOut != NULL) {
                lpTime = (TIME_STRUCT far *) rgbValueOut;
                lpTimestamp = (TIMESTAMP_STRUCT far *) rgbValueIn;
                lpTime->hour = lpTimestamp->hour;
                lpTime->minute = lpTimestamp->minute;
                lpTime->second = lpTimestamp->second;
            }
            if (pcbValueOut != NULL)
                *pcbValueOut = 6;
            break;

        case SQL_C_DEFAULT:
        case SQL_C_TIMESTAMP:
            if (rgbValueOut != NULL)
                *((TIMESTAMP_STRUCT far *) rgbValueOut) =
                                  *((TIMESTAMP_STRUCT far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 16;
            break;

        case SQL_C_BINARY:
            if (rgbValueOut != NULL)
                *((TIMESTAMP_STRUCT far *) rgbValueOut) =
                                  *((TIMESTAMP_STRUCT far *) rgbValueIn);
            if (pcbValueOut != NULL)
                *pcbValueOut = 16;
            break;

        default:
            return ERR_NOTCONVERTABLE;
        }
        break;

    default:
        return ERR_NOTCAPABLE;
    }

    if (fTruncated)
        return ERR_DATATRUNCATED;

    return ERR_SUCCESS;
}

/***************************************************************************/

BOOL INTFUNC PatternMatch(
        BOOL   fEscape,
        LPUSTR  lpCandidate,
        SDWORD cbCandidate,
        LPUSTR  lpPattern,
        SDWORD cbPattern,
        BOOL   fCaseSensitive)
{
    /* Take care of "special" lengths */
    if ((cbCandidate < 0) || (cbPattern < 0)) {

        /* Handle case where candidate is null-terminated */
        if (cbCandidate == SQL_NTS)
            return PatternMatch(fEscape, lpCandidate, s_lstrlen(lpCandidate),
                                lpPattern, cbPattern, fCaseSensitive);
        
        /* Handle case where pattern is null-terminated */
        else if (cbPattern == SQL_NTS)
            return PatternMatch(fEscape, lpCandidate, cbCandidate,
                                lpPattern, s_lstrlen(lpPattern),
                                fCaseSensitive);

        /* Handle case where candidate is null */
        else if (cbCandidate == SQL_NULL_DATA)
            return PatternMatch(fEscape, lpCandidate, 0,
                                lpPattern, cbPattern,
                                fCaseSensitive);

        /* Handle case where pattern is null */
        else if (cbPattern == SQL_NULL_DATA)
            return PatternMatch(fEscape, lpCandidate, cbCandidate,
                                lpPattern, 0,
                                fCaseSensitive);

        else
            return FALSE;
    }

	/* Remove trailing blanks */
	while ( (cbPattern > 0) && (lpPattern[cbPattern-1] == ' ') )
		cbPattern--;
	while ( (cbCandidate > 0) && (lpCandidate[cbCandidate-1] == ' ') )
		cbCandidate--;

    /* End of pattern? */
    if (cbPattern == 0) {

        /* Yes.  End of candidate? */
        if (cbCandidate == 0)

            /* Yes.  They match */
            return TRUE;

        else

            /* No.  They don't match */
            return FALSE;
    }

    else {

        /* No.  What is next pattern character? */
        switch (*lpPattern) {

        /* Match any single character. */
        case '_':

            /* End of candidate? */
            if (cbCandidate == 0)

                /* Yes.  No match */
                return FALSE;
            else

               /* No.  Comapre rest of both strings */
                return PatternMatch(fEscape, lpCandidate + 1, cbCandidate - 1,
                                    lpPattern + 1, cbPattern - 1,
                                    fCaseSensitive);

        /* Match zero-or more characters */
        case '%':

            /* End of candidate? */
            if (cbCandidate == 0)

                /* Yes.  Make sure rest of pattern matches too. */
                return PatternMatch(fEscape, lpCandidate, cbCandidate,
                                    lpPattern + 1, cbPattern - 1,
                                    fCaseSensitive);

            /* If you skip the first character of the candidate, does the   */
            /* rest of the candidate match the pattern (test to see if      */
            /* the '%' corresponds to one or more characters (the 'or more' */
            /* is done at the next recursive level)?                        */
            else if (PatternMatch(fEscape, lpCandidate + 1,
                                  cbCandidate - 1, lpPattern, cbPattern,
                                  fCaseSensitive))

                /* Yes.  We have a match */
                return TRUE;

            /* Does the rest of the pattern match the candidate (test to */
            /* see if the '%' corresponds to no characters)?             */
            else if (PatternMatch(fEscape, lpCandidate, cbCandidate,
                                  lpPattern + 1, cbPattern - 1,
                                  fCaseSensitive))

                /* Yes.  We have a match */
                return TRUE;

            else

                /* No match. */
                return FALSE;

        /* Single character match */
        default:

            /* Is it the escape character? */
            if (fEscape && (cbPattern > 1) && (*lpPattern == '\\')) {

                /* Yes.  Go to next character */
                cbPattern--;
                lpPattern++;
            }

            
            /* If the candidate is empty, no match */
            if (cbCandidate == 0)
                return FALSE;

            /* If the characters match, test the rest of the strings */
            else if (*lpCandidate == *lpPattern)
                return PatternMatch(fEscape, lpCandidate + 1, cbCandidate - 1,
                                    lpPattern + 1, cbPattern - 1,
                                    fCaseSensitive);

            /* Try a case insensitve match if allowed */
            else if (!fCaseSensitive) {
                if ((*lpCandidate >= 'a') && (*lpCandidate <= 'z')) {
                    if (((*lpCandidate - 'a') + 'A') == *lpPattern)
                        return PatternMatch(fEscape, lpCandidate + 1,
                                    cbCandidate - 1, lpPattern + 1,
                                    cbPattern - 1, fCaseSensitive);
                    else
                        return FALSE;
                }
                else if ((*lpPattern >= 'a') && (*lpPattern <= 'z')) {
                    if (*lpCandidate == ((*lpPattern - 'a') + 'A'))
                        return PatternMatch(fEscape, lpCandidate + 1,
                                    cbCandidate - 1, lpPattern + 1,
                                    cbPattern - 1, fCaseSensitive);
                    else
                        return FALSE;
                }
                else
                    return FALSE;
            }

            else
                return FALSE;
        }
    }
}

/***************************************************************************/

SDWORD INTFUNC TrueSize(LPUSTR lpStr, SDWORD cbStr, SDWORD cbMax)
{
    /* If no string, return 0 */
    if (lpStr == NULL)
        return 0;

    /* If zero terminated string, get length */
    if (cbStr == SQL_NTS)
        cbStr = s_lstrlen(lpStr);

    /* If bigger than mat, return the max */
    if (cbStr > cbMax)
        cbStr = cbMax;

    /* If a "special" length, return 0 */
    else if (cbStr < 0)
        cbStr = 0;

    /* Otherwise just return length of the string */
    return cbStr;
}
/***************************************************************************/
void INTFUNC DateToChar (
        DATE_STRUCT FAR *lpDate,
        LPUSTR     lpChar)
{
    wsprintf((LPSTR)lpChar, "%04d-%02u-%02u", lpDate->year, lpDate->month,
             lpDate->day);
}
/***************************************************************************/
void INTFUNC TimeToChar (
        TIME_STRUCT FAR *lpTime,
        LPUSTR     lpChar)
{
    wsprintf((LPSTR)lpChar, "%02u:%02u:%02u", lpTime->hour, lpTime->minute,
             lpTime->second);
}
/***************************************************************************/
void INTFUNC TimestampToChar (
        TIMESTAMP_STRUCT FAR *lpTimestamp,
        LPUSTR     lpChar)
{
    UCHAR szTemplate[36];
    UDWORD fraction;
    int i;
                                                   
    if (TIMESTAMP_SCALE > 0) {
        s_lstrcpy((LPSTR)szTemplate, "%04d-%02u-%02u %02u:%02u:%02u.%0");
        wsprintf((LPSTR)szTemplate + lstrlen((char*)szTemplate), "%1u", (UWORD) TIMESTAMP_SCALE);
	s_lstrcat((LPSTR)szTemplate, "lu");
        fraction = lpTimestamp->fraction;
        for (i = 9 - TIMESTAMP_SCALE; i != 0; i--)
            fraction = fraction/10;
        wsprintf((LPSTR)lpChar, (LPSTR)szTemplate,
             lpTimestamp->year, lpTimestamp->month, lpTimestamp->day,
             lpTimestamp->hour, lpTimestamp->minute, lpTimestamp->second,
             fraction);
    }
    else {
        wsprintf((LPSTR)lpChar, "%04d-%02u-%02u %02u:%02u:%02u",
             lpTimestamp->year, lpTimestamp->month, lpTimestamp->day,
             lpTimestamp->hour, lpTimestamp->minute, lpTimestamp->second);
    }
}
/***************************************************************************/
#define UPPER(c)	((((c) < 'a') || ((c) > 'z')) ? (c) : (((c) - 'a') + 'A'))

#define CHARCHECK(c)                         \
        if (cbChar == 0)                     \
            return ERR_NOTCONVERTABLE;       \
        if (UPPER (*ptr) != UPPER(c))                       \
            return ERR_NOTCONVERTABLE;       \
        ptr++;                               \
        cbChar--;

#define GETDIGIT(val)                        \
        if (cbChar == 0)                     \
            return ERR_NOTCONVERTABLE;       \
        if ((*ptr < '0') || (*ptr > '9'))    \
            return ERR_NOTCONVERTABLE;       \
        val = (val * 10) + (*ptr - '0');     \
        ptr++;                               \
        cbChar--;

#define CLEARBLANKS                               \
        while ((cbChar > 0) && (*ptr == ' ')) {   \
            ptr++;                                \
            cbChar--;                             \
        }

/***************************************************************************/
RETCODE INTFUNC CharToDate (
        LPUSTR      lpChar,
        SDWORD     cbChar,
        DATE_STRUCT FAR *lpDate)
{
    LPUSTR ptr;
    BOOL fEscape;
    BOOL fShorthand;

    /* Point to string */
    ptr = lpChar;
    if (cbChar == SQL_NTS)
        cbChar = s_lstrlen(lpChar);
    if (cbChar < 0)
        cbChar = 0;
    
    /* Clear leading blanks */
    CLEARBLANKS
    if (cbChar == 0)
        return ERR_NOTCONVERTABLE;

    /* Start of escape clause? */
    if (*ptr == '-') {

        /* Yes.  Set flags */
        fEscape = TRUE;
        fShorthand = FALSE;

        /* Point at the next character */
        ptr++;
        cbChar--;

        /* Make sure the rest of the escape clause is correct */
        CHARCHECK('-')
        CHARCHECK('(')
        CHARCHECK('*')

        CLEARBLANKS

        CHARCHECK('V')
        CHARCHECK('E')
        CHARCHECK('N')
        CHARCHECK('D')
        CHARCHECK('O')
        CHARCHECK('R')

        CLEARBLANKS

        CHARCHECK('(')

        CLEARBLANKS

        CHARCHECK('M')
        CHARCHECK('i')
        CHARCHECK('c')
        CHARCHECK('r')
        CHARCHECK('o')
        CHARCHECK('s')
        CHARCHECK('o')
        CHARCHECK('f')
        CHARCHECK('t')

        CLEARBLANKS

        CHARCHECK(')')

        CLEARBLANKS

        CHARCHECK(',')

        CLEARBLANKS

        CHARCHECK('P')
        CHARCHECK('R')
        CHARCHECK('O')
        CHARCHECK('D')
        CHARCHECK('U')
        CHARCHECK('C')
        CHARCHECK('T')

        CLEARBLANKS

        CHARCHECK('(')

        CLEARBLANKS

        CHARCHECK('O')
        CHARCHECK('D')
        CHARCHECK('B')
        CHARCHECK('C')

        CLEARBLANKS

        CHARCHECK(')')

        CLEARBLANKS

        CHARCHECK('d')

        CLEARBLANKS

        CHARCHECK('\'')
    }

    /* Start of shorthand? */
    else if (*ptr == '{') {

        /* Yes.  Set flags */
        fEscape = FALSE;
        fShorthand = TRUE;

        /* Point at the next character */
        ptr++;
        cbChar--;

        /* Make sure the rest of the escape clause is correct */
        CLEARBLANKS

        CHARCHECK('d')

        CLEARBLANKS

        CHARCHECK('\'')
    }

    /* Plain value? */
    else {

        /* Yes.  Set flags */
        fEscape = FALSE;
        fShorthand = FALSE;
    }

    /* Get year */
    lpDate->year = 0;
    GETDIGIT(lpDate->year)
    GETDIGIT(lpDate->year)
    GETDIGIT(lpDate->year)
    GETDIGIT(lpDate->year)

    /* Get separator */
    CHARCHECK('-')

    /* Get month */
    lpDate->month = 0;
    GETDIGIT(lpDate->month)
    GETDIGIT(lpDate->month)

    /* Get separator */
    CHARCHECK('-')

    /* Get day */
    lpDate->day = 0;
    GETDIGIT(lpDate->day)
    GETDIGIT(lpDate->day)

    /* Escape clause? */
    if (fEscape) {

        /* Make sure it is properly terminated */
        CHARCHECK('\'')

        CLEARBLANKS

        CHARCHECK('*')
        CHARCHECK(')')
        CHARCHECK('-')
        CHARCHECK('-')
    }

    /* Shorthand? */
    if (fShorthand) {

        /* Make sure it is properly terminated */
        CHARCHECK('\'')

        CLEARBLANKS

        CHARCHECK('}')
    }

    /* Make sure only trailing blanks */
    CLEARBLANKS
    if (cbChar != 0)
        return ERR_NOTCONVERTABLE;

    /* Make sure date is legal */
    if ((lpDate->year != 0) || (lpDate->month != 0) || (lpDate->day != 0)) {
        switch (lpDate->month) {
        case  1: /* January   */
        case  3: /* March     */
        case  5: /* May       */
        case  7: /* July      */
        case  8: /* August    */
        case 10: /* October   */
        case 12: /* December  */
            if ((lpDate->day < 1) || (lpDate->day > 31))
                return ERR_NOTCONVERTABLE;
            break;
        case  4: /* April     */
        case  6: /* June      */
        case  9: /* September */
        case 11: /* November  */
            if ((lpDate->day < 1) || (lpDate->day > 30))
                return ERR_NOTCONVERTABLE;
            break;
        case  2: /* February  */
            if (((lpDate->year / 400) * 400) == lpDate->year) {
                if ((lpDate->day < 1) || (lpDate->day > 29))
                    return ERR_NOTCONVERTABLE;
            }
            else if (((lpDate->year / 100) * 100) == lpDate->year) {
                if ((lpDate->day < 1) || (lpDate->day > 28))
                    return ERR_NOTCONVERTABLE;
            }
            else if (((lpDate->year / 4) * 4) == lpDate->year) {
                if ((lpDate->day < 1) || (lpDate->day > 29))
                    return ERR_NOTCONVERTABLE;
            }
            else {
            if ((lpDate->day < 1) || (lpDate->day > 28))
                return ERR_NOTCONVERTABLE;
            }
            break;
        default:
            return ERR_NOTCONVERTABLE;
        }
    }
    
    return 0;
}
/***************************************************************************/
RETCODE INTFUNC CharToTime (
        LPUSTR      lpChar,
        SDWORD     cbChar,
        TIME_STRUCT FAR *lpTime)
{
    LPUSTR ptr;
    BOOL fEscape;
    BOOL fShorthand;

    /* Point to string */
    ptr = lpChar;
    if (cbChar == SQL_NTS)
        cbChar = s_lstrlen(lpChar);
    if (cbChar < 0)
        cbChar = 0;
    
    /* Clear leading blanks */
    CLEARBLANKS
    if (cbChar == 0)
        return ERR_NOTCONVERTABLE;

    /* Start of escape clause? */
    if (*ptr == '-') {

        /* Yes.  Set flags */
        fEscape = TRUE;
        fShorthand = FALSE;

        /* Point at the next character */
        ptr++;
        cbChar--;

        /* Make sure the rest of the escape clause is correct */
        CHARCHECK('-')
        CHARCHECK('(')
        CHARCHECK('*')

        CLEARBLANKS

        CHARCHECK('V')
        CHARCHECK('E')
        CHARCHECK('N')
        CHARCHECK('D')
        CHARCHECK('O')
        CHARCHECK('R')

        CLEARBLANKS

        CHARCHECK('(')

        CLEARBLANKS

        CHARCHECK('M')
        CHARCHECK('i')
        CHARCHECK('c')
        CHARCHECK('r')
        CHARCHECK('o')
        CHARCHECK('s')
        CHARCHECK('o')
        CHARCHECK('f')
        CHARCHECK('t')

        CLEARBLANKS

        CHARCHECK(')')

        CLEARBLANKS

        CHARCHECK(',')

        CLEARBLANKS

        CHARCHECK('P')
        CHARCHECK('R')
        CHARCHECK('O')
        CHARCHECK('D')
        CHARCHECK('U')
        CHARCHECK('C')
        CHARCHECK('T')

        CLEARBLANKS

        CHARCHECK('(')

        CLEARBLANKS

        CHARCHECK('O')
        CHARCHECK('D')
        CHARCHECK('B')
        CHARCHECK('C')

        CLEARBLANKS

        CHARCHECK(')')

        CLEARBLANKS

        CHARCHECK('t')

        CLEARBLANKS

        CHARCHECK('\'')
    }

    /* Start of shorthand? */
    else if (*ptr == '{') {

        /* Yes.  Set flags */
        fEscape = FALSE;
        fShorthand = TRUE;

        /* Point at the next character */
        ptr++;
        cbChar--;

        /* Make sure the rest of the escape clause is correct */
        CLEARBLANKS

        CHARCHECK('t')

        CLEARBLANKS

        CHARCHECK('\'')
    }

    /* Plain value? */
    else {

        /* Yes.  Set flags */
        fEscape = FALSE;
        fShorthand = FALSE;
    }

    /* Get hour */
    lpTime->hour = 0;
    GETDIGIT(lpTime->hour)
    GETDIGIT(lpTime->hour)

    /* Get separator */
    CHARCHECK(':')

    /* Get minute */
    lpTime->minute = 0;
    GETDIGIT(lpTime->minute)
    GETDIGIT(lpTime->minute)

    /* Are seconds specified (or required)? */
    lpTime->second = 0;
    if (fEscape || fShorthand || ((cbChar != 0) && (*ptr == ':'))) {

        /* Yes.  Get separator */
        CHARCHECK(':')

        /* Get second */
        GETDIGIT(lpTime->second)
        GETDIGIT(lpTime->second)
    }

    /* Escape clause? */
    if (fEscape) {

        /* Make sure it is properly terminated */
        CHARCHECK('\'')

        CLEARBLANKS

        CHARCHECK('*')
        CHARCHECK(')')
        CHARCHECK('-')
        CHARCHECK('-')
    }

    /* Shorthand? */
    if (fShorthand) {

        /* Make sure it is properly terminated */
        CHARCHECK('\'')

        CLEARBLANKS

        CHARCHECK('}')
    }

    /* AM or PM specified? */
    CLEARBLANKS
    if (!fEscape && !fShorthand) {
    
        if (cbChar != 0) {
            switch (*ptr) { 
            case 'p':
            case 'P':
                lpTime->hour += (12);

                /* **** DROP DOWN TO NEXT CASE **** */

            case 'a':
            case 'A':

                /* **** CONTROL MAY COME HERE FROM PREVIOUS CASE **** */
                ptr++;
                cbChar--;
                if (cbChar != 0) {
                    switch (*ptr) { 
                    case 'm':
                    case 'M':
                    case ' ':
                        break;
                    default:
                        return ERR_NOTCONVERTABLE;
                    }
                    ptr++;
                    cbChar--;
                }
                break;

            default:
                return ERR_NOTCONVERTABLE;
            }
        }
        CLEARBLANKS
    }

    /* Make sure only trailing blanks */
    if (cbChar != 0)
        return ERR_NOTCONVERTABLE;

    /* Make sure time is legal */
    if (lpTime->hour > 23)
        return ERR_NOTCONVERTABLE;
    if (lpTime->minute > 59)
        return ERR_NOTCONVERTABLE;
    if (lpTime->second > 59)
        return ERR_NOTCONVERTABLE;

    return 0;
}
/***************************************************************************/
RETCODE INTFUNC CharToTimestamp (
        LPUSTR      lpChar,
        SDWORD     cbChar,
        TIMESTAMP_STRUCT FAR *lpTimestamp)
{
    LPUSTR ptr;
    BOOL fEscape;
    BOOL fShorthand;
    UWORD i;

    /* Point to string */
    ptr = lpChar;
    if (cbChar == SQL_NTS)
        cbChar = s_lstrlen(lpChar);
    if (cbChar < 0)
        cbChar = 0;
    
    /* Clear leading blanks */
    CLEARBLANKS
    if (cbChar == 0)
        return ERR_NOTCONVERTABLE;

    /* Start of escape clause? */
    if (*ptr == '-') {

        /* Yes.  Set flags */
        fEscape = TRUE;
        fShorthand = FALSE;

        /* Point at the next character */
        ptr++;
        cbChar--;

        /* Make sure the rest of the escape clause is correct */
        CHARCHECK('-')
        CHARCHECK('(')
        CHARCHECK('*')

        CLEARBLANKS

        CHARCHECK('V')
        CHARCHECK('E')
        CHARCHECK('N')
        CHARCHECK('D')
        CHARCHECK('O')
        CHARCHECK('R')

        CLEARBLANKS

        CHARCHECK('(')

        CLEARBLANKS

        CHARCHECK('M')
        CHARCHECK('i')
        CHARCHECK('c')
        CHARCHECK('r')
        CHARCHECK('o')
        CHARCHECK('s')
        CHARCHECK('o')
        CHARCHECK('f')
        CHARCHECK('t')

        CLEARBLANKS

        CHARCHECK(')')

        CLEARBLANKS

        CHARCHECK(',')

        CLEARBLANKS

        CHARCHECK('P')
        CHARCHECK('R')
        CHARCHECK('O')
        CHARCHECK('D')
        CHARCHECK('U')
        CHARCHECK('C')
        CHARCHECK('T')

        CLEARBLANKS

        CHARCHECK('(')

        CLEARBLANKS

        CHARCHECK('O')
        CHARCHECK('D')
        CHARCHECK('B')
        CHARCHECK('C')

        CLEARBLANKS

        CHARCHECK(')')

        CLEARBLANKS

        CHARCHECK('t')
        CHARCHECK('s')

        CLEARBLANKS

        CHARCHECK('\'')
    }

    /* Start of shorthand? */
    else if (*ptr == '{') {

        /* Yes.  Set flags */
        fEscape = FALSE;
        fShorthand = TRUE;

        /* Point at the next character */
        ptr++;
        cbChar--;

        /* Make sure the rest of the escape clause is correct */
        CLEARBLANKS

        CHARCHECK('t')
        CHARCHECK('s')

        CLEARBLANKS

        CHARCHECK('\'')
    }

    /* Plain value? */
    else {

        /* Yes.  Set flags */
        fEscape = FALSE;
        fShorthand = FALSE;
    }

    /* Get year */
    lpTimestamp->year = 0;
    GETDIGIT(lpTimestamp->year)
    GETDIGIT(lpTimestamp->year)
    GETDIGIT(lpTimestamp->year)
    GETDIGIT(lpTimestamp->year)

    /* Get separator */
    CHARCHECK('-')

    /* Get month */
    lpTimestamp->month = 0;
    GETDIGIT(lpTimestamp->month)
    GETDIGIT(lpTimestamp->month)

    /* Get separator */
    CHARCHECK('-')

    /* Get day */
    lpTimestamp->day = 0;
    GETDIGIT(lpTimestamp->day)
    GETDIGIT(lpTimestamp->day)

    /* Get separator */
    CHARCHECK(' ')

    /* Get hour */
    lpTimestamp->hour = 0;
    GETDIGIT(lpTimestamp->hour)
    GETDIGIT(lpTimestamp->hour)

    /* Get separator */
    CHARCHECK(':')

    /* Get minute */
    lpTimestamp->minute = 0;
    GETDIGIT(lpTimestamp->minute)
    GETDIGIT(lpTimestamp->minute)

    /* Get separator */
    CHARCHECK(':')

    /* Get second */
    lpTimestamp->second = 0;
    GETDIGIT(lpTimestamp->second)
    GETDIGIT(lpTimestamp->second)

    /* Is a fraction specified? */
    lpTimestamp->fraction = 0;
    if ((cbChar != 0) && (*ptr == '.')) {

        /* Yes.  Get separator */
        CHARCHECK('.')

        /* Get fraction */
        for (i=0; i < 9; i++) {
            if ((*ptr < '0') || (*ptr > '9'))
                break;
            GETDIGIT(lpTimestamp->fraction)
        }
        for (; i < 9; i++)
            lpTimestamp->fraction = lpTimestamp->fraction * 10;
    }

    /* Escape clause? */
    if (fEscape) {

        /* Make sure it is properly terminated */
        CHARCHECK('\'')

        CLEARBLANKS

        CHARCHECK('*')
        CHARCHECK(')')
        CHARCHECK('-')
        CHARCHECK('-')
    }

    /* Shorthand? */
    if (fShorthand) {

        /* Make sure it is properly terminated */
        CHARCHECK('\'')

        CLEARBLANKS

        CHARCHECK('}')
    }

    /* Make sure only trailing blanks */
    CLEARBLANKS
    if (cbChar != 0)
        return ERR_NOTCONVERTABLE;

    /* Make sure timestamp is legal */
    if ((lpTimestamp->year != 0) || (lpTimestamp->month != 0) ||
        (lpTimestamp->day != 0) || (lpTimestamp->hour != 0) ||
        (lpTimestamp->minute != 0) || (lpTimestamp->second != 0) ||
        (lpTimestamp->fraction != 0)) {
        switch (lpTimestamp->month) {
        case  1: /* January   */
        case  3: /* March     */
        case  5: /* May       */
        case  7: /* July      */
        case  8: /* August    */
        case 10: /* October   */
        case 12: /* December  */
            if ((lpTimestamp->day < 1) || (lpTimestamp->day > 31))
                return ERR_NOTCONVERTABLE;
            break;
        case  4: /* April     */
        case  6: /* June      */
        case  9: /* September */
        case 11: /* November  */
            if ((lpTimestamp->day < 1) || (lpTimestamp->day > 30))
                return ERR_NOTCONVERTABLE;
            break;
        case  2: /* February  */
            if (((lpTimestamp->year / 400) * 400) == lpTimestamp->year) {
                if ((lpTimestamp->day < 1) || (lpTimestamp->day > 29))
                    return ERR_NOTCONVERTABLE;
            }
            else if (((lpTimestamp->year / 100) * 100) == lpTimestamp->year) {
                if ((lpTimestamp->day < 1) || (lpTimestamp->day > 28))
                    return ERR_NOTCONVERTABLE;
            }
            else if (((lpTimestamp->year / 4) * 4) == lpTimestamp->year) {
                if ((lpTimestamp->day < 1) || (lpTimestamp->day > 29))
                    return ERR_NOTCONVERTABLE;
            }
            else {
                if ((lpTimestamp->day < 1) || (lpTimestamp->day > 28))
                    return ERR_NOTCONVERTABLE;
            }
            break;
        default:
            return ERR_NOTCONVERTABLE;
        }
    }
    
    if (lpTimestamp->hour > 23)
        return ERR_NOTCONVERTABLE;
    if (lpTimestamp->minute > 59)
        return ERR_NOTCONVERTABLE;
    if (lpTimestamp->second > 59)
        return ERR_NOTCONVERTABLE;

    return 0;
}
/***************************************************************************/
#ifndef WIN32
BOOL INTFUNC DeleteFile (
        LPCSTR      lpszFilename)
{
static UCHAR szFilename[MAX_PATHNAME_SIZE+1];
	szFilename[0] = 0;
    lstrcpy(szFilename, lpszFilename);
    remove(szFilename);
    return TRUE;
}
#endif
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\transact.cpp ===
/****************************************************************************/
/* TRANSASCT.C                                                              */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                   */
/****************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"

/****************************************************************************/
RETCODE INTFUNC TxnEnd(LPDBC lpdbc, BOOL fCommit)
{
    LPSTMT    lpstmt;
    RETCODE   err;
    
    /* Just leave if nothing to do */
    if (lpdbc->lpISAM == NULL)
        return ERR_SUCCESS;
    if (lpdbc->lpISAM->fTxnCapable == SQL_TC_NONE)
        return ERR_SUCCESS;

    /* Close all active statements */
    for (lpstmt = lpdbc->lpstmts; lpstmt != NULL; lpstmt = lpstmt->lpNext) {

        /* Close the statement */
        lpstmt->fStmtType = STMT_TYPE_NONE; /* (to prevent recursive loop) */
        err = SQLFreeStmt((HSTMT) lpstmt, SQL_CLOSE);
        if ((err != SQL_SUCCESS) && (err != SQL_SUCCESS_WITH_INFO)) {
            lpdbc->errcode = lpstmt->errcode;
            s_lstrcpy(lpdbc->szISAMError, lpstmt->szISAMError);
            return lpdbc->errcode;
        }

        /* Will the metadata survive the commit/rollback */
        if (lpdbc->lpISAM->fSchemaInfoTransactioned) {

            /* No.  Release all the prepared statements */
            if (lpstmt->lpSqlStmt != NULL) {
                FreeTree(lpstmt->lpSqlStmt);
                lpstmt->lpSqlStmt = NULL;
                lpstmt->fPreparedSql = FALSE;
                if (lpstmt->lpISAMStatement != NULL) {
                    ISAMFreeStatement(lpstmt->lpISAMStatement);
                    lpstmt->lpISAMStatement = NULL;
                }
            }
        }
    }

    /* Commit/rollback the operation */
    if (fCommit)
        err = ISAMCommitTxn(lpdbc->lpISAM);
    else
        err = ISAMRollbackTxn(lpdbc->lpISAM);
    if (err != NO_ISAM_ERR) {
        ISAMGetErrorMessage(lpdbc->lpISAM, lpdbc->szISAMError);
        return err;
    }

    /* Clear all the transaction flags */
    for (lpstmt = lpdbc->lpstmts; lpstmt != NULL; lpstmt = lpstmt->lpNext) {
        lpstmt->fISAMTxnStarted = FALSE;
        lpstmt->fDMLTxn = FALSE;
    }

    return ERR_SUCCESS;
}
/****************************************************************************/

RETCODE SQL_API SQLTransact(
    HENV    henv,
    HDBC    hdbc,
    UWORD   fType)
{
	//We currently don't support transactions
    LPENV lpenv;
    LPDBC lpdbc;
    RETCODE rc;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im ((LPDBC)hdbc, "SQLTransact");

    if (hdbc != SQL_NULL_HDBC) {
        lpdbc = (LPDBC) hdbc;
        switch (fType) {
        case SQL_COMMIT:
            lpdbc->errcode = TxnEnd(lpdbc, TRUE);
            if (lpdbc->errcode != ERR_SUCCESS)
                return SQL_ERROR;
            break;
        case SQL_ROLLBACK:
            lpdbc->errcode = TxnEnd(lpdbc, FALSE);
            if (lpdbc->errcode != ERR_SUCCESS)
                return SQL_ERROR;
            break;
        }
//        lpdbc->errcode = ERR_NOTSUPPORTED;
        lpdbc->errcode = ERR_SUCCESS;
    }
    else if (henv != SQL_NULL_HENV) {
        lpenv = (LPENV) henv;
        for (lpdbc = lpenv->lpdbcs; lpdbc != NULL; lpdbc = lpdbc->lpNext) {
            rc = SQLTransact(SQL_NULL_HENV, (HDBC) lpdbc, fType);
            if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO)) {
                lpenv->errcode = lpdbc->errcode;
                s_lstrcpy(lpenv->szISAMError, lpdbc->szISAMError);
                return SQL_ERROR;
            }
        }
//        lpenv->errcode = ERR_NOTSUPPORTED;
        lpenv->errcode = ERR_SUCCESS;
    }
    else
        return SQL_INVALID_HANDLE;

    return SQL_ERROR;
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\sqltype.h ===
/***************************************************************************/
/* SQLTYPE.H                                                               */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
/* Table of supported types */

/* For a description of these values, see SQLGetTypeInfo() in the ODBC spec. */
/* Use NULL or -1 to designate a null value. */

typedef struct  tagSQLTYPE {
	BOOL         supported;     /* Is this type supported by this driver? */
	LPUSTR        name;
	SWORD        type;
	UDWORD       precision;
	LPUSTR        prefix;
	LPUSTR        suffix;
	LPUSTR        params;
	SWORD        nullable;      /* Always SQL_NULLABLE in this implementation */
	SWORD        caseSensitive;
	SWORD        searchable;
	SWORD        unsignedAttribute;
	SWORD        money;
	SWORD        autoincrement;
	LPUSTR        localName;
	SWORD        minscale;
	SWORD        maxscale;
}       SQLTYPE,
	FAR *LPSQLTYPE;

extern SQLTYPE SQLTypes[];

/***************************************************************************/

/* Precisions for certian types.  The ODBC spec fixes them at these values */
/* but some people want to change them anyways                              */



//Some new precisions added by SMW 05/24/96
#define	DOUBLE_PRECISION  15
#define BOOL_PRECISION    1
#define REAL_PRECISION    7
#define ULONG_PRECISION   10
#define SLONG_PRECISION   ULONG_PRECISION + 1
#define UTINYINT_PRECISION 3
#define STINYINT_PRECISION UTINYINT_PRECISION + 1
#define DATE_PRECISION    10
#define TIME_PRECISION    8
#define SMALLINT_PRECISION 5
#define USHORT_PRECISION  4
#define SSHORT_PRECISION  5


/***************************************************************************/

/* The number of digits to the right of the decimal point in a timestamp */
/* Set this number to a value between 0 and 9                            */
#define TIMESTAMP_SCALE 6
/***************************************************************************/
/* Function prototypes */

UWORD INTFUNC NumTypes(void);
/* Returns the total number of ODBC types */


LPSQLTYPE INTFUNC GetType(SWORD fSqlType);
LPSQLTYPE INTFUNC GetType2(UCHAR* szTypeName);
/* Returns a pointer to the description of an SQL_* type */


/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\sqltype.cpp ===
/***************************************************************************/
/* SQLTYPE.C                                                               */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"

//#include  <windows.h>
//#include  <windowsx.h>

#undef ODBCVER
#define ODBCVER 0x0210
#include "sql.h"
#include "sqlext.h"

typedef unsigned char FAR*           LPUSTR;
typedef const unsigned char FAR*     LPCUSTR;

#include "util.h"
#include "sqltype.h"

#include "limits.h"

/***************************************************************************/
/* Precisions for certain types.  The ODBC spec fixes them at these values */
/* but some people want to change them anyways                             */

#define NUMERIC_PRECISION 15
#define DECIMAL_PRECISION 15
#define BIGINT_PRECISION  20

/***************************************************************************/
/* This module contains the definition of the ODBC SQL_* types.  For each  */
/* type supported by the driver (i.e., the SQL_* type that a column in a   */
/* table may have), the 'supported' flag is set to TRUE.  To add/remove    */
/* a type for your driver, set the 'supported' flag to TRUE/FALSE.         */
/*                                                                         */
/* If you map more than one type in the underlying database to a single    */
/* SQL_x type, add additional entries for these additional types (just     */
/* copy the existing entry for the SQL_x type, change the 'name' and       */ 
/* 'local_name' values to some unique value, and make any other needed     */
/* changes).  The first entry in SQLTypes[] for the SQL_x type must be the */
/* most general of all the types, because the system uses the that         */ 
/* description when figuring out the characteristics of values of that     */
/* type when manipulating them internally.  If you add additional entries, */
/* you will also have to update the implementation of ISAMGetColumnType()  */
/* in ISAM.C.                                                              */
/***************************************************************************/

SQLTYPE SQLTypes[] = {
    /* SQL_CHAR */
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "SMALL_STRING", 
    /* type              */ SQL_VARCHAR,
    /* precision         */ 254,  /* must be <= MAX_CHAR_LITERAL_LENGTH */
    /* prefix            */ (LPUSTR) "'",
    /* suffix            */ (LPUSTR) "'",
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ TRUE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "SMALL_STRING",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_BIGINT (SINT64)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "SINT64", 
    /* type              */ SQL_BIGINT,
    /* precision         */ 19,  
    /* prefix            */ NULL, //(LPUSTR) "'",
    /* suffix            */ NULL, //(LPUSTR) "'",
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ TRUE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "SINT64",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_BIGINT (UINT64)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "UINT64", 
    /* type              */ SQL_BIGINT,
    /* precision         */ 20,  
    /* prefix            */ NULL, //(LPUSTR) "'",
    /* suffix            */ NULL, //(LPUSTR) "'",
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ TRUE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1, //TRUE
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "UINT64",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARCHAR (STRING)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "STRING", 
    /* type              */ SQL_LONGVARCHAR,
    /* precision         */ ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ (LPUSTR) "'",
    /* suffix            */ (LPUSTR) "'",
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ TRUE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "STRING",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_DECIMAL */
    {
    /* supported         */ FALSE, 
    /* name              */ (LPUSTR) "DECIMAL", 
    /* type              */ SQL_DECIMAL,
    /* precision         */ DECIMAL_PRECISION,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "precision, scale",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "DECIMAL",
    /* minscale          */ 0,
    /* maxscale          */ DECIMAL_PRECISION,
    },
    /* SQL_NUMERIC */
    {
    /* supported         */ FALSE, 
    /* name              */ (LPUSTR) "NUMERIC", 
    /* type              */ SQL_NUMERIC,
    /* precision         */ NUMERIC_PRECISION,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "precision, scale",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "NUMERIC",
    /* minscale          */ 0,
    /* maxscale          */ NUMERIC_PRECISION,
    },
    /* SQL_TINYINT (SINT8)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "SINT8", 
    /* type              */ SQL_TINYINT,
    /* precision         */ 3,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ FALSE,
    /* localname         */ (LPUSTR) "SINT8",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_TINYINT (UINT8)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "UINT8", 
    /* type              */ SQL_TINYINT,
    /* precision         */ 3,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1, //TRUE
    /* money             */ FALSE,
    /* autoincrement     */ FALSE,
    /* localname         */ (LPUSTR) "UINT8",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_SMALLINT (SINT16) */
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "SINT16", 
    /* type              */ SQL_SMALLINT,
    /* precision         */ 5,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ FALSE,
    /* localname         */ (LPUSTR) "SINT16",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_SMALLINT (UINT16) */
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "UINT16", 
    /* type              */ SQL_SMALLINT,
    /* precision         */ 5,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1, // TRUE 
    /* money             */ FALSE,
    /* autoincrement     */ FALSE,
    /* localname         */ (LPUSTR) "UINT16",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_INTEGER (INTEGER)*/
    {
    /* supported         */ FALSE, 
    /* name              */ (LPUSTR) "INTEGER", 
    /* type              */ SQL_INTEGER,
    /* precision         */ 10,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ FALSE,
    /* localname         */ (LPUSTR) "INTEGER",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_INTEGER (SINT32)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "SINT32", 
    /* type              */ SQL_INTEGER,
    /* precision         */ 10,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ FALSE,
    /* localname         */ (LPUSTR) "SINT32",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_INTEGER (UINT32)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "UINT32", 
    /* type              */ SQL_INTEGER,
    /* precision         */ 10,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1, //TRUE
    /* money             */ FALSE,
    /* autoincrement     */ FALSE,
    /* localname         */ (LPUSTR) "UINT32",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_DOUBLE (REAL)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "REAL", 
    /* type              */ SQL_DOUBLE,
    /* precision         */ 7,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "REAL",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_DOUBLE (DOUBLE)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "DOUBLE", 
    /* type              */ SQL_DOUBLE,
    /* precision         */ 15,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "DOUBLE",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_BIT */
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "BIT", 
    /* type              */ SQL_BIT,
    /* precision         */ 1,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "BIT",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_DATE */
    {
    /* supported         */ FALSE, 
    /* name              */ (LPUSTR) "DATE", 
    /* type              */ SQL_DATE,
    /* precision         */ 10,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "DATE",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_TIME */
    {
    /* supported         */ FALSE, 
    /* name              */ (LPUSTR) "TIME", 
    /* type              */ SQL_TIME,
    /* precision         */ 8,
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "TIME",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_TIMESTAMP */
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "TIMESTAMP", 
    /* type              */ SQL_TIMESTAMP,
#if TIMESTAMP_SCALE
    /* precision         */ 20 + TIMESTAMP_SCALE,
#else
    /* precision         */ 19,
#endif
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "TIMESTAMP",
    /* minscale          */ TIMESTAMP_SCALE,
    /* maxscale          */ TIMESTAMP_SCALE,
    },
    /* SQL_TIMESTAMP  (INTERVAL) */
    {
    /* supported         */ FALSE, 
    /* name              */ (LPUSTR) "INTERVAL", 
    /* type              */ SQL_TIMESTAMP,
#if TIMESTAMP_SCALE
    /* precision         */ 20 + TIMESTAMP_SCALE,
#else
    /* precision         */ 19,
#endif
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL,
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "INTERVAL",
    /* minscale          */ TIMESTAMP_SCALE,
    /* maxscale          */ TIMESTAMP_SCALE,
    },
    /* SQL_LONGVARBINARY (SINT8_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "SINT8_ARRAY", 
    /* type              */ SQL_TINYINT, //SQL_LONGVARBINARY,
    /* precision         */ 3, //ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "SINT8_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (UINT8_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "UINT8_ARRAY", 
    /* type              */ SQL_TINYINT, //SQL_LONGVARBINARY,
    /* precision         */ 3, //ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "UINT8_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (SINT32_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "SINT32_ARRAY", 
    /* type              */ SQL_INTEGER, //SQL_LONGVARBINARY,
    /* precision         */ 10, //ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "SINT32_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (UINT32_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "UINT32_ARRAY", 
    /* type              */ SQL_INTEGER, //SQL_LONGVARBINARY,
    /* precision         */ 10, //ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1, //TRUE
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "UINT32_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (BOOL_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "BOOL_ARRAY", 
    /* type              */ SQL_BIT, //SQL_LONGVARBINARY,
    /* precision         */ 1, //ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL, //(LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "BOOL_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (SINT16_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "SINT16_ARRAY", 
    /* type              */ SQL_SMALLINT, //SQL_LONGVARBINARY,
    /* precision         */ 5, //ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "SINT16_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (UINT16_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "UINT16_ARRAY", 
    /* type              */ SQL_SMALLINT, //SQL_LONGVARBINARY,
    /* precision         */ 5, //ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "UINT16_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (REAL_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "REAL_ARRAY", 
    /* type              */ SQL_DOUBLE, //SQL_LONGVARBINARY,
    /* precision         */ 7, //ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL, //(LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "REAL_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (DOUBLE_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "DOUBLE_ARRAY", 
    /* type              */ SQL_DOUBLE, //SQL_LONGVARBINARY,
    /* precision         */ 15, //ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ NULL, //(LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE, //-1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "DOUBLE_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (SINT64_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "SINT64_ARRAY", 
    /* type              */ SQL_BIGINT, //SQL_LONGVARBINARY,
    /* precision         */ 19, //ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ FALSE,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "SINT64_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (UINT64_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              00000000000*/ (LPUSTR) "UINT64_ARRAY", 
    /* type              */ SQL_BIGINT, //SQL_LONGVARBINARY,
    /* precision         */ 20, //ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1, //TRUE
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "UINT64_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_VARCHAR (SMALL_STRING_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "SMALL_STRING_ARRAY", 
    /* type              */ SQL_VARCHAR, 
    /* precision         */ 254,  /* must be <= MAX_CHAR_LITERAL_LENGTH */
    /* prefix            */ (LPUSTR) "'", //NULL,
    /* suffix            */ (LPUSTR) "'", //NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ TRUE, //FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "SMALL_STRING_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINAR (STRING_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "STRING_ARRAY", 
    /* type              */ SQL_LONGVARCHAR, //SQL_LONGVARBINARY,
    /* precision         */ ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ (LPUSTR) "'", //NULL,
    /* suffix            */ (LPUSTR) "'", //NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ TRUE, //FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "STRING_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (TIMESTAMP_ARRAY)*/
    {
    /* supported         */ TRUE, 
    /* name              */ (LPUSTR) "TIMESTAMP_ARRAY", 
    /* type              */ SQL_TIMESTAMP,
#if TIMESTAMP_SCALE
    /* precision         */ 20 + TIMESTAMP_SCALE,
#else
    /* precision         */ 19,
#endif
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "TIMESTAMP_ARRAY",
    /* minscale          */ TIMESTAMP_SCALE,
    /* maxscale          */ TIMESTAMP_SCALE,
    },
    /* SQL_LONGVARBINARY (INTERVAL_ARRAY)*/
    {
    /* supported         */ FALSE, 
    /* name              */ (LPUSTR) "INTERVAL_ARRAY", 
    /* type              */ SQL_LONGVARBINARY,
    /* precision         */ ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "INTERVAL_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (DATE_ARRAY)*/
    {
    /* supported         */ FALSE, 
    /* name              */ (LPUSTR) "DATE_ARRAY", 
    /* type              */ SQL_LONGVARBINARY,
    /* precision         */ ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "DATE_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
    /* SQL_LONGVARBINARY (TIME_ARRAY)*/
    {
    /* supported         */ FALSE, 
    /* name              */ (LPUSTR) "TIME_ARRAY", 
    /* type              */ SQL_LONGVARBINARY,
    /* precision         */ ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/  /* varied length */
    /* prefix            */ NULL,
    /* suffix            */ NULL,
    /* params            */ (LPUSTR) "max length",
    /* nullable          */ SQL_NULLABLE,
    /* caseSensitive     */ FALSE,
    /* searchable        */ SQL_SEARCHABLE,
    /* unsignedAttribute */ -1,
    /* money             */ FALSE,
    /* autoincrement     */ -1,
    /* localname         */ (LPUSTR) "TIME_ARRAY",
    /* minscale          */ -1,
    /* maxscale          */ -1,
    },
};

/***************************************************************************/
UWORD INTFUNC NumTypes(void)
{
    return (sizeof(SQLTypes) / sizeof(SQLTYPE));
}
/***************************************************************************/
LPSQLTYPE INTFUNC GetType(SWORD fSqlType)
{
    UWORD i;

    for (i = 0; i < NumTypes(); i++) {
        if (SQLTypes[i].type == fSqlType)
            return &(SQLTypes[i]);
    }
    return NULL;
}
/***************************************************************************/

LPSQLTYPE INTFUNC GetType2(UCHAR* szTypeName)
{
    UWORD i;

    for (i = 0; i < NumTypes(); i++) 
    {
        if ( (lstrlen( (LPSTR)SQLTypes[i].name) == lstrlen((LPSTR)szTypeName)) &&
            (lstrcmp( (LPSTR)SQLTypes[i].name, (LPSTR)szTypeName) == 0) )
            return &(SQLTypes[i]);
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\setup.cpp ===
/***************************************************************************/
/* SETUP.C                                                                 */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"
#include "odbcinst.h"

/***************************************************************************/
typedef struct  tagSETUP {
	WORD      fRequest;
	char      szOriginalDSN[SQL_MAX_DSN_LENGTH+1];
	char      szDSN[SQL_MAX_DSN_LENGTH+1];
	char      szDatabase[MAX_DATABASE_NAME_LENGTH+1];
	char      szUsername[MAX_USER_NAME_LENGTH+1];
	char      szPassword[MAX_PASSWORD_LENGTH+1];
	char      szHost[MAX_HOST_NAME_LENGTH+1];
	char      szPort[MAX_PORT_NUMBER_LENGTH+1];
} SETUP, FAR *LPSETUP;
/***************************************************************************/
extern "C" BOOL EXPFUNC dlgSetup (
	HWND hDlg,
	UINT message,
	WPARAM wParam,
	LPARAM lParam)
{
	LPSETUP lpSetup;

	switch (message) {

	case WM_INITDIALOG:
		lpSetup = (LPSETUP) lParam;
		SendDlgItemMessage(hDlg, DSN_NAME, EM_LIMITTEXT,
						   SQL_MAX_DSN_LENGTH, 0L);
		SendDlgItemMessage(hDlg, DATABASE_NAME, EM_LIMITTEXT,
						   MAX_DATABASE_NAME_LENGTH, 0L);
		SendDlgItemMessage(hDlg, HOST_NAME, EM_LIMITTEXT,
						   MAX_HOST_NAME_LENGTH, 0L);
		SendDlgItemMessage(hDlg, PORT_NUMBER, EM_LIMITTEXT,
						   MAX_PORT_NUMBER_LENGTH, 0L);
		SetWindowLong(hDlg, DWL_USER, (LPARAM) lpSetup);
		SetDlgItemText(hDlg, DSN_NAME, (LPSTR) (lpSetup->szDSN));
		SetDlgItemText(hDlg, DATABASE_NAME, (LPSTR) (lpSetup->szDatabase));
		SetDlgItemText(hDlg, HOST_NAME, (LPSTR) (lpSetup->szHost));
		SetDlgItemText(hDlg, PORT_NUMBER, (LPSTR) (lpSetup->szPort));
		if ((lpSetup->fRequest == ODBC_ADD_DSN) &&
										   (lstrlen((char*)lpSetup->szDSN) != 0))
			EnableWindow(GetDlgItem(hDlg, DSN_NAME), FALSE);
		return (TRUE);

	case WM_COMMAND:
		switch (GET_WM_COMMAND_ID(wParam, lParam)) {
		case IDOK:

			/* Get data source name */
			lpSetup = (LPSETUP) GetWindowLong(hDlg, DWL_USER);
			GetDlgItemText(hDlg, DSN_NAME, (char*)lpSetup->szDSN,
						   SQL_MAX_DSN_LENGTH);

			/* Get database name */
			GetDlgItemText(hDlg, DATABASE_NAME, (char*)lpSetup->szDatabase,
						   MAX_DATABASE_NAME_LENGTH);
			AnsiToOem((char*)lpSetup->szDatabase, (char*)lpSetup->szDatabase);

			/* Clear off leading blanks */
			while (*lpSetup->szDatabase == ' ')
				lstrcpy((char*)lpSetup->szDatabase, (char*) (lpSetup->szDatabase+1));

			/* Clear off trailing blanks */
			while (*lpSetup->szDatabase != '\0') { 
				if (lpSetup->szDatabase[lstrlen((char*)lpSetup->szDatabase)-1] != ' ')
					break;
			   lpSetup->szDatabase[lstrlen((char*)lpSetup->szDatabase)-1] = '\0';
			}

			/* Get rid of terminating backslash (if any) */
			if (lstrlen((char*)lpSetup->szDatabase) > 0) {
				if (lpSetup->szDatabase[lstrlen((char*)lpSetup->szDatabase)-1] == '\\')
					lpSetup->szDatabase[lstrlen((char*)lpSetup->szDatabase)-1] = '\0';
			}
			else {

				/* If no directory specified, use the current directory */
				lstrcpy((char*)lpSetup->szDatabase, ".");
			}

			/* Get host name */
			GetDlgItemText(hDlg, HOST_NAME, lpSetup->szHost,
						   MAX_HOST_NAME_LENGTH);

			/* Clear off leading blanks */
			while (*lpSetup->szHost == ' ')
				lstrcpy(lpSetup->szHost, lpSetup->szHost+1);

			/* Clear off trailing blanks */
			while (*lpSetup->szHost != '\0') { 
				if (lpSetup->szHost[lstrlen(lpSetup->szHost)-1] != ' ')
					break;
			   lpSetup->szHost[lstrlen(lpSetup->szHost)-1] = '\0';
			}

			/* Get port number */
			GetDlgItemText(hDlg, PORT_NUMBER, lpSetup->szPort,
						   MAX_PORT_NUMBER_LENGTH);

			/* Clear off leading blanks */
			while (*lpSetup->szPort == ' ')
				lstrcpy(lpSetup->szPort, lpSetup->szPort+1);

			/* Clear off trailing blanks */
			while (*lpSetup->szPort != '\0') { 
				if (lpSetup->szPort[lstrlen(lpSetup->szPort)-1] != ' ')
					break;
			   lpSetup->szPort[lstrlen(lpSetup->szPort)-1] = '\0';
			}

			/* Return */
			EndDialog(hDlg, TRUE);
			return (TRUE);

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			return (TRUE);
		}
		break;
	}
	return (FALSE);
}
/***************************************************************************/
extern "C" BOOL INSTAPI ConfigDSN(HWND    hwnd,
					   WORD    fRequest,
					   LPCSTR  lpszDriver,
					   LPCSTR  lpszAttributes)
{
	SETUP     sSetup;
	LPSTR     ptr;
	LPSTR     lpszKeyword;
	LPSTR     lpszValue;
	DLGPROC   lpProc;
	char      szDriver[MAX_DRIVER_LENGTH+1];
	char      szTitle[100];
	char      szMessage[128];

	
	/* Parse the attribute string */
	sSetup.fRequest = fRequest;
	lstrcpy((char*)sSetup.szOriginalDSN, "");
	lstrcpy((char*)sSetup.szDSN, "");
	lstrcpy((char*)sSetup.szDatabase, "");
	lstrcpy((char*)sSetup.szUsername, "");
	lstrcpy((char*)sSetup.szPassword, "");
	lstrcpy(sSetup.szHost, "");
	lstrcpy(sSetup.szPort, "");
	ptr = (LPSTR) lpszAttributes;
	while ( (lpszAttributes != NULL) && *ptr) {

		/* Point at start of next keyword */
		lpszKeyword = ptr;

		/* Find the end of the keyword */
		while ((*ptr != '\0') && (*ptr != '='))
			ptr++;

		/* Accomodate bug in Microsoft ODBC Administrator */
		if (*ptr == '\0') {
			ptr++;
			continue;
		}

		/* Error if no value */
		if ((*ptr == '\0') || (ptr == lpszKeyword))
			return FALSE;

		/* Put a zero terminator on the keyword */
		*ptr = '\0';
		ptr++;

		/* Point at start of the keyword's value */
		lpszValue = ptr;

		/* Find the end of the value */
		while (*ptr != '\0')
			ptr++;

		/* Save the keyword */
		if (!lstrcmpi(lpszKeyword, KEY_DSN)) {
			lstrcpy((char*)sSetup.szOriginalDSN, lpszValue);
			lstrcpy((char*)sSetup.szDSN, lpszValue);
		}
		else if (!lstrcmpi(lpszKeyword, KEY_DATABASE))
			lstrcpy((char*)sSetup.szDatabase, lpszValue);
		else if (!lstrcmpi(lpszKeyword, KEY_USERNAME))
			lstrcpy((char*)sSetup.szUsername, lpszValue);
		else if (!lstrcmpi(lpszKeyword, KEY_PASSWORD))
			lstrcpy((char*)sSetup.szPassword, lpszValue);
		else if (!lstrcmpi(lpszKeyword, KEY_HOST))
			lstrcpy(sSetup.szHost, lpszValue);
		else if (!lstrcmpi(lpszKeyword, KEY_PORT))
			lstrcpy(sSetup.szPort, lpszValue);

		/* Restore the input string */
		lpszKeyword[lstrlen(lpszKeyword)] = '=';
		ptr++;
	}

	/* Which configuration operation? */
	switch (fRequest) {
	case ODBC_REMOVE_DSN:

		/* Remove.  Error if none specified */
		if (lstrlen((char*)sSetup.szOriginalDSN) == 0)
			return FALSE;

		/* Remove the datasource */
		if (!SQLRemoveDSNFromIni((char*)sSetup.szOriginalDSN))
			return FALSE;
		break;

	case ODBC_CONFIG_DSN:

		/* Config.  Get the database name from ODBC.INI file if not specified */
		if (lstrlen((char*)sSetup.szDatabase) == 0) {
			if (lstrlen((char*)sSetup.szOriginalDSN) > 0) {
				SQLGetPrivateProfileString((char*)sSetup.szOriginalDSN, KEY_DATABASE,
					   ".", (char*)sSetup.szDatabase, MAX_DATABASE_NAME_LENGTH+1,
					   ODBC_INI);
			}
		}

		/* Get the user name from ODBC.INI file if not specified */
		if (lstrlen((char*)sSetup.szUsername) == 0) {
			if (lstrlen((char*)sSetup.szOriginalDSN) > 0) {
				SQLGetPrivateProfileString((char*)sSetup.szOriginalDSN, KEY_USERNAME,
					   "", (char*)sSetup.szUsername, MAX_USER_NAME_LENGTH+1,
					   ODBC_INI);
			}
		}

		/* Get the password from ODBC.INI file if not specified */
		if (lstrlen((char*)sSetup.szPassword) == 0) {
			if (lstrlen((char*)sSetup.szOriginalDSN) > 0) {
				SQLGetPrivateProfileString((char*)sSetup.szOriginalDSN, KEY_PASSWORD,
					   "", (char*)sSetup.szPassword, MAX_PASSWORD_LENGTH+1,
					   ODBC_INI);
			}
		}

		/* Get the host from ODBC.INI file if not specified */
		if (lstrlen(sSetup.szHost) == 0) {
			if (lstrlen(sSetup.szOriginalDSN) > 0) {
				SQLGetPrivateProfileString(sSetup.szOriginalDSN, KEY_HOST,
					   "", sSetup.szHost, MAX_HOST_NAME_LENGTH+1,
					   ODBC_INI);
			}
		}

		/* Get the port number from ODBC.INI file if not specified */
		if (lstrlen(sSetup.szPort) == 0) {
			if (lstrlen(sSetup.szOriginalDSN) > 0) {
				SQLGetPrivateProfileString(sSetup.szOriginalDSN, KEY_PORT,
					   "", sSetup.szPort, MAX_PORT_NUMBER_LENGTH+1,
					   ODBC_INI);
			}
		}

		/* Get changes from the user */
		if (hwnd != NULL) {
			lpProc = MakeProcInstance( dlgSetup, s_hModule);
			if (!DialogBoxParam(s_hModule, "dlgSetup", hwnd, lpProc,
					  (LPARAM) ((LPSETUP) &sSetup))) {
				FreeProcInstance(lpProc);
				return FALSE;
			}
			FreeProcInstance(lpProc);
		}

		/* Did datasource name change? */
		if (lstrcmpi((char*)sSetup.szOriginalDSN, (char*)sSetup.szDSN)) {

			/* Yes.  Does the new datasource name already exist? */
			SQLGetPrivateProfileString((char*)sSetup.szDSN, KEY_DRIVER,
					   "", (char*)szDriver, MAX_DRIVER_LENGTH+1, ODBC_INI);
			if (lstrlen((char*)szDriver) != 0) {            
			
				/* Yes.  Ask user if it is OK to overwrite. */
				LoadString(s_hModule, STR_SETUP, (char*)szTitle, sizeof(szTitle));
				LoadString(s_hModule, STR_OVERWRITE, (char*)szMessage, sizeof(szMessage));
				if (IDOK != MessageBox(hwnd, (char*)szMessage, (char*)szTitle,
									   MB_OKCANCEL | MB_ICONQUESTION))
					return FALSE;
			}

			/* Remove the old datasource */
			if (!SQLRemoveDSNFromIni((char*)sSetup.szOriginalDSN))
				return FALSE;

			/* Create a new one */
			if (!SQLWriteDSNToIni((char*)sSetup.szDSN, lpszDriver))
				return FALSE;
		}

		/* Write the rest of the INI file entries */
		SQLWritePrivateProfileString((char*)sSetup.szDSN, KEY_DATABASE,
								  (char*)sSetup.szDatabase, ODBC_INI);

		SQLWritePrivateProfileString((char*)sSetup.szDSN, KEY_USERNAME,
								  (char*)sSetup.szUsername, ODBC_INI);

		SQLWritePrivateProfileString((char*)sSetup.szDSN, KEY_PASSWORD,
								  (char*)sSetup.szPassword, ODBC_INI);
		SQLWritePrivateProfileString(sSetup.szDSN, KEY_HOST,
								  sSetup.szHost, ODBC_INI);
		SQLWritePrivateProfileString(sSetup.szDSN, KEY_PORT,
								  sSetup.szPort, ODBC_INI);
		break;

	case ODBC_ADD_DSN:

		/* Add.  Get changes from the user */
		if (hwnd != NULL) {
			lpProc = MakeProcInstance( dlgSetup, s_hModule);
			if (!DialogBoxParam(s_hModule, "dlgSetup", hwnd, lpProc,
					  (LPARAM) ((LPSETUP) &sSetup))) {
				FreeProcInstance(lpProc);
				return FALSE;
			}
			FreeProcInstance(lpProc);
		}

		/* Does the new datasource name already exist? */
		SQLGetPrivateProfileString((char*)sSetup.szDSN, KEY_DRIVER,
					   "", (char*)szDriver, MAX_DRIVER_LENGTH+1, ODBC_INI);
		if (lstrlen((char*)szDriver) != 0) {            
			
			/* Yes.  Ask user if it is OK to overwrite. */
			if (hwnd != NULL) {
				LoadString(s_hModule, STR_SETUP, (char*)szTitle, sizeof(szTitle));
				LoadString(s_hModule, STR_OVERWRITE, (char*)szMessage, sizeof(szMessage));
				if (IDOK != MessageBox(hwnd, (char*)szMessage, (char*)szTitle,
									   MB_OKCANCEL | MB_ICONQUESTION))
					return FALSE;
			}

			/* Remove the old datasource */
			if (!SQLRemoveDSNFromIni((char*)sSetup.szDSN))
				return FALSE;
		}

		/* Create a new one */
		if (!SQLWriteDSNToIni((char*)sSetup.szDSN, lpszDriver))
				return FALSE;
		SQLWritePrivateProfileString((char*)sSetup.szDSN, KEY_DATABASE,
								  (char*)sSetup.szDatabase, ODBC_INI);

		SQLWritePrivateProfileString((char*)sSetup.szDSN, KEY_USERNAME,
								  (char*)sSetup.szUsername, ODBC_INI);

		SQLWritePrivateProfileString((char*)sSetup.szDSN, KEY_PASSWORD,
								  (char*)sSetup.szPassword, ODBC_INI);
		SQLWritePrivateProfileString(sSetup.szDSN, KEY_HOST,
								  sSetup.szHost, ODBC_INI);
		SQLWritePrivateProfileString(sSetup.szDSN, KEY_PORT,
								  sSetup.szPort, ODBC_INI);
		break;
	}

	return TRUE;
}
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\util.h ===
/***************************************************************************/
/* UTIL.H                                                                  */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/

#ifdef WIN32
#define INTFUNC  __stdcall
#else
#define INTFUNC PASCAL
#endif

/***************************************************************************/

/* To turn on tracing, set ISAM_TRACE to TRUE and recompile */
#define ISAM_TRACE FALSE

/* Max size for SQL_LONGVARCHAR */
#define ISAM_MAX_LONGVARCHAR		16384 //cannot be more than (32767 - 4)

/***************************************************************************/
#define BINARY_LENGTH(x) *((SDWORD FAR *) x)
#define BINARY_DATA(x)   (x + sizeof(SDWORD))
/***************************************************************************/
RETCODE INTFUNC ReturnString (
    PTR        rgbValue,
    SWORD      cbValueMax,
    SWORD FAR  *pcbValue,
    LPCUSTR     lpstr);

RETCODE INTFUNC ReturnStringD (
    PTR        rgbValue,
    SDWORD     cbValueMax,
    SDWORD FAR *pcbValue,
    LPCUSTR     lpstr);

/* Takes the zero terminated string 'lpstr' and copies it to buffer */
/* rgbValue[0..cbValueMax-1], truncating it if need be (if rgbValue */
/* is null, no data is copied).  Also, if pcbValue is not null, it  */
/* is set to the length of the un-truncated string.                 */
/*                                                                  */
/* Returns ERR_SUCCESS or ERR_DATATRUNCATED                         */

/***************************************************************************/

RETCODE INTFUNC ConvertSqlToC (
    SWORD      fSqlTypeIn,
    BOOL       fUnsignedAttributeIn,
    PTR        rgbValueIn,
    SDWORD     cbValueIn,
    SDWORD FAR *pcbOffset,
    SWORD      fCTypeOut,
    PTR        rgbValueOut,
    SDWORD     cbValueOutMax,
    SDWORD  FAR *pcbValueOut);

/* Copies rgbValueIn to rgbValueOut (if not null) and sets pcbValueOut (if */
/* not null).  Data is converted as need be.  Data is copied stating at    */
/* rgbValueIn[*pcbOffset] and *pcbOffset is increased by the number of     */
/* bytes returned.                                                         */
/*                                                                         */
/* Returns ERR_SUCCESS or ERR_DATATRUNCATED or some other error            */

/***************************************************************************/

BOOL INTFUNC PatternMatch(
    BOOL   fEscape,
    LPUSTR  lpCandidate,
    SDWORD cbCandidate,
    LPUSTR  lpPattern,
    SDWORD cbPattern,
    BOOL   fCaseSensitive);

/* Tests to see if lpCandidate matched the template specified by           */
/* lpPattern.  Percent signs (%) match zero or more characters.            */
/* Underscores (_) match single characters.  The camparison is done        */
/* case-insensitive if fCaseSensitive is FALSE.                            */
/*                                                                         */
/* If fEscape is TRUE, "%%" in the pattern only matches a single '%' in    */
/* the candidate and "%_" in the pattern only matches a single '_' in the  */
/* candidate.                                                              */
/*                                                                         */
/* Returns TRUE if there is a match, otherwise FALSE.                      */

/***************************************************************************/

SDWORD INTFUNC TrueSize(
     LPUSTR  lpStr,
     SDWORD cbStr,
     SDWORD cbMax);

/* Returns the size of a string (but not larger than cbMax)                */

/***************************************************************************/

BOOL INTFUNC DoubleToChar (
        double    dbl,
		BOOL	  ScientificNotationOK,
        LPUSTR     lpChar,
        SDWORD    cbChar);
        
/* Convert a double to a character string.  Returns TRUE if value is       */
/* truncated (lpChar will not contain a null terminator).  Otherwise FALSE.*/

/***************************************************************************/

void INTFUNC DateToChar (
        DATE_STRUCT FAR *lpDate,
        LPUSTR     lpChar);

/* Convert a date to a character string                                    */

/***************************************************************************/

void INTFUNC TimeToChar (
        TIME_STRUCT FAR *lpTime,
        LPUSTR     lpChar);

/* Convert a time to a character string                                    */

/***************************************************************************/

void INTFUNC TimestampToChar (
        TIMESTAMP_STRUCT FAR *lpTimestamp,
        LPUSTR     lpChar);

/* Convert a timestamp to a character string                               */

/***************************************************************************/

RETCODE INTFUNC CharToDouble (
        LPUSTR      lpChar,
        SDWORD     cbChar,
        BOOL       fIntegerOnly,
        double     dblLowBound,
        double     dblHighBound,
        double FAR *lpDouble);

/* Convert a character string to a double                                  */

/***************************************************************************/

RETCODE INTFUNC CharToDate (
        LPUSTR      lpChar,
        SDWORD     cbChar,
        DATE_STRUCT FAR *lpDate);

/* Convert a character string to a date                                   */

/***************************************************************************/

RETCODE INTFUNC CharToTime (
        LPUSTR      lpChar,
        SDWORD     cbChar,
        TIME_STRUCT FAR *lpTime);

/* Convert a character string to a time                                    */

/***************************************************************************/

RETCODE INTFUNC CharToTimestamp (
        LPUSTR      lpChar,
        SDWORD     cbChar,
        TIMESTAMP_STRUCT FAR *lpTimestamp);

/* Convert a character string to a timestamp                               */

/***************************************************************************/

#ifndef WIN32
BOOL INTFUNC DeleteFile (
        LPCSTR      lpszFilename);

/* Deletes specified file                                                  */
#endif
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\accessor.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CImpIAccessor object implementation
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

#define INITIAL_NUM_PARAM 256
const DBTYPE TYPE_MODIFIERS = (DBTYPE_BYREF | DBTYPE_VECTOR | DBTYPE_ARRAY);
static const MAX_BITS = 1008;

//////////////////////////////////////////////////////////////////////////////////////////////////
// Initialize the accessor
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIAccessor::FInit( )
{
    HRESULT hr = S_OK;

    if( !m_prowbitsIBuffer ){
        if( !CreateNewBitArray()){
            hr = E_OUTOFMEMORY;
        }
    }

    if( hr == S_OK ){
        if( !m_pextbufferAccessor ){
            if( !CreateNewAccessorBuffer() ){
			   hr = E_OUTOFMEMORY ;
		    }
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a reference count to an existing accessor
//
// HRESULT
//      S_OK                      Method Succeeded
//      E_FAIL                    Provider specific Error
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIAccessor::AddRefAccessor  (	HACCESSOR	hAccessor,		// IN Accessor Handle
												DBREFCOUNT*		pcRefCounts		// OUT Reference Count
    )
{
	//==============================================================================================
    // Retrieve our accessor structure from the client's hAccessor, free it, then mark accessor 
	// ptr as unused. We do not re-use accessor handles.  This way, we hope to catch more client 
	// errors.  (Also, ExtBuffer doesn't maintain a free list, so it doesn't know how to.)
	//==============================================================================================
	// NTRaid : 111811
	// 06/13/00
    PACCESSOR   pAccessor = NULL;
    HRESULT     hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    if( pcRefCounts )
	{
		*pcRefCounts = 0;
	}

	// Start a critical section
	CAutoBlock cab(((CBaseObj*)(m_pObj))->GetCriticalSection());

	g_pCError->ClearErrorInfo();
	hr = m_pextbufferAccessor->GetItemOfExtBuffer( hAccessor, &pAccessor );

    if (FAILED( hr ) || pAccessor == NULL){
        hr = DB_E_BADACCESSORHANDLE;
	}
	else
	{

		InterlockedIncrement(&(pAccessor->cRef));
		if( pcRefCounts )
		{
			*pcRefCounts = (ULONG)(pAccessor->cRef);
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IAccessor);

	CATCH_BLOCK_HRESULT(hr,L"IAccessor::AddRefAccessor");
	
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Creates a set of bindings that can be used to send data to or retrieve data from the data cache.
//
// HRESULT
//      S_OK                      Method Succeeded
//      E_FAIL                    Provider specific Error
//      E_INVALIDARG              pHAccessor was NULL, dwAccessorFlags was invalid, or cBindings 
//								  was not 0 and rgBindings was NULL
//      E_OUTOFMEMORY             Out of Memory
//      DB_E_ERRORSOCCURRED		  dwBindPart in an rgBindings element was invalid, OR
//									 Column number specified was out of range, OR
//									 Requested coercion is not supported.
//      OTHER                     Other HRESULTs returned by called functions
//
//	NTRaid:130142: changes for this bug and also channged the accessorflag = to accessoflag &
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIAccessor::CreateAccessor(
					DBACCESSORFLAGS dwAccessorFlags,
					DBCOUNTITEM          cBindings,      // IN Number of Bindings
					const DBBINDING rgBindings[],   // IN Array of DBBINDINGS
					DBLENGTH           cbRowSize,      // IN Number of bytes in consumer's buffer
					HACCESSOR*      phAccessor,     // OUT Accessor Handle
					DBBINDSTATUS	rgStatus[])		// OUT Binding status
{
    PACCESSOR   pAccessor		= NULL;
    ULONG       hAccessor;
    ULONG       ibind;
    DBORDINAL	icol;
    HRESULT     hr				= S_OK;
	DBTYPE		lType			= 0;
	DBTYPE		lAccType		= 0;
	DBTYPE		currType		= 0;
	DBTYPE		currTypePtr		= 0;
	DBTYPE		currTypeBase	= 0;
	ULONG		cError			= 0;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//======================================
	// Start a critical section
	//======================================
	CAutoBlock cab(((CBaseObj*)(m_pObj))->GetCriticalSection());
	g_pCError->ClearErrorInfo();


/*	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
*/	//============================================================================
	// Check Parameters
	//============================================================================
	if ( ( cBindings && !rgBindings ) || ( phAccessor == NULL ) )
	{
		hr = E_INVALIDARG;
		//return g_pCError->PostHResult(E_INVALIDARG,&IID_IAccessor);
	}
	else
	if(cBindings == 0)
	{
		if((dwAccessorFlags & DBACCESSOR_ROWDATA) && m_bRowset)
		{
			VARIANT varTemp;
			VariantInit(&varTemp);
			if(SUCCEEDED(hr = ROWSET->GetRowsetProperty(DBPROP_IRowsetChange,varTemp)))
			{
				if(V_BOOL(&varTemp) == VARIANT_FALSE)
				{
					hr = DB_E_NULLACCESSORNOTSUPPORTED;
				}
				else
				if(SUCCEEDED(hr = ROWSET->GetRowsetProperty(DBPROP_UPDATABILITY,varTemp)))
				{
					if(!(DBPROPVAL_UP_INSERT & varTemp.lVal))
					{
						hr = DB_E_NULLACCESSORNOTSUPPORTED;
					}
				}
			}
		}
		else
		if(!(dwAccessorFlags & DBACCESSOR_PARAMETERDATA) && m_bRowset == FALSE)
		{
			hr = DB_E_NULLACCESSORNOTSUPPORTED;
		}
	}
	else
	{
  
		//============================================================================
		// init out params
		//============================================================================
		*phAccessor = NULL;

		//============================================================================
		// Check if we have a correct accessor type
		//============================================================================
		if ( dwAccessorFlags & DBACCESSOR_PASSBYREF )
		{
			hr = DB_E_BYREFACCESSORNOTSUPPORTED;
		}
		
	}

	if( SUCCEEDED(hr))
	{
   		//============================================================================
		// Take DBACCESSOR_OPTIMIZED off since we do nothing with it
		//============================================================================
		dwAccessorFlags &= ~DBACCESSOR_OPTIMIZED;
		// NTRaid:130142
		if (!( (dwAccessorFlags & DBACCESSOR_ROWDATA)  || (dwAccessorFlags & DBACCESSOR_PARAMETERDATA))) 
		{
			hr = DB_E_BADACCESSORFLAGS;
			//return  g_pCError->PostHResult(DB_E_BADACCESSORFLAGS,&IID_IAccessor) ;
		}
		else
		// If parameterdata accessor is to be created when the accessor
		// is from Rowset object then throw error
		if((dwAccessorFlags & DBACCESSOR_PARAMETERDATA) && m_bRowset)
		{
			hr = DB_E_BADACCESSORFLAGS;
		}
	}
	
	// if the accessor is on command and if it is command text is not been 
	// set then throw an erro
	if(SUCCEEDED(hr) && (dwAccessorFlags & DBACCESSOR_PARAMETERDATA) && 
		!(COMMAND->m_pQuery->GetStatus() & CMD_TEXT_SET))
	{
		DB_E_NOCOMMAND;
	}
	
	if( SUCCEEDED(hr))
	{
		//============================================================================
		// reset the parameter data
		//============================================================================
		if (dwAccessorFlags & DBACCESSOR_PARAMETERDATA)
		{
	    	m_prowbitsIBuffer->ResetAllSlots();
		}

		//============================================================================
		// Initialize the status array to DBBINDSTATUS_OK.
		//============================================================================
		if ( rgStatus )
		{
			memset(rgStatus, 0x00, cBindings*sizeof(DBBINDSTATUS));
		}


		//============================================================================
		// Check on the bindings the user gave us.
		//============================================================================
		hr = NOERROR;

		for (ibind =0; ibind < cBindings && hr != E_OUTOFMEMORY; ibind++)
		{

			//========================================================================
			// other binding problems forbidden by OLE-DB
			//========================================================================
			currType		= rgBindings[ibind].wType;
			currTypePtr		= currType & (DBTYPE_BYREF|DBTYPE_ARRAY|DBTYPE_VECTOR);
			currTypeBase	= currType & ~(DBTYPE_BYREF|DBTYPE_ARRAY|DBTYPE_VECTOR);

			icol = rgBindings[ibind].iOrdinal;

			//========================================================================
			// make sure column number is in range
			//========================================================================
			if( dwAccessorFlags & DBACCESSOR_ROWDATA)
			{
				if(((ROWSET->m_ulProps & BOOKMARKPROP) && (DB_LORDINAL)icol < 0) || 
				(!(ROWSET->m_ulProps & BOOKMARKPROP) && (DB_LORDINAL)icol <= 0) ||
				 (icol > ROWSET->m_cTotalCols) )
				{

					//====================================================================
					// Set Bind status to DBBINDSTATUS_BADORDINAL
					//====================================================================
					hr = DB_E_ERRORSOCCURRED;
					if ( rgStatus )
					{
						rgStatus[ibind] = DBBINDSTATUS_BADORDINAL;
					}
					cError++;
				}
			}
			else
			{
				if(icol > COMMAND->GetParamCount() )
				{
					//====================================================================
					// Set Bind status to DBBINDSTATUS_BADORDINAL
					//====================================================================
					hr = DB_E_ERRORSOCCURRED;
					if ( rgStatus )
					{
						rgStatus[ibind] = DBBINDSTATUS_BADORDINAL;
					}
					cError++;
				}
			}

			//========================================================================
			// At least one of these valid parts has to be set. In SetData I assume 
			// it is the case.
			//========================================================================
			if( SUCCEEDED(hr) &&  !(rgBindings[ibind].dwPart & (DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS)) )
			{

				//====================================================================
				// Set Bind status to DBBINDSTATUS_BADBINDINFO
				//====================================================================
				hr = DB_E_ERRORSOCCURRED;
				if ( rgStatus )
				{
					rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
				}
				cError++;
			}

			//========================================================================
			// dwPart is something other than value, length, or status
			//========================================================================
			else if ( (rgBindings[ibind].dwPart & ~(DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS)) )
			{

				//====================================================================
				// Set Bind status to DBBINDSTATUS_BADBINDINFO
				//====================================================================
				hr = DB_E_ERRORSOCCURRED;
				if ( rgStatus )
				{
					rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
				}
				cError++;
			}

			//========================================================================
			// wType was DBTYPE_EMPTY or DBTYPE_NULL
			//========================================================================
			else 
			if ( (currType==DBTYPE_EMPTY || currType==DBTYPE_NULL) )
			{
				//====================================================================
				// Set Bind status to DBBINDSTATUS_BADBINDINFO
				//====================================================================
				hr = DB_E_ERRORSOCCURRED;
				if ( rgStatus )
				{
					rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
				}
				cError++;
			}
			//========================================================================
			// wType was DBTYPE_BYREF or'ed with DBTYPE_EMPTY, NULL, or RESERVED
			//========================================================================
			else 
			if ( ((currType & DBTYPE_BYREF) && 
					(currTypeBase == DBTYPE_EMPTY || currTypeBase == DBTYPE_NULL || currType & DBTYPE_RESERVED)) )
			{

				//====================================================================
				// Set Bind status to DBBINDSTATUS_BADBINDINFO
				//====================================================================
				hr = DB_E_ERRORSOCCURRED;
				if ( rgStatus )
				{
					rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
				}
				cError++;
			}

			//========================================================================
			// wType was used with more than one type indicators
			//========================================================================
			else 
			if ( !(currTypePtr == 0 || currTypePtr == DBTYPE_BYREF ||
					currTypePtr == DBTYPE_ARRAY || currTypePtr == DBTYPE_VECTOR) )
			{

				//====================================================================
				// Set Bind status to DBBINDSTATUS_BADBINDINFO
				//====================================================================
				hr = DB_E_ERRORSOCCURRED;
				if ( rgStatus )
				{
					rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
				}
				cError++;
			}

			//========================================================================
			// wType was a non pointer type with provider owned memory
			//========================================================================
			else 
			if ( !currTypePtr &&  rgBindings[ibind].dwMemOwner==DBMEMOWNER_PROVIDEROWNED )
			{

    			//========================================================================
	    		// We are dealing with parameter data
		    	//========================================================================
	   			if ((dwAccessorFlags & DBACCESSOR_PARAMETERDATA)
					&& ((rgBindings[ibind].eParamIO & DBPARAMIO_OUTPUT)
					|| ((rgBindings[ibind].eParamIO & DBPARAMIO_INPUT)
					&&(dwAccessorFlags & DBACCESSOR_PASSBYREF) == 0)))
				{
					hr = DB_E_ERRORSOCCURRED;
					if ( rgStatus )
					{
						rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
					}
					cError++;
				}
				//====================================================================
				// Set Bind status to DBBINDSTATUS_BADBINDINFO
				//====================================================================
				else
				{
					hr = DB_E_ERRORSOCCURRED;
					if ( rgStatus )
					{
						rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
					}
					cError++;
				}
			}

			//========================================================================
			// we only support client owned memory
			//========================================================================
			else 
			if ( rgBindings[ibind].dwMemOwner != DBMEMOWNER_CLIENTOWNED )
			{
				//====================================================================
				// Set Bind status to DBBINDSTATUS_BADBINDINFO
				//====================================================================
				hr = DB_E_ERRORSOCCURRED;
				if ( rgStatus )
				{
					rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
				}
				cError++;
			}

			//========================================================================
			// Make sure we can do the coercion that is requested
			//========================================================================
			else
			{
               	WORD wBaseType;
				BOOL fInParam = FALSE, fOutParam = FALSE;

				if( NOERROR == S_OK	&& (dwAccessorFlags & DBACCESSOR_PARAMETERDATA))
				{
        			if (rgBindings[ibind].iOrdinal == 0)
					{
						if(rgStatus)
						{
							rgStatus[ibind] = DBBINDSTATUS_BADORDINAL;
						}
					}
					else 
					if ((rgBindings[ibind].eParamIO & (DBPARAMIO_INPUT|DBPARAMIO_OUTPUT)) == 0	|| 
							(rgBindings[ibind].eParamIO & ~(DBPARAMIO_INPUT|DBPARAMIO_OUTPUT)) )
					{
						if(rgStatus)
						{
							rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
						}
					}
					else 
					if (rgBindings[ibind].eParamIO & DBPARAMIO_INPUT)
					{

						if (m_prowbitsIBuffer->IsSlotSet((ULONG)rgBindings[ibind].iOrdinal) == S_OK)
						{
							if(rgStatus)
							{
								rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
							}
						}
						else 
						if (SUCCEEDED(hr)	&& FAILED(m_prowbitsIBuffer->SetSlots((ULONG)rgBindings[ibind].iOrdinal,(ULONG)rgBindings[ibind].iOrdinal)))
						{
							hr = E_OUTOFMEMORY;
							break;
						}
					}	
    			

					if ((rgBindings[ibind].eParamIO & DBPARAMIO_OUTPUT)
		    			&& (rgBindings[ibind].wType & DBTYPE_BYREF)
			    		&& (wBaseType = (rgBindings[ibind].wType & ~TYPE_MODIFIERS)) != DBTYPE_BYTES
						&& wBaseType != DBTYPE_STR && wBaseType != DBTYPE_WSTR)
					
					{
						if(rgStatus && (rgStatus[ibind] == DBBINDSTATUS_OK))
						{
							rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
						}
					}
					
					if (rgStatus && (rgStatus[ibind] == DBBINDSTATUS_OK) && (dwAccessorFlags & DBACCESSOR_PASSBYREF))
					{
						if (!fInParam && (rgBindings[ibind].eParamIO & DBPARAMIO_INPUT))
							fInParam = TRUE;
						if (!fOutParam && (rgBindings[ibind].eParamIO & DBPARAMIO_OUTPUT))
							fOutParam = TRUE;
						if (fInParam && fOutParam && rgStatus)
							rgStatus[ibind] = DBBINDSTATUS_BADBINDINFO;
					}

				}
				else
				{
					// If the type of the column is of type CHAPTER then consider \
					// that as of type unsigned long 
					if((dwAccessorFlags & DBACCESSOR_ROWDATA) && (DBTYPE_HCHAPTER == ROWSET->m_Columns.ColumnType(icol)))
					{
						lType	= DBTYPE_UI4;
					}
					else
					{
						if(dwAccessorFlags & DBACCESSOR_ROWDATA)
						{
							lType	= ROWSET->m_Columns.ColumnType(icol);
						}
					}

					if(rgBindings[ibind].wType == DBTYPE_HCHAPTER)
					{
						lAccType = DBTYPE_UI4;
					}
					else
					{
						lAccType = rgBindings[ibind].wType;
					}

					if(S_OK != (hr = g_pIDataConvert->CanConvert(lAccType, lType)) ||
					S_OK != (hr = g_pIDataConvert->CanConvert( lType, lAccType)))
					{
						//================================================================
						// Set Bind status to DBBINDSTATUS_UNSUPPORTEDCONVERSION
						//================================================================
						hr = DB_E_ERRORSOCCURRED;
						if ( rgStatus )
							rgStatus[ibind] = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
						cError++;
					}
				} // else for if( NOERROR == S_OK	&& (dwAccessorFlags & DBACCESSOR_PARAMETERDATA))
			}
		}	// end of for loop

		//============================================================================
		// Any errors amongst those checks?
		//============================================================================
		if(cError)
		{
			hr = DB_E_ERRORSOCCURRED;
		}
		else
		if ( NOERROR == hr)
		{
			try
			{

				//========================================================================
				// Make a copy of the client's binding array, and the type of binding.
				//========================================================================
				pAccessor = (ACCESSOR *) new BYTE[sizeof( ACCESSOR ) + (cBindings - 1) *sizeof( DBBINDING )];
			}
			catch(...)
			{
				SAFE_DELETE_PTR(pAccessor);
				throw;
			}
			if ( pAccessor == NULL )
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				//====================================================================
				// We store a ptr to the newly created variable-sized ACCESSOR.
				// We have an array of ptrs (to ACCESSOR's).
				// The handle is the index into the array of ptrs.
				// The InsertIntoExtBuffer function appends to the end of the array.
				//====================================================================
				assert( m_pextbufferAccessor );
				hr = m_pextbufferAccessor->InsertIntoExtBuffer( &pAccessor, hAccessor );
				if ( FAILED( hr ) )
				{

					SAFE_DELETE_PTR( pAccessor );
					hr = E_OUTOFMEMORY;
				}
				else
				{
					assert( hAccessor );
					
					//=================================================================
					// Copy the client's bindings into the ACCESSOR.
					//=================================================================
					pAccessor->dwAccessorFlags	= dwAccessorFlags;
					pAccessor->cBindings		= cBindings;

					//=================================================================
					// Establish Reference count.
					//=================================================================
					pAccessor->cRef				= 1;					
					memcpy( &(pAccessor->rgBindings[0]), &rgBindings[0], cBindings*sizeof( DBBINDING ));

					//=================================================================
					// fill out-param 
					//=================================================================
					*phAccessor = (HACCESSOR) hAccessor;
					hr = S_OK ;
				
				} // else for Failed(hr) after call to InsertIntoExtBuffer()

			}  // Else for if(pAccessor == NULL)
		} // if ( NOERROR == hr )
	
	}	// If succeeded(hr) after validating arguments
	

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IAccessor);

	CATCH_BLOCK_HRESULT(hr,L"IAccessor::CreateAccessor");
	
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Returns the bindings in an accessor
//
//  HRESULT
//       S_OK                       Method Succeeded
//       E_INVALIDARG               pdwAccessorFlags/pcBinding/prgBinding were NULL
//       E_OUTOFMEMORY              Out of Memory
//       DB_E_BADACCESSORHANDLE     Invalid Accessor given
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIAccessor::GetBindings(    HACCESSOR        hAccessor,         // IN Accessor Handle
											DBACCESSORFLAGS* pdwAccessorFlags,  // OUT Binding Type flag
											DBCOUNTITEM*           pcBindings,        // OUT Number of Bindings returned
											DBBINDING**      prgBindings        // OUT Bindings
    )
{
	//========================================================================
    // Retrieve our accessor structure from the client's hAccessor,
    // make a copy of the bindings for the user, then done.
	//========================================================================
	// NTRaid:111810
	// 06/067/00
    PACCESSOR   pAccessor = NULL;
    ULONG       cBindingSize;
    HRESULT     hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//========================================================================
    // init out-params
	//========================================================================
	if(	pdwAccessorFlags )
	{
		*pdwAccessorFlags = 0;
	}
	if( pcBindings )
	{
		*pcBindings = 0;
	}
	if ( prgBindings )
	{
		*prgBindings = NULL;
	}

	// Start a critical section
	CAutoBlock cab(((CBaseObj*)(m_pObj))->GetCriticalSection());
	g_pCError->ClearErrorInfo();

/*	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
*/  //========================================================================
    // check parameters
	//========================================================================
    if (!pdwAccessorFlags || !pcBindings || !prgBindings)
	{
        hr = E_INVALIDARG;
	}
	else
	{
		//====================================================================
		// Validate Accessor Handle
 		//====================================================================
		hr = m_pextbufferAccessor->GetItemOfExtBuffer( hAccessor, &pAccessor );
		if (FAILED( hr ) || pAccessor == NULL)
		{
			hr = DB_E_BADACCESSORHANDLE;
		}
		else
		{
			//================================================================
			// Allocate and return Array of bindings
			//================================================================
			cBindingSize = (ULONG)(pAccessor->cBindings * sizeof( DBBINDING ));
			if ( cBindingSize )
			{
				*prgBindings = (DBBINDING *) g_pIMalloc->Alloc( cBindingSize );
			}
    
			//================================================================
			// Check the Allocation
			//================================================================
			if ( ( *prgBindings == NULL ) && ( cBindingSize ) )
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{

				*pdwAccessorFlags = pAccessor->dwAccessorFlags;
				*pcBindings = pAccessor->cBindings;
				memcpy( *prgBindings, pAccessor->rgBindings, cBindingSize );
				hr =  S_OK ;
			}
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IAccessor);

	CATCH_BLOCK_HRESULT(hr,L"IAccessor::GetBindings");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Releases an Accessor
//
//  HRESULT
//       S_OK                      Method Succeeded
//       DB_E_BADACCESSORHANDLE    hAccessor was invalid
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIAccessor::ReleaseAccessor(   HACCESSOR	hAccessor,      // IN Accessor handle to release
											   DBREFCOUNT*		pcRefCounts		// OUT Reference Count
											)
{
	//===============================================================================
    // Retrieve our accessor structure from the client's hAccessor, free it, then 
	// mark accessor ptr as unused. We do not re-use accessor handles.  This way, 
	// we hope to catch more client errors.  (Also, ExtBuffer doesn't
    // maintain a free list, so it doesn't know how to.)
	//===============================================================================
	// NTRaid:111809
	// 06/13/00
    PACCESSOR   pAccessor = NULL;
    HRESULT     hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	if( pcRefCounts )
	{
		*pcRefCounts = 0;
	}

	//========================================================
	// Start a critical section
	//========================================================
	CAutoBlock cab(((CBaseObj*)(m_pObj))->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	hr = m_pextbufferAccessor->GetItemOfExtBuffer( hAccessor, &pAccessor );
    if (FAILED( hr ) || pAccessor == NULL)
	{
        hr =  DB_E_BADACCESSORHANDLE;
	}
	else
	{
		//============================================================
		// Free the actual structure.
		//============================================================
		InterlockedDecrement(&(pAccessor->cRef));
		assert( pAccessor->cRef >= 0 );
		if( pAccessor->cRef <= 0 )
		{

			SAFE_DELETE_PTR( pAccessor );
			if( pcRefCounts )
			{
				*pcRefCounts = 0;
			}

			//========================================================
			// Store a null in our array-of-ptrs, so we know next time 
			// that it is invalid. (operator[] returns a ptr to the 
			// space where the ptr is stored.)
			//========================================================
			*(PACCESSOR*) ((*m_pextbufferAccessor)[ (ULONG) hAccessor]) = NULL;
		}
		else
		if( pcRefCounts )
		{
			*pcRefCounts = (ULONG)(pAccessor->cRef);
		}

	    hr = S_OK ;
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IAccessor);

	CATCH_BLOCK_HRESULT(hr,L"IAccessor::ReleaseAccessor");
	
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Create helper objects
//
// Bit array to track presence/absense of rows.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CImpIAccessor::CreateNewBitArray()
{
    BOOL fRc = TRUE;

    SAFE_DELETE_PTR(m_prowbitsIBuffer);

	m_prowbitsIBuffer = new CBitArray;
	if (m_prowbitsIBuffer == NULL || FAILED( m_prowbitsIBuffer->FInit( MAX_BITS, g_dwPageSize ))){
		fRc = FALSE;
	}

    return fRc;

}
///////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CImpIAccessor::CreateNewAccessorBuffer()
{
    BOOL fRc = TRUE;

    SAFE_DELETE_PTR( m_pextbufferAccessor );

	m_pextbufferAccessor = (LPEXTBUFFER) new CExtBuffer;
	if (m_pextbufferAccessor == NULL || FAILED( m_pextbufferAccessor->FInit( 1, sizeof( PACCESSOR ), g_dwPageSize ))){
		fRc = FALSE;
	}
    return fRc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\asserts.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Simple Assertion Routines
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include <time.h>
#include "asserts.h"

//=======================================================================================
//  only compile for debug!
//=======================================================================================
#ifdef DEBUG    

/////////////////////////////////////////////////////////////////////////////////////////
//
//  Variable argument formatter and Dump routine for messages
//
/////////////////////////////////////////////////////////////////////////////////////////
void OLEDB_Trace( const char *format,		// IN Format String
				...							// IN Variable Arg List
				)
{
    char buff[300 ];
    int cBytesWritten;
    va_list argptr;

	//====================================================================================
    // If this overflows, it will wipe out the return stack. However, we have a wonderful 
	// version that ensures no overwrite. Nice because we can't do anything about errors 
	// here.
	//====================================================================================

    va_start( argptr, format );
    cBytesWritten = _vsnprintf( buff, sizeof( buff ), format, argptr );
    va_end( argptr );

	//====================================================================================
    // assert would report overflow first, recursively, but don't bother.
    // Would be OK, since this assert could be proven not to overflow temp buffer in assert.
    // assert( cBytesWritten < sizeof(buff) );
	//====================================================================================

    OutputDebugStringA( buff );
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//  This an internal assertion routine that dumps more information
//  than the normal assertion routines..
//
/////////////////////////////////////////////////////////////////////////////////////////
void OLEDB_Assert(		LPSTR expression,   // IN  Expression to assert on
						LPSTR filename,     // IN  Filname where assertion occurred
						long linenum        // IN  Line number where assertion occurred
						)
{
    char          szbuff[350 ];
    int           cBytesWritten;
    volatile int  fAbort;

	//====================================================================================
    // If this overflows, it will wipe out the return stack.
    // However, we have a wonderful version that ensures no overwrite.
    // Good thing, because we can't do much about overflows here anyway.
    // (However, use of "%.nns" works well.)
	//====================================================================================

    cBytesWritten = _snprintf( szbuff, sizeof( szbuff ),
        "Assertion error!\n  File '%.50s', line '%ld'\n  Expression '%.200s'\n",
        filename, linenum, expression );

    TRACE( szbuff );

	//====================================================================================
    // We're a DLL (therefore Windows), so may not have an output stream we can write to.
	//====================================================================================
    ::MessageBoxA(
        NULL,   // HWND, which we don't have
        szbuff, // Text
        "Assertion Error",  // Title
        MB_SYSTEMMODAL | MB_ICONHAND | MB_OK );

	//====================================================================================
    // Break and let the user get a crack at it. Set fAbort=0 to continue merrily along.
	//====================================================================================
    fAbort = 1;
    if (fAbort){
        abort();    // Raises SIGABRT
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\baseobj.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//
// This module contains the base object for CDatasource, CDBSession, CCommand,
// and CRowset.  It contains routines such as globally registering the object 
// for the cleanup routine and typing the object so persist an other internal
// implementation can know what object they are talking to.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor for this class
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CBaseObj::CBaseObj(	EBaseObjectType botVal,         // IN Base Object Type
	                LPUNKNOWN		pUnkOuter		// IN Outer Unknown Pointer  
                    ) : m_cs(TRUE)
{

	m_BaseObjectType = botVal;
	m_cRef = 0;
	m_pUnkOuter = pUnkOuter? pUnkOuter : LPUNKNOWN(this);
	InterlockedIncrement(&g_cObj);

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor for this class
//
//        
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CBaseObj::~CBaseObj()
{
	InterlockedDecrement(&g_cObj);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Return Base Object type name.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
WCHAR * CBaseObj::GetBaseObjectTypeName()
{
#ifdef DEBUG
	static WCHAR * s_wszName[] = {
		L"Unknown",
		L"DataSource",
		L"Session",
		L"Command",
		L"Rowset",
		L"Error",
		L"ClassFactory",
		L"Enumerator",
		L"TransactionOptions",
	};
	assert(m_BaseObjectType >= BOT_DATASOURCE	&&     m_BaseObjectType <= BOT_MULTIPLERESULTS);
	return s_wszName[m_BaseObjectType];
#else
	return L"";
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\autobloc.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Generic class which encapsulates CCriticalSection class
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _AUTOBLOC_H_
#define _AUTOBLOC_H_

class CAutoBlock
{
private:
	CCriticalSection *m_pCriticalSection;

public:
	CAutoBlock(CCriticalSection *pCriticalSection);
	~CAutoBlock();
};

inline CAutoBlock::CAutoBlock(CCriticalSection *pCriticalSection)
{
	m_pCriticalSection = NULL;
	if(pCriticalSection)
		pCriticalSection->Enter();

	m_pCriticalSection = pCriticalSection;
}

inline CAutoBlock::~CAutoBlock()
{
	if(m_pCriticalSection)
		m_pCriticalSection->Leave();

}


#endif	// _AUTOBLOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\baseobj.h ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// BaseObj.h | CBaseObj Definitions
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __BASEOBJ_H__
#define __BASEOBJ_H__


#include "headers.h"
#include "critsec.h"
// Used in some classes that wish to distinguish behavior based on object type.
// (i.e. cast a void* to either CDataSource, CDBSession, CCommand, CRowset, etc.)
// Note that CBaseObj::GetBaseObjectTypeName() depends.
enum EBaseObjectType
	{
	BOT_UNDEFINED,
	BOT_DATASOURCE,
	BOT_SESSION,
	BOT_COMMAND,
	BOT_ROWSET,
	BOT_ENUMERATOR,
	BOT_ERROR,
    BOT_BINDER,
	BOT_TXNOPTIONS
	};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CBaseObj is the base object for CDatasource, CDBSession, CCommand, and CRowset
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning(disable : 4275)
class CBaseObj : public IUnknown		//@base public | IUnknown
{
    private: 
    	EBaseObjectType		m_BaseObjectType;
    	CCriticalSection	m_cs;
    	DEBUGCODE(ULONG		m_hObjCollection);

protected: 

    	LPUNKNOWN			m_pUnkOuter;
	    ULONG				m_cRef;

protected:
    	CBaseObj(EBaseObjectType botVal, LPUNKNOWN pUnkOuter);

public: 
    	virtual ~CBaseObj();

	    EBaseObjectType GetBaseObjectType()		{ return m_BaseObjectType; }
        WCHAR * GetBaseObjectTypeName();
    	CCriticalSection * GetCriticalSection()	{ return &m_cs; }

	// Get the outer unknown. Used by another object to call QI on this object.
	// (Which should go through outer unknown instead of direct.)
	    inline IUnknown* GetOuterUnknown()		{ return m_pUnkOuter; }
};
#pragma warning(default : 4275)

#endif  // __BASEOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\baserowobj.h ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// @module baseRowobj.h  Header file of abstract base class of CRow and CRowset
// 
//
///////////////////////////////////////////////////////////////////////////////////
#ifndef _ROWSETBASE_H_
#define _ROWSETBASE_H_

#include "headers.h"
#include "bitarray.h"
#include "extbuff.h"
#include "hashtbl.h"


#define NUMBER_OF_COLUMNS_IN_QUALIFERROWSET 4
#define COLNAMESIZE							255
#define QUALIFERNAMECOL						0

#define	ONE_ROW								1

#define QUALIFIERNAMECOL					1
#define QUALIFIERTYPECOL					2
#define QUALIFIERVALCOL						3
#define QUALIFIERFLAVOR						4



class CImpIRowsetLocate;
class CImpIRowsetChange;
class CImpIColumnsInfo;
class CImpIAccessor;
class CImpIRowsetInfo;
class CImpIRowsetIdentity;
class CImpIConvertType;
class CImpIChapteredRowset;
class CRowFetchObj;
class CInstanceRowFetchObj;
class CQualifierRowFetchObj;
class CRowset;

class CChapterMgr;
class CInstance;
class CWMIInstanceMgr;

typedef CImpIRowsetLocate*	PIMPIROWSET;
typedef CImpIRowsetLocate*	PIMPIROWSETLOCATE;
typedef CImpIRowsetChange*	PIMPIROWSETCHANGE;
typedef CImpIColumnsInfo*	PIMPICOLUMNSINFO;
typedef CImpIAccessor *		PIMPIACCESSOR;
typedef CImpIRowsetIdentity*PIMPIROWSETIDENTITY;
typedef CImpIRowsetInfo*	PIMPIROWSETINFO;
typedef CImpIConvertType*	PIMPICONVERTTYPE;
typedef CImpIChapteredRowset* PICHAPTEREDROWSET;

typedef CRowFetchObj*		PROWFETCHOBJ;

//=====================================================
// Struct to hold column information for Rowsets/row
// showing qualifiers
//=====================================================
struct _qualifierColInfo
{
	PWSTR		pwszName;
	DBTYPE		wType;
	DBLENGTH	ulSize;
	DBSTATUS	dwStatus;

};

typedef _qualifierColInfo QUALIFIERCOLINFO;


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Class to manage Row Data
/////////////////////////////////////////////////////////////////////////////////////////////////////
class CRowDataMemMgr
{
    public:
        CRowDataMemMgr();
        ~CRowDataMemMgr();

        HRESULT SetColumnBind( DBORDINAL dwCol, PCOLUMNDATA pColumn );
        HRESULT ReAllocRowData();
        HRESULT AllocRowData(ULONG_PTR);
        HRESULT ResetColumns();

        HRESULT CommitColumnToRowData(CVARIANT & vVar,DBTYPE lType);
		HRESULT CommitColumnToRowData(CVARIANT & vVar, DBORDINAL nIndex,DBTYPE lType);
		void	ReleaseRowData();
		void	ReleaseBookMarkColumn();

    private:
    	PCOLUMNDATA *m_prgpColumnData;
        DBCOUNTITEM       m_cbTotalCols;
        DBORDINAL         m_nCurrentIndex;

};

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Class to manage column information
/////////////////////////////////////////////////////////////////////////////////////////////////////
class cRowColumnInfoMemMgr
{
    public:

        cRowColumnInfoMemMgr(cRowColumnInfoMemMgr *pSrcRsColInfo = NULL);
        ~cRowColumnInfoMemMgr();

        DBTYPE			ColumnType(DBORDINAL icol);
		WCHAR *			ColumnName(DBORDINAL icol);
		DBCOLUMNFLAGS	ColumnFlags(DBORDINAL icol);
		DBORDINAL		GetColOrdinal(WCHAR *pColName);
		LONG			GetCIMType(DBORDINAL icol);
        ULONG_PTR		SetRowSize();

        DBBYTEOFFSET	GetDataOffset(DBORDINAL icol);
        WCHAR *			ColumnNameListStartingPoint();
        DBORDINAL		GetCurrentIndex();

        HRESULT			CopyColumnInfoList(DBCOLUMNINFO *& pNew,BOOL bBookMark = TRUE);
        HRESULT			CopyColumnNamesList(WCHAR *& pNew);
        
        DBCOLUMNINFO ** CurrentColInfo();
		DBCOLUMNINFO *	GetColInfo(DBORDINAL icol);

        WCHAR *			ColumnNameListStartingPointOfSrcRs();
        DBLENGTH			GetCountOfBytesCopiedForSrcRs();

        HRESULT			AddColumnNameToList(WCHAR * pColumnName, DBCOLUMNINFO ** pCol);
		// NTRaid:111762
		// 06/13/00
        HRESULT			CommitColumnInfo();
        HRESULT			ResetColumns();

        HRESULT			ReAllocColumnInfoList();
        HRESULT			AllocColumnInfoList(DBCOUNTITEM cCols);
        HRESULT			AllocColumnNameList(DBCOUNTITEM nCols);

        HRESULT			FreeUnusedMemory();
        HRESULT			FreeColumnNameList();
        HRESULT			FreeColumnInfoList();
		HRESULT			InitializeBookMarkColumn();
		DBCOUNTITEM		GetTotalNumberOfColumns();				// This includes all the columns including the sources rowsets
		DBCOUNTITEM		GetNumberOfColumnsInSourceRowset();
		void			SetCIMType(ULONG dwCIMType,DBORDINAL lIndex = -1); // IF index is -1 then set the CIMTYPE of the current col

    protected:
	    WCHAR *					m_pbColumnNames;            //Pointer to Info Array Heap (heap of column name strings)
	    WCHAR *					m_lpCurrentName;            //Pointer to Info Array Heap (heap of column name strings)
		DBCOUNTITEM       		m_cbFreeColumnNameBytes;    // how many bytes of the column names heap is in use
        DBCOUNTITEM             m_cbColumnInfoBytesUsed;	// count of bytes used for column information
		DBCOLUMNINFO*			m_DBColInfoList;            // ColumnInfo array
		DBBYTEOFFSET*			m_rgdwDataOffsets;	        // column offsets in buffer
        DBORDINAL               m_cbCurrentIndex;			// The current index of column information
        DBCOUNTITEM             m_cbTotalCols;				// number of columns
        DBCOLUMNINFO *          m_pCurrentColInfo;			// Pointer to the current column information
        DBBYTEOFFSET            m_dwOffset;					
		cRowColumnInfoMemMgr *	m_pSrcRsColInfo;   			// pointer to the the rowset that created this
																	// Mainly used with row objects. If there are any 
																	// new rows apart from the source rowset

		DBORDINAL				m_nFirstIndex;				// Index of the first column if there is any source
															// rowset for the row
		ULONG	*				m_rgCIMType;				// array to store the base CIMTYP of the property
};


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Abstract Base class for CRow and CRowset class
/////////////////////////////////////////////////////////////////////////////////////////////////////
class CBaseRowObj:public CBaseObj
{
	friend class CImpIColumnsInfo;
	friend class CImpIConvertType;
	friend class CRowFetchObj;
	friend class CInstanceRowFetchObj;
	friend class CQualifierRowFetchObj;
	friend class CRowset;

protected:

    CWmiOleDBMap *			m_pMap;					//	CWmiOleDBMap class pointer to interact with WMI
	cRowColumnInfoMemMgr	m_Columns;				//  Column information class
    CRowDataMemMgr  *		m_pRowData;				//  pointer to Row data manager to manage row data
	CChapterMgr	*			m_pChapterMgr;			//  chapter manager of the rowset to manage chapters

    DBCOUNTITEM				m_cTotalCols;			// Total number of columns
	DBCOUNTITEM				m_cCols;			    // Count of Parent Columns in Result Set
    DBCOUNTITEM				m_cNestedCols;          // Number of child rowsets ( chaptered columns)
    BYTE *					m_rgbRowData;			// Pointer to row data of the current row that rowset/row is dealing

    PCUTILPROP				m_pUtilProp;            // Utility object to manage properties

	PIMPICOLUMNSINFO		m_pIColumnsInfo;		// Contained IColumnsInfo
	PIMPICONVERTTYPE		m_pIConvertType;        // Contained IConvertType
	PLSTSLOT        		m_pIBuffer;             // internal buffer structure
	PIMPISUPPORTERRORINFO	m_pISupportErrorInfo;	// contained ISupportErrorInfo

	DBLENGTH           		m_cbRowSize;            // size of row data in the buffer
	unsigned int			m_uRsType;				// Type of the rowset/row
	ULONG					m_ulProps;				// member variable storing value of some commonly used rowset properties
	HROW					m_hRow;					// member variable that stores the last HROW given out

	//Back pointer to a creator object. Used in IRowssetInfo::GetSpecification
	PCDBSESSION             m_pCreator;  

	CWbemConnectionWrapper* m_pCon;					// This used for remote/cross namespace objects to
													// to store their IWbemServicesPointer
	BOOL					m_bNewConAllocated;		// variable which indicates whether m_pCon was allocated or not

	BOOL					m_IsZoombie;			// flag which indicates whether the object is in Zoombie state


	HRESULT		GatherColumnInfo(void);         	                	//Builds DBCOLINFO structures
	HROW		GetNextHRow() { return ++ m_hRow; };
	
	HRESULT		GetRowsetProperty(DBPROPID propId , VARIANT & varValue);
	void		GetCommonRowsetProperties();
    HRESULT		GetColumnInfo();
	DBORDINAL	GetOrdinalFromColName(WCHAR *pColName);
	HRESULT		SetRowsetProperty(DBPROPID propId , VARIANT varValue);
	HRESULT		RefreshInstance(CWbemClassWrapper *pInstance);

	HRESULT		SynchronizeDataSourceMode();
	HRESULT		GatherColumnInfoForQualifierRowset();
	ULONG		GetQualifierFlags();
    DBLENGTH	GetRowSize()      { return m_cbRowSize;}
	HRESULT		SetProperties(const ULONG cPropertySets, const DBPROPSET	rgPropertySets[] );
	HRESULT		SetSearchPreferences();
	BOOL		IsZoombie() { return m_IsZoombie; }
	
	INSTANCELISTTYPE GetObjectTypeProp(const ULONG cPropertySets, const DBPROPSET	rgPropertySets[]);
	HRESULT InitializePropertiesForSchemaRowset();
	HRESULT InitializePropertiesForCommandRowset();
	HRESULT InitializePropertiesForMethodRowset();

	// This function is to be overridden by derived classes
	virtual HRESULT GetColumnInfo(DBORDINAL* pcColumns, DBCOLUMNINFO** prgInfo,WCHAR** ppStringsBuffer) = 0;
	virtual HRESULT AddInterfacesForISupportErrorInfo() = 0;
	

public:

	CBaseRowObj(LPUNKNOWN pUnkOuter);
	~CBaseRowObj();

	// IUnknown methods
	STDMETHODIMP			QueryInterface(REFIID, LPVOID *) = 0;
	STDMETHODIMP_(ULONG)	AddRef(void) = 0;
	STDMETHODIMP_(ULONG)	Release(void) = 0;
	
	void SetStatusToZoombie() { m_IsZoombie = TRUE; }

};





/////////////////////////////////////////////////////////////////////////////////////////////////////
// A linked list class to store list of HROWS for a particular chapter
/////////////////////////////////////////////////////////////////////////////////////////////////////
class CHRowsForChapter
{
	friend class CChapter;
	friend class CChapterMgr;

	HROW				m_hRow;
	CHRowsForChapter *	m_pNext;
	HSLOT				m_hSlot;
	CWbemClassWrapper * m_pInstance;
	BSTR				m_strKey;
	DBSTATUS			m_dwStatus;

	CHRowsForChapter() 
	{ 
		m_hRow		= 0;
		m_pNext		= NULL;
		m_hSlot		= -1;
		m_pInstance = NULL;
		m_strKey	= NULL;
		m_dwStatus	= DBROWSTATUS_S_OK;
	}
	~CHRowsForChapter()
	{
		if(m_strKey != NULL)
		{
			SysFreeString(m_strKey);
		}
	}
	void		SetRowStatus(DWORD dwStatus) { m_dwStatus = dwStatus ; };
	DBSTATUS	GetRowStatus() { return m_dwStatus; };
};


/////////////////////////////////////////////////////////////////////////////////////////////////////
// class to maintain HCHAPTER to Rowset mapping
/////////////////////////////////////////////////////////////////////////////////////////////////////
class CChapter
{
	friend class CChapterMgr;
	CChapter();
	~CChapter();
	
	HRESULT		AddHRow(HROW hRow = 0, CWbemClassWrapper *pInstance = NULL, HSLOT hSlot = -1);
	HRESULT		DeleteHRow(HROW hRow);
	HRESULT		IsHRowOfThisChapter(HROW hRow);
	HRESULT		GetAllHRowsInList(HROW *pHRows);
	HRESULT		SetSlot(HROW hRow , HSLOT hSolt);
	HSLOT		GetSlot(HROW hRow);
	HRESULT		SetInstance(HROW hRow ,BSTR strInstKey , CWbemClassWrapper *pInstance);		// This method is for chapter representing child rows of type Embeded classes
	HRESULT		GetInstanceKey(HROW hRow , BSTR *pstrKey);
	void		SetRowStatus(HROW hRow, DBSTATUS dwStatus);
	DBSTATUS	GetRowStatus(HROW hRow);
	HROW		GetHRow(BSTR strInstKey);

	CWbemClassWrapper * GetInstance(HROW hRow);							// This method is for chapter representing child rows of type Embeded classes
	
private:
	CHRowsForChapter *	m_pFirstRow;
	HCHAPTER			m_hChapter;
	ULONG				m_cRefChapter;
	CWbemClassWrapper *	m_pInstance;
	BSTR				m_strKey;
	CChapter *			m_pNext;
	ULONG_PTR			m_lCount;							// count of HROWS in the list
	DBSTATUS			m_dwStatus;
};


/////////////////////////////////////////////////////////////////////////////////////////////////////
// class to maintain Chapters for a rowset
/////////////////////////////////////////////////////////////////////////////////////////////////////
class CChapterMgr
{
	CChapter *	m_pHead;						
	ULONG_PTR	m_lCount;	// count of Chapters in the list

public:
	CChapterMgr();
	~CChapterMgr();

	HRESULT					AddChapter(HCHAPTER hChapter);
	HRESULT					DeleteChapter(HCHAPTER hChapter);

	void					SetInstance(HCHAPTER hChapter , CWbemClassWrapper *pInstance,BSTR strKey,HROW hRow = 0);
	CWbemClassWrapper *		GetInstance(HCHAPTER hChapter , HROW hRow = 0);
	HRESULT					GetInstanceKey(HCHAPTER hChapter, BSTR *pstrKey , HROW hRow = 0);

	HRESULT					AddHRowForChapter(HCHAPTER hChapter , HROW hRow, CWbemClassWrapper *pInstance = NULL, HSLOT hSlot = -1);
	HRESULT					SetSlot(HROW hRow , HSLOT hSlot);
	HRESULT					DeleteHRow(HROW hRow);

	HCHAPTER				GetChapterForHRow(HROW hRow);
	HSLOT					GetSlot(HROW hRow);
	BOOL					IsRowExists(HROW hRow);
	BOOL					IsExists(HCHAPTER hChapter);
	BOOL					IsInstanceExist(BSTR strKey);
	BOOL					IsInstanceExist(CWbemClassWrapper *pInstance);

	ULONG					AddRefChapter(HCHAPTER hChapter);
	ULONG					ReleaseRefChapter(HCHAPTER hChapter);
	HRESULT					GetAllHROWs(HROW *&prghRows , DBCOUNTITEM &cRows);
	HRESULT					IsRowExistsForChapter(HCHAPTER hChapter);
	void					SetRowStatus(HROW hRow , DWORD dwStatus);
	DBSTATUS				GetRowStatus(HROW hRow);
	void					SetChapterStatus(HCHAPTER hChapter , DBSTATUS dwStatus);
	DBSTATUS				GetChapterStatus(HCHAPTER hChapter);

	HROW					GetHRow(HCHAPTER hChapter ,BSTR strKey = Wmioledb_SysAllocString(NULL));

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\asserts.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Assertion Routines
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _ASSERTS_H_
#define _ASSERTS_H_

//====================================================================================
// Global function prototypes -- helper stuff
// The assert and trace macros below calls these.
//====================================================================================

void OLEDB_Assert(LPSTR expression, LPSTR filename, long linenum);
void OLEDB_Trace(const char* format, ...);

//====================================================================================
// Debugging macros
//
// Ensure "DEBUG" is set if "_DEBUG" is set.
//====================================================================================

#ifdef _DEBUG
# ifndef DEBUG
#  define DEBUG 1
# endif
#endif

//====================================================================================
// Ensure no previous versions of our macros.
//====================================================================================
#ifdef  assert
# undef assert
#endif
#ifdef  Assert
# undef Assert
#endif
#ifdef  ASSERT
# undef ASSERT
#endif
#ifdef  TRACE
# undef TRACE
#endif


#ifdef DEBUG
# define assert(x) { if ( ! (x) ) OLEDB_Assert( #x, __FILE__, __LINE__ ); }
# define Assert(x) assert(x)
# define ASSERT(x) assert(x)
# define VERIFY(x) assert(x)
# define TRACE  OLEDB_Trace
# define DEBUGCODE(p) p
#else	// DEBUG
# define assert(x)  ((void)0)
# define Assert(x)  ((void)0)
# define ASSERT(x)  ((void)0)
# define VERIFY(x)  ((void)(x))
# define TRACE  OLEDB_Trace
  inline void OLEDB_Trace( const char *format, ... ) { /* do nothing */ }
# define DEBUGCODE(p)
#endif	// DEBUG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\baserowobj.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CBaseRowObj base class implementation
// 
//
///////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

// NTRaid : 146015
// 07/19/00
QUALIFIERCOLINFO rgQualfierColInfo[] =	{	{L"QualifierName",	DBTYPE_BSTR ,	-1,				0},
											{L"DataType",		DBTYPE_UI4  ,	sizeof(long),	0},
											{L"Value",			DBTYPE_VARIANT,	sizeof(VARIANT),	DBCOLUMNFLAGS_WRITE},
											{L"Flavor",			DBTYPE_UI4,		sizeof(long),	0} 
										};



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CBaseRowObj::CBaseRowObj(LPUNKNOWN pUnkOuter): CBaseObj(BOT_ROWSET, pUnkOuter)
{
	m_pMap				= NULL;
	m_pRowData			= NULL;				
	m_pChapterMgr		= NULL;
	m_rgbRowData		= NULL;
	m_pUtilProp			= NULL;
	m_pIBuffer			= NULL;

	m_pIColumnsInfo		= NULL;
	m_pIConvertType		= NULL;
	m_pCon				= NULL;
	m_bNewConAllocated	= FALSE;
	m_IsZoombie			= FALSE;
	
	m_pISupportErrorInfo = NULL;

	m_cTotalCols		= 0;
	m_cCols				= 0;
	m_cNestedCols		= 0;
	m_cbRowSize			= 0;
	m_uRsType			= 0;
	m_ulProps			= 0;
	m_hRow				= 0;
	
														
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CBaseRowObj::~CBaseRowObj()
{
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get Column Information
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBaseRowObj::GatherColumnInfo()
{
    HRESULT hr = S_OK;

	switch(	m_uRsType)
	{
        case SCHEMA_ROWSET:
        case METHOD_ROWSET:
        case COMMAND_ROWSET:
		case 0 :

			//=============================================================
			// Get the number of columns
			//=============================================================
			hr = m_pMap->GetColumnInfoForParentColumns(&m_Columns);
			break;


		case PROPERTYQUALIFIER:
		case CLASSQUALIFIER:

			//==================================================================================
			// Get the number of columns for the property qualifier
			//==================================================================================
			hr = GatherColumnInfoForQualifierRowset();
			break;

		default:
			hr = E_FAIL;
			break;

	};

    if( hr == S_OK )
	{
        m_cbRowSize = m_Columns.SetRowSize();
        hr = m_Columns.FreeUnusedMemory();
    }

  	
    return hr;


}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get a value of a Rowset property
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBaseRowObj::GetRowsetProperty(DBPROPID propId , VARIANT & varValue)
{
	DBPROPIDSET	rgPropertyIDSets[1];
	ULONG		cPropertySets		= 0;	
	DBPROPSET*	prgPropertySets		= NULL;
	DBPROPID	rgPropId[1];
	HRESULT		hr					= S_OK;


	VariantClear(&varValue);

    //========================================================================
    // Get the value of the required rowset property
    //========================================================================
	rgPropertyIDSets[0].guidPropertySet	= DBPROPSET_ROWSET;
	rgPropertyIDSets[0].rgPropertyIDs	= rgPropId;
	rgPropertyIDSets[0].cPropertyIDs	= 1;
	rgPropId[0]							= propId;

    if( S_OK == (hr = m_pUtilProp->GetProperties( PROPSET_ROWSET,	1, rgPropertyIDSets,&cPropertySets,	&prgPropertySets )))
		VariantCopy(&varValue,&prgPropertySets->rgProperties->vValue);

    //==========================================================================
	//  Free memory we allocated to by GetProperties
    //==========================================================================
	m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropertySets, prgPropertySets);
	
	return hr;

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get some of the boolean properties of the rowset to set a particular bit in the flag in one of the member variables
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CBaseRowObj::GetCommonRowsetProperties()
{
	VARIANT vPropVal;
	VariantInit(&vPropVal);
	HRESULT hr = 0;

	if(S_OK == GetRowsetProperty(DBPROP_CANHOLDROWS,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= CANHOLDROWS;
			VariantClear(&vPropVal);
		}
	}


	if(S_OK == GetRowsetProperty(DBPROP_CANSCROLLBACKWARDS,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= CANSCROLLBACKWARDS;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_CANFETCHBACKWARDS,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= CANFETCHBACKWARDS;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_OTHERUPDATEDELETE,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= OTHERUPDATEDELETE;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_OWNINSERT,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= OWNINSERT;
			VariantClear(&vPropVal);
		}
	}


	if(S_OK == GetRowsetProperty(DBPROP_REMOVEDELETED,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= REMOVEDELETED;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_OTHERINSERT,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= OTHERINSERT;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_OWNUPDATEDELETE,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= OWNUPDATEDELETE;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_IRowsetChange,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= IROWSETCHANGE;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_BOOKMARKS,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= BOOKMARKPROP;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_WMIOLEDB_FETCHDEEP,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= FETCHDEEP;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_IRowsetLocate,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= IROWSETLOCATE;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_IGetRow,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= IGETROW;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_IRowsetRefresh,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= IROWSETREFRESH;
			VariantClear(&vPropVal);
		}
	}

	if(S_OK == GetRowsetProperty(DBPROP_IChapteredRowset,vPropVal))
	{
		if(V_BOOL(&vPropVal) == VARIANT_TRUE)
		{
			m_ulProps |= ICHAPTEREDROWSET;
			VariantClear(&vPropVal);
		}
	}

}



//////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the column information
// Get the information about the various properties of the classes if rowset is refering to a class
// Get the information of the the different qualifiers if rowset is referring to qualifiers
//////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBaseRowObj::GetColumnInfo(void)
{
    HRESULT hr = S_OK;

	//==================================================================================
	// switch on type of the recordset. If it is 0 then the recordset is 
	// representing the instances of the class
	//==================================================================================
	switch(	m_uRsType)
	{
        case SCHEMA_ROWSET:
        case COMMAND_ROWSET:
        case METHOD_ROWSET:
		case 0 :

			//==================================================================================
			// Get the count of columns in the table
			//==================================================================================
			hr = m_pMap->GetColumnCount(m_cTotalCols,m_cCols,m_cNestedCols);
			break;

		case PROPERTYQUALIFIER :
		case CLASSQUALIFIER:

			//==================================================================================
			// Get the number of columns for the property qualifier
			//==================================================================================
			m_cCols			= NUMBER_OF_COLUMNS_IN_QUALIFERROWSET + 1;	// for first column which should be always used
																		// as bookmark
			m_cTotalCols = m_cCols;
			break;

		default:
			hr = E_FAIL;
			break;

	};


	if( SUCCEEDED(hr))
	{
			// NTRaid : 142133 & 141923
			// 07/12/00
			if(m_cTotalCols == 0)
			{
				hr = S_OK;
			}
			else
			{
				if( S_OK == (hr = m_Columns.AllocColumnNameList(m_cTotalCols)) ){

					//===============================================================================
					//  Allocate the DBCOLUMNINFO structs to match the number of columns
					//===============================================================================
					if( S_OK == (hr = m_Columns.AllocColumnInfoList(m_cTotalCols))){
						m_Columns.InitializeBookMarkColumn();
						hr = GatherColumnInfo();
					}
				}
			}
	}

    //==================================================================================
    // Free the columnlist if more is allocated
    //==================================================================================
    if( hr != S_OK ){
        m_Columns.FreeColumnNameList();
        m_Columns.FreeColumnInfoList();
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get ordinal of the column given the column name
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
DBORDINAL CBaseRowObj::GetOrdinalFromColName(WCHAR *pColName)
{
	return m_Columns.GetColOrdinal(pColName);
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set a particular rowset property
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBaseRowObj::SetRowsetProperty(DBPROPID propId , VARIANT varValue)
{

	DBPROPSET	rgPropertySets[1];
	DBPROP		rgprop[1];
	HRESULT		hr				= S_OK;


	memset(&rgprop[0],0,sizeof(DBPROP));
	memset(&rgPropertySets[0],0,sizeof(DBPROPSET));

	rgprop[0].dwPropertyID = propId;
	VariantCopy(&rgprop[0].vValue,&varValue);

	rgPropertySets[0].rgProperties		= &rgprop[0];
	rgPropertySets[0].cProperties		= 1;
	rgPropertySets[0].guidPropertySet	= DBPROPSET_ROWSET;


	hr = m_pUtilProp->SetProperties( PROPSET_ROWSET,1,rgPropertySets);

	VariantClear(&rgprop[0].vValue);

	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Refresh the instance pointer
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT	CBaseRowObj::RefreshInstance(CWbemClassWrapper *pInstance)
{
	return m_pMap->RefreshInstance(pInstance);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the mode property of the Datasource and set the UPDATIBILITY property of the rowset accordingly
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT	CBaseRowObj::SynchronizeDataSourceMode()
{
	HRESULT hr = S_OK;
	BOOL bUpdate = TRUE;

	VARIANT varPropValue;
	VariantInit(&varPropValue);

	//==================================================
	// Get the mode property of the datasource
	//==================================================
	if(S_OK == (hr = m_pCreator->GetDataSrcProperty(DBPROP_INIT_MODE,varPropValue)))
	{
		switch(varPropValue.lVal)
		{
			case DB_MODE_READ:
				bUpdate = FALSE;
				break;

			case DB_MODE_SHARE_DENY_WRITE:
				bUpdate = FALSE;
				break;

		}
	}

	//===============================================================
	// If the datasource is opened in readonly then set the rowset
	// property to readonly
	//===============================================================
	if(bUpdate == FALSE)
	{
		varPropValue.lVal = 0;
		SetRowsetProperty(DBPROP_UPDATABILITY , varPropValue);
	}


	return hr;


}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get Column information for rowset representing qualifiers
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBaseRowObj::GatherColumnInfoForQualifierRowset()
{
	HRESULT hr = S_OK;
	m_Columns.ResetColumns();
	CDataMap DataMap;
	DBCOLUMNINFO **ppColCurColInfo = NULL;

	//======================================================================================
	// Column information for rowset showing qualifer is constant and is stored in array
	// Get this information from this array an put it into the column information mgr
	//======================================================================================
	for( int nIndex = 0 ; nIndex < NUMBER_OF_COLUMNS_IN_QUALIFERROWSET ; nIndex++)
	{
		ppColCurColInfo = m_Columns.CurrentColInfo();
		hr = m_Columns.AddColumnNameToList(rgQualfierColInfo[nIndex].pwszName, ppColCurColInfo);
        if( hr == S_OK )
		{
			m_pMap->SetCommonDBCOLUMNINFO(ppColCurColInfo, m_Columns.GetCurrentIndex());

			(*ppColCurColInfo)->wType			= rgQualfierColInfo[nIndex].wType;
			(*ppColCurColInfo)->ulColumnSize	= rgQualfierColInfo[nIndex].ulSize;
			(*ppColCurColInfo)->dwFlags			= rgQualfierColInfo[nIndex].dwStatus;

			// NTRaid:111762
			// 06/13/00
		    hr = m_Columns.CommitColumnInfo();
		}
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the mode property of the Datasource and set the UPDATIBILITY property of the rowset accordingly
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CBaseRowObj::GetQualifierFlags()
{
	HRESULT hr = S_OK;
	ULONG	lRet = 0;

	VARIANT varPropValue;
	VariantInit(&varPropValue);

	//===============================================================================================
	// Get the value of DBPROP_WMIOLEDB_QUALIFIERS property whether to show qualifiers or not
	//===============================================================================================
	if(S_OK == (hr = m_pCreator->GetDataSrcProperty(DBPROP_WMIOLEDB_QUALIFIERS,varPropValue)))
	{
		lRet = varPropValue.lVal;
	}


	return lRet;


}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//	Set properties on the object
//////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBaseRowObj::SetProperties(const ULONG cPropertySets, const DBPROPSET	rgPropertySets[] )
{
    HRESULT hr = S_OK;
	VARIANT varPropVal;
	VariantInit(&varPropVal);
	LONG lFlag = 0;

    //============================================================================
	//Set rowset properties
    //============================================================================
    if ( cPropertySets > 0 ) 
	{

        DBPROPSET* pPropSets = (DBPROPSET*)rgPropertySets;
		//=====================================================
		// Check the arguments
		//=====================================================
	    if( S_OK == (hr = m_pUtilProp->SetPropertiesArgChk(cPropertySets, pPropSets)))
		{

			hr = m_pUtilProp->SetProperties(PROPSET_ROWSET, cPropertySets, pPropSets);

			if( (hr == DB_E_ERRORSOCCURRED) ||   (hr == DB_S_ERRORSOCCURRED) )
			{
				//====================================================================
				// If all the properties set were OPTIONAL then we can set 
				// our status to DB_S_ERRORSOCCURRED and continue.
				//====================================================================
				for(ULONG ul=0;ul<cPropertySets; ul++) 
				{

					for(ULONG ul2=0;ul2<rgPropertySets[ul].cProperties; ul2++)
					{

						//============================================================
						// Check for a required property that failed, if found, we 
						// must return DB_E_ERRORSOCCURRED
						//============================================================
						if( (rgPropertySets[ul].rgProperties[ul2].dwStatus != DBPROPSTATUS_NOTSETTABLE) &&
							(rgPropertySets[ul].rgProperties[ul2].dwStatus != DBPROPSTATUS_OK) &&
							(rgPropertySets[ul].rgProperties[ul2].dwOptions != DBPROPOPTIONS_OPTIONAL) ) 
						{
							hr =  DB_E_ERRORSOCCURRED ;
							break;
						}
					}
				}
			}
		}
    }
    
    //============================================================================
	// call this function to set the DBPROP_UPDATIBILITY to readonly if the Datasource
	// open mode is readonly
    //============================================================================
	if( (hr == S_OK) ||   (hr == DB_S_ERRORSOCCURRED) )
	{
		SynchronizeDataSourceMode();
		hr = S_OK;
	}

	return hr;
	
}


//////////////////////////////////////////////////////////////////////////////////////////////////////
//	Set Search preference
//////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBaseRowObj::SetSearchPreferences()
{
	HRESULT		hr = S_OK;
	DBPROPIDSET	rgPropertyIDSets[1];
	ULONG		cPropertySets;
	DBPROPSET*	prgPropertySets;
	DBPROPID	rgPropId[NUMBEROF_SEARCHPREF];

	rgPropId[0]								= DBPROP_WMIOLEDB_DS_DEREFALIAS;
	rgPropId[1]								= DBPROP_WMIOLEDB_DS_SIZELIMIT;
	rgPropId[2]								= DBPROP_WMIOLEDB_DS_PAGEDTIMELIMIT;
	rgPropId[3]								= DBPROP_WMIOLEDB_DS_ASYNCH;
	rgPropId[4]								= DBPROP_WMIOLEDB_DS_SEARCHSCOPE;
	rgPropId[5]								= DBPROP_WMIOLEDB_DS_TIMEOUT;
	rgPropId[6]								= DBPROP_WMIOLEDB_DS_PAGESIZE;
	rgPropId[7]								= DBPROP_WMIOLEDB_DS_TIMELIMIT;
	rgPropId[8]								= DBPROP_WMIOLEDB_DS_CHASEREF;
	rgPropId[9]								= DBPROP_WMIOLEDB_DS_FILTER;
	rgPropId[10]							= DBPROP_WMIOLEDB_DS_CACHERESULTS;
	rgPropId[11]							= DBPROP_WMIOLEDB_DS_ATTRIBUTES;
	rgPropId[12]							= DBPROP_WMIOLEDB_DS_TOMBSTONE;
	rgPropId[13]							= DBPROP_WMIOLEDB_DS_ATTRIBONLY;

	rgPropertyIDSets[0].guidPropertySet		= DBPROPSET_ROWSET;
	rgPropertyIDSets[0].rgPropertyIDs		= rgPropId;
	rgPropertyIDSets[0].cPropertyIDs		= NUMBEROF_SEARCHPREF;

	//==============================================================================
	// Get the value of the DBPROP_INIT_DATASOURCE property, this is the namespace
    // to be opened.
	//==============================================================================
	hr = m_pUtilProp->GetProperties( PROPSET_ROWSET,1, rgPropertyIDSets,&cPropertySets,&prgPropertySets );
    if( SUCCEEDED(hr) )
	{
		hr = m_pMap->SetSearchPreferences(prgPropertySets->cProperties,prgPropertySets[0].rgProperties);
    	//==========================================================================
        //  Free memory we allocated to get the namespace property above
    	//==========================================================================
        m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropertySets, prgPropertySets);
	}

	return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get a DBPROP_WMIOLEDB_OBJECTTYPE property . 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
INSTANCELISTTYPE CBaseRowObj::GetObjectTypeProp(const ULONG cPropertySets, const DBPROPSET	rgPropertySets[])
{
	INSTANCELISTTYPE instType = SCOPE;
	BOOL bFound = FALSE;


	for( ULONG lIndex = 0 ; lIndex < cPropertySets ; lIndex++)
	{
		if(rgPropertySets[lIndex].guidPropertySet == DBPROPSET_ROWSET ||
			rgPropertySets[lIndex].guidPropertySet == DBPROPSET_WMIOLEDB_ROWSET )
		{
			for ( ULONG nPropIndex = 0 ; nPropIndex < rgPropertySets[lIndex].cProperties ; nPropIndex++ )
			{
				if(rgPropertySets[lIndex].rgProperties[nPropIndex].dwPropertyID == DBPROP_WMIOLEDB_OBJECTTYPE)
				{
					instType = rgPropertySets[lIndex].rgProperties[nPropIndex].vValue.lVal == DBPROPVAL_SCOPEOBJ ? SCOPE : CONTAINER;
					bFound = TRUE;
					break;
				} // if DBPROP_IRow is true;
			
			}// for loop
		
		} // if propertyset is DBPROPSET_ROWSET or DBPROPSET_WMIOLEDB_ROWSET
		if(bFound)
		{
			break;
		}
	
	} // outer for loop
	
	return instType;
}

// set rowset properties for Schema rowset
HRESULT CBaseRowObj::InitializePropertiesForSchemaRowset()
{

	HRESULT	hr		= S_OK;
	LONG	lIndex	= 0;

	DBPROPSET	rgPropertySets[1];
	DBPROP		rgprop[5];

	memset(&rgprop[0],0,sizeof(DBPROP) * 5);
	memset(&rgPropertySets[0],0,sizeof(DBPROPSET));

	rgprop[0].dwPropertyID	= DBPROP_UPDATABILITY;
	rgprop[1].dwPropertyID	= DBPROP_IRowsetChange;
	rgprop[2].dwPropertyID	= DBPROP_IRowsetLocate;
	rgprop[3].dwPropertyID	= DBPROP_BOOKMARKS;
	rgprop[4].dwPropertyID	= DBPROP_IGetRow;

	rgprop[0].vValue.vt		= VT_I4;
	rgprop[0].vValue.lVal	= 0;

	for(lIndex = 1 ; lIndex < 5 ; lIndex++)
	{
		rgprop[lIndex].vValue.vt		= VT_BOOL;
		rgprop[lIndex].vValue.boolVal	= VARIANT_FALSE;
	}

	rgPropertySets[0].rgProperties		= &rgprop[0];
	rgPropertySets[0].cProperties		= 5;
	rgPropertySets[0].guidPropertySet	= DBPROPSET_ROWSET;


	hr = m_pUtilProp->SetProperties( PROPSET_ROWSET,1,rgPropertySets);

	return hr;
}

// set rowset properties for command rowset
HRESULT CBaseRowObj::InitializePropertiesForCommandRowset()
{

	HRESULT	hr		= S_OK;
	LONG	lIndex	= 0;

	DBPROPSET	rgPropertySets[1];
	DBPROP		rgprop[2];

	memset(&rgprop[0],0,sizeof(DBPROP) * 2);
	memset(&rgPropertySets[0],0,sizeof(DBPROPSET));

	rgprop[0].dwPropertyID	= DBPROP_IRowsetLocate;
	rgprop[1].dwPropertyID	= DBPROP_BOOKMARKS;

	for(lIndex = 0 ; lIndex < 2 ; lIndex++)
	{
		rgprop[lIndex].vValue.vt		= VT_BOOL;
		rgprop[lIndex].vValue.boolVal	= VARIANT_FALSE;
	}

	rgPropertySets[0].rgProperties		= &rgprop[0];
	rgPropertySets[0].cProperties		= 2;
	rgPropertySets[0].guidPropertySet	= DBPROPSET_ROWSET;


	hr = m_pUtilProp->SetProperties( PROPSET_ROWSET,1,rgPropertySets);

	return hr;
}

// set rowset properties for method rowset
HRESULT CBaseRowObj::InitializePropertiesForMethodRowset()
{

	HRESULT	hr		= S_OK;
	LONG	lIndex	= 0;

	DBPROPSET	rgPropertySets[1];
	DBPROP		rgprop[5];

	memset(&rgprop[0],0,sizeof(DBPROP) * 5);
	memset(&rgPropertySets[0],0,sizeof(DBPROPSET));

	rgprop[0].dwPropertyID	= DBPROP_UPDATABILITY;
	rgprop[1].dwPropertyID	= DBPROP_IRowsetChange;
	rgprop[2].dwPropertyID	= DBPROP_IRowsetLocate;
	rgprop[3].dwPropertyID	= DBPROP_BOOKMARKS;
	rgprop[4].dwPropertyID	= DBPROP_IGetRow;

	rgprop[0].vValue.vt		= VT_I4;
	rgprop[0].vValue.lVal	= 0;

	for(lIndex = 1 ; lIndex < 5 ; lIndex++)
	{
		rgprop[lIndex].vValue.vt		= VT_BOOL;
		rgprop[lIndex].vValue.boolVal	= VARIANT_FALSE;
	}

	rgPropertySets[0].rgProperties		= &rgprop[0];
	rgPropertySets[0].cProperties		= 5;
	rgPropertySets[0].guidPropertySet	= DBPROPSET_ROWSET;


	hr = m_pUtilProp->SetProperties( PROPSET_ROWSET,1,rgPropertySets);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\binder.h ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// @module Binder.h | Binder.cpp base object and contained interface
// 
//
///////////////////////////////////////////////////////////////////////////////////

#ifndef _BINDER_H_
#define _BINDER_H_

#include "headers.h"

// forward declaration
class CImplICreateRow;
class CImplIDBBinderProperties;
class CImplIBindResource;

typedef CImplICreateRow*			PICREATEROW;
typedef CImplIDBBinderProperties*	PIDBBINDERPROPERTIES;
typedef CImplIBindResource*			PIDBBINDRESOURCE;
typedef CDBSession*					PDBSESSION;

class CBinder:public CBaseObj
{
	friend class CImplICreateRow;
	friend class CImplIDBBinderProperties;
	friend class CImplIBindResource;

 	CDataSource*					m_pDataSrc;
   	CDBSession*		                m_pSession;		//Parent Session Object
	PICREATEROW						m_pICreateRow;
	PIDBBINDERPROPERTIES			m_pIBinderProperties;
	PIDBBINDRESOURCE				m_pIBindResource;
	PIMPISUPPORTERRORINFO			m_pISupportErrorInfo;			// contained ISupportErrorInfo

	CUtilProp*						m_pUtilProp;
	CURLParser*						m_pUrlParser;

	BOOL							m_fDSOInitialized;

	HRESULT CreateDSO(IUnknown *pUnkOuter,LONG lInitFlag, REFGUID guidTemp,IUnknown ** ppUnk);
	HRESULT CreateSession(IUnknown *pUnkOuter, REFGUID guidTemp,IUnknown ** ppUnk);
	HRESULT CreateCommand(IUnknown *pUnkOuter, REFGUID guidTemp,IUnknown ** ppUnk);
	HRESULT CreateRow(IUnknown *pUnkOuter, REFGUID guidTemp,IUnknown ** ppUnk , ROWCREATEBINDFLAG rowCreateFlag = ROWOPEN);
	HRESULT CreateRowset(IUnknown *pUnkOuter, REFGUID guidTemp,IUnknown ** ppUnk);

//	void	GetInitAndBindFlagsFromBindFlags(DBBINDURLFLAG dwBindURLFlags,LONG & lInitMode ,LONG & lInitBindFlags);
	HRESULT ReleaseAllObjects();
	HRESULT	AddInterfacesForISupportErrorInfo();
	
public:

	CBinder(LPUNKNOWN pUnkOuter);
	~CBinder();

	HRESULT					InitBinder();
	STDMETHODIMP			QueryInterface(REFIID, LPVOID *);
	STDMETHODIMP_(ULONG)	AddRef(void);
	STDMETHODIMP_(ULONG)	Release(void);

};


class CImplIBindResource : public IBindResource
{
private:
		CBinder		*m_pObj;											
		DEBUGCODE(ULONG m_cRef);

		BOOL	CheckBindURLFlags(DBBINDURLFLAG dwBindURLFlags , REFGUID rguid);	// Function to check if proper flags are
																				// are set for the require object
		// To check if URL Matches the requested type of object
		BOOL	CheckIfProperURL(BSTR & strUrl,REFGUID rguid,DBBINDURLSTATUS * pdwBindStatus);

		HRESULT BindURL(IUnknown *            pUnkOuter,
					 LPCOLESTR             pwszURL,
					 DBBINDURLFLAG         dwBindURLFlags,
					 REFGUID               rguid,
					 REFIID                riid,
					 DBIMPLICITSESSION *   pImplSession,
					 DBBINDURLSTATUS *     pdwBindStatus,
					 IUnknown **           ppUnk);
		
//		void	GetInitAndBindFlagsFromBindFlags(DBBINDURLFLAG dwBindURLFlags,LONG & lInitMode ,LONG & lInitBindFlags);

	public: 
		CImplIBindResource( CBinder *pObj )				
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImplIBindResource()													
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP Bind( IUnknown *            pUnkOuter,
						   LPCOLESTR             pwszURL,
						   DBBINDURLFLAG         dwBindURLFlags,
						   REFGUID               rguid,
						   REFIID                riid,
						   IAuthenticate *       pAuthenticate,
						   DBIMPLICITSESSION *   pImplSession,
						   DBBINDURLSTATUS *     pdwBindStatus,
						   IUnknown **           ppUnk);

};


class CImplICreateRow : public ICreateRow
{
	private:
		CBinder		*m_pObj;											
		DEBUGCODE(ULONG m_cRef);
		
		BOOL	CheckBindURLFlags(DBBINDURLFLAG dwBindURLFlags , REFGUID rguid);
		BOOL	CheckIfProperURL(BSTR & strUrl,REFGUID rguid,DBBINDURLSTATUS * pdwBindStatus);
		HRESULT BindURL(	IUnknown *            pUnkOuter,
							LPCOLESTR             pwszURL,
							DBBINDURLFLAG         dwBindURLFlags,
							REFGUID               rguid,
							REFIID                riid,
							DBIMPLICITSESSION *   pImplSession,
							DBBINDURLSTATUS *     pdwBindStatus,
							IUnknown **           ppUnk);

		HRESULT CreateNewRow(	IUnknown *            pUnkOuter,
							LPCOLESTR             pwszURL,
							DBBINDURLFLAG         dwBindURLFlags,
							REFGUID               rguid,
							REFIID                riid,
							DBIMPLICITSESSION *   pImplSession,
							DBBINDURLSTATUS *     pdwBindStatus,
							IUnknown **           ppUnk);


	public: 
		CImplICreateRow( CBinder *pObj )				
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImplICreateRow()													
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}


		STDMETHODIMP CreateRow(IUnknown *           pUnkOuter,
							   LPCOLESTR            pwszURL,
							   DBBINDURLFLAG        dwBindURLFlags,
							   REFGUID              rguid,
							   REFIID               riid,
							   IAuthenticate *       pAuthenticate,
							   DBIMPLICITSESSION *   pImplSession,
							   DBBINDURLSTATUS *     pdwBindStatus,
							   LPOLESTR *            ppwszNewURL,
							   IUnknown **           ppUnk);



};



class CImplIDBBinderProperties : public IDBBinderProperties
{
private:
		CBinder		*m_pObj;											
		DEBUGCODE(ULONG m_cRef);
		DWORD GetBitMask(REFGUID rguid);

	public: 
		CImplIDBBinderProperties( CBinder *pObj )				
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImplIDBBinderProperties()													
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		//==========================================================
		//	IDBProperties member functions
		//==========================================================
        STDMETHODIMP GetProperties										// GetProperties method
		        	(
						ULONG				cPropertySets,		
				      	const DBPROPIDSET	rgPropertySets[], 	
			        	ULONG*              pcProperties, 	
					 	DBPROPSET**			prgProperties 	    
		        	);

        STDMETHODIMP    GetPropertyInfo									// GetPropertyInfo method
                        ( 
							ULONG				cPropertySets, 
							const DBPROPIDSET	rgPropertySets[],
							ULONG*				pcPropertyInfoSets, 
							DBPROPINFOSET**		prgPropertyInfoSets,
							WCHAR**				ppDescBuffer
                        );

        
        STDMETHODIMP	SetProperties									// SetProperties method
					 	(
							ULONG				cProperties,		
						 	DBPROPSET			rgProperties[] 	    
						);

		STDMETHODIMP Reset();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\binder.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CBinder object implementation
// 
//
///////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "WmiOleDBMap.h"


///////////////////////////////////////////////////////////////////////////////////
//	Constructor
///////////////////////////////////////////////////////////////////////////////////
CBinder::CBinder(LPUNKNOWN pUnkOuter) : CBaseObj(BOT_BINDER,pUnkOuter)
{
	m_cRef					= 0;

	m_pICreateRow			= NULL;
	m_pIBinderProperties	= NULL;
	m_pIBindResource		= NULL;
	m_pISupportErrorInfo	= NULL;

	m_pDataSrc				= NULL;
	m_pSession				= NULL;

	m_pUrlParser			= NULL;

	m_fDSOInitialized		= FALSE;

	//===============================================================
    // Increment global object count.
	//===============================================================
	InterlockedIncrement(&g_cObj);
}

///////////////////////////////////////////////////////////////////////////////////
//	Destructor
///////////////////////////////////////////////////////////////////////////////////
CBinder::~CBinder()
{
	HRESULT hr = S_OK;
	IDBInitialize *pInitialize = NULL;
	
	SAFE_RELEASE_PTR(m_pSession);

	SAFE_RELEASE_PTR(m_pDataSrc);
	SAFE_DELETE_PTR(m_pICreateRow);
	SAFE_DELETE_PTR(m_pIBinderProperties);
	SAFE_DELETE_PTR(m_pIBindResource);
	SAFE_DELETE_PTR(m_pISupportErrorInfo);

	SAFE_DELETE_PTR(m_pUrlParser);
	SAFE_DELETE_PTR(m_pUtilProp);

	//===============================================================
    // Decrement global object count.
	//===============================================================
    InterlockedDecrement(&g_cObj);
}




/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to navigate between the different interfaces
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBinder::QueryInterface ( REFIID riid, LPVOID * ppv)
{
    HRESULT hr = S_OK;


    //======================================================
    //  Check parameters, if not valid return
    //======================================================
    if (NULL == ppv){
        hr = E_INVALIDARG ;
    }
	else
	{
		//======================================================
		//  Place NULL in *ppv in case of failure
		//======================================================
		*ppv = NULL;

		//======================================================
		//  This is the non-delegating IUnknown implementation
		//======================================================
		if (riid == IID_IUnknown)
		{
			*ppv = (LPVOID) this;
		}
		else if (riid == IID_IBindResource)
		{
			*ppv = (LPVOID) m_pIBindResource;
		}
		else if (riid == IID_IDBBinderProperties || riid == IID_IDBProperties)
		{
			*ppv = (LPVOID) m_pIBinderProperties;
		}
		else if (riid == IID_ICreateRow)
		{
			*ppv = (LPVOID) m_pICreateRow;
		}
		else if(riid == IID_ISupportErrorInfo)
		{
			*ppv = (LPVOID)m_pISupportErrorInfo;
		}
		

		//======================================================
		//  If we're going to return an interface, AddRef first
		//======================================================
		if (*ppv){
			((LPUNKNOWN) *ppv)->AddRef();
			hr = S_OK ;
		}
		else{
			hr =  E_NOINTERFACE;
		}
	}
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Increments a persistence count for the object
//
// Current reference count
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CBinder::AddRef(  void   )
{
    return InterlockedIncrement((long*)&m_cRef);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrements a persistence count for the object and if persistence count is 0, the object
// destroys itself.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CBinder::Release( void   )
{
    InterlockedDecrement((long*)&m_cRef);
    if (!m_cRef){
		g_pIDataConvert->Release();
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to initialize the binder object
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBinder::InitBinder()
{
	HRESULT	hr		= S_OK;
	BOOL	bRet	= TRUE;

	//================================================
	// Instantiate the data conversion service object
	//================================================
	if( !g_pIDataConvert ){

		hr = CoCreateInstance(CLSID_OLEDB_CONVERSIONLIBRARY, NULL, CLSCTX_INPROC_SERVER, IID_IDataConvert, (void **)&g_pIDataConvert);
	}
	else
	{
		//============================================
		// Already instantiated, increment reference 
		// count
		//============================================
		g_pIDataConvert->AddRef();
	}

	if(SUCCEEDED(hr))
	{
		IDCInfo *pDcInfo = NULL;
		DCINFO dcInfo[1];

		dcInfo[0].eInfoType = DCINFOTYPE_VERSION;
		V_VT(&dcInfo[0].vData) = VT_UI4;
		V_UI4(&dcInfo[0].vData) = 0x200;

		hr = g_pIDataConvert->QueryInterface(IID_IDCInfo,(void **)&pDcInfo);
		hr = pDcInfo->SetInfo(1,dcInfo);

		//================================================
		// Allocate properties management object
		//================================================
		m_pUtilProp = new CUtilProp;
		
		if(m_pUtilProp == NULL)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		// NTRaid: 136443
		// 07/05/00
		if(SUCCEEDED(hr = m_pUtilProp->FInit(BINDERPROP)))
		{
			//================================================
			// Allocate the URLParser class
			//================================================
			m_pUrlParser			= new CURLParser;

			//================================================
			//  Allocate contained interface objects
			//================================================
			m_pIBindResource		= new CImplIBindResource( this );
			m_pICreateRow			= new CImplICreateRow( this );
			m_pIBinderProperties	= new CImplIDBBinderProperties( this );
			m_pISupportErrorInfo	= new CImpISupportErrorInfo(this);

			if(!((BOOL)(m_pUtilProp && m_pUrlParser && m_pIBindResource &&   m_pICreateRow &&  m_pIBinderProperties && m_pISupportErrorInfo)))
			{
				hr = E_OUTOFMEMORY;
			}
		}
	}

	if(SUCCEEDED(hr))
	{
		hr = AddInterfacesForISupportErrorInfo();
	}

    return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to add interfaces to ISupportErrorInfo interface
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBinder::AddInterfacesForISupportErrorInfo()
{
	HRESULT hr = S_OK;

	if(SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IBindResource)))
	if(SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IDBBinderProperties)))
	if(SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IDBProperties)))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_ICreateRow);
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to Create a Datasource object. The init flat parameter is the flags obtained 
// from the binder flags passed to the IBinderResource::Bind function
// If the caller needs a pointer to a particular interface , then the id of the interface 
// required will be passed in riid parmeter , otherwise this parameter will be GUID_NULL
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBinder::CreateDSO(IUnknown *pUnkOuter,LONG lInitFlag, REFGUID riid,IUnknown ** ppUnk)
{
	HRESULT			hr				= E_FAIL;
	IDBInitialize *	pInitialize		= NULL;
	IDBProperties *	pDBProperties	= NULL;

	DBPROPSET	rgPropertySets[1];
	DBPROPIDSET rgPropIDSet[1];

	DBPROP		rgprop[1];
	VARIANT		varValue;
	ULONG		cPropSets		= 1;
	DBPROPSET*	prgPropertySets;
	DBPROPID	rgPropId[1];



	if(m_pDataSrc != NULL)
	{
		hr = S_OK;
		if( riid != GUID_NULL)
		{
			//=============================================
			// Get the required interface pointer 
			//=============================================
			hr = m_pDataSrc->QueryInterface(riid , (void **)ppUnk);
		}
	}
	else
	{
		memset(&rgprop[0],0,sizeof(DBPROP));
		memset(&rgPropertySets[0],0,sizeof(DBPROPSET));

		VariantInit(&varValue);
		CDataSource *pDatasource = NULL;
		try
		{
			//=============================================
			// Allocate a new datasource object
			//=============================================
			pDatasource = new CDataSource( pUnkOuter );
		}
		catch(...)
		{
			SAFE_DELETE_PTR(pDatasource);
			throw;
		}
		if(pDatasource == NULL)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		if(SUCCEEDED(hr = pDatasource->FInit()))
		{
			//==================================================================
			// QI for IUnknown and save pointer in the member variable
			//==================================================================
			if(SUCCEEDED(hr =pDatasource->QueryInterface(IID_IUnknown , (void **)&m_pDataSrc)))
			if(SUCCEEDED(hr = m_pDataSrc->QueryInterface(IID_IDBProperties ,(void **)&pDBProperties)))
			{
				rgPropIDSet[0].cPropertyIDs		= 0;
				rgPropIDSet[0].guidPropertySet	= DBPROPSET_DBINIT;

				//==================================================================
				// Get the properties set thru IDBBinderProperties
				//==================================================================
				hr = m_pUtilProp->GetProperties(PROPSET_INIT,0,rgPropIDSet, &cPropSets,&prgPropertySets);

				if(SUCCEEDED(hr = pDBProperties->SetProperties(cPropSets,prgPropertySets)))
				{

    				//==========================================================================
					//  Free memory we allocated to by GetProperties
    				//==========================================================================
					m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropSets, prgPropertySets);


					rgPropId[0]								= DBPROP_INIT_DATASOURCE;

					rgPropIDSet[0].guidPropertySet		= DBPROPSET_DBINIT;
					rgPropIDSet[0].rgPropertyIDs		= rgPropId;
					rgPropIDSet[0].cPropertyIDs		= 1;

					hr = m_pUtilProp->GetProperties( PROPSET_INIT,1, rgPropIDSet,&cPropSets,&prgPropertySets );
					
					if(SUCCEEDED(hr))
					{
						// if the property set is not empty then get the property DBPROP_INIT_DATASOURCE
						// else extract it from URL
						if(prgPropertySets[0].rgProperties[0].vValue.vt == VT_BSTR && 
							prgPropertySets[0].rgProperties[0].vValue.bstrVal != NULL &&
							SysStringLen(prgPropertySets[0].rgProperties[0].vValue.bstrVal) > 0)
						{
							rgprop[0].vValue.bstrVal = Wmioledb_SysAllocString(prgPropertySets[0].rgProperties[0].vValue.bstrVal);
						}
						else
						{
							m_pUrlParser->GetNameSpace(rgprop[0].vValue.bstrVal);
						}
    					
						//==========================================================================
						//  Free memory we allocated to by GetProperties
    					//==========================================================================
						m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropSets, prgPropertySets);

						//==================================================================
						// Get the namespace from the Parser and then set
						// the DBPROP_INIT_DATASOURCE property
						//==================================================================
						rgprop[0].dwPropertyID = DBPROP_INIT_DATASOURCE;
						rgprop[0].vValue.vt		= VT_BSTR;
	//					m_pUrlParser->GetNameSpace(rgprop[0].vValue.bstrVal);

						rgPropertySets[0].rgProperties		= &rgprop[0];
						rgPropertySets[0].cProperties		= 1;
						rgPropertySets[0].guidPropertySet	= DBPROPSET_DBINIT;

						if(SUCCEEDED(hr = pDBProperties->SetProperties(1,rgPropertySets)))
						{
							// set the properties on the current property handler
							hr = m_pUtilProp->SetProperties(PROPSET_INIT,1,rgPropertySets);
						}


						SAFE_FREE_SYSSTRING(rgprop[0].vValue.bstrVal);
					}

					if(SUCCEEDED(hr))
					{
					
						VariantClear(&(rgprop[0].vValue));
															
						//========================================
						// Setting the DBPROP_DBINIT property
						//========================================
						rgprop[0].dwPropertyID = DBPROP_INIT_MODE;
						rgprop[0].vValue.vt =VT_I4;
						rgprop[0].vValue.lVal	= lInitFlag;

						rgPropertySets[0].rgProperties		= &rgprop[0];
						rgPropertySets[0].cProperties		= 1;
						rgPropertySets[0].guidPropertySet	= DBPROPSET_DBINIT;

						if(SUCCEEDED(hr = pDBProperties->SetProperties(1,rgPropertySets)) &&
							SUCCEEDED(hr = m_pUtilProp->SetProperties(PROPSET_INIT,1,rgPropertySets)))
						{
							//===============================================
							// Get the pointer to IDBInitialize interface
							//===============================================
							hr = m_pDataSrc->QueryInterface(IID_IDBInitialize, (void **)&pInitialize);

							//===============================================================
							// Initialize the Datasource object if
							// the flag does not indicate waiting for the initialization
							//===============================================================
							if(!(lInitFlag & DBBINDURLFLAG_WAITFORINIT))
							{
								if(S_OK == (hr = pInitialize->Initialize()))
									m_fDSOInitialized = TRUE;
							}

							if(S_OK == hr)
							{

								if( riid != GUID_NULL)
								{
									//========================================
									// Get the required interface pointer 
									//========================================
									hr = m_pDataSrc->QueryInterface(riid , (void **)ppUnk);
								}
							}
							pInitialize->Release();
							pDBProperties->Release();
						
						} // If(Succeeded(call to SetProperties)) of DBPROP_INIT_MODE property
					
					} // If(Succeeded(call to SetProperties)) of DBPROP_INIT_DATASOURCE property
				
				} // If(Succeeded(call to SetProperties))
			
			} // If Succeeded() for QI
		
		}  // if(Succeeded(pDatasource->FInit()))
		else
		{
			hr = E_FAIL;
		}
	
	}	// Else for if(m_pDataSrc != NULL)

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to create a session object
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBinder::CreateSession(IUnknown *pUnkOuter, REFGUID riid,IUnknown ** ppUnk)
{
	HRESULT hr = S_OK;

	IDBCreateSession *	pDBCreateSession	= NULL;
	IDBInitialize *		pInitialize			= NULL;

	assert(m_pDataSrc != NULL);

	//====================================================================
	// If the datasource is not yet initialized , then initialize it
	//====================================================================
	if(m_fDSOInitialized == FALSE)
	{
		//================================================
		// Get the pointer to IDBInitialize interface
		//================================================
		hr = m_pDataSrc->QueryInterface(IID_IDBInitialize, (void **)&pInitialize);

		if(S_OK == (hr = pInitialize->Initialize()))
		{
			m_fDSOInitialized = TRUE;
		}
		pInitialize->Release();
	}
	
	if(SUCCEEDED(hr))
	if(S_OK ==(hr = m_pDataSrc->QueryInterface(IID_IDBCreateSession,(void **)&pDBCreateSession)))
	{
		//======================
		// Create session
		//======================
		if(S_OK ==(hr = pDBCreateSession->CreateSession(pUnkOuter,IID_IUnknown,(IUnknown**)&m_pSession)))
		{
			if(riid != GUID_NULL)
			{
				hr = m_pSession->QueryInterface(riid,(void **)ppUnk);
			}
		}
	}

	if(pDBCreateSession)
	{
		pDBCreateSession->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to create a Command object
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBinder::CreateCommand(IUnknown *pUnkOuter, REFGUID guidTemp,IUnknown ** ppUnk)
{

	return m_pSession->CreateCommand(pUnkOuter, guidTemp,ppUnk);

}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to create a required row object
// NTRaid:136539 , 136540
// 07/05/00
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBinder::CreateRow(IUnknown *pUnkOuter, REFGUID riid,IUnknown ** ppUnk ,ROWCREATEBINDFLAG rowCreateFlag)
{
	HRESULT				hr			= E_FAIL;
	IUnknown *			pUnkRow		= NULL;
	BSTR				strTable	= NULL;
	BSTR				strPath		= NULL;
	CDBSession *		pDBSess		= NULL;
	ISessionProperties *pSessProp	= NULL;
	CRow *				pNewRow		= NULL;
	DBPROPSET *			pPropSet	= NULL;

	if( S_OK == (hr = m_pSession->QueryInterface(IID_ISessionProperties , (void **)&pSessProp)))
	{

		pDBSess = ((CImpISessionProperties *)pSessProp)->GetSessionPtr();
		
		pSessProp->Release();

		// Get the path of the object
		hr = m_pUrlParser->GetPathWithEmbededInstInfo(strPath);

		// Get the class name 
//		m_pUrlParser->GetClassName(strTable);
		// NTRaid : 134967
		// 07/12/00
		if(SUCCEEDED(hr) && SUCCEEDED(hr = m_pUtilProp->GetConnectionInitProperties(&pPropSet)))
		{
			hr = GetClassName(m_pUrlParser,pPropSet,strTable,m_pDataSrc->m_pWbemWrap);
		}
		
		//==========================================================================
		//  Free memory we allocated to get the namespace property above
		//==========================================================================
		CPropertyMemoryMgr::FreeDBPROPSET( 1, pPropSet);

		if(SUCCEEDED(hr))
		{
			try
			{
				// currently hardcoded to NO_QUALIFIERS 
				pNewRow = new CRow(pUnkOuter,pDBSess);
			}
			catch(...)
			{
				SAFE_DELETE_PTR(pNewRow);
				throw;
			}


			if( pNewRow == NULL)
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				if(S_OK ==(hr = pNewRow->InitRow(strPath,strTable,-1,rowCreateFlag)))
				{
					hr = pNewRow->QueryInterface(riid,(void **)ppUnk);
				}

				if(hr == S_OK && rowCreateFlag != ROWOPEN)
				{
					hr = pNewRow->UpdateKeysForNewInstance();
				}
			}
			//========================================================
			// Free the strings allocated by the URLParser class
			//========================================================
			SysFreeString(strTable);
			SysFreeString(strPath);
		}
		
		if(FAILED(hr))
		{
			SAFE_DELETE_PTR(pNewRow);
			*ppUnk = NULL;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to create a Rowset object
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBinder::CreateRowset(IUnknown *pUnkOuter, REFGUID riid,IUnknown ** ppUnk)
{
	HRESULT			hr			= E_FAIL;
	IOpenRowset *	pOpenRowset	= NULL;
	DBPROPSET *		pPropSet	= NULL;
	ULONG			cPropSets	= 1;

	DBPROPSET*	prgPropertySets	= NULL;
	BSTR		strTableName = NULL;

	assert(m_pSession != NULL);

   	//=========================================
	// Get pointer to IOpenRowset interface
   	//=========================================
	if(S_OK == (hr = m_pSession->QueryInterface(IID_IOpenRowset , (void **)&pOpenRowset)))
	{
		DBPROPIDSET rgPropIDSet[1];
		rgPropIDSet[0].cPropertyIDs		= 0;
		rgPropIDSet[0].guidPropertySet	= DBPROPSET_ROWSET;

	   	//=========================================
		// Get the properties
	   	//=========================================
		hr = m_pUtilProp->GetProperties(PROPSET_ROWSET,0,rgPropIDSet, &cPropSets,&prgPropertySets);

	   	//=========================================
		// Get the class name and initialize the tableID
	   	//=========================================
		// NTRaid : 134967
		// 07/12/00
		if(SUCCEEDED(hr))
		{		
			if (SUCCEEDED(hr = m_pUtilProp->GetConnectionInitProperties(&pPropSet)))
			{
				hr = GetClassName(m_pUrlParser,pPropSet,strTableName,m_pDataSrc->m_pWbemWrap);

				if (SUCCEEDED(hr))
				{
					DBID tableID;
					memset(&tableID , 0 , sizeof(DBID));
					tableID.eKind = DBKIND_NAME;
					tableID.uName.pwszName = strTableName;

	   				//=========================================
					// Open the rowset
	   				//=========================================
					hr = pOpenRowset->OpenRowset(pUnkOuter,&tableID,NULL,riid,cPropSets,prgPropertySets,ppUnk);

					SAFE_FREE_SYSSTRING(strTableName);
				}

				//==========================================================================
				//  Free memory we allocated to get the namespace property above
				//==========================================================================
				CPropertyMemoryMgr::FreeDBPROPSET( 1, pPropSet);

			}

    		//==========================================================================
			//  Free memory we allocated to by GetProperties
    		//==========================================================================
			m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropSets, prgPropertySets);
		}
	}

	SAFE_RELEASE_PTR(pOpenRowset);

	return hr;
}


/*
///////////////////////////////////////////////////////////////////////////////////////////////////
// Get Binding flags and put it in a variable as INIT_MODE flags
///////////////////////////////////////////////////////////////////////////////////////////////////
void CBinder::GetInitAndBindFlagsFromBindFlags(DBBINDURLFLAG dwBindURLFlags,LONG & lInitMode ,LONG & lInitBindFlags)
{

	lInitMode = 0;
	lInitBindFlags = 0;

	// DBPROP_INIT_MODE
	if(DBBINDURLFLAG_READ & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_READ;
	}

	if(DBBINDURLFLAG_WRITE & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_WRITE;
	}

	if(DBBINDURLFLAG_SHARE_DENY_READ & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_SHARE_DENY_READ;
	}

	if(DBBINDURLFLAG_SHARE_DENY_WRITE & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_SHARE_DENY_WRITE;
	}

	if(DBBINDURLFLAG_SHARE_EXCLUSIVE & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_SHARE_EXCLUSIVE;
	}

	if(DBBINDURLFLAG_SHARE_DENY_NONE & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_SHARE_DENY_NONE;
	}

	// DBPROP_INIT_BINDFLAGS
	if(DBBINDURLFLAG_RECURSIVE & dwBindURLFlags)
	{
		lInitBindFlags = lInitBindFlags | DB_BINDFLAGS_RECURSIVE;
	}

	if(DBBINDURLFLAG_OUTPUT & dwBindURLFlags)
	{
		lInitBindFlags = lInitBindFlags | DB_BINDFLAGS_OUTPUT;
	}

	if(DBBINDURLFLAG_DELAYFETCHCOLUMNS & dwBindURLFlags)
	{
		lInitBindFlags = lInitBindFlags | DB_BINDFLAGS_DELAYFETCHCOLUMNS;
	}

	if(DBBINDURLFLAG_DELAYFETCHSTREAM & dwBindURLFlags)
	{
		lInitBindFlags = lInitBindFlags | DB_BINDFLAGS_DELAYFETCHSTREAM;
	}



}
*/
////////////////////////////////////////////////////////////
// Function to release all the bound objects
////////////////////////////////////////////////////////////
HRESULT CBinder::ReleaseAllObjects()
{
	SAFE_RELEASE_PTR(m_pDataSrc);
	SAFE_RELEASE_PTR(m_pSession);
	
	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\binderclassfac.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider 
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Class Definitions for CBinderClassFactory and DLL Entry Points
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _BINDERCLASSFAC_H_
#define _BINDERCLASSFAC_H_

//////////////////////////////////////////////////////////////////////////////////////////////////////////

class CBinderClassFactory : public IClassFactory		
{
	protected:
		ULONG			m_cRef;												//Reference count

	public: 
		CBinderClassFactory(void);
		~CBinderClassFactory(void);

		
		STDMETHODIMP			QueryInterface(REFIID, LPVOID *);			//Request an Interface
		STDMETHODIMP_(ULONG)	AddRef(void);								//Increments the Reference count
		STDMETHODIMP_(ULONG)	Release(void);								//Decrements the Reference count

		STDMETHODIMP			CreateInstance(LPUNKNOWN, REFIID, LPVOID *);//Instantiates an uninitialized instance of an object
		STDMETHODIMP			LockServer(BOOL);							//Lock Object so that it can not be unloaded
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\bitarray.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// This contains an implementation of a bit array class currently used by the Internal Buffer to 
// mark released or unreleased rows.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "bitarray.h"


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor for this class
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
CBitArray::CBitArray ( void  )
{
    m_rgbBit       = NULL;
    m_cPageMax     = 0;
    m_cPageCurrent = 0;
    m_cslotCurrent = 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor for this class
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
CBitArray:: ~CBitArray (void )
{
    if (m_rgbBit){

        if (m_cPageCurrent){
			VirtualFree((VOID *) m_rgbBit, m_cPageCurrent *m_cbPage, MEM_DECOMMIT );
		}

        VirtualFree((VOID *) m_rgbBit, 0, MEM_RELEASE );
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Allocate and Initialize the array of bits
//
// HRESULT indicating routines status
//        S_OK          | Initialization succeeded
//        E_OUTOFMEMORY | Not enough memory to allocate bit array
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBitArray::FInit(  HSLOT cslotMax,     //IN  Maximum number of slot
								ULONG cbPage        //IN  Count of bytes per page
							 )
{
    LONG_PTR cPage;
    BYTE ib;
	HRESULT hr = S_OK;

    cPage = (cslotMax / 8 + 1) / cbPage + 1;
    m_rgbBit = (BYTE *) VirtualAlloc( NULL, cbPage *cPage, MEM_RESERVE, PAGE_READWRITE );

    if (m_rgbBit == NULL){
        hr = E_OUTOFMEMORY;
	}
	else{

		m_cPageMax = cPage;
	    m_cbPage = cbPage;

		for (ib =0; ib < 8; ib++){
			m_rgbBitMask[ib] = (1 << ib);
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Set a range of bit slots
//
// HRESULT indicating routines status
//       S_OK           Initialization succeeded
//       E_OUTOFMEMORY  Not enough memory to allocate bit array
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBitArray::SetSlots (  HSLOT islotFirst,   //IN  First slot in range to set
									HSLOT islotLast     //IN  Last slot in range to set
								 )
{
    HSLOT islot;
	HRESULT hr = S_OK;

    if (islotLast >=    m_cslotCurrent){

        ULONG_PTR cPageAdd;

        cPageAdd = ((islotLast - m_cslotCurrent + 1) / 8 + 1) / m_cbPage + 1;

        if ((cPageAdd + m_cPageCurrent) > (ULONG_PTR)m_cPageMax  || VirtualAlloc( m_rgbBit + m_cPageCurrent*m_cbPage, cPageAdd *m_cbPage, MEM_COMMIT, PAGE_READWRITE ) == NULL){
			hr = E_OUTOFMEMORY;
		}
		else{
			memset( m_rgbBit + m_cPageCurrent*m_cbPage, 0x00, cPageAdd *m_cbPage );
			m_cPageCurrent += cPageAdd;
			m_cslotCurrent += cPageAdd *m_cbPage *8;
		}
	}

	if( hr == S_OK ){

		//=======================================================================================================
		// Only do this top section if we have at least 2 byte's worth of bits to set. Although no real speedup 
		// until we have 3 byte's worth. Note really ought to be ((ilast-ifirst+1) >= 2*8).
		// (Note could use CHAR_BIT, num bits in a char.) Also optimized end cases, so nothing is done
		// if the start or end is byte aligned. Need this copied into ResetSlots.
		//if((islotLast -islotFirst) > 2*sizeof(BYTE))
		//=======================================================================================================
		if (islotLast - islotFirst > 2 * 8){

			HSLOT ibFirst, ibLast;
			int iFixFirst, iFixLast;

			ibFirst = islotFirst / 8;
			ibLast  = islotLast / 8;
			iFixFirst = (islotFirst % 8 != 0);  // set to 1 if first byte not totally set
			iFixLast  = (islotLast % 8 != 7);   // set to 1 if last  byte not totally set

			if (iFixFirst){
				for (islot = islotFirst; (islot / 8) == ibFirst; islot++){
					m_rgbBit[islot / 8] |= m_rgbBitMask[islot % 8];
				}
			}

			memset( &m_rgbBit[ibFirst + iFixFirst], 0xff, ibLast - ibFirst + 1 - iFixFirst - iFixLast );

			if (iFixLast){
				for (islot = islotLast; (islot / 8) == ibLast; islot--){
					m_rgbBit[islot / 8] |= m_rgbBitMask[islot % 8];
				}
			}
		}
		else{
			for (islot = islotFirst; islot <= islotLast; islot++){
				m_rgbBit[islot / 8] |= m_rgbBitMask[islot % 8];
			}
		}
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Clear all bit slots
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID CBitArray::ResetAllSlots ( void  )
{
    memset( m_rgbBit, 0x00, m_cPageCurrent*m_cbPage );
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Reset a range of slots
//
// HRESULT indicating routines status
//      S_OK  Reset Succeeded
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBitArray::ResetSlots(  HSLOT islotFirst,   //IN  First slot in range to reset
									 HSLOT islotLast     //IN  Last slot in range to reset
								  )
{
    HSLOT ibFirst, ibLast, islot;

    if (islotFirst < m_cslotCurrent){
        if (islotLast >=    m_cslotCurrent){
            islotLast = m_cslotCurrent - 1;
		}

        if ((islotLast - islotFirst) > 2*8){
            ibFirst = islotFirst / 8;
            ibLast  = islotLast / 8;
            for (islot = islotFirst; (islot / 8) == ibFirst; islot++){
                m_rgbBit[islot / 8] &= ~m_rgbBitMask[islot % 8];
			}

            memset( &m_rgbBit[ibFirst + 1], 0x00, ibLast - ibFirst - 1 );
            for (islot = islotLast; (islot / 8) == ibLast; islot--){
                m_rgbBit[islot / 8] &= ~m_rgbBitMask[islot % 8];
            }
		}
        else{
            for (islot = islotFirst; islot <= islotLast; islot++){
                m_rgbBit[islot / 8] &= ~m_rgbBitMask[islot % 8];
            }
        }
	}

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Determines if any bits are set
//
// HRESULT indicating routines status
//       S_OK      Array is Empty
//       S_FALSE   Array contains set bits
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBitArray::ArrayEmpty ( void )
{
	HRESULT hr = S_OK;

    if (m_cPageCurrent){
        ULONG_PTR idw, cdw, *rgdw;

        cdw = m_cPageCurrent * (m_cbPage / sizeof( ULONG_PTR ));
        rgdw = (ULONG_PTR *) m_rgbBit;

        for (idw =0; idw < cdw; idw++){
            if (rgdw[idw]){
                hr = S_FALSE;
			}
        }
	}
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Determine if a particular bit slot is set
//
// HRESULT indicating routines status
//      S_OK           Slot is set
//      E_OUTOFMEMORY  Slot is not set
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBitArray::IsSlotSet( HSLOT islot )                //IN  Bit slot to check
{
	HRESULT hr = S_OK;

    if (islot >= m_cslotCurrent || (m_rgbBit[islot / 8] & m_rgbBitMask[islot % 8]) == 0x00){
        hr = S_FALSE;  // not set
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Find the first set slot within the bit array given a starting position
//
// HRESULT indicating routines status
//      S_OK           Initialization succeeded
//      E_OUTOFMEMORY  Not enough memory to allocate bit array
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBitArray::FindSet( HSLOT islotStart,   //IN  Starting slot to search from
								 HSLOT islotLimit,   //IN  Number of slots to check
								 HSLOT *pislot       //OUT Index of first set slot
								)
{
    HSLOT ibStart, ibLimit, idwStart, idwLimit, ibEnd, ib, islot, islotEnd, idw, *pdw;
	HRESULT hr		= E_FAIL;
	BOOL	bRet	= FALSE;
	BOOL	bFound	= FALSE;

	islot = islotLimit;

    if (islotStart > islotLimit)
	{

        ibStart  = islotStart / 8;
        ibLimit  = islotLimit / 8;

        if ((ibStart - ibLimit) > 1)
		{
            islotEnd = ibStart*8;

            for (islot = islotStart; islot >= islotEnd; islot--){
                if (m_rgbBit[islot / 8] & m_rgbBitMask[islot % 8]){
                    *pislot = islot;
                    hr = S_OK;
					bRet = TRUE;
					break;
                }
			}
			
			if(bRet == FALSE)
			{
				idwStart = islotStart / 32;
				idwLimit = islotLimit / 32;

				if (idwStart - idwLimit > 1)
				{
					ibEnd = idwStart*4;

					for (ib = ibStart - 1; ib >= ibEnd; ib--)
					{

						if (m_rgbBit[ib]){
							islot = ib*8 + 7;
							bFound = TRUE;
							break;
						}
					}
					
					if( bFound == FALSE)
					{
						for (pdw = (HSLOT *) & m_rgbBit[ (idwStart - 1) *4], idw = idwStart - 1; idw > idwLimit; idw--, pdw--)
						{
							if (*pdw)
							{
								islot = idw*32 + 31;
								bFound = TRUE;
								break;
							}
						}
						if(bFound == FALSE)
						{
							ib = (idwLimit*4 + 3);
						}
					}
				}

				else
				{
					ib = ibStart - 1;
				}

				if( bFound == FALSE)
				{
					for (; ib > ibLimit; ib--)
					{

						if (m_rgbBit[ib])
						{
							islot = ib*8 + 7;
							bFound = TRUE;
							break;
						}
					}
					if(bFound == FALSE)
					{
						islot = (ibLimit*8 + 7);
					}
				}
			}
        }
        else
		{

            islot = islotStart;
		}
	}


    if(bFound == TRUE)
	{
		for (; islot >= islotLimit; islot--)
		{
            if (m_rgbBit[islot / 8] & m_rgbBitMask[islot % 8])
			{
                *pislot = islot;
                hr = S_OK;
            }
		}
        hr = S_FALSE;  // not found
	}
 
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\classfac.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// The module contains the DLL Entry and Exit points, plus the OLE ClassFactory class.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//===============================================================================
//  Don't include everything from windows.h, but always bring in OLE 2 support
//===============================================================================
//#define WIN32_LEAN_AND_MEAN
#define INC_OLE2

//===============================================================================
// Basic Windows and OLE everything
//===============================================================================
#include <windows.h>


//===============================================================================
//  OLE DB headers
//===============================================================================
#include "oledb.h"
#include "oledberr.h"

//===============================================================================
//	Data conversion library header
//===============================================================================
#include "msdadc.h"

//===============================================================================
// Guids for data conversion library
//===============================================================================
#include "msdaguid.h"


//===============================================================================
//  GUIDs
//===============================================================================
#include "guids.h"
#include <cguid.h>
//===============================================================================
//  Common project stuff
//===============================================================================
#include "headers.h"
#include "classfac.h"
#include "binderclassfac.h"
#include "binder.h"
#include "schema.h"
#include "enumerat.h"



////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor for this class
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
CClassFactory::CClassFactory( void  )
{
    m_cRef = 0;

	//================================================================
    // Increment global object count
	//================================================================
    InterlockedIncrement(&g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor for this class
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
CClassFactory:: ~CClassFactory( void )
{
	//================================================================
    // Decrement global object count
	//================================================================
    InterlockedDecrement(&g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to a specified interface. Callers use QueryInterface to determine which interfaces 
// the called object supports.
//
//  HRESULT indicating the status of the method
//       S_OK           Interface is supported and ppvObject is set.
//       E_NOINTERFACE  Interface is not supported by the object
//       E_INVALIDARG   One or more arguments are invalid.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassFactory::QueryInterface ( REFIID riid,   // IN Interface ID of the interface being queried for.
							                 LPVOID *    ppvObj  // OUT Pointer to interface that was instantiated
                                            )
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//=================================================================
    // Check for valid ppvObj pointer
	//=================================================================
    if (!ppvObj){
        hr = E_INVALIDARG;
        LogMessage("QueryInterface:  Invalid argument pointer");
	}
	else{
		//=================================================================
		// In case we fail, we need to zero output arguments
		//=================================================================
		*ppvObj = NULL;

		//=================================================================
		// Do we support this interface?
		//=================================================================
		if (riid == IID_IUnknown || riid == IID_IClassFactory)
		{
			*ppvObj = (LPVOID) this;
		}

		//=================================================================
		// If we're going to return an interface, AddRef it first
		//=================================================================
		if (*ppvObj){
			((LPUNKNOWN) *ppvObj)->AddRef();
		}
		else{
			hr = E_NOINTERFACE;
            LogMessage("QueryInterface:  No interface");
		}
	}

	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::QueryInterface");
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Increments a persistence count for the object
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CClassFactory::AddRef( void )
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    hr = InterlockedIncrement((long*)&m_cRef);

	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::AddRef");

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrements a persistence count for the object and if persistence count is 0,the object destroys itself.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CClassFactory::Release( void )
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    if (!InterlockedDecrement((long*)&m_cRef)){
        delete this;
        return 0;
    }
	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::Release");
    return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Controls whether an object application is kept in memory. Keeping the application alive in memory 
//  allows instances of this class to be created more quickly.
//
//  HRESULT indicating the status of the method
//       S_OK  Interface is supported and ppvObject is set.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassFactory::LockServer ( BOOL fLock )                 // IN TRUE or FALSE to lock or unlock
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    if (fLock)
	{
        InterlockedIncrement( &g_cLock );
	}
    else
	{
        InterlockedDecrement( &g_cLock );
	}

	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::LockServer");
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CDataSourceClassFactory
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDataSourceClassFactory::CreateInstance( LPUNKNOWN	pUnkOuter, REFIID riid,	LPVOID * ppvObj	)
{
    PCDATASOURCE    pObj = NULL;
    HRESULT         hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//==============================================================
    // Check for valid ppvObj pointer
	//==============================================================
    if (ppvObj == NULL){
        LogMessage("CreateInstance:  Invalid argument pointer");
        hr = ( E_INVALIDARG );
    }
	else
	{
		//==============================================================
		// In case we fail, we need to zero output arguments
		//==============================================================
		*ppvObj = NULL;

		//==============================================================
		// If we're given a controlling IUnknown, it must ask for 
		// IUnknown. Otherwise, caller will end up getting a pointer to 
		// their pUnkOuter instead of to the new object we create and 
		// will have no way of getting back to this new object, so they 
		// won't be able to free it.  Bad!
		//==============================================================
		if (pUnkOuter && riid != IID_IUnknown){
			hr = DB_E_NOAGGREGATION;
			LogMessage("CreateInstance:  No aggregation");
		}
		else{
			//==========================================================
			// Prepare for the possibility that there might be an error
			//==========================================================
			hr = E_OUTOFMEMORY;
			try
			{
				pObj = new CDataSource( pUnkOuter );
			}
			catch(...)
			{
				SAFE_DELETE_PTR(pObj);
				throw;
			}
   			//==========================================================
			// Create a CDataSource object
			//==========================================================
			if ((pObj != NULL)){
				//======================================================
				// Initialize it
    			//======================================================
				if (SUCCEEDED(hr = pObj->FInit())){
					hr = pObj->QueryInterface( riid, ppvObj );
				}
				if (FAILED( hr )){
					LogMessage("CreateInstance:  Out of memory");
					SAFE_DELETE_PTR( pObj );
				}
			}
		}
	}

	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::CreateInstance for Datasource");

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CEnumeratorClassFactory
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEnumeratorClassFactory::CreateInstance( LPUNKNOWN	pUnkOuter, REFIID riid,	LPVOID * ppvObj	)
{
    CEnumeratorNameSpace*  pObj = NULL;
    HRESULT         hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//==============================================================
    // Check for valid ppvObj pointer
	//==============================================================
    if (ppvObj == NULL){
        LogMessage("CreateInstance:  Invalid argument pointer");
        hr =  E_INVALIDARG;
    }
	else
	{
		//==============================================================
		// In case we fail, we need to zero output arguments
		//==============================================================
		*ppvObj = NULL;

		//==============================================================
		// If we're given a controlling IUnknown, it must ask for 
		// IUnknown. Otherwise, caller will end up getting a pointer to 
		// their pUnkOuter instead of to the new object we create and 
		// will have no way of getting back to this new object, so they 
		// won't be able to free it.  Bad!
		//==============================================================
		if (pUnkOuter && riid != IID_IUnknown){
			hr = DB_E_NOAGGREGATION;
			LogMessage("CreateInstance:  No aggregation");
		}
		else{
			//==========================================================
			// Prepare for the possibility that there might be an error
			//==========================================================
			hr = E_OUTOFMEMORY;
			
			try
			{
   				//==========================================================
				// Create a CBinder object
				//==========================================================
				pObj = new CEnumeratorNameSpace(pUnkOuter);
			}
			catch(...)
			{
				SAFE_DELETE_PTR(pObj);
				throw;
			}
			if (pObj != NULL ){
				//======================================================
				// Initialize it
    			//======================================================
				hr = pObj->Initialize();
				if( S_OK == hr ){
					hr = pObj->QueryInterface( riid, ppvObj );
				}
				if (FAILED( hr )){
					LogMessage("CreateInstance:  Out of memory");
					SAFE_DELETE_PTR( pObj );
				}
			}
		}
	}

	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::CreateInstance for Enumerator");
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Creates an uninitialized instance of an object class. 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CErrorLookupClassFactory::CreateInstance(	LPUNKNOWN	pUnkOuter,	//IN  Points to the controlling IUnknown interface    
	                                                    REFIID		riid,		//IN  Interface ID of the interface being queried for.
	                                                    LPVOID *	ppvObj )	//OUT Pointer to interface that was instantiated     
{
	PCERRORLOOKUP	pObj = NULL;
	HRESULT			hr;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //============================================================================
    // Check for valid ppvObj pointer
    //============================================================================
    if (ppvObj == NULL){
        ERRORTRACE((THISPROVIDER,"CErrorLookupClassFactory::CreateInstance invalid argument "));
		hr = E_INVALIDARG;
    }
	else
	{
		//============================================================================
		// In case we fail, we need to zero output arguments
		//============================================================================
		*ppvObj = NULL;

		//============================================================================
		// If we're given a controlling IUnknown, it must ask for IUnknown.
		// Otherwise, the caller will end up getting a pointer to their pUnkOuter
		// instead of to the new object we create and will have no way of getting
		// back to this new object, so they won't be able to free it.  Bad!
		//============================================================================
		if( pUnkOuter && riid != IID_IUnknown ){
			ERRORTRACE((THISPROVIDER,"CErrorLookupClassFactory::CreateInstance no aggregation "));
			hr = CLASS_E_NOAGGREGATION;
		}
		else
		{
			hr = E_OUTOFMEMORY;
			try
			{
				//============================================================================
				// Create a CErrorLookup object
				//============================================================================
				pObj = new CErrorLookup(pUnkOuter);
			}
			catch(...)
			{
				SAFE_DELETE_PTR(pObj);
				throw;
			}
			if( pObj != NULL)
			{
				hr = pObj->QueryInterface(riid, ppvObj);
				if( FAILED(hr) ){
					delete pObj;
					ERRORTRACE((THISPROVIDER,"ClassFactory::CreateInstance failed in call to CError::QueryInterface."));
				}
			}
		}
	}

	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::CreateInstance for ErrorLookup");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\bitarray.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Class Definitions for Bitarray Class
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _BITARRAY_H_
#define _BITARRAY_H_

//=================================================================================
// Forward Declaration
//=================================================================================
class FAR CBitArray;
typedef CBitArray FAR *LPBITARRAY;

//=================================================================================
// Allocates and manages a bit array through various methods defined in the class
// 
// hungarian bits or pbits
//
//=================================================================================
class FAR CBitArray
{
	private:					
		
		LONG_PTR    m_cslotCurrent;									//Count of Slots
		LONG_PTR    m_cPageMax;										//Maximum number of pages 
		LONG_PTR    m_cPageCurrent;									//Current number of pages
		LONG_PTR    m_cbPage;											//Number of bytes per page
		BYTE		m_rgbBitMask[8];									//Mask buffer
		BYTE     *	m_rgbBit;											//Bit Array
		

	public:
		
		CBitArray( void );											//Class constructor
		~CBitArray( void );											//Class destructor
		
		STDMETHODIMP FInit(HSLOT cslotMax, ULONG cbPage);			//Initialization method
		STDMETHODIMP SetSlots(HSLOT islotFirst, HSLOT islotLast);	//Set a range of slots
		STDMETHODIMP ResetSlots(HSLOT islotFirst, HSLOT islotLast);	//Reset a range of slots
		VOID		 ResetAllSlots(void);							//Reset all slots
		STDMETHODIMP ArrayEmpty(void);								//Check if any bits are set
		STDMETHODIMP IsSlotSet(HSLOT islot);						//Check the status of a particular bit
		STDMETHODIMP FindSet(HSLOT islotStart, HSLOT islotLimit, HSLOT* pislot);		//Find the first set bit in a range of bits

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\binderclassfac.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// The module contains the DLL Entry and Exit points, plus the OLE ClassFactory class for RootBinder object.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//#define DECLARE_GLOBALS
//===============================================================================
//  Don't include everything from windows.h, but always bring in OLE 2 support
//===============================================================================
//#define WIN32_LEAN_AND_MEAN
#define INC_OLE2

//===============================================================================
//  Make sure constants get initialized
//===============================================================================
#define INITGUID
#define DBINITCONSTANTS

//===============================================================================
// Basic Windows and OLE everything
//===============================================================================
#include <windows.h>


//===============================================================================
//  OLE DB headers
//===============================================================================
#include "oledb.h"
#include "oledberr.h"

//===============================================================================
//	Data conversion library header
//===============================================================================
#include "msdadc.h"

//===============================================================================
// Guids for data conversion library
//===============================================================================
#include "msdaguid.h"


//===============================================================================
//  GUIDs
//===============================================================================
#include "guids.h"

//===============================================================================
//  Common project stuff
//===============================================================================

#include "headers.h"
#include "binderclassfac.h"

//===============================================================================
//  Globals
//===============================================================================
extern LONG g_cObj;						// # of outstanding objects
extern LONG g_cLock;						// # of explicit locks set
extern DWORD g_cAttachedProcesses;			// # of attached processes
extern DWORD g_dwPageSize;					// System page size
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor for this class
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
CBinderClassFactory:: CBinderClassFactory( void )
{
	m_cRef = 0;
	//================================================================
    // Decrement global object count
	//================================================================
    InterlockedIncrement(&g_cObj);
}

CBinderClassFactory:: ~CBinderClassFactory( void )
{
	//================================================================
    // Decrement global object count
	//================================================================
    InterlockedDecrement(&g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to a specified interface. Callers use QueryInterface to determine which interfaces 
// the called object supports.
//
//  HRESULT indicating the status of the method
//       S_OK           Interface is supported and ppvObject is set.
//       E_NOINTERFACE  Interface is not supported by the object
//       E_INVALIDARG   One or more arguments are invalid.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBinderClassFactory::QueryInterface (
							REFIID      riid,   // IN Interface ID of the interface being queried for.
							LPVOID *    ppvObj  // OUT Pointer to interface that was instantiated
    )
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//=================================================================
    // Check for valid ppvObj pointer
	//=================================================================
    if (!ppvObj){
        hr = E_INVALIDARG;
        LogMessage("QueryInterface:  Invalid argument pointer");
	}
	else{
		//=================================================================
		// In case we fail, we need to zero output arguments
		//=================================================================
		*ppvObj = NULL;

		//=================================================================
		// Do we support this interface?
		//=================================================================
		if (riid == IID_IUnknown || riid == IID_IClassFactory)
		{
			*ppvObj = (LPVOID) this;
		}

		//=================================================================
		// If we're going to return an interface, AddRef it first
		//=================================================================
		if (*ppvObj){
			((LPUNKNOWN) *ppvObj)->AddRef();
		}
		else{
			hr = E_NOINTERFACE;
            LogMessage("QueryInterface:  No interface");
		}
	}

	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::QueryInterface for RootBinder");
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Increments a persistence count for the object
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CBinderClassFactory::AddRef( void )
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;
    hr = InterlockedIncrement((long *)&m_cRef);

	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::AddRef for RootBinder");

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrements a persistence count for the object and if persistence count is 0,the object destroys itself.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CBinderClassFactory::Release( void )
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    if (!InterlockedDecrement((long *)&m_cRef)){
        delete this;
    }

	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::Release for RootBinder");
    return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Creates an uninitialized instance of an object class.Initialization is subsequently performed using 
// another interface-specific method
//
//  HRESULT indicating the status of the method
//       S_OK           Interface is supported and ppvObject is set.
//       E_NOINTERFACE  Interface is not supported by the object
//       E_INVALIDARG   One or more arguments are invalid.
//       E_OUTOFMEMORY  Memory could not be allocated
//       OTHER          Other HRESULTs returned by called functions
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBinderClassFactory::CreateInstance (
						LPUNKNOWN   pUnkOuter,  // IN Points to the controlling IUnknown interface
						REFIID      riid,       // IN Interface ID of the interface being queried for.
						LPVOID *    ppvObj      // OUT Pointer to interface that was instantiated
    )
{
    CBinder*	    pObj = NULL;
    HRESULT         hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//==============================================================
    // Check for valid ppvObj pointer
	//==============================================================
    if (ppvObj == NULL){
        LogMessage("CreateInstance:  Invalid argument pointer");
        hr = ( E_INVALIDARG );
    }
	else
	{
		//==============================================================
		// In case we fail, we need to zero output arguments
		//==============================================================
		*ppvObj = NULL;

		//==============================================================
		// If we're given a controlling IUnknown, it must ask for 
		// IUnknown. Otherwise, caller will end up getting a pointer to 
		// their pUnkOuter instead of to the new object we create and 
		// will have no way of getting back to this new object, so they 
		// won't be able to free it.  Bad!
		//==============================================================
		if (pUnkOuter && riid != IID_IUnknown){
			hr = DB_E_NOAGGREGATION;
			LogMessage("CreateInstance:  No aggregation");
		}
		else{
			//==========================================================
			// Prepare for the possibility that there might be an error
			//==========================================================
			hr = E_OUTOFMEMORY;

			try
			{
   				//==========================================================
				// Create a CBinder object
				//==========================================================
				pObj = new CBinder(pUnkOuter);
			}
			catch(...)
			{
				SAFE_DELETE_PTR(pObj);
				throw;
			}
			if (pObj != NULL ){
				//======================================================
				// Initialize it
    			//======================================================
				if (SUCCEEDED(hr = pObj->InitBinder())){
					hr = pObj->QueryInterface( riid, ppvObj );
				}
				if (FAILED( hr )){
					LogMessage("CreateInstance:  Out of memory");
					SAFE_DELETE_PTR( pObj );
				}
			}
		}
	}
	
	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::CreateInstance for RootBinder");

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Controls whether an object application is kept in memory. Keeping the application alive in memory 
//  allows instances of this class to be created more quickly.
//
//  HRESULT indicating the status of the method
//       S_OK  Interface is supported and ppvObject is set.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBinderClassFactory::LockServer ( BOOL fLock )                 // IN TRUE or FALSE to lock or unlock
{
	HRESULT hr = NOERROR;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    if (fLock)
	{
        InterlockedIncrement( &g_cLock );
	}
    else
	{
        InterlockedDecrement( &g_cLock );
	}

	CATCH_BLOCK_HRESULT(hr,L"IClassFactory::LockServer for RootBinder");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\classfac.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider 
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Class Definitions for CClassFactory and DLL Entry Points
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _CLASSFAC_H_
#define _CLASSFAC_H_

//////////////////////////////////////////////////////////////////////////////////////////////////////////

class CClassFactory : public IClassFactory		
{
	protected:
		ULONG			m_cRef;												//Reference count

	public: 
		CClassFactory(void);
		~CClassFactory(void);

		
		STDMETHODIMP			QueryInterface(REFIID, LPVOID *);			//Request an Interface
		STDMETHODIMP_(ULONG)	AddRef(void);								//Increments the Reference count
		STDMETHODIMP_(ULONG)	Release(void);								//Decrements the Reference count

		STDMETHODIMP			LockServer(BOOL);							//Lock Object so that it can not be unloaded
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////
class CEnumeratorClassFactory : public CClassFactory		
{
	public: 
		STDMETHODIMP			CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////
class CDataSourceClassFactory : public CClassFactory		
{
	public: 
		STDMETHODIMP			CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////
class CErrorLookupClassFactory : public CClassFactory		
{
	public: 
		STDMETHODIMP			CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\cmdcolinfo.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// colinfo.cpp  |   IColumnsInfo interface implementation
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  IColumnsInfo specific methods
//
//  Returns the column metadata needed by most consumers.
//
//  HRESULT
//      S_OK               The method succeeded
//      E_OUTOFMEMORY      Out of memory
//      E_INVALIDARG       pcColumns or prginfo or ppStringsbuffer was NULL
//		DB_E_NOTPREPARED   command is not supported
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIColumnsInfoCmd::GetColumnInfo( DBORDINAL*          pcColumns,      //OUT  Number of columns in rowset
										      DBCOLUMNINFO**  prgInfo,        //OUT  Array of DBCOLUMNINFO Structures
											  OLECHAR**         ppStringsBuffer //OUT  Storage for all string values
)
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;


	TRY_BLOCK;

	//==============================================
	// Initialize
	//==============================================
	if ( pcColumns ){
		*pcColumns = 0;
	}
	if ( prgInfo ){
		*prgInfo = NULL;
	}
	if ( ppStringsBuffer ){
		*ppStringsBuffer = NULL;
	}

	// Serialize access to this object.
	CAutoBlock cab(m_pcmd->GetCriticalSection());
	g_pCError->ClearErrorInfo();
   	//==============================================
	// Usual argument checking
	//==============================================
    if ( pcColumns == NULL || prgInfo == NULL || ppStringsBuffer == NULL ){
        hr = E_INVALIDARG;
	}
	else
	if(!(m_pcmd->m_pQuery->GetStatus() & CMD_TEXT_SET))
	{
		hr = DB_E_NOCOMMAND;
	}
	else
	{
		hr = GetColInfo(pcColumns,prgInfo,ppStringsBuffer);
	}

	hr = hr == S_OK ? hr : g_pCError->PostHResult(hr,&IID_IColumnsInfo);

	CATCH_BLOCK_HRESULT(hr,L"IColumnInfo::GetColumnInfo on command");
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns an array of ordinals of the columns in a rowset that are identified by the specified column IDs.
//
// HRESULT
//      S_OK                       The method succeeded
//      E_INVALIDARG               cColumnIDs was not 0 and rgColumnIDs was NULL,rgColumns was NULL
//      DB_E_COLUMNUNAVAILABLE     An element of rgColumnIDs was invalid
//		DB_E_NOTPREPARED   command is not supported
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIColumnsInfoCmd::MapColumnIDs (  DBORDINAL        cColumnIDs,     //IN  Number of Column IDs to map
											   const DBID	rgColumnIDs[],		//IN  Column IDs to map
											   DBORDINAL        rgColumns[]     //OUT Ordinal values
    )
{
	ULONG	ulError = 0;
    ULONG   i = 0;
	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;

	CAutoBlock 	cab( m_pcmd->GetCriticalSection() );

	TRY_BLOCK;
	
	//========================================
	// Serialize access to this object.
	//========================================
	CAutoBlock cab(m_pcmd->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	//==========================================================
    // If cColumnIDs is 0 return
	//==========================================================
	if ( cColumnIDs != 0 )
	{

		//======================================================
		// Check arguments
		//======================================================
		if ( rgColumnIDs == NULL )
		{
			hr = E_INVALIDARG;
		}
		else
		{

			if ( rgColumns == NULL )
			{
				hr = E_INVALIDARG ;
			}
			else
			if(!(m_pcmd->m_pQuery->GetStatus() & CMD_TEXT_SET))
			{
				hr = DB_E_NOCOMMAND;
			}
			else
			{
				//===============================================
				// Walk the Column ID structs and determine
				// the ordinal value
				//===============================================
				for (i=0; i < cColumnIDs; i++ )
				{

					if ( ( rgColumnIDs[i].eKind == DBKIND_PROPID && 
							rgColumnIDs[i].uName.ulPropid < 1  && 
							rgColumnIDs[i].uName.ulPropid > m_pcmd->m_cTotalCols ) ||

							( rgColumnIDs[i].eKind == DBKIND_NAME && 
							  rgColumnIDs[i].uName.pwszName == NULL ) ||
						 
							( rgColumnIDs[i].eKind == DBKIND_GUID_PROPID ) )
					{

						rgColumns[i] = DB_INVALIDCOLUMN;
						ulError++;
					}
					else
					{
						if(rgColumnIDs[i].eKind == DBKIND_PROPID)
						{
							rgColumns[i] = rgColumnIDs[i].uName.ulPropid;
						}
						else
						{
							rgColumns[i] = m_pcmd->m_pColumns->GetColOrdinal(rgColumnIDs[i].uName.pwszName);
						}
					}
				}

				if ( !ulError ){
					hr = S_OK;
				}
				else if ( ulError < cColumnIDs ){
					hr = DB_S_ERRORSOCCURRED;
				}
				else{
					hr = DB_E_ERRORSOCCURRED;
				}
			}
		}
	}	
	
	hr = hr == S_OK ? hr : g_pCError->PostHResult(hr,&IID_IColumnsInfo);

	CATCH_BLOCK_HRESULT(hr,L"IColumnInfo::MapColumnIDs on Command");
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function which executes command and gets the column information
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIColumnsInfoCmd::GatherColumnInfo()
{

	CWmiOleDBMap *pMap = NULL;
	HRESULT hr = S_OK;
	DWORD dwQryStatus = 0;
	DWORD	dwFlags = 0;

	VARIANT varPropValue;
	VariantInit(&varPropValue);

	//===============================================================================================
	// Get the value of DBPROP_WMIOLEDB_QUALIFIERS property whether to show qualifiers or not
	//===============================================================================================
	if(S_OK == (hr = m_pcmd->m_pCDBSession->GetDataSrcProperty(DBPROP_WMIOLEDB_QUALIFIERS,varPropValue)))
	{
		dwFlags = varPropValue.lVal;
	}



	if(!m_pcmd->m_pColumns)
	{

		//==========================================================================
		// Allocate memory for the WMIOLEDB map classe
		//==========================================================================

		pMap = new CWmiOleDBMap;
		
		if(pMap)
		{

			if(SUCCEEDED(hr = pMap->FInit(dwFlags,m_pcmd->m_pQuery,m_pcmd->m_pCDBSession->m_pCDataSource->m_pWbemWrap)))
			{
				m_pcmd->m_pColumns = new cRowColumnInfoMemMgr;

				m_pcmd->m_pCDBSession->GetDataSrcProperty(DBPROP_WMIOLEDB_SYSTEMPROPERTIES,varPropValue);
				if( varPropValue.boolVal == VARIANT_TRUE)
				{
					pMap->SetSytemPropertiesFlag(TRUE);
				}

				// Get the current status
				dwQryStatus = m_pcmd->m_pQuery->GetStatus();

				// Set the status to CMD_READY
				m_pcmd->m_pQuery->InitStatus(CMD_READY);

				hr = pMap->GetColumnCount(m_pcmd->m_cTotalCols,m_pcmd->m_cCols,m_pcmd->m_cNestedCols);


				if( SUCCEEDED(hr))
				{
						if( S_OK == (hr = m_pcmd->m_pColumns->AllocColumnNameList(m_pcmd->m_cTotalCols)))
						{

							//===============================================================================
							//  Allocate the DBCOLUMNINFO structs to match the number of columns
							//===============================================================================
							if( S_OK == (hr = m_pcmd->m_pColumns->AllocColumnInfoList(m_pcmd->m_cTotalCols)))
							{
								m_pcmd->m_pColumns->InitializeBookMarkColumn();
								hr = pMap->GetColumnInfoForParentColumns(m_pcmd->m_pColumns);
							}
						}
				}
			
					
				// Set the status back
				m_pcmd->m_pQuery->InitStatus(dwQryStatus);

				//==================================================================================
				// Free the columnlist if more is allocated
				//==================================================================================
				if( hr != S_OK )
				{
					m_pcmd->m_pColumns->FreeColumnNameList();
					m_pcmd->m_pColumns->FreeColumnInfoList();
				}
			}
		}
	}

	SAFE_DELETE_PTR(pMap);

	if(FAILED(hr))
	{
		SAFE_DELETE_PTR(m_pcmd->m_pColumns);
	}
	return hr;
}





///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function to fetch the column information and puts in the buffer passed
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIColumnsInfoCmd::GetColInfo(DBORDINAL* pcColumns, DBCOLUMNINFO** prgInfo,WCHAR** ppStringsBuffer)
{
    ULONG           icol = 0;
    DBCOLUMNINFO*   rgdbcolinfo = NULL;
    WCHAR*          pstrBuffer = NULL;
    WCHAR*          pstrBufferForColInfo = NULL;
	HRESULT			hr = S_OK;
	DBCOUNTITEM		nTotalCols = 0;
	BOOL			bFlag = TRUE;

//	if(!(m_ulProps & BOOKMARKPROP))
//	{
//		nTotalCols--;
//		bFlag = FALSE;
//	}
	hr = GatherColumnInfo();
	
	nTotalCols = m_pcmd->m_cTotalCols;
	if(SUCCEEDED(hr))
	//=======================================
	// Copy the columninformation
	//=======================================
	if(SUCCEEDED(hr = m_pcmd->m_pColumns->CopyColumnInfoList(rgdbcolinfo,bFlag)))
	{
		//===========================================
		// Copy the heap for column names.
		//===========================================
		if ( m_pcmd->m_pColumns->ColumnNameListStartingPoint() != NULL){

			ptrdiff_t dp;

			hr = m_pcmd->m_pColumns->CopyColumnNamesList(pstrBuffer);
			dp = (LONG_PTR) pstrBuffer - (LONG_PTR) (m_pcmd->m_pColumns->ColumnNameListStartingPoint());
			dp >>= 1;

			//===========================================
			// Loop through columns and adjust pointers 
			// to column names.
			//===========================================
			for ( icol =0; icol < nTotalCols; icol++ )
			{
				if ( rgdbcolinfo[icol].pwszName )
				{
					rgdbcolinfo[icol].pwszName += dp;
				}
			}
		}

		//==============================
		// Set the output parameters
		//==============================
		*prgInfo = &rgdbcolinfo[0];			
		*ppStringsBuffer = pstrBuffer;
		*pcColumns = nTotalCols; 
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\cmdparam.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Microsoft WMI OLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Module	:	CMDPARAM.CPP	- ICommandWithParameters interface implementation
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "command.h"


////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Increments a reference count for the object.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpICommandWithParameters::AddRef(void)
{
    DEBUGCODE(InterlockedIncrement((long*)&m_cRef));
	return m_pcmd->AddRef();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrement the object's reference count and deletes the object when the new reference count is zero.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpICommandWithParameters::Release(void)
{
	DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef));
	DEBUGCODE(if( lRef < 0 ){
	   ASSERT("Reference count on Object went below 0!")
	});

	return m_pcmd->GetOuterUnknown()->Release();								
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to a specified interface. Callers use QueryInterface to determine which interfaces the 
// called object supports. 
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandWithParameters::QueryInterface( REFIID riid, LPVOID * ppv	)	
{
	return m_pcmd->QueryInterface(riid, ppv);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Get a list of the command's parameters, their names, and their required types.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandWithParameters::GetParameterInfo( DB_UPARAMS* pcParams,	DBPARAMINFO** 	prgParamInfo, OLECHAR**	ppNamesBuffer )
{
	HRESULT			hr = S_OK;
	
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //=========================================================
    // Serialize access
    //=========================================================
	CAutoBlock cab(m_pcmd->GetCriticalSection());

    //=========================================================
    // Clear previous Error Object for this thread
    //=========================================================
	g_pCError->ClearErrorInfo();

    //=========================================================
	// Initialize buffers
    //=========================================================
	if ( pcParams )
	{
		*pcParams = 0;
	}
	if ( prgParamInfo )
	{
		*prgParamInfo = NULL;
	}
	if ( ppNamesBuffer )
	{
		*ppNamesBuffer = NULL;
	}

    //=========================================================
	// Validate Agruments
    //=========================================================
	if ( (pcParams == NULL) || (prgParamInfo == NULL) )
	{
		hr = E_INVALIDARG;
	}
	else
    //=========================================================
	// If the consumer has not supplied parameter information.
    //=========================================================
	if ( m_pcmd->m_pQuery->GetParamCount() == 0 )
	{

        //=====================================================
		// Command Object must be in prepared state
        //=====================================================
        if ( !(m_pcmd->m_pQuery->GetStatus() & CMD_READY) )
		{
			hr  = DB_E_NOTPREPARED;
		}
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pcmd->GetParameterInfo(pcParams, prgParamInfo, ppNamesBuffer, &IID_ICommandWithParameters);
	}

	hr = hr == S_OK ? hr : g_pCError->PostHResult(hr,&IID_ICommandWithParameters);

	CATCH_BLOCK_HRESULT(hr,L"ICommandWithParameters::GetParameterInfo");
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Map parameter names to parameter ordinals
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandWithParameters::MapParameterNames( DB_UPARAMS cParamNames, const OLECHAR* rgParamNames[], DB_LPARAMS rgParamOrdinals[] )
{
	
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //=========================================================
    // Serialize access
    //=========================================================
	CAutoBlock cab(m_pcmd->GetCriticalSection());

    //==============================================================
	// Clear previous Error Object for this thread
    //==============================================================
	g_pCError->ClearErrorInfo();

	if(cParamNames != 0)
	{
		if (rgParamNames == NULL || rgParamOrdinals == NULL){
			hr = E_INVALIDARG;
		}
		else
		//==============================================================
		// If the consumer has not supplied parameter information.
		//==============================================================
		if ( m_pcmd->m_pQuery->GetParamCount() == 0 ){

			//==========================================================
			// Command Text must be set
			//==========================================================
			if (!(m_pcmd->m_pQuery->GetStatus() & CMD_TEXT_SET)){
				hr = DB_E_NOCOMMAND;
			}
			else
			//==========================================================
			// Command Object must be in prepared state
			//==========================================================
			if ( !(m_pcmd->m_pQuery->GetStatus() & CMD_READY) ){
				hr = DB_E_NOTPREPARED;
			}
		}
		
		if(SUCCEEDED(hr))
		{
			hr = m_pcmd->MapParameterNames(cParamNames, rgParamNames, rgParamOrdinals, &IID_ICommandWithParameters);
		}
	}

	hr = hr == S_OK ? hr : g_pCError->PostHResult(hr,&IID_ICommandWithParameters);
	
	CATCH_BLOCK_HRESULT(hr,L"ICommandWithParameters::MapParameterNames");
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Override the provider's parameter information. 
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandWithParameters::SetParameterInfo( DB_UPARAMS cParams, const DB_UPARAMS rgParamOrdinals[], const DBPARAMBINDINFO rgParamBindInfo[] )
{
	ULONG	i;
	BOOL	fNamedParams = (cParams > 0) ? TRUE : FALSE;
	HRESULT	hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //=========================================================
    // Serialize access
    //=========================================================
	CAutoBlock cab(m_pcmd->GetCriticalSection());

    //===================================================================
	// Clear previous Error Object for this thread
    //===================================================================
	g_pCError->ClearErrorInfo();

	if ( (cParams != 0) && (rgParamOrdinals == NULL) ){
		hr = E_INVALIDARG;
	}
	else
	{
		//===================================================================
		// Scan for invalid arguments in the arrays
		//===================================================================
		for( i = 0; i < cParams; i++ ){
			if ( !rgParamOrdinals[i] || (rgParamBindInfo && !(rgParamBindInfo[i].pwszDataSourceType)) )	{
				hr = E_INVALIDARG;
			}
			else
			if (rgParamBindInfo && rgParamBindInfo[i].pwszName == NULL)
			{
				fNamedParams = FALSE;
			}
		}

		if(SUCCEEDED(hr))
		{
			//===================================================================
			// Don't allow parameters to be set if we've got a rowset open
			//===================================================================
			if ( m_pcmd->IsRowsetOpen() ){
				hr = DB_E_OBJECTOPEN;
			}
			else
			{
				//===================================================================
				// Need to unprepare the statement when parameter info is changed and
				// set named params
				//===================================================================
				if ((m_pcmd->m_pQuery->GetStatus() & CMD_READY) && m_pcmd->m_pQuery->GetParamCount() > 0 && fNamedParams){
					m_pcmd->UnprepareHelper(UNPREPARE_RESET_STMT);
				}

				hr = m_pcmd->SetParameterInfo(cParams, rgParamOrdinals, rgParamBindInfo);
			}
		}
	}

	hr = hr == S_OK ? hr : g_pCError->PostHResult(hr,&IID_ICommandWithParameters);
	
	CATCH_BLOCK_HRESULT(hr,L"ICommandWithParameters::SetParameterInfo");
	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Get a list of the command's parameters, their names, and their required types.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CCommand::GetParameterInfo(	DB_UPARAMS* pcParams, DBPARAMINFO** 	prgDBParamInfo,	WCHAR**	ppNamesBuffer, const IID* piid )
{
	HRESULT			hr = S_OK;
	SHORT 			sw = 0;
	ULONG			cNumParams = 0;
	ULONG			cbNames = 0;
	DBPARAMINFO*	pTempInfo;
	WCHAR*			pwszNameBuffer;
	PPARAMINFO		pParamInfo;
	ULONG			iParam;

  //=================================================================================
	// If the consumer has set info for at least one parameter,
	// we only return info on the parameters set by the consumer
    //=================================================================================
	if (m_pQuery->GetParamCount() > 0){

	    //=============================================================================
    	// Count the params set by the consumer
	    //=============================================================================
		cNumParams = 0;
		for (iParam = 0; iParam <(unsigned) m_pQuery->GetParamCount(); iParam++){
			pParamInfo = (PPARAMINFO)m_pQuery->GetParam(iParam);
			if (pParamInfo){
				cNumParams++;
				if (ppNamesBuffer && pParamInfo->pwszParamName)
					cbNames += (wcslen(pParamInfo->pwszParamName)+1)*sizeof(WCHAR);
			}
		}
	}
	else{

        hr = S_OK;

		if (!m_pQuery->m_prgProviderParamInfo && m_pQuery->GetParamCount()){

    	    //=========================================================================
			// Get the parameter info 
    	    //=========================================================================
			hr = GetParamInfo(piid);
		}

        if( hr == S_OK ){
            cNumParams = m_pQuery->GetParamCount();
		    if (ppNamesBuffer){

			    for (iParam = 0; iParam < cNumParams; iParam++){
				    pParamInfo = m_pQuery->m_prgProviderParamInfo + iParam;
				    if (pParamInfo->pwszParamName)
					    cbNames += (wcslen(pParamInfo->pwszParamName)+1)*sizeof(WCHAR);
			    }
            }
		}
	}

    //==================================================================================
	// Check if we have any parameters
    //==================================================================================
    if ( cNumParams ){

        //==============================================================================
	    // Allocate memory to return the information
        //==============================================================================
	    *prgDBParamInfo = (DBPARAMINFO*)g_pIMalloc->Alloc(cNumParams*sizeof(DBPARAMINFO));
	    if ( !*prgDBParamInfo ){
		    hr = g_pCError->PostHResult(E_OUTOFMEMORY, piid);
	    }
        else{

            hr = S_OK;

	        if (cbNames){

		        *ppNamesBuffer = (WCHAR*)g_pIMalloc->Alloc(cbNames);
		        if (!*ppNamesBuffer){
			        hr = g_pCError->PostHResult(E_OUTOFMEMORY, piid);
		        }
	        }

            if( S_OK == hr ){

                //======================================================================
	            // Initialize memory
                //======================================================================
	            memset(*prgDBParamInfo, 0, (cNumParams*sizeof(DBPARAMINFO)));

                //======================================================================
	            // Describe the Parameter Markers
                //======================================================================
	            if (m_pQuery->GetParamCount() > 0){

                    //==================================================================
		            // Return the parameter information set by the consumer
                    //==================================================================
		            pwszNameBuffer = ppNamesBuffer? *ppNamesBuffer : NULL;
		            pTempInfo = *prgDBParamInfo;

		            for (iParam = 0; iParam < (unsigned)m_pQuery->GetParamCount(); iParam++) {

			            pParamInfo = (PPARAMINFO) m_pQuery->GetParam(iParam);
			            if (!pParamInfo)
				            continue;

                        //==============================================================
			            // Fill 'er up
                        //==============================================================
			            pTempInfo->dwFlags		= pParamInfo->dwFlags;
			            pTempInfo->iOrdinal		= iParam+1;
			            if (pwszNameBuffer && pParamInfo->pwszParamName) {
				            pTempInfo->pwszName = pwszNameBuffer;
				            wcscpy(pwszNameBuffer, pParamInfo->pwszParamName);
				            pwszNameBuffer += wcslen(pParamInfo->pwszParamName) + 1;
			            }
                        //==============================================================
			            // pTempInfo->pTypeInfo	already NULL
                        //==============================================================
			            pTempInfo->ulParamSize	= pParamInfo->ulParamSize;
			            pTempInfo->wType		= pParamInfo->wOLEDBType,
			            pTempInfo++;
		            }
	            }
	            else{

                    //==================================================================
		            // Return the parameter information derived from the command.
                    //==================================================================
		            pwszNameBuffer = ppNamesBuffer? *ppNamesBuffer : NULL;
		            pTempInfo = *prgDBParamInfo;
		            for (iParam = 0; iParam <(ULONG) m_pQuery->GetParamCount(); iParam++){
			            pParamInfo = m_pQuery->m_prgProviderParamInfo + iParam;

                        //==============================================================
			            // Fill 'er up
                        //==============================================================
			            pTempInfo->dwFlags		= pParamInfo->dwFlags;
			            pTempInfo->iOrdinal		= iParam+1;
			            if (pwszNameBuffer && pParamInfo->pwszParamName){
				            pTempInfo->pwszName = pwszNameBuffer;
				            wcscpy(pwszNameBuffer, pParamInfo->pwszParamName);
				            pwszNameBuffer += wcslen(pParamInfo->pwszParamName) + 1;
			            }
                        //==============================================================
			            // pTempInfo->pTypeInfo	already NULL
                        //==============================================================
			            pTempInfo->ulParamSize	= pParamInfo->ulParamSize;
			            pTempInfo->wType		= pParamInfo->wOLEDBType,
			            pTempInfo++;
		            }
	            }
            }
        }
    }
	
	if ( SUCCEEDED(hr) ){
		*pcParams = cNumParams;
	}
	else{
		*pcParams = 0;
		if (*prgDBParamInfo){
			g_pIMalloc->Free(*prgDBParamInfo);
			*prgDBParamInfo = NULL;
		}
		if (ppNamesBuffer && *ppNamesBuffer){
			g_pIMalloc->Free(*ppNamesBuffer);
			ppNamesBuffer = NULL;
		}
	}
	return hr;		
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This method allows client to define the parameters.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CCommand::SetParameterInfo(	DB_UPARAMS cParams, const DB_UPARAMS rgParamOrdinals[], const DBPARAMBINDINFO	rgParamBindInfo[] )
{
	HRESULT			hr			= S_OK;
	PPARAMINFO		pParamInfo	= NULL;
	DBORDINAL		iMax		= 0;
	DBORDINAL		iParams;
    CDataMap        DataMap;
    DBTYPE          wDataType	= 0;
	BOOL			bOveridden	= FALSE;
	BOOL			bRet		= FALSE;
    //=====================================================================
	// If given no params, discard all user param info and return
    //=====================================================================
	if (!cParams){
		m_pQuery->DeleteConsumerParamInfo();
		hr = S_OK;
	}
	else
	{
		//=====================================================================
		// If there's no rgParamBindInfo, we're to discard the param information
		//=====================================================================
		if ( !rgParamBindInfo ){

			ULONG_PTR iElem = 0;
			//=================================================================
			// Discard the param info
			//=================================================================
			for (iParams = 0; iParams < cParams; iParams++){

				iElem = rgParamOrdinals[iParams];
				if (iElem > 0 && iElem <= (unsigned)m_pQuery->GetParamCount()){

					m_pQuery->RemoveParam(iElem-1);
					delete pParamInfo;
				}
			}
			hr	= S_OK;
			bRet = TRUE;
		}

		//=====================================================================
		// Find the max param ordinal and check for valid param names
		//=====================================================================
		iMax = rgParamOrdinals[0];
		for (iParams = 0; iParams < cParams; iParams++){

			if (iMax < rgParamOrdinals[iParams])
			{
				iMax = rgParamOrdinals[iParams];
			}

			if(rgParamBindInfo[iParams].pwszName != NULL)
/*			{
				hr = DB_E_BADPARAMETERNAME;	
			}
			else
*/			if (wcslen(rgParamBindInfo[iParams].pwszName )== 0){
				hr = DB_E_BADPARAMETERNAME;	
			}
		}
		
		if(SUCCEEDED(hr))
		{
			DBORDINAL iOrdinal; 
			//=====================================================================
			// Loop over bind info and set or override the param info
			//=====================================================================
			for (iParams = 0; iParams < cParams; iParams++){

				iOrdinal = rgParamOrdinals[iParams];
				//=================================================================
				// Add the consumer-provided information to our cache
				//=================================================================
				try
				{
					pParamInfo = new PARAMINFO;
				}
				catch(...)
				{
					SAFE_DELETE_PTR(pParamInfo);
					throw;
				}

				if (NULL == pParamInfo){
					hr = (E_OUTOFMEMORY);
				}
				else
				{
					pParamInfo->dwFlags      = rgParamBindInfo[iParams].dwFlags;
					pParamInfo->ulParamSize  = rgParamBindInfo[iParams].ulParamSize;
					pParamInfo->iOrdinal	 = iOrdinal;

					DataMap.TranslateParameterStringToOLEDBType( wDataType, rgParamBindInfo[iParams].pwszDataSourceType);
					pParamInfo->wOLEDBType   = wDataType;

					if (rgParamBindInfo[iParams].pwszName){
						ULONG cwchName = wcslen(rgParamBindInfo[iParams].pwszName);
						try
						{
							pParamInfo->pwszParamName = new WCHAR[cwchName+1];
						}
						catch(...)
						{
							SAFE_DELETE_ARRAY(pParamInfo->pwszParamName);
							throw;
						}

						if (NULL == pParamInfo->pwszParamName){
							SAFE_DELETE_PTR(pParamInfo);
							hr = (E_OUTOFMEMORY);
						}
						else
						{
    						wcscpy(pParamInfo->pwszParamName,rgParamBindInfo[iParams].pwszName);
						}
					}
						
					if(SUCCEEDED(hr))
					{
						// Remove the parameter if a parameter alread exist at the ordinal
						if (iOrdinal > 0 && iOrdinal <= (unsigned)m_pQuery->GetParamCount()){

							m_pQuery->RemoveParam(iOrdinal-1);
							SAFE_DELETE_ARRAY(pParamInfo->pwszParamName);
							SAFE_DELETE_PTR(pParamInfo);
							bOveridden = TRUE;
						}
						// If there is already a parameter at this ordinal , remove 
						// that and insert this new one
						hr = m_pQuery->AddConsumerParamInfo(iOrdinal-1,pParamInfo);
						if( FAILED(hr)){
							break;
						}
						if( hr == S_OK && bOveridden == TRUE)
						{
							hr = DB_S_TYPEINFOOVERRIDDEN;
						}
					}
				}
			}  // for loop


		}		// If succeeded(hr)
	}


	hr = hr == S_OK ? hr : g_pCError->PostHResult(hr, &IID_ICommandWithParameters);
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Gets the parameter information for each param marker present in the command.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CCommand::GetParamInfo( const IID *piid	)
{
	PPARAMINFO	prgParamInfo	= NULL;

	if (m_CError.Size())
	{
		m_CError.FreeErrors();
	}

	m_pQuery->SetProviderParamInfo(prgParamInfo);
	return S_OK;

}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCommand::MapParameterNames(   DB_UPARAMS cParamNames, const OLECHAR*	rgParamNames[], DB_LPARAMS rgParamOrdinals[],
	                                        const IID* piid	)
{
	HRESULT hr		= S_OK;
	ULONG iName		= 0;
	ULONG iParam	= 0;
	ULONG cParam	= 0;
	ULONG cErrors	= 0;

    //=======================================================
    // Check if we have any parameters
    //=======================================================
	if ( cParamNames )
	{
		cParam = m_pQuery->GetParamCount();

		if (cParam  > 0){

			for (iName = 0; iName < cParamNames; iName++){

				for (iParam = 0; iParam < cParam; iParam++){

					PPARAMINFO pParamInfo;
					pParamInfo = (PPARAMINFO) m_pQuery->GetParam(iParam);
					if (pParamInfo && pParamInfo->pwszParamName	&& !_wcsicmp(rgParamNames[iName],pParamInfo->pwszParamName)){

						rgParamOrdinals[iName] = LONG(iParam + 1);
						break;
					}
				}
				if (iParam == cParam){
					rgParamOrdinals[iName] = 0;
					cErrors++;
				}
			}
		}
		else{

			if (!m_pQuery->m_prgProviderParamInfo && m_pQuery->GetParamCount() && !(m_pQuery->GetStatus())){

				//=======================================================
				// Get the parameter info 
				//=======================================================
				if (SUCCEEDED(hr = GetParamInfo(piid))){

					cParam = m_pQuery->GetParamCount();
					for (iName = 0; iName < cParamNames; iName++) {

						for (iParam = rgParamNames[iName]? 0 : cParam; iParam < cParam; iParam++){

							PPARAMINFO pParamInfo = m_pQuery->m_prgProviderParamInfo + iParam;
							if (pParamInfo->pwszParamName  && !_wcsicmp(rgParamNames[iName],pParamInfo->pwszParamName)){
    							rgParamOrdinals[iName] = LONG(iParam + 1);
	    						break;
		    				}
						}
					}
					if (iParam == cParam) {
						rgParamOrdinals[iName] = 0;
						cErrors++;
					}
				}
			}
		}
		if (!cErrors)
		{
			hr = S_OK;
		}
		else if (cErrors < cParamNames) 
		{
			hr = DB_S_ERRORSOCCURRED;
		}
		else
		{
			hr = DB_E_ERRORSOCCURRED;
		}
	}

	hr = hr == S_OK ? hr : g_pCError->PostHResult(hr, &IID_ICommandWithParameters);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\cmdcreat.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Implementation 
//
// (C) Copyright 1999 By Microsoft Corporation.
//
//	Module	:	CMDCREAT.CPP	- IDBCreateCommand interface implementation
////////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "command.h"
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Creates a Command object.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBCreateCommand::CreateCommand( IUnknown *	pUnkOuter, REFIID riid,	IUnknown**	ppCommand )	
{

	HRESULT		hr;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //=========================================================================
	// Seriliaze the object
    //=========================================================================
	CAutoBlock cab(m_pCDBSession->GetCriticalSection());

    //=========================================================================
	// Clear previous Error Object for this thread
    //=========================================================================
	g_pCError->ClearErrorInfo();

    //=========================================================================
	// Initialize output param
    //=========================================================================
	if (ppCommand)
	{
		*ppCommand = NULL;
	}

    //=========================================================================
	// Call this function to create a command
    //=========================================================================
	hr = m_pCDBSession->CreateCommand(pUnkOuter,riid,ppCommand);

    //=========================================================================
	// Since only failure codes can hit this return, just post
	// the error record here
    //=========================================================================
	hr = hr == S_OK ? hr : g_pCError->PostHResult(hr, &IID_IDBCreateCommand);

	CATCH_BLOCK_HRESULT(hr,L"IDBCreateCommand::CreateCommand");
   	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\colinfo.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// colinfo.cpp  |   IColumnsInfo interface implementation
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  IColumnsInfo specific methods
//
//  Returns the column metadata needed by most consumers.
//
//  HRESULT
//      S_OK               The method succeeded
//      E_OUTOFMEMORY      Out of memory
//      E_INVALIDARG       pcColumns or prginfo or ppStringsbuffer was NULL
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIColumnsInfo::GetColumnInfo( DBORDINAL*          pcColumns,      //OUT  Number of columns in rowset
										      DBCOLUMNINFO**  prgInfo,        //OUT  Array of DBCOLUMNINFO Structures
											  OLECHAR**         ppStringsBuffer //OUT  Storage for all string values
)
{
    ULONG           icol = 0;
    DBCOLUMNINFO*   rgdbcolinfo = NULL;
    WCHAR*          pstrBuffer = NULL;
    WCHAR*          pstrBufferForColInfo = NULL;
	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//==============================================
	// Initialize
	//==============================================
	if ( pcColumns ){
		*pcColumns = 0;
	}
	if ( prgInfo ){
		*prgInfo = NULL;
	}
	if ( ppStringsBuffer ){
		*ppStringsBuffer = NULL;
	}

	// Serialize access to this object.
	CAutoBlock cab(BASEROW->GetCriticalSection());
	g_pCError->ClearErrorInfo();
   	//==============================================
	// Usual argument checking
	//==============================================
	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
    if ( pcColumns == NULL || prgInfo == NULL || ppStringsBuffer == NULL ){
        hr = E_INVALIDARG;
	}
	else{

		hr = BASEROW->GetColumnInfo(pcColumns,prgInfo , ppStringsBuffer);
	}

	hr = hr == S_OK ? hr : g_pCError->PostHResult(hr,&IID_IColumnsInfo);

	CATCH_BLOCK_HRESULT(hr,L"IColumnInfo::GetColumnInfo");
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns an array of ordinals of the columns in a rowset that are identified by the specified column IDs.
//
// HRESULT
//      S_OK                       The method succeeded
//      E_INVALIDARG               cColumnIDs was not 0 and rgColumnIDs was NULL,rgColumns was NULL
//      DB_E_COLUMNUNAVAILABLE     An element of rgColumnIDs was invalid
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIColumnsInfo::MapColumnIDs (  DBORDINAL        cColumnIDs,     //IN  Number of Column IDs to map
											   const DBID	rgColumnIDs[],		//IN  Column IDs to map
											   DBORDINAL        rgColumns[]     //OUT Ordinal values
    )
{
	ULONG	ulError = 0;
    ULONG   i = 0;
	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;
	
	//========================================
	// Serialize access to this object.
	//========================================
	CAutoBlock cab(BASEROW->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	//==========================================================
    // If cColumnIDs is 0 return
	//==========================================================
	if ( cColumnIDs != 0 ){

		//======================================================
		// Check arguments
		//======================================================
		if ( rgColumnIDs == NULL ){
			hr = E_INVALIDARG;
		}
		else{

			if ( rgColumns == NULL ){
				hr = E_INVALIDARG ;
			}
			else{

				//===============================================
				// Walk the Column ID structs and determine
				// the ordinal value
				//===============================================
				for ( i=0; i < cColumnIDs; i++ ){

					if ( ( rgColumnIDs[i].eKind == DBKIND_PROPID && 
							rgColumnIDs[i].uName.ulPropid < 1  && 
							rgColumnIDs[i].uName.ulPropid > BASEROW->m_cTotalCols ) ||

							( rgColumnIDs[i].eKind == DBKIND_NAME && 
							  rgColumnIDs[i].uName.pwszName == NULL ) ||
						 
							( rgColumnIDs[i].eKind == DBKIND_GUID_PROPID ) )
					{

/*					if ( ( rgColumnIDs[i].uName.ulPropid < 1 )               ||
						 ( rgColumnIDs[i].uName.ulPropid > BASEROW->m_cTotalCols ) ||
						 ( rgColumnIDs[i].eKind != DBKIND_GUID_PROPID )      ||
						 ( rgColumnIDs[i].uGuid.guid != GUID_NULL ) )
*/
						rgColumns[i] = DB_INVALIDCOLUMN;
						ulError++;
					}
					else
					{
						if(rgColumnIDs[i].eKind == DBKIND_PROPID)
						{
							rgColumns[i] = rgColumnIDs[i].uName.ulPropid;
						}
						else
						{
							rgColumns[i] = BASEROW->GetOrdinalFromColName(rgColumnIDs[i].uName.pwszName);
						}
					}
				}

				if ( !ulError ){
					hr = S_OK;
				}
				else if ( ulError < cColumnIDs ){
					hr = DB_S_ERRORSOCCURRED;
				}
				else{
					hr = DB_E_ERRORSOCCURRED;
				}
			}
		}
	}

	hr = hr == S_OK ? hr : g_pCError->PostHResult(hr,&IID_IColumnsInfo);

	CATCH_BLOCK_HRESULT(hr,L"IColumnInfo::MapColumnIDs");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\cmdtext.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Microsoft WMI OLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Module	: CMDTEXT.CPP	- ICommandText interface implementation
//							  Also has implementation of CUtlParam class
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "command.h"


////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpICommandText::AddRef(void)
{
   	DEBUGCODE(InterlockedIncrement( (long*) &m_cRef));

	return m_pcmd->GetOuterUnknown()->AddRef();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpICommandText::Release(void)
{
	DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef));
	DEBUGCODE(if( lRef < 0 ){
	   ASSERT("Reference count on Object went below 0!")
	})

	return m_pcmd->GetOuterUnknown()->Release();								
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandText::QueryInterface(	REFIID riid, LPVOID *	ppv		)	
{
	return m_pcmd->GetOuterUnknown()->QueryInterface(riid, ppv);
}

  

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Echos the current command as text, including all post-processing operations added.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandText::GetCommandText( GUID* pguidDialect, LPOLESTR* ppwszCommand )
{
	HRESULT		hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //===============================================================================
	// At the creation of the CAutoBlock object a critical section
	// is entered. This is because the method manipulates shared structures
	// access to which must be serialized . The critical
	// section is left when this method terminate and the destructor
	// for CAutoBlock is called. 
    //===============================================================================
	CAutoBlock 	cab( m_pcmd->GetCriticalSection() );

    //===============================================================================
	// Clear previous Error Object for this thread
    //===============================================================================
	g_pCError->ClearErrorInfo();

    //===============================================================================
	// Check Function Arguments
    //===============================================================================
	if ( ppwszCommand == NULL ){
		
		hr = E_INVALIDARG;
	}
	else
    //===============================================================================
	// If the command has not been set, make sure the buffer
	// contains an empty stringt to return to the consumer
    //===============================================================================
	if(!(m_pcmd->m_pQuery->GetStatus() & CMD_TEXT_SET)){
		hr = DB_E_NOCOMMAND;
	}
	else
	{
		//===============================================================================
		// Copy our saved text into the newly allocated string
		//===============================================================================
		m_pcmd->m_pQuery->GetQuery(*ppwszCommand);

		//===============================================================================
		// If the text we're giving back is a different dialect than was
		// requested, let the caller know what dialect the text is in
		//===============================================================================
		if (pguidDialect && *pguidDialect != DBGUID_DEFAULT && *pguidDialect!= DBGUID_WQL && 
			*pguidDialect != DBGUID_LDAP && *pguidDialect != GUID_NULL && *pguidDialect != DBGUID_WMI_METHOD
			&& *pguidDialect != DBGUID_LDAPSQL){
			hr = DB_S_DIALECTIGNORED;
		}
	}

	if ( FAILED(hr) ){
		if ( pguidDialect )
		{
			memset(pguidDialect, 0, sizeof(GUID));
		}
	}
	else
	{
		if(pguidDialect)
		{
			GUID guidTemp = m_pcmd->m_pQuery->GetDialectGuid();
			memcpy(pguidDialect, &guidTemp,sizeof(GUID));
		}
	}

	hr = hr != S_OK ? g_pCError->PostHResult(hr, &IID_ICommandText): hr;

	CATCH_BLOCK_HRESULT(hr,L"ICommandText::GetCommandText");
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the current command text
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandText::SetCommandText( REFGUID rguidDialect, LPCOLESTR	pwszCommand	)
{
	HRESULT		hr = S_OK;
	VARIANT		varQryLang;
	
	VariantInit(&varQryLang);

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //=========================================================================
	// At the creation of the CAutoBlock object a critical section
	// is entered. This is because the method manipulates shared structures
	// access to which must be serialized . The critical
	// section is left when this method terminate and the destructor
	// for CAutoBlock is called. 
    //=========================================================================
	CAutoBlock 	cab( m_pcmd->GetCriticalSection() );

    //=========================================================================
	// Clear previous Error Object for this thread
    //=========================================================================
	g_pCError->ClearErrorInfo();


    //=========================================================================
	// Don't allow text to be set if we've got a rowset open
    //=========================================================================
	if ( m_pcmd->IsRowsetOpen() ){
		return g_pCError->PostHResult((DB_E_OBJECTOPEN), &IID_ICommandText);
	}

    //=========================================================================
	// Check Dialect
    //=========================================================================
	if (rguidDialect != DBGUID_WQL && rguidDialect != DBGUID_DEFAULT && 
		rguidDialect != DBGUID_LDAP && rguidDialect != DBGUID_WMI_METHOD &&
		rguidDialect != DBGUID_LDAPSQL){

		return g_pCError->PostHResult((DB_E_DIALECTNOTSUPPORTED), &IID_ICommandText);
	}

	if(rguidDialect == DBGUID_WMI_METHOD)
	{
		m_pcmd->m_pQuery->SetType(METHOD_ROWSET);
	}
    //=========================================================================
	// Unprepare if we've already got something prepared
    //=========================================================================
	m_pcmd->UnprepareHelper(UNPREPARE_NEW_CMD);

	// NTRaid 134165
	if(SUCCEEDED(hr = m_pcmd->GetQueryLanguage(varQryLang)))
	{
		//=========================================================================
		// Delete the old text
		//=========================================================================
		if(SUCCEEDED(hr = m_pcmd->m_pQuery->InitQuery(varQryLang.bstrVal)))
		{
			//=========================================================================
			// Save the new text
			//=========================================================================
			if (pwszCommand && *pwszCommand){
				hr = m_pcmd->m_pQuery->SetQuery(pwszCommand,rguidDialect);
			}
			else{
				//=========================================================================
				// There is no text
				//=========================================================================
				hr = m_pcmd->m_pQuery->SetDefaultQuery();
			}
		}
	}
	
	if(SUCCEEDED(hr))
	{
		// If everything is fine then set the datasource persist info to dirty 
		m_pcmd->m_pCDBSession->m_pCDataSource->SetPersistDirty();

		// Clear the column information
		SAFE_DELETE_PTR(m_pcmd->m_pColumns);
		m_pcmd->m_cTotalCols		= 0;
		m_pcmd->m_cCols				= 0;
		m_pcmd->m_cNestedCols		= 0;
	}
	
	VariantClear(&varQryLang);
	hr = hr != S_OK ? g_pCError->PostHResult(hr, &IID_ICommandText): hr;

	CATCH_BLOCK_HRESULT(hr,L"ICommandText::SetCommandText");
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Return an interface from the session object that created this command object
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandText::GetDBSession( REFIID	riid, IUnknown**	ppSession)
{
	HRESULT hr;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //=========================================================================
	// At the creation of the CAutoBlock object a critical section
	// is entered. This is because the method manipulates shared structures
	// access to which must be serialized . The critical
	// section is left when this method terminate and the destructor
	// for CAutoBlock is called. 
    //=========================================================================
	CAutoBlock 	cab( m_pcmd->GetCriticalSection() );

    //=========================================================================
	// Clear previous Error Object for this thread
    //=========================================================================
	g_pCError->ClearErrorInfo();

    //=========================================================================
	// Check Arguments
    //=========================================================================
	if (ppSession == NULL){

		return g_pCError->PostHResult((E_INVALIDARG), &IID_ICommandText);
	}

    //=========================================================================
	// Initialize output param
    //=========================================================================
	*ppSession = NULL;

    //=========================================================================
	// Query for the interface on the session object.  If failure,
	// return the error from QueryInterface.
    //=========================================================================
	hr = (m_pcmd->m_pCDBSession->GetOuterUnknown())->QueryInterface(riid, (VOID**)ppSession);
	
	hr = hr != S_OK ? g_pCError->PostHResult(hr, &IID_ICommandText): hr;

	CATCH_BLOCK_HRESULT(hr,L"ICommandText::GetSession");
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The consumer can allocate a secondary thread in which to cancel 
// the currently executing thread.  This cancel will only succeed if 
// the result set is still being generated.  If the rowset object is being
// created, then it will be to late to cancel.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandText::Cancel(void)
{
	HRESULT		hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //=========================================================================
	// Clear previous Error Object for this thread
    //=========================================================================
	g_pCError->ClearErrorInfo();

	m_pcmd->m_pQuery->m_pcsQuery->Enter();
	if (m_pcmd->m_pQuery){

        HRESULT retcode = m_pcmd->m_pQuery->CancelQuery();
		if( S_OK == retcode){
			m_pcmd->m_pQuery->InitQuery(); // ?
		}
		else{
			hr = DB_E_CANTCANCEL;
		}
		m_pcmd->m_pQuery->SetCancelStatus(CMD_EXEC_CANCELED);
	}
    else{
		m_pcmd->m_pQuery->SetCancelStatus(CMD_EXEC_CANCELED | CMD_EXEC_CANCELED_BEFORE_CQUERY_SET);
	}
	m_pcmd->m_pQuery->m_pcsQuery->Leave();

	hr = hr != S_OK ? g_pCError->PostHResult(hr, &IID_ICommandText): hr;

	CATCH_BLOCK_HRESULT(hr,L"ICommandText::Cancel");
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Execute the command.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandText::Execute(	IUnknown*		pUnkOuter,
	REFIID			riid,			//@parm IN | Interface ID of the interface being queried for.
	DBPARAMS*		pParams,		//@parm INOUT | Parameter Array
	DBROWCOUNT*		pcRowsAffected,	//@parm OUT | count of rows affected by command
	IUnknown**		ppRowsets		//@parm OUT | Pointer to interface that was instantiated     
	)
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;
	VARIANT		varQryLang;
	
	VariantInit(&varQryLang);

	TRY_BLOCK;
    
	//=========================================================================
	// At the creation of the CAutoBlock object a critical section is entered. 
	// This is because the method manipulates shared structures access to which 
	// must be serialized . The critical section is left when this method 
	// terminate and the destructor for CAutoBlock is called. 
    //=========================================================================
	CAutoBlock 	cab( m_pcmd->GetCriticalSection() );

	m_pcmd->m_pQuery->m_pcsQuery->Enter();
	if (m_pcmd->m_pQuery->GetCancelStatus() & CMD_EXEC_CANCELED_BEFORE_CQUERY_SET){

		m_pcmd->m_pQuery->ClearCancelStatus(CMD_EXEC_CANCELED | CMD_EXEC_CANCELED_BEFORE_CQUERY_SET);
	}
	if (m_pcmd->m_pQuery->GetStatus() & CMD_EXECUTED_ONCE){

		m_pcmd->m_pQuery->ClearStatus(CMD_EXECUTED_ONCE);
	}
	// get the QueryLanguage Property and set it on the
	// query object
	// NTRaid 134165
	if(SUCCEEDED(hr = m_pcmd->GetQueryLanguage(varQryLang)))
	{
		hr = m_pcmd->m_pQuery->SetQueryLanguage(varQryLang.bstrVal);
	}
	m_pcmd->m_pQuery->m_pcsQuery->Leave();

    //=========================================================================
	// Clear previous Error Object for this thread
    //=========================================================================
	g_pCError->ClearErrorInfo();
	
	if(SUCCEEDED(hr))
	{
		//=========================================================================
		// Execute the command
		//=========================================================================
		hr = m_pcmd->Execute(pUnkOuter, riid, pParams, pcRowsAffected, ppRowsets);
	}
	
	VariantClear(&varQryLang);
	CATCH_BLOCK_HRESULT(hr,L"ICommandText::Execute");
	return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//*********************************************************************************************************
//
//  CUtlParam class
//	
//*********************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This routine builds the binding information needed to execute a command with parameters 
//
//  HRESULT indicating status 
//		 S_OK | No problem processing parameter or statement
//		 E_FAIL | Provider specific error
//		 E_OUTOFMEMORY | Not enough resources
//		 E_UNEXPECTED | Zombie State
//		 DB_E_BADACCESSORHANDLE | Accessor handle invalid
//		 DB_E_BADACCESSORTYPE | Non-Parameter Accessor used
//		 DB_E_BADPARAMETER | Parameter information not correct
//		 DB_E_BADPARAMETERCOUNT | Bad Parameter Count
//		 DB_E_DUPLICATEPARAM | Same parameter used twice      
///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUtlParam::BuildBindInfo(	CCommand	*pcmd,	DBPARAMS	*pParams,	const IID*	piid)
{
	HRESULT			hr = S_OK;
	// NTRaid::111812
	// 06/07/00
	PACCESSOR	    pAccessor = NULL;
	DBORDINAL		iBind;
	DBCOUNTITEM		iParamSet;
	DBBINDING		*pBind;
//	DBTYPE			wType;
	ULONG			cErrors	= 0;
	DBORDINAL		iParam;
	BYTE			*pbData;
	ULONG			cBindInfo;
	ULONG			iDupBind;
	WMIBINDINFO		*pBindInfo;
	BOOL			fDeriveParamsFromSql = FALSE;

    //==========================================================
	// Copy DBPARAMS struct (C++ bitwise copy)
    //==========================================================
	m_dbparams	= *pParams;

    //==========================================================
	// Add an extra reference count to the user's accessor,
	// since we're now holding a pointer to it in m_dbparams
    //==========================================================
	m_pIAccessor = pcmd->GetIAccessorPtr();
	m_pIAccessor->AddRefAccessor(m_dbparams.hAccessor, NULL);

    //==========================================================
	// Obtain pointer to the accessor that the user passed to us
    //==========================================================
	m_pIAccessor->GetAccessorPtr()->GetItemOfExtBuffer(pParams->hAccessor, &pAccessor);
	m_cbRowSize = 999;
	
    //==========================================================
	// Make sure at least one binding for each parameter
    //==========================================================
	m_cParams = pcmd->GetParamCount();
    if (pAccessor->cBindings < m_cParams){
		hr = DB_E_PARAMNOTOPTIONAL;
    }
	else
	{
		//==========================================================
		// Allocate mem ory for binding information
		//==========================================================
		iDupBind = m_cParams;
		cBindInfo = max(m_cParams, pAccessor->cBindings);
		m_prgBindInfo = new WMIBINDINFO[cBindInfo];

		if (NULL == m_prgBindInfo){
			hr = E_OUTOFMEMORY;
		}
		else
		{
			memset(m_prgBindInfo, 0, sizeof(WMIBINDINFO)*cBindInfo);

			//==========================================================
			// Process each binding of the given accessor
			//==========================================================
			for (iBind = 0; iBind < pAccessor->cBindings; iBind++){

				//======================================================
				// Get the pointer to the binding of interest
				//======================================================
				pBind = pAccessor->rgBindings + iBind;

				//======================================================
				// Make sure this binding's ordinal is valid
				//======================================================
				if (!pBind->iOrdinal || pBind->iOrdinal > m_cParams){

					//==================================================
					// This is a bad accessor; set status if bound
					//==================================================
					SetStatus(pBind, DBSTATUS_E_BADACCESSOR);

					//==================================================
					// Count this error and look for more
					//==================================================
					cErrors++;
					continue;
				}
				iParam = pBind->iOrdinal - 1;
				
				//======================================================
				// Save the binding 
				//======================================================
				if (NULL == m_prgBindInfo[iParam].pBinding){

					m_prgBindInfo[iParam].pBinding = pBind;
					if (pBind->eParamIO & DBPARAMIO_OUTPUT)
						m_prgBindInfo[iParam].wFlags |= DBPARAMIO_OUTPUT;
					if (pBind->eParamIO & DBPARAMIO_INPUT)
						m_prgBindInfo[iParam].wFlags |= DBPARAMIO_INPUT;
				}
				else {

					//==================================================
					// Multiple bindings for this parameter
					//==================================================
					pBindInfo = m_prgBindInfo + iDupBind++;
					pBindInfo->pBinding = pBind;
					pBindInfo->pNextBindInfo = 
						m_prgBindInfo[iParam].pNextBindInfo;
					m_prgBindInfo[iParam].pNextBindInfo = pBindInfo;
					if (pBind->eParamIO & DBPARAMIO_OUTPUT)
						m_prgBindInfo[iParam].wFlags |= DBPARAMIO_OUTPUT;
					if (pBind->eParamIO & DBPARAMIO_INPUT){

						if (m_prgBindInfo[iParam].wFlags & DBPARAMIO_INPUT){

							//==========================================
							// A bad accessor; set status if bound
							//==========================================
							SetStatus(pBind, DBSTATUS_E_BADACCESSOR);
							//==========================================
							// Count this error and look for more
							//==========================================
							cErrors++;
							continue;
						}
						m_prgBindInfo[iParam].wFlags |= DBPARAMIO_INPUT;
					}
				}
			
				//======================================================
				// Get the parameter type from the accessor
				//======================================================
				switch (pBind->eParamIO){

					case DBPARAMIO_INPUT:
					case DBPARAMIO_OUTPUT:
					case DBPARAMIO_INPUT|DBPARAMIO_OUTPUT:
						break;

					case DBPARAMIO_NOTPARAM:
					default:
						// This is a bad accessor; set status if bound
						SetStatus(pBind, DBSTATUS_E_BADACCESSOR);

						// Count this error and look for more
						cErrors++;
						continue;
				}

				for (pbData = (BYTE*)m_dbparams.pData, iParamSet = 0;iParamSet < m_dbparams.cParamSets;pbData += m_cbRowSize, iParamSet++ ){

					//=========================================================================
					// If this is not an output param and we aren't given a value 
					// or a DBSTATUS_S_ISNULL, that's an error
					//=========================================================================
					BOOL fOutput = m_prgBindInfo[iParam].wFlags & DBPARAMIO_OUTPUT;
					if ((!fOutput )	&& !(pBind->dwPart & DBPART_VALUE) 	&& (!(pBind->dwPart & DBPART_STATUS) 
							|| *(DBSTATUS *)((BYTE *)pbData + pBind->obStatus) 	!= DBSTATUS_S_ISNULL) )	{

						// This is a bad accessor; set status if bound
						if (pBind->dwPart & DBPART_STATUS){

							*(DBSTATUS *)(pbData + pBind->obStatus) =DBSTATUS_E_BADACCESSOR;
						}

						// Count this error and look for more
						cErrors++;
						break;
					}
					if ((pBind->dwPart & DBPART_STATUS) && DBSTATUS_S_DEFAULT == *(DBSTATUS*)((BYTE*)pbData + pBind->obStatus)) {
						m_dwStatus |= CUTLPARAM_DEFAULT_PARAMS;
					}

				}
			} // end of outer for loop


			// Any errors in processing bindings?
			if (cErrors){
				hr = DB_E_ERRORSOCCURRED;
			}
			else
			if (SUCCEEDED(hr = BuildParamInfo(pcmd, piid)))
			{

				for (iParam = 0; iParam < m_cParams; iParam++){
					if ((m_prgBindInfo[iParam].wFlags & DBPARAMIO_INPUT)      && !((m_prgBindInfo[iParam].pParamInfo->dwFlags & DBPARAMFLAGS_ISINPUT))
						|| ((m_prgBindInfo[iParam].wFlags & DBPARAMIO_OUTPUT) && !(m_prgBindInfo[iParam].pParamInfo->dwFlags & DBPARAMFLAGS_ISOUTPUT))){

						// This is a bad accessor; set status if bound
						SetStatus(pBind, DBSTATUS_E_BADACCESSOR);
						for (pBindInfo = m_prgBindInfo[iParam].pNextBindInfo; pBindInfo; pBindInfo = pBindInfo->pNextBindInfo)
							SetStatus(pBindInfo->pBinding, DBSTATUS_E_BADACCESSOR);

						// Count this error and look for more
						cErrors++;
					}
				}
				if (cErrors)
				{
					hr = DB_E_ERRORSOCCURRED;
				}
			}
		} // if memory is allocated properly

	}		// else for checking for DB_E_PARAMNOTOPTIONAL error


	hr = hr != S_OK ? g_pCError->PostHResult(hr, piid): hr;
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This routine builds the parameter information for the command from the binding information.
//
//  HRESULT indicating status 
//		 S_OK | No problem processing parameter or statement
//		 E_FAIL | Provider specific error
//		 E_OUTOFMEMORY | Not enough resources
//        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUtlParam::BuildParamInfo( CCommand	*pcmd,	const IID*	piid	)
{
	HRESULT		hr = S_OK;
	ULONG		iParam(0);
	PPARAMINFO	pParamInfo;
	DBBINDING	*pBind;
	BYTE*		pbData = NULL;
	DWORD*		pdwLength;
	DWORD		dwLength(0);
	DBSTATUS*	pdwStatus;
	DBSTATUS	dwStatus(0);
	DBLENGTH	cbMaxLen(0);
	VARIANT		varValue;

	VariantInit(&varValue);

	m_rgpParamInfo = new PPARAMINFO[m_cParams];
	if (NULL == m_rgpParamInfo)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		memset(m_rgpParamInfo, 0, sizeof(PPARAMINFO)*m_cParams);

		for (iParam = 0; iParam < m_cParams; iParam++){

			VariantClear(&varValue);
			pParamInfo = pcmd->GetParamInfo(iParam);
			if (pParamInfo){

				m_rgpParamInfo[m_cParamInfo++] = pParamInfo;

				pParamInfo->dwFlags = DBPARAMFLAGS_ISNULLABLE;
				if (m_prgBindInfo[iParam].wFlags & DBPARAMIO_INPUT)
					pParamInfo->dwFlags |= DBPARAMFLAGS_ISINPUT;
				if (m_prgBindInfo[iParam].wFlags & DBPARAMIO_OUTPUT)
					pParamInfo->dwFlags |= DBPARAMFLAGS_ISOUTPUT;

				//=========================================================
				// Bind the parameter
				//=========================================================
				pBind = GetBinding(m_prgBindInfo+iParam);
				if( pBind ){
					BindParamData(1, iParam+1, pBind, &pParamInfo->pbData, &pdwLength, (ULONG*)&pParamInfo->cbColLength, &pdwStatus, &dwStatus, &(pParamInfo->wOLEDBType));

					//=========================================================
					// Get the data type for variant params
					//=========================================================
					if (pParamInfo->wOLEDBType == DBTYPE_VARIANT && pParamInfo->pbData != NULL)
						pParamInfo->wOLEDBType = V_VT((VARIANT *)pParamInfo->pbData);

					// For variable length params, find the max len
					cbMaxLen = 0;
					if (DBTYPE_STR == pParamInfo->wOLEDBType     || DBTYPE_WSTR == pParamInfo->wOLEDBType
						|| DBTYPE_BSTR == pParamInfo->wOLEDBType || DBTYPE_BYTES == pParamInfo->wOLEDBType)
					{

						ULONG iParamSet;
						DBTYPE wDstType = (DBTYPE_BSTR == pParamInfo->wOLEDBType) ? DBTYPE_WSTR : pParamInfo->wOLEDBType;

						cbMaxLen = pBind->cbMaxLen;
						
						for (iParamSet = 2; iParamSet <= m_dbparams.cParamSets; iParamSet++)
						{

							DBTYPE wSrcType;

							//==========================================
							// Bind the parameter
							//==========================================
							pBind = m_prgBindInfo[iParam].pBinding;
							BindParamData(iParamSet, iParam+1, pBind, &pbData, &pdwLength, &dwLength, &pdwStatus, &dwStatus, &wSrcType);

							cbMaxLen = pBind->cbMaxLen;
						}
					

    					// Initialize the parameter info
						BOOL bArray = FALSE;
						CDataMap Map;
						if(hr == S_OK)
						{
							hr = Map.MapOLEDBTypeToCIMType(pParamInfo->wOLEDBType, pParamInfo->CIMType ) ;

							if( S_OK == hr ){

								WORD wTmp = 0;
								DBLENGTH uSize = 0;
								DWORD dwFlags = 0;
								
								// if the length as obtained from BindParamData is 0 and if the parameter
								// is input then get the size of parameter for the type
								if(pParamInfo->cbColLength == 0 && (pParamInfo->dwFlags & DBPARAMIO_INPUT))
								{
									hr = Map.MapCIMTypeToOLEDBType(pParamInfo->CIMType, wTmp, uSize, dwFlags );
									if( hr == S_OK ){

										pParamInfo->cbColLength = pParamInfo->cbValueMax = pParamInfo->ulParamSize = uSize;

									}
								}

						   }
						}
					}
					m_prgBindInfo[iParam].pParamInfo = pParamInfo;
					
				}
			}
		 }
	}
//Exit:
	hr = hr != S_OK ? g_pCError->PostHResult(E_OUTOFMEMORY, piid): hr;
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the bind status for all parameters, except the one that caused the command to fail, 
// to DBSTATUS_E_UNAVAILABLE.
//
//  Nothing
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
void CUtlParam::SetParamsUnavailable(	ULONG	iParamSetFailed,	ULONG	iParamFailed,	BOOL	fBackOut	)
{
	assert(iParamSetFailed);

	ULONG		iParam;
	ULONG		iParamSet;
	BYTE*		pbData;
	PWMIBINDINFO pBindInfo;

	for ( iParamSet = fBackOut? 1 : iParamSetFailed,  pbData= (BYTE*)m_dbparams.pData + (iParamSet-1)*m_cbRowSize;
			iParamSet <= m_dbparams.cParamSets; iParamSet++, pbData += m_cbRowSize){

		for (	iParam = 1, pBindInfo = m_prgBindInfo;	iParam <= m_cParams; iParam++, pBindInfo++){
			DBSTATUS* pdbstatus = (DBSTATUS *)	(pbData + pBindInfo->pBinding->obStatus);

			if (pBindInfo->pBinding->dwPart & DBPART_STATUS){ 

				if (iParamSet != iParamSetFailed || iParam != iParamFailed
					|| *pdbstatus == DBSTATUS_S_OK
					|| *pdbstatus == DBSTATUS_S_ISNULL
					|| *pdbstatus == DBSTATUS_S_DEFAULT){
					*pdbstatus = DBSTATUS_E_UNAVAILABLE;
				}
			}
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUtlParam::BindParamData( ULONG iParamSet, ULONG iParam, DBBINDING*	pBinding,BYTE**	ppbValue, 
                               DWORD** ppdwLength, DWORD* pdwLength,DBSTATUS**	ppdwStatus,	
                               DBSTATUS*	pdwStatus,	DBTYPE*	pdbtype	 )
{
	assert(iParamSet && iParamSet <= m_dbparams.cParamSets);
	assert(iParam && iParam <= m_cParams);
	assert(pBinding);
	assert(pBinding->iOrdinal == iParam);
	assert(ppbValue);
	assert(ppdwLength);
	assert(pdwLength);
	assert(ppdwStatus);
	assert(pdwStatus);
	BYTE* pbData = (BYTE*)m_dbparams.pData + (iParamSet-1)*m_cbRowSize;
	
	*pdbtype = pBinding->wType & ~DBTYPE_BYREF;
	if (pBinding->dwPart & DBPART_VALUE){
		*ppbValue = pbData + pBinding->obValue;

		if (pBinding->wType & DBTYPE_BYREF){
			assert(!IsBadReadPtr(*ppbValue,sizeof(BYTE*)));
			*ppbValue = *(BYTE**)*ppbValue;
		}
	}
	else{
		*ppbValue = NULL;
	}

	if (pBinding->dwPart & DBPART_STATUS){
		assert(!IsBadReadPtr(pbData+pBinding->obStatus,sizeof(DBSTATUS)));
		*ppdwStatus = (DBSTATUS*)(pbData + pBinding->obStatus);
		*pdwStatus = **ppdwStatus;
	}
	else{
		*ppdwStatus = NULL;
		*pdwStatus = DBSTATUS_S_OK;
	}

	*ppdwLength = (pBinding->dwPart & DBPART_LENGTH) ? (DWORD*)(pbData + pBinding->obLength) : NULL;
	if (*pdwStatus != DBSTATUS_S_OK || *ppbValue == NULL || pBinding->eParamIO == DBPARAMIO_OUTPUT){
		*pdwLength = 0;
	}
	//NTRaid:111761
	// 06/07/00
	else
	if(*ppdwLength)
	{
		*pdwLength = *(*ppdwLength);
	}
	else
	{
		*pdwLength = 0;
	}

	// check NULL data
	if (*pdwStatus == DBSTATUS_S_OK	&& *ppbValue  && (*pdbtype == DBTYPE_VARIANT || *pdbtype == DBTYPE_PROPVARIANT)
		&& V_VT((VARIANT *)(*ppbValue)) == VT_NULL){
		*pdwStatus = DBSTATUS_S_ISNULL;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////

ULONG CUtlParam::AddRef ( void)
{
	return InterlockedIncrement( (long*) &m_cRef);
}	


///////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CUtlParam::Release(void)
{
	assert( m_cRef > 0 );
	ULONG cRef = InterlockedDecrement( (long*) &m_cRef);
	if (!cRef)
		delete this;
	return cRef;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
CUtlParam::CUtlParam()
{
    m_cRef = 0;			
    m_cbRowSize = 0;
	m_cParams = 0;		
    m_cParamInfo = 0;
	m_dwStatus = 0;

    m_pIAccessor = NULL;
	m_prgBindInfo = NULL;
    m_rgpParamInfo = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
CUtlParam::~CUtlParam()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\cmdprop.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Microsoft WMI OLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Module	:	CMDPROP.CPP		- ICommandProperties interface implementation
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"


////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpICommandProperties::AddRef(void)
{
	DEBUGCODE(InterlockedIncrement((long*) &m_cRef ));
	return m_pcmd->GetOuterUnknown()->AddRef();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpICommandProperties::Release(void)
{
	DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef));
	DEBUGCODE(if( lRef < 0 ){
	   ASSERT("Reference count on Object went below 0!")
	});

	return m_pcmd->GetOuterUnknown()->Release();								
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandProperties::QueryInterface( REFIID riid, LPVOID *	ppv		)	
{
	return m_pcmd->GetOuterUnknown()->QueryInterface(riid, ppv);
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandProperties::GetProperties(	const ULONG			cPropertySets,		//@parm IN | Number of property sets
	                                                const DBPROPIDSET	rgPropertySets[],	//@parm IN | Property Sets
	                                                ULONG*				pcProperties,		//@parm OUT | Count of structs returned
	                                                DBPROPSET**			prgProperties		//@parm OUT | Array of Properties
)
{
	HRESULT hr;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //=============================================================================
	// At the creation of the CAutoBlock object a critical section
	// is entered. This is because the method manipulates shared structures
	// access to which must be serialized . The critical
	// section is left when this method terminate and the destructor
	// for CAutoBlock is called. 
    //=============================================================================
	CAutoBlock 	cab( m_pcmd->GetCriticalSection() );

	assert( m_pcmd );

    //=============================================================================
	//NOTE: Since we are non-chaptered, we just ignore the 
	// rowset name argument.
    //=============================================================================

	g_pCError->ClearErrorInfo();

	hr = m_pcmd->m_pUtilProps->GetPropertiesArgChk(PROPSET_COMMAND, cPropertySets, rgPropertySets, pcProperties, prgProperties,TRUE);

	if ( SUCCEEDED(hr) ){
		// NTRaid: 135246
		hr = m_pcmd->m_pUtilProps->GetProperties(PROPSET_COMMAND,cPropertySets, rgPropertySets, pcProperties,prgProperties);
	}

	hr = hr != S_OK ? g_pCError->PostHResult(hr, &IID_ICommandProperties): hr;

	CATCH_BLOCK_HRESULT(hr,L"ICommandProperties::GetProperties");
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpICommandProperties::SetProperties(	ULONG	   cPropertySets,		//@parm IN | Count of structs returned
	                                                DBPROPSET  rgPropertySets[])	//@parm IN | Array of Properties

{
	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	assert( m_pcmd );

    //=============================================================================
	// At the creation of the CAutoBlock object a critical section
	// is entered. This is because the method manipulates shared structures
	// access to which must be serialized . The critical
	// section is left when this method terminate and the destructor
	// for CAutoBlock is called. 
    //=============================================================================
	CAutoBlock 	cab( m_pcmd->GetCriticalSection() );

    //=============================================================================
	//NOTE: Since we are non-chaptered, we just ignore the rowset name argument.
    //=============================================================================
	g_pCError->ClearErrorInfo();

    //=============================================================================
	// Quick return if the Count of Properties is 0
    //=============================================================================
	if ( cPropertySets != 0 )
		{
		hr = m_pcmd->m_pUtilProps->SetPropertiesArgChk(cPropertySets, rgPropertySets);
		if ( SUCCEEDED(hr) ){

			//=========================================================================
			// Don't allow properties to be set if we've got a rowset open
			//=========================================================================
			if ( m_pcmd->IsRowsetOpen() )
			{
				hr = DB_E_OBJECTOPEN;
			}
			else
			{
				hr = m_pcmd->m_pUtilProps->SetProperties(PROPSET_COMMAND,cPropertySets, rgPropertySets);
			}
		}

	}
	
	hr = hr != S_OK ? g_pCError->PostHResult(hr, &IID_ICommandProperties):  hr;

	CATCH_BLOCK_HRESULT(hr,L"ICommandProperties::SetProperties");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\command.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// COMMAND.CPP - CCommand object implementation
//					File also contain the implementation of CQuery class
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"
#include "command.h"

#define NO_ROWCOUNT_TOTAL		(-1)
#define PARAM_LIST_SIZE        2056
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning (disable:4355)
CCommand::CCommand( CDBSession*	pCDBSession, LPUNKNOWN pUnkOuter ) : CBaseObj(BOT_COMMAND,pUnkOuter)
{
	//===============================================================
	//  Initially, NULL all contained interfaces
	//===============================================================
	m_pIAccessor                    = NULL;
	m_pIColumnsInfo                 = NULL;
	m_pIConvertType					= NULL;


    //=======================================================
    // Establish the parent object
    //=======================================================
	m_pCDBSession				= pCDBSession;
	m_pCDBSession->GetOuterUnknown()->AddRef();

    //=======================================================
    // Initialize all ptrs to embedded interfaces
    //=======================================================
    m_pICommandText = NULL;
	m_pICommandWithParameters = NULL;	
    m_pICommandProperties = NULL;
    m_pISupportErrorInfo = NULL;


    //=======================================================
	//	Initialize simple member vars
    //=======================================================
	m_cRowsetsOpen				= 0;
	m_guidImpersonate			= GUID_NULL;
//	m_pdbc						= pCDBSession->GetDBConnection();
	m_pQuery					= NULL;

	m_pColumns					= NULL;
	m_cTotalCols				= 0;
	m_cCols						= 0;
	m_cNestedCols				= 0;

}
#pragma warning (default:4355)
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor for this class
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
CCommand::~CCommand (void)
{
    
    SAFE_DELETE_PTR( m_pUtilProps);
    SAFE_DELETE_PTR( m_pQuery );
    //====================================================================
	// Free Statement 
    //====================================================================
	if (m_pQuery)
	{
		m_pQuery->InitQuery();
	}

    //=======================================================
    //  Delete the embedded pointers
    //=======================================================
    SAFE_DELETE_PTR( m_pICommandText );
	SAFE_DELETE_PTR( m_pICommandWithParameters );	
    SAFE_DELETE_PTR( m_pICommandProperties );
	SAFE_DELETE_PTR(m_pIAccessor);
	SAFE_DELETE_PTR(m_pIConvertType);
	SAFE_DELETE_PTR(m_pISupportErrorInfo);
	SAFE_DELETE_PTR(m_pIColumnsInfo);


	SAFE_DELETE_PTR(m_pColumns);

    //====================================================================
	// Since Command Object is going away, we can decrement 
	// our count on the session object.
	// Note that this typically deletes our hdbc, DataSource, Session.
	// (So do this last.)
    //====================================================================
	if (m_pCDBSession)
	{
		m_pCDBSession->GetOuterUnknown()->Release();
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Initialize the command Object.  This Init routine should be used by CreateCommand and also be called
// as a secondary initialization routine for the other FInit on the command object.
//
// If this initialization routine fails, it is the callers responsibility to delete this object. 
// The destructor will then clean up any allocated resources
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CCommand::FInit( WORD wRowsetProps )
{
    HRESULT hr = S_OK;

	//===============================================
	//  Get the query class going
	//===============================================
	m_pQuery = new CQuery;

	//===============================================
	// Initialize rowset properties
	//===============================================
	m_pUtilProps     = new CUtilProp;

	// NTRaid: 136443
	// 07/05/00
	if(m_pUtilProps == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	if(SUCCEEDED(hr = m_pUtilProps->FInit(COMMANDPROP)))
	{

		//===============================================
		// Initialize ErrorData
		//===============================================
		if (FAILED(m_CError.FInit()))
			hr = (E_OUTOFMEMORY);
		else
		{
			m_pIAccessor                = new CImpIAccessor(this,FALSE);
			if( m_pIAccessor ){
				hr = m_pIAccessor->FInit();
					
			}

			if(SUCCEEDED(hr))
			{
				m_pICommandText             = new CImpICommandText(this);
				m_pICommandWithParameters   = new CImpICommandWithParameters(this);	
				m_pICommandProperties       = new CImpICommandProperties(this);
				m_pIConvertType				= new CImpIConvertType(this);
				m_pISupportErrorInfo		= new CImpISupportErrorInfo(this);
				m_pIColumnsInfo				= new CImpIColumnsInfoCmd(this);

				//===============================================
				// Initialize name pool
				//===============================================
				m_extNamePool.FInit(1,0,256);


				if( m_pUtilProps && m_pIAccessor && m_pICommandText && m_pICommandWithParameters && 
					m_pIConvertType && m_pIColumnsInfo && m_pISupportErrorInfo)
				{
    				hr = S_OK;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}
		}
	}

	if(SUCCEEDED(hr))
	{
		hr = AddInterfacesForISupportErrorInfo();
	}

    return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to add interfaces to ISupportErrorInfo interface
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CCommand::AddInterfacesForISupportErrorInfo()
{
	HRESULT hr = S_OK;

	if(SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IAccessor))					&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_ICommand))					&&  
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_ICommandText))				&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_ICommandProperties))		&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_ICommandWithParameters))	&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IColumnsInfo)))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IConvertType);
	}

	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Determines if command is canceled and if not sets the currently active CQuery.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline HRESULT CCommand::CheckCanceledHelper(CQuery*		pstmt)
{
	HRESULT		hr;
    DWORD dwCancelStatus = m_pQuery->GetCancelStatus();

	// Set the currently active CQuery, for use by the cancel routine
	m_pQuery->m_pcsQuery->Enter();
	if (dwCancelStatus & CMD_EXEC_CANCELED){
		dwCancelStatus &= ~(CMD_EXEC_CANCELED|CMD_EXEC_CANCELED_BEFORE_CQUERY_SET);
		hr = DB_E_CANCELED;
	}
	else{
		hr = S_OK;
	}
	m_pQuery->m_pcsQuery->Leave();
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to a specified interface. Callers use QueryInterface to determine which interfaces 
// the called object supports. 
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCommand::QueryInterface( REFIID riid,	LPVOID * ppv )
{
	HRESULT hr = S_OK;

	if ( ppv == NULL )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		//=======================================================
		//	This is the non-delegating IUnknown implementation
		//=======================================================
		if ( riid == IID_IUnknown )
			*ppv = (LPVOID)this;
		else if ( riid == IID_IAccessor )
			*ppv = (LPVOID)m_pIAccessor;
		else if ( riid == IID_ICommand || riid == IID_ICommandText)
			*ppv = (LPVOID)m_pICommandText;
		else if ( riid == IID_ICommandProperties )
			*ppv = (LPVOID)m_pICommandProperties;
		else if ( riid == IID_IColumnsInfo )
			*ppv = (LPVOID)m_pIColumnsInfo;
		else if ( riid == IID_ICommandWithParameters )
			*ppv = (LPVOID)m_pICommandWithParameters;
		else if ( riid == IID_ISupportErrorInfo )
			*ppv = (LPVOID)m_pISupportErrorInfo;
		else if ( riid == IID_IConvertType )
			*ppv = (LPVOID)m_pIConvertType;
		else{
			*ppv = NULL;
			hr = E_NOINTERFACE;
		}

		if( *ppv ){
    		((LPUNKNOWN)*ppv)->AddRef();
		}
	}
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Increments a persistence count for the object
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CCommand::AddRef (void)
{
	ULONG cRef = InterlockedIncrement( (long*) &m_cRef);
	return cRef;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrements a persistence count for the object and if persistence count is 0, the object destroys itself.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CCommand::Release (void)
{
	ULONG cRef = InterlockedDecrement( (long *) &m_cRef);
	if ( !cRef ){
		delete this;
		return 0;
	}
	return cRef;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//  UTILITY FUNCTIONS   UTILITY FUNCTIONS
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Errors that can occur may result in another HRESULT other than E_FAIL, thus this routine 
// determines that HRESULT and posts the errors
//
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CCommand::PostExecuteWarnings( CErrorData* pError, const IID* piid )
{
	HRESULT		hr = S_OK;

	if (*piid == IID_ITableDefinition){

	}
	if (*piid == IID_IIndexDefinition){
	}
    //==========================================================
	// If we are not posting errors for IID_IOpenRowset
    //==========================================================
	if (*piid == IID_IOpenRowset){
        //======================================================
		// Map errors in command to DB_E_NOTABLE.
		// Other errors should flow through.  (Some like 
        // _DATAOVERFLOW we should never get.)
        //======================================================
		if (hr == DB_E_ERRORSINCOMMAND)
		{
			hr = (DB_E_NOTABLE);
		}
		else if (hr == DB_E_ABORTLIMITREACHED || hr == DB_E_CANCELED)
		{
			hr = (E_FAIL);
		}
	}
	g_pCError->PostWMIErrors(hr, piid, pError);
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Errors that can occur may result in another HRESULT other than E_FAIL, thus this routine 
// determines that HRESULT and posts the errors
//
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CCommand::PostExecuteErrors( CErrorData* pError, const IID* piid )
{
	HRESULT		hr = S_OK;

	if (*piid == IID_ITableDefinition){

	}
	if (*piid == IID_IIndexDefinition){
	}
    //==========================================================
	// If we are not posting errors for IID_IOpenRowset
    //==========================================================
	if (*piid == IID_IOpenRowset){
        //======================================================
		// Map errors in command to DB_E_NOTABLE.
		// Other errors should flow through.  (Some like 
        // _DATAOVERFLOW we should never get.)
        //======================================================
		if (hr == DB_E_ERRORSINCOMMAND)
		{
			hr = (DB_E_NOTABLE);
		}
		else if (hr == DB_E_ABORTLIMITREACHED || hr == DB_E_CANCELED)
		{
			hr = (E_FAIL);
		}
	}
	g_pCError->PostWMIErrors(hr, piid, pError);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Marks command as unprepared, and may force this state.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCommand::UnprepareHelper( DWORD dwUnprepareType )
{

	// Unprepare the statement - free it from WBEM


	// Free memory for the row metadata for the first rowset in the command.
//	m_extNamePool.Free();
    DWORD dwStatus = m_pQuery->GetStatus();
    
    dwStatus &= ~CMD_HAVE_COLUMNINFO;

	if (UNPREPARE_NEW_CMD == dwUnprepareType)	// A new command is being set
	{
		// We need to remember that we have to rebuild our parameter info
		dwStatus &= ~(CMD_TEXT_PARSED 
			| CMD_READY
			| CMD_PARAMS_USED 
			| CMD_EXECUTED_ONCE );

		// Reset parameter information. 
		if (m_pQuery->GetParamCount()){
			if (m_pQuery->m_prgbCallParams){
				delete [] m_pQuery->m_prgbCallParams;
				m_pQuery->m_prgbCallParams = NULL;
			}
			if (m_pQuery->m_prgProviderParamInfo){
				delete [] m_pQuery->m_prgProviderParamInfo;
				m_pQuery->m_prgProviderParamInfo = NULL;
			}
			//@devnote We do not delete the consumer parameter information.
			// The only reference in the OLE DB spec to removing the consumer
			// parameter info is via ICommandWithParameters::SetParameterInfo.
			}
		}
	else if (UNPREPARE_RESET_CMD == dwUnprepareType){
		dwStatus &= ~CMD_READY;
	}

    m_pQuery->InitStatus(dwStatus);
	return S_OK;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Determines if bookmarks are present.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CCommand::FHaveBookmarks()
{
	BOOL flag = FALSE;

//	flag = 	(m_pUtilProps.IsRequiredTrue(CUtilProp::eid_DBPROPSET_ROWSET, CUtilProp::eid_DBPROPVAL_BOOKMARKS)
//		    || m_pUtilProps.IsRequiredTrue(CUtilProp::eid_DBPROPSET_ROWSET, CUtilProp::eid_DBPROPVAL_IRowsetLocate)
//		    || m_pUtilProps.IsRequiredTrue(CUtilProp::eid_DBPROPSET_ROWSET, CUtilProp::eid_DBPROPVAL_CANHOLDROWS) 	);
	return flag;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Re-executes a command to reposition to reposition to the beginning of the rowset.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CCommand::ReExecute( PCROWSET	pCRowset,LONG* pcCursorRows, WORD*	pcCols	)
{
	DWORD dwFlags = EXECUTE_RESTART;
//	return ExecuteHelper(&IID_IRowset, pCRowset->GetStmt(),  &dwFlags, 	pCRowset->GetRowsetProps(), NULL, NULL, pcCursorRows, pcCols, NULL);
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCommand::Execute(	IUnknown*		pUnkOuter,			//@parm IN | Outer Unknown
	                            REFIID			riid,				//@parm IN | Interface ID of the interface being queried for.
	                            DBPARAMS*		pParams,			//@parm INOUT | Parameter Array
	                            DBROWCOUNT*		pcRowsAffected,		//@parm OUT | count of rows affected by command
	                            IUnknown**		ppRowsets			//@parm OUT | Pointer to interface that was instantiated     
	                            )
{
	HRESULT				hr                  = S_OK;
	HRESULT				hrProp				= S_OK;
	DWORD				dwFlags				= 0;
	CRowset*			pCRowset			= NULL;
	DWORD				dwStatus			= 0;
	LPWSTR				pwstrWQL			= NULL;
	ULONG				cwchWQL				= 0;
	const IID*			pIID				= &IID_ICommand;
	CUtilProp*		    pRowsetProps		= NULL;
	CUtlParam			*pCUtlParam			= NULL;
	LONG				cCursorCount		= 0;

    //==========================================================================
	// Initialize Return Buffers
    //==========================================================================
	if ( ppRowsets )
	{
		*ppRowsets = NULL;
	}
	if ( pcRowsAffected )
	{
		*pcRowsAffected = NO_ROWCOUNT_TOTAL;
	}
	

    //==========================================================================
	// If the IID asked for is IID_NULL, then we can expect that this is a 
	// non-row returning statement
    //==========================================================================
	if (riid == IID_NULL)
	{
		dwFlags |= EXECUTE_NOROWSET;
	}
	
    //==========================================================================
	// Check to see if IID_IOpenRowset is calling Execute to open a rowset.
    //==========================================================================
	if (m_guidImpersonate != GUID_NULL)
	{
		pIID = &m_guidImpersonate;
	}
		 
    //==========================================================================
	// Check Arguments - Only check on row returning statements
    //==========================================================================
	if (!(dwFlags & EXECUTE_NOROWSET) && (ppRowsets == NULL))
	{
		hr = E_INVALIDARG;
//		return g_pCError->PostHResult((E_INVALIDARG), pIID);
	}
	else
    //==========================================================================
	// At least 1 ParamSet and pData is null
    //==========================================================================
	if (pParams && (pParams->cParamSets > 0) && (NULL == pParams->pData))
	{
		hr = E_INVALIDARG;
//		return g_pCError->PostHResult((E_INVALIDARG), pIID);
	}
	else
    //==========================================================================
	// Check that a command has been set
    //==========================================================================
	if(!(m_pQuery->GetStatus() & CMD_TEXT_SET))
	{
		hr = DB_E_NOCOMMAND;
//		return g_pCError->PostHResult((DB_E_NOCOMMAND), pIID);
	}
	else
    //==========================================================================
	// The outer object must explicitly ask for IUnknown
    //==========================================================================
	if (pUnkOuter != NULL && riid != IID_IUnknown)
	{
		hr = DB_E_NOAGGREGATION;
//		return g_pCError->PostHResult((DB_E_NOAGGREGATION), pIID);
	}
	else
	{
		//==========================================================================
		// If there are parameters
		//==========================================================================
		if (pParams){
    
			//======================================================================
			// Build the bind information
			//======================================================================
			pCUtlParam =  new CUtlParam;
			if (NULL == pCUtlParam){
				hr = E_OUTOFMEMORY;
//				hr = g_pCError->PostHResult((E_OUTOFMEMORY), pIID);
			}
			else
			{
				pCUtlParam->AddRef();
				hr = pCUtlParam->BuildBindInfo(this, pParams, pIID);
/*				if (SUCCEEDED(hr = pCUtlParam->BuildBindInfo(this, pParams, pIID)))
				{
					m_pQuery->SetType(METHOD_ROWSET);
				}

*/			}
		}

		if( SUCCEEDED(hr))
		{
			if (!(m_pQuery->GetStatus() & CMD_EXECUTED_ONCE)){
				//======================================================================
				// Set the parameter binding information for the statement
				//======================================================================
				if (pCUtlParam)
				{
					m_pQuery->SetBindInfo(pCUtlParam);
				}
			
				//======================================================================
				// If command not prepared, prepare it now
				//======================================================================
				m_pQuery->SetStatus(CMD_READY);
			}		

			//==========================================================================
			// For Row Returning statements, we need to make a copy of the 
			// command object's Property object to hand off to the Rowset Object
			//==========================================================================

			if ( !(dwFlags & EXECUTE_NOROWSET) ){


				pCRowset = new CRowset(pUnkOuter,m_pCDBSession);
				if (pCRowset == NULL){
					hr = E_OUTOFMEMORY;
//					hr = g_pCError->PostHResult((E_OUTOFMEMORY), pIID);
				}
				else
				{
					//=========================================================================
					// We need to take a reference count on the pCRowset Ptr so if a
					// called method calls Addref and then Release on this
					// pointer, we do not go back to zero and delete ourselve.			
					//=========================================================================
					pCRowset->AddRef();

					/*
					//=========================================================================
					// AddRef Session Object
					//=========================================================================
					if (m_pCDBSession)		
						m_pCDBSession->AddRef(); // AddRef is not required as the Rowset Constuctor
												 // does the AddRef on the passed session
					*/


					if (IID_ICommand == *pIID){

						//=====================================================================
						// AddRef ourself (as Parent)
						//=====================================================================
			//    		GetOuterUnknown()->AddRef();	
					}
					else{
						//=====================================================================
    					// AddRef Session Object (as Parent)
						//=====================================================================
						if (m_pCDBSession)	
						{
							m_pCDBSession->GetOuterUnknown()->AddRef();
						}
					}
					//=========================================================================
					// AddRef ourself (as Command)
					//=========================================================================
					//AddRef();		

					//=========================================================================
					// Do initialization.
					//=========================================================================
					ULONG  cPropSets = 0;
    				DBPROPSET*	prgPropertySets = NULL;
					DBPROPIDSET rgPropIDSet[2];
					DBPROPID	rgPropId[1];

					memset(rgPropIDSet,0,2 * sizeof(DBPROPIDSET));
					// Get the property DBPROP_WMIOLEDB_ISMETHOD
					rgPropId[0]							= DBPROP_WMIOLEDB_ISMETHOD;
    				rgPropIDSet[0].cPropertyIDs		= 1;
					rgPropIDSet[0].guidPropertySet	= DBPROPSET_WMIOLEDB_ROWSET;
					rgPropIDSet[0].rgPropertyIDs	= rgPropId;

					// if this property is true then set the command type to METHOD
					if(SUCCEEDED(hr = m_pUtilProps->GetProperties(PROPSET_COMMAND,1,rgPropIDSet, &cPropSets,&prgPropertySets)))
					{
						if(prgPropertySets->rgProperties->vValue.boolVal == VARIANT_TRUE)
						{
							m_pQuery->SetType(METHOD_ROWSET);
						}
						else
						{
							m_pQuery->SetType(COMMAND_ROWSET);
						}
					}

					hr = S_OK;

					//==========================================================================
					//  Free memory we allocated to by GetProperties
					//==========================================================================
					m_pUtilProps->m_PropMemMgr.FreeDBPROPSET( cPropSets, prgPropertySets);

					memset(rgPropIDSet,0,2 * sizeof(DBPROPIDSET));

					// NTRaid: 135246
					// Getting only the rowset properties
					rgPropIDSet[0].cPropertyIDs		= 0;
					rgPropIDSet[0].guidPropertySet	= DBPROPSET_ROWSET;
					rgPropIDSet[0].rgPropertyIDs	= NULL;

					rgPropIDSet[1].cPropertyIDs		= 0;
					rgPropIDSet[1].guidPropertySet	= DBPROPSET_WMIOLEDB_ROWSET;
					rgPropIDSet[1].rgPropertyIDs	= NULL;

					//=========================================================================
    				// Get the properties- get the rowset properties 
					//=========================================================================
					hr = m_pUtilProps->GetProperties(PROPSET_ROWSET,2,rgPropIDSet, &cPropSets,&prgPropertySets);
					if( hr == S_OK ){

    					hr = pCRowset->InitRowset(cPropSets, prgPropertySets,-1,m_pQuery , this );
	    				if ( FAILED(hr) ){
		    				g_pCError->PostHResult(hr, pIID);
							*ppRowsets = NULL;
						}

					}
					else{
	    				if ( FAILED(hr) ){
		    				g_pCError->PostHResult(hr, pIID);
							*ppRowsets = NULL;
						}
					}

					if (DB_S_ERRORSOCCURRED == hr){
						hrProp = DB_S_ERRORSOCCURRED;
					}

					//==========================================================================
					//  Free memory we allocated to by GetProperties
					//==========================================================================
					m_pUtilProps->m_PropMemMgr.FreeDBPROPSET( cPropSets, prgPropertySets);

					//=========================================================================
					// We are guaranteed to have handed off the pRowsetProps value, 
					// so set the NULL it flag
					//=========================================================================
					dwFlags |= EXECUTE_NULL_PROWSETPROPS;
				
				} // Else for failure of allocation of CRowset
			}
			else
			{
				// 07/12/2000
				// Modified after finding NTBug : 142348, debugging of which
				// revealed that nothing was being done if a query is to be
				// executed without requiring a resultant rowset
				// Just execute the query here, without worring about
				// building the resulting rowset
				hr = m_pCDBSession->ExecuteQuery(m_pQuery);
			}

			if (!FAILED(hr))
			{	
			
				//=========================================================================
				// We are guarunteed to have handed off the pRowsetProps value, so set 
				// the NULL it flag
				//=========================================================================
				dwFlags |= EXECUTE_NULL_PROWSETPROPS;

				// 07/12/2000
				// NTRaid : 142348
				// Query for the rowset only if any rowset is asked for
				if ( !(dwFlags & EXECUTE_NOROWSET) )
				{

					//=========================================================================
					// Get the requested interface
					//=========================================================================
					if ( FAILED(hr = pCRowset->QueryInterface( riid, (LPVOID*) ppRowsets)) ){
	//					g_pCError->PostHResult(hr, pIID);
					}
					else{
						//=====================================================================
						// If IID_NULL was specified, it is assumed that you
						// are not getting a rowset set back, but just in case
						// we'll close the statement handle
						//=====================================================================
						
					}
				}
			} // If(!Failed(hr))

		}	// if succeeded(hr) after BuildBindInfo()
	}
	if (pCRowset)
	{
		pCRowset->Release();
	}
	if (pCUtlParam)
	{
		pCUtlParam->Release();
	}

	hr = FAILED(hr) ? hr : hrProp;

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,pIID);
	return hr;

/*
EXIT_EXECUTE:
    //=========================================================================
	// It is possible that we have gotten to this point and have handled off
	// our pRowsetProps pointer to the rowset, but have no NULL'd the
	// pointer. NULL it if flag is on.
    //=========================================================================
	if (dwFlags & EXECUTE_NULL_PROWSETPROPS)
		pRowsetProps = NULL;

	if (pCRowset)
		pCRowset->Release();

	if (pCUtlParam){
		pCUtlParam->Release();
	}

	delete pRowsetProps;

	return hr;*/
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Function to get the DBPROP_WMIOLEDB_QUERYLANGUAGE property
// NTRaid 134165
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CCommand::GetQueryLanguage(VARIANT &varProp)
{
	HRESULT hr						= S_OK;
	ULONG		cPropertySets		= 0;	
	DBPROPSET*	prgPropertySets		= NULL;
	DBPROPIDSET	rgPropertyIDSets[1];
	DBPROPID	rgPropId[1];


	VariantClear(&varProp);

    //========================================================================
    // Get the value of the required rowset property
    //========================================================================
	rgPropertyIDSets[0].guidPropertySet	= DBPROPSET_WMIOLEDB_ROWSET;
	rgPropertyIDSets[0].rgPropertyIDs	= rgPropId;
	rgPropertyIDSets[0].cPropertyIDs	= 1;
	rgPropId[0]							= DBPROP_WMIOLEDB_QUERYLANGUAGE;

    if( S_OK == (hr = m_pUtilProps->GetProperties( PROPSET_COMMAND,	1, rgPropertyIDSets,&cPropertySets,	&prgPropertySets )))
		VariantCopy(&varProp,&prgPropertySets->rgProperties->vValue);

    //==========================================================================
	//  Free memory we allocated to by GetProperties
    //==========================================================================
	m_pUtilProps->m_PropMemMgr.FreeDBPROPSET( cPropertySets, prgPropertySets);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//***********************************************************************************************************
//
//  Class CQuery
//
//***********************************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CQuery::CQuery()
{
	m_prgbCallParams			= NULL;
	m_dwStatus					= 0;
	m_dwCancelStatus			= 0;
	m_prgProviderParamInfo		= NULL;
	m_pwstrWMIText				= NULL;
	m_pwstrQryLang				= NULL;

    //===============================================
	// Init critical section
    //===============================================
    m_pcsQuery = new CCriticalSection(TRUE);
    m_uRsType = COMMAND_ROWSET;     // By default, set it for commands, can reset it to methods when needed.
    m_pParamList = NULL;

}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CQuery::~CQuery()
{
    DeleteConsumerParamInfo();
    SAFE_DELETE_ARRAY( m_prgProviderParamInfo );
	SAFE_DELETE_ARRAY( m_prgbCallParams );
    SAFE_DELETE_PTR( m_pcsQuery );
	SAFE_DELETE_ARRAY( m_pwstrWMIText );
	SAFE_DELETE_ARRAY( m_pwstrQryLang );

}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Deletes the consumer specified parameter information.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQuery::DeleteConsumerParamInfo(void)
{
	ULONG iElem;

    if( m_pParamList ){
	    ULONG cElem = GetParamCount();
	    for (iElem = 0; iElem < cElem; iElem++)	{
		    PPARAMINFO pParamInfo;
		    pParamInfo = (PPARAMINFO) m_pParamList->GetAt(iElem);
		    delete pParamInfo;
	    }
        SAFE_DELETE_PTR(m_pParamList);
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Deletes the consumer specified parameter information.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CQuery::AddConsumerParamInfo(ULONG_PTR ulParams,PPARAMINFO pParamInfo)
{
    HRESULT hr = E_FAIL;

    if( !m_pParamList ){
        m_pParamList = new CFlexArray(PARAM_LIST_SIZE,50);
    }
    

    if( m_pParamList ){

        if( ulParams < PARAM_LIST_SIZE ){

            m_pParamList->InsertAt((int)ulParams,pParamInfo);
            hr = S_OK;
        }
        else{

            // There is a bug here with CFlexArray, when you add to it, it messes up the ordinal position
            // need to work with the owners of CFlexArray to fix this
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Gets the parameter information for a specific parameter.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
PPARAMINFO CQuery::GetParamInfo( ULONG iParams )
{
	PPARAMINFO pParamInfo = NULL;
    ULONG uSize = GetParamCount();
    if( uSize > 0 ){
	    if ( iParams <= uSize){

		    pParamInfo = (PPARAMINFO)m_pParamList->GetAt(iParams);
		    if (pParamInfo)
			    return pParamInfo;
	    }
	    pParamInfo = m_prgProviderParamInfo	? m_prgProviderParamInfo + iParams : NULL;
    }
	return pParamInfo;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CQuery::InitQuery(BSTR strQryLang)
{
	HRESULT hr = S_OK;

    if( m_pwstrWMIText ){
    	delete []m_pwstrWMIText;
    }
    m_pwstrWMIText = NULL;

	// NTRaid 135165
	hr = SetQueryLanguage(strQryLang);

    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CQuery::GetQuery(WCHAR *& wcsQuery)
{
    HRESULT hr = E_FAIL;
    //===============================================================================
	// Initialize output parameter
    //===============================================================================
	wcsQuery = NULL;
    //===============================================================================
	// Allocate memory for the string we're going to return to the caller
    //===============================================================================
	wcsQuery = (LPWSTR)g_pIMalloc->Alloc((wcslen(m_pwstrWMIText) + 1) * sizeof(WCHAR));
	if ( !wcsQuery ){
		hr = g_pCError->PostHResult((E_OUTOFMEMORY), &IID_ICommandText);
        hr = E_OUTOFMEMORY;
	}
    else{
	    wcscpy(wcsQuery, m_pwstrWMIText);
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CQuery::SetQuery(LPCOLESTR wcsQuery, GUID rguidDialect)
{
    HRESULT hr = E_FAIL;

	ULONG cwch = wcslen(wcsQuery);
	LPWSTR pwstr = new WCHAR[cwch+2];
	if (pwstr){

        //=================================================================
		// Save the text and dialect
        //=================================================================
		m_cwchWMIText = cwch;
		m_pwstrWMIText = pwstr;
		wcscpy(pwstr, wcsQuery);
		m_guidCmdDialect = rguidDialect;

        //=================================================================
		// Set status flag that we have set text
        //=================================================================
		m_dwStatus = CMD_TEXT_SET;

        //=================================================================
		// Count the number of parameters
		//pcmd->m_cParams = pcmd->CountParamMarkers(pwstr, cwch);
        //=================================================================
		hr = S_OK;
	}
	else{
		hr = g_pCError->PostHResult((E_OUTOFMEMORY),&IID_ICommandText);
	}
	
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CQuery::SetDefaultQuery()
{
	m_cwchWMIText = 0;
    InitQuery();
	m_guidCmdDialect = DBGUID_WQL;
    m_dwStatus &= ~CMD_TEXT_SET;

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CQuery::CancelQuery()
{
    return E_FAIL;
}

DBTYPE CQuery::GetParamType(DBORDINAL lOrdinal)
{
	PPARAMINFO param = NULL;

	param = (PPARAMINFO)m_pParamList->GetAt((int)lOrdinal);
	assert(param);
	
	return param->wOLEDBType;
}


////////////////////////////////////////////////////////////////////////
// set the query language
// NTRaid 135165
////////////////////////////////////////////////////////////////////////
HRESULT CQuery::SetQueryLanguage(BSTR strQryLang)
{
	HRESULT hr = S_OK;
	if(strQryLang)
	{
		SAFE_DELETE_ARRAY( m_pwstrQryLang );
		m_pwstrQryLang = new WCHAR[(SysStringLen(strQryLang) + 1) * sizeof(WCHAR)];
		if(m_pwstrQryLang)
		{
			wcscpy(m_pwstrQryLang,strQryLang);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	if(m_pwstrQryLang == NULL)
	{
		m_pwstrQryLang = new WCHAR[wcslen(DEFAULTQUERYLANG) + 1];
		if(m_pwstrQryLang)
		{
			wcscpy(m_pwstrQryLang,DEFAULTQUERYLANG);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\corepol.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    COREPOL.H

Abstract:

    declspec import/export helpers

History:

--*/

//#define TRACKING 

// If we are building a the  DLL then define the 
// class as exporteded otherwise its inmported
// ============================================
#ifndef COREPOL_HEADERFILE_IS_INCLUDED
#define COREPOL_HEADERFILE_IS_INCLUDED
//#pragma message( "Including COREPOL.H..." )


#ifdef USE_POLARITY
  #ifdef BUILDING_DLL
//   #pragma message( "Building static library or DLL..." )
   #define POLARITY __declspec( dllexport )
  #else 
//   #pragma message( "Building Provider..." )
   #define POLARITY __declspec( dllimport )
  #endif
 #else
  #define POLARITY
//  #pragma message( "NO Polarity...")
 #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\corex.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    COREX.H

Abstract:

    WMI Core Services Exceptions

History:

--*/

#ifndef __COREX_H_
#define __COREX_H_

class CX_Exception {};

class CX_MemoryException : CX_Exception {};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\colinfomgr.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// cRowColumnInfoMemMgr object implementation - implements column information
// 
//
///////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  cRowColumnInfoMemMgr class implementation
///////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
cRowColumnInfoMemMgr::cRowColumnInfoMemMgr(cRowColumnInfoMemMgr *pSrcRsColInfo)
{
    m_DBColInfoList     = NULL;
    m_rgdwDataOffsets   = NULL;
	m_rgCIMType			= NULL;
    m_dwOffset			= 0;
    m_cbTotalCols		= 0L;
    m_cbCurrentIndex	= 0L;
	m_lpCurrentName		= NULL;

    m_pbColumnNames = NULL;
    m_cbColumnInfoBytesUsed = 0L;
	m_nFirstIndex			= 0L;
	m_pSrcRsColInfo			= pSrcRsColInfo;
	
	if(m_pSrcRsColInfo != NULL)
	{
		m_nFirstIndex			= m_pSrcRsColInfo->m_cbTotalCols;
		m_cbCurrentIndex		= 0;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
cRowColumnInfoMemMgr::~cRowColumnInfoMemMgr()
{
    FreeColumnNameList();    
    FreeColumnInfoList();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Reallocate the column list
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::ReAllocColumnInfoList()
{
    HRESULT hr = S_OK;

    DBCOUNTITEM cNewCols = m_cbTotalCols + DEFAULT_COLUMNS_TO_ADD;
    DBCOUNTITEM cOldCols = m_cbTotalCols;
	DBCOUNTITEM cbColumnInfoBytesUsed = m_cbColumnInfoBytesUsed;

	// If there is a source rowset info then adjuct the column numbers and bytes 
	if(m_pSrcRsColInfo != NULL)
	{
		cOldCols = cOldCols - m_pSrcRsColInfo->m_cbTotalCols;
		cbColumnInfoBytesUsed = cbColumnInfoBytesUsed - m_pSrcRsColInfo->m_cbColumnInfoBytesUsed;
	}
    //==================================================
	// save the old buffer ptrs
    //==================================================
	DBCOLUMNINFO*	OldCol		= m_DBColInfoList;
	DBBYTEOFFSET*	OldOffset	= m_rgdwDataOffsets;	  
	DWORD*			OldCIMTypes = m_rgCIMType;

    hr = AllocColumnInfoList(cNewCols);
    if( S_OK == hr ){
        //==============================================
        // copy what we have so far
        //==============================================
        
		memcpy(m_DBColInfoList,OldCol,cbColumnInfoBytesUsed);
		memcpy(m_rgdwDataOffsets,OldOffset,cOldCols*sizeof(DBBYTEOFFSET));
		memcpy(m_rgCIMType,OldCIMTypes,cOldCols*(sizeof(ULONG)));

        SAFE_DELETE_ARRAY(OldCol);
        SAFE_DELETE_ARRAY(OldOffset);
        SAFE_DELETE_ARRAY(OldCIMTypes);
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the current column information
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
DBCOLUMNINFO ** cRowColumnInfoMemMgr::CurrentColInfo()
{
    return &m_pCurrentColInfo;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the column information of a particular column
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
DBCOLUMNINFO * cRowColumnInfoMemMgr::GetColInfo(DBORDINAL icol)
{
	if(m_pSrcRsColInfo != NULL && icol < m_nFirstIndex)
	{
		return &(m_pSrcRsColInfo->m_DBColInfoList[icol]); 
	}
	else
	{
		return &(m_DBColInfoList[icol-m_nFirstIndex]); 
	}

	return NULL;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Initialize the indexes and pointer to point to the first column
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::ResetColumns()
{
    //=================================================================
    //  Initialize ptr to beginning of DBCOLUMNINFO struct list,
    //  beginning with 1 ( 0 is a bookmark )
    //=================================================================
    m_dwOffset = offsetof( ROWBUFF, pdData );
    m_cbCurrentIndex = 1;
//    m_cbColumnInfoBytesUsed = 1;
    m_cbColumnInfoBytesUsed = sizeof(DBCOLUMNINFO);

	// if the columninfo has a parent rowset then there is no need of BOOKMARK column
	// as the current col info is just a extenstion of the source rowset and source rowset
	// will have the bookmark column
	if(m_pSrcRsColInfo != NULL)
	{
		m_nFirstIndex			= m_pSrcRsColInfo->m_cbTotalCols;
		m_cbCurrentIndex		= 0;
	}
	else
	{
		InitializeBookMarkColumn();
	}
    m_pCurrentColInfo = &m_DBColInfoList[m_cbCurrentIndex];
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Allocate memory for th columnlist for the given number of columns
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::AllocColumnInfoList(DBCOUNTITEM cCols)
{
    HRESULT hr = S_OK;

	DBCOUNTITEM nTotalColsToAlloc = 0;

	//====================================================================
	// Add an extra index, so we can be 1 based
	//====================================================================
	if(m_pSrcRsColInfo != NULL)
	{
		nTotalColsToAlloc = cCols - m_pSrcRsColInfo->m_cbTotalCols;
	}
	else
	{
		nTotalColsToAlloc = cCols;
	}
	m_cbTotalCols = cCols ;
	m_DBColInfoList		= new DBCOLUMNINFO[nTotalColsToAlloc];
	m_rgdwDataOffsets	= new DBBYTEOFFSET[nTotalColsToAlloc];
	m_rgCIMType			= new ULONG[nTotalColsToAlloc];

	//NTRaid:111761
	// 06/07/00
	if ( m_DBColInfoList == NULL || m_rgdwDataOffsets == NULL || m_rgCIMType == NULL ){
		hr = E_OUTOFMEMORY;
	}
	else
	{
		memset(m_DBColInfoList,0,nTotalColsToAlloc * sizeof(DBCOLUMNINFO));
		memset(m_rgdwDataOffsets,0,nTotalColsToAlloc * sizeof(DBBYTEOFFSET));
		memset(m_rgCIMType,0,nTotalColsToAlloc * sizeof(ULONG));

		//====================================================================
		//  Set all ptrs to the beginning
		//====================================================================
		ResetColumns();
	}

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to initialize the column info for the bookmark column
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::InitializeBookMarkColumn()
{
    HRESULT hr = S_OK;

	memset(&m_DBColInfoList[0],0,sizeof(DBCOLUMNINFO));
	m_DBColInfoList[0].iOrdinal		= 0;
	m_DBColInfoList[0].dwFlags		= DBCOLUMNFLAGS_ISBOOKMARK || DBCOLUMNFLAGS_MAYBENULL;
	m_DBColInfoList[0].ulColumnSize = BOOKMARKSIZE;
	m_DBColInfoList[0].wType		= DBTYPE_I4;
	m_DBColInfoList[0].columnid.eKind	= DBKIND_GUID_PROPID ;
	m_DBColInfoList[0].columnid.uGuid.guid	= DBCOL_SPECIALCOL; 
	m_DBColInfoList[0].columnid.uName.ulPropid = 3; // This should be more than 2 for bookmarks that are not self bookmark

    m_dwOffset = ROUND_UP( m_dwOffset, COLUMN_ALIGNVAL );
    m_rgdwDataOffsets[0] = m_dwOffset;
    m_dwOffset += offsetof( COLUMNDATA, pbData );

    return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Commit the column information and move to the next column
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::CommitColumnInfo()
{
	HRESULT hr = S_OK;
    //==============================================================
    // Set the offset from the start of the row, for this column, 
    // then advance past.
    //==============================================================
    if( m_cbCurrentIndex > m_cbTotalCols ){
        hr = ReAllocColumnInfoList();
    }
	// NTRaid:111762
	// 06/13/00
	if(SUCCEEDED(hr))
	{
		m_dwOffset = ROUND_UP( m_dwOffset, COLUMN_ALIGNVAL );
		m_rgdwDataOffsets[m_cbCurrentIndex] = m_dwOffset;
		m_dwOffset += offsetof( COLUMNDATA, pbData );
		
		m_pCurrentColInfo->columnid.eKind			= DBKIND_NAME;
		m_pCurrentColInfo->columnid.uName.pwszName	= m_pCurrentColInfo->pwszName;

		m_cbCurrentIndex++;
		m_cbColumnInfoBytesUsed += sizeof(*m_pCurrentColInfo);
		m_pCurrentColInfo = &m_DBColInfoList[m_cbCurrentIndex];
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Allocate memory for the Column Name list
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::AllocColumnNameList(DBCOUNTITEM nCols)
{
    HRESULT hr = E_UNEXPECTED;
	DBCOUNTITEM nTotalColsToAlloc = 0;

	// Adjust the number of colinfo to allocate , if there is a source rowset ( which is in case of row object
	// created from rowset)
	if(m_pSrcRsColInfo != NULL)
	{
		nTotalColsToAlloc = nCols - m_pSrcRsColInfo->m_cbTotalCols;
	}
	else
	{
		nTotalColsToAlloc = nCols;
	}

    if( !m_pbColumnNames  || m_pSrcRsColInfo != NULL){


        if( nCols > 0 ){


            //===================================================================================
            //  Allocate memory for the columns names.Commit it all, then de-commit and release
            //  once we know size.
            //===================================================================================
            DBCOUNTITEM nSize = nTotalColsToAlloc * COLUMNINFO_SIZE;

            m_pbColumnNames = (WCHAR *) VirtualAlloc( NULL, nSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );
            if (NULL == m_pbColumnNames){
                hr = E_OUTOFMEMORY;
            }
            else{
                //=================================================================
                // Initialize ptrs to the beginning of the column name buffer
                //=================================================================
                m_lpCurrentName  =  m_pbColumnNames;
                m_cbFreeColumnNameBytes = nSize;
                hr = S_OK;
            }
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Add a column name to the list of columns
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::AddColumnNameToList(WCHAR * pColumnName, DBCOLUMNINFO ** pCol)
{

    HRESULT hr = E_UNEXPECTED;

    //=================================================================
    //  initialize stuff
    //=================================================================
    int nLen = wcslen(pColumnName) * sizeof(WCHAR);
    (*pCol)->pwszName = NULL;

    if( nLen > 0 ){
        //=============================================================
        // Store the Column Name in the Heap, providing there is one
        //=============================================================
        if (!( (!m_cbFreeColumnNameBytes) || ( ((ULONG) nLen + 2 ) <= m_cbFreeColumnNameBytes ))){

            //=========================================================
            // Reallocate and copy what was there to new buffer
            //=========================================================
        }
        else{
            //=====================================================
            //  we have enough space, so
            //  Copy the name of the column to the memory and set
            //  a ptr to it in the DBCOLINFO struct
            //=====================================================
            memcpy( m_lpCurrentName, pColumnName, nLen);
            (*pCol)->pwszName = m_lpCurrentName;

            //=====================================================
            //  Increment the current ptr, add a NULL,and decrement
            //  free bytes
            //=====================================================
            m_lpCurrentName += wcslen(pColumnName);//nLen;
            m_cbFreeColumnNameBytes -= nLen;

            *m_lpCurrentName++ = NULL;
            m_cbFreeColumnNameBytes--;

            hr = S_OK;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the rows size
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG_PTR cRowColumnInfoMemMgr::SetRowSize()
{
	ULONG_PTR lRowSize = 0;
	// Adjust the rowsize , if there is a source rowset ( which is in case of row object
	// created from rowset)
    if (NULL != m_pSrcRsColInfo)
	{
		lRowSize = ROUND_UP( m_pSrcRsColInfo->m_dwOffset, COLUMN_ALIGNVAL );
	}

	lRowSize += ROUND_UP( m_dwOffset, COLUMN_ALIGNVAL );
    //=================================================================
    //  Set the row size 
    //=================================================================
//    return ( ROUND_UP( m_dwOffset, COLUMN_ALIGNVAL ));

	return lRowSize;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Free unused memory
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::FreeUnusedMemory()
{
    //==================================================================================
    // Decommit unused memory in our column-name buffer. We know it will never grow 
    // beyond what it is now. Decommit all pages past where we currently are.
    //==================================================================================

    LPVOID  pDiscardPage;
    DBLENGTH  ulSize;

    pDiscardPage = (LPVOID)ROUND_UP( m_lpCurrentName, g_dwPageSize );
    ulSize       = (ULONG)(MAX_HEAP_SIZE - ((BYTE *)pDiscardPage - (BYTE*) m_pbColumnNames));
    if (ulSize > 0){
        VirtualFree( pDiscardPage, ulSize, MEM_DECOMMIT );
    }

    //==================================================================================
    // We shouldn't generate a mem fault.
    //==================================================================================
    assert( '\0' == (*m_lpCurrentName = '\0'));  

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Free the columninfo list
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::FreeColumnInfoList()
{
    
	//===============================================================
    // Release buffer for column names 
	//===============================================================
    SAFE_DELETE_ARRAY( m_DBColInfoList );
    SAFE_DELETE_ARRAY( m_rgdwDataOffsets );
	SAFE_DELETE_ARRAY(m_rgCIMType);
    return S_OK;

}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// free the column name list
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::FreeColumnNameList()
{
    
	//===============================================================
    // Release buffer for column names 
	//===============================================================
    if (NULL != m_pbColumnNames){
        VirtualFree((VOID *) m_pbColumnNames, 0, MEM_RELEASE );
        m_pbColumnNames = NULL;
	}
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////////////////////////
// allocate a new colinfo and Copy column information 
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::CopyColumnInfoList(DBCOLUMNINFO *& pNew,BOOL bBookMark)
{
    HRESULT			hr						= E_OUTOFMEMORY;
	ULONG_PTR		nBytesToAlloc			= m_cbColumnInfoBytesUsed;
	DBCOLUMNINFO *	pTemp					= NULL;
	ULONG_PTR		cSourceBytesToBeCopied	= 0;

	//===================================================================================================================
	// Adjust the bytes to be allocated for column info , if there is a source rowset ( which is in case of row object
	// created from rowset)
	//===================================================================================================================
	if(m_pSrcRsColInfo != NULL)
	{
		pTemp					= m_pSrcRsColInfo->m_DBColInfoList;
		cSourceBytesToBeCopied	= m_pSrcRsColInfo->m_cbColumnInfoBytesUsed;

		nBytesToAlloc	+= cSourceBytesToBeCopied;

		//==============================================================
		// If there is no bookmarks required , then calculate
		// the bytes to be copied accordingly
		//==============================================================
		if( bBookMark == FALSE)
		{
			pTemp = pTemp++;
			cSourceBytesToBeCopied -= sizeof(DBCOLUMNINFO);
		}
	}

	if( bBookMark == FALSE)
	{
		nBytesToAlloc -= sizeof(DBCOLUMNINFO);
	}


	try
	{
		pNew = (DBCOLUMNINFO *)g_pIMalloc->Alloc( nBytesToAlloc );
	}
	catch(...)
	{
		if(pNew)
		{
			g_pIMalloc->Free(pNew);
		}
		throw;
	}
	if( pNew ){
		//===================================================================================================================
		// if there is a source rowset then copy the col info of the source rowset and then col info of the remaining
		// columns
		//===================================================================================================================
		if(m_pSrcRsColInfo != NULL)
		{
			memcpy(pNew,pTemp,cSourceBytesToBeCopied);
			memcpy(((BYTE *)pNew) + cSourceBytesToBeCopied,m_DBColInfoList,m_cbColumnInfoBytesUsed);				
		}
		else
		{
			if(bBookMark == TRUE)
			{
				memcpy(pNew,m_DBColInfoList,m_cbColumnInfoBytesUsed);
			}
			else
			{
				memcpy(pNew,&m_DBColInfoList[1],m_cbColumnInfoBytesUsed-sizeof(DBCOLUMNINFO));
			}
		}
		hr = S_OK;
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Copy column names to the buffer
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT cRowColumnInfoMemMgr::CopyColumnNamesList(WCHAR *& pNew)
{
    HRESULT hr = E_OUTOFMEMORY;
    DBLENGTH nBytesUsed = (ULONG)((m_lpCurrentName - m_pbColumnNames) * sizeof(WCHAR));
	DBLENGTH nBytesUsedBySrcRs = 0;
	WCHAR *pTemp = NULL;

	pTemp = m_pSrcRsColInfo != NULL ? m_pSrcRsColInfo->m_pbColumnNames : m_pbColumnNames;

	//===================================================================================================================
	// Adjust the bytes to be allocated for column names , if there is a source rowset ( which is in case of row object
	// created from rowset)
	//===================================================================================================================
	if(m_pSrcRsColInfo != NULL)
	{
		nBytesUsedBySrcRs = (m_pSrcRsColInfo->m_lpCurrentName - m_pSrcRsColInfo->m_pbColumnNames) * sizeof(WCHAR);
	}

	try
	{
		pNew = (WCHAR *)g_pIMalloc->Alloc( nBytesUsed + nBytesUsedBySrcRs);
	} // try
	catch(...)
	{
		if(pNew)
		{
			g_pIMalloc->Free(pNew);
		}

		throw;
	}
	if( pNew )
	{
		//===================================================================================================================
		// if there is a source rowset then copy the names of the source rowset and then the names of the remaining
		// columns
		//===================================================================================================================
		if(m_pSrcRsColInfo != NULL)
		{
			memcpy( pNew, pTemp, nBytesUsedBySrcRs);
			memcpy( ((BYTE *)pNew) + nBytesUsedBySrcRs, m_pbColumnNames, nBytesUsed);
		}
		else
		{
			memcpy( pNew, pTemp, nBytesUsed);
		}
		hr = S_OK;
	} 
	else
	{
		hr = E_OUTOFMEMORY;
	}
	

    return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
// Gives the ordinal of the column given the name of the column
/////////////////////////////////////////////////////////////////////////////////////////////////
DBORDINAL cRowColumnInfoMemMgr::GetColOrdinal(WCHAR *pColName)
{
	DBORDINAL	lOrdinal = -1;
	DBCOUNTITEM cCols	 = m_cbTotalCols;

	//===================================================================================================================
	// Adjust the ordinal fo the column , if there is a source rowset ( which is in case of row object
	// created from rowset)
	if(m_pSrcRsColInfo != NULL)
	{
		lOrdinal = m_pSrcRsColInfo->GetColOrdinal(pColName);
		cCols = m_cbTotalCols - m_pSrcRsColInfo->m_cbTotalCols;
	}

	// If ordinal is not found in the source rowset then search in the current col info
	if( (DB_LORDINAL)lOrdinal == -1)
	{
		for(DBORDINAL lIndex = 0 ; lIndex < cCols ; lIndex++)
		{
			if(m_DBColInfoList[lIndex].pwszName != NULL)
			if(0 == _wcsicmp(m_DBColInfoList[lIndex].pwszName,pColName))
			{
				lOrdinal = m_DBColInfoList[lIndex].iOrdinal;
				break;
			}
		}
	}

	return lOrdinal;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Gives the column type of the column
/////////////////////////////////////////////////////////////////////////////////////////////////
DBTYPE  cRowColumnInfoMemMgr::ColumnType(DBORDINAL icol)   
{ 
	if(m_pSrcRsColInfo != NULL && icol < m_nFirstIndex)
	{
		return m_pSrcRsColInfo->m_DBColInfoList[icol].wType; 
	}
	else
	{
		return m_DBColInfoList[icol-m_nFirstIndex].wType; 
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Gives the name of the columns
/////////////////////////////////////////////////////////////////////////////////////////////////
WCHAR * cRowColumnInfoMemMgr::ColumnName(DBORDINAL icol)
{ 
	if(m_pSrcRsColInfo != NULL && icol < m_nFirstIndex)
	{
		return m_pSrcRsColInfo->m_DBColInfoList[icol].pwszName; 
	}
	else
	{
		return m_DBColInfoList[icol-m_nFirstIndex].pwszName; 
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Gives the column flags of a particular column
/////////////////////////////////////////////////////////////////////////////////////////////////
DBCOLUMNFLAGS cRowColumnInfoMemMgr::ColumnFlags(DBORDINAL icol)
{ 
	if(m_pSrcRsColInfo != NULL && icol < m_nFirstIndex)
	{
		return m_pSrcRsColInfo->m_DBColInfoList[icol].dwFlags; 
	}
	else
	{
		return m_DBColInfoList[icol-m_nFirstIndex].dwFlags; 
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Get the offset of a particular columns
/////////////////////////////////////////////////////////////////////////////////////////////////
DBBYTEOFFSET   cRowColumnInfoMemMgr::GetDataOffset(DBORDINAL icol)
{ 
	if(m_pSrcRsColInfo != NULL && icol < m_nFirstIndex)
	{
		return m_pSrcRsColInfo->m_rgdwDataOffsets[icol]; 
	}
	else
	{
		return m_rgdwDataOffsets[icol-m_nFirstIndex]; 
	}
}



/////////////////////////////////////////////////////////////////////////////////////////////////
// Get the total number of columns in the col info manager for a particula row/rowset
/////////////////////////////////////////////////////////////////////////////////////////////////
DBCOUNTITEM cRowColumnInfoMemMgr::GetTotalNumberOfColumns()
{
	DBCOUNTITEM cColumns = m_cbTotalCols;
		
	if(m_pSrcRsColInfo != NULL)
	{
		cColumns += m_pSrcRsColInfo->m_cbTotalCols;
	}

	return m_cbTotalCols;

}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Get the number of columns in the sources rowset
/////////////////////////////////////////////////////////////////////////////////////////////////
DBCOUNTITEM cRowColumnInfoMemMgr::GetNumberOfColumnsInSourceRowset()
{
	DBCOUNTITEM cColumns = 0;
		
	if(m_pSrcRsColInfo != NULL)
	{
		cColumns = m_pSrcRsColInfo->m_cbTotalCols;
	}
	return cColumns;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Set the CIMTYPE of the column
//  IF index is -1 then set the CIMTYPE of the current col
/////////////////////////////////////////////////////////////////////////////////////////////////
void cRowColumnInfoMemMgr::SetCIMType(ULONG dwCIMType,DBORDINAL lIndex)
{
	if((DB_LORDINAL)lIndex == -1)
	{
		lIndex = m_cbCurrentIndex;
	}
	if(m_pSrcRsColInfo != NULL && lIndex < m_nFirstIndex)
	{
		m_rgCIMType[lIndex] = dwCIMType;
	}
	else
	{
		m_rgCIMType[lIndex-m_nFirstIndex] = dwCIMType;
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Get the CIMTYPE of the column
/////////////////////////////////////////////////////////////////////////////////////////////////
LONG cRowColumnInfoMemMgr::GetCIMType(DBORDINAL icol)
{
	LONG lRet = -1;
	
	if(m_pSrcRsColInfo != NULL && icol < m_nFirstIndex)
	{
		lRet =  m_rgCIMType[icol]; 
	}
	else
	{
		lRet = m_rgCIMType[icol-m_nFirstIndex]; 
	}
	return lRet;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// get the number of bytes copied for source rowset
/////////////////////////////////////////////////////////////////////////////////////////////////
DBLENGTH cRowColumnInfoMemMgr::GetCountOfBytesCopiedForSrcRs()   
{
	DBLENGTH nBytesUsedBySrcRs = 0;
	//===================================================================================================================
	// Adjust the bytes to be allocated for column names , if there is a source rowset ( which is in case of row object
	// created from rowset)
	//===================================================================================================================
	if(m_pSrcRsColInfo != NULL)
	{
		nBytesUsedBySrcRs = (m_pSrcRsColInfo->m_lpCurrentName - m_pSrcRsColInfo->m_pbColumnNames) * sizeof(WCHAR);
	}
	else
	{
		nBytesUsedBySrcRs = 0;
	}

	return nBytesUsedBySrcRs;

}


/////////////////////////////////////////////////////////////////////////////////////////////////
// get the pointer to starting point of the column names
/////////////////////////////////////////////////////////////////////////////////////////////////
WCHAR *	cRowColumnInfoMemMgr::ColumnNameListStartingPoint()   
{ 
	return m_pbColumnNames; 
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// get the current index 
/////////////////////////////////////////////////////////////////////////////////////////////////
DBORDINAL cRowColumnInfoMemMgr::GetCurrentIndex()
{ 
	return (m_cbCurrentIndex + m_nFirstIndex); 
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// get the pointer to starting point of the column names for the source rowset
/////////////////////////////////////////////////////////////////////////////////////////////////
WCHAR * cRowColumnInfoMemMgr::ColumnNameListStartingPointOfSrcRs()   
{
	WCHAR *pwszRet = NULL;

	if(m_pSrcRsColInfo != NULL)
	{
		pwszRet =  m_pSrcRsColInfo->m_pbColumnNames; 
	}

	return pwszRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\command.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Command base Routines
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef __COMMAND_H__
#define __COMMAND_H__

#include "errinf.h"
#include "utlparam.h"
#include "utilprop.h"

class CCommand;
class CImpIAccessor;
class CColInfo;
class CImpIColumnsInfoCmd;

typedef CCommand*					PCCOMMAND;
typedef CImpIConvertType*			PIMPICONVERTTYPE;
typedef CImpIColumnsInfoCmd*		PIMPCOLINFOCMD;


////////////////////////////////////////////////////////////////////////////////////////////////////////
// For CCommand::m_dwStatus
// These are bit masks.
////////////////////////////////////////////////////////////////////////////////////////////////////////
enum COMMAND_STATUS_FLAG {
	// Command Object status flags
	CMD_TEXT_SET			= 0x00000001,	//  Set when the command is set
	CMD_READY      			= 0x00000002,	//
	CMD_EXECUTED_ONCE  		= 0x00000004,	// Set when the command has changed.
	CMD_TEXT_PARSED			= 0X00000008,	// Set if text has been parsed
	CMD_PARAMS_USED			= 0x00000010,	// command uses parameters
	CMD_HAVE_COLUMNINFO     = 0x00000020,
    CMD_EXEC_CANCELED       = 0x00000040,	
	CMD_EXEC_CANCELED_BEFORE_CQUERY_SET	= 0x00000080,	
/*	                		= 0x00000100,
	                    	= 0x00000200,	
	                        = 0x00000400,
			                = 0x00000800,
	                    	= 0x00001000,
	                		= 0x00002000,
			                = 0x00004000,
	                		= 0x00008000,
	                		= 0x00010000,
	                		= 0x00020000,
			                = 0x10000000,
	                        = 0x20000000,*/
};
////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constant values for dwFlags on ICommand::Execute
////////////////////////////////////////////////////////////////////////////////////////////////////////
const DWORD EXECUTE_NOROWSET			= 0x00000001;
const DWORD EXECUTE_SUCCESSWITHINFO		= 0x00000002;
const DWORD EXECUTE_NEWSTMT				= 0x00000004;
const DWORD EXECUTE_NONROWRETURNING		= 0x00000008;
const DWORD EXECUTE_RESTART				= 0x00000010;
const DWORD EXECUTE_MULTIPLERESULTS		= 0x00000020;
const DWORD EXECUTE_NULL_PROWSETPROPS	= 0x00000040;
const DWORD EXECUTE_ERROR				= 0x00000080;

////////////////////////////////////////////////////////////////////////////////////////////////////////
// Used in escape code processing
////////////////////////////////////////////////////////////////////////////////////////////////////////
const WCHAR x_wchSTX = L'\02';
const WCHAR x_wchETX = L'\03';

////////////////////////////////////////////////////////////////////////////////////////////////////////
// CCommand::m_prgbCallParams constants
////////////////////////////////////////////////////////////////////////////////////////////////////////
enum 
	{
	CALL_NULL = 0,
	CALL_PARAM,
	CALL_RETURNSTATUS
	};

////////////////////////////////////////////////////////////////////////////////////////////////////////
// Defines for UnprepareHelper
////////////////////////////////////////////////////////////////////////////////////////////////////////
enum 
	{
	UNPREPARE_RESET_STMT, 
	UNPREPARE_RESET_CMD, 
	UNPREPARE_NEW_CMD
	};

////////////////////////////////////////////////////////////////////////////////////////////////////////
struct PARAMTYPE
	{
	PWSTR		pwszName;	// Type Name
	WORD		wWMIType;	// Default WMI Server Type for above name
	WORD		wDBType;	// Default OLE DB type for above name
	LONG		cbLength;	// length of WMI Server Type
	};

////////////////////////////////////////////////////////////////////////////////////////////////////////
class CQuery
{
    private:

    	DWORD			m_dwStatus;			// Execution Status Flags
    	DWORD			m_dwCancelStatus;	// Cancel status flags
	    LPWSTR			m_pwstrWMIText;		        // current WMI text, if any
	    ULONG			m_cwchWMIText;		        // length of current WMI text
	    GUID			m_guidCmdDialect;	// GUID for dialect of current text or tree
        unsigned int    m_uRsType;
	    CFlexArray *    m_pParamList;    // Consumer provided param info
		CUtlParam*		m_pCUtlParam;
		LPWSTR			m_pwstrQryLang;


    public:

        CQuery ();
        ~CQuery();

   	    CCriticalSection *m_pcsQuery;		//Critical Section for Query

        HRESULT InitQuery(BSTR strQryLang = NULL);
        HRESULT SetQuery(LPCOLESTR wcsQuery, GUID rguidDialect);
        HRESULT SetDefaultQuery();
        HRESULT GetQuery(WCHAR *& wcsQuery);
        LPWSTR  GetQuery()                      { return m_pwstrWMIText; }
        LPWSTR  GetQueryLang()                      { return m_pwstrQryLang; }
        HRESULT CancelQuery();
        HRESULT AddConsumerParamInfo(ULONG_PTR ulParams,PPARAMINFO pParamInfo);

        inline DWORD GetStatus()        		{ return m_dwStatus; 	}
	    inline DWORD GetStatus(DWORD dw) 		{ return (m_dwStatus & dw); 	}
        inline void SetStatus(DWORD dw)         { m_dwStatus |= dw;	}
        inline void InitStatus(DWORD dw)  		{ m_dwStatus = dw; 	}
        inline void ClearStatus(DWORD dw)       { m_dwStatus &= ~dw;	}

        inline GUID GetDialectGuid()            { return m_guidCmdDialect; }

        inline DWORD GetCancelStatus()          { return m_dwCancelStatus;}
        inline void SetCancelStatus(DWORD dw)   { m_dwCancelStatus |= dw;	}
        inline void ClearCancelStatus(DWORD dw) { m_dwCancelStatus &= ~dw;	}

        inline BOOL FIsEmpty() const    		{ return (m_cwchWMIText == 0); 		}
        inline BYTE* RgbCallParams() const  	{ return m_prgbCallParams;}
 	    inline BOOL FAreParametersUsed() 		{ return !!(m_dwStatus & CMD_PARAMS_USED); };
    	inline void SetProviderParamInfo(PPARAMINFO prgParamInfo){	m_prgProviderParamInfo = prgParamInfo;	}
		void	DeleteConsumerParamInfo(void);
		HRESULT SetQueryLanguage(BSTR strQryLang);
        PPARAMINFO GetParamInfo(ULONG iParams);
	    
        inline void SetBindInfo(CUtlParam* pCUtlParam){
        	pCUtlParam->AddRef();
	        m_pCUtlParam = pCUtlParam;
	    }

        PPARAMINFO      m_prgProviderParamInfo;
	    BYTE*			m_prgbCallParams;	        // information about param markes
										            // in {call..} statements

        inline PPARAMINFO GetParam(ULONG u )    
		{ 
			if(m_pParamList != NULL)
				return (PPARAMINFO) m_pParamList->GetAt(u); 
			else
				return NULL;
		}

   	    inline ULONG GetParamCount() const		
		{ 
			if( m_pParamList ) 
				return m_pParamList->Size(); 
            return 0; 
        }
        inline void RemoveParam(ULONG_PTR u)        
		{ 
			if( m_pParamList )
				m_pParamList->RemoveAt((int)u);   
		}
        inline unsigned int GetType()           { return m_uRsType;}
        inline void SetType(unsigned int x)          { m_uRsType = x; }
		DBTYPE GetParamType(DBORDINAL lOrdinal);

};
////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpICommandText : public ICommandText		
{
    private: 
	    PCCOMMAND		m_pcmd;
	    DEBUGCODE(ULONG           m_cRef);


    public: 
    	CImpICommandText(PCCOMMAND pcmd)	
        {
		    m_pcmd = pcmd;
            DEBUGCODE(m_cRef = 0);
		}
	
	    ~CImpICommandText()	{}

	    STDMETHODIMP_(ULONG) AddRef(void);
	    STDMETHODIMP_(ULONG) Release(void);
		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP Cancel();
	    STDMETHODIMP Execute(	IUnknown*	pUnkOuter, 	REFIID		riid, 	DBPARAMS*	pParams, 	DBROWCOUNT*		pcRowsAffected, 	IUnknown**	ppRowset		);
	    STDMETHODIMP GetDBSession(REFIID riid, IUnknown** ppSession);

        STDMETHODIMP GetCommandText(GUID* pguidDialect, LPOLESTR* ppwszCommand);
	    STDMETHODIMP SetCommandText(REFGUID rguidDialect, LPCOLESTR pwszCommand);
};
typedef CImpICommandText*			PIMPICOMMANDTEXT;

////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpICommandWithParameters : public ICommandWithParameters	
{
    private: 
	    DEBUGCODE(ULONG           m_cRef);
	    PCCOMMAND		m_pcmd;

    public: 
	    CImpICommandWithParameters(PCCOMMAND pcmd){	DEBUGCODE(m_cRef = 0L);	m_pcmd = pcmd;	}
	    ~CImpICommandWithParameters()	{}
    
	    STDMETHODIMP_(ULONG) AddRef(void);
	    STDMETHODIMP_(ULONG) Release(void);
		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);

        STDMETHODIMP GetParameterInfo(	DB_UPARAMS* pcParams,    DBPARAMINFO**	prgParamInfo, 	OLECHAR** ppNamesBuffer		);
    	STDMETHODIMP MapParameterNames(	DB_UPARAMS cParamNames, 	const OLECHAR*	rgParamNames[],	DB_LPARAMS rgParamOrdinals[]	);
    	STDMETHODIMP SetParameterInfo(	DB_UPARAMS cParams, 	    const DB_UPARAMS	rgParamOrdinals[],	const DBPARAMBINDINFO rgParamBindInfo[]	);
};	

typedef CImpICommandWithParameters*	PIMPICOMMANDWITHPARAMETERS;

////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpICommandProperties : public ICommandProperties	
{
    private: 
    	DEBUGCODE(ULONG       m_cRef);
	    PCCOMMAND	m_pcmd;

    public: 

    	CImpICommandProperties(PCCOMMAND pcmd){	DEBUGCODE(m_cRef = 0L);	m_pcmd = pcmd;	}
    	~CImpICommandProperties()	{}

	    STDMETHODIMP_(ULONG) AddRef(void);
	    STDMETHODIMP_(ULONG) Release(void);
		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
		
    	STDMETHODIMP GetProperties(	const ULONG	cPropertySets, 
		                            const DBPROPIDSET	rgPropertySets[], 
		                            ULONG*				pcProperties, 
		                            DBPROPSET**			prgProperties
		                            );
        STDMETHODIMP SetProperties(	ULONG cProperties, 	DBPROPSET	rgProperties[]	);
};

typedef CImpICommandProperties*		PIMPICOMMANDPROPERTIES;

////////////////////////////////////////////////////////////////////////////////////////////////////////
class CCommand : public CBaseObj
{
	//	Contained interfaces are friends
	friend class CImpIAccessor;
	friend class CImpICommandText;
	friend class CImpICommandWithParameters;
	friend class CImpICommandProperties;
	friend class CImpIColumnsInfo;
	friend class CImpIConvertType;
	friend class CImpIPersistFile;
	friend class CImpISupportErrorInfo;
	friend class CTableDefinition;
	friend class CIndexDefinition;
	friend class CImpIColumnsInfoCmd;

    protected: 
    	CImpIAccessor				*m_pIAccessor;
    	CImpICommandText			*m_pICommandText;
	    CImpICommandWithParameters	*m_pICommandWithParameters;	
    	CImpICommandProperties		*m_pICommandProperties;
    	CImpIColumnsInfoCmd			*m_pIColumnsInfo;			
    	CImpIConvertType			*m_pIConvertType;
    	CImpISupportErrorInfo		*m_pISupportErrorInfo;


      	LPBITARRAY	m_pbitarrayParams;			//@cmember bit array to mark referenced params


    	CDBSession*		m_pCDBSession;		//Parent Session Object
    	CUtilProp *  	m_pUtilProps;		//Rowset Properties
    	CError		    m_CError;		    //Error data object
    	CQuery*			m_pQuery;			//Statement object

    	ULONG			m_cRowsetsOpen;		//Count of Active Rowsets on this command object

	    GUID			m_guidImpersonate;	// Impersonation GUID
//	    DBCOLUMNINFO	m_CRowMetadata;		// metadata for first statement in the command
	    CExtBuffer		m_extNamePool;		// name pool for row metadata
	    DWORD			m_dwStatusPrep;			// rowset status for prepared command

		cRowColumnInfoMemMgr *	m_pColumns;
		DBCOUNTITEM				m_cTotalCols;			// Total number of columns
		DBCOUNTITEM				m_cCols;			    // Count of Parent Columns in Result Set
		DBCOUNTITEM				m_cNestedCols;          // Number of child rowsets ( chaptered columns)

		HRESULT AddInterfacesForISupportErrorInfo();

    public:
        CCommand(CDBSession* pCSession, LPUNKNOWN pUnkOuter);
    	~CCommand();

        inline CImpIAccessor * GetIAccessorPtr() { return m_pIAccessor; }
    	HRESULT FInit(CCommand* pCloneCmd, const IID* piid);
	    HRESULT FInit(WORD wRowsetProps = 0);

    	STDMETHODIMP			QueryInterface(REFIID, LPVOID *);
    	STDMETHODIMP_(ULONG)	AddRef(void);
    	STDMETHODIMP_(ULONG)	Release(void);

    	virtual HRESULT ReExecute(CRowset* pCRowset,LONG* pcCursorRows,	WORD* pcCols );

    	inline HRESULT CheckCanceledHelper(CQuery* pstmt);
    	inline CDBSession* GetSessionObject()   { return m_pCDBSession; };
    	inline CQuery* GetStmt()                 { return m_pQuery; }
        inline CError* GetErrorData()           { return &m_CError;	}
//	    inline CUtilProps* GetRowsetProps() 	{ return &m_CUtilProps;}
		inline void DecrementOpenRowsets()  	{ if(m_cRowsetsOpen > 0) {InterlockedDecrement( (LONG*) &m_cRowsetsOpen );	assert( m_cRowsetsOpen != ULONG(-1) );} 	}
        inline void IncrementOpenRowsets()		{ InterlockedIncrement( (LONG*) &m_cRowsetsOpen );	}
	    inline BOOL IsRowsetOpen()      		{ return (m_cRowsetsOpen > 0) ? TRUE : FALSE; 		};


    	HRESULT GetColumnInfo(  const IID*	piid, DBCOLUMNINFO	*pDBCOLUMNINFO,	// OUT | pointer to the row metadata
		                        CExtBuffer		**ppextBuffer		// OUT | pointer to the name pool
		                        );
    	void SetColumnInfo(		DBCOLUMNINFO	*DBCOLUMNINFO,	// IN | pointer to the row metadata
		                        CExtBuffer *	pextBuffer);		// IN | pointer to the name pool

    	STDMETHODIMP MapParameterNames(	DB_UPARAMS cPNames, const OLECHAR* rgPNames[], DB_LPARAMS rgPOrdinals[], const IID* piid );
    	STDMETHODIMP Execute( IUnknown* pUnkOuter, REFIID riid, DBPARAMS* pParams, DBROWCOUNT* pcRowsAffected, IUnknown** ppRowsets );
    	STDMETHODIMP ExecuteWithParameters(	DBPARAMS		*pParams, DWORD *dwFlags, const IID *piid );
    	STDMETHODIMP OpenRowset( IUnknown*	pUnkOuter, DBID* pTableID, REFIID riid, ULONG cPropertySets, DBPROPSET rgPropertySets[], IUnknown** ppRowset);
    	STDMETHODIMP UnprepareHelper(DWORD dwUnprepareType);
	    STDMETHODIMP PostExecuteErrors(	CErrorData*	pErrorData,	const IID*  piid );
	    STDMETHODIMP PostExecuteWarnings( CErrorData* pErrorData, const IID*  piid	);
	   	STDMETHODIMP GetParamInfo( const IID *piid	);
        PPARAMINFO   GetParamInfo( ULONG i)         { return m_pQuery->GetParamInfo(i);}

        HRESULT GetParameterInfo(	DB_UPARAMS* pcParams, DBPARAMINFO** 	prgDBParamInfo,	WCHAR**	ppNamesBuffer, const IID* piid );
	    HRESULT SetParameterInfo( DB_UPARAMS cParams, const DB_UPARAMS rgParamOrdinals[],	const DBPARAMBINDINFO	rgParamBindInfo[] );

		BOOL FHaveBookmarks();
        ULONG GetParamCount()               { return m_pQuery->GetParamCount();}
		DBTYPE GetParamType(DBORDINAL lOrdinal)	{ return m_pQuery->GetParamType(lOrdinal); }
		HRESULT GetQueryLanguage(VARIANT &varProp);
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIColumnsInfoCmd : public IColumnsInfo 		
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
		PCCOMMAND	m_pcmd;											

		HRESULT GetColInfo(DBORDINAL* pcColumns, DBCOLUMNINFO** prgInfo,WCHAR** ppStringsBuffer);
		HRESULT GatherColumnInfo();
	public: 

    	CImpIColumnsInfoCmd(PCCOMMAND pcmd)
		{
	    	DEBUGCODE(m_cRef = 0L);
		    m_pcmd		= pcmd;
		}

		~CImpIColumnsInfoCmd()												
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));	
           	return m_pcmd->GetOuterUnknown()->AddRef();
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
        	return m_pcmd->GetOuterUnknown()->Release();

		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pcmd->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

	    STDMETHODIMP	GetColumnInfo(DBORDINAL* pcColumns, DBCOLUMNINFO** prgInfo, OLECHAR** ppStringsBuffer);
		STDMETHODIMP	MapColumnIDs(DBORDINAL, const DBID[], DBORDINAL[]);
};

#endif	// __COMMAND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\crtsess.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// IDBCreateSession interface implementation
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Creates a new DB Session object from the DSO, and returns the requested interface on the newly 
// created object.
//
// HRESULT
//      S_OK                   The method succeeded.
//      E_INVALIDARG           ppDBSession was NULL
//      DB_E_NOAGGREGATION     pUnkOuter was not NULL (this object does not support being aggregated)
//      E_FAIL                 Provider-specific error. This provider can only create one DBSession
//      E_OUTOFMEMORY          Out of memory
//      E_NOINTERFACE          Could not obtain requested interface on DBSession object
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBCreateSession::CreateSession( 
								IUnknown*   pUnkOuter,  //IN  Controlling IUnknown if being aggregated 
								REFIID      riid,       //IN  The ID of the interface 
								IUnknown**  ppDBSession //OUT A pointer to memory in which to return the interface pointer
    )
{
    CDBSession* pDBSession = NULL;
    HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//================================
	// Serialize the object
	//================================
	CAutoBlock	cab(DATASOURCE->GetCriticalSection());

	//=========================================================================
    // check in-params and NULL out-params in case of error
	//=========================================================================
    if (ppDBSession){
        *ppDBSession = NULL;
	}
    else{
        hr = E_INVALIDARG;
	}
    assert( m_pObj );

	//=========================================================================
	// Check to see if the DSO is Uninitialized
	//=========================================================================
	if( hr == S_OK ){
		if (!m_pObj->m_fDSOInitialized){
			hr = E_UNEXPECTED;
		}
		else{

			//=================================================================
			// this Data Source object can only create 1 DBSession...
			//=================================================================
			if (m_pObj->m_fDBSessionCreated){
				hr =  DB_E_OBJECTCREATIONLIMITREACHED;
			}
			else{

				//=============================================================
				// We do not allow the riid to be anything other than 
				// IID_IUnknown for aggregation
				//=============================================================
				if ( (pUnkOuter) && (riid != IID_IUnknown) ){
					hr = DB_E_NOAGGREGATION;
				}
				else{

					hr = m_pObj->CreateSession(pUnkOuter,riid,ppDBSession);
/*
					try
					{
						//=========================================================
						// open a DBSession object
						//=========================================================
						pDBSession = new CDBSession( pUnkOuter );
					}
					catch(...)
					{
						SAFE_DELETE_PTR(pDBSession);
						throw;
					}

					if (!pDBSession){
						hr = E_OUTOFMEMORY;
					}
					else{

						//=====================================================
						// initialize the object
						//=====================================================
						if (FAILED(hr = pDBSession->FInit( m_pObj ))){
							SAFE_DELETE_PTR( pDBSession );
						}
						else{
							//=================================================
							// get requested interface pointer on DBSession
							//=================================================
							hr = pDBSession->QueryInterface( riid, (void **) ppDBSession );
							if (FAILED( hr )){
								SAFE_DELETE_PTR( pDBSession );
							}
							else{
								//=============================================
								// all went well
								//=============================================
								m_pObj->m_fDBSessionCreated = TRUE;
							}
						}
					}

					*/
				}
			}
		}
	}

	CATCH_BLOCK_HRESULT(hr,L"IDBCreateSession::CreateSession");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\critsec.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Generic critical section handling classes
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef __CRITSEC_H_
#define __CRITSEC_H_

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The constructor/destructor automatically initializes/deletes the CRITIICAL_SECTION correctly, to ensure 
// that each call is correctly paired, IF the fAutoInit is set to TRUE, otherwise, you have to manually deal
// with this - this is implemented for the static global CS that is required.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CCriticalSection 
{
    public:		

	    inline CCriticalSection(BOOL fAutoInit);		// CTOR. 
	    inline ~CCriticalSection();		                // DTOR.
	    inline void Enter();			                // Enter the critical section
	    inline void Leave();			                // Leave the critical section
//	    inline DWORD OwningThreadId();	                // Returns the "owning" thread id
        inline void Init(void);
        inline void Delete(void);

    private:

        BOOL                m_fAutoInit;
	    CRITICAL_SECTION	m_criticalsection;			// standby critical section
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline CCriticalSection::CCriticalSection(BOOL fAutoInit)
{
    m_fAutoInit = fAutoInit;
    if( m_fAutoInit ){
	    Init();
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void CCriticalSection::Init(void)
{
    InitializeCriticalSection(&m_criticalsection);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void CCriticalSection::Delete(void)
{
	DeleteCriticalSection(&m_criticalsection);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline CCriticalSection::~CCriticalSection()
{
    if( m_fAutoInit ){
        Delete();
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void CCriticalSection::Enter(void)
{
	EnterCriticalSection(&m_criticalsection);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void CCriticalSection::Leave(void)
{
	LeaveCriticalSection(&m_criticalsection);
}
/*
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline DWORD CCriticalSection::OwningThreadId(void)
{
	return DWORD(m_criticalsection.OwningThread);
}

*/
#endif // __CRITSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\cvttype.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CImpIConvertType implementation
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIConvertType::CanConvert
//
// Used by consumer to determine provider support for a conversion
//
// HRESULT indicating the status of the method
//
//		S_OK					Conversion supported
//		S_FALSE					Conversion unsupported
//		DB_E_BADCONVERTFLAG		dwConvertFlags was invalid
//		DB_E_BADCONVERTFLAG		called on rowset for DBCONVERTFLAG_PARAMETER 
//      OTHER					HRESULTS returned from support functions
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIConvertType::CanConvert(	DBTYPE			wFromType,		//IN  src type
											DBTYPE			wToType,		//IN  dst type
											DBCONVERTFLAGS	dwConvertFlags	//IN  conversion flags
										 )
{
	HRESULT hr = S_OK;
	DWORD dwFlags = dwConvertFlags & ~(DBCONVERTFLAGS_ISLONG | DBCONVERTFLAGS_ISFIXEDLENGTH | 	DBCONVERTFLAGS_FROMVARIANT);
	//=======================================================================================
	//
	// Check Arguments 
	// The flags should be column if this is on rowset and should be Parameter if on command
	//
	//=======================================================================================
	if (!((dwFlags == DBCONVERTFLAGS_COLUMN  && BOT_ROWSET == m_pObj->GetBaseObjectType()) ||
		(dwFlags == DBCONVERTFLAGS_PARAMETER && BOT_COMMAND == m_pObj->GetBaseObjectType()))){
		hr = DB_E_BADCONVERTFLAG;
	}
	else{
		//=======================================================================================
		//
		// Make sure that we check that the type is a variant if they say so
		//
		//=======================================================================================
		if (dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT){
			DBTYPE	wVtType = wFromType & VT_TYPEMASK;

			//===================================================================================
			// Take out all of the Valid VT_TYPES (36 is VT_RECORD in VC 6)
			//===================================================================================
			if ((wVtType > VT_DECIMAL && wVtType < VT_I1) ||((wVtType > VT_LPWSTR && wVtType < VT_FILETIME) && wVtType != 36) ||(wVtType > VT_CLSID)){
				hr = DB_E_BADTYPE;
			}
		}
	}

	if( hr == S_OK ){

		//===================================================================================
		// Don't allow _ISLONG on fixed-length types
		//===================================================================================
		if( dwConvertFlags & DBCONVERTFLAGS_ISLONG ){

			switch( wFromType & ~(DBTYPE_RESERVED|DBTYPE_VECTOR|DBTYPE_ARRAY|DBTYPE_BYREF) ){
				case DBTYPE_BYTES:
				case DBTYPE_STR:
				case DBTYPE_WSTR:
				case DBTYPE_VARNUMERIC:
					break;

				default:
					hr = DB_E_BADCONVERTFLAG;
			}
		}
	}

	if( hr == S_OK ){
		//===================================================================================
		// Tell the DC that we are 2.x
		//===================================================================================
		DCINFO rgInfo[] = {{DCINFOTYPE_VERSION,{VT_UI4, 0, 0, 0, 0x0}}};
		IDCInfo	*pIDCInfo = NULL;

		if ((g_pIDataConvert->QueryInterface(IID_IDCInfo, (void **)&pIDCInfo) == S_OK) && pIDCInfo){

			V_UI4(&rgInfo->vData) = 0x200;	// OLE DB Version 02.00
			pIDCInfo->SetInfo(NUMELEM(rgInfo),rgInfo);
			pIDCInfo->Release();
		}

		//===================================================================================
		// Ask the conversion library for the answer
		//===================================================================================
		hr = g_pIDataConvert->CanConvert(wFromType, wToType);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\csrcrow.h ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// @module CSRCROW.H | CRowset base object and contained interface
// 
//
///////////////////////////////////////////////////////////////////////////////////

#ifndef _CSRCROW_H_
#define _CSRCROW_H_

#include "rowset.h"

typedef DWORD BOOKMARK;
///////////////////////////////////////////////////////////////////////////////////
//
// Rowset object for rowsets built from structures in memory.
//
///////////////////////////////////////////////////////////////////////////////////

class CRowsetInMem : public CRowset
{
    public:	

    	CRowsetInMem(LPUNKNOWN pUnkOuter, LONG cCursorRowCount, PCDBSESSION p);
	    ~CRowsetInMem();
	
    	STDMETHODIMP InstantiateDataObj(void);                                  // Instantiate Utility Objects which provided data retrieval related methods.
    	STDMETHODIMP GetRowsIntoInternalBuffer( ULONG cRows, ULONG *pcRowsObtained, PROWBUFF rgrowbuff );

        inline void Restart(void){ m_iCurrentRow = 0;}                          // Sets the column (we examine) / row (we produce) to start with.
	    inline void PositionToEnd(void){m_iCurrentRow = m_cRows + 1;}           // Positions to the end of the rowset
	    inline HRESULT FetchByBookmark(	BOOKMARK bookmark, LONG irow, DWORD *pcrow, DWORD dwRowsetSize,	PROWBUFF rgrowbuff );
	    inline HRESULT FetchRelative( LONG irow, DWORD *pcrow, DWORD dwRowsetSize, PROWBUFF	rgrowbuff );
    	inline HRESULT GetPosition(	BOOKMARK dwBookmark, ULONG *pulPosition	);
	    inline HRESULT PositionToBookmark( BOOKMARK dwBookmark );               // Position to a row in the rowset using a bookmark

    protected:	
        LONG		m_iCurrentRow;
};

///////////////////////////////////////////////////////////////////////////////////
class CColumnsRowset : public CRowsetInMem
{
    public:	

	    CColumnsRowset( LPUNKNOWN pUnkOuter,DBCOLUMNINFO	*pDBCOLUMNINFO);
	    ~CColumnsRowset();
    	STDMETHODIMP Init(	DBCOLUMNINFO	pDBCOLUMNINFO,	// IN | Source row metadata
	                        ULONG			cOptColumns,	// IN | Count of optional columns
	                        const DBID		rgOptColumns[],	// IN | array of optional columns
	                        PCUTILPROP  	*pCRowsetProps,	// IN | Rowset properties for this rowset.
	                        DWORD			dwStatusFlags,	// IN | flags providing additional info obtained at Execute time 
	                        CQuery			*pstmt,			// IN | Statement Handle Node
	                        IUnknown 		*pParentObj,	// IN | Object that instantiated the rowset
	                        CDBSession		*pCDBSession,	// IN | ptr to parent Session object
	                        CCommand		*pcmd	);		// IN | ptr to parent Command object
    public:	


	enum eColumns                                           	// Enumeration for the columns This is expected to match the order of the static arrays.
		{
		ecol_IDName=1,
		ecol_Guid,
		ecol_Propid,
		ecol_Name,
		ecol_Number,
		ecol_Type,
		ecol_TypeInfo,
		ecol_ColumnSize,
		ecol_Precision,
		ecol_Scale,
		ecol_Flags,
		// optional columns
		ecol_BaseCatalogName,
		ecol_BaseColumnName,
		ecol_BaseSchemaName,
		ecol_BaseTableName,
		ecol_DateTimePrecision,
		ecol_IsAutoIncrement,
		ecol_IsCaseSensitive,
		ecol_IsSearchable,
		ecol_OctetLength,
		ecol_KeyColumn,
		ecol_NUM = ecol_KeyColumn,			// Index of last element
		ecol_NUM_REQD = ecol_Flags,			// Index of last required element
		ecol_NUM_OPT = ecol_KeyColumn,		// Index of last optional element
		};

	
	    inline static const DBID *GetColumnId(ULONG ecol){	return sm_rgpColumnID[ecol]; }

    protected:	

	
	    STDMETHODIMP GetRows( ULONG		cRows,				// IN  | count of rows requested
 	                          ULONG       *pcRowsObtained,	// OUT | count of rows obtained
		                      PROWBUFF	rgrowbuff		);	// IN  | buffer for multiple rows

    private:		 

		static const DBID * sm_rgpColumnID[];               // DBIDs for all columns
    	DWORD 			*m_rgEcol;                          // Array of eColumns for the columns we expose. It includes all required columns + only the requested optional columns.
		DBCOLUMNINFO	m_SrcMetadata;                      //Row metadata that is the source for the IColumnsRowset
		CExtBuffer		m_extSrcNamePool;                   //Name pool for the row metadata
	};

//////////////////////////////////////////////////////////////////////////////////////////////////////////
class CSourcesRowset : public CRowsetInMem
{

    public:	

	    CSourcesRowset(LPUNKNOWN pUnkOuter, CGenericArray* pdynNames);
    	~CSourcesRowset() {}

	enum eColumns                                       // Enumeration for the columns.This is expected to match the order of the static arrays.
		{
		ecol_Sources_Name=1,
		ecol_Sources_Parsename,
		ecol_Sources_Description,
		ecol_Type,
		ecol_Is_Parent,
		ecol_NUM = ecol_Is_Parent,			// Index of last element
		};

    protected:	

    // Get several rows into the internal buffer.	
	STDMETHODIMP	GetRows(	ULONG		cRows,				// IN  | count of rows requested
		                        ULONG       *pcRowsObtained,	// OUT | count of rows obtained
		                        PROWBUFF	rgrowbuff			// IN  | buffer for multiple rows
		                        );

    private:	

	    typedef DWORD DBSOURCETYPE;
	    enum DDBSOURCETYPEENUM{		DBSOURCETYPE_DATASOURCE = 1,		DBSOURCETYPE_ENUMERATOR =2		};

    	CGenericArray	*m_pdynNames;
        CQuery           *m_pstmt;
};
typedef CSourcesRowset	*PCSOURCESROWSET;
//////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpISequentialStream : public ISequentialStream	//@base public | ISequentialStream
{

    private: 
	
    	CCriticalSection m_cs;  

	    PCROWSET	m_pCRowset;		// Pointer to parent rowset object.
	    ULONG		m_cRef;			// Reference count
	    DWORD		m_dwStatus;		// Status flags
	    PROWBUFF	m_prowbuff;		// rowbuffer associated with this BLOB.
	    HROW		m_hrow;			// hrow for the rowbuffer
	    LONG		m_cbLength;		// Length of the BLOB data
	    LONG		m_cbRead;		// # of bytes read
	    WORD		m_iColumn;		// Column ordinal
		

    public: 
    	CImpISequentialStream(PCROWSET pCRowset);
    	~CImpISequentialStream();
    	STDMETHODIMP FInit(DWORD dwFlags, PROWBUFF prowbuff, HROW hrow, WORD iColumn, LONG cbLength = 0);
	WORD WGetCol(void) const	{ return m_iColumn; }
	// Zombie out the object
	STDMETHODIMP_(void)	MakeZombie (void);

	//	Object's base IUnknown
	// Request an Interface
	STDMETHODIMP QueryInterface(REFIID, LPVOID *);
	// Increments the Reference count
	STDMETHODIMP_(ULONG) AddRef(void);
	// Decrements the Reference count
	STDMETHODIMP_(ULONG) Release(void);

	// Read Chunks
	STDMETHODIMP Read(void* pBuffer, ULONG cb, ULONG* pcb);
	// Write Chunks
	STDMETHODIMP Write(const void* pBuffer,	ULONG cb, ULONG* pcb);
	};



////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fetches the specified rowset of data from the result set and returns the cached data in row buffers.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline HRESULT CRowsetInMem::FetchByBookmark(BOOKMARK	bookmark,		// IN | bookmark
		                                    LONG		irow,			// IN | row to fetch or bookmark
		                                    DWORD		*pcrow,			// OUT| # rows actually fetched (optional)
		                                    DWORD		dwRowsetSize,	// IN | size of the rowset
		                                    PROWBUFF	rgrowbuff	)	// IN | row buffers to use (optional)			
{
    if (bookmark){

	    //	need to adjust irow
	    irow += bookmark;
	    if (irow < 1){
		    dwRowsetSize = dwRowsetSize + irow - 1;
		    if (dwRowsetSize > 0)
			    irow = 1;		
		    else
			    return DB_S_ENDOFROWSET;
		    }
	    }
    else{
	    return DB_S_ENDOFROWSET;
	}
    m_iCurrentRow = irow;
    return GetRowsIntoInternalBuffer(dwRowsetSize, pcrow, rgrowbuff);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline HRESULT CRowsetInMem::FetchRelative(	LONG		irow,			// IN | row to fetch or bookmark
		                                    DWORD		*pcrow,			// OUT| # rows actually fetched (optional)
		                                    DWORD		dwRowsetSize,	// IN | size of the rowset
		                                    PROWBUFF	rgrowbuff	)	// IN | row buffers to use (optional)			
{
	if ((irow < -1 && LONG(irow+m_iCurrentRow) < 0)	||(irow > 1	&& ULONG(irow+m_iCurrentRow) > ULONG(m_cRows+1))) 
		return DB_E_BADSTARTPOSITION;

	m_iCurrentRow += irow;
	if (m_iCurrentRow < 1){

		dwRowsetSize = dwRowsetSize + m_iCurrentRow - 1;
		if (dwRowsetSize > 0)
			m_iCurrentRow = 1;		
		else
			return DB_S_ENDOFROWSET;
	}
	return GetRowsIntoInternalBuffer(dwRowsetSize, pcrow, rgrowbuff);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline HRESULT CRowsetInMem::GetPosition( BOOKMARK dwBookmark,		// IN | a bookmark
		                                  ULONG	 *pulPosition	)	// OUT | the bookmark's position in the rowset
{
    if (dwBookmark == 0 || dwBookmark > BOOKMARK(m_cRows)){
	    return DB_E_BADBOOKMARK;
    }

    *pulPosition = dwBookmark;
    return S_OK;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline HRESULT CRowsetInMem::PositionToBookmark( BOOKMARK dwBookmark )
{
	if (dwBookmark == 0 || dwBookmark > BOOKMARK(m_cRows)){
		return DB_E_BADBOOKMARK;
	}
	m_iCurrentRow = dwBookmark;
	return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\dataconvert.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  dataconvert.cpp
//

////////////////////////////////////////////////////////////////////////////

#include "headers.h"


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This function returns the default OLE DB representation for a data type
//
// To be used only to create tables or any other things
// But should not be used for setting properties of type ARRAYS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::MapOLEDBTypeToCIMType(WORD wDataType, long & lCIMType) 
{
    HRESULT hr = S_OK;
	BOOL bArray = FALSE;

	if( wDataType & DBTYPE_ARRAY)
	{
		bArray = TRUE;
		wDataType = wDataType & ~DBTYPE_ARRAY;
	}

    switch( wDataType ){

        case DBTYPE_I1:
			lCIMType = CIM_SINT8;
            break; 

        case DBTYPE_UI1:
			lCIMType = CIM_UINT8;
            break;

        case DBTYPE_I2:
			lCIMType = CIM_SINT16;
            break;

        case DBTYPE_UI2:
			lCIMType = CIM_UINT16;
            break;

        case DBTYPE_I4:
			lCIMType = CIM_SINT32;
            break;

        case DBTYPE_UI4:
			lCIMType = CIM_UINT32;
            break;

        case DBTYPE_I8:
			lCIMType = CIM_SINT64;
            break;

        case DBTYPE_UI8:
			lCIMType = CIM_UINT64;
            break;

        case DBTYPE_R4:
			lCIMType = CIM_REAL32;
            break;

        case DBTYPE_R8:
			lCIMType = CIM_REAL64;
            break;

        case DBTYPE_BOOL:
			lCIMType = CIM_BOOLEAN;
            break;

        case DBTYPE_WSTR:
        case DBTYPE_BSTR:
        case DBTYPE_STR:
			lCIMType = CIM_STRING;
            break;

        case DBTYPE_DATE :
        case DBTYPE_DBTIME :
		case DBTYPE_DBTIMESTAMP:
			lCIMType = CIM_DATETIME;
            break;

        case DBTYPE_IDISPATCH :
        case DBTYPE_IUNKNOWN :
			lCIMType = CIM_IUNKNOWN;
            break;

        case DBTYPE_VARIANT:
			hr = E_FAIL;
			break;


        default:
            assert( !"Unmatched OLEDB Data Type to CIMTYPE." );
    }

	if( bArray == TRUE)
	{
		lCIMType |= CIM_FLAG_ARRAY;
	}
    
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to Map CIMType to OLEDB type and allocate memory for the data
// NTRaid:111819 - 111822
// 06/07/00
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::AllocateAndMapCIMTypeToOLEDBType(CVARIANT & vValue,BYTE *& pData,DBTYPE & dwColType,DBLENGTH & dwSize, DWORD &dwFlags)
{

    HRESULT hr = S_OK;
	SAFEARRAY *pArray = NULL;
	LONG  lType= 0;
	VARIANT *pVar = NULL,*pvar2 = NULL;
	pData = NULL;

	lType = vValue.GetType();
	if(lType != VT_NULL && lType != VT_NULL)
	{
		lType = dwColType;
		// If the type is of some array
		if (dwColType & CIM_FLAG_ARRAY)
		{
			lType = CIM_FLAG_ARRAY;
		}
	}

	try
	{
		switch( lType ){

			case VT_NULL:
				pData = NULL;
				hr = DBSTATUS_S_ISNULL;
				dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
				break;

			case VT_EMPTY:
				pData = NULL;
				hr = DBSTATUS_S_ISNULL;
				dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
				break;

			// Arrays are always shown as ARRAY of VARIANTS to make it easily accessible with scripting
			case CIM_FLAG_ARRAY:
				lType = vValue.GetType();
				// since date is given out as string from WMI
				if(IsDateType((DBTYPE)dwColType))
				{
					lType = dwColType;
				}
				hr = ConvertToVariantArray(((VARIANT *)&vValue)->parray,(DBTYPE)lType,(SAFEARRAY **)&pData);
				dwSize = sizeof(SAFEARRAY);
				dwColType = VT_ARRAY | VT_VARIANT;
				dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
				break;

			case CIM_SINT8:
			case CIM_UINT8:
				pData = new BYTE[1];
				if(pData)
				{
					*pData = (BYTE)vValue.GetByte();
					dwSize = sizeof(BYTE);
					dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
				break; 

			case CIM_CHAR16:
			case CIM_SINT16:
			case CIM_UINT16:
			case CIM_BOOLEAN:
				{
					dwSize = sizeof(short);
					pData = new BYTE[dwSize];
					short tmp = vValue.GetShort();
					if(pData)
					{
						memcpy(pData,(BYTE*)&tmp,dwSize);
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}
				dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
				break;

			case CIM_SINT32:
			case CIM_UINT32:
			case CIM_REAL32:
				{
					dwSize = sizeof(long);
					long tmp = vValue.GetLONG();
					pData = new BYTE[dwSize];
					if(pData)
					{
						memset(pData,0,dwSize);
						memcpy(pData,(BYTE*)&tmp,dwSize);
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}
				dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
				break;

			case CIM_SINT64:
			case CIM_UINT64:
			case CIM_REAL64:
				{
					dwSize = 8;
					double dblVal = vValue.GetDouble();
					pData = new BYTE[dwSize];
					if(pData)
					{
						memcpy(pData,&dblVal,dwSize);
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}
				dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
				break;

			case CIM_DATETIME:
			case DBTYPE_DBTIMESTAMP:
				dwSize = sizeof(DBTIMESTAMP);
				dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
				if( vValue.GetStr() != NULL)
				{
					pData = new BYTE[dwSize];
					if(pData)
					{
						hr = ConvertDateToOledbType(vValue.GetStr(),(DBTIMESTAMP *)pData);
						dwColType = DBTYPE_DBTIMESTAMP;
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}
				else
				{
					hr = DBSTATUS_S_ISNULL;
					pData = NULL;
					dwSize = 0;
				}
				break;

			case VT_DATE:
				dwSize = sizeof(DBTIMESTAMP);
				pData = new BYTE[dwSize];
				if(pData)
				{
					ConvertVariantDateOledbDate(&((VARIANT *)&vValue)->date,(DBTIMESTAMP *)pData);
					dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
					dwColType = DBTYPE_DBTIMESTAMP;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
				break;

			case CIM_STRING:
				pData = (BYTE *)Wmioledb_SysAllocString(vValue.GetStr());
				dwSize = SysStringLen(vValue.GetStr());
				break;

			case CIM_REFERENCE:
				break;

			case CIM_OBJECT:
				break;

			case CIM_IUNKNOWN:
				pData = new BYTE[sizeof(IUnknown *)];
				if(pData)
				{
					memset(pData,0,sizeof(IUnknown *));
					hr = vValue.GetUnknown()->QueryInterface(IID_IUnknown,(void **)pData);
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
				break;
				
			case VT_VARIANT:
				dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
				dwSize = sizeof(VARIANT);
				pVar = new VARIANT;
				if(pVar)
				{
					VariantInit(pVar);
					hr = VariantCopy(pVar,vValue);
					dwColType = DBTYPE_VARIANT;
					pData = (BYTE *) pVar;
					pvar2 = (VARIANT *)pData;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
				break;

			default:
				assert( !"Unmatched OLEDB Data Type to CIMTYPE." );
		}
	} // try
	catch(...)
	{
		switch( lType )
		{

			case CIM_FLAG_ARRAY:
				{
					if(pData)
					{
						SafeArrayDestroy((SAFEARRAY *)pData);
					}
				}
				break;
			case CIM_STRING:
				{
					if(pData)
					{
						SysFreeString((BSTR)pData);
					}
				}
				break;

			case VT_VARIANT:
				{
					SAFE_DELETE_PTR((VARIANT *&)pData);
				}
				break;

			case CIM_IUNKNOWN:
				if(pData)
				{
					(*(IUnknown **)pData)->Release();
					SAFE_DELETE_ARRAY(pData);
				}

				break;

			default:
				{
					SAFE_DELETE_ARRAY(pData);
				}
				break;

			throw;
		}
	}
    
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Free the data allocated to store data
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::FreeData(DBTYPE lType, BYTE *& pData)
{
    HRESULT hr = S_OK;
	VARIANT *pVar = NULL;

    //=======================================================================
    //  See if it is an array
    //=======================================================================
/*   	if( lType & CIM_FLAG_ARRAY ){
       lType = lType &~  CIM_FLAG_ARRAY;
       fArray = TRUE;
    }
*/
	// If the pointer sent is not NULL
   	if( lType & CIM_FLAG_ARRAY )
	{
		lType = CIM_FLAG_ARRAY;
    }

	if(pData)
	{
		switch( lType ){

			case VT_EMPTY:
				break; 

			case VT_NULL:
				break; 

			case CIM_FLAG_ARRAY:
				pVar = (VARIANT *)pData;
				hr = SafeArrayDestroy((SAFEARRAY *)pData);
				break;

			case CIM_UINT8:
			case CIM_SINT8:
				SAFE_DELETE_PTR((BYTE*)pData);
				break;

			case CIM_BOOLEAN:
			case CIM_CHAR16:
			case CIM_SINT16:
			case CIM_UINT16:
				SAFE_DELETE_PTR((short*&)pData);
				break;

			case CIM_REAL32:
			case CIM_SINT32:
			case CIM_UINT32:
				SAFE_DELETE_PTR((DWORD*&)pData);
				break;

			case CIM_SINT64:
			case CIM_UINT64:
			case CIM_REAL64:
				SAFE_DELETE_ARRAY((BYTE*)pData);
				break;

			case CIM_DATETIME:
			case DBTYPE_DBTIMESTAMP:
				SAFE_DELETE_PTR((DBTIMESTAMP *&)pData);
				break;

			case CIM_STRING:
				SysFreeString((BSTR)pData);
				break;

			case CIM_REFERENCE:
				break;

			case CIM_OBJECT:
			case CIM_IUNKNOWN:
//			case DBTYPE_IUNKNOWN:
				if(pData)
				{
					SAFE_RELEASE_PTR((*(IUnknown **)pData));
					SAFE_DELETE_ARRAY(pData);
				}
				break;

			case VT_VARIANT:
				hr = VariantClear((VARIANT *)pData);
				SAFE_DELETE_PTR((VARIANT *&)pData);
				break;

			case DBTYPE_DATE:
				SAFE_DELETE_PTR((DATE *&)pData);
				break;
			

			default:
				assert( !"Unmatched OLEDB Data Type to CIMTYPE." );
		}
	}
	if(hr  == S_OK)
		pData = NULL;
    
    return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This function returns the default OLE DB representation for a data type
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::MapCIMTypeToOLEDBType(long lType, WORD & wdbOLEDBType, DBLENGTH & uColumnSize , DWORD &dwFlags) // OUT OLE DB type for DBColumnInfo
{
    HRESULT hr = S_OK;
	LONG lCimType = lType;

	if ( lType & CIM_FLAG_ARRAY)
	{
		lCimType = CIM_FLAG_ARRAY;
	}

	switch( lCimType ){

		case VT_EMPTY:
			wdbOLEDBType = DBTYPE_EMPTY;
			uColumnSize = 0;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break; 

		case VT_NULL:
			wdbOLEDBType = DBTYPE_NULL;
			uColumnSize = 0;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break; 

		case CIM_SINT8:
			wdbOLEDBType = DBTYPE_I1;
			uColumnSize = 1;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break; 

		case CIM_UINT8:
			wdbOLEDBType = DBTYPE_UI1;
			uColumnSize = 1;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_SINT16:
			wdbOLEDBType = DBTYPE_I2;
			uColumnSize = 2;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_UINT16:
			wdbOLEDBType = DBTYPE_UI2;
			uColumnSize = 2;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_SINT32:
			wdbOLEDBType = DBTYPE_I4;
			uColumnSize = 4;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_UINT32:
			wdbOLEDBType = DBTYPE_UI4;
			uColumnSize = 4;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_SINT64:
			wdbOLEDBType = DBTYPE_I8 ; //DBTYPE_R8; //DBTYPE_I8;
			uColumnSize = 8;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_UINT64:
			wdbOLEDBType = DBTYPE_UI8 ; //DBTYPE_R8; //DBTYPE_UI8;
			uColumnSize = 8;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_REAL32:
			wdbOLEDBType = DBTYPE_R4;
			uColumnSize = 4;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_REAL64:
			wdbOLEDBType = DBTYPE_R8;
			uColumnSize = 8;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_BOOLEAN:
			wdbOLEDBType = DBTYPE_BOOL;
			uColumnSize = 2;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_STRING:
			wdbOLEDBType = DBTYPE_BSTR;
			uColumnSize = ~0 ;//MAX_CIM_STRING_SIZE; //sizeof(BSTR); // set the size to -1 ( a variable length string)
			break;

		case CIM_DATETIME:
		case DBTYPE_DBTIMESTAMP:
		case VT_DATE :
			wdbOLEDBType = DBTYPE_DBTIMESTAMP;
			uColumnSize = sizeof(DBTIMESTAMP);
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_REFERENCE:
			wdbOLEDBType = DBTYPE_BSTR;
			uColumnSize = sizeof(BSTR);
			break;

		case CIM_CHAR16:
			wdbOLEDBType = DBTYPE_STR;
			uColumnSize = 2;
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
			break;

		case CIM_OBJECT:
			wdbOLEDBType = DBTYPE_BSTR;
			uColumnSize = sizeof(BSTR);
			break;

		case CIM_FLAG_ARRAY:

			wdbOLEDBType = VT_ARRAY | VT_VARIANT;
			uColumnSize = sizeof(SAFEARRAY);
			hr = S_OK;
			break;

        case DBTYPE_GUID:
			wdbOLEDBType = DBTYPE_GUID;
			uColumnSize = sizeof(GUID);
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
            break;

		case CIM_IUNKNOWN:
			wdbOLEDBType = DBTYPE_IUNKNOWN;
			uColumnSize = sizeof(IUnknown *);
			dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
            break;

		default:
			assert( !"Unmatched CIMTYPE to OLEDB Data Type." );

	}
    return hr;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This function translates text strings to OLEDB types
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::TranslateParameterStringToOLEDBType( DBTYPE & wDataType, WCHAR * str) 
{
    HRESULT hr = S_OK;

    // Arrays ????

    wDataType = 999;

    if( 0 == _wcsicmp(L"DBTYPE_CHAR",str )){
        wDataType = DBTYPE_STR;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_VARCHAR",str )){
        wDataType = DBTYPE_STR;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_LONGVARCHAR",str )){
        wDataType = DBTYPE_STR;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_WCHAR",str )){
        wDataType = DBTYPE_WSTR;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_WVARCHAR",str )){
        wDataType = DBTYPE_WSTR;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_WLONGVARCHAR",str )){
        wDataType = DBTYPE_WSTR;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_UI1",str )){
		wDataType = DBTYPE_UI1;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_I1",str )){
		wDataType = DBTYPE_I1;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_I2",str )){
		wDataType = DBTYPE_I2;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_UI2",str )){
		wDataType = DBTYPE_UI2;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_I4",str )){
		wDataType = DBTYPE_I4;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_UI4",str )){
		wDataType = DBTYPE_UI4;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_I8",str )){
		wDataType = DBTYPE_I8;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_UI8",str )){
		wDataType = DBTYPE_UI8;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_R4",str )){
		wDataType = DBTYPE_R4;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_R8",str )){
		wDataType = DBTYPE_R8;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_BOOL",str )){
		wDataType = DBTYPE_BOOL;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_WSTR",str )){
		wDataType = DBTYPE_WSTR;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_BSTR",str )){
		wDataType = DBTYPE_BSTR;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_STR",str )){
		wDataType = DBTYPE_STR;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_DATE ",str )){
		wDataType = DBTYPE_DATE ;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_DBTIME ",str )){
		wDataType = DBTYPE_DBTIME ;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_DBTIMESTAMP",str )){
		wDataType = DBTYPE_DBTIMESTAMP;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_IDISPATCH",str )){
		wDataType = DBTYPE_IDISPATCH;
    }
    else if( 0 == _wcsicmp(L"DBTYPE_IUNKNOWN",str )){
		wDataType = DBTYPE_IUNKNOWN;
    }
 
	return hr;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This function maps and converts OLEDBTYPE to CIMTYPE
//
// Note: 
//	dwArrayCIMType	= -1				- If data passed is not array
//	dwArrayCIMType  = actual CIMTYPE	- If the passed data is array 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::MapAndConvertOLEDBTypeToCIMType(DBTYPE wDataType, void *pData ,DBLENGTH dwSrcLength, VARIANT &varData,LONG_PTR lArrayCIMType) 
{
    HRESULT hr = S_OK;
	DWORD dwDstStatus = 0 , cbDstMaxLength = 0;
	void *pSrc = NULL;
	BSTR strDate=Wmioledb_SysAllocString(NULL);
	SAFEARRAY * pArrayTemp = NULL;
	DBLENGTH dbDstLen = 0;
	
	if(lArrayCIMType == -1)
	{
		if(wDataType == VT_BSTR)
			pSrc = &pData;
		else
			pSrc = pData;

		switch( wDataType )
		{
			case DBTYPE_UI1:
			case DBTYPE_I1:
				wDataType = DBTYPE_I2;
				break;

			case DBTYPE_UI2:
				wDataType = DBTYPE_I2;
				break;

			case DBTYPE_UI4:
				wDataType = DBTYPE_I4;
				break;

			case DBTYPE_DBTIMESTAMP:
				if(IsValidDBTimeStamp((DBTIMESTAMP *)pData))
				{
					// Converts OLEDB DBTIMESTAMP to DMTF date format
					ConvertOledbDateToCIMType((DBTIMESTAMP *)pData,strDate);
					pSrc = &strDate;
					wDataType = VT_BSTR;
				}
				else
				 hr = DBSTATUS_E_CANTCONVERTVALUE;

		}
	}
	else
	// if the type is array then convert it into the appropriate type
	if( (wDataType & DBTYPE_ARRAY) && (lArrayCIMType & DBTYPE_ARRAY))
	{
		hr = ConvertAndCopyArray((SAFEARRAY *)pData, &pArrayTemp, wDataType,(DBTYPE)lArrayCIMType,&dwDstStatus);
		wDataType = (DBTYPE)lArrayCIMType;
		pSrc = pArrayTemp;
	}
	if( hr == S_OK)
	{
		hr = g_pIDataConvert->DataConvert(  wDataType, VT_VARIANT, dwSrcLength, &dbDstLen, pSrc,
										&varData, sizeof(VARIANT),  0,  &dwDstStatus,
										0,	// bPrecision for conversion to DBNUMERIC
										0,		// bScale for conversion to DBNUMERIC
										DBDATACONVERT_DEFAULT);

	}

	// Release memory
	if( pArrayTemp)
	{
		SafeArrayDestroy(pArrayTemp);
		pArrayTemp = NULL;
	}

	SysFreeString(strDate);
	return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This function maps and converts OLEDBTYPE to CIMTYPE
//
// Note: 
//	dwArrayCIMType	= -1				- If data passed is not array
//	dwArrayCIMType  = actual CIMTYPE	- If the passed data is array 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::ConvertToCIMType(BYTE *pData, DBTYPE lType ,DBLENGTH lDataLength,LONG lCIMType ,VARIANT &varData) 
{
    HRESULT		hr				= DBSTATUS_E_CANTCONVERTVALUE;
	DWORD		dwDstStatus		= 0;
	DWORD		cbDstMaxLength	= 0;
	void *		pDst			= NULL;
	void *		pSrc			= NULL;
	void *		pTemp			= NULL;
	BYTE *		pbTemp			= NULL;
	BSTR		strDate			= Wmioledb_SysAllocString(NULL);
	SAFEARRAY * pArrayTemp		= NULL;
	BOOL		bAlloc			= FALSE;
	DBLENGTH	dbDstLen		= 0;
	DBTYPE		wDataType		= 0;
	BOOL		bConverted		= FALSE;

	wDataType	= (DBTYPE)lCIMType;
	
	if(! pData)
	{
		VariantClear(&varData);
		hr = S_OK;
	}
	else
	{
		switch(lCIMType)
		{
			case CIM_UINT8:
				wDataType = VT_I2;
				break;

			case CIM_UINT16:
				wDataType = VT_I2;
				break;

			case CIM_UINT32:
				wDataType = VT_I4;
				break;

			case CIM_DATETIME:
				BSTR	strDate;
				pTemp = new BYTE[sizeof(DBTIMESTAMP)];

				if( lType == VT_BSTR)
					pSrc = *(BSTR **)pData;
				else
					pSrc = pData;

				//NTRaid:111795
				// 06/07/00
				if(pTemp == NULL)
				{
					hr = E_OUTOFMEMORY;
				}
				else
				// Convert the given date to DBTIMESTAMP
				if( S_OK == (hr = g_pIDataConvert->DataConvert( (DBTYPE)lType,DBTYPE_DBTIMESTAMP, lDataLength,&dbDstLen, pSrc,
									pTemp, sizeof(DBTIMESTAMP),  0,  &dwDstStatus,
									0,	// bPrecision for conversion to DBNUMERIC
									0,		// bScale for conversion to DBNUMERIC
									DBDATACONVERT_DEFAULT)) && dwDstStatus != DBSTATUS_S_ISNULL)

				{
					// Call this function to convert DBTIMESTAMP date to CIM date format
					if(S_OK == (hr = ConvertOledbDateToCIMType((DBTIMESTAMP*)pTemp,strDate)))
					{
						varData.vt = VT_BSTR;
						varData.bstrVal = Wmioledb_SysAllocString(strDate);
						SysFreeString(strDate);
					}
				}
				SAFE_DELETE_ARRAY(pTemp);
				bConverted = TRUE;
				break;

		}
			
		if(bConverted == FALSE)
		{
			pTemp	 = pData;
			hr = S_OK;
			// if the required type and the type of the data passed is different then convert the data to appropriate 
			// type
			if( lType != (LONG)wDataType && (hr = g_pIDataConvert->CanConvert((DBTYPE)lType,(DBTYPE)wDataType)) == S_OK)
			{
				pTemp = NULL;
				if(SUCCEEDED(hr = AllocateData(wDataType,pTemp,dbDstLen)))
				{
					bAlloc	= TRUE;

					if( lType == VT_BSTR)
						pSrc = (BYTE *)*((BSTR **)pData);
					else
						pSrc = pData;

					hr = g_pIDataConvert->DataConvert( (DBTYPE)lType,(DBTYPE)wDataType, lDataLength,&dbDstLen, pSrc,
										pTemp, dbDstLen,  0,  &dwDstStatus,
										0,	// bPrecision for conversion to DBNUMERIC
										0,		// bScale for conversion to DBNUMERIC
										DBDATACONVERT_DEFAULT);
				}
			}
			if( hr == S_OK)
			{

				if( wDataType == VT_BSTR)
					pSrc = *(BSTR **)pTemp;
				else
					pSrc = pTemp;

				hr = g_pIDataConvert->DataConvert((DBTYPE)wDataType, VT_VARIANT, dbDstLen, &dbDstLen, pSrc,
												&varData, sizeof(VARIANT),  0,  &dwDstStatus,
												0,	// bPrecision for conversion to DBNUMERIC
												0,		// bScale for conversion to DBNUMERIC
												DBDATACONVERT_DEFAULT);
			}
			if( bAlloc == TRUE)
			{
				pbTemp = (BYTE *)pTemp;
				FreeData(wDataType,pbTemp);
			}

		}

	}

	SysFreeString(strDate);
	return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This function convert data to the OLEDBTYPE required. It also allocates memory for the data
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::AllocateAndConvertToOLEDBType(VARIANT &varData,LONG lCimType , DBTYPE lOledbType,BYTE *&pData, DBLENGTH &lDataLength, DBSTATUS &dwStatus)
{
    HRESULT hr = DBSTATUS_E_CANTCONVERTVALUE;
	DBTYPE wDataType = 0;
	DBLENGTH  dwDstLength = 0;
	BYTE *pSrc = NULL;
	void *pTemp = NULL;
	void *pDst	= NULL;
	BOOL bConvert = FALSE;
	BOOL bAlloc		= FALSE;
	DBLENGTH	dbDstLen = 0;
	
	wDataType	= (DBTYPE)lCimType;

	if(wDataType & CIM_FLAG_ARRAY)
	{
		wDataType = CIM_FLAG_ARRAY;
	}
	
	if(varData.vt   == VT_NULL || varData.vt == VT_EMPTY)
	{
		pData = NULL;
		lDataLength = NULL;
		dwStatus = DBSTATUS_S_ISNULL;
		return S_OK;
	}

	switch(wDataType)
	{
		// Arrays are always shown as ARRAY of VARIANTS to make it easily accessible with scripting
		case CIM_FLAG_ARRAY:
//			if(lOledbType != VT_ARRAY || VT_VARIANT)
			// Bug number 103751 in Windows bugs
			hr = DBSTATUS_E_CANTCONVERTVALUE;
			if(lOledbType == (VT_ARRAY | VT_VARIANT))
			{
				hr = ConvertToVariantArray(((VARIANT *)&varData)->parray,varData.vt,(SAFEARRAY **)&pData);
			}
			bConvert = TRUE;
			break;

		case CIM_DATETIME:
		case DBTYPE_DBTIMESTAMP:
			lDataLength = sizeof(DBTIMESTAMP);
			if( varData.bstrVal != NULL)
			{
				// NTRaid:111818
				// 06/13/00
				pSrc = new BYTE[lDataLength];

				if(pSrc)
				{
					bAlloc = TRUE;
					hr = ConvertDateToOledbType(varData.bstrVal,(DBTIMESTAMP *)pSrc);
					wDataType = DBTYPE_DBTIMESTAMP;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}
			else
			{
				hr = S_OK;
				pSrc = NULL;
				lDataLength = 0;
				bConvert = TRUE;
			}
			break;

		default:
			wDataType = VT_VARIANT;
			lDataLength = sizeof(VARIANT);
			pSrc		= (BYTE *)&varData;
			// NTRaid:111818
			// 06/13/00
			hr = S_OK;
	}
	// NTRaid:111818
	// 06/13/00
	if(SUCCEEDED(hr) && bConvert == FALSE && pSrc != NULL && g_pIDataConvert->CanConvert((DBTYPE)wDataType,(DBTYPE)lOledbType) == S_OK)
	{
		//AllocateData(lOledbType,pDst,dwDstLength);

		if(wDataType == VT_BSTR)
			pDst = *(BSTR **)pData;
		else
			pDst = (void *)pData;

		hr = g_pIDataConvert->DataConvert( (DBTYPE)wDataType,(DBTYPE)lOledbType, lDataLength,&dbDstLen, pSrc,
							pDst, dbDstLen,  0,  &dwStatus,
							0,	// bPrecision for conversion to DBNUMERIC
							0,		// bScale for conversion to DBNUMERIC
							DBDATACONVERT_DEFAULT);

		if( hr == S_OK)
		{
			pData = (BYTE *)pDst;
		}
	}

	if(bAlloc == TRUE)
	{
		delete [] pSrc;
	}

	lDataLength = (LONG)dbDstLen;

	return hr;

}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to convert the data to variant type
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::ConvertVariantType(VARIANT &varSrc, VARIANT varDst ,CIMTYPE lDstType)
{
	HRESULT hr = E_FAIL;

	switch(lDstType)
	{
		case CIM_DATETIME:
		case DBTYPE_DBTIMESTAMP:
		case DBTYPE_DATE:
		case DBTYPE_DBTIME:
			lDstType =  DBTYPE_BSTR;
			break;

		case CIM_REFERENCE	:
		case CIM_CHAR16:
		case CIM_OBJECT:
		case CIM_FLAG_ARRAY:
			break;

		case CIM_UINT64:
		case CIM_SINT64:
			lDstType = VT_R8;
	};

	hr = VariantChangeType(&varSrc,&varDst,0,(SHORT)lDstType);

	return hr;

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to compare data of same types and check if both are same
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CDataMap::CompareData(DWORD dwType,void * pData1 , void *pData2)
{

	BOOL bRet = FALSE;
	long lType = VT_NULL;

	if(pData1 == NULL || pData2 == NULL)
	{
		if(pData1 == pData2)
			bRet = TRUE;

		return bRet;
	}

	// If the type is of some array
	if (dwType & VT_ARRAY)
	{
		lType = CIM_FLAG_ARRAY;
	}
	else 
		lType = dwType;

	switch( lType ){

		case VT_NULL:
		case VT_EMPTY:
			bRet = TRUE;
			break;

		case CIM_FLAG_ARRAY:
			bRet = FALSE;
			break;

		case CIM_SINT8:
		case CIM_UINT8:
			if(!memcmp(pData1,pData2,1))
				bRet = TRUE;
			break; 

		case CIM_CHAR16:
		case CIM_SINT16:
		case CIM_UINT16:
		case CIM_BOOLEAN:
			if(!memcmp(pData1,pData2,2))
				bRet = TRUE;
			break; 

		case CIM_SINT32:
		case CIM_UINT32:
		case CIM_REAL32:
			if(!memcmp(pData1,pData2,4))
				bRet = TRUE;
			break; 

		case CIM_SINT64:
		case CIM_UINT64:
		case CIM_REAL64:
			if(!memcmp(pData1,pData2,8))
				bRet = TRUE;
			
			break; 

		case CIM_DATETIME:
		case DBTYPE_DBTIMESTAMP:
			if(!memcmp(pData1,pData2,sizeof(DBTIMESTAMP)))
				bRet = TRUE;
			
			break; 

		case CIM_STRING:
			

			if( pData1 != NULL && pData2 != NULL)
			{
				if(!_wcsicmp((WCHAR *)pData1,(WCHAR *)pData2))
					bRet = TRUE;
			}

			break;

		case CIM_REFERENCE:
		case CIM_OBJECT:
		case VT_VARIANT:
		case CIM_IUNKNOWN:
			break;

		
		case DBTYPE_DATE:
			if(!memcmp(pData1,pData2,sizeof(DATE)))
				bRet = TRUE;
			break;

				

		default:
			assert( !"Unmatched OLEDB Data Type to CIMTYPE." );
	}
    
	return bRet;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to check if a Safearray is Empty or not
// NOTE :Works on Single dimensional array
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CDataMap::IsSafeArrayEmpty(SAFEARRAY *psa)
{
	BOOL bRet = TRUE;
	long lUBound = 0,lLBound = 0;
	HRESULT hr = 0;

	hr = SafeArrayGetUBound(psa,1,&lUBound);
	hr = SafeArrayGetLBound(psa,1,&lLBound);

	if( hr == S_OK && lLBound <= lUBound)
	{
		bRet = FALSE;
	}

	return bRet;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to convert a safearray of one type to safearray of another type if, 
// the source and destination arrays are of different type 
// and this will just copy the safearray to the destination if the arraytypes are of same type
// NOTE: Works on Single dimensional array
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::ConvertAndCopyArray(SAFEARRAY *psaSrc, SAFEARRAY **ppsaDst, DBTYPE dwSrcType,DBTYPE dwDstType,DBSTATUS *pdwStatus)
{
	HRESULT				hr			= S_OK;
	SAFEARRAYBOUND  	sabound;
	LONG				lUBound		= 0;
	LONG				lLBound		= 0;
	int					nArrayIndex = 0;
	void *				pSrc		= NULL;
	void *				pDst		= NULL;
	void *				pTemp		= NULL;
	DBLENGTH			dbSrcLen	= 0;
	DBLENGTH			dbDstLen	= 0;
	BSTR *				pTempStr;
	BYTE *				pbTemp		= NULL;
	
	short				dwSrcElemType  = (SHORT) dwSrcType & ~DBTYPE_ARRAY;
	short				dwDstElemType  = (SHORT)dwDstType & ~DBTYPE_ARRAY;

	*pdwStatus	= DBSTATUS_S_OK;

	// If the array is not a single dimenstion array , then there is an error
    if(SafeArrayGetDim(psaSrc) != 1)
        return E_FAIL;      // Bad array, or too many dimensions
 
	// If the source safearray is not empty
	if(!IsSafeArrayEmpty(psaSrc))
	{
		// if source and destination safe array is same then we can 
		// copy the safearray using SafeArrayCopy
		if( dwSrcType != dwDstType)
		{
			// if the destination type is array of DBDATETIME then 
			// set error and status
			if( IsDateType(dwDstType) && dwDstElemType == DBTYPE_DBTIMESTAMP)
			{
					hr			= E_FAIL;
					*pdwStatus	= DBSTATUS_E_BADSTATUS;				
			}
			else
			// If the data type of the elements of the array can be converted
			// if the source type is date then conversion will be from the string in CIMDATE formate
			// which will be done by a utility function and not from the OLEDB conversion routine
			if( SUCCEEDED (hr = g_pIDataConvert->CanConvert(dwSrcElemType, dwDstElemType)) || IsDateType(dwSrcElemType))
			{
				dbSrcLen = SafeArrayGetElemsize(psaSrc);
				memset(&sabound,0,sizeof(SAFEARRAYBOUND));

				hr = SafeArrayGetUBound(psaSrc,1,&lUBound);
				hr = SafeArrayGetLBound(psaSrc,1,&lLBound);
				if( lUBound > lLBound)
				{
					sabound.lLbound		= lLBound;
					sabound.cElements	= lUBound - lLBound +1;

					// Create the safearray
					*ppsaDst = SafeArrayCreate(dwDstElemType, 1, &sabound);
					pSrc   = new BYTE[dbSrcLen];
					if(SUCCEEDED(hr = AllocateData(dwDstElemType,pDst,dbDstLen)))
					{
						if(dwDstElemType == VT_BSTR)
							pTemp = *(BSTR **)pDst;
						else
							pTemp = pDst;


						// Navigate thru each element in the dimension of the array
						for(nArrayIndex = lLBound ; nArrayIndex <= lUBound ; nArrayIndex++)
						{
							hr = SafeArrayGetElement(psaSrc,(long *)&nArrayIndex,pSrc);
							if(hr == S_OK && dbDstLen > 0)
							{
								if( IsDateType(dwSrcType) || IsDateType(dwDstType))
								{
									// Convert the element data
									hr = ConvertDateTypes(
											dwSrcElemType,
											dwDstElemType,
											dbSrcLen,
											&dbDstLen,
											&(((VARIANT *)pSrc)->bstrVal),
											pTemp,
											dbDstLen,
											pdwStatus);
								}
								else
								{
									// Free the previous string allocated from previous
									// conversion
									if( dwDstElemType == VT_BSTR && pDst != NULL)
									{
										pTempStr = *(BSTR **)pDst;
										SysFreeString(*pTempStr);
									}


									// Convert the element data
									hr = g_pIDataConvert->DataConvert(
											dwSrcElemType,
											dwDstElemType,
											dbSrcLen,
											&dbDstLen,
											pSrc,
											pTemp,
											dbDstLen,
											0,
											pdwStatus,
											0,
											0,
											DBDATACONVERT_DEFAULT);

									if(hr == DB_E_UNSUPPORTEDCONVERSION && pdwStatus != NULL)
										*pdwStatus = DBSTATUS_E_CANTCONVERTVALUE;
								}

								// Put the data to the destination array
								hr = SafeArrayPutElement(*ppsaDst,(long *)&nArrayIndex,pTemp);
							}
							else
							{
								hr			= E_FAIL;
								*pdwStatus	= DBSTATUS_E_BADSTATUS;
								break;
							}
						}// for

					}
				}

				SAFE_DELETE_ARRAY(pSrc);
				pbTemp = (BYTE *)pDst;
				FreeData(dwDstElemType,pbTemp);
				pDst = pbTemp;
			}
			else // Else if the data types of src and dst is not convertible then set the status
			{
				*pdwStatus = DBSTATUS_E_CANTCONVERTVALUE;
			}
		}
		else  // if the src and dst or of same type then just copy the arrays
		{
			hr =  SafeArrayCopy(psaSrc,ppsaDst);
		}

	}
	else
	{
		ppsaDst		= NULL;
		*pdwStatus  = DBSTATUS_S_ISNULL;
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to allocate memory 
// Used by ConvertAndCopyArray function to allocate data for elements for converting
// the data type and putting it to the array
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::AllocateData(DBTYPE dwType,void *& pData,DBLENGTH &dwLength)
{

    HRESULT hr = S_OK;
	long lType = dwType;
	SAFEARRAY *pArray = NULL;
	dwLength = 0;

	// If the type is of some array
	if (lType & CIM_FLAG_ARRAY)
	{
		lType = CIM_FLAG_ARRAY;
	}

	try
	{
		switch( lType ){

			case VT_NULL:
				pData = NULL;
				hr = DBSTATUS_S_ISNULL;
				break;

			case VT_EMPTY:
				pData = NULL;
				hr = DBSTATUS_S_ISNULL;
				break;

			case CIM_FLAG_ARRAY:
				break;

			case CIM_SINT8:
			case CIM_UINT8:
				pData = new BYTE[1];
				dwLength = sizeof(BYTE);
				if(!pData)
				{
					hr = E_OUTOFMEMORY;
				}
				break; 

			case CIM_CHAR16:
			case CIM_SINT16:
			case CIM_UINT16:
			case CIM_BOOLEAN:
				dwLength = sizeof(short);
				pData = new BYTE[dwLength];
				if(!pData)
				{
					hr = E_OUTOFMEMORY;
				}
				break;

			case CIM_SINT32:
			case CIM_UINT32:
			case CIM_REAL32:
				dwLength = sizeof(long);
				pData = new BYTE[dwLength];
				if(!pData)
				{
					hr = E_OUTOFMEMORY;
				}
				break;

			case CIM_SINT64:
			case CIM_UINT64:
			case CIM_REAL64:
				dwLength = 8;
				pData = new BYTE[8];
				if(!pData)
				{
					hr = E_OUTOFMEMORY;
				}
				break;

			case CIM_DATETIME:
			case DBTYPE_DBTIMESTAMP:
				dwLength = sizeof(DBTIMESTAMP);
				pData = new BYTE[dwLength];
				if(!pData)
				{
					hr = E_OUTOFMEMORY;
				}
				break;

			case DBTYPE_DATE:
				dwLength = sizeof(DATE);
				pData = new BYTE[dwLength];
				if(!pData)
				{
					hr = E_OUTOFMEMORY;
				}
				break;

			case CIM_STRING:
				pData = new BYTE[sizeof(BSTR)];
				dwLength = sizeof(BSTR);
				if(!pData)
				{
					hr = E_OUTOFMEMORY;
				}
				break;

			case CIM_REFERENCE:
				break;

			case CIM_OBJECT:
				break;

			case VT_VARIANT:
				dwLength	= sizeof(VARIANT);
				pData		= new BYTE[sizeof(VARIANT)];
				if(!pData)
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					VariantInit((VARIANT *)pData);
				}
				break;


			default:
				hr = E_FAIL;
//				assert( !"Unmatched OLEDB Data Type to CIMTYPE." );
		}
	} // try
	catch(...)
	{
		SAFE_DELETE_ARRAY(pData);
		throw;
	}
    
	return hr;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to convert WMI (DMTF) formate date to OLEDB format 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::ConvertDateToOledbType(BSTR strDate,DBTIMESTAMP *pTimeStamp)
{

	WBEMTime wbemTime(strDate);
	if(wbemTime.IsOk())
	{
		SYSTEMTIME sysTime;
		memset(&sysTime,0,sizeof(SYSTEMTIME));

		wbemTime.GetSYSTEMTIME(&sysTime);

		pTimeStamp->year	= (SHORT) sysTime.wYear;
		pTimeStamp->month	= (USHORT)sysTime.wMonth;
		pTimeStamp->day		= (USHORT)sysTime.wDay;
		pTimeStamp->hour	= (USHORT)sysTime.wHour;
		pTimeStamp->minute	= (USHORT)sysTime.wMinute;
		pTimeStamp->second	= (USHORT)sysTime.wSecond;
		pTimeStamp->fraction= (ULONG)sysTime.wMilliseconds * 1000000; // converting into billionth of second

		return S_OK;
	}
	return DBSTATUS_E_CANTCONVERTVALUE;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to convert VARIANT date format to OLEDB format 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::ConvertVariantDateOledbDate(DATE *pDate,DBTIMESTAMP *pTimeStamp)
{
    HRESULT hr = S_OK;
	DWORD dwDstStatus = 0 ,cbDstMaxLength = 0;
	DBLENGTH dbDstLen = 0;

	hr = g_pIDataConvert->DataConvert(  VT_DATE, DBTYPE_DBTIMESTAMP, sizeof(DATE), &dbDstLen, pDate,
										pTimeStamp, sizeof(DBTIMESTAMP),  0,  &dwDstStatus,
										0,	// bPrecision for conversion to DBNUMERIC
										0,		// bScale for conversion to DBNUMERIC
										DBDATACONVERT_DEFAULT);

	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to convert OLEDB format to WMI (DMTF) format
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::ConvertOledbDateToCIMType(DBTIMESTAMP *pTimeStamp,BSTR &strDate)
{
	WBEMTime wbemTime;
	SYSTEMTIME sysTime;
	memset(&sysTime,0,sizeof(SYSTEMTIME));

	sysTime.wYear			= pTimeStamp->year;
	sysTime.wMonth			= pTimeStamp->month;
	sysTime.wDay			= pTimeStamp->day;
	sysTime.wHour			= pTimeStamp->hour;
	sysTime.wMinute			= pTimeStamp->minute;
	sysTime.wSecond			= pTimeStamp->second;
	sysTime.wMilliseconds	= (WORD)pTimeStamp->fraction/ 1000000; // converting into micosecond

	wbemTime = sysTime;
	strDate = wbemTime.GetDMTF();

	return S_OK;
}


HRESULT CDataMap::ConvertOledbDateToCIMType(VARIANT *vTimeStamp,BSTR &strDate)
{
	WBEMTime wbemTime;
	SYSTEMTIME sysTime;
	memset(&sysTime,0,sizeof(SYSTEMTIME));
	DBTIMESTAMP *pTimeStamp;

	assert(vTimeStamp->vt == (VT_ARRAY | VT_UI1) || vTimeStamp->vt == (VT_ARRAY | VT_I1));

	SafeArrayAccessData(vTimeStamp->parray,(void **)&pTimeStamp);

	ConvertOledbDateToCIMType(pTimeStamp,strDate);
	SafeArrayUnaccessData(vTimeStamp->parray);

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to convert OLEDB format to WMI (DMTF) format
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::ConvertVariantDateToCIMType(DATE *pDate,BSTR &strDate)
{

	DBTIMESTAMP dbTimeStamp;

	memset(&dbTimeStamp,0,sizeof(DBTIMESTAMP));
	ConvertVariantDateOledbDate(pDate,&dbTimeStamp);
	ConvertOledbDateToCIMType(&dbTimeStamp,strDate);

	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check if the DTIMESTAMP passed is valid or not
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CDataMap::IsValidDBTimeStamp(DBTIMESTAMP *pTimeStamp) 
{
    HRESULT hr = S_OK;
	DWORD dwDstStatus = 0 , cbDstMaxLength = 0;
	void *pSrc = NULL;
	CVARIANT varDate;
	DBLENGTH dbDstLen = 0;
	
	hr = g_pIDataConvert->DataConvert(  DBTYPE_DBTIMESTAMP, VT_VARIANT, sizeof(DBTIMESTAMP), &dbDstLen, pTimeStamp,
										&varDate, sizeof(VARIANT),  0,  &dwDstStatus,
										0,	// bPrecision for conversion to DBNUMERIC
										0,		// bScale for conversion to DBNUMERIC
										DBDATACONVERT_DEFAULT);


	if( hr != S_OK)
		return FALSE;
	
	return TRUE;

}


BOOL CDataMap::IsDateType(DWORD dwType)
{
	BOOL bRet = FALSE;

	if(dwType & VT_ARRAY)
		dwType = dwType & ~(VT_ARRAY);

	switch(dwType)
	{
		case DBTYPE_DATE:
		case DBTYPE_DBTIMESTAMP:
		case DBTYPE_DBTIME:
		case CIM_DATETIME:
			
			bRet = TRUE;
			break;
	}

	return bRet;
}

HRESULT CDataMap::ConvertDateTypes(	DWORD		dwSrcType,
									DWORD		dwDstType,
									DBLENGTH	dwSrcLen,
									DBLENGTH*	pdwDstLen,
									void  *		pSrc,
									void * &	pDst,
									DBLENGTH	dbDstLen,
									DWORD *		pdwStatus)
{
	HRESULT hr = S_OK;
	DBTIMESTAMP *pSrcTimeStamp = NULL;
	

	pSrcTimeStamp = new DBTIMESTAMP;
	// NTRaid:111817
	// 06/07/00
	if(!pSrcTimeStamp)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		memset(pSrcTimeStamp,0,sizeof(DBTIMESTAMP));

		switch(dwSrcType)
		{
			case CIM_DATETIME:
				hr = ConvertDateToOledbType(*(BSTR*)pSrc ,pSrcTimeStamp);
				break;

			default :
				hr = g_pIDataConvert->DataConvert(  (USHORT)dwSrcType , DBTYPE_DBTIMESTAMP,  dwSrcLen,  &dbDstLen, pSrc, pSrcTimeStamp,
													sizeof(DBTIMESTAMP),  0,  pdwStatus,
													0,	// bPrecision for conversion to DBNUMERIC
													0,		// bScale for conversion to DBNUMERIC
													DBDATACONVERT_DEFAULT);

		}

		if( hr == S_OK)
		{
			switch(dwDstType)
			{
				case CIM_DATETIME:	
					hr = ConvertOledbDateToCIMType(pSrcTimeStamp,(BSTR)*(BSTR *)pDst);

				default:
					hr = g_pIDataConvert->DataConvert(  DBTYPE_DBTIMESTAMP, (USHORT)dwDstType, sizeof(DBTIMESTAMP), &dbDstLen, pSrcTimeStamp,
														pDst, dbDstLen,  0,  pdwStatus,
														0,	// bPrecision for conversion to DBNUMERIC
														0,		// bScale for conversion to DBNUMERIC
														DBDATACONVERT_DEFAULT);
			}
		}

		SAFE_DELETE_PTR(pSrcTimeStamp);
	}
	return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Clear data for a particular DBTYPE
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::ClearData(DBTYPE lType, void * pData)
{
    HRESULT hr = S_OK;
	VARIANT *pVar = NULL;
	BSTR * pStr;;

    //=======================================================================
    //  See if it is an array
    //=======================================================================
	// If the pointer sent is not NULL
   	if( lType & CIM_FLAG_ARRAY )
	{
		lType = CIM_FLAG_ARRAY;
    }

	if(pData)
	{
		switch( lType ){

			case DBTYPE_EMPTY:
				break; 

			case DBTYPE_NULL:
				break; 

			case DBTYPE_ARRAY:
				pVar = (VARIANT *)pData;
				hr = SafeArrayDestroy((SAFEARRAY *)pData);
				break;

			case DBTYPE_I1:
			case DBTYPE_UI1:
				memset(pData,0,sizeof(BYTE));
				break;

			case DBTYPE_BOOL:
			case DBTYPE_I2:
			case DBTYPE_UI2:
				memset(pData,0,sizeof(short));
				break;

			case DBTYPE_R4:
			case DBTYPE_UI4:
			case DBTYPE_I4:
				memset(pData,0,sizeof(long));
				break;

			case DBTYPE_R8:
			case DBTYPE_I8:
			case DBTYPE_UI8:
				memset(pData,0,8);
				break;

			case DBTYPE_DBTIMESTAMP:
				memset(pData,0,sizeof(DBTIMESTAMP));
				break;

			case DBTYPE_BSTR:
				pStr = (BSTR *)pData;
				SysFreeString(*pStr);
				break;

			case DBTYPE_STR:
				wcscpy((WCHAR *)pData,L"");


			case DBTYPE_VARIANT:
				hr = VariantClear((VARIANT *)pData);
				break;

			case DBTYPE_DATE:
				memset(pData,0,sizeof(DATE));
				break;

			case DBTYPE_WSTR:
				memset(pData,0,sizeof(WCHAR));
				break;

			case DBTYPE_IUNKNOWN:
				pData = NULL;
				break;

			default:
				assert( !"Unmatched OLEDB Data Type to CIMTYPE." );
		}
	}
	if(hr  == S_OK)
		pData = NULL;
    
    return hr;
}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Convert a SAFEARRAY or any type to SAFEARRAY of VARIANT
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataMap::ConvertToVariantArray(SAFEARRAY *pArray,DBTYPE dwSrcType,SAFEARRAY ** ppArrayOut)
{
	DWORD dwStatus = 0;
	return ConvertAndCopyArray(pArray, ppArrayOut, dwSrcType,VT_ARRAY|VT_VARIANT,&dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\cwbemwrap.h ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CWBEMWRAP.h | CWbem* class Header file. These are classes talking to WMI
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _CWBEMWRAP_HEADER
#define _CWBEMWRAP_HEADER

#include <wbemcli.h>
#include <oahelp.inl>

BOOL UnicodeToAnsi(WCHAR * pszW, char *& pAnsi);
void AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW);
BOOL AllocateAndCopy( WCHAR *& pwcsDestination, WCHAR * pwcsSource );
HRESULT MapWbemErrorToOLEDBError(HRESULT hrToMap);


#define DEFAULT_NAMESPACE   L"ROOT\\DEFAULT"
#define ROOT_NAMESPACE      L"ROOT"

class CQuery;

typedef enum _InstanceListType
{
	NORMAL,		// normal query which returns homogenous objects 
	MIXED,		// query which returns heterogenours objects
	SCOPE,		// instance list showing list of objects in scope
	CONTAINER,   // instance list showing list of objects in container

}INSTANCELISTTYPE;



template <class T> class CCOMPointer
{
	T* p;
public:
	CCOMPointer()
	{
		p=NULL;
	}
	CCOMPointer(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CCOMPointer(const CCOMPointer<T>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CCOMPointer()
	{
		if (p)
		{
			p->Release();
			p = NULL;
		}
	}
	operator T*() const
	{
		return (T*)p;
	}
	T& operator*() const
	{
		ATLASSERT(p!=NULL);
		return *p;
	}

};


class CWbemSecurityDescriptor
{
private:
	IWbemClassObject  * m_pAccessor;
	IWbemServicesEx	  *	m_pISerEx;
	CVARIANT        	m_sd;
	BSTR				m_strPath;
	IWbemContext *		m_pIContext;
	ULONG				m_lSdSize;

public:
	CWbemSecurityDescriptor();
	~CWbemSecurityDescriptor();
	HRESULT Init(IWbemServices *pSer,BSTR strPath,IWbemContext *pContext);
	PSECURITY_DESCRIPTOR GetSecurityDescriptor() { return (PSECURITY_DESCRIPTOR) &m_sd; }
	HRESULT PutSD();
	BOOL GetSID(TRUSTEE_W *pTrustee ,PSID & psid);

	
};

/////////////////////////////////////////////////////////////////////////////////////////////
class CWbemConnectionWrapper
{
	public:

		~CWbemConnectionWrapper();
        CWbemConnectionWrapper();
		HRESULT FInit() { return m_PrivelagesToken.FInit();}
//        CWbemConnectionWrapper(CWbemConnectionWrapper *pWrap , WCHAR *pstrPath,INSTANCELISTTYPE instListType );
		HRESULT FInit(CWbemConnectionWrapper *pWrap , WCHAR *pstrPath,INSTANCELISTTYPE instListType );
        void InitVars();
		
        //=========================================================
        //  Connection handling functions
        //=========================================================

        HRESULT GetConnectionToWbem(void);
        BOOL    ValidConnection(); 

        //=========================================================
        //  Namespace functions
        //=========================================================
        void SetValidNamespace(VARIANT *v);
        WCHAR * GetNamespace();

        void SetUserInfo(BSTR strUser,BSTR strPassword,BSTR strAuthority);

        IWbemServices* GetServicesPtr();
        IWbemContext * GetContext()        { return m_pCtx; }
		void		   SetConnAttributes(DWORD dwAuthnLevel , DWORD dwImpLevel);
        HRESULT		   DeleteClass(BSTR strClassName);
		BOOL		   AdjustTokenPrivileges(ULONG cProps , DBPROP rgProp[]) 
		{ return m_PrivelagesToken.AdjustTokenPrivileges(cProps,rgProp); }

		BOOL		   AdjustTokenPrivileges(ULONG ulProp) 
		{ return m_PrivelagesToken.AdjustTokenPrivileges(ulProp); }

		void			SetLocale(LONG lLocaleID);
		// transaction related functions
		HRESULT BeginTransaction(ULONG uTimeout,ULONG uFlags,GUID *pTransGUID);
		HRESULT CompleteTransaction(BOOL bRollBack,ULONG uFlags);

		HRESULT CreateNameSpace();
		HRESULT DeleteNameSpace();
		HRESULT GetObjectAccessRights(BSTR strPath,
									  ULONG  *pcAccessEntries,
									  EXPLICIT_ACCESS_W **prgAccessEntries,
									  ULONG  ulAccessEntries = 0,
									  EXPLICIT_ACCESS_W *pAccessEntries = NULL);

		HRESULT SetObjectAccessRights(BSTR strPath,
									  ULONG  ulAccessEntries,
									  EXPLICIT_ACCESS_W *pAccessEntries);
		
		HRESULT SetObjectOwner(BSTR strPath,TRUSTEE_W  *pOwner);
		HRESULT GetObjectOwner(BSTR strPath,TRUSTEE_W  ** ppOwner);
		BOOL	IsValidObject(BSTR strPath);
		HRESULT IsObjectAccessAllowed( BSTR strPath,EXPLICIT_ACCESS_W *pAccessEntry,BOOL  *pfResult);
		// function to get the class name given the object path
		// used in case of direct binding and UMI paths
		HRESULT GetParameters(BSTR strPath,BSTR &strClassName,BSTR *pstrNameSpace = NULL);
		HRESULT GetClassName(BSTR strPath,BSTR &strClassName);
		// 07/12/2000
		// NTRaid : 142348
		HRESULT ExecuteQuery(CQuery *pQuery); // function which executes Action queries
		HRESULT GetNodeName(BSTR &strNode);		// function which gets the pointer to the
												// the object for which it is pointing

	private:
		IWbemServices * m_pIWbemServices;
        IWbemContext  * m_pCtx;
        CVARIANT        m_vNamespace;
		DWORD			m_dwAuthnLevel;        //Authentication level to use
		DWORD			m_dwImpLevel;          //Impersonation level to use
		BSTR			m_strUser;				// UserID
		BSTR			m_strPassword;			// Password
		BSTR			m_strAuthority;
		CPreviligeToken	m_PrivelagesToken;		// For Setting Token privelege
		BSTR			m_strLocale;
		CWbemConnectionWrapper *m_pDataSourceCon;
  		
};

class CWbemClassWrapper;
//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemClassParameters
{

    public:
        WCHAR *                     m_pwcsClassName;
        DWORD                       m_dwFlags;
        DWORD                       m_dwNavFlags;
		DWORD						m_dwQueryFlags;
        CWbemConnectionWrapper *    m_pConnection;
		WCHAR	*					m_pwcsParentClassName;
		BOOL						m_bSystemProperties;			// Indicates , if system properties 
		IWbemContext *				m_pIContext;

																	// to be fetched or not

        CWbemClassParameters(DWORD dwFlags,WCHAR * pClassName,CWbemConnectionWrapper * pWrap );
//		CWbemClassParameters(DWORD dwFlags,IDispatch *pDisp,CWbemConnectionWrapper * pWrap );

        ~CWbemClassParameters();

        WCHAR * GetClassName();
        void	SetParentClassName( WCHAR * p ){ AllocateAndCopy( m_pwcsParentClassName,p);}
        void	SetClassName( WCHAR * p )      { AllocateAndCopy( m_pwcsClassName,p);}
        void	DeleteClassName()              { SAFE_DELETE_ARRAY(m_pwcsClassName);}

        WCHAR * GetSuperClassName() { return m_pwcsParentClassName; }
        DWORD	GetFlags()            { return m_dwFlags; }
        DWORD	GetNavigationFlags()  { return m_dwNavFlags; }
        DWORD	GetQueryFlags()  { return m_dwQueryFlags; }
		HRESULT GetClassNameForWbemObject(IWbemClassObject *pInst );
		void	SetEnumeratorFlags(DWORD dwFlags);
		void	SetQueryFlags(DWORD dwFlags);
		HRESULT	ParseClassName();
		void	SetSytemPropertiesFlag(BOOL bSystemProperties) { m_bSystemProperties = bSystemProperties;}
		HRESULT RemoveObjectFromContainer(BSTR strContainerObj,BSTR strObject);
		HRESULT AddObjectFromContainer(BSTR strContainerObj,BSTR strObject);
		HRESULT CloneAndAddNewObjectInScope(CWbemClassWrapper *pClass,BSTR strDstObj,WCHAR *& pstrNewPath);
		
		HRESULT	SetSearchPreferences(ULONG cProps , DBPROP rgProp[]);
		virtual IWbemServices* GetServicesPtr() { return m_pConnection->GetServicesPtr();}
        IWbemContext * GetContext()        { return m_pIContext; }
        
};

//////////////////////////////////////////////////////////////////////////////////////////////
// Class which manages the position for qualifiers
class 	CQualiferPos
{
	CFlexArray		m_QualifierPos;			// Array to store the qualifer names
	LONG_PTR		m_lPos;					// The current position
	FETCHDIRECTION	m_FetchDir;			// The current fetch direction
public:
	CQualiferPos();
	~CQualiferPos();

	void	RemoveAll();									// Remove all the elements from the array
	void	Remove(WCHAR *pwcsQualifier);					// Remove a particular element from the array
	WCHAR * operator [] (DBORDINAL nIndex);						// Operator overloading to get a particular elemtent
	HRESULT GetRelative (DBROWOFFSET lRelPos,WCHAR *&pwcsQualifier);// Get a element which is at a relative position to the current element
	//NTBug:111779
	// 06/13/00
	HRESULT	Add(WCHAR *pwcsQualifier);						// Add an element to the array
	HRESULT SetRelPos(DBROWOFFSET lRelative);						// Set the relation position
	FETCHDIRECTION	GetDirFlag()			{ return m_FetchDir ;}	// Get the current fetch direction
	void	SetDirFlag(FETCHDIRECTION DirFlag)	{ m_FetchDir = DirFlag;}	// Set the direction of fetch

};

//////////////////////////////////////////////////////////////////////////////////////////////
// Class to manage property qualifers for a instance/class
class CWbemPropertyQualifierWrapper
{
public:
    
	IWbemQualifierSet*  m_pIWbemPropertyQualifierSet;
	WCHAR			 *	m_pwstrPropertyName;
	CQualiferPos		m_QualifierPos;
	

	CWbemPropertyQualifierWrapper()
	{
		m_pIWbemPropertyQualifierSet	= NULL;
		m_pwstrPropertyName			= NULL;
	}

	~CWbemPropertyQualifierWrapper()
	{
		SAFE_RELEASE_PTR(m_pIWbemPropertyQualifierSet);
		SAFE_DELETE_PTR(m_pwstrPropertyName);
		m_QualifierPos.RemoveAll();
	}

};

//////////////////////////////////////////////////////////////////////////////////////////////
// Class which contains a list of Property qualifer set pointers
class CWbemPropertyQualifierList
{
        CFlexArray               m_QualifierList;
public:
	~CWbemPropertyQualifierList();

	//NTBug:111779
	// 06/13/00
	HRESULT				Add(IWbemQualifierSet* pQualifierSet,WCHAR *pwstrPropertyName);	// Add a name to the qualifier list
	void				Remove(WCHAR *pwstrPropertyName);								// Remove a qualifier from the list
	IWbemQualifierSet*	GetPropertyQualifierSet(WCHAR *pwstrPropertyName);				// Get the qualiferset pointer
	void				RemoveAll();													// Remove all the elements
	CQualiferPos	*	GetQualiferPosObject(WCHAR *pwcsProperty);						// Get the CQualifierPos pointer
};


//////////////////////////////////////////////////////////////////////////////////////////////
// Works with just one class
class CWbemClassWrapper 
{

    protected:
        CWbemClassParameters *      m_pParms;

        IWbemClassObject *          m_pClass;
   	    IWbemQualifierSet*          m_pIWbemClassQualifierSet;
   	    IWbemQualifierSet*          m_pIWbemPropertyQualifierSet;
		CWbemPropertyQualifierList	m_pPropQualifList;
		CQualiferPos				m_QualifierPos;

		HRESULT GetClassName(IDispatch *pDisp );    

    public:

        CWbemClassWrapper( CWbemClassParameters * p);
        ~CWbemClassWrapper();


        //=========================================================
        //  Utility functions
        //=========================================================
        HRESULT SetClass(IWbemClassObject * p);
        IWbemClassObject * GetClass()       { return m_pClass ;}
        IWbemClassObject ** GetClassPtr()   { return &m_pClass;}
        virtual HRESULT ValidClass();
        WCHAR * GetClassName()              { return m_pParms->GetClassName(); }
        void SetClassName( WCHAR * p )      { m_pParms->SetClassName(p); }
        DWORD GetFlags()                    { return m_pParms->GetFlags(); }
        DWORD GetNavigationFlags()          { return m_pParms->GetNavigationFlags(); }
        DWORD GetQueryFlags()          { return m_pParms->GetQueryFlags(); }

        //=========================================================
        //  Managing Properties
        //=========================================================
        HRESULT SetProperty(BSTR pProperty, VARIANT * vValue,CIMTYPE lType = -1 );

        virtual HRESULT BeginPropertyEnumeration();
        virtual HRESULT GetNextProperty(BSTR * pProperty, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor );
        virtual HRESULT EndPropertyEnumeration();
        HRESULT DeleteProperty(BSTR pProperty );
        virtual HRESULT TotalPropertiesInClass(ULONG & ulPropCount, ULONG &ulSysPropCount);
        HRESULT GetProperty(BSTR pProperty, VARIANT * var, CIMTYPE * pType = NULL ,LONG * plFlavor = NULL );

        //=========================================================
        //  Managing Qualifiers
        //=========================================================
        HRESULT SetPropertyQualifier(BSTR pProperty, BSTR Qualifier, VARIANT * vValue, LONG lQualifierFlags );
        HRESULT DeletePropertyQualifier(BSTR pProperty, BSTR Qualifier );
 		HRESULT TotalPropertyQualifier(BSTR strPropName , ULONG & ulCount );	
        HRESULT GetPropertyQualifier(BSTR  pPropertyQualifier, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor );
		HRESULT IsValidPropertyQualifier(BSTR strProperty);
		void	ReleaseAllPropertyQualifiers() { m_pPropQualifList.RemoveAll(); }
		void	ReleasePropertyQualifier(BSTR strQualifier) ;

		virtual HRESULT BeginPropertyQualifierEnumeration(BSTR strPropName);
        HRESULT GetNextPropertyQualifier(BSTR pProperty,BSTR * pPropertyQualifier, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor );
        HRESULT GetPrevPropertyQualifier(BSTR pProperty,BSTR * pPropertyQualifier, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor );
        HRESULT GetPropertyQualifier(BSTR pProperty,BSTR PropertyQualifier, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor );
		HRESULT EndPropertyQualifierEnumeration();

		HRESULT IsValidClassQualifier();
        HRESULT GetNextClassQualifier(BSTR * pClassQualifier, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor );
        HRESULT GetPrevClassQualifier(BSTR * pClassQualifier, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor );
        HRESULT GetClassQualifier(BSTR ClassQualifier, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor );
		HRESULT	ReleaseClassQualifier();
        HRESULT SetClassQualifier(BSTR Qualifier, VARIANT * vValue, LONG lQualifierFlags );

		HRESULT SetQualifierRelPos(DBROWOFFSET lRelPos ,BSTR strQualifierName = Wmioledb_SysAllocString(NULL));

		HRESULT GetKeyPropertyNames( SAFEARRAY **ppsaNames);
		
		CWbemClassWrapper * GetInstance(BSTR strPath);
};

//////////////////////////////////////////////////////////////////////////////////////////////
// Works with just one class
class CWbemClassDefinitionWrapper : public CWbemClassWrapper
{
	protected:
		BOOL			m_bSchema;
    public:
        CWbemClassDefinitionWrapper( CWbemClassParameters * p,BOOL bGetClass = TRUE);
        ~CWbemClassDefinitionWrapper();

		HRESULT Init(BOOL bGetClass) 
		{ 
			if(bGetClass) 
				return GetClass();
			else
				return S_OK;
		}

        //=========================================================
        //  Managing classes
        //=========================================================
        HRESULT GetEmptyWbemClass();
        HRESULT DeleteClass();
        HRESULT GetClass();

        HRESULT CreateClass();
        HRESULT DeleteClassQualifier(BSTR Qualifier );

		HRESULT SetClass( WCHAR *pClassName);
		HRESULT SaveClass(BOOL bNewClass = TRUE);
		HRESULT GetInstanceCount(ULONG_PTR &cInstance);
		BOOL	IsClassSchema() { return m_bSchema; }

};

//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemClassInstanceWrapper : public CWbemClassWrapper
{
    public:
        CWbemClassInstanceWrapper(CWbemClassParameters * p);
        ~CWbemClassInstanceWrapper();

        IWbemClassObject * GetClassObject()     { return m_pClass ;}
        virtual WCHAR * GetInstanceName()               { return GetClassName(); }

        virtual HRESULT ResetInstanceFromKey(CBSTR Key);
        virtual HRESULT GetKey(CBSTR & Key);
		void			SetPos(ULONG_PTR lPos) { m_lPos = lPos; }
		ULONG_PTR		GetPos() { return m_lPos; }
		virtual HRESULT RefreshInstance();
		virtual WCHAR * GetClassName();

 		DBSTATUS	GetStatus() { return m_dwStatus;}
		void		SetStatus(DBSTATUS dwStatus) { m_dwStatus = dwStatus; }

		HRESULT		CloneInstance(IWbemClassObject *& pInstance);
		HRESULT		GetRelativePath(WCHAR *& pstrRelPath);

    protected:
		ULONG_PTR	m_lPos;
		DBSTATUS	m_dwStatus;

};

//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemInstanceList 
{
    protected:

        CFlexArray               m_List;
        CWbemClassParameters *      m_pParms;
        CRITICAL_SECTION            m_InstanceCs;
        IEnumWbemClassObject  *     m_ppEnum;
		ULONG_PTR					m_lCurrentPos;
		FETCHDIRECTION				m_FetchDir;
        int							m_nBaseType;
		ULONG_PTR					m_cTotalInstancesInEnum;

    public:
        CWbemInstanceList(CWbemClassParameters * p);
        ~CWbemInstanceList();

        //======================================================================
        //  Critical section handling
        //======================================================================
        inline void Enter() {EnterCriticalSection(&m_InstanceCs);}
        inline void Leave() {LeaveCriticalSection(&m_InstanceCs);}

        int TotalInstances();

        HRESULT ReleaseAllInstances();
        HRESULT ReleaseInstance(CWbemClassInstanceWrapper *& pClass);

        virtual HRESULT Reset();
        virtual HRESULT NextInstance(CBSTR & Key, CWbemClassInstanceWrapper ** p);
		virtual HRESULT PrevInstance( CBSTR & Key, CWbemClassInstanceWrapper *& p);

        HRESULT FindInstancePosition( CWbemClassInstanceWrapper * pClass, int & nPosition );
        HRESULT DeleteInstance( CWbemClassInstanceWrapper *& pClass );

        HRESULT AddInstance( CWbemClassInstanceWrapper * pClass );
        HRESULT UpdateInstance(CWbemClassInstanceWrapper * pInstance , BOOL bNewInst);
        HRESULT AddInstanceNew( CWbemClassInstanceWrapper ** ppNewClass );
		HRESULT AddNewInstance(CWbemClassWrapper *pClassWrappper ,CWbemClassInstanceWrapper ** ppNewClass  );
		HRESULT ResetRelPosition( DBROWOFFSET lPos );

//		CWbemClassInstanceWrapper * AddInstanceToList( IUnknown *pDisp,CBSTR & Key);
		CWbemClassInstanceWrapper * GetInstance( ULONG_PTR lPos );
		HRESULT  GetNumberOfInstanceInEnumerator(ULONG_PTR *pcInstance=NULL);
		FETCHDIRECTION	 GetCurFetchDirection() { return m_FetchDir; }
		void	 SetCurFetchDirection(FETCHDIRECTION FetchDir) { m_FetchDir = FetchDir; }
};

//////////////////////////////////////////////////////////////////////////////////////////////
// Works with just the rowsets generated by queries
//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemCommandClassDefinitionWrapper;
class CQuery;
class CWbemCommandInstanceList;
class CWbemCommandInstanceWrapper;
class CWbemCommandParameters;
///////////////////////////////////////////////////////////////////////////////////////////////////
class CWbemCommandManager 
{

    public:
        BOOL ValidQuery();
        HRESULT ValidQueryResults();

        CWbemCommandManager(CQuery * p);
        ~CWbemCommandManager();

        void Init(CWbemCommandInstanceList * InstanceList, CWbemCommandParameters * pParms,CWbemCommandClassDefinitionWrapper* pDef);
        HRESULT GetClassDefinitionForQueryResults();
		INSTANCELISTTYPE GetObjListType();


    private:

        CQuery * m_pQuery;

        CWbemCommandClassDefinitionWrapper  * m_pClassDefinition;
        CWbemCommandInstanceList            * m_pInstanceList;
        CWbemCommandInstanceWrapper         * m_pInstance;
        CWbemCommandParameters              * m_pParms;



};
//////////////////////////////////////////////////////////////////////////////////////////////
class  CWbemCommandClassDefinitionWrapper : public CWbemClassDefinitionWrapper
{
    private:
        int                         m_nMaxColumns;
        CWbemCommandManager *       m_pCmdManager;
		INSTANCELISTTYPE			m_objListType;			// Method Storing type of the command.
					

    public:
        CWbemCommandClassDefinitionWrapper(CWbemClassParameters * p,CWbemCommandManager * pWbemCommandManager);
        ~CWbemCommandClassDefinitionWrapper();

        HRESULT ValidClass();

        HRESULT TotalPropertiesInClass(ULONG & ulPropCount, ULONG &ulSysPropCount);
		HRESULT	SetQueryType(LPCWSTR strQry,GUID QryDialect,LPCWSTR strQryLang = NULL);
		
		INSTANCELISTTYPE GetObjListType() { return m_objListType; }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
class CWbemCommandInstanceList: public CWbemInstanceList 
{
    private:
        ULONG m_ulMaxRow;
        CWbemCommandManager *       m_pCmdManager;
	    LPWSTR			            m_pwstrQuery;		        // current Query
		LPWSTR						m_pwstrQueryLanguage;

    public:
        CWbemCommandInstanceList(CWbemClassParameters * p,CWbemCommandManager * pWbemCommandManager);
        ~CWbemCommandInstanceList();

        HRESULT SetQuery( LPWSTR p,GUID QryDialect,LPCWSTR strQryLang = NULL);
		WCHAR*	GetQuery()						{ return m_pwstrQuery;}
		WCHAR*	GetQueryLanguage()				{return m_pwstrQueryLanguage; }
        virtual HRESULT Reset();

};

//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemCommandInstanceWrapper : public CWbemClassInstanceWrapper
{
    private:
            CWbemCommandManager *       m_pCmdManager;

    public:
        CWbemCommandInstanceWrapper(CWbemClassParameters * p,CWbemCommandManager * pWbemCommandManager);
        ~CWbemCommandInstanceWrapper();

		virtual WCHAR * GetClassName();
        virtual HRESULT GetKey(CBSTR & Key);
 		virtual HRESULT RefreshInstance();


};

///////////////////////////////////////////////////////////////////////////////////////////////////
class CWbemCommandParameters :public CWbemClassParameters
{

    public:
        CWbemCommandParameters(DWORD dwFlags,CWbemConnectionWrapper * Connect,CWbemCommandManager * pWbemCommandManager);
        ~CWbemCommandParameters();

        inline CWbemCommandManager * GetCommandManagerPtr()        { return m_pCmdManager;}

    private:
        CWbemCommandManager *       m_pCmdManager;

};
//////////////////////////////////////////////////////////////////////////////////////////////
// Works with just the rowsets that deal with Methods
//////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
class CWbemMethodParameters :public CWbemClassParameters
{

    public:
        CWbemMethodParameters(CQuery * p, DWORD dwFlags,CWbemConnectionWrapper * Connect);
        ~CWbemMethodParameters();

        HRESULT ExtractNamesFromQuery();
        HRESULT ValidMethod();

        WCHAR * GetInstanceName()   { return m_pwcsInstance; }
        WCHAR * GetMethodName()     { return m_pwcsMethod;}
        CQuery *                    m_pQuery;

    private:
        WCHAR *                     m_pwcsInstance;
        WCHAR *                     m_pwcsMethod;

};

class  CWbemMethodClassDefinitionWrapper : public CWbemClassDefinitionWrapper
{
    private:
        int  m_nMaxColumns;
        int  m_nCount;
        IWbemClassObject * m_pInClass;

    public:
        CWbemMethodClassDefinitionWrapper(CWbemMethodParameters * parm);
        ~CWbemMethodClassDefinitionWrapper();

        IWbemClassObject * GetInputClassPtr()   { return m_pInClass; }

        HRESULT Init();
        HRESULT ValidClass();

        HRESULT TotalPropertiesInClass(ULONG & ulPropCount, ULONG &ulSysPropCount);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
class CWbemMethodInstanceList: public CWbemInstanceList 
{
    private:
        ULONG m_ulMaxRow;
        CWbemMethodClassDefinitionWrapper * m_pClassDefinition;

    public:
        CWbemMethodInstanceList(CWbemMethodParameters * p,CWbemMethodClassDefinitionWrapper * pDef);
        ~CWbemMethodInstanceList();

        virtual HRESULT Reset();
        virtual HRESULT NextInstance(CBSTR & Key, CWbemClassInstanceWrapper ** p);
		virtual HRESULT PrevInstance( CBSTR & Key, CWbemClassInstanceWrapper *& p);

        HRESULT ProcessInputParameters(IWbemClassObject **ppParamInput);
        HRESULT ProcessOutputParameters();
		HRESULT GetInputParameterName(IWbemClassObject *pObject,DBORDINAL iOrdinal , BSTR &strPropName);

};

//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemMethodInstanceWrapper : public CWbemClassInstanceWrapper
{
    private:

    public:
        CWbemMethodInstanceWrapper(CWbemMethodParameters * p);
        ~CWbemMethodInstanceWrapper();

        virtual HRESULT ResetInstanceFromKey(CBSTR Key);
 		virtual HRESULT RefreshInstance();
		virtual WCHAR * GetClassName();
        virtual HRESULT GetKey(CBSTR & Key);

};



class CWbemCollectionInstanceList;
class CWbemCollectionInstanceWrapper;

//////////////////////////////////////////////////////////////////////////////////////////////
// Works with just the rowsets that deal with Methods
//////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
class CWbemCollectionParameters : public CWbemClassParameters
{

    public:
        CWbemCollectionParameters(DWORD dwFlags,CWbemConnectionWrapper * pWrap ,WCHAR *pClassName);
        ~CWbemCollectionParameters();


		virtual IWbemServices* GetServicesPtr() { return m_pServices;}
		HRESULT Init(BSTR strPath,CWbemConnectionWrapper * pWrap); 

    private:
	IWbemServices * m_pServices;

};

class  CWbemCollectionClassDefinitionWrapper : public CWbemClassDefinitionWrapper
{
    private:
		INSTANCELISTTYPE	m_objListType;			// Method Storing type of the command.
		WCHAR *				m_pstrPath;
						

    public:
        CWbemCollectionClassDefinitionWrapper(CWbemClassParameters * p,WCHAR * pstrPath,INSTANCELISTTYPE colType);
        ~CWbemCollectionClassDefinitionWrapper();

		HRESULT Initialize(WCHAR * pstrPath);
        HRESULT ValidClass();
        HRESULT TotalPropertiesInClass(ULONG & ulPropCount, ULONG &ulSysPropCount);
		
		INSTANCELISTTYPE GetObjListType() { return m_objListType; }
		WCHAR *GetObjectPath() { return m_pstrPath; }
};

class CWbemCollectionManager 
{

    public:

        CWbemCollectionManager();
        ~CWbemCollectionManager();

        void Init(CWbemCollectionInstanceList * InstanceList, 
					CWbemCollectionParameters * pParms,
					CWbemCollectionClassDefinitionWrapper * pDef);

		INSTANCELISTTYPE GetObjListType() { return m_pClassDefinition->GetObjListType(); }
		WCHAR *GetObjectPath() { return  m_pClassDefinition->GetObjectPath(); }


    private:


        CWbemCollectionClassDefinitionWrapper	* m_pClassDefinition;
        CWbemCollectionInstanceList				* m_pInstanceList;
        CWbemCollectionInstanceWrapper			* m_pInstance;
        CWbemCollectionParameters				* m_pParms;



};


class CWbemCollectionInstanceWrapper : public CWbemClassInstanceWrapper
{
    private:
            CWbemCollectionManager *       m_pColMgr;

    public:
        CWbemCollectionInstanceWrapper(CWbemClassParameters * p,CWbemCollectionManager * pWbemColMgr = NULL);
        ~CWbemCollectionInstanceWrapper();

		virtual WCHAR * GetClassName();
        virtual HRESULT GetKey(CBSTR & Key);
 		virtual HRESULT RefreshInstance();


};


// Class to represent instance list for scope/collection
class CWbemCollectionInstanceList: public CWbemInstanceList 
{
	private:
		CWbemCollectionManager *m_pColMgr;

    public:
        CWbemCollectionInstanceList(CWbemClassParameters * p,CWbemCollectionManager * pCollectionMgr);
        ~CWbemCollectionInstanceList();
        virtual HRESULT Reset();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\dataconvert.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  dataconvert.h
//
////////////////////////////////////////////////////////////////////////////

typedef LONG_PTR HSLOT;
#define MAX_CIM_STRING_SIZE -1

#ifndef __DATA_CONVERT_H__
#define __DATA_CONVERT_H__

class CDataMap
{

		HRESULT AllocateData(DBTYPE dwType,void *& pData,DBLENGTH &dwLength);
		BOOL	IsValidDBTimeStamp(DBTIMESTAMP *pTimeStamp);
		BOOL	IsSafeArrayEmpty(SAFEARRAY *psa);
		BOOL	IsDateType(DWORD dwType);
		HRESULT ConvertDateTypes(DWORD		dwSrcType,
								DWORD		dwDstType,
								DBLENGTH	dwSrcLen,
								DBLENGTH*	pdwDstLen,
								void  *		pSrc,
								void * &	pDst,
								DBLENGTH	dbDstLen,
								DWORD *		pdwStatus);

    public:
        CDataMap()  {};
        ~CDataMap() {};

        HRESULT MapOLEDBTypeToCIMType(WORD dwDataType, long & dwCIMType );
        HRESULT MapCIMTypeToOLEDBType(long lType, WORD & dwdbOLEDBType, DBLENGTH & uColumnSize , DWORD &dwFlags);
        HRESULT FreeData(DBTYPE lType, BYTE *& pData);
        HRESULT AllocateAndMapCIMTypeToOLEDBType(CVARIANT & vValue,BYTE *& pData,DBTYPE &dwColType,DBLENGTH & dwSize, DWORD &dwFlags);
		HRESULT MapAndConvertOLEDBTypeToCIMType(DBTYPE wDataType, void *pData ,DBLENGTH dwSrcLength,VARIANT &varData,LONG_PTR dwArrayCIMType = -1);
		HRESULT ConvertVariantType(VARIANT &varSrc, VARIANT varDst ,CIMTYPE lType);
		BOOL	CompareData(DWORD dwType,void * pData1 , void *pData2);

		// Array conversion functions
		HRESULT ConvertAndCopyArray(SAFEARRAY *psaSrc, SAFEARRAY **psaDst, DBTYPE dwSrcType,DBTYPE dwDstType,DBSTATUS *pdwStatus);
		HRESULT ConvertToVariantArray(SAFEARRAY *pArray,DBTYPE dwSrcType,SAFEARRAY ** ppArrayOut);

		// Date conversion functions
		HRESULT ConvertOledbDateToCIMType(VARIANT *vTimeStamp,BSTR &strDate);
		HRESULT ConvertDateToOledbType(BSTR strDate,DBTIMESTAMP *pTimeStamp);
		HRESULT ConvertVariantDateOledbDate(DATE *pDate,DBTIMESTAMP *pTimeStamp);
		HRESULT ConvertOledbDateToCIMType(DBTIMESTAMP *pTimeStamp,BSTR &strDate);
		HRESULT ConvertVariantDateToCIMType(DATE *pDate,BSTR &strDate);
		
		HRESULT ClearData(DBTYPE lType, void * pData);
		HRESULT ConvertToCIMType(BYTE *pData, DBTYPE lType ,DBLENGTH lDataLength,LONG lCIMType ,VARIANT &varData);
		HRESULT AllocateAndConvertToOLEDBType(VARIANT &varData,LONG lCimType , DBTYPE lOledbType,BYTE *&pData, DBLENGTH &lDataLength, DBSTATUS &dwStatus);
	
        HRESULT TranslateParameterStringToOLEDBType( DBTYPE & wDataType, WCHAR * str) ;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\cwbemwrap.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CWBEMWRAP.CPP | CWbem* class implementation. These are classes talking to WMI
//
// NTRaid:: 139685 Transaction support removed
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define _WIN32_DCOM

#include "headers.h"
//#include <wbemprov.h>

#define CLASSSEPARATOR	L"."
#define WBEMERROR_QUALIFIER_NOT_FOUND		0x80043000
#define WBEMERROR_PROPERTY_NOT_FOUND		0x80043001
#define WBEMERROR_QUALIFER_TOBE_FETCHED		0x80043001
#define NUMBEROFINSTANCESTOBEFETCHED		50
#define	LOCALESTRING_MAXSIZE				40
#define SEARCHPREFERENCE_NAMESIZE			128

const WCHAR szSelectCountQry[]	= L"select __PATH from ";
const WCHAR szWhereClause[]		= L" WHERE __CLASS=\"";
const WCHAR szDoubleQuotes[]	= L"\"";
const WCHAR szReferenceOfQry[]	= L"REFERENCES";
const WCHAR szAssociatersQry[]	= L"ASSOCIATORS";
const WCHAR szWQL[]				= L"WQL";
const WCHAR szLDAP[]			= L"LDAP";
const WCHAR szLDAPSQL[]			= L"SQL";
const WCHAR szInstance[]		= L"WMIInstance";
const WCHAR	szCollection[]		= L"Collection";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AllocateAndCopy( WCHAR *& pwcsDestination, WCHAR * pwcsSource )
{
    BOOL fRc = FALSE;
    if( wcslen( pwcsSource ) > 0){
        pwcsDestination = new WCHAR[wcslen(pwcsSource)+2];
        wcscpy(pwcsDestination,pwcsSource);
        fRc = TRUE;
    }
    return fRc;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT MapWbemErrorToOLEDBError(HRESULT hrToMap)
{
    HRESULT hr = E_FAIL;
    switch( hrToMap ){

        case WBEM_S_NO_MORE_DATA:
			hr = WBEM_S_NO_MORE_DATA;
			break;

        case S_OK:
            hr = S_OK;
            break;

		case WBEM_E_ACCESS_DENIED :
			hr = DB_SEC_E_PERMISSIONDENIED;
			LogMessage("Access denied to do this operation" , hr);
			break;

		case WBEM_E_CANNOT_BE_KEY:
			hr = DB_E_ERRORSOCCURRED;
			LogMessage("Error in setting a property as Key" , hr);
			break;

		case WBEM_E_NOT_FOUND :
            hr = E_UNEXPECTED;
			LogMessage("Object not found" , hr);
			break;

		case WBEM_E_INVALID_CLASS :
			hr = DB_E_NOTABLE;
			LogMessage("The class specified is not present" , hr);
			break;

		case WBEMERROR_PROPERTY_NOT_FOUND :
			hr = DB_E_BADCOLUMNID;
			LogMessage("Object not found" , hr);
			break;


		case WBEM_E_INVALID_OPERATION :
			hr = DB_E_DROPRESTRICTED;
			LogMessage("Provider not able to drop do the operation as the operation is invalid" , hr);
			break;

		case WBEMERROR_QUALIFIER_NOT_FOUND :
			hr = DB_E_BADCOLUMNID;
			LogMessage("Qualifier does not exist" , hr);
			break;

		case WBEM_E_PROPAGATED_PROPERTY :
			hr = DB_E_DROPRESTRICTED;
			LogMessage("Error due to attempt to delete a property that was not owned" , hr);
			break;

		case WBEM_E_INVALID_NAMESPACE:
			hr = DB_E_ERRORSOCCURRED;
			LogMessage("Invalid Namespace" , hr);
			break;

		case E_ACCESSDENIED:
			hr = DB_SEC_E_PERMISSIONDENIED;
			LogMessage("Acess Denied" , hr);
			break;

		case WBEM_E_INVALID_QUERY:
			hr = DB_E_ERRORSINCOMMAND;
			LogMessage("Error in the query string" , hr);
			break;

 		case WBEM_E_PROVIDER_NOT_CAPABLE:
			hr = WBEM_E_PROVIDER_NOT_CAPABLE;
			break;

		case DB_E_ALREADYINITIALIZED:
			hr = DB_E_ALREADYINITIALIZED;
			break;

		case WBEM_E_OUT_OF_MEMORY:
		case E_OUTOFMEMORY:
			hr = E_OUTOFMEMORY;
			break;

		//NTRaid 138547
		case WBEM_E_LOCAL_CREDENTIALS:
			hr = DB_E_ERRORSOCCURRED;
			LogMessage("User Name and password cannot be given for local machine" , hr);
			break;

		// NTRaid:144995
		case WBEM_E_TRANSPORT_FAILURE:
		case HRESULT_FROM_WIN32(RPC_S_CALL_FAILED_DNE):
		case HRESULT_FROM_WIN32(RPC_S_CALL_FAILED):
		case HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE):
			hr = E_FAIL;
			LogMessage("Connection broken due to RPC failure" , hr);
			break;

		case WBEM_E_INVALID_QUERY_TYPE:
			hr = DB_E_ERRORSINCOMMAND;
			LogMessage("Invalid Query Type" , hr);
			break;

		case S_FALSE:
			hr = S_FALSE;
			break;

		default:
            hr = E_UNEXPECTED;
    }
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemConnectionWrapper::CWbemConnectionWrapper()
{
//   	HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);     
//    CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_NONE, 0  );
    InitVars();
}

HRESULT CWbemConnectionWrapper::FInit(CWbemConnectionWrapper *pWrap , WCHAR *pstrPath,INSTANCELISTTYPE instListType )
{
	HRESULT hr = S_OK;
    InitVars();
	CBSTR strPath(pstrPath);
	IWbemServicesEx *pSerEx = NULL;
	LONG lFlag = instListType == SCOPE ? WBEM_FLAG_OPEN_SCOPE : WBEM_FLAG_OPEN_COLLECTION;
	// Call the function to initialize the
	hr = m_PrivelagesToken.FInit();
	if(SUCCEEDED(hr) && SUCCEEDED(pWrap->GetServicesPtr()->QueryInterface(IID_IWbemServicesEx,(void **)&pSerEx)))
	{
		if(pstrPath)
		{
			IWbemServicesEx *pCollectionEx = NULL;
			if(SUCCEEDED(hr =pSerEx->Open(strPath,NULL,lFlag,NULL,&pCollectionEx,NULL)))
			{
				if(SUCCEEDED(hr = pCollectionEx->QueryInterface(IID_IWbemServices,(void **)&m_pIWbemServices)))
				{
					m_pDataSourceCon = pWrap;
				}
			}
		}
		else
		{
			hr = pSerEx->QueryInterface(IID_IWbemServices,(void **)&m_pIWbemServices);
		}
		SAFE_RELEASE_PTR(pSerEx);
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemConnectionWrapper::~CWbemConnectionWrapper()
{
 //   CoUninitialize();
	SAFE_RELEASE_PTR(m_pIWbemServices);
	SAFE_RELEASE_PTR(m_pCtx);
	if(m_strUser)
	{
		SysFreeString(m_strUser);
	}
	if(m_strPassword)
	{
		SysFreeString(m_strPassword);
	}
	if(m_strLocale)
	{
		SysFreeString(m_strLocale);
	}
	if(m_strAuthority)
	{
		SysFreeString(m_strAuthority);
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWbemConnectionWrapper::InitVars()
{
    m_vNamespace.SetStr(DEFAULT_NAMESPACE);

    m_pIWbemServices	= NULL;
	m_pCtx				= NULL;
	m_dwAuthnLevel		= RPC_C_IMP_LEVEL_IMPERSONATE;
	m_dwImpLevel		= RPC_C_AUTHN_LEVEL_CONNECT;
	m_strUser			= NULL;
	m_strPassword		= NULL;
	m_strLocale			= NULL;
	m_pDataSourceCon	= NULL;
	m_strAuthority		= NULL;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWbemConnectionWrapper::ValidConnection()
{ 
	BOOL bRet = FALSE;
    if( m_pIWbemServices ){
        bRet = TRUE;
    }
    if( S_OK == GetConnectionToWbem() ){
        bRet = TRUE;
    }
    return bRet;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWbemConnectionWrapper::SetValidNamespace(VARIANT * v)
{ 
    if((V_VT(v) == VT_NULL ) || (V_VT(v) == VT_EMPTY )){
        m_vNamespace.SetStr(DEFAULT_NAMESPACE);
    }
    else{
        m_vNamespace.SetStr(V_BSTR(v));
    }
}

void CWbemConnectionWrapper::SetUserInfo(BSTR strUser,BSTR strPassword,BSTR strAuthority)
{
	m_strUser		= Wmioledb_SysAllocString(strUser);
	m_strPassword	= Wmioledb_SysAllocString(strPassword);
	m_strAuthority	= Wmioledb_SysAllocString(strAuthority);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemConnectionWrapper::GetConnectionToWbem( void  )
{

	HRESULT hr = S_OK;
	IWbemLocator *pLoc = 0;
	IWbemServicesEx *pSer = NULL;

    hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pLoc);
    if(SUCCEEDED(hr )){

        hr = pLoc->ConnectServer(m_vNamespace,m_strUser, m_strPassword, m_strLocale,0, m_strAuthority, 0, &m_pIWbemServices );
        if( SUCCEEDED(hr)){
			IClientSecurity *pClientSecurity = NULL;
			if(SUCCEEDED(m_pIWbemServices->QueryInterface(IID_IClientSecurity,(void **)&pClientSecurity)))
			{
				hr = CoSetProxyBlanket( m_pIWbemServices,    RPC_C_AUTHN_WINNT,  RPC_C_AUTHN_NONE,   NULL,
										  m_dwAuthnLevel, m_dwImpLevel,   NULL,   EOAC_NONE );
				pClientSecurity->Release();
			}

			HRESULT hr1 = m_pIWbemServices->QueryInterface(IID_IWbemServicesEx,(void **)&pSer);
			SAFE_RELEASE_PTR(pSer);
        }
		pLoc->Release();
    }
	if(SUCCEEDED(hr) && !g_pIWbemCtxClassFac)
	{
		CoGetClassObject(CLSID_WbemContext,CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory,(void **)&g_pIWbemCtxClassFac);
	}
	if(hr == WBEM_E_NOT_FOUND)
	{
		hr = WBEM_E_INVALID_NAMESPACE;
	}
    return MapWbemErrorToOLEDBError(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the conneciton attributes for the connection
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWbemConnectionWrapper::SetConnAttributes(DWORD dwAuthnLevel , DWORD dwImpLevel)
{
	m_dwAuthnLevel	= dwAuthnLevel;
	m_dwImpLevel	= dwImpLevel;
}


//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemConnectionWrapper::DeleteClass(BSTR strClassName)
{
    HRESULT hr = m_pIWbemServices->DeleteClass(strClassName, 0,NULL,NULL);
	if(hr == WBEM_E_NOT_FOUND)
	{
		hr = WBEM_E_INVALID_CLASS;
	}

    return MapWbemErrorToOLEDBError(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Begin a transaction
// Removing transaction support as per alanbos mail ( core is removing the support)
// 06/30/2000
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemConnectionWrapper::BeginTransaction(ULONG uTimeout,ULONG uFlags,GUID *pTransGUID)
{
	HRESULT				hr			= S_OK;
/*	IWbemTransaction *	pWbemTrans	= NULL;
	IWbemServicesEx *pTest = NULL;

	if(SUCCEEDED(hr = GetServicesPtr()->QueryInterface(IID_IWbemTransaction,(void **)&pWbemTrans)))
	{
		hr = pWbemTrans->Begin(uTimeout,uFlags,pTransGUID);
	}
	
	SAFE_RELEASE_PTR(pWbemTrans);
*/
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Commit/Rollback a transaction
// Removing transaction support as per alanbos mail ( core is removing the support)
// 06/30/2000
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemConnectionWrapper::CompleteTransaction(BOOL bRollBack,ULONG uFlags)
{
	HRESULT				hr			= S_OK;
/*	IWbemTransaction *	pWbemTrans	= NULL;

	if(SUCCEEDED(hr = GetServicesPtr()->QueryInterface(IID_IWbemTransaction,(void **)&pWbemTrans)))
	{
		if(bRollBack)
		{
			hr = pWbemTrans->Rollback(uFlags);
		}
		else
		{
			hr = pWbemTrans->Commit(uFlags);
		}
	}
	
	SAFE_RELEASE_PTR(pWbemTrans);
*/
	return hr;
}

IWbemServices* CWbemConnectionWrapper::GetServicesPtr()
{
	return m_pIWbemServices;
}

WCHAR * CWbemConnectionWrapper::GetNamespace()
{ 
	WCHAR *pNameSpace = NULL;
	if(!m_pDataSourceCon)
	{
		pNameSpace = m_vNamespace.GetStr();
	}
	else
	{
		pNameSpace = m_pDataSourceCon->GetNamespace();
	}
	
	return  pNameSpace;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the Locale Identifier
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWbemConnectionWrapper::SetLocale(LONG lLocaleID)
{
	WCHAR wstrLocale[LOCALESTRING_MAXSIZE];
	swprintf(wstrLocale,L"MS_%x",lLocaleID);
	m_strLocale	= Wmioledb_SysAllocString(wstrLocale);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create an new namespace and initialize the wrapper
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemConnectionWrapper::CreateNameSpace()
{
	HRESULT hr = S_OK;
	BSTR	strNameSpace = NULL;
	BSTR	strParentNameSpace = NULL;
	CURLParser urlParser;

	if(m_pIWbemServices)
	{
		hr = DB_E_ALREADYINITIALIZED;
	}
	else
	{
		VARIANT varTemp;
		VariantInit(&varTemp);
		varTemp.vt = VT_BSTR;
		urlParser.SetPath(m_vNamespace.GetStr());
		if(SUCCEEDED(hr = urlParser.ParseNameSpace(strParentNameSpace,strNameSpace)))
		{
			varTemp.bstrVal = strParentNameSpace;
			SetValidNamespace(&varTemp);
			// connect to the Parent namespace
			if(SUCCEEDED(hr =GetConnectionToWbem()))
			{
				IWbemClassObject *pClass = NULL;
				CBSTR strNamespaceClass(L"__NameSpace");

				if(SUCCEEDED(hr = m_pIWbemServices->GetObject((BSTR)strNamespaceClass,WBEM_FLAG_RETURN_WBEM_COMPLETE,NULL,&pClass,NULL)))
				{
					// Create the namespace instance and save the object
					// after saving the name
					IWbemClassObject *pNewInstance = NULL;
					if(SUCCEEDED(hr = pClass->SpawnInstance(0,&pNewInstance)))
					{
						varTemp.bstrVal = strNameSpace;
						if(SUCCEEDED(hr = pNewInstance->Put(L"Name",0,&varTemp,CIM_STRING)) &&
							SUCCEEDED(hr = m_pIWbemServices->PutInstance(pNewInstance,WBEM_FLAG_CREATE_ONLY,NULL,NULL)))
						{
							// Open the namespace and replace the IWbemServices pointer to point to new namespcee
							IWbemServices *pTempSer = NULL;
							if(SUCCEEDED(hr = m_pIWbemServices->OpenNamespace(strNameSpace,WBEM_FLAG_RETURN_WBEM_COMPLETE,m_pCtx,&pTempSer,NULL)))
							{
								SAFE_RELEASE_PTR(m_pIWbemServices);
								pTempSer->QueryInterface(IID_IWbemServices,(void **)&m_pIWbemServices);
								SAFE_RELEASE_PTR(pTempSer);
							}
						}
					}
					SAFE_RELEASE_PTR(pNewInstance);
				}
			}
			SysFreeString(strParentNameSpace);
			SysFreeString(strNameSpace);
			urlParser.GetNameSpace(strNameSpace);
			varTemp.bstrVal = strNameSpace;

			// Set the correct namespace
			SetValidNamespace(&varTemp);
			SysFreeString(strNameSpace);

			hr = MapWbemErrorToOLEDBError(hr);
		}
	}
	
	if(FAILED(hr))
	{
		SAFE_DELETE_PTR(m_pIWbemServices);
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Delete a namespace
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemConnectionWrapper::DeleteNameSpace()
{
	HRESULT hr = S_OK;
	BSTR	strNameSpace = NULL;
	BSTR	strParentNameSpace = NULL;
	CURLParser urlParser;

	if(m_pIWbemServices == NULL)
	{
		hr = E_UNEXPECTED;
	}
	else
	{
		VARIANT varTemp;
		VariantInit(&varTemp);
		varTemp.vt = VT_BSTR;
		urlParser.SetPath(m_vNamespace.GetStr());
		if(SUCCEEDED(hr = urlParser.ParseNameSpace(strParentNameSpace,strNameSpace)))
		{
			// Store the pointer in temporary variable
			IWbemServices *pSerTemp = NULL;
			m_pIWbemServices->QueryInterface(IID_IWbemServices,(void **)&pSerTemp);
			
			SAFE_RELEASE_PTR(m_pIWbemServices);

			varTemp.bstrVal = strParentNameSpace;
			SetValidNamespace(&varTemp);
			// connect to the Parent namespace
			if(SUCCEEDED(hr =GetConnectionToWbem()))
			{
				WCHAR strNameSpaceObject[PATH_MAXLENGTH];
				wcscpy(strNameSpaceObject,L"");
				swprintf(strNameSpaceObject,L"__NAMESPACE.Name=\"%s\"",strNameSpace);

				CBSTR strNameSpacePath(strNameSpaceObject);

				// Delete the namespace instance
				if(FAILED(hr = m_pIWbemServices->DeleteInstance(strNameSpacePath,WBEM_FLAG_RETURN_WBEM_COMPLETE,m_pCtx,NULL)))
				{	
					SAFE_RELEASE_PTR(m_pIWbemServices);
					strNameSpacePath.Clear();
					urlParser.GetNameSpace((BSTR &)strNameSpacePath);
					varTemp.bstrVal = (BSTR)strNameSpacePath;
					// Set the correct namespace
					SetValidNamespace(&varTemp);
					pSerTemp->QueryInterface(IID_IWbemServices, (void **)&m_pIWbemServices);

				}
				else
				{
					SAFE_RELEASE_PTR(m_pIWbemServices);
				}
			}
			SAFE_RELEASE_PTR(pSerTemp);
			SysFreeString(strParentNameSpace);
			SysFreeString(strNameSpace);
		}
		hr = MapWbemErrorToOLEDBError(hr);
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Delete a namespace
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemConnectionWrapper::GetObjectAccessRights(BSTR strPath,
													  ULONG  *pcAccessEntries,
													  EXPLICIT_ACCESS_W **prgAccessEntries,
													  ULONG  ulAccessEntries,
													  EXPLICIT_ACCESS_W *pAccessEntries)
{
	IWbemServicesEx *pSerEx = NULL;
	IWbemRawSdAccessor *pSdAccessor = NULL;
	HRESULT hr = S_OK;
	SECURITY_DESCRIPTOR	sd;
	InitializeSecurityDescriptor(&sd,SECURITY_DESCRIPTOR_REVISION);

	*pcAccessEntries = 0;
	*prgAccessEntries = NULL;

	if(m_pIWbemServices == NULL)
	{
		hr = E_UNEXPECTED;
	}
	else
	{
		CWbemSecurityDescriptor wbemSD;
		if(SUCCEEDED(hr = wbemSD.Init(m_pIWbemServices,strPath,GetContext())))
		{
			PACL pDacl;
			BOOL bDacl = TRUE;
			BOOL bDefaultDacl = TRUE;
			if(GetSecurityDescriptorDacl(wbemSD.GetSecurityDescriptor(),&bDacl,&pDacl,&bDefaultDacl) && bDacl )
			{
				hr = GetExplicitEntriesFromAclW(pDacl,pcAccessEntries,prgAccessEntries);
			}
			else
			// DACL for SD was null
			if(bDacl == FALSE)
			{
				hr = FALSE;
			}
		}
		else
		if(hr == WBEM_E_NULL_SECURITY_DESCRIPTOR)
		{
			hr = S_OK;
		}
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Delete a namespace
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemConnectionWrapper::SetObjectAccessRights(BSTR strPath,
													  ULONG  ulAccessEntries,
													  EXPLICIT_ACCESS_W *pAccessEntries)
{
	HRESULT hr = S_OK;

	if(m_pIWbemServices == NULL)
	{
		hr = E_UNEXPECTED;
	}
	else
	{
		CWbemSecurityDescriptor wbemSD;
		if(SUCCEEDED(hr = wbemSD.Init(m_pIWbemServices,strPath,GetContext())))
		{
			PACL pDacl;
			BOOL bDacl = TRUE;
			BOOL bDefaultDacl = TRUE;
			// Get the security descriptor DACL for the given Security descriptor
			if(GetSecurityDescriptorDacl(wbemSD.GetSecurityDescriptor(),&bDacl,&pDacl,&bDefaultDacl) && bDacl )
			{
				PACL pNewDacl;
				BOOL bRet = SetEntriesInAclW(ulAccessEntries,pAccessEntries,pDacl,&pNewDacl);
				if(bRet)
				{
					if(SetSecurityDescriptorDacl(wbemSD.GetSecurityDescriptor(),TRUE,pNewDacl,TRUE))
					{
						hr = wbemSD.PutSD();
					}
				}
				else
				{
					hr = E_FAIL;
				}
			}
			else
			// DACL for SD was null
			if(bDacl == FALSE)
			{
				hr = FALSE;
			}
		}
		else
		if(hr == WBEM_E_NULL_SECURITY_DESCRIPTOR)
		{
			hr = S_OK;
		}
	}

	return hr;
}

HRESULT CWbemConnectionWrapper::SetObjectOwner(BSTR strPath,TRUSTEE_W  *pOwner)
{
	HRESULT hr = S_OK;

	if(m_pIWbemServices == NULL)
	{
		hr = E_UNEXPECTED;
	}
	else
	{
		CWbemSecurityDescriptor wbemSD;
		if(SUCCEEDED(hr = wbemSD.Init(m_pIWbemServices,strPath,GetContext())))
		{
			PSID psid;
			if(!wbemSD.GetSID(pOwner,psid))
			{
				hr = E_FAIL;
			}
			else
			if(SetSecurityDescriptorOwner(wbemSD.GetSecurityDescriptor(),psid,TRUE))
			{
				// set the Security descriptor for the object
				hr = wbemSD.PutSD();
			}
			else
			{
				hr = E_FAIL;
			}

		}
		else
		if(hr == WBEM_E_NULL_SECURITY_DESCRIPTOR)
		{
			hr = S_OK;
		}
	}

	return hr;
}

HRESULT CWbemConnectionWrapper::GetObjectOwner( BSTR strPath,TRUSTEE_W  ** ppOwner)
{
	HRESULT hr = S_OK;

	if(m_pIWbemServices == NULL)
	{
		hr = E_UNEXPECTED;
	}
	else
	{
		CWbemSecurityDescriptor wbemSD;
		if(SUCCEEDED(hr = wbemSD.Init(m_pIWbemServices,strPath,GetContext())))
		{
			PSID psid;
			BOOL bOwnerDefaulted = TRUE;
			if(!GetSecurityDescriptorOwner(wbemSD.GetSecurityDescriptor(),&psid,&bOwnerDefaulted))
			{
				hr = E_FAIL;
			}
			else
			if(psid == NULL)
			{
				hr = SEC_E_NOOWNER;
			}
			else
			BuildTrusteeWithSidW(*ppOwner,psid);
		}
		else
		if(hr == WBEM_E_NULL_SECURITY_DESCRIPTOR)
		{
			hr = S_OK;
		}
	}

	return hr;
}

HRESULT CWbemConnectionWrapper::IsObjectAccessAllowed( BSTR strPath,EXPLICIT_ACCESS_W *pAccessEntry,BOOL  *pfResult)
{
	HRESULT hr = S_OK;
	*pfResult = FALSE;

	if(m_pIWbemServices == NULL)
	{
		hr = E_UNEXPECTED;
	}
	else
	{
		CWbemSecurityDescriptor wbemSD;
		if(SUCCEEDED(hr = wbemSD.Init(m_pIWbemServices,strPath,GetContext())))
		{
			PACL pDacl;
			BOOL bDacl = TRUE;
			BOOL bDefaultDacl = TRUE;
			ACCESS_MASK AccMask;
			// Get the security descriptor DACL for the given Security descriptor
			if(GetSecurityDescriptorDacl(wbemSD.GetSecurityDescriptor(),&bDacl,&pDacl,&bDefaultDacl) && bDacl )
			{
				// Get the permissions for a particular trustee
				if(ERROR_SUCCESS == (hr = GetEffectiveRightsFromAclW(pDacl,&(pAccessEntry->Trustee),&AccMask)))
				{
					ACCESS_MASK AccMaskTemp;
					AccMaskTemp = AccMask & pAccessEntry->grfAccessPermissions;
					if(AccMaskTemp >= pAccessEntry->grfAccessPermissions)
					{
						*pfResult = TRUE;
					}
				}
			}

		}
		else
		if(hr == WBEM_E_NULL_SECURITY_DESCRIPTOR)
		{
			hr = S_OK;
		}
	}

	return hr;
}

BOOL CWbemConnectionWrapper::IsValidObject(BSTR strPath)
{
	HRESULT hr = S_OK;
	BOOL bRet = FALSE;

	if(m_pIWbemServices == NULL)
	{
		hr = E_UNEXPECTED;
	}
	else
	{
		if(SUCCEEDED(hr = m_pIWbemServices->GetObject(strPath,WBEM_FLAG_RETURN_WBEM_COMPLETE,GetContext(),NULL,NULL)))
		{
			bRet = TRUE;
		}
	}
	
	return bRet;
}


HRESULT CWbemConnectionWrapper::GetParameters(BSTR strPath,BSTR &strClassName,BSTR *strNameSpace)
{

	HRESULT hr = S_OK;
	IWbemLocator *pLoc = NULL;
	IWbemServices *pSer = NULL;
	IWbemClassObject *pObject = NULL;
	VARIANT varProp;
	VariantInit(&varProp);
			

    hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pLoc);
    if(SUCCEEDED(hr ))
	{

		hr = pLoc->ConnectServer(strNameSpace ? *strNameSpace : strPath,
								m_strUser, m_strPassword, m_strLocale,0, m_strAuthority, 0, &pSer);

        if( SUCCEEDED(hr))
		{
			IClientSecurity *pClientSecurity = NULL;
			
			hr = pSer->QueryInterface(IID_IClientSecurity,(void **)&pClientSecurity);

			if(SUCCEEDED(hr))
			{
				hr = CoSetProxyBlanket( pSer,RPC_C_AUTHN_WINNT,  RPC_C_AUTHN_NONE,   NULL,
										m_dwAuthnLevel, m_dwImpLevel,   NULL,   EOAC_NONE );
				
				SAFE_RELEASE_PTR(pClientSecurity);
			}
			else
			{
				hr = S_OK;
			}

			if(strNameSpace)
			{
				hr = pSer->GetObject(strPath,0,NULL,&pObject,NULL);
			}
			else
			{
				hr = pSer->QueryInterface(IID_IWbemClassObject , (void **)&pObject);
			}
						
			if(SUCCEEDED(hr) && SUCCEEDED(hr = pObject->Get(L"__CLASS",0,&varProp,NULL,NULL)))
			{
				strClassName = Wmioledb_SysAllocString(varProp.bstrVal);
				VariantClear(&varProp);
			}
			SAFE_RELEASE_PTR(pObject);
			SAFE_RELEASE_PTR(pSer);
        }
		SAFE_RELEASE_PTR(pLoc);
    }

	if(hr == WBEM_E_NOT_FOUND)
	{
		hr = WBEM_E_INVALID_NAMESPACE;
	}

    return MapWbemErrorToOLEDBError(hr);
}

// get the class name of the object pointed by the classname
// NTRaid : 134967
// 07/12/00
HRESULT CWbemConnectionWrapper::GetClassName(BSTR strPath,BSTR &strClassName)
{
	HRESULT hr = S_OK;
	IWbemClassObject *pObject = NULL;

	if(SUCCEEDED(hr = m_pIWbemServices->GetObject(strPath,WBEM_FLAG_RETURN_WBEM_COMPLETE,GetContext(),&pObject,NULL)))
	{
		VARIANT varVal;
		VariantInit(&varVal);
		if(SUCCEEDED(hr = pObject->Get(L"__CLASS",0,&varVal,NULL,NULL)))
		{
			strClassName = Wmioledb_SysAllocString(varVal.bstrVal);
		}
		VariantClear(&varVal);
	}
	SAFE_RELEASE_PTR(pObject);
	return MapWbemErrorToOLEDBError(hr);
}

// 07/12/2000
// NTRaid : 142348
// function which executes Action queries
HRESULT CWbemConnectionWrapper::ExecuteQuery(CQuery *pQuery) 
{
	HRESULT hr = S_OK;
	IEnumWbemClassObject *pEnumObject = NULL;

	CBSTR stQryLanguage(pQuery->GetQueryLang());
    CBSTR strQuery(pQuery->GetQuery());

	hr = m_pIWbemServices->ExecQuery(stQryLanguage,strQuery,0,GetContext(),&pEnumObject);
	SAFE_RELEASE_PTR(pEnumObject);

	return MapWbemErrorToOLEDBError(hr);
}

// function which gets the pointer to the the object for which it is pointing
// If the connection doesn not point to object then this returns the namespace

HRESULT CWbemConnectionWrapper::GetNodeName(BSTR &strNode)
{
	HRESULT hr = S_OK;
	IWbemClassObject *pObject = NULL;
	if(SUCCEEDED(hr = m_pIWbemServices->QueryInterface(IID_IWbemClassObject,(void **)&pObject)))
	{	
		VARIANT var;
		VariantInit(&var);
		if(FAILED(hr = pObject->Get(L"__URL",0,&var,NULL,NULL)))
		{
			hr = pObject->Get(L"__PATH",0,&var,NULL,NULL);
		}
		if(SUCCEEDED(hr))
		{
			strNode = Wmioledb_SysAllocString(var.bstrVal);
		}
		SAFE_RELEASE_PTR(pObject);
		VariantClear(&var);
	}
	else
	{
		strNode = Wmioledb_SysAllocString(GetNamespace());
		hr = S_OK;
	}

	return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*********************************************************************************************************************
//
//  CWbemClassParameters
//
//*********************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassParameters::CWbemClassParameters(DWORD dwFlags,WCHAR * pClassName,CWbemConnectionWrapper * pWrap )
{
    m_dwNavFlags			= 0;
    m_dwFlags				= dwFlags;
	m_dwQueryFlags			= WBEM_FLAG_SHALLOW;
    m_pConnection			= pWrap;
    m_pwcsClassName			= NULL;
	m_bSystemProperties		= FALSE;
    m_pwcsClassName			= NULL;
	m_pwcsParentClassName	= NULL;
	m_pIContext				= NULL;
}

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassParameters::CWbemClassParameters(DWORD dwFlags,IDispatch *pDisp,CWbemConnectionWrapper * pWrap )
{
    m_dwNavFlags		= 0;
    m_dwFlags			= dwFlags;
    m_pConnection		= pWrap;
    m_pwcsClassName		= NULL;
	m_bSystemProperties	= FALSE;
	
	m_pwcsParentClassName = NULL;
//	GetClassNameForWbemObject(pDisp);
}

*/

/////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassParameters::~CWbemClassParameters()
{
	DeleteClassName();
	SAFE_RELEASE_PTR(m_pIContext);
	SAFE_DELETE_ARRAY(m_pwcsClassName);
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Function to get the class name and copy it to the member variable from 
// the instance pointed by the IDispatch pointer
/////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassParameters::GetClassNameForWbemObject(IWbemClassObject *pInstance )
{
	HRESULT hr = 0;
	BSTR strClassPropName;
	VARIANT varClassName;

	VariantInit(&varClassName);

	strClassPropName = Wmioledb_SysAllocString(L"__CLASS");

	hr = pInstance->Get(strClassPropName,0,&varClassName,NULL, NULL);

	if( hr == S_OK )
	{
		SAFE_DELETE_ARRAY(m_pwcsClassName)
		m_pwcsClassName = new WCHAR[SysStringLen(varClassName.bstrVal)];
		wcscpy(m_pwcsClassName,(WCHAR *)varClassName.bstrVal);
	}

	VariantClear(&varClassName);
	SysFreeString(strClassPropName);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// function to set the enumerator flags 
/////////////////////////////////////////////////////////////////////////////////////////////
void CWbemClassParameters::SetEnumeratorFlags(DWORD dwFlags)
{
		m_dwNavFlags |= dwFlags;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// function to set the enumerator flags 
/////////////////////////////////////////////////////////////////////////////////////////////
void CWbemClassParameters::SetQueryFlags(DWORD dwFlags)
{
		m_dwQueryFlags = dwFlags;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// function which seperates class name and its
// parent classname if present in the name
/////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassParameters::ParseClassName()
{
	WCHAR *pTemp = NULL;
	pTemp = wcsstr(m_pwcsClassName,CLASSSEPARATOR);
	HRESULT hr = S_OK;

	if(pTemp != NULL)
	{
		m_pwcsParentClassName = new WCHAR[pTemp - m_pwcsClassName + 1];
		//NTRaid:111763 & NTRaid:111764
		// 06/07/00
		if(m_pwcsParentClassName)
		{
			memset(m_pwcsParentClassName , 0,(pTemp - m_pwcsClassName + 1) * sizeof(WCHAR));
			memcpy(m_pwcsParentClassName,m_pwcsClassName,(pTemp - m_pwcsClassName) * sizeof(WCHAR));

			pTemp += wcslen(CLASSSEPARATOR);

			wcscpy(m_pwcsClassName,pTemp);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

	}
	else
	{
		m_pwcsParentClassName = NULL;
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Function to get class Name
/////////////////////////////////////////////////////////////////////////////////////////////
WCHAR * CWbemClassParameters::GetClassName()
{ 
    return m_pwcsClassName;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Function to remove an object from a container
/////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassParameters::RemoveObjectFromContainer(BSTR strContainerObj,BSTR strObject)
{
	HRESULT				hr						= S_OK;
	IWbemServicesEx *	pServicesEx				= NULL;
	IWbemServicesEx *	pContainerServicesEx	= NULL;
	
	if(SUCCEEDED(hr = GetServicesPtr()->QueryInterface(IID_IWbemServicesEx,(void **)&pServicesEx)))
	{
		if(SUCCEEDED(hr =pServicesEx->Open(strContainerObj,NULL,WBEM_FLAG_OPEN_COLLECTION,NULL,&pContainerServicesEx,NULL)))
		{
			hr = pContainerServicesEx->Remove(strObject,0,NULL,NULL);
			SAFE_RELEASE_PTR(pContainerServicesEx);
		}
		SAFE_RELEASE_PTR(pServicesEx);
	}

	return MapWbemErrorToOLEDBError(hr);
}


/////////////////////////////////////////////////////////////////////////////////////////////
// Function to add an object to a container
/////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassParameters::AddObjectFromContainer(BSTR strContainerObj,BSTR strObject)
{
	HRESULT				hr						= S_OK;
	IWbemServicesEx *	pServicesEx				= NULL;
	IWbemServicesEx *	pContainerServicesEx	= NULL;
	
	if(SUCCEEDED(hr = GetServicesPtr()->QueryInterface(IID_IWbemServicesEx,(void **)&pServicesEx)))
	{
		if(SUCCEEDED(hr =pServicesEx->Open(strContainerObj,NULL,WBEM_FLAG_OPEN_COLLECTION,NULL,&pContainerServicesEx,NULL)))
		{
			hr = pContainerServicesEx->Add(strObject,0,NULL,NULL);
			SAFE_RELEASE_PTR(pContainerServicesEx);
		}
		SAFE_RELEASE_PTR(pServicesEx);
	}

	return MapWbemErrorToOLEDBError(hr);
}


///////////////////////////////////////////////////////////////////////////////////////////
// Function to clone an object from one scope to another
///////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassParameters::CloneAndAddNewObjectInScope(CWbemClassWrapper *pClass,BSTR strObj,WCHAR *& pstrNewPath)
{
	HRESULT				hr						= S_OK;
	IWbemServicesEx *	pServicesEx				= NULL;
	IWbemServicesEx *	pContainerServicesEx	= NULL;
	IWbemClassObject*   pNewObject				= NULL;

	if(SUCCEEDED( hr = ((CWbemClassInstanceWrapper *)pClass)->CloneInstance(pNewObject)))
	{
		if(SUCCEEDED(hr = GetServicesPtr()->QueryInterface(IID_IWbemServicesEx,(void **)&pServicesEx)))
		{
			// Open object as scope
			if(SUCCEEDED(hr =pServicesEx->Open(strObj,NULL,WBEM_FLAG_OPEN_SCOPE,NULL,&pContainerServicesEx,NULL)))
			{
				if(SUCCEEDED(hr = pContainerServicesEx->PutInstance(pNewObject,WBEM_FLAG_CREATE_ONLY,GetContext(),NULL)))
				{
					CVARIANT var;
					CBSTR strProp;
					strProp.SetStr(L"__PATH");

					HRESULT hr = pNewObject->Get(L"__PATH",0,var,NULL,NULL);
					if( hr == S_OK )
					{
						try
						{
							pstrNewPath = new WCHAR[wcslen(var.GetStr()) + 1];
						}
						catch(...)
						{
							SAFE_DELETE_ARRAY(pstrNewPath);
							SAFE_RELEASE_PTR(pContainerServicesEx);
							SAFE_RELEASE_PTR(pServicesEx);
							SAFE_RELEASE_PTR(pNewObject);
							throw;
						}
						if(pstrNewPath)
						{
							wcscpy(pstrNewPath,var.GetStr());
						}
						else
						{
							hr = E_OUTOFMEMORY;
						}
					}
				}
				SAFE_RELEASE_PTR(pContainerServicesEx);
			}
			SAFE_RELEASE_PTR(pServicesEx);
		}
		SAFE_RELEASE_PTR(pNewObject);
	}

	return MapWbemErrorToOLEDBError(hr);
}

///////////////////////////////////////////////////////////////////////////////////////////
// Set the search preferences for DS provider
///////////////////////////////////////////////////////////////////////////////////////////
HRESULT	CWbemClassParameters::SetSearchPreferences(ULONG cProps , DBPROP rgProp[])
{
	HRESULT hr = S_OK;
	UINT nStrId = 0;
	WCHAR wcsPreferenceName[SEARCHPREFERENCE_NAMESIZE];
	VARIANT	varValue;
	
	memset(wcsPreferenceName,0,SEARCHPREFERENCE_NAMESIZE * sizeof(WCHAR));
	VariantInit(&varValue);

	for(ULONG i = 0 ; i < cProps  ; i++)
	{
		nStrId = 0;
		if(!m_pIContext)
		{
			hr = g_pIWbemCtxClassFac->CreateInstance(NULL,IID_IWbemContext,(void **)&m_pIContext);
		}
		else
		{
			m_pIContext->DeleteAll();
		}
		if(SUCCEEDED(hr))
		{
			switch(rgProp[i].dwPropertyID)
			{
				case DBPROP_WMIOLEDB_DS_DEREFALIAS :
					nStrId = IDS_DS_DEREFALIAS;
					varValue.vt = VT_I4;
					varValue.lVal = rgProp[i].vValue.lVal;
					break;

				case DBPROP_WMIOLEDB_DS_SIZELIMIT :
					nStrId = IDS_DS_SIZELIMIT;
					varValue.vt = VT_I4;
					varValue.lVal = rgProp[i].vValue.lVal;
					break;

				case DBPROP_WMIOLEDB_DS_PAGEDTIMELIMIT:
					nStrId = IDS_DS_PAGEDTIMELIMIT;
					varValue.vt = VT_I4;
					varValue.lVal = rgProp[i].vValue.lVal;
					break;

				case DBPROP_WMIOLEDB_DS_ASYNCH:
					nStrId = IDS_DS_ASYNC;
					varValue.vt = VT_BOOL;
					varValue.lVal = rgProp[i].vValue.boolVal;
					break;

				case DBPROP_WMIOLEDB_DS_ATTRIBONLY:
					nStrId = IDS_DS_ATTRIBONLY;
					varValue.vt = VT_BOOL;
					varValue.lVal = rgProp[i].vValue.boolVal;
					break;

				case DBPROP_WMIOLEDB_DS_TOMBSTONE:
					nStrId = IDS_DS_TOMBSTONE;
					varValue.vt = VT_BOOL;
					varValue.lVal = rgProp[i].vValue.boolVal;
					break;

				case DBPROP_WMIOLEDB_DS_SEARCHSCOPE:
					nStrId = IDS_DS_SEARCHSCOPE;
					varValue.vt = VT_I4;
					varValue.lVal = rgProp[i].vValue.lVal;
					break;

				case DBPROP_WMIOLEDB_DS_TIMEOUT:
					nStrId = IDS_DS_TIMEOUT;
					varValue.vt = VT_I4;
					varValue.lVal = rgProp[i].vValue.lVal;
					break;

				case DBPROP_WMIOLEDB_DS_PAGESIZE:
					nStrId = IDS_DS_PAGESIZE;
					varValue.vt = VT_I4;
					varValue.lVal = rgProp[i].vValue.lVal;
					break;

				case DBPROP_WMIOLEDB_DS_TIMELIMIT:
					nStrId = IDS_DS_TIMELIMIT;
					varValue.vt = VT_I4;
					varValue.lVal = rgProp[i].vValue.lVal;
					break;

				case DBPROP_WMIOLEDB_DS_CHASEREF:
					nStrId = IDS_DS_CHASEREF;
					varValue.vt = VT_I4;
					varValue.lVal = rgProp[i].vValue.lVal;
					break;

				case DBPROP_WMIOLEDB_DS_FILTER:
					nStrId = IDS_DS_FILTER;
					varValue.vt = VT_BSTR;
					varValue.bstrVal = rgProp[i].vValue.bstrVal;
					break;

				case DBPROP_WMIOLEDB_DS_ATTRIBUTES:
					nStrId = IDS_DS_ATTRIBUTES;
					varValue.vt = VT_BSTR;
					varValue.bstrVal = rgProp[i].vValue.bstrVal;
					break;

				case DBPROP_WMIOLEDB_DS_CACHERESULTS:
					nStrId = IDS_DS_CACHERESULTS;
					varValue.vt = VT_BOOL;
					varValue.lVal = rgProp[i].vValue.boolVal;
					break;

			}
		}
		WMIOledb_LoadStringW(nStrId,wcsPreferenceName,SEARCHPREFERENCE_NAMESIZE * sizeof(WCHAR));
		m_pIContext->SetValue(wcsPreferenceName,0,&varValue);
		VariantClear(&varValue);
		wcscpy(wcsPreferenceName,L"");
	}

	return MapWbemErrorToOLEDBError(hr);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//************************************************************************************************
//
//  Common base class functions in dealing with a class definition or an instance
//
//************************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassWrapper::CWbemClassWrapper( CWbemClassParameters * p )
{
    m_pParms = p;
    m_pClass = NULL;
 	m_pIWbemClassQualifierSet = NULL;
   	m_pIWbemPropertyQualifierSet = NULL;

}
//////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassWrapper::~CWbemClassWrapper( )
{
	m_pPropQualifList.RemoveAll();

	if( m_pIWbemClassQualifierSet != NULL)
	{
		m_pIWbemClassQualifierSet->EndEnumeration();
	}

    SAFE_RELEASE_PTR(m_pClass);
    SAFE_RELEASE_PTR(m_pIWbemClassQualifierSet);
    SAFE_RELEASE_PTR(m_pIWbemPropertyQualifierSet);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// funciton to check if the pointer to IWbemQualiferSet for property qualifer is valid
// If not then it will get the pointer to it
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::IsValidPropertyQualifier(BSTR strProperty)
{
	HRESULT hr = S_OK;
	IWbemQualifierSet *pQualifierSet = NULL;

	if(NULL == m_pPropQualifList.GetPropertyQualifierSet(strProperty))
	{
	    if(S_OK ==(hr = m_pClass->GetPropertyQualifierSet(strProperty, &pQualifierSet)))
		{
			//NTRaid:111779
			// 06/13/00
			hr = m_pPropQualifList.Add(pQualifierSet,strProperty);
		}

	}

	return hr;

}

//////////////////////////////////////////////////////////////////////////////////////////////////
// funciton to check if the pointer to IWbemQualiferSet for class qualifer is valid
// If not then it will get the pointer to it and starts the enumeration on the qualiferset
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::IsValidClassQualifier()
{
	HRESULT hr = S_OK;

	if(NULL == m_pIWbemClassQualifierSet)
	{
		if(S_OK == (hr = m_pClass->GetQualifierSet(&m_pIWbemClassQualifierSet)))
		hr = m_pIWbemClassQualifierSet->BeginEnumeration(0);

	}

	return hr;

}

//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::GetPropertyQualifier(BSTR  pPropertyQualifier, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr;
//	if( S_OK == (hr = IsValidPropertyQualifier(pPropertyQualifier)))
	{
	    hr = m_pIWbemPropertyQualifierSet->Get(pPropertyQualifier,0, vValue, plFlavor);
		//hr = m_pPropQualifList.GetPropertyQualifierSet(pPropertyQualifier)->Get(pPropertyQualifier,0, vValue, plFlavor);
	}

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::ValidClass( )
{
	CBSTR bstrClassName(m_pParms->m_pwcsClassName);
	IWbemClassObject *pClass = NULL;
	HRESULT hr = 0;

		//==========================================================
    //  NOTE:  This is simply a utility class, we MUST have
    //  a valid pointer set when this class is constructed
    //==========================================================
    if( m_pClass == NULL ){

		hr = m_pParms->GetServicesPtr()->GetObject(bstrClassName, 0, NULL, &pClass, NULL);
		if( hr == WBEM_E_NOT_FOUND || hr == WBEM_E_INVALID_OBJECT_PATH)
			return DB_E_NOTABLE;
		else
		if( hr == S_OK)
			pClass->Release();

        return MapWbemErrorToOLEDBError(hr);
    }
    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::SetProperty(BSTR pProperty, VARIANT * vValue,CIMTYPE lType )
{
    HRESULT hr = S_OK;
	if(lType == -1)
	{
		hr = m_pClass->Put(pProperty,0, vValue,NULL);
	}
	else
	{
		hr = m_pClass->Put(pProperty,0, vValue,lType);
	}

    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::SetPropertyQualifier(BSTR pProperty, BSTR Qualifier, VARIANT * vValue, LONG lQualifierFlags )
{
    HRESULT hr;
        
    //==============================================================
    //  If coming thru here the first time, get the qualifier set
    //  otherwise, just use it
    //==============================================================
//    hr = m_pClass->GetPropertyQualifierSet(pProperty, &m_pIWbemPropertyQualifierSet);
	if( S_OK == (hr = IsValidPropertyQualifier(pProperty)))
	{
       	hr = m_pPropQualifList.GetPropertyQualifierSet(pProperty)->Put(Qualifier, vValue, lQualifierFlags);
	}

    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::DeletePropertyQualifier(BSTR pProperty, BSTR Qualifier )
{
    HRESULT hr;
        
    //==============================================================
    //  If coming thru here the first time, get the qualifier set
    //  otherwise, just use it
    //==============================================================
//    hr = m_pClass->GetPropertyQualifierSet(pProperty, &m_pIWbemPropertyQualifierSet);
	if( S_OK == (hr = IsValidPropertyQualifier(pProperty)))
	{
       	hr = m_pPropQualifList.GetPropertyQualifierSet(pProperty)->Delete(Qualifier);
    }

	if(hr == WBEM_E_NOT_FOUND)
	{
		hr = WBEMERROR_QUALIFIER_NOT_FOUND;
	}

    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::BeginPropertyEnumeration()
{
	LONG lFlags = (m_pParms->m_bSystemProperties == TRUE)? 0 : WBEM_FLAG_NONSYSTEM_ONLY;
    HRESULT hr = m_pClass->BeginEnumeration(lFlags);
    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::EndPropertyEnumeration()
{
    HRESULT hr = S_OK;
    m_pClass->EndEnumeration();
    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::TotalPropertiesInClass(ULONG & ulPropCount, ULONG & ulSysPropCount)
{
    HRESULT hr;
    ulPropCount = 0L;
	ulSysPropCount = 0;
	LONG lFlavour = 0;

    if( S_OK == (hr = BeginPropertyEnumeration())){

        while( S_OK == (hr = GetNextProperty(NULL,NULL,NULL,&lFlavour))){
			// If the property is system property increment the systemproperty count
			if(lFlavour == WBEM_FLAVOR_ORIGIN_SYSTEM)
				ulSysPropCount++;
			else
				ulPropCount ++;

        }

        if ( WBEM_S_NO_MORE_DATA == hr ){
            hr = S_OK;
        }
	    EndPropertyEnumeration();
    }
    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr;
    if( !pProperty ){
        hr = m_pClass->Next(0,NULL,NULL,pType,plFlavor);
    }
    else{
        hr = m_pClass->Next(0,pProperty, vValue, pType, plFlavor);
    }
    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::GetProperty(BSTR pProperty, VARIANT * var,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr;

    hr = m_pClass->Get(pProperty,0,var,pType,plFlavor);
    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::DeleteProperty(BSTR pProperty )
{
    HRESULT hr;
    hr = m_pClass->Delete(pProperty);

	if( hr == WBEM_E_NOT_FOUND)
		hr = WBEMERROR_PROPERTY_NOT_FOUND;

    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get the number of qualifer for a property
HRESULT CWbemClassWrapper::TotalPropertyQualifier(BSTR strPropName , ULONG & ulCount )
{
    HRESULT hr;
    ulCount = 0L;
	
    if( S_OK == (hr = BeginPropertyQualifierEnumeration(strPropName)))
	{
        while( S_OK == (hr =  m_pIWbemPropertyQualifierSet->Next(0,NULL,NULL,NULL)))
		{
            ulCount ++;
        }

        if ( WBEM_S_NO_MORE_DATA == hr ){
            hr = S_OK;
        }
		EndPropertyQualifierEnumeration();
    }
    return MapWbemErrorToOLEDBError(hr);
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//Get the property qualifier and begin the enumeration
HRESULT CWbemClassWrapper::BeginPropertyQualifierEnumeration(BSTR strPropName)
{
	HRESULT hr = S_OK;
	//Release the previous quality Qualifier
	if(m_pIWbemPropertyQualifierSet)
	{
		m_pIWbemPropertyQualifierSet->Release();
		m_pIWbemPropertyQualifierSet = NULL;
	}

    if( S_OK == (hr = m_pClass->GetPropertyQualifierSet(strPropName,&m_pIWbemPropertyQualifierSet)))
		hr = m_pIWbemPropertyQualifierSet->BeginEnumeration(0);

	return MapWbemErrorToOLEDBError(hr);
}

HRESULT CWbemClassWrapper::GetPropertyQualifier(BSTR pProperty,BSTR  PropertyQualifier, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor )
{
    HRESULT hr = S_OK;
	IWbemQualifierSet *pQualiferSet = NULL;

	if( S_OK == (hr = IsValidPropertyQualifier(pProperty)))
	{
       	pQualiferSet = m_pPropQualifList.GetPropertyQualifierSet(pProperty);
		hr = pQualiferSet->Get(PropertyQualifier, 0,vValue, plFlavor);
	}
    return MapWbemErrorToOLEDBError(hr);
}



//////////////////////////////////////////////////////////////////////////////////////////////////
//Get the property qualifier and begin the enumeration
HRESULT CWbemClassWrapper::GetNextPropertyQualifier(BSTR pProperty, BSTR * pPropertyQualifier, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT				hr					= S_OK;
	IWbemQualifierSet *	pQualiferSet		= NULL;
	WCHAR *				pStrQualiferTemp	= NULL;
	DBROWOFFSET			lRelativePos		= 1;

	if( S_OK == (hr = IsValidPropertyQualifier(pProperty)))
	{
		// IF the direction has changed compared to the previous fetch then
		// the first fetch will be the last one fetched
		if( m_pPropQualifList.GetQualiferPosObject(pProperty)->GetDirFlag() == FALSE)
			lRelativePos = 0;

		// Check if the qualifer is already fetched
		hr = m_pPropQualifList.GetQualiferPosObject(pProperty)->GetRelative(lRelativePos,pStrQualiferTemp);

		if( hr == WBEMERROR_QUALIFER_TOBE_FETCHED)
		{
       		pQualiferSet = m_pPropQualifList.GetPropertyQualifierSet(pProperty);
		

			if(S_OK ==(hr = pQualiferSet->Next(0,pPropertyQualifier, vValue, plFlavor)))
				//NTRaid:111779
				// 06/13/00
				hr = m_pPropQualifList.GetQualiferPosObject(pProperty)->Add(*pPropertyQualifier);
		}
		// If already fetched get the qualifier name from the QualiferPosList
		else
		if( hr = S_OK)
		{
			*pPropertyQualifier = Wmioledb_SysAllocString(pStrQualiferTemp);
			m_pPropQualifList.GetQualiferPosObject(pProperty)->SetRelPos(lRelativePos);
			hr = GetPropertyQualifier(pProperty,*pPropertyQualifier,vValue,pType,plFlavor);
			m_pPropQualifList.GetQualiferPosObject(pProperty)->SetDirFlag(FETCHDIRFORWARD);
		}
	}
    return MapWbemErrorToOLEDBError(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//Get the property qualifier 
HRESULT CWbemClassWrapper::GetPrevPropertyQualifier(BSTR pProperty, BSTR * pPropertyQualifier, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr = S_OK;
	WCHAR *pStrQualiferTemp = NULL;
	DBROWOFFSET lRelativePos		= -1;

	if( S_OK == (hr = IsValidPropertyQualifier(pProperty)))
	{
		// IF the direction has changed compared to the previous fetch then
		// the first fetch will be the last one fetched
		if( m_pPropQualifList.GetQualiferPosObject(pProperty)->GetDirFlag() == TRUE)
			lRelativePos = 0;

		// Get the name of the qualifier previous in the list
		hr = m_pPropQualifList.GetQualiferPosObject(pProperty)->GetRelative(lRelativePos,pStrQualiferTemp);

		if( hr == DB_E_BADSTARTPOSITION)
		{
			hr = DB_S_ENDOFROWSET;
		}
		if(hr == S_OK)
		{
			*pPropertyQualifier = Wmioledb_SysAllocString(pStrQualiferTemp);
			m_pPropQualifList.GetQualiferPosObject(pProperty)->SetRelPos(lRelativePos);
			hr = GetPropertyQualifier(pProperty,*pPropertyQualifier,vValue,pType,plFlavor);
			m_pPropQualifList.GetQualiferPosObject(pProperty)->SetDirFlag(FETCHDIRBACKWARD);
		}
	}
    return MapWbemErrorToOLEDBError(hr);
}


//////////////////////////////////////////////////////////////////////////////////////////////////
// End the property qualifer enumeration and release the pointers
HRESULT CWbemClassWrapper::EndPropertyQualifierEnumeration()
{
    HRESULT hr = S_OK;
    m_pIWbemPropertyQualifierSet->EndEnumeration();
	m_pIWbemPropertyQualifierSet->Release();
	m_pIWbemPropertyQualifierSet = NULL;
    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::SetClass( IWbemClassObject * pPtr)
{
    HRESULT hr = S_OK;
    if( pPtr ){
        SAFE_RELEASE_PTR(m_pClass);
        m_pClass = pPtr;
		m_pClass->AddRef();
		hr = S_OK;
	}
    return MapWbemErrorToOLEDBError(hr);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// if strPath parameter is NULL then the object to be obtained is same as the object represented by the 
// connection. THis is because GetObject is not working for absolute UMI paths
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassWrapper *  CWbemClassWrapper::GetInstance(BSTR strPath)
{

    CWbemClassInstanceWrapper * pInst = NULL;
	HRESULT hr = S_OK;
	IWbemClassObject * pClass = NULL;

	//============================================================
	//  Get the required instance
	//============================================================
	if(strPath == NULL)
	{
		hr = (m_pParms->GetServicesPtr())->QueryInterface(IID_IWbemClassObject,(void **)&pClass);
	}
	else
	{
		hr = (m_pParms->GetServicesPtr())->GetObject(strPath,0,m_pParms->GetContext(),&pClass ,NULL);
	}

	if( hr == S_OK )
	{
		pInst = new CWbemClassInstanceWrapper(m_pParms);
		//NTRaid:111778
		// 06/07/00
		if(pInst)
		{
			pInst->SetClass(pClass );
		}
		SAFE_RELEASE_PTR(pClass);
	}

    return (CWbemClassWrapper *)pInst;    
}


// Get the key properties
HRESULT CWbemClassWrapper::GetKeyPropertyNames( SAFEARRAY **ppsaNames)
{
	HRESULT hr = S_OK;

	hr = m_pClass->GetNames(NULL,WBEM_FLAG_ALWAYS | WBEM_FLAG_KEYS_ONLY , NULL, ppsaNames);
    return MapWbemErrorToOLEDBError(hr);
}


//////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get a next class/instance qualifer 
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::GetNextClassQualifier(BSTR * pClassQualifier, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor )
{

    HRESULT hr					= S_OK;
	WCHAR *	pStrQualifierTemp	= NULL;
	DBROWOFFSET	lRelativePos		= 1;

	if( S_OK == (hr = IsValidClassQualifier()))
	{	
		// IF the direction has changed compared to the previous fetch then
		// the first fetch will be the last one fetched
		if( m_QualifierPos.GetDirFlag() == FALSE)
			lRelativePos = 0;

		// Check if the qualifer is already fetched
		hr = m_QualifierPos.GetRelative(lRelativePos,pStrQualifierTemp);

		if( hr == WBEMERROR_QUALIFER_TOBE_FETCHED)
		{

			if(S_OK ==(	hr = m_pIWbemClassQualifierSet->Next(0,pClassQualifier, vValue, plFlavor)))
				//NTRaid:111779
				// 06/13/00
				hr = m_QualifierPos.Add(*pClassQualifier);
		}
		else
		if( hr == S_OK)
		{
			*pClassQualifier = Wmioledb_SysAllocString(pStrQualifierTemp);
			m_QualifierPos.SetRelPos(lRelativePos);
			hr = GetClassQualifier(*pClassQualifier,vValue,pType,plFlavor);
			m_QualifierPos.SetDirFlag(FETCHDIRFORWARD);
		}
	}
    return MapWbemErrorToOLEDBError(hr);
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//Get the property qualifier and begin the enumeration
HRESULT CWbemClassWrapper::GetPrevClassQualifier(BSTR * pClassQualifier, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor )
{
    HRESULT hr					= S_OK;
	WCHAR *	pStrQualiferTemp	= NULL;
	DBROWOFFSET	lRelativePos		= 1;

	if( S_OK == (hr = IsValidClassQualifier()))
	{
		// IF the direction has changed compared to the previous fetch then
		// the first fetch will be the last one fetched
		if( m_QualifierPos.GetDirFlag() == TRUE)
			lRelativePos = 0;

		// Get the name of the qualifier previous in the list
		hr = m_QualifierPos.GetRelative(lRelativePos,pStrQualiferTemp);

		if( hr == DB_E_BADSTARTPOSITION)
		{
			hr = DB_S_ENDOFROWSET;
		}
		if(hr == S_OK)
		{
			*pClassQualifier = Wmioledb_SysAllocString(pStrQualiferTemp);
			m_QualifierPos.SetRelPos(lRelativePos);
			hr = GetClassQualifier(*pClassQualifier,vValue,pType,plFlavor);
			m_QualifierPos.SetDirFlag(FETCHDIRBACKWARD);
		}
	}
    return MapWbemErrorToOLEDBError(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get a particular class/instance qualifer 
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::GetClassQualifier(BSTR ClassQualifier, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor )
{
    HRESULT hr;
	if( S_OK == (hr = IsValidClassQualifier()))
	{
		hr = m_pIWbemClassQualifierSet->Get(ClassQualifier,0, vValue, plFlavor);
	}

    return hr;
}

HRESULT	CWbemClassWrapper::ReleaseClassQualifier()
{
	HRESULT hr = S_OK;
	if(m_pIWbemClassQualifierSet != NULL)
	{
		m_pIWbemClassQualifierSet->EndEnumeration();
		m_pIWbemClassQualifierSet->Release();
		m_pIWbemClassQualifierSet = NULL;
		m_QualifierPos.RemoveAll();
	}
	return hr;

}

void CWbemClassWrapper::ReleasePropertyQualifier(BSTR strQualifier)
{ 
	m_pPropQualifList.Remove(strQualifier); 

}


// If qualifername parameter is null, then the class qualifer has
// to be positioned
HRESULT CWbemClassWrapper::SetQualifierRelPos(DBROWOFFSET lRelPos ,BSTR strPropertyName)
{
	HRESULT	hr = E_FAIL;
	BSTR strQualifier;
	
	if(strPropertyName != NULL)
	{
		if( S_OK == (hr = IsValidPropertyQualifier(strPropertyName)))
		{
			hr = m_pPropQualifList.GetQualiferPosObject(strPropertyName)->SetRelPos(lRelPos);
			if(hr == WBEMERROR_QUALIFER_TOBE_FETCHED)
			{
				do
				{
					if(S_OK != (hr =m_pPropQualifList.GetPropertyQualifierSet(strPropertyName)->Next(0,&strQualifier, NULL, NULL)))
						break;
					else
					{
						//NTRaid:111779
						// 06/13/00
						if(FAILED(hr = m_pPropQualifList.GetQualiferPosObject(strPropertyName)->Add(strQualifier)))
						{
							SAFE_FREE_SYSSTRING(strQualifier);
							break;
						}
						SAFE_FREE_SYSSTRING(strQualifier);
						lRelPos--;
					}
				}while(hr == WBEMERROR_QUALIFER_TOBE_FETCHED || lRelPos != 0);
			}
		}
	}
	else 
	if( S_OK == (hr = IsValidClassQualifier()))
	{
		hr = m_QualifierPos.SetRelPos(lRelPos);
		if(hr == WBEMERROR_QUALIFER_TOBE_FETCHED)
		{
			do
			{
				if(S_OK != (hr =m_pIWbemClassQualifierSet->Next(0,&strQualifier, NULL, NULL)))
					break;
				else
				{
					//NTRaid:111779
					// 06/13/00
					if(FAILED(hr = m_QualifierPos.Add(strQualifier)))
					{
						break;
						SAFE_FREE_SYSSTRING(strQualifier);
					}
					lRelPos--;
					SAFE_FREE_SYSSTRING(strQualifier);
				}
			}while(hr == WBEMERROR_QUALIFER_TOBE_FETCHED || lRelPos != 0);
		}
	}

	if( hr == WBEM_E_NOT_FOUND)
	{
		hr = DB_E_BADSTARTPOSITION;
	}

	return hr;

}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassWrapper::SetClassQualifier(BSTR Qualifier, VARIANT * vValue, LONG lQualifierFlags )
{

    HRESULT hr;
    //==============================================================
    //  call this function to get the qualifer set if not obtained
    //==============================================================
    hr = IsValidClassQualifier();
    if ( SUCCEEDED(hr) ){
        hr = m_pIWbemClassQualifierSet->Put(Qualifier, vValue, lQualifierFlags);
    }
    return MapWbemErrorToOLEDBError(hr);
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//************************************************************************************************
//
//  Deal with a class definition
//
//************************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassDefinitionWrapper::CWbemClassDefinitionWrapper( CWbemClassParameters * p,BOOL bGetClass ): CWbemClassWrapper(p)
{	m_bSchema = FALSE;
	if(bGetClass)
	{
		GetClass();
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassDefinitionWrapper::~CWbemClassDefinitionWrapper( )
{
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassDefinitionWrapper::GetEmptyWbemClass( )
{
    HRESULT hr;
    SAFE_RELEASE_PTR(m_pClass);
	hr = m_pParms->GetServicesPtr()->GetObject( NULL, 0, NULL, &m_pClass, NULL);
    if( hr == S_OK ){
        m_pClass->AddRef();
    }
    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassDefinitionWrapper::DeleteClass()
{
    HRESULT hr = m_pParms->GetServicesPtr()->DeleteClass(m_pParms->m_pwcsClassName, WBEM_FLAG_RETURN_IMMEDIATELY,NULL,NULL);
    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassDefinitionWrapper::GetClass( )
{
    HRESULT hr = S_OK;
    SAFE_RELEASE_PTR(m_pClass);

	if(m_pParms->m_pwcsClassName != NULL)
	{
		CBSTR bstrClassName(m_pParms->m_pwcsClassName);
		hr = m_pParms->GetServicesPtr()->GetObject(bstrClassName, 0, NULL, &m_pClass, NULL);
		if( hr == S_OK ){
			m_pClass->AddRef();
		}
	}
    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassDefinitionWrapper::CreateClass()
{
    HRESULT hr;

	CBSTR bstrName(L"__Class");
	CBSTR bstrClassName,bstrSuperClassName;
	CVARIANT NameVal;
	IWbemClassObject *pNewClass = NULL;

	// Parse the class name if it contains the parent class name from which
	// it is to be derived from
	//NTRaid:111763 & NTRaid:111764
	// 06/07/00
	if( S_OK == (hr = m_pParms->ParseClassName()))
	{
		bstrClassName.SetStr(m_pParms->GetClassName());
		bstrSuperClassName.SetStr( m_pParms->GetSuperClassName());
		NameVal.SetStr(bstrClassName);

		if( S_OK == (hr = m_pParms->GetServicesPtr()->GetObject(bstrSuperClassName, 0, NULL, &pNewClass, NULL)))
		{
			if(m_pParms->GetSuperClassName() != NULL)
				hr = pNewClass->SpawnDerivedClass(0, &m_pClass);
			else
				hr = pNewClass->QueryInterface(IID_IWbemClassObject, (void **)&m_pClass);
			
			SAFE_RELEASE_PTR(pNewClass);

			// Set the name of the class
			hr = m_pClass->Put((BSTR)bstrName, 0, &NameVal, CIM_STRING);
		}

		if( hr == WBEM_E_NOT_FOUND)
			hr = WBEM_E_INVALID_CLASS;
	}


    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassDefinitionWrapper::DeleteClassQualifier(BSTR Qualifier)
{

    HRESULT hr;
    //==============================================================
    //  call this function to get the qualifer set if not obtained
    //==============================================================
    hr = IsValidClassQualifier();
    if ( SUCCEEDED(hr) ){
        hr = m_pIWbemClassQualifierSet->Delete(Qualifier);
    }

	if( hr == WBEM_E_NOT_FOUND)
	{
		hr = WBEMERROR_QUALIFIER_NOT_FOUND;
	}

    return MapWbemErrorToOLEDBError(hr);
}



//////////////////////////////////////////////////////////////////////////////////////////////////
// Method to change the class name to which the classdefination class points to
// NOTE:This method is to be called before fetching any instance
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassDefinitionWrapper::SetClass( WCHAR *pClassName)
{
	if(m_pParms->m_pwcsClassName != NULL)
		delete [] m_pParms->m_pwcsClassName;

    m_pParms->m_pwcsClassName = new WCHAR[wcslen(pClassName)+2];
    wcscpy(m_pParms->m_pwcsClassName,pClassName);

    SAFE_RELEASE_PTR(m_pClass);

    HRESULT hr = S_OK;
	CBSTR bstrClassName(m_pParms->m_pwcsClassName);

	hr = m_pParms->GetServicesPtr()->GetObject(bstrClassName, 0, NULL, &m_pClass, NULL);
    if( hr == S_OK ){
        m_pClass->AddRef();
    }
    return MapWbemErrorToOLEDBError(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Method to save the the class defination into WMI
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassDefinitionWrapper::SaveClass(BOOL bNewClass)
{
	LONG lFlag = 0;
	HRESULT hr = S_OK;

	if(bNewClass == TRUE)
		lFlag = WBEM_FLAG_CREATE_ONLY;
	else
		lFlag = WBEM_FLAG_UPDATE_ONLY;

	hr = m_pParms->GetServicesPtr()->PutClass(m_pClass,lFlag,NULL,NULL);

    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// Method to get the number of instances of a class
// This function executes a query "select __path from class" , so that time is reduced in
// getting the count
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassDefinitionWrapper::GetInstanceCount(ULONG_PTR &cInstance)
{
	HRESULT hr = E_FAIL;
	cInstance = -1;
	IEnumWbemClassObject *pEnum = NULL;
	LONG_PTR lObjectsReturned	= 0;
	LONG_PTR lInstance			= 0;
	BSTR strWQL,strQry;
	int nBuffSize			= 0;


	if(ValidClass() == S_OK)
	{
		nBuffSize	= wcslen(szSelectCountQry) + wcslen(GetClassName()) + 1;
		// If the query is not deep then add the where clause for the query
		// to get just the instances of the class 
		if(WBEM_FLAG_DEEP != m_pParms->m_dwQueryFlags)
		{
			nBuffSize = nBuffSize + wcslen(szWhereClause) + wcslen(GetClassName()) + wcslen(szDoubleQuotes);
		}

		WCHAR *szCountQry = new WCHAR[nBuffSize];
		//NTRaid:111773
		// 06/07/00
		if(szCountQry)
		{
			strWQL = Wmioledb_SysAllocString(szWQL);

			// frame the query
			wcscpy(szCountQry , szSelectCountQry);
			wcscat(szCountQry , GetClassName());
			// If the query is not deep then add the where clause for the query
			// to get just the instances of the class 
			if(WBEM_FLAG_DEEP != m_pParms->m_dwQueryFlags)
			{
				wcscat(szCountQry,szWhereClause);
				wcscat(szCountQry,GetClassName());
				wcscat(szCountQry,szDoubleQuotes);
			}

			strQry = Wmioledb_SysAllocString(szCountQry);
			// free the memory
			delete [] szCountQry;

			// Execute the query just to get the __Path property of the instances
			hr = m_pParms->GetServicesPtr()->ExecQuery(strWQL, strQry,WBEM_FLAG_FORWARD_ONLY , m_pParms->GetContext(),&pEnum);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

		if(hr == S_OK)
		{
			lInstance = 0;
			do
			{
				// get NUMBEROFINSTANCESTOBEFETCHED at once and increment the count accordingly
				CCOMPointer<IWbemClassObject >	pObjects[NUMBEROFINSTANCESTOBEFETCHED];
				hr = pEnum->Next(WBEM_INFINITE ,NUMBEROFINSTANCESTOBEFETCHED,(IWbemClassObject **)pObjects,(ULONG *)&lObjectsReturned);
				
				if(!FAILED(hr))
				{
					lInstance += lObjectsReturned;
				}

				if(lObjectsReturned < NUMBEROFINSTANCESTOBEFETCHED)
				{
					break;
				}
			}
			while(hr != WBEM_S_FALSE || !FAILED(hr));

			hr = hr == WBEM_S_FALSE ? S_OK : hr;

			// Release interfaces and free the string
			pEnum->Release();
			SysFreeString(strWQL);
			SysFreeString(strQry);
		}

	}
	else
	{
		hr = WBEM_E_INVALID_CLASS;
	}

	if( hr == S_OK)
		cInstance = lInstance;

	return MapWbemErrorToOLEDBError(hr);
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//************************************************************************************************
//
//  Deal with a class instance
//
//************************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassInstanceWrapper::CWbemClassInstanceWrapper( CWbemClassParameters * p ): CWbemClassWrapper(p)
{
	m_lPos		= 0;
	m_dwStatus	= DBSTATUS_S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassInstanceWrapper::~CWbemClassInstanceWrapper( )
{
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassInstanceWrapper::GetKey(CBSTR & Key)
{
    CVARIANT var;
    HRESULT hr = S_OK;
	
	if(FAILED(hr = GetProperty(L"__URL",var )))
	{
		hr = GetProperty(L"__PATH",var );
	}

    if( hr == S_OK ){
        Key.SetStr(var.GetStr());
    }
    return MapWbemErrorToOLEDBError(hr);    
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassInstanceWrapper::ResetInstanceFromKey(CBSTR Key)
{
    HRESULT hr;
    SAFE_RELEASE_PTR(m_pClass);
	hr = m_pParms->GetServicesPtr()->GetObject(Key, 0, NULL, &m_pClass, NULL);
    if( hr == S_OK ){
        m_pClass->AddRef();
    }
    return MapWbemErrorToOLEDBError(hr);
}


// Refresh the internal pointer of the instance
// Object is refreshed by getting object by __PATH  for WMI object
// and __URL property for WMI objects returned by UMI Providers
HRESULT CWbemClassInstanceWrapper::RefreshInstance()
{
	CBSTR strPath;
	HRESULT hr = S_OK;

	hr = GetKey(strPath);

	if( hr == S_OK){
		m_pClass->Release();
		m_pClass = NULL;

		hr = (m_pParms->GetServicesPtr())->GetObject(strPath,0,m_pParms->GetContext(),&m_pClass ,NULL);
	}

	if(hr == S_OK)
	{
		m_dwStatus = DBSTATUS_S_OK;
	}
	else
	{
		m_dwStatus = DBSTATUS_E_UNAVAILABLE;
	}

    return MapWbemErrorToOLEDBError(hr);
}

////////////////////////////////////////////////////////////////////////////////////////////
// Get the name of the class to which the instance belongs
// THe returned pointer is to be cleaned by the callee
////////////////////////////////////////////////////////////////////////////////////////////
WCHAR *  CWbemClassInstanceWrapper::GetClassName()
{
	WCHAR *pClass = NULL;
	BSTR strPropName;
	HRESULT hr = 0;

	strPropName = Wmioledb_SysAllocString(L"__Class");

	VARIANT varClassName;
	VariantInit(&varClassName);

	// Get the class name
	hr = m_pClass->Get(strPropName,0, &varClassName , NULL , NULL);

	SysFreeString(strPropName);

	if( hr == S_OK)
	{	
        AllocateAndCopy(pClass,varClassName.bstrVal);
		VariantClear(&varClassName);
	}
	return pClass;
}


HRESULT CWbemClassInstanceWrapper::CloneInstance(IWbemClassObject *& pInstance)
{
	HRESULT hr = S_OK;
	pInstance = NULL;

	hr = m_pClass->Clone(&pInstance);

	return MapWbemErrorToOLEDBError(hr);
}

// function which get the RElative path
// Gets __RELURL property for objects of UMI
// gets the __RELPATH for normal WMI objects ( as __RELURL property fetching fails)
HRESULT CWbemClassInstanceWrapper::GetRelativePath(WCHAR *& pstrRelPath)
{
	HRESULT hr = S_OK;
	VARIANT varRelPath;
	VariantInit(&varRelPath);
	LONG nStringLen = 0;

	if(FAILED(hr = m_pClass->Get(L"__RELURL",0,&varRelPath,NULL,NULL)))
	{
		hr = m_pClass->Get(L"__RELPATH",0,&varRelPath,NULL,NULL);
	}
	if(SUCCEEDED(hr))
	{
		if(varRelPath.vt == VT_BSTR && varRelPath.bstrVal != NULL)
		{
			nStringLen = (SysStringLen(varRelPath.bstrVal) +1) * sizeof(WCHAR);
			pstrRelPath = NULL;
			pstrRelPath = new WCHAR[nStringLen];
			if(pstrRelPath)
			{
				memset(pstrRelPath,0, nStringLen);
				memcpy(pstrRelPath,varRelPath.bstrVal,nStringLen-sizeof(WCHAR));
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
		else
		{
			E_FAIL;
		}
		VariantClear(&varRelPath);
	}
	return MapWbemErrorToOLEDBError(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//************************************************************************************************
//
//  Manage class instance list
//
//************************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////////
CWbemInstanceList::CWbemInstanceList(CWbemClassParameters * pParms)
{
    m_pParms		= pParms;
	m_ppEnum		= NULL;
	m_lCurrentPos	= 0;
	m_FetchDir		= FETCHDIRNONE;
    m_nBaseType   = FALSE;
	
	m_cTotalInstancesInEnum = 0;
    InitializeCriticalSection(&m_InstanceCs);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
CWbemInstanceList::~CWbemInstanceList()
{
    ReleaseAllInstances();
    DeleteCriticalSection(&m_InstanceCs);
    SAFE_RELEASE_PTR(m_ppEnum);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemInstanceList::ReleaseAllInstances()
{
    HRESULT hr = S_OK;
    //==========================================================================
    //  Enter the critical section
    //==========================================================================
	Enter();

	//==========================================================================
	//  Go through the instances one at a time and close them, then delete them
    //==========================================================================
    int nSize = m_List.Size(); 

    if( nSize > 0 ){

        for(int i = 0; i < nSize; i++){
    		    
		    CWbemClassInstanceWrapper * pClass = (CWbemClassInstanceWrapper*) m_List[i];
            SAFE_DELETE_PTR(pClass);
	    }
        m_List.Empty();
    }

	m_lCurrentPos = 0;
    //==========================================================================
    //  Leave Critical Section
    //==========================================================================
    Leave();
    return MapWbemErrorToOLEDBError(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CWbemInstanceList::DeleteInstance( CWbemClassInstanceWrapper *& pClass )
{
    HRESULT hr;
	CBSTR strPath;
	pClass->GetKey(strPath);

    //=======================================================================
    //  Delete the instance from CIMOM
    //=======================================================================
    hr = (m_pParms->GetServicesPtr())->DeleteInstance((BSTR)strPath,0,m_pParms->GetContext(),NULL);
    if( hr == S_OK ){
//        hr = ReleaseInstance(pClass);
		pClass->SetStatus(DBROWSTATUS_E_DELETED);

		if(m_cTotalInstancesInEnum)
			m_cTotalInstancesInEnum--;
    }

    return MapWbemErrorToOLEDBError(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemInstanceList::AddInstance( CWbemClassInstanceWrapper * pClass )
{
    //==========================================================================
    //  Enter Critical Section
    //==========================================================================
    Enter();
    //==========================================================================
    //  Add it to the list
    //==========================================================================
 	m_List.Add(pClass);
    //==========================================================================
    //  Leave Critical Section
    //==========================================================================
    Leave();
    return MapWbemErrorToOLEDBError(S_OK);
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemInstanceList::ReleaseInstance(CWbemClassInstanceWrapper *& pClass)
{
    //========================================================================
    //  Enter the critical section
    //========================================================================
    Enter();

    //========================================================================
    //  Look for it in the list
    //========================================================================
    HRESULT hr = DB_E_NOTFOUND;
    int n = 0;

    for(int i = 0; i < m_List.Size(); i++){

        CWbemClassInstanceWrapper * pClassInList = (CWbemClassInstanceWrapper * ) m_List[i];
        if(pClass == pClassInList){
            n = i;
            hr = S_OK;
            break;
        }
    }

    //========================================================================
    //  If we found it, then delete it from the list.  
    //  The deconstructor will release the wbem class object
    //========================================================================
    if( S_OK == hr ){
        m_List.RemoveAt(n);
        delete pClass;
        pClass = NULL;
    }
    //========================================================================
    //  Leave critical section
    //========================================================================
    Leave();

    return MapWbemErrorToOLEDBError(hr);
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemInstanceList::NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst)
{
	LONG						lRelativePos	= 1;
    HRESULT hr = E_FAIL;

    //============================================================
    //  Now, enumerate all of the instances
    //============================================================
    if( m_ppEnum ){


		// IF the direction has changed compared to the previous fetch then
		// the first fetch will be the last one fetched
		if( m_FetchDir == FETCHDIRBACKWARD)
			lRelativePos = 0;

		// Check if the instance is already fetched
		*pInst = GetInstance(m_lCurrentPos +lRelativePos);
		if( *pInst == NULL){
			unsigned long u;
			IWbemClassObject * pClass = NULL;
	
			hr = m_ppEnum->Next(0,1,&pClass,&u);
			if( hr == S_OK ){

                switch( m_nBaseType )
                {
                    case COMMAND_ROWSET:
    				    *pInst = new CWbemCommandInstanceWrapper(m_pParms,((CWbemCommandParameters*)m_pParms)->GetCommandManagerPtr());
                        break;

                    case SOURCES_ROWSET:
                        *pInst = (CWbemSchemaSourcesInstanceWrapper *) new CWbemSchemaSourcesInstanceWrapper(m_pParms);
                        break;

                    case PROVIDER_TYPES_ROWSET:
                        *pInst = (CWbemSchemaProviderTypesInstanceWrapper *) new CWbemSchemaProviderTypesInstanceWrapper(m_pParms);
                        break;

                    case CATALOGS_ROWSET:
                        *pInst = (CWbemSchemaCatalogsInstanceWrapper *) new CWbemSchemaCatalogsInstanceWrapper(m_pParms);
                        break;

                    case COLUMNS_ROWSET:
                        *pInst = (CWbemSchemaColumnsInstanceWrapper *) new CWbemSchemaColumnsInstanceWrapper(m_pParms);
                        break;

                    case TABLES_ROWSET:
                        *pInst = (CWbemSchemaTablesInstanceWrapper *) new CWbemSchemaTablesInstanceWrapper(m_pParms);
                        break;

                    case PRIMARY_KEYS_ROWSET:
                        *pInst = (CWbemSchemaPrimaryKeysInstanceWrapper *) new CWbemSchemaPrimaryKeysInstanceWrapper(m_pParms);
                        break;

                    case TABLES_INFO_ROWSET:
                        *pInst = (CWbemSchemaTablesInfoInstanceWrapper *) new CWbemSchemaTablesInfoInstanceWrapper(m_pParms);
                        break;

                    default:
    				    *pInst = new CWbemClassInstanceWrapper(m_pParms);

                }
				//NTRaid:111798 & 111799
				// 06/07/00
				if(*pInst)
				{
					(*pInst)->SetClass(pClass);
					(*pInst)->SetPos(++m_lCurrentPos);
					AddInstance(*pInst);
					(*pInst)->GetKey(Key);
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}
			SAFE_RELEASE_PTR(pClass);
		}
		else
		{
			// Adjust the enumerator to position to the current positon
			if(( m_lCurrentPos +lRelativePos) > m_lCurrentPos)
				hr = m_ppEnum->Skip(WBEM_INFINITE ,(LONG)lRelativePos);

			m_lCurrentPos += lRelativePos;
			m_FetchDir	   = FETCHDIRFORWARD;
			(*pInst)->GetKey(Key);
			hr = S_OK;
		}
    }

    return hr;    
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemInstanceList::UpdateInstance(CWbemClassInstanceWrapper * pInstance, BOOL bNewInst)
{
    HRESULT hr;
	LONG lFlag = 0;

	if(bNewInst == TRUE)
		lFlag = WBEM_FLAG_CREATE_ONLY;
	else
		lFlag = WBEM_FLAG_UPDATE_ONLY;

    hr = (m_pParms->GetServicesPtr())->PutInstance(pInstance->GetClassObject(),lFlag,m_pParms->GetContext(),NULL);
    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemInstanceList::Reset()
{
    HRESULT hr = E_UNEXPECTED;
	BOOL	bGetInstanceEnum = TRUE;
    //============================================================
    //  If we already got an enumeration, reset it, otherwise
    //  don't
    //============================================================
    if( m_ppEnum ){
		if(WBEM_FLAG_FORWARD_ONLY & m_pParms->m_dwNavFlags)
		{
			ReleaseAllInstances();
			m_ppEnum->Release();
			m_ppEnum			= NULL;
		}
		else
		{
			hr = m_ppEnum->Reset();
			//ReleaseAllInstances();
			bGetInstanceEnum	= FALSE;
		}
    }

	if(bGetInstanceEnum	== TRUE)
    {
		CBSTR bstrClassName(m_pParms->m_pwcsClassName);
        hr = (m_pParms->GetServicesPtr())->CreateInstanceEnum(bstrClassName,
																m_pParms->m_dwNavFlags | m_pParms->m_dwQueryFlags,
																m_pParms->GetContext(),
																&m_ppEnum);
		if( hr == S_OK)
			m_cTotalInstancesInEnum = 0;
    }
	if(hr == S_OK)
	{
		m_lCurrentPos = 0;
//		m_FetchDir	  = FETCHDIRFORWARD;
	}

    return MapWbemErrorToOLEDBError(hr);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemInstanceList::AddNewInstance(CWbemClassWrapper *pClassWrappper, CWbemClassInstanceWrapper ** ppNewClass )
{
	IWbemClassObject *pInstClassObject = NULL;
    CWbemClassInstanceWrapper * pInst = NULL;
	HRESULT hr = S_OK;
    //==========================================================================
    //  Enter Critical Section
    //==========================================================================
    Enter();
    //==========================================================================
    //  create a new instance
    //==========================================================================
 	hr = pClassWrappper->GetClass()->SpawnInstance(0, &pInstClassObject);

    if( hr == S_OK ){
        *ppNewClass = new CWbemClassInstanceWrapper(m_pParms);
		//NTRaid:111776 & NTRaid:111777
		// 06/07/00
		if(*ppNewClass)
		{
			(*ppNewClass)->SetClass(pInstClassObject);
			(*ppNewClass)->SetPos(++m_lCurrentPos);
			AddInstance(*ppNewClass);

 			if(m_cTotalInstancesInEnum)
				m_cTotalInstancesInEnum++;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
		SAFE_RELEASE_PTR(pInstClassObject);

   }

    //==========================================================================
    //  Leave Critical Section
    //==========================================================================
    Leave();
    return MapWbemErrorToOLEDBError(hr);
}
/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function called for instances embededed in another instance.
// This function adds the instance pointed by dispatch to the CWbemInstanceList
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CWbemClassInstanceWrapper *  CWbemInstanceList::AddInstanceToList( IUnknown *pDisp,CBSTR & Key)
{

	IWbemClassObject *			pClassObj	= NULL;
	HRESULT						hr			= S_OK;
    CWbemClassInstanceWrapper * pInst		= NULL;

	hr = pDisp->QueryInterface(IID_IWbemClassObject , (void **) &pClassObj);

	if( hr == S_OK)
	{

        pInst = new CWbemClassInstanceWrapper(m_pParms);
		//NTRaid:111774 & NTRaid:111775
		// 06/07/00
		if(pInst)
		{
			pInst->SetClass(pClassObj);
			pInst->SetPos(++m_lCurrentPos);
			AddInstance(pInst);
			pInst->GetKey(Key);
		}
		SAFE_RELEASE_PTR(pClassObj);;

    }

    return pInst;    
}
*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get a previous instance in the enumerator
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemInstanceList::PrevInstance( CBSTR & Key,CWbemClassInstanceWrapper *& pInst )
{
	HRESULT						hr				= S_OK;
	DBROWOFFSET					lRelativePos	= -1;
	IWbemClassObject *			pClass			= NULL;
	ULONG						u				= 0;
	pInst										= NULL;
	BOOL						bResetDone		= FALSE;

	// if the first call after initialization / restartPositon of rowset is getting
	// instance in reverse direction then
	if( !(WBEM_FLAG_FORWARD_ONLY & m_pParms->m_dwNavFlags) && m_lCurrentPos == 0 && m_FetchDir == FETCHDIRFORWARD)
	{
		if(!m_cTotalInstancesInEnum)
			if(S_OK != (hr = GetNumberOfInstanceInEnumerator()))
				return MapWbemErrorToOLEDBError(hr);


		if((LONG)(m_cTotalInstancesInEnum - lRelativePos) > 0)
		{
			m_lCurrentPos = m_cTotalInstancesInEnum;
		}
		else
			hr = E_FAIL;
	}
	else
	if( (m_lCurrentPos + lRelativePos) == 0 && m_FetchDir == FETCHDIRBACKWARD)
		return E_FAIL;
	else
	{
		// IF the direction has changed compared to the previous fetch then
		// the first fetch will be the last one fetched
		if( m_FetchDir == FETCHDIRFORWARD)
			lRelativePos = 0;

		// Reset the position to the so that 
		// NextInstance function gives the instance required

		hr = ResetRelPosition(lRelativePos);
	}

	pInst = GetInstance(m_lCurrentPos);
	if(pInst == NULL)
	{
		bResetDone = TRUE;
		// restore the original position
		if(!(WBEM_FLAG_FORWARD_ONLY & m_pParms->m_dwNavFlags))
		{
			m_ppEnum->Reset();
			m_ppEnum->Skip(WBEM_INFINITE,(LONG)(m_lCurrentPos - 1));
			hr = m_ppEnum->Next(0,1,&pClass,&u);
			if( hr == S_OK )
			{
                switch( m_nBaseType ){

                    case COMMAND_ROWSET:
    				    pInst = (CWbemClassInstanceWrapper *) new CWbemCommandInstanceWrapper(m_pParms,((CWbemCommandParameters*)m_pParms)->GetCommandManagerPtr());
                        break;

                    case SOURCES_ROWSET:
                        pInst = (CWbemClassInstanceWrapper *) new CWbemSchemaSourcesInstanceWrapper(m_pParms);
                        break;

                    case PROVIDER_TYPES_ROWSET:
                        pInst = (CWbemClassInstanceWrapper *) new CWbemSchemaProviderTypesInstanceWrapper(m_pParms);
                        break;

                    case CATALOGS_ROWSET:
                        pInst = (CWbemSchemaCatalogsInstanceWrapper *) new CWbemSchemaCatalogsInstanceWrapper(m_pParms);
                        break;

                    case COLUMNS_ROWSET:
                        pInst = (CWbemSchemaColumnsInstanceWrapper *) new CWbemSchemaColumnsInstanceWrapper(m_pParms);
                        break;

                    case TABLES_ROWSET:
                        pInst = (CWbemSchemaTablesInstanceWrapper *) new CWbemSchemaTablesInstanceWrapper(m_pParms);
                        break;

                    case PRIMARY_KEYS_ROWSET:
                        pInst = (CWbemSchemaPrimaryKeysInstanceWrapper *) new CWbemSchemaPrimaryKeysInstanceWrapper(m_pParms);
                        break;

                    case TABLES_INFO_ROWSET:
                        pInst = (CWbemSchemaTablesInfoInstanceWrapper *) new CWbemSchemaTablesInfoInstanceWrapper(m_pParms);
                        break;

                    default:
    				    pInst = new CWbemClassInstanceWrapper(m_pParms);
                        
                }
				//NTRaid:111796-111797
				// 06/07/00
				if(pInst)
				{
					(pInst)->SetClass(pClass);
					(pInst)->SetPos(m_lCurrentPos);
					AddInstance(pInst);
	//				(pInst)->GetKey(Key);
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}
			SAFE_RELEASE_PTR(pClass);
		}

	}
	if(pInst != NULL)
	{
		pInst->GetKey(Key);
		m_FetchDir	= FETCHDIRBACKWARD; // setting that the last fetch was backwards
//		m_lCurrentPos = m_lCurrentPos + lRelativePos;
	}
	else
	{
		if(bResetDone)
			hr = ResetRelPosition(lRelativePos * (-1));

		hr = E_OUTOFMEMORY;
	}

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function which returns the instance pointer given the position if already retrieved
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassInstanceWrapper *  CWbemInstanceList::GetInstance( ULONG_PTR lPos )
{
	CWbemClassInstanceWrapper * pInst = NULL  ;

    for(int i = 0; i < m_List.Size(); i++)
	{

        CWbemClassInstanceWrapper *pTempInst = (CWbemClassInstanceWrapper * ) m_List[i];
        if(pTempInst->GetPos() == lPos)
		{
			pInst = pTempInst;
            break;
        }
    }

	return pInst;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to reset the positon by the number of instance specified
// so that the NextInstance function gives the instance required
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemInstanceList::ResetRelPosition( DBROWOFFSET lPos )
{
	DBROWOFFSET	lPosRequired = 0;
	HRESULT		hr			 = E_FAIL;
	
	CWbemClassInstanceWrapper * pInst = NULL;
	
	// Get the position at which the enumerator to be pointed to
	lPosRequired = m_lCurrentPos + lPos;
	if( lPosRequired > 0)
	{
		// If skipping is forward then skip by the number of positions
		if(lPos > 0)
		{
			if(S_OK == (hr = m_ppEnum->Skip(WBEM_INFINITE ,(LONG)lPos)))
				m_lCurrentPos = lPosRequired;
			else
			// restore the original position
			if(!(WBEM_FLAG_FORWARD_ONLY & m_pParms->m_dwNavFlags))
			{
				m_ppEnum->Reset();
				hr = m_ppEnum->Skip(WBEM_INFINITE,(LONG)m_lCurrentPos);
				hr = E_FAIL;
			}	
		}
		// Else if skipping is negative , then 
		else
		if( lPos < 0)
		{
			// If enumerator is not forward only then skip Reset 
			// the begining and spip to the position required
			if(!(WBEM_FLAG_FORWARD_ONLY & m_pParms->m_dwNavFlags))
			{
				if(S_OK == (hr = m_ppEnum->Reset()))
				{
					if(S_OK == (hr = m_ppEnum->Skip(WBEM_INFINITE ,(LONG)lPosRequired)))
						m_lCurrentPos = lPosRequired;
					else
					{
						m_ppEnum->Reset();
						hr = m_ppEnum->Skip(WBEM_INFINITE,(LONG)m_lCurrentPos);
						hr = E_FAIL;
					}	
				}
			}
			// other wise if the enumerator is forward only return
			// error
			else
				hr = E_FAIL;
		}
		else
			hr = S_OK;
	}
	else
	if(lPosRequired == 0 && !(WBEM_FLAG_FORWARD_ONLY & m_pParms->m_dwNavFlags))
	{
		hr = m_ppEnum->Reset();
		m_lCurrentPos = lPosRequired;
	}
	else
	// if the initial position is negative when the enumerator is at the begining then
	if(lPosRequired < 0 && !(WBEM_FLAG_FORWARD_ONLY & m_pParms->m_dwNavFlags) && m_lCurrentPos == 0)
	{
		if(!m_cTotalInstancesInEnum)
			if(S_OK != (hr = GetNumberOfInstanceInEnumerator()))
				return MapWbemErrorToOLEDBError(hr);


		if((LONG)(m_cTotalInstancesInEnum + lPos) > 0)
		{
			hr = m_ppEnum->Reset();
			if(S_OK == (hr = m_ppEnum->Skip(WBEM_INFINITE,(LONG)(m_cTotalInstancesInEnum + lPos))))
				m_lCurrentPos = m_cTotalInstancesInEnum + lPos;
		}
		else
			hr = E_FAIL;
	}
	
	return MapWbemErrorToOLEDBError(hr);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get the number of instances in a enumerator
// 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemInstanceList::GetNumberOfInstanceInEnumerator(ULONG_PTR *pcInstance)
{
	ULONG ulObj = 0;
	HRESULT hr = S_OK;
	m_cTotalInstancesInEnum = 0;
	int i = 0;

	if(S_OK == (hr = m_ppEnum->Reset()))
	{
		// Calculate the number of instance in the enumerator
		while(S_OK == hr)
		{
			{
				CCOMPointer<IWbemClassObject >	pObjects[NUMBEROFINSTANCESTOBEFETCHED];
				hr = m_ppEnum->Next(0,NUMBEROFINSTANCESTOBEFETCHED,(IWbemClassObject **)pObjects , &ulObj);

			}
			if( hr == S_OK || hr == WBEM_S_FALSE)
				m_cTotalInstancesInEnum += ulObj;
		}

		// Bring back to the original position
		if((S_OK == (hr = m_ppEnum->Reset())) && m_lCurrentPos != 0)
			hr = m_ppEnum->Skip(WBEM_INFINITE ,(LONG)m_lCurrentPos);

	}
	if(SUCCEEDED(hr) && &pcInstance)
	{
		*pcInstance = m_cTotalInstancesInEnum;
	}
	return hr;
}

/***********************************************************************************************************
				Class CWbemPropertyQualifierList implementation
/***********************************************************************************************************/


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemPropertyQualifierList::~CWbemPropertyQualifierList()
{
	RemoveAll();
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Remove all elements from the list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWbemPropertyQualifierList::RemoveAll()
{
	CWbemPropertyQualifierWrapper *pQualifWrap = NULL;
	int nSize = m_QualifierList.Size();

	if(m_QualifierList.Size() > 0)
	for( int nIndex = nSize-1 ; nIndex >= 0 ; nIndex--)
	{
			pQualifWrap = (CWbemPropertyQualifierWrapper *)m_QualifierList[nIndex];
			m_QualifierList.RemoveAt(nIndex);
			pQualifWrap->m_pIWbemPropertyQualifierSet->EndEnumeration();
			SAFE_DELETE_PTR(pQualifWrap);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// add a Element to the list
//NTRaid:111779
// 06/13/00
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemPropertyQualifierList::Add(IWbemQualifierSet* pQualifierSet,WCHAR *pwstrPropertyName)
{
	CWbemPropertyQualifierWrapper *pNewQualifWrap = NULL;
	pNewQualifWrap = new CWbemPropertyQualifierWrapper;
	HRESULT hr = S_OK;
	
	// NTRaid:111779 & NTRaid:111780
	// 06/07/00
	if(pNewQualifWrap)
	{
		pNewQualifWrap->m_pIWbemPropertyQualifierSet	= pQualifierSet;
		pNewQualifWrap->m_pwstrPropertyName			= new WCHAR[wcslen(pwstrPropertyName) + 1];
		if(pNewQualifWrap->m_pwstrPropertyName)
		{
			wcscpy(pNewQualifWrap->m_pwstrPropertyName,pwstrPropertyName);

			//NTRaid:111779
			// 06/13/00
			if(SUCCEEDED(hr = m_QualifierList.Add(pNewQualifWrap)))
			{
				hr = pQualifierSet->BeginEnumeration(0);
			}
			else
			{
				SAFE_DELETE_ARRAY(pNewQualifWrap->m_pwstrPropertyName)
				SAFE_DELETE_PTR(pNewQualifWrap)
			}
		}
		else
		{
			SAFE_DELETE_PTR(pNewQualifWrap);
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Remove a Element from the  list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWbemPropertyQualifierList::Remove(WCHAR *pwstrPropertyName)
{
	CWbemPropertyQualifierWrapper *pQualifWrap = NULL;

	for( int nIndex = 0 ; nIndex < m_QualifierList.Size(); nIndex++)
	{
		if(0 == wbem_wcsicmp(((CWbemPropertyQualifierWrapper *)m_QualifierList[nIndex])->m_pwstrPropertyName,pwstrPropertyName))
		{
			pQualifWrap = (CWbemPropertyQualifierWrapper *)m_QualifierList[nIndex];
			m_QualifierList.RemoveAt(nIndex);
			pQualifWrap->m_pIWbemPropertyQualifierSet->EndEnumeration();
			SAFE_DELETE_PTR(pQualifWrap);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the IWbemQualifierSet pointer to the required property
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
IWbemQualifierSet* CWbemPropertyQualifierList::GetPropertyQualifierSet(WCHAR *pwstrPropertyName)
{
	for( int nIndex = 0 ; nIndex < m_QualifierList.Size(); nIndex++)
	{
		if(0 == wbem_wcsicmp(((CWbemPropertyQualifierWrapper *)m_QualifierList[nIndex])->m_pwstrPropertyName,pwstrPropertyName))
			return ((CWbemPropertyQualifierWrapper *)m_QualifierList[nIndex])->m_pIWbemPropertyQualifierSet;
	}

	return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the CQualiferPos pointer for a property
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CQualiferPos *CWbemPropertyQualifierList::GetQualiferPosObject(WCHAR *pwcsProperty)
{
	for( int nIndex = 0 ; nIndex < m_QualifierList.Size(); nIndex++)
	{
		if(0 == wbem_wcsicmp(((CWbemPropertyQualifierWrapper *)m_QualifierList[nIndex])->m_pwstrPropertyName,pwcsProperty))
			return &(((CWbemPropertyQualifierWrapper *)m_QualifierList[nIndex])->m_QualifierPos);
	}

	return NULL;
}


/***********************************************************************************************************
				Class CQualifier implementation
/***********************************************************************************************************/




/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CQualiferPos::CQualiferPos()
{
	m_lPos		= -1;
	m_FetchDir	= FETCHDIRNONE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CQualiferPos::~CQualiferPos()
{
	RemoveAll();
	m_lPos = -1;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Remove all the elements from the list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQualiferPos::RemoveAll()
{
	WCHAR *pChar = NULL;
	int nSize = m_QualifierPos.Size();

	if(m_QualifierPos.Size() > 0)
	for( int nIndex = nSize-1 ; nIndex >= 0 ; nIndex--)
	{
		if ( NULL != (pChar = (WCHAR *)m_QualifierPos[nIndex]))
		{
			delete [] pChar;
			pChar = NULL;
		}
		m_QualifierPos.RemoveAt(nIndex);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Remove a qualifier from the list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQualiferPos::Remove(WCHAR *pwcsQualifier)
{
	int nSize = m_QualifierPos.Size();

	if(m_QualifierPos.Size() > 0)
	for( int nIndex = nSize-1 ; nIndex >= 0 ; nIndex--)
	{
		if(wbem_wcsicmp((WCHAR *)m_QualifierPos[nIndex],pwcsQualifier) == 0)
		{
			m_QualifierPos.RemoveAt(nIndex);
			m_lPos--;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get qualifier at a particula position
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
WCHAR * CQualiferPos::operator [] (DBORDINAL nIndex)
{
	if( nIndex <= (ULONG_PTR)m_QualifierPos.Size())
		return (WCHAR *)m_QualifierPos[(int)nIndex];

	return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the qualifier at a relation positon from the current position
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CQualiferPos::GetRelative (DBROWOFFSET lRelPos, WCHAR *&pwcsQualifier)
{
	HRESULT hr = S_OK;
	LONG lSize = m_QualifierPos.Size();

	if( lSize > 0)
	{
		if( (m_lPos + lRelPos) >= lSize)
		{
			hr = WBEMERROR_QUALIFER_TOBE_FETCHED;
		}
		else
		if( (m_lPos + lRelPos) < 0)
		{
			hr = DB_E_BADSTARTPOSITION;
		}
		else
		{
			pwcsQualifier = (WCHAR *)m_QualifierPos[(int)(m_lPos + lRelPos)];
		}
	}
	else
		hr = lRelPos > 0 ? WBEMERROR_QUALIFER_TOBE_FETCHED :DB_E_BADSTARTPOSITION;

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Add qualifier to the list
//NTRaid:111779
// 06/13/00
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CQualiferPos::Add(WCHAR *pwcsQualifier)
{
	WCHAR *pstrTemp = NULL;
	HRESULT hr = S_OK;
	pstrTemp = new WCHAR[wcslen(pwcsQualifier) +1];

	if(pstrTemp)
	{
		wcscpy(pstrTemp,pwcsQualifier);
		if(SUCCEEDED(hr = m_QualifierPos.Add(pstrTemp)))
		{
			m_lPos++;
		}
		else
		{
			SAFE_DELETE_ARRAY(pstrTemp);
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set relation position 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CQualiferPos::SetRelPos(DBROWOFFSET lRelPos)
{
	HRESULT hr = S_OK;

	if( m_QualifierPos.Size() > 0)
	{
		if( (m_lPos + lRelPos) >= m_QualifierPos.Size())
		{
			hr = WBEMERROR_QUALIFER_TOBE_FETCHED;
		}
		else
		if( (m_lPos + lRelPos) < -1)
		{
			hr = DB_E_BADSTARTPOSITION;
		}
		else
		{
			m_lPos = m_lPos + lRelPos;
		}
	}
	else
		hr = lRelPos > 0 ? WBEMERROR_QUALIFER_TOBE_FETCHED :DB_E_BADSTARTPOSITION;

	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************
//
//
//  The COMMAND classes
//
//
//*****************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************
//  The Command Manager, manages all the command interfaces
//*************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCommandManager::CWbemCommandManager(CQuery * p)
{
    m_pClassDefinition = NULL;
    m_pInstanceList = NULL;
    m_pInstance = NULL;
    m_pParms = NULL;
    m_pQuery = p;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCommandManager::~CWbemCommandManager()
{

    // These pointers are all deleted elsewhere, so do not delete, this class is simply a pass-through class
}
///////////////////////////////////////////////////////////////////////////////////////////////////
void CWbemCommandManager::Init(CWbemCommandInstanceList * InstanceList, CWbemCommandParameters * pParms,
                               CWbemCommandClassDefinitionWrapper* pDef)
{
    m_pInstanceList = InstanceList;       
    m_pParms = pParms;
    m_pClassDefinition = pDef;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWbemCommandManager::ValidQuery()
{
    if( m_pQuery ){
        return TRUE;
    }
    return FALSE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandManager::ValidQueryResults()
{
    HRESULT hr = E_FAIL;

    if( ValidQuery() ){
        m_pQuery->m_pcsQuery->Enter();

        if ( !(m_pQuery->GetStatus() & CMD_EXECUTED_ONCE)){

            if ( m_pQuery->GetStatus() & CMD_READY){

                if( m_pInstanceList ){

                    if(SUCCEEDED(hr = m_pInstanceList->SetQuery(m_pQuery->GetQuery(),m_pQuery->GetDialectGuid(),m_pQuery->GetQueryLang())) && 
					SUCCEEDED(hr = m_pClassDefinition->SetQueryType(m_pQuery->GetQuery(),m_pQuery->GetDialectGuid(),m_pQuery->GetQueryLang())) )
//                    if( hr == S_OK )
					{
                        hr = m_pInstanceList->Reset();
                        if( hr == S_OK ){
                            m_pQuery->ClearStatus(CMD_READY);
                            m_pQuery->SetStatus(CMD_EXECUTED_ONCE);        

                        }
                    }
                }
            }
        }
        m_pQuery->m_pcsQuery->Leave();
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandManager::GetClassDefinitionForQueryResults()
{
	CWbemClassInstanceWrapper *pInst = NULL;
    CBSTR strKey;
    HRESULT hr = S_OK;
  	CBSTR stQryLanguage(m_pInstanceList->GetQueryLanguage());
    CBSTR strQuery(m_pInstanceList->GetQuery());
	IEnumWbemClassObject *pEnum = NULL;
	IWbemClassObject *p = NULL;
	ULONG cElem = 0;

	if(NORMAL == GetObjListType())
	{
		// Execute the query just to get the class defination
		if(SUCCEEDED(hr = (m_pParms->GetServicesPtr())->ExecQuery(stQryLanguage, strQuery, WBEM_FLAG_PROTOTYPE,m_pParms->GetContext(),&pEnum)))
		{
			if(SUCCEEDED(hr = pEnum->Next(0,1,&p,&cElem)) && cElem > 0)
			{
				pEnum->Release();

				((CWbemClassWrapper*)(m_pClassDefinition))->SetClass(p);
			}
			SAFE_RELEASE_PTR(p);
		}
		else
		{
			hr = E_FAIL;
		}
	}

    return hr;
}

INSTANCELISTTYPE CWbemCommandManager::GetObjListType() 
{ 
	return m_pClassDefinition->GetObjListType(); 
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************
//  The Command parameters
//*************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCommandParameters::CWbemCommandParameters(DWORD dwFlags,CWbemConnectionWrapper * Connect,CWbemCommandManager * p) :
        CWbemClassParameters(dwFlags,(WCHAR*)NULL,Connect)
{
	m_pwcsClassName	= new WCHAR [wcslen(szInstance) + 1];
	wcscpy(m_pwcsClassName,szInstance);
    m_pCmdManager = p;            
}
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCommandParameters::~CWbemCommandParameters()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************
//  The Command class definition
//*************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCommandClassDefinitionWrapper::CWbemCommandClassDefinitionWrapper( CWbemClassParameters * p,CWbemCommandManager * pCmd )
: CWbemClassDefinitionWrapper(p)
{
    m_nMaxColumns	= 0;
    m_pCmdManager	= pCmd;
	m_objListType	= NORMAL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCommandClassDefinitionWrapper::~CWbemCommandClassDefinitionWrapper()
{

}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandClassDefinitionWrapper::ValidClass()
{
    if( ! m_pCmdManager->ValidQuery() ) {
        return E_FAIL;
    }
    return S_OK;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get the total number of columns for a resultset on executing a command
// NTRaid:142133
// 07/11/2000
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandClassDefinitionWrapper::TotalPropertiesInClass(ULONG & ulPropCount, ULONG &ulSysPropCount)
{
    HRESULT hr = E_FAIL;

    hr = m_pCmdManager->ValidQueryResults();

    if( hr == S_OK ){
        hr = m_pCmdManager->GetClassDefinitionForQueryResults();
		
        if(hr == S_OK){
			switch(m_pCmdManager->GetObjListType())
			{
				case NORMAL:
					{
			            hr = CWbemClassWrapper::TotalPropertiesInClass(ulPropCount,ulSysPropCount);
					}
					break;

				case MIXED:
					{
						//  if it is a heterogenous objects then just have column for 
						// only the __PATH
						ulPropCount		= 0;
						ulSysPropCount	= 1;
						hr				= S_OK;
					}
					break;
			}
        }
		else
		// this means that the query was unable to get return any object or unable
		// to get the prototype of the resultant object for query execution
		if(SUCCEEDED(hr))
		{
			ulPropCount		= 0;
			ulSysPropCount	= 0;
			hr				= S_FALSE;
		}
    }

    return MapWbemErrorToOLEDBError(hr);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to set the query type after looking for "ASSOCIATORS OF" and "REFERENCES OF" in the query
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandClassDefinitionWrapper::SetQueryType(LPCWSTR strQry,GUID QryDialect,LPCWSTR strQryLang)
{
	HRESULT hr			= S_OK;
	BOOL	bLDAPQry	= FALSE;
   
	if((strQryLang != NULL && _wcsicmp(strQryLang,szWQL) == 0) && 
	   (!wbem_wcsincmp(strQry,szReferenceOfQry,wcslen(szReferenceOfQry)) || 
		!wbem_wcsincmp(strQry,szAssociatersQry,wcslen(szAssociatersQry))) )
	{
		m_objListType = MIXED;
	}
	else
	if((QryDialect == DBGUID_DEFAULT || QryDialect == DBGUID_WQL) && 
	   (!wbem_wcsincmp(strQry,szReferenceOfQry,wcslen(szReferenceOfQry)) || 
		!wbem_wcsincmp(strQry,szAssociatersQry,wcslen(szAssociatersQry))) )
	{
		m_objListType = MIXED;
	}
	else
	if((strQryLang != NULL && _wcsicmp(strQryLang,szWQL)) ||
		(QryDialect != DBGUID_DEFAULT && QryDialect != DBGUID_WQL) )
	{
		hr = E_FAIL;
		if(strQryLang  != NULL)
		{
			if(_wcsicmp(strQryLang,szLDAP) == 0)
			{
				bLDAPQry = TRUE;
				m_objListType = MIXED;
				hr = S_OK;
			}
			else
			if(_wcsicmp(strQryLang,szLDAPSQL) == 0)
			{
				bLDAPQry = FALSE;
				hr = S_OK;
			}
			else
			{
				hr = E_FAIL;
			}
		}
		else
		if(QryDialect == DBGUID_LDAP)
		{
			bLDAPQry = TRUE;
			m_objListType = MIXED;
			hr = S_OK;
		}
		if(QryDialect == DBGUID_LDAPSQL)
		{
			bLDAPQry = FALSE;
			m_objListType = MIXED;
			hr = S_OK;
		}
	}

	if(SUCCEEDED(hr) && bLDAPQry == FALSE)
	{
		// check if the query is "SELECT * FROM" type of query
		// if so then set the query type to MIXED
		WCHAR *pStrQry			= NULL;
		WCHAR *strToken			= NULL;
		WCHAR strSeparator[]		= L" ";

		pStrQry			= new WCHAR[wcslen(strQry) + 1];
		
		if(pStrQry)
		{
			// by default query is MIXED for LDAP and SQL Queries
			// except that if it is select col1,col2 from ...
			m_objListType = MIXED;
			memset(pStrQry,0,sizeof(WCHAR) * wcslen(strQry) + 1);
			wcscpy(pStrQry,strQry);
			strToken				= wcstok( pStrQry, strSeparator );

			if(strToken && _wcsicmp(L"Select",strToken) == 0)
			{
				m_objListType = NORMAL;
				strToken			= wcstok( NULL, strSeparator );
			   if(strToken && _wcsicmp(L"*",strToken) == 0)
			   {
					strToken = wcstok( NULL, strSeparator );
				   if(strToken && _wcsicmp(L"FROM",strToken) == 0)
				   {
						m_objListType = MIXED;
				   }
			   }
			}
		}
		else
		{
		   hr = E_OUTOFMEMORY;
		}
		SAFE_DELETE_ARRAY(pStrQry);
   }

	return hr;
}

/*///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandClassDefinitionWrapper::BeginPropertyEnumeration()
{
    return CWbemClassWrapper::BeginPropertyEnumeration();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandClassDefinitionWrapper::EndPropertyEnumeration()
{
    return CWbemClassWrapper::EndPropertyEnumeration();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandClassDefinitionWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor )
{
    return CWbemClassWrapper::GetNextProperty(pProperty,vValue,pType,plFlavor);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandClassDefinitionWrapper::BeginPropertyQualifierEnumeration(BSTR strPropName)
{
    return CWbemClassWrapper::BeginPropertyQualifierEnumeration(strPropName);
}*/
///////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************
//  The Command instance list
//*************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCommandInstanceList::CWbemCommandInstanceList(CWbemClassParameters * p,CWbemCommandManager * pCmd): CWbemInstanceList(p)
{
    m_pCmdManager = pCmd;
    m_pParms = p;
    m_nBaseType = COMMAND_ROWSET; 
	m_pwstrQueryLanguage	= NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCommandInstanceList::~CWbemCommandInstanceList()
{
	SAFE_DELETE_ARRAY(m_pwstrQueryLanguage);
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandInstanceList::Reset()
{
	HRESULT hr = E_FAIL;

  	CBSTR strQryLanguage(m_pwstrQueryLanguage);
    CBSTR strQuery(m_pwstrQuery);
	BOOL	bExecQuery = TRUE;
	LONG	lFlags = m_pParms->m_dwNavFlags | m_pParms->m_dwQueryFlags | WBEM_FLAG_ENSURE_LOCATABLE;

	if(m_ppEnum != NULL)
	{
		if(WBEM_FLAG_FORWARD_ONLY & m_pParms->m_dwNavFlags)
		{
			ReleaseAllInstances();
			m_ppEnum->Release();
			m_ppEnum			= NULL;
		}
		else
		{
			hr = m_ppEnum->Reset();
			bExecQuery = FALSE;
		}
	}


	if( bExecQuery)
	{
		hr = (m_pParms->GetServicesPtr())->ExecQuery(strQryLanguage, 
													strQuery, 
													lFlags,
													m_pParms->GetContext(),
													&m_ppEnum);
		m_lCurrentPos = 0;
	}

	if(hr == S_OK)
	{
		m_lCurrentPos = 0;
//		m_FetchDir	  = FETCHDIRFORWARD;
	}

    return hr;
}

HRESULT CWbemCommandInstanceList::SetQuery( LPWSTR p,GUID QryDialect,LPCWSTR strQryLang)
{ 
	HRESULT hr = E_OUTOFMEMORY;
	m_pwstrQuery = p; 
	SAFE_DELETE_ARRAY(m_pwstrQueryLanguage);

	if(strQryLang == NULL)
	{
		if(QryDialect == DBGUID_WQL || QryDialect == DBGUID_DEFAULT)
		{
			m_pwstrQueryLanguage = new WCHAR[wcslen(szWQL) + 1];
			if(m_pwstrQueryLanguage)
			{
				wcscpy(m_pwstrQueryLanguage,szWQL);
				hr = S_OK;
			}
		}
		else
		if(QryDialect == DBGUID_LDAP)
		{
			// MOdify the string here to be passed for executing
			// LDAP queries
			m_pwstrQueryLanguage = new WCHAR[wcslen(szLDAP) + 1];
			if(m_pwstrQueryLanguage)
			{
				wcscpy(m_pwstrQueryLanguage,szLDAP);
				hr = S_OK;
			}
		}
		else
		if(QryDialect == DBGUID_LDAPSQL)
		{
			// MOdify the string here to be passed for executing
			// LDAP queries
			m_pwstrQueryLanguage = new WCHAR[wcslen(szLDAPSQL) + 1];
			if(m_pwstrQueryLanguage)
			{
				wcscpy(m_pwstrQueryLanguage,szLDAPSQL);
				hr = S_OK;
			}
		}
		else
		if(QryDialect == DBGUID_WMI_METHOD)
		{
			hr = S_OK;
		}
		else
		{
			hr = E_FAIL;
		}
	}
	else
	{
		m_pwstrQueryLanguage = new WCHAR[wcslen(strQryLang) + 1];
		if(m_pwstrQueryLanguage)
		{
			wcscpy(m_pwstrQueryLanguage,strQryLang);
			hr = S_OK;
		}
	}
	return hr; 
}


///////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************
//  The Command instance wrapper list
//*************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCommandInstanceWrapper::CWbemCommandInstanceWrapper(CWbemClassParameters * p, CWbemCommandManager * pCmd ): CWbemClassInstanceWrapper(p)
{
    m_pCmdManager = pCmd;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCommandInstanceWrapper::~CWbemCommandInstanceWrapper()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////
WCHAR * CWbemCommandInstanceWrapper::GetClassName()
{
	WCHAR *pClass = NULL;
	BSTR strPropName;
	HRESULT hr = 0;

	// Get the class name only if query is mixed 
	// meaning heteregenous objects are requested
	if(MIXED == m_pCmdManager->GetObjListType())
	{
		strPropName = Wmioledb_SysAllocString(L"__Class");

		VARIANT varClassName;
		VariantInit(&varClassName);

		// Get the class name
		hr = m_pClass->Get(strPropName,0, &varClassName , NULL , NULL);

		SysFreeString(strPropName);

		if( hr == S_OK)
		{	
			AllocateAndCopy(pClass,varClassName.bstrVal);
			VariantClear(&varClassName);
		}
	}

	return pClass;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  Function to get __PATH of the instance
// __PATH property makes sense only when REFERENCES OF or ASSOCIATERS OF query is run
// otherwise __PATH property will be NULL string
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandInstanceWrapper::GetKey(CBSTR & Key)
{
    CVARIANT var;
	HRESULT hr = E_FAIL;

	// NTRaid: 130047
	// Get the Key name only if query is mixed 
	// meaning heteregenous objects are requested
//	if(MIXED == m_pCmdManager->GetObjListType())
	{
		if(FAILED(hr = GetProperty(L"__URL",var)))
		{
			hr = GetProperty(L"__PATH",var );
		}
		if( hr == S_OK )
		{
			Key.SetStr(var.GetStr());
		}
	}
    return MapWbemErrorToOLEDBError(hr);    
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// This method applies only for instances obtained from REFERENCES OF or ASSOCIATERS OF query
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCommandInstanceWrapper::RefreshInstance()
{
	HRESULT hr = S_OK;

	// Get the Key name only if query is mixed 
	// meaning heteregenous objects are requested
	if(MIXED == m_pCmdManager->GetObjListType())
	{
		hr  = CWbemClassInstanceWrapper::RefreshInstance();
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************
//  The Method class definition
//*************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////
//  The Method parameters
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemMethodParameters::CWbemMethodParameters(CQuery * p, DWORD dwFlags,CWbemConnectionWrapper * Connect) :
        CWbemClassParameters(dwFlags,(WCHAR*)NULL,Connect)
{
	m_pwcsClassName	= new WCHAR [wcslen(szInstance) + 1];
	wcscpy(m_pwcsClassName,szInstance);

    m_pQuery = p;
    m_pwcsInstance=NULL;
    m_pwcsMethod=NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemMethodParameters::~CWbemMethodParameters()
{
    SAFE_DELETE_PTR(m_pwcsInstance);
    SAFE_DELETE_PTR(m_pwcsMethod);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodParameters::ExtractNamesFromQuery()
{
    HRESULT hr = DB_E_ERRORSINCOMMAND;
    WCHAR * wcsQuery = m_pQuery->GetQuery();

    //=======================================================================
    // The purpose of this function is to extract the class name and 
    // method name from the query string.  This query is in the format of:
    //  Win32_Process.Handle="20".GetOwner 
    //=======================================================================
    DeleteClassName();
    SAFE_DELETE_PTR(m_pwcsInstance);
    SAFE_DELETE_PTR(m_pwcsMethod);

    int nMax = wcslen(wcsQuery);

	// NTRaid: 136429
	// 07/05/00
    WCHAR *pTmp1 = NULL;
	WCHAR *pTmp2 = NULL;
	WCHAR *pTmp3 = NULL;
	WCHAR *pTmp4 = NULL;

    pTmp1    = new WCHAR[nMax];
    pTmp2    = new WCHAR[nMax];
    pTmp3    = new WCHAR[nMax];
    pTmp4    = new WCHAR[nMax];


    if( pTmp1 && pTmp2 && pTmp3 && pTmp4 ){

		memset(pTmp1,0,nMax * sizeof(WCHAR));
		memset(pTmp2,0,nMax * sizeof(WCHAR));
		memset(pTmp3,0,nMax * sizeof(WCHAR));
		memset(pTmp4,0,nMax * sizeof(WCHAR));

		swscanf(wcsQuery,L"%[^.].%[^=]=%[^.].%s",pTmp1,pTmp2,pTmp3,pTmp4);
        //============================================================
         //        Win32_Process.Handle="20"     .GetOwner
        //============================================================
		if(wcslen(pTmp4) == 0 || wcslen(pTmp3) == 0)
		{
			swscanf(wcsQuery,L"%[^=].%s",pTmp1,pTmp2);
		}
		else
		{
			swscanf(wcsQuery,L"%[^.].%s",pTmp1,pTmp2);
		}
		_wcsrev(wcsQuery);
        swscanf(wcsQuery,L"%[^.].%s",pTmp4,pTmp2);
		_wcsrev(wcsQuery);
		if(wcslen(pTmp4) > 0 && wcslen(pTmp2) > 0 && wcslen(pTmp1) && 
			wcscmp(pTmp1,pTmp4) != 0)
		{
			_wcsrev(pTmp4);
			_wcsrev(pTmp2);
			hr = S_OK;
		}
		else
		{
			hr = DB_E_ERRORSINCOMMAND;
		}

		if(SUCCEEDED(hr))
		{
	

	//        swscanf(wcsQuery,L"%[^.].%[^=]=\"%[^\"]\".%s",pTmp1,pTmp2,pTmp3,pTmp4);

			if( pTmp1 && pTmp2 && pTmp4)
			{
				SetClassName(pTmp1);
				AllocateAndCopy(m_pwcsMethod,pTmp4);
				AllocateAndCopy(m_pwcsInstance,pTmp2);
				hr = S_OK;
			}
/*
	        swscanf(wcsQuery,L"%[^.].%[^=]=\"%[^\"]\".%s",pTmp1,pTmp2,pTmp3,pTmp4);
			if( pTmp1 && pTmp2 && pTmp3 && pTmp4){
				SetClassName(pTmp1);
				AllocateAndCopy(m_pwcsMethod,pTmp4);
				AllocateAndCopy(m_pwcsInstance,wcsQuery);

				m_pwcsInstance = new WCHAR[nMax];
				if( m_pwcsInstance ){
					swprintf(m_pwcsInstance,L"%s.%s=\"%s\"",pTmp1,pTmp2,pTmp3);
					hr = S_OK;
				}
			
			}
*/		}
    }
    else{
        hr = E_OUTOFMEMORY;
    }

    SAFE_DELETE_PTR(pTmp1);
    SAFE_DELETE_PTR(pTmp2);
    SAFE_DELETE_PTR(pTmp3);
    SAFE_DELETE_PTR(pTmp4);

    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodParameters::ValidMethod()
{

    HRESULT hr = E_FAIL;

    if( GetClassName() && m_pwcsInstance && m_pwcsMethod ){
        hr = S_OK;
    }
 
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//  The class definition for method
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemMethodClassDefinitionWrapper::CWbemMethodClassDefinitionWrapper(CWbemMethodParameters * parm )
: CWbemClassDefinitionWrapper(parm)
{
     m_nMaxColumns = 0;
     m_nCount = 0;
     m_pInClass = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemMethodClassDefinitionWrapper::~CWbemMethodClassDefinitionWrapper()
{
    SAFE_RELEASE_PTR( m_pInClass );
} 
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodClassDefinitionWrapper::Init()
{
    HRESULT hr = DB_E_ERRORSINCOMMAND;

    //=======================================================================
    // The purpose of this function is to extract the class name and 
    // method name from the query string.  This query is in the format of:
    //  Win32_ProcessHandle="20".GetOwner 
    //=======================================================================

    hr = ((CWbemMethodParameters*) m_pParms)->ExtractNamesFromQuery();

    //=======================================================================
    // Any other initialization?
    //=======================================================================
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodClassDefinitionWrapper::ValidClass()
{
    return ((CWbemMethodParameters*) m_pParms)->ValidMethod();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodClassDefinitionWrapper::TotalPropertiesInClass(ULONG & ulPropCount, ULONG &ulSysPropCount)
{
    //=======================================================================
    //  Since we are return the output parameters are the rowset, we are
    //  intereseted in the properties of the output parameter class
    //=======================================================================
    HRESULT hr = E_FAIL;
    IWbemClassObject * pClass = NULL;

	CBSTR bstrClass(((CWbemMethodParameters*) m_pParms)->GetClassName());
    CBSTR bstrMethod(((CWbemMethodParameters*) m_pParms)->GetMethodName());
    CBSTR bstrInstance(((CWbemMethodParameters*) m_pParms)->GetInstanceName());


    hr = (m_pParms->GetServicesPtr())->GetObject(bstrClass, 0,m_pParms->GetContext(), &pClass, NULL);
	if( hr == S_OK ){

    	//==========================================================
	    //  Now, get the list of Input and Output parameters
	    //==========================================================
	    hr = pClass->GetMethod(bstrMethod, 0, &m_pInClass, &m_pClass);
        if( hr == S_OK ){
            hr = CWbemClassWrapper::TotalPropertiesInClass(ulPropCount,ulSysPropCount);
        }

	}

    SAFE_RELEASE_PTR(pClass);
    return hr;
}
/*///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodClassDefinitionWrapper::BeginPropertyEnumeration()
{

}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodClassDefinitionWrapper::EndPropertyEnumeration()
{
    m_nCount = 0;
    return S_OK;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodClassDefinitionWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor )
{
    HRESULT hr = WBEM_S_NO_MORE_DATA;

    if( m_nCount == 1 ){
        *plFlavor = 0l;
        *pType = CIM_BOOLEAN;
      	*pProperty = Wmioledb_SysAllocString(L"SUCCESS");
    }

    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodClassDefinitionWrapper::BeginPropertyQualifierEnumeration(BSTR strPropName)
{
    return S_OK;
}*/
///////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************
//  The Method instance list
//*************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemMethodInstanceList::CWbemMethodInstanceList(CWbemMethodParameters * p,CWbemMethodClassDefinitionWrapper * pDef): CWbemInstanceList(p)
{
    m_pParms = p;
    m_pClassDefinition = pDef;
    m_nBaseType = METHOD_ROWSET; 
}
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemMethodInstanceList::~CWbemMethodInstanceList()
{
}


HRESULT CWbemMethodInstanceList::GetInputParameterName(IWbemClassObject *pObject,DBORDINAL iOrdinal , BSTR &strPropName)
{
	HRESULT hr = S_OK;

	if(SUCCEEDED(hr = pObject->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
	{
		for(DBORDINAL i = 0 ; i < iOrdinal && SUCCEEDED(hr); i++)
		{
			hr = pObject->Next(0,&strPropName,NULL,NULL,NULL);
			if(i != iOrdinal && SUCCEEDED(hr))
			{
				SysFreeString(strPropName);
			}
		}
		pObject->EndEnumeration();
	}

	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
// Function gets the input parameter values and puts it to a input parameters object which it returns
HRESULT CWbemMethodInstanceList::ProcessInputParameters(IWbemClassObject **ppParamInput)
{
    HRESULT hr = S_OK;
	IWbemClassObject *pParamInput = NULL;
	LONG	lType		= 0;
	CDataMap map;
	VARIANT varParamValue;
	VariantInit(&varParamValue);

    //===========================================================
    //  Enumerate the properties, read them from the parameter
    //  list and put them in the input class
    //===========================================================
    if( m_pClassDefinition->GetInputClassPtr() ){

        ((CWbemMethodParameters*)m_pParms)->m_pQuery->m_pcsQuery->Enter();

      	PPARAMINFO	pParamInfo;
    	ULONG		iParam;
        ULONG       uCount = ((CWbemMethodParameters*)m_pParms)->m_pQuery->GetParamCount();
		// Spawn an instance of input paramter object
		hr = m_pClassDefinition->GetInputClassPtr()->SpawnInstance(0,&pParamInput);
		
		for (iParam = 0; iParam <uCount; iParam++){
			
			VariantClear(&varParamValue);
			pParamInfo = (PPARAMINFO)((CWbemMethodParameters*)m_pParms)->m_pQuery->GetParam(iParam);
			if (pParamInfo && (pParamInfo->dwFlags & DBPARAMFLAGS_ISINPUT)){

                CBSTR bstrProperty(pParamInfo->pwszParamName);
	
				if(pParamInfo->pwszParamName == NULL)
				{
					GetInputParameterName(pParamInput,pParamInfo->iOrdinal,(BSTR&)bstrProperty);
				}

                if(S_OK == (hr =  pParamInput->Get(bstrProperty,0,NULL,&lType,NULL)))
				{
					// Call this function to convert the OLEDB bound type to CIMTYPE of the parameter
					hr = map.ConvertToCIMType(pParamInfo->pbData,pParamInfo->wOLEDBType,pParamInfo->cbColLength,lType,varParamValue);
					
					// if the value is not empty put the value of the parameter
					if( varParamValue.vt != VT_EMPTY && varParamValue.vt != VT_NULL)
						hr =  pParamInput->Put(bstrProperty,0,&varParamValue,0);

					if( S_OK != hr ){
						break;
					}
					else
					{
						*ppParamInput = NULL;
						hr = pParamInput->QueryInterface(IID_IWbemClassObject , (void **)ppParamInput);
					}
				}
			}
		}
		VariantClear(&varParamValue);
		SAFE_RELEASE_PTR(pParamInput);
        ((CWbemMethodParameters*)m_pParms)->m_pQuery->m_pcsQuery->Leave();
    }
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodInstanceList::ProcessOutputParameters()
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    IWbemClassObject * pClass = ((CWbemClassWrapper*) m_pClassDefinition)->GetClass();
	VARIANT varValue;
	VariantInit(&varValue);
    //===========================================================
    //  Enumerate the properties, read them and update the values
    //  in the parameter list
    //===========================================================

    if( pClass ){
		hr = S_OK;
        ((CWbemMethodParameters*)m_pParms)->m_pQuery->m_pcsQuery->Enter();

      	PPARAMINFO	pParamInfo;
    	ULONG		iParam;
        ULONG       uCount = ((CWbemMethodParameters*)m_pParms)->m_pQuery->GetParamCount();

		for (iParam = 0; iParam <uCount; iParam++){

			pParamInfo = (PPARAMINFO)((CWbemMethodParameters*)m_pParms)->m_pQuery->GetParam(iParam);
			
			if (pParamInfo && (pParamInfo->dwFlags & DBPARAMFLAGS_ISOUTPUT))
			{

                CBSTR bstrProperty(pParamInfo->pwszParamName);

                hr = pClass->Get(bstrProperty,0,&varValue,&(pParamInfo)->CIMType,&(pParamInfo)->Flavor);

				if( hr == S_OK)
				{
					CDataMap map;
					DWORD dwStatus = 0;
					// set the size to the maximum available
					pParamInfo->cbColLength = pParamInfo->ulParamSize;
					hr = map.AllocateAndConvertToOLEDBType(varValue,pParamInfo->CIMType , pParamInfo->wOLEDBType ,
										pParamInfo->pbData , pParamInfo->cbColLength , pParamInfo->dwStatus);
					

				}
                if( S_OK != hr ){
					break;
	               }
				VariantClear(&varValue);
			}
		}

        ((CWbemMethodParameters*)m_pParms)->m_pQuery->m_pcsQuery->Leave();

    }

    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodInstanceList::Reset()
{
    HRESULT hr = E_FAIL;

    CBSTR bstrMethod(((CWbemMethodParameters*) m_pParms)->GetMethodName());
    CBSTR bstrInstance(((CWbemMethodParameters*) m_pParms)->GetInstanceName());
    IWbemClassObject ** ppClass = ((CWbemClassWrapper*) m_pClassDefinition)->GetClassPtr();

	IWbemClassObject *pParamInput = NULL;

    hr = ProcessInputParameters(&pParamInput);

    if( S_OK == hr ){

        hr = (m_pParms->GetServicesPtr())->ExecMethod( bstrInstance,bstrMethod, 0, 
                                                                m_pParms->GetContext(), 
                                                                m_pClassDefinition->GetInputClassPtr(), 
                                                                ppClass, NULL);

        //====================================================================
        //  We should update the DBPARAMS array as well as put these results
        //  in a rowset
        //====================================================================
        if( S_OK == hr ){
            hr = ProcessOutputParameters();
        }
    }
    SAFE_RELEASE_PTR(pParamInput);
    return MapWbemErrorToOLEDBError(hr);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodInstanceList::NextInstance(CBSTR & Key, CWbemClassInstanceWrapper ** pInst)
{
	LONG						lRelativePos	= 1;
    HRESULT hr = E_FAIL;

    //============================================================
    //  Now, we only have one instance of output parameters
    //============================================================


    if( m_lCurrentPos == 0 )
	{
		// IF the direction has changed compared to the previous fetch then
		// the first fetch will be the last one fetched
	    if( m_FetchDir == FETCHDIRBACKWARD)
		    lRelativePos = 0;

	    // Check if the instance is already fetched
   	    *pInst = GetInstance(m_lCurrentPos +lRelativePos);
	    if( *pInst == NULL)
		{

	        *pInst = new CWbemMethodInstanceWrapper((CWbemMethodParameters*)m_pParms);

            if( *pInst ){
                IWbemClassObject * pClass = ((CWbemClassWrapper*) m_pClassDefinition)->GetClass();

			    (*pInst)->SetClass(pClass);
			    (*pInst)->SetPos(++m_lCurrentPos);
			    AddInstance(*pInst);
			    (*pInst)->GetKey(Key);

                hr = S_OK;
		    }
		    else
		    {
			    hr = E_OUTOFMEMORY;
		    }
        }
		else
		{
			m_lCurrentPos += lRelativePos;
			m_FetchDir	   = FETCHDIRFORWARD;
			(*pInst)->GetKey(Key);
			hr = S_OK;
		}
    }
    else
	{
        hr = WBEM_S_NO_MORE_DATA;
    }

    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodInstanceList::PrevInstance( CBSTR & Key, CWbemClassInstanceWrapper *& pInst)
{
   	HRESULT		hr			 = S_OK;
	DBROWOFFSET	lRelativePos = -1;

	// IF the direction has changed compared to the previous fetch then
	// the first fetch will be the last one fetched
	if( m_FetchDir == FETCHDIRFORWARD)
		lRelativePos = 0;

	// Reset the position to the so that 
	// NextInstance function gives the instance required

	hr = ResetRelPosition(lRelativePos);
	pInst = GetInstance(m_lCurrentPos);
	if(pInst != NULL)
		pInst->GetKey(Key);

	m_FetchDir	= FETCHDIRBACKWARD;

    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************
//  The Method instance wrapper list
//*************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemMethodInstanceWrapper::CWbemMethodInstanceWrapper(CWbemMethodParameters * p): CWbemClassInstanceWrapper(p)
{

//    m_nBaseType = METHOD_ROWSET; // METHOD_ROWSET
}
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemMethodInstanceWrapper::~CWbemMethodInstanceWrapper()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodInstanceWrapper::ResetInstanceFromKey(CBSTR Key)
{
    // This doesn't really apply to methods
    return S_OK;
}    
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodInstanceWrapper::RefreshInstance()
{
    // This doesn't really apply to methods
    return S_OK;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
WCHAR * CWbemMethodInstanceWrapper::GetClassName()
{
    return m_pParms->GetClassName();
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemMethodInstanceWrapper::GetKey(CBSTR & Key)
{
    HRESULT hr = S_OK;
    Key.SetStr(L"OutputParameters");
    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//			CWbemCollectionClassDefinitionWrapper class implementation
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCollectionClassDefinitionWrapper::CWbemCollectionClassDefinitionWrapper(CWbemClassParameters * p,
																			 WCHAR * pstrPath,
																			 INSTANCELISTTYPE objListType)
		:CWbemClassDefinitionWrapper(p,
		((pstrPath == NULL) || (pstrPath != NULL && wcscmp(pstrPath,OPENCOLLECTION) == 0)) ? FALSE : TRUE)
{
	m_pstrPath = NULL;
	if((pstrPath == NULL) || (pstrPath != NULL && wcscmp(pstrPath,OPENCOLLECTION) == 0))
	{
		m_objListType = objListType;
	}
	else
	{
		m_objListType = NORMAL;
	}
}

HRESULT CWbemCollectionClassDefinitionWrapper::Initialize(WCHAR * pstrPath)
{
	HRESULT hr = S_OK;
	WCHAR *pStrTemp = (WCHAR *)OPENCOLLECTION;

	if(pstrPath != NULL)
	{
		pStrTemp = pstrPath;
	}

	m_pstrPath	= new WCHAR[wcslen(pStrTemp) + 1];
	if(m_pstrPath)
	{
		wcscpy(m_pstrPath,pStrTemp);
		// function to get the class defination object if required
		hr = Init(m_objListType == NORMAL);
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	return hr;
}

CWbemCollectionClassDefinitionWrapper::~CWbemCollectionClassDefinitionWrapper()
{
	SAFE_DELETE_ARRAY(m_pstrPath);
}

HRESULT CWbemCollectionClassDefinitionWrapper::ValidClass()
{
    return S_OK;
}

HRESULT CWbemCollectionClassDefinitionWrapper::TotalPropertiesInClass(ULONG & ulPropCount, ULONG &ulSysPropCount)
{
	HRESULT hr = S_OK;
	// if the rowset refers to a mixed rowset then
	// there is only one column in the row
	if(m_objListType != NORMAL)
	{
		ulPropCount		= 0;
		ulSysPropCount	= 1;
	}
	else
	{
		hr = CWbemClassDefinitionWrapper::TotalPropertiesInClass(ulPropCount,ulSysPropCount);
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//			CWbemCollectionInstanceList class implementation
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

CWbemCollectionInstanceList::CWbemCollectionInstanceList(CWbemClassParameters * p,CWbemCollectionManager * pCollectionMgr) 
:CWbemInstanceList(p)
{
	m_pColMgr = pCollectionMgr;
}

CWbemCollectionInstanceList::~CWbemCollectionInstanceList()
{
}

HRESULT CWbemCollectionInstanceList::Reset()
{
    HRESULT hr = E_UNEXPECTED;
	BOOL	bGetInstanceEnum = TRUE;
    //============================================================
    //  If we already got an enumeration, reset it, otherwise
    //  don't
    //============================================================
    if( m_ppEnum ){
		if(WBEM_FLAG_FORWARD_ONLY & m_pParms->m_dwNavFlags)
		{
			ReleaseAllInstances();
			m_ppEnum->Release();
			m_ppEnum			= NULL;
		}
		else
		{
			hr = m_ppEnum->Reset();
			bGetInstanceEnum	= FALSE;
		}
    }

	if(bGetInstanceEnum	== TRUE)
    {
		IWbemServicesEx *pServicesEx		= NULL;

		if(SUCCEEDED(hr = m_pParms->GetServicesPtr()->QueryInterface(IID_IWbemServicesEx,(void **)&pServicesEx)))
		{
			long lFlags = 0;
			CBSTR strPath;
			strPath.SetStr(m_pColMgr->GetObjectPath());
			INSTANCELISTTYPE colType = m_pColMgr->GetObjListType();

			hr = pServicesEx->CreateInstanceEnum(strPath,
												m_pParms->m_dwNavFlags | m_pParms->m_dwQueryFlags,
												m_pParms->GetContext(),
												&m_ppEnum);

			SAFE_RELEASE_PTR(pServicesEx);
		}

		if( hr == S_OK)
		{
			m_cTotalInstancesInEnum = 0;
		}
    }
	if(hr == S_OK)
	{
		m_lCurrentPos = 0;
	}

    return MapWbemErrorToOLEDBError(hr);
}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//			CWbemCollectionParameters class implementation
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCollectionParameters::CWbemCollectionParameters(DWORD dwFlags,CWbemConnectionWrapper * pWrap ,WCHAR *pClassName)
			: CWbemClassParameters(dwFlags,NULL,pWrap)
{
	m_pServices		= NULL;
	m_pwcsClassName = NULL;
}

CWbemCollectionParameters::~CWbemCollectionParameters()	
{ 
	SAFE_RELEASE_PTR(m_pServices);
}

HRESULT CWbemCollectionParameters::Init(BSTR strPath,CWbemConnectionWrapper * pWrap)
{
	HRESULT		hr			= S_OK;
	WCHAR *		pStrTemp	= NULL;
	
	if(strPath == NULL || (strPath != NULL && wcscmp(strPath,OPENCOLLECTION) == 0))
	{
		pStrTemp = (WCHAR *)szInstance;
	}
	else
	{
		pStrTemp = strPath;
	}
	
	m_pwcsClassName	= new WCHAR [wcslen(pStrTemp) + 1];
	if(m_pwcsClassName)
	{
		wcscpy(m_pwcsClassName,pStrTemp);
		hr = pWrap->GetServicesPtr()->QueryInterface(IID_IWbemServices,(void **)&m_pServices);
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}


    return MapWbemErrorToOLEDBError(hr);    

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//			CWbemCollectionInstanceList class implementation
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCollectionManager::CWbemCollectionManager()
{
	m_pClassDefinition	= NULL;
	m_pInstanceList		= NULL;
	m_pInstance			= NULL;
	m_pParms			= NULL;
	
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCollectionManager::~CWbemCollectionManager()
{
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Initialization function
///////////////////////////////////////////////////////////////////////////////////////////////////
void CWbemCollectionManager::Init(CWbemCollectionInstanceList * InstanceList, CWbemCollectionParameters * pParms,CWbemCollectionClassDefinitionWrapper* pDef)
{
	m_pClassDefinition	= pDef;
	m_pInstanceList		= InstanceList;
	m_pInstance			= NULL;
	m_pParms			= pParms;

	CBSTR strPath;
	strPath.SetStr(GetObjectPath());
	INSTANCELISTTYPE colType = GetObjListType();
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//			CWbemCollectionInstanceWrapper class implementation
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
// Consturctor
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCollectionInstanceWrapper::CWbemCollectionInstanceWrapper(CWbemClassParameters * p,CWbemCollectionManager * pWbemColMgr)
	:CWbemClassInstanceWrapper(p)
{
	m_pColMgr = pWbemColMgr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
///////////////////////////////////////////////////////////////////////////////////////////////////
CWbemCollectionInstanceWrapper::~CWbemCollectionInstanceWrapper()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Get classname of the object
///////////////////////////////////////////////////////////////////////////////////////////////////
WCHAR * CWbemCollectionInstanceWrapper::GetClassName()
{
	WCHAR *pClass = NULL;
	BSTR strPropName;
	HRESULT hr = 0;

	strPropName = Wmioledb_SysAllocString(L"__Class");

	VARIANT varClassName;
	VariantInit(&varClassName);

	// Get the class name
	hr = m_pClass->Get(strPropName,0, &varClassName , NULL , NULL);

	SysFreeString(strPropName);

	if( hr == S_OK)
	{	
		AllocateAndCopy(pClass,varClassName.bstrVal);
		VariantClear(&varClassName);
	}

	return pClass;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
// Refreshing the instance
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCollectionInstanceWrapper::GetKey(CBSTR & Key)
{
    CVARIANT var;
	HRESULT hr = E_FAIL;

	if(FAILED(hr = GetProperty(L"__URL",&var)))
	{
		hr = GetProperty(L"__PATH",var );
	}
	if( hr == S_OK )
	{
		Key.SetStr(var.GetStr());
	}
    return MapWbemErrorToOLEDBError(hr);    
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Refreshing the instance
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemCollectionInstanceWrapper::RefreshInstance()
{
	return CWbemClassInstanceWrapper::RefreshInstance();

}


///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
//	CWbemSecurityDescriptor class implementaion
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemSecurityDescriptor::CWbemSecurityDescriptor()
{
	m_strPath = NULL;
	m_pISerEx = NULL;
	m_lSdSize = 0;
	m_pAccessor = NULL;
	m_pIContext	= NULL;

	InitializeSecurityDescriptor(&m_sd,SECURITY_DESCRIPTOR_REVISION);

}

HRESULT CWbemSecurityDescriptor::Init(IWbemServices *pSer,BSTR strPath,IWbemContext *pContext)
{
	ULONG lSDSize = 0;
	HRESULT hr = S_OK;

	if(SUCCEEDED(hr = pSer->QueryInterface(IID_IWbemServicesEx , (void**)&m_pISerEx)))
	{
		if(SUCCEEDED(hr = m_pISerEx->GetObject(strPath,0,m_pIContext,&m_pAccessor,NULL)))
        {
            CIMTYPE lType = 0;
			hr = m_pAccessor->Get(CBSTR(L"__SD"),0,&m_sd,&lType,NULL);
		}
	}
	
	m_pIContext = pContext;
	if(m_pIContext)
	{
		m_pIContext->AddRef();
	}
	return hr;
}

CWbemSecurityDescriptor::~CWbemSecurityDescriptor()
{
	SAFE_RELEASE_PTR(m_pISerEx);
	SAFE_RELEASE_PTR(m_pAccessor);
	SAFE_RELEASE_PTR(m_pIContext);
	
	SAFE_FREE_SYSSTRING(m_strPath);
}

HRESULT CWbemSecurityDescriptor::PutSD()
{
	HRESULT hr;

  	if(SUCCEEDED(hr = m_pAccessor->Put(CBSTR(L"__SD"),0,&m_sd,VT_ARRAY|VT_UI1)))
	{
		hr = m_pISerEx->PutInstance(m_pAccessor,0,m_pIContext,NULL);
	}
	return hr;
}

BOOL CWbemSecurityDescriptor::GetSID(TRUSTEE_W *pTrustee, PSID & psid)
{
	WCHAR *pName = NULL;
	BOOL bLookUp = FALSE;
	PSID psidTemp = NULL;
	ULONG lSID	 = 0;
	BOOL bRet = TRUE;
	BYTE *pMem = NULL;
	
	switch(GetTrusteeFormW(pTrustee))
	{
		case TRUSTEE_IS_NAME:
			pName = GetTrusteeNameW(pTrustee);
			bLookUp = TRUE;
			break;

			// THis is only in windows 2000
		case TRUSTEE_IS_OBJECTS_AND_NAME:
			pName = ((OBJECTS_AND_NAME_W *)GetTrusteeNameW(pTrustee))->ptstrName;
			bLookUp = TRUE;
			break;

		case TRUSTEE_IS_OBJECTS_AND_SID:
			psidTemp	= ((OBJECTS_AND_SID *)GetTrusteeNameW(pTrustee))->pSid;
			break;

		case TRUSTEE_IS_SID : 
			psidTemp = (PSID)GetTrusteeNameW(pTrustee);
			break;
	}

	if(bLookUp)
	{
		SID_NAME_USE sidNameUseTemp;
		ULONG lDomainName = NULL;
		// Get the length of SID to be allocated
		if(LookupAccountNameW(NULL,pName,NULL,(LPDWORD)&lSID,NULL,(LPDWORD)&lDomainName,&sidNameUseTemp))
		{
			try
			{
				pMem = new BYTE[lSID];
			}
			catch(...)
			{
				SAFE_DELETE_ARRAY(pMem);
				throw;;
			}
			psid = (PSID)pMem;
			bRet = LookupAccountNameW(NULL,pName,psid,(LPDWORD)&lSID,NULL,(LPDWORD)&lDomainName,&sidNameUseTemp);
		}
	}
	else
	{
		lSID = (ULONG)GetLengthSid(psidTemp);
		try
		{
			pMem = new BYTE[lSID];
		}
		catch(...)
		{
			SAFE_DELETE_ARRAY(pMem);
			throw;;
		}
		psid = (PSID)pMem;
		bRet = CopySid(lSID,psid,psidTemp);
	}	

	if(!bRet)
	{
		SAFE_DELETE_ARRAY(pMem);
		psid = NULL;
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\datamap.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Microsoft WMI OLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//	datamap.h
////////////////////////////////////////////////////////////////////////////
#ifndef _DATAMAP_HEADER
#define _DATAMAP_HEADER

/////////////////////////////////////////////////////////////////////
//
// DATAMAP.H
//
//  Module:
//  Purpose: 
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////

// Typedefs ------------------------------------------------------------------
typedef VOID**	LPLPVOID;

typedef long int            SDWORD;
typedef short int           SWORD;
typedef unsigned long int   UDWORD;
typedef unsigned short int  UWORD;
typedef signed long 		SLONG;
typedef unsigned long		ULONG;
typedef unsigned short		USHORT;





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\datasrc.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////////
CDataSource::CDataSource( LPUNKNOWN pUnkOuter )	: CBaseObj(BOT_DATASOURCE, pUnkOuter)
{
	//===============================================
	//  Initialize simple member vars
	//===============================================
	m_cRef              = 0L;
	m_fDSOInitialized   = FALSE;
	m_fDBSessionCreated = FALSE;
	m_pUtilProp         = NULL;

	//===============================================
	//  Initially, NULL all contained interfaces
	//===============================================
	m_pIDBInitialize		= NULL;
	m_pIDBProperties		= NULL;
	m_pIDBInfo				= NULL;
	m_pIDBCreateSession		= NULL;
	m_pIPersistFile			= NULL;
	m_pWbemWrap				= NULL;
	m_pISupportErrorInfo	= NULL;
	m_pIDBDataSourceAdmin	= NULL;	
	m_pIObjectAccessControl	= NULL;
	m_pISecurityInfo		= NULL;

	m_strPersistFileName = Wmioledb_SysAllocString(NULL);
	m_bIsPersitFileDirty = TRUE;

	//===============================================
	// Increment global object count.
	//===============================================
	InterlockedIncrement(&g_cObj);

}

////////////////////////////////////////////////////////////////////////////////////////////////
//
//   Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////////
CDataSource:: ~CDataSource( void )
{
	ULONG	ulRefCount;

	//===============================================
	// Decrement the ref count on the data conversion 
	// object
	//===============================================
	if( g_pIDataConvert ){
		ulRefCount = g_pIDataConvert->Release();
		//===========================================
		// Is it gone for good?
		//===========================================
		if( !ulRefCount )
			g_pIDataConvert = NULL;
	}

	//===============================================
    // Free properties management object and
	// contained interfaces
	//===============================================
    SAFE_DELETE_PTR( m_pUtilProp );
    SAFE_DELETE_PTR( m_pIDBInitialize );
    SAFE_DELETE_PTR( m_pIDBProperties );
    SAFE_DELETE_PTR( m_pIDBInfo );
	SAFE_DELETE_PTR( m_pIDBCreateSession );
	SAFE_DELETE_PTR( m_pIPersistFile );
	SAFE_DELETE_PTR( m_pWbemWrap );
	SAFE_DELETE_PTR( m_pISupportErrorInfo );
	SAFE_DELETE_PTR(m_pIDBDataSourceAdmin);
	SAFE_DELETE_PTR(m_pIObjectAccessControl);
	SAFE_DELETE_PTR(m_pISecurityInfo);

	SysFreeString(m_strPersistFileName);

	//===============================================
    // Decrement global object count.
	//===============================================
    InterlockedDecrement(&g_cObj);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Initialize the command Object
//
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataSource::FInit( void  )
{
	HRESULT	hr		= S_OK;
	BOOL	bRet	= TRUE;
	//================================================
	// Instantiate the data conversion service object
	//================================================
	if( !g_pIDataConvert ){

		hr = CoCreateInstance(CLSID_OLEDB_CONVERSIONLIBRARY, NULL, CLSCTX_INPROC_SERVER, IID_IDataConvert, (void **)&g_pIDataConvert);
	}
	else
	{
		//============================================
		// Already instantiated, increment reference 
		// count
		//============================================
		g_pIDataConvert->AddRef();
	}

	if(SUCCEEDED(hr))
	{
		IDCInfo *pDcInfo = NULL;
		DCINFO dcInfo[1];

		dcInfo[0].eInfoType = DCINFOTYPE_VERSION;
		V_VT(&dcInfo[0].vData) = VT_UI4;
		V_UI4(&dcInfo[0].vData) = 0x200;

		hr = g_pIDataConvert->QueryInterface(IID_IDCInfo,(void **)&pDcInfo);
		hr = pDcInfo->SetInfo(1,dcInfo);

		hr = E_OUTOFMEMORY;

		m_pWbemWrap = new CWbemConnectionWrapper();
		
		if(m_pWbemWrap == NULL)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		if(SUCCEEDED(hr = m_pWbemWrap->FInit()))
		{
			//================================================
			// Allocate properties management object
			//================================================
			m_pUtilProp = new CUtilProp;

			// NTRaid: 136443
			// 07/05/00
			if(m_pUtilProp == NULL)
			{
				hr = E_OUTOFMEMORY;
			}
			else
			if(SUCCEEDED(hr = m_pUtilProp->FInit(DATASOURCEPROP)))
			{

				//================================================
				//  Allocate contained interface objects
				//================================================
				m_pIDBInitialize		= new CImpIDBInitialize( this );
				m_pIDBProperties		= new CImpIDBProperties( this );
				m_pIDBInfo				= new CImpIDBInfo( this );
				m_pIDBCreateSession		= new CImpIDBCreateSession( this );
				m_pIPersistFile			= new CImpIPersistFile( this );
				m_pISupportErrorInfo	= new CImpISupportErrorInfo(this);
				m_pIDBDataSourceAdmin	= new CImpIDBDataSrcAdmin(this);
				m_pIObjectAccessControl = new CImpIObjectAccessControl(this);
				m_pISecurityInfo		= new CImpISecurityInfo(this);

				if(m_pUtilProp && m_pIDBInitialize &&   m_pIDBInfo &&  m_pIDBProperties  && 
					m_pIDBCreateSession && m_pIPersistFile && m_pISupportErrorInfo && 
					m_pIDBDataSourceAdmin && m_pIObjectAccessControl && m_pISecurityInfo)
				{
					hr = S_OK;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}
		}
	}
	
	if(SUCCEEDED(hr))
	{
		hr = AddInterfacesForISupportErrorInfo();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to add interfaces to ISupportErrorInfo interface
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataSource::AddInterfacesForISupportErrorInfo()
{
	HRESULT hr = S_OK;

	if(SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IDBInitialize))			&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IDBInfo))				&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IDBProperties))			&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IPersist))				&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IDBDataSourceAdmin))	&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IObjectAccessControl))	&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_ISecurityInfo)))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IPersistFile);
	}

	if(SUCCEEDED(hr) && m_fDSOInitialized)
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IDBCreateSession);
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to a specified interface. 
// Callers use QueryInterface to determine which interfaces the called object supports.
//s
// HRESULT indicating the status of the method
//      S_OK          | Interface is supported and ppvObject is set.
//      E_NOINTERFACE | Interface is not supported by the object
//      E_INVALIDARG  | One or more arguments are invalid.
//
////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDataSource::QueryInterface(  REFIID riid,    //@parm IN | Interface ID of the interface being queried for.
										   LPVOID * ppv    //@parm OUT | Pointer to interface that was instantiated
										)
{
	HRESULT hr = E_INVALIDARG;
	//=================================================
    // Is the pointer bad?
	//=================================================
    if (ppv != NULL){

		//=================================================
		//  Place NULL in *ppv in case of failure and init
		//  stuff
		//=================================================
		*ppv = NULL;
		hr = S_OK;

		//=================================================
		// This is the non-delegating IUnknown 
		// implementation
		//=================================================
		if( riid == IID_IUnknown){
			*ppv = (LPVOID) this;
		}
		else if( riid == IID_IDBInitialize ){
			*ppv = (LPVOID) m_pIDBInitialize;
		}
		else if( riid == IID_IDBInfo && m_fDSOInitialized){
			*ppv = (LPVOID) m_pIDBInfo;
		}
		else if( riid == IID_IDBProperties ){
			*ppv = (LPVOID) m_pIDBProperties;
		}
		else if( riid == IID_IPersist || riid == IID_IPersistFile){
			*ppv = (LPVOID) m_pIPersistFile;
		}
		else if( riid == IID_IDBCreateSession && m_fDSOInitialized ){
			*ppv = (LPVOID)m_pIDBCreateSession;
		}
		else if(riid == IID_ISupportErrorInfo)
		{
			*ppv = (LPVOID)m_pISupportErrorInfo;
		}
		else if(riid == IID_IDBDataSourceAdmin)
		{
			*ppv = (LPVOID)m_pIDBDataSourceAdmin;
		}
		else if(riid == IID_IObjectAccessControl)
		{
			*ppv = (LPVOID)m_pIObjectAccessControl;
		}
		else if(riid == IID_ISecurityInfo)
		{
			*ppv = (LPVOID)m_pISecurityInfo;
		}
		
		//======================================
		// Special case for uninitialized.
		//======================================
		else if( *ppv && !m_fDSOInitialized ){
			*ppv = NULL;			
			hr = E_UNEXPECTED;
		}
		else{
			//==================================
			//  We don't support this interface
			//==================================
			hr = E_NOINTERFACE;
		}

		//==============================================
		//  If we're going to return an interface, 
		//  AddRef it first
		//==============================================
		if( S_OK == hr){
			if (*ppv){
				((LPUNKNOWN) *ppv)->AddRef();
			}
		}

	}
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
//
// Increments a persistence count for the object
//
////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CDataSource::AddRef( void )
{
    return InterlockedIncrement((long*)&m_cRef);
}


////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrements a persistence count for the object and if persistence count is 0, the object
// destroys itself.
//
////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CDataSource::Release( void  )
{
    InterlockedDecrement((long*)&m_cRef);
    if (!m_cRef){
        delete this;
        return 0;
    }
    return m_cRef;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//	Get value of a property of datasource
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataSource::GetDataSrcProperty(DBPROPID propId , VARIANT & varValue)
{
	DBPROPIDSET	rgPropertyIDSets[1];
	ULONG		cPropertySets	= 0;
	DBPROPSET*	prgPropertySets = NULL;
	DBPROPID	rgPropId[1];
	HRESULT		hr				= S_OK;


	VariantClear(&varValue);

    //========================================================================
    // Get the value of the required property
    //========================================================================
	rgPropertyIDSets[0].guidPropertySet	= DBPROPSET_DBINIT;
	rgPropertyIDSets[0].rgPropertyIDs	= rgPropId;
	rgPropertyIDSets[0].cPropertyIDs	= 1;
	rgPropId[0]							= propId;

    if( S_OK == (hr = m_pUtilProp->GetProperties( PROPSET_DSOINIT,	1, rgPropertyIDSets,&cPropertySets,	&prgPropertySets )))
		VariantCopy(&varValue,&prgPropertySets->rgProperties->vValue);

    //==========================================================================
	//  Free memory we allocated to by GetProperties
    //==========================================================================
	m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropertySets, prgPropertySets);

	return hr;

}

//////////////////////////////////////////////////////////////////////////////////////////////
// Function to adjust the privelige tokens  as set in the properties
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDataSource::AdjustPreviligeTokens()
{
	DBPROPIDSET	rgPropertyIDSets[1];
	ULONG		cPropertySets;
	DBPROPSET*	prgPropertySets;
	HRESULT		hr = S_OK;

	rgPropertyIDSets[0].guidPropertySet		= DBPROPSET_WMIOLEDB_DBINIT;
	rgPropertyIDSets[0].rgPropertyIDs		= NULL;
	rgPropertyIDSets[0].cPropertyIDs		= 0;
	
	if(SUCCEEDED(hr = m_pUtilProp->GetProperties(PROPSET_DSO,1,rgPropertyIDSets,&cPropertySets,&prgPropertySets)))
	{
		if(!(m_pWbemWrap->AdjustTokenPrivileges(prgPropertySets->cProperties  ,prgPropertySets->rgProperties)))
		{
			hr = E_FAIL;
		}
    	//==========================================================================
        //  Free memory we allocated to get the namespace property above
    	//==========================================================================
        m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropertySets, prgPropertySets);
	}

	return hr;

}


HRESULT CDataSource::InitializeConnectionProperties()
{
	HRESULT		hr = S_OK;
	DBPROPIDSET	rgPropertyIDSets[1];
	ULONG		cPropertySets;
	DBPROPSET*	prgPropertySets;
	DBPROPID	rgPropId[7];
	DWORD		dwAuthnLevel;
	DWORD		dwImpLevel; 

	rgPropId[0]								= DBPROP_INIT_DATASOURCE;
	rgPropId[1]								= DBPROP_INIT_PROTECTION_LEVEL;
	rgPropId[2]								= DBPROP_INIT_IMPERSONATION_LEVEL;
	rgPropId[3]								= DBPROP_AUTH_USERID;
	rgPropId[4]								= DBPROP_AUTH_PASSWORD;
	rgPropId[5]								= DBPROP_INIT_LCID;
	rgPropId[6]								= DBPROP_WMIOLEDB_AUTHORITY;

	rgPropertyIDSets[0].guidPropertySet		= DBPROPSET_DBINIT;
	rgPropertyIDSets[0].rgPropertyIDs		= rgPropId;
	rgPropertyIDSets[0].cPropertyIDs		= 7;

	//==============================================================================
	// Get the value of the DBPROP_INIT_DATASOURCE property, this is the namespace
    // to be opened.
	//==============================================================================
	hr = m_pUtilProp->GetProperties( PROPSET_DSO,1, rgPropertyIDSets,&cPropertySets,&prgPropertySets );
    if( SUCCEEDED(hr) )
	{

    	//==========================================================================
        //  now, set the namespace, if this isn't a valid namespace, then it reverts
        //  to the default
    	//==========================================================================
        m_pWbemWrap->SetValidNamespace(&(prgPropertySets[0].rgProperties[0].vValue));

		m_pWbemWrap->SetUserInfo(prgPropertySets[0].rgProperties[3].vValue.bstrVal,
											prgPropertySets[0].rgProperties[4].vValue.bstrVal,
											prgPropertySets[0].rgProperties[6].vValue.bstrVal);

		// convert the OLEDB prop value to the actual value
		dwAuthnLevel = GetAuthnLevel(prgPropertySets[0].rgProperties[1].vValue.lVal);
		dwImpLevel	 = GetImpLevel(prgPropertySets[0].rgProperties[2].vValue.lVal);
		m_pWbemWrap->SetLocale(prgPropertySets[0].rgProperties[5].vValue.lVal);

		m_pWbemWrap->SetConnAttributes(dwAuthnLevel,dwImpLevel);

		//==========================================================================
        //  Free memory we allocated to get the namespace property above
    	//==========================================================================
        m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropertySets, prgPropertySets);
	}

	return hr;
}


HRESULT CDataSource::CreateSession(IUnknown*   pUnkOuter,  //IN  Controlling IUnknown if being aggregated 
									REFIID      riid,       //IN  The ID of the interface 
									IUnknown**  ppDBSession)
{
    CDBSession* pDBSession = NULL;
    HRESULT hr = S_OK;

	try
	{
		//=========================================================
		// open a DBSession object
		//=========================================================
		pDBSession = new CDBSession( pUnkOuter );
	}
	catch(...)
	{
		SAFE_DELETE_PTR(pDBSession);
		throw;
	}

	if (!pDBSession){
		hr = E_OUTOFMEMORY;
	}
	else
	{

		//=====================================================
		// initialize the object
		//=====================================================
		if (FAILED(hr = pDBSession->FInit(this)))
		{
			SAFE_DELETE_PTR( pDBSession );
		}
		else
		{
			//=================================================
			// get requested interface pointer on DBSession
			//=================================================
			hr = pDBSession->QueryInterface( riid, (void **) ppDBSession );
			if (FAILED( hr ))
			{
				SAFE_DELETE_PTR( pDBSession );
			}
			else
			{
				//=============================================
				// all went well
				//=============================================
				m_fDBSessionCreated = TRUE;
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\dbinit.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999  Microsoft Corporation. All Rights Reserved.
//
// IDBInitialize interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Initializes the DataSource object.. 
//
// HRESULT
//      S_OK						Namespace opened
//      E_FAIL						Invalid namespace
//      E_INVALIDARG				Invalid Parameters passed in
//		DB_E_ALREADYINITIALIZED		Datasource Object already initialized
//
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBInitialize::Initialize(	)
{
	HRESULT		hr = S_OK;
/*	DBPROPIDSET	rgPropertyIDSets[1];
	ULONG		cPropertySets;
	DBPROPSET*	prgPropertySets;
	DBPROPID	rgPropId[6];
	DWORD		dwAuthnLevel;
	DWORD		dwImpLevel; 
*/    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;


    assert( m_pObj );

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

    if (m_pObj->m_fDSOInitialized){
        hr = DB_E_ALREADYINITIALIZED;
	}
	else{

		if(SUCCEEDED(hr = m_pObj->InitializeConnectionProperties()))
		{
    		//==========================================================================
            //  Make the wbem connection
    		//==========================================================================
            hr = m_pObj->m_pWbemWrap->GetConnectionToWbem();
            if( SUCCEEDED(hr)){
   				m_pObj->m_fDSOInitialized = TRUE;
				
				hr = m_pObj->AdjustPreviligeTokens();
            }

    		//==========================================================================
            //  Free memory we allocated to get the namespace property above
    		//==========================================================================
//            m_pObj->m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropertySets, prgPropertySets);

			m_pObj->m_bIsPersitFileDirty = TRUE;
		
		}	// if(InitializeConnectionProperties())
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBInitialize);

	CATCH_BLOCK_HRESULT(hr,L"IDBInitialize::Initialize");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the Data Source Object to an uninitialized state
//
// HRESULT
//      S_OK             The method succeeded
//      DB_E_OBJECTOPEN  A DBSession object was already created
//
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBInitialize::Uninitialize( void )
{
    assert( m_pObj );
	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//============================
	// Serialize the object
	//============================
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	//===================================================================================
    // if data source object is not initialized; do nothing, otherwise
	//===================================================================================
    if(m_pObj->m_fDSOInitialized){

        if (!m_pObj->m_fDBSessionCreated){

			//===========================================================================
            // DSO initialized, but no DBSession has been created.
            // So, reset DSO to uninitialized state
			//===========================================================================
            m_pObj->m_fDSOInitialized = FALSE;
        }
        else{
			//===========================================================================
            // DBSession has already been created; trying to uninit
            // the DSO now is an error
			//===========================================================================
            hr = DB_E_OBJECTOPEN;
        }
	}
	m_pObj->m_bIsPersitFileDirty = TRUE;


	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBInitialize);

	CATCH_BLOCK_HRESULT(hr,L"IDBInitialize::Uninitialize");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\dbprop.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// IDBProperties and IDBInfo interface implementations
//
//////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"

WCHAR g_szKeyWords[] =	L"CLUSTERED,COMMITTED,COMPUTE,CONFIRM,CONTROLROW,DATABASE,DENY,DISK,DISTRIBUTED,DUMMY,DUMP," 
						L"ERRLVL,ERROREXIT,EXIT,FILLFACTOR,FLOPPY,HOLDLOCK,IDENTITY_INSERT,IDENTITYCOL,IF,INDEX,KILL,"  
						L"LINENO,LOAD,LOG,NOCHECK,NONCLUSTERED,OFF,OFFSETS,ONCE,OVER,PERCENT,PERM,PERMANENT,PIPE,PLAN," 
						L"PRINT,PROC,PROCESSEXIT,QUALIFIER,RECONFIGURE,REPEATABLE,REPLICATION,RETURN,ROWCOUNT,RULE,SAVE," 
						L"SETUSER,SHUTDOWN,STATISTICS,TAPE,TEMP,TEXTSIZE,TOP,TRAN,TRUNCATE,TSEQUAL,UNCOMMITTED," 
						L"UPDATETEXT,WHILE";


#define KEYWORD_MAXSIZE					1024
#define NUMBER_OF_SUPPORTED_LITERALS	7

DBLITERAL g_SupportedLiterals[] = {	DBLITERAL_CATALOG_NAME,
									DBLITERAL_CHAR_LITERAL,
									DBLITERAL_COLUMN_NAME,
									DBLITERAL_SCHEMA_NAME,
									DBLITERAL_SCHEMA_SEPARATOR,
									DBLITERAL_TABLE_NAME,
									DBLITERAL_TEXT_COMMAND};
DBLITERALINFO g_SupportedInfo[] =	{ 
										{	L"",
											L"!\"%&()*+-,/;:<=>?@[\\]^{|}~" , 
											L"0123456789!\"%%&()*+-,/;:<=>?@[\\]^{|}~_ ",
											DBLITERAL_CATALOG_NAME,
											TRUE,
											~0
										} ,

										{	L"",
											L"" , 
											L"",
											DBLITERAL_CHAR_LITERAL,
											TRUE,
											0
										} ,
										{	L"",
											L"!\"%&()*+-,/;:<=>?@[\\]^{|}~" , 
											L"0123456789!\"%%&()*+-,/;:<=>?@[\\]^{|}~_ ",
											DBLITERAL_COLUMN_NAME,
											TRUE,
											~0
										} ,
										{	L"",
											L"!\"%&()*+-,/;:<=>?@[\\]^{|}~" , 
											L"0123456789!\"%%&()*+-,/;:<=>?@[\\]^{|}~_ ",
											DBLITERAL_SCHEMA_NAME,
											TRUE,
											~0
										} ,
										{	L".",
											L"", 
											L"",
											DBLITERAL_SCHEMA_SEPARATOR,
											TRUE,
											1
										} ,
										{	L"",
											L"!\"%&()*+-,/;:<=>?@[\\]^{|}~" , 
											L"0123456789!\"%%&()*+-,/;:<=>?@[\\]^{|}~_ ",
											DBLITERAL_TABLE_NAME,
											TRUE,
											~0
										} ,
										{	L"",
											L"", 
											L"",
											DBLITERAL_TEXT_COMMAND,
											TRUE,
											0
										} 
									};
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  IDBInfo specific interface methods
//
//  Returns information about keywords used in text commands
//
//  HRESULT
//		S_OK			Keywords successfully returned, NULL because no keywords
//      E_INVALIDARG	ppwszKeywords was NULL
//      E_UNEXPECTED	Can not be called unless initialized
//
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP    CImpIDBInfo::GetKeywords(  LPWSTR*		ppwszKeywords   )
{
	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;
	WCHAR wcsKeyWords[KEYWORD_MAXSIZE];
	wcscpy(wcsKeyWords,L"");

	TRY_BLOCK;

	WMIOledb_LoadStringW(IDS_DBKEYWORDS,wcsKeyWords,KEYWORD_MAXSIZE * sizeof(WCHAR));
	//=========================
	// Serialize the object
	//=========================
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();
	
	//=================================================================
	// Initialize 
	//=================================================================
    if (ppwszKeywords){
		*ppwszKeywords	= NULL;
	}

   	//=================================================================
	// check params
	//=================================================================
    if (NULL == ppwszKeywords){
		hr = E_INVALIDARG;
	}

	//=================================================================
	// check if we are initialized
	//=================================================================
	else if (!m_pObj->m_fDSOInitialized){
		hr = E_UNEXPECTED;
	}
	else
	{
		try
		{
			*ppwszKeywords = (LPWSTR)g_pIMalloc->Alloc((wcslen(wcsKeyWords) + 1) * sizeof(WCHAR));
		}
		catch(...)
		{
			if(*ppwszKeywords)
			{
				g_pIMalloc->Free(*ppwszKeywords);
			}
			throw;
		}
		
		if(*ppwszKeywords)
		{
			wcscpy(*ppwszKeywords, wcsKeyWords);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBInfo);

	CATCH_BLOCK_HRESULT(hr,L"IDBInfo::GetKeywords");
    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns information about literals used in text command
//
// HRESULT
//		S_OK				cLiterals was 0
//      E_INVALIDARG		cLiterals not equal to 0 and rgLiterals was NULL or pcLiteralInfo, 
//							prgLiteralInfo, or ppCharBuffer was NULL
//      E_UNEXPECTED		Can not be called unless initialized
//		DB_E_ERRORSOCCURRED None of the requested literals are supported
//
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP    CImpIDBInfo::GetLiteralInfo (
	    ULONG           cLiterals,      // IN   Number of literals being asked about
		const DBLITERAL rgLiterals[],   // IN   Array of literals about which to return information
		ULONG*          pcLiteralInfo,  // OUT  Number of literals for which info is returned
		DBLITERALINFO** prgLiteralInfo, // OUT  Array of info structures
		WCHAR**         ppCharBuffer    // OUT  Buffer for characters
    )
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//==================================================================
	// Initialize 
	//==================================================================
	if( pcLiteralInfo ){
		*pcLiteralInfo = 0;
	}
	if( prgLiteralInfo ){
		*prgLiteralInfo = NULL;
	}
	if( ppCharBuffer ){
		*ppCharBuffer = NULL;
	}

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	//==================================================================
    // check params
	//==================================================================
    if ((cLiterals != 0) && (rgLiterals == NULL))
	{
        hr = E_INVALIDARG;
	}
	else if (!pcLiteralInfo || !prgLiteralInfo || !ppCharBuffer)
	{
        hr = E_INVALIDARG;
	}
	else if (!m_pObj->m_fDSOInitialized)
	{
		//==============================================================
		// check if we are initialized
		//==============================================================
		hr = E_UNEXPECTED;
	}
	else
	{

		ULONG cLiteralsToFetch = cLiterals == 0 ? NUMBER_OF_SUPPORTED_LITERALS : cLiterals;

		//==========================================================
		// Allocate memory for return information
		// - DBLITERALINFO array
		//==========================================================
		try
		{
			*prgLiteralInfo = (DBLITERALINFO*)g_pIMalloc->Alloc(cLiteralsToFetch * sizeof(DBLITERALINFO));
			*ppCharBuffer = (WCHAR *)g_pIMalloc->Alloc(GetStringBufferSize(cLiterals,rgLiterals));
		}
		catch(...)
		{
			if(*prgLiteralInfo)
			{
				g_pIMalloc->Free(*prgLiteralInfo);
				*prgLiteralInfo = NULL;
			}
			if(*ppCharBuffer)
			{
				g_pIMalloc->Free(*ppCharBuffer);
				*ppCharBuffer = NULL;
			}
			throw;
		}
		if (!(*prgLiteralInfo) || !(*ppCharBuffer))
		{

			if(*prgLiteralInfo)
			{
				g_pIMalloc->Free(*prgLiteralInfo);
				*prgLiteralInfo = NULL;
			}
			if(*ppCharBuffer)
			{
				g_pIMalloc->Free(*ppCharBuffer);
				*ppCharBuffer = NULL;
			}
			hr= E_OUTOFMEMORY;
		}
		else
		{
			LONG lLiteralIndex = 0;
			WCHAR *pTemp = *ppCharBuffer;

			memset(*prgLiteralInfo , 0 , sizeof(DBLITERALINFO) * cLiteralsToFetch);
			memset(*ppCharBuffer , 0 , GetStringBufferSize(cLiterals,rgLiterals));

			for(ULONG lIndex = 0; lIndex <  cLiteralsToFetch ; lIndex++)
			{
				lLiteralIndex = -1;
				lLiteralIndex = cLiterals == 0 ? lIndex : GetLiteralIndex(rgLiterals[lIndex]);

				if(lLiteralIndex >= 0)
				{
					if(g_SupportedInfo[lLiteralIndex].pwszLiteralValue != NULL)
					{
						// copy the litervalue
						wcscpy(pTemp,g_SupportedInfo[lLiteralIndex].pwszLiteralValue);
						(*prgLiteralInfo)[lIndex].pwszLiteralValue = pTemp;
						(*prgLiteralInfo)[lIndex].cchMaxLen = wcslen(pTemp);
						pTemp += (wcslen(pTemp) + 1);
					}
					else
					{
						(*prgLiteralInfo)[lIndex].pwszLiteralValue = NULL;
					}

					if(g_SupportedInfo[lLiteralIndex].pwszInvalidChars != NULL)
					{
						// copy the litervalue
						wcscpy(pTemp,g_SupportedInfo[lLiteralIndex].pwszInvalidChars);
						(*prgLiteralInfo)[lIndex].pwszInvalidChars = pTemp;
						if(wcslen(pTemp) > (*prgLiteralInfo)[lIndex].cchMaxLen)
						{
							(*prgLiteralInfo)[lIndex].cchMaxLen = wcslen(pTemp);
						}

						pTemp += (wcslen(pTemp) + 1);
					}
					else
					{
						(*prgLiteralInfo)[lIndex].pwszInvalidChars = NULL;
					}

					if(g_SupportedInfo[lLiteralIndex].pwszInvalidStartingChars != NULL)
					{
						// copy the litervalue
						wcscpy(pTemp,g_SupportedInfo[lLiteralIndex].pwszInvalidStartingChars);
						(*prgLiteralInfo)[lIndex].pwszInvalidStartingChars = pTemp;
						if(wcslen(pTemp) > (*prgLiteralInfo)[lIndex].cchMaxLen)
						{
							(*prgLiteralInfo)[lIndex].cchMaxLen = wcslen(pTemp);
						}
						pTemp += (wcslen(pTemp) + 1);
					}
					else
					{
						(*prgLiteralInfo)[lIndex].pwszInvalidStartingChars = NULL;
					}

				   (*prgLiteralInfo)[lIndex].lt = g_SupportedInfo[lLiteralIndex].lt;
				   (*prgLiteralInfo)[lIndex].fSupported = TRUE;

				} // if valid literal index
			
			} // for loop
		
		}	// after succesfull memory allocation
	
		if(SUCCEEDED(hr))
		{
			*pcLiteralInfo = cLiteralsToFetch;
		}

	}	// initial parameter checking


	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBInfo);

	CATCH_BLOCK_HRESULT(hr,L"IDBInfo::GetLiteralInfo");
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////
// Get index of the given literal in the global array
///////////////////////////////////////////////////////////////////////////////////
LONG CImpIDBInfo::GetLiteralIndex(DBLITERAL rgLiterals)
{
	LONG lRet = -1;
	for( int i = 0 ; i < NUMBER_OF_SUPPORTED_LITERALS ; i++)
	{
		if(g_SupportedLiterals[i] == rgLiterals)
		{
			lRet = i;
			break;
		}
	}

	return lRet;
}

///////////////////////////////////////////////////////////////////////////////////
// Get length of buffer to be allocated for strings
///////////////////////////////////////////////////////////////////////////////////
LONG CImpIDBInfo::GetStringBufferSize(ULONG           cLiterals,      // IN   Number of literals being asked about
									 const DBLITERAL rgLiterals[])
{
	LONG lBuffSize = 0;

	LONG lLiteralIndex = 0;
	LONG cLiteralsToFetch = cLiterals == 0 ? NUMBER_OF_SUPPORTED_LITERALS : cLiterals;

	for(LONG lIndex =0 ; lIndex <  cLiteralsToFetch ; lIndex++)
	{
		lLiteralIndex = -1;
		lLiteralIndex = cLiterals == 0 ? lIndex : GetLiteralIndex(rgLiterals[lIndex]);

		if(lLiteralIndex >= 0)
		{
			lBuffSize += wcslen(g_SupportedInfo[lLiteralIndex].pwszLiteralValue) + 1;
			lBuffSize += wcslen(g_SupportedInfo[lLiteralIndex].pwszInvalidChars) + 1;
			lBuffSize += wcslen(g_SupportedInfo[lLiteralIndex].pwszInvalidStartingChars) + 1;
		}
	}
	lBuffSize *= sizeof(WCHAR);
	return lBuffSize;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Returns information about rowset and data source properties supported by the provider
//
//  HRESULT
//       S_OK           The method succeeded
//       E_INVALIDARG   pcPropertyInfo or prgPropertyInfo was NULL
//       E_OUTOFMEMORY  Out of memory
//
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP    CImpIDBProperties::GetPropertyInfo (
	    ULONG				cPropertySets,		// IN   Number of properties being asked about
	    const DBPROPIDSET	rgPropertySets[],	// IN   Array of cPropertySets properties about which to return information
	    ULONG*				pcPropertyInfoSets,	// OUT  Number of properties for which information is being returned
	    DBPROPINFOSET**		prgPropertyInfoSets,// OUT  Buffer containing default values returned
		WCHAR**				ppDescBuffer		// OUT  Buffer containing property descriptions
    )
{
    assert( m_pObj );
    assert( m_pObj->m_pUtilProp );

	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	//=====================================================================================
    // just pass this call on to the utility object that manages our properties
	//=====================================================================================
    hr = m_pObj->m_pUtilProp->GetPropertyInfo(
									m_pObj->m_fDSOInitialized,
									cPropertySets, 
									rgPropertySets,
									pcPropertyInfoSets, 
									prgPropertyInfoSets,
									ppDescBuffer);


	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBProperties);

	CATCH_BLOCK_HRESULT(hr,L"IDBProperties::GetPropertyInfo");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Returns current settings of all properties in the FLAGS_DATASRCINF property group
//
//  HRESULT
//       S_OK           The method succeeded
//       E_INVALIDARG   pcProperties or prgPropertyInfo was NULL
//       E_OUTOFMEMORY  Out of memory
//
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBProperties::GetProperties (
						ULONG				cPropertySets,		// IN   count of restiction guids
						const DBPROPIDSET	rgPropertySets[],	// IN   restriction guids
						ULONG*              pcProperties,		// OUT  count of properties returned
						DBPROPSET**			prgProperties		// OUT  property information returned
    )
{
	DWORD dwBitMask = PROPSET_DSO;

    assert( m_pObj );
    assert( m_pObj->m_pUtilProp );
	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	//=================================================================================
	// set BitMask
	//=================================================================================
	if ( m_pObj->m_fDSOInitialized ){
		dwBitMask |= PROPSET_INIT;
	}

	//=================================================================================
	// Check Arguments
	//=================================================================================
	hr = m_pObj->m_pUtilProp->GetPropertiesArgChk(dwBitMask, cPropertySets, rgPropertySets, pcProperties, prgProperties,m_pObj->m_fDSOInitialized);
	if ( !FAILED(hr) ){

		//=============================================================================
		// Just pass this call on to the utility object that manages our properties
		//=============================================================================
		hr = m_pObj->m_pUtilProp->GetProperties(dwBitMask,cPropertySets, rgPropertySets,pcProperties, prgProperties );
	}
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBProperties);

	CATCH_BLOCK_HRESULT(hr,L"IDBProperties::GetProperties");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Set properties in the FLAGS_DATASRCINF property group
//
//  HRESULT
//       S_OK          | The method succeeded
//       E_INVALIDARG  | cProperties was not equal to 0 and rgProperties was NULL
//
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP    CImpIDBProperties::SetProperties (  ULONG		cProperties,DBPROPSET	rgProperties[]	)
{
    HRESULT hr			= E_FAIL;
	DWORD	dwBitMask   = PROPSET_DSO;

	assert( m_pObj );
    assert( m_pObj->m_pUtilProp );

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	//===================================================================================
	// Quick return if the Count of Properties is 0
	//===================================================================================
	if( cProperties == 0 ){
		hr = S_OK ;
	}

	//===================================================================================
	// Check Arguments for use by properties
	//===================================================================================
	hr = m_pObj->m_pUtilProp->SetPropertiesArgChk(cProperties, rgProperties,m_pObj->m_fDSOInitialized);
	if( !FAILED(hr) ){

		//===================================================================================
		// set BitMask
		//===================================================================================
		if ( m_pObj->m_fDSOInitialized )
			dwBitMask |= PROPSET_INIT;

		//===================================================================================
		// just pass this call on to the utility object that manages our properties
		//===================================================================================
		hr = m_pObj->m_pUtilProp->SetProperties(dwBitMask,cProperties, rgProperties);
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBProperties);

	CATCH_BLOCK_HRESULT(hr,L"IDBProperties::SetProperties");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\datasrc.h ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider 
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CDataSource base object and contained interface definitions
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _DATASRC_H_
#define _DATASRC_H_

#include "headers.h"
#include "errinf.h"

///////////////////////////////////////////////////////////////////////////////////
// Forward declarations 
///////////////////////////////////////////////////////////////////////////////////

class   CImpIDBInitialize;
class   CImpIDBProperties;
class	CImpIDBInfo;
class   CImpIDBCreateSession;
class   CImpIPersistFile;
class	CDataSource;
class	CImpIDBDataSrcAdmin;
class	CImpIObjectAccessControl;
class	CImpISecurityInfo;

typedef CImpIDBInitialize*			PIMPIDBINITIALIZE;
typedef CImpIDBProperties*			PIMPIDBProperties;
typedef CImpIDBInfo*				PIMPIDBINFO;
typedef CImpIDBCreateSession*		PIMPIDBCREATESESSION;
typedef CImpIPersistFile*			PIMPIPERSISTFILE;
typedef CDataSource*				PCDATASOURCE;
typedef CImpIDBDataSrcAdmin*		PIDBDATASRCADMIN;
typedef CImpIObjectAccessControl*	PIOBJACCESSCTRL;
typedef CImpISecurityInfo *			PIMPISECURITYINFO;


///////////////////////////////////////////////////////////////////////////////////
//
// CDataSource: Containing class for all interfaces on the Datasource 
// CoType Object
//
///////////////////////////////////////////////////////////////////////////////////
class CDataSource : public CBaseObj			
{
	//==========================================
	//	Contained interfaces are friends
	//==========================================
	friend class CImpIDBInitialize;
    friend class CImpIDBInfo;
	friend class CImpIDBProperties;
    friend class CImpIDBCreateSession;
    friend class CImpIPersistFile;
    friend class CDBSession;
	friend class CImpIDBDataSrcAdmin;
    friend class CImpISupportErrorInfo;
	friend class CImpIObjectAccessControl;
	friend class CImpISecurityInfo;

	protected:

        BOOL                        m_fDSOInitialized;			// TRUE if this Data Source object is an an initialized state
        BOOL                        m_fDBSessionCreated;		// TRUE if DBSession object has been created
        PCUTILPROP                  m_pUtilProp;				// Utility object to manage properties
		PIMPIDBINITIALIZE			m_pIDBInitialize;			// Contained IDBInitialize
        PIMPIDBProperties           m_pIDBProperties;			// Contained IDBProperties
		PIMPIDBINFO					m_pIDBInfo;					// Contained IDBInfo
        PIMPIDBCREATESESSION        m_pIDBCreateSession;		// contained IDBCreateSession
        PIMPIPERSISTFILE			m_pIPersistFile;			// contained IPersistFile
//        PIMPIPERSISTFILE            m_pIPersistFile;
        PIDBDATASRCADMIN			m_pIDBDataSourceAdmin;	    //contained IDBDataSourceAdmin interface
		PIOBJACCESSCTRL				m_pIObjectAccessControl;		// contained IObjectAccessControl
        PIMPISUPPORTERRORINFO       m_pISupportErrorInfo;	    //DataSource interface
		PIMPISECURITYINFO			m_pISecurityInfo;


    	CErrorData		            m_CErrorData;		        // Error data object
		BOOL						m_bIsPersitFileDirty;		// flag to indicate whether persist file is dirty or not
		BSTR						m_strPersistFileName;		// Name of the file in which datasource is persisted

		HRESULT AddInterfacesForISupportErrorInfo();
		HRESULT AdjustPreviligeTokens();
		HRESULT InitializeConnectionProperties();
		HRESULT CreateSession(IUnknown*   pUnkOuter,  //IN  Controlling IUnknown if being aggregated 
								REFIID      riid,       //IN  The ID of the interface 
								IUnknown**  ppDBSession);

	public:
		 CDataSource(LPUNKNOWN);
		~CDataSource(void);

		HRESULT					FInit(void);										//Intitialization Routine

		STDMETHODIMP			QueryInterface(REFIID, LPVOID *);// Request an Interface
		STDMETHODIMP_(ULONG)	AddRef(void);					//Increments the Reference count
		STDMETHODIMP_(ULONG)	Release(void);					//Decrements the Reference count
		inline VOID				RemoveSession(void)				//Set the DBSessionCreated flag to FALSE
								{ m_fDBSessionCreated = FALSE;};

        inline CErrorData * GetErrorDataPtr() { return &m_CErrorData; }

        //==========================================================================
        //  The wbem api
        //==========================================================================
        CWbemConnectionWrapper*               m_pWbemWrap;
		HRESULT GetDataSrcProperty(DBPROPID propId , VARIANT & varValue);
		void SetPersistDirty() { m_bIsPersitFileDirty = FALSE; }
		void ReSetPersistDirty() { m_bIsPersitFileDirty = TRUE; }
		HRESULT GetConnectionInitProperties(DBPROPSET**	pprgPropertySets)
		{
			return m_pUtilProp->GetConnectionInitProperties(pprgPropertySets);
		}

};
///////////////////////////////////////////////////////////////////////////////////
typedef CDataSource *PCDATASOURCE;

///////////////////////////////////////////////////////////////////////////////////
//
// CImpIDBInitialize: Contained IDBInitialize class
//
///////////////////////////////////////////////////////////////////////////////////
class CImpIDBInitialize : public IDBInitialize		
{
	private: 

		DEBUGCODE(ULONG m_cRef);											
		CDataSource		*m_pObj;											

	public:  
		CImpIDBInitialize( CDataSource *pObj )
		{	
			m_cRef = 0L;											
			m_pObj		= pObj;												
		}				
		
		~CImpIDBInitialize()
		{	
		}

		STDMETHODIMP_(ULONG) AddRef(void)
		{
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)
		{
		    DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef));
		    return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		//==================================================
		//	IDBInitialize members 
		//==================================================
	    STDMETHODIMP			Initialize(void);				// Initialize Method
        STDMETHODIMP            Uninitialize(void);				// Uninitialize Method
};


///////////////////////////////////////////////////////////////////////////////////
//
// CImpIDBCreateSession:  contained IDBCreateSession class
//
///////////////////////////////////////////////////////////////////////////////////
class CImpIDBCreateSession : public IDBCreateSession    
{
	private:        
		DEBUGCODE(ULONG m_cRef);											
		CDataSource		*m_pObj;											

	public:         
		CImpIDBCreateSession( CDataSource *pObj )		
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	

		~CImpIDBCreateSession()														
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
           	return m_pObj->GetOuterUnknown()->AddRef();

		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		    DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef));
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		//=================================================================
        // IDBCreateSession method
		//=================================================================
        STDMETHODIMP    CreateSession( IUnknown*, REFIID, IUnknown** );	// CreateSession method
};



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIDBProperties:  Contained IDBProperties class
//
/////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIDBProperties : public IDBProperties	
{
	private:       
		DEBUGCODE(ULONG m_cRef);											
		CDataSource		*m_pObj;											

	public:        

		CImpIDBProperties( CDataSource *pObj )			
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	

		~CImpIDBProperties()												
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		    DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef));
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		//==========================================================
		//	IDBProperties member functions
		//==========================================================
        STDMETHODIMP GetProperties										// GetProperties method
		        	(
						ULONG				cPropertySets,		
				      	const DBPROPIDSET	rgPropertySets[], 	
			        	ULONG*              pcProperties, 	
					 	DBPROPSET**			prgProperties 	    
		        	);

        STDMETHODIMP    GetPropertyInfo									// GetPropertyInfo method
                        ( 
							ULONG				cPropertySets, 
							const DBPROPIDSET	rgPropertySets[],
							ULONG*				pcPropertyInfoSets, 
							DBPROPINFOSET**		prgPropertyInfoSets,
							WCHAR**				ppDescBuffer
                        );

        
        STDMETHODIMP	SetProperties									// SetProperties method
					 	(
							ULONG				cProperties,		
						 	DBPROPSET			rgProperties[] 	    
						);
};

////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIDBInfo: Contained IDBInfo class
//
////////////////////////////////////////////////////////////////////////////////////////
class CImpIDBInfo : public IDBInfo		
{
	private:       

		DEBUGCODE(ULONG m_cRef);											
		CDataSource		*m_pObj;											
		LONG GetLiteralIndex(DBLITERAL rgLiterals);
		LONG GetStringBufferSize(ULONG cLiterals,  
								 const DBLITERAL rgLiterals[]);

	public:       
		CImpIDBInfo( CDataSource *pObj )				
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	
		~CImpIDBInfo()														
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef));
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		//========================================================
		//	IDBProperties member functions
		//========================================================
        
        STDMETHODIMP    GetKeywords										// GetKeywords method
                        (
	                        LPWSTR*			ppwsKeywords
                        );
        
        STDMETHODIMP    GetLiteralInfo									// GetLiteralInfo method
                        (
	                        ULONG           cLiterals,
							const DBLITERAL rgLiterals[ ],
							ULONG*          pcLiteralInfo,
							DBLITERALINFO** prgLiteralInfo,
							WCHAR**         ppCharBuffer
                        );
};


///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIPersist: contained IPersist class
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIPersistFile : public IPersistFile
{
	private:      
		DEBUGCODE(ULONG m_cRef);											
		CDataSource		*m_pObj;											

		HRESULT WriteToFile(LPCOLESTR strFileName);
		HRESULT ReadFromFile(LPCOLESTR pszFileName);
		void	ClearDirtyFlag();
		BOOL	IsInitialized();
		BOOL	WritePrivateProfileString(LPCOLESTR wszAppName,LPCOLESTR wszKeyName,LPCOLESTR wszValue,LPCOLESTR wszFileName);
		HRESULT GetCurrentFile(LPCOLESTR pszFileName,LPOLESTR wszFileNameFull,DWORD dwAccess);
		BOOL	GetPrivateProfileStr(LPCOLESTR wszAppName,LPCOLESTR wszKeyName,LPCOLESTR wszFileName,LPOLESTR wszValue);
		BOOL	GetPrivateProfileLong(LPCOLESTR wszAppName,LPCOLESTR wszKeyName,LPCOLESTR wszFileName, LONG &lValue);
		HRESULT GetAbsolutePath(LPCOLESTR pwszFileName,LPOLESTR wszFileNameFull);
		HRESULT SetDBInitProp(DBPROPID propId ,GUID guidPropSet,VARIANT vPropValue);

	public:       
		CImpIPersistFile( CDataSource *pObj )				
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	
		~CImpIPersistFile()														
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		    DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef));
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		//============================================================
        // IPersist method
   		//============================================================
        STDMETHODIMP    GetClassID( CLSID *pClassID );						// GetClassID method
		STDMETHODIMP	IsDirty(void);
		STDMETHODIMP	GetCurFile(LPOLESTR *ppszFileName);
		STDMETHODIMP	Load(LPCOLESTR pszFileName, DWORD dwMode);
		STDMETHODIMP	Save(LPCOLESTR pszFileName,BOOL fRemember);
		STDMETHODIMP	SaveCompleted(LPCOLESTR pszFileName);
 
};


class CImpIDBDataSrcAdmin : public IDBDataSourceAdmin 
{
	private:      
		DEBUGCODE(ULONG m_cRef);											
		CDataSource		*m_pObj;											

	public:       
		CImpIDBDataSrcAdmin( CDataSource *pObj )				
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	
		~CImpIDBDataSrcAdmin()														
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
			DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef));
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP CreateDataSource(	ULONG		cPropertySets,
										DBPROPSET	rgPropertySets[  ],
										IUnknown  *	pUnkOuter,
										REFIID		riid,
										IUnknown **	ppDBSession);

		STDMETHODIMP DestroyDataSource( void);

		STDMETHODIMP GetCreationProperties( ULONG				cPropertyIDSets,
											const DBPROPIDSET	rgPropertyIDSets[  ],
											ULONG  *			pcPropertyInfoSets,
											DBPROPINFOSET  **	prgPropertyInfoSets,
											OLECHAR  **			ppDescBuffer);

		STDMETHODIMP ModifyDataSource( ULONG cPropertySets,DBPROPSET  rgPropertySets[]);
    
};

class CImpIObjectAccessControl : public IObjectAccessControl 
{
	private:      
		DEBUGCODE(ULONG m_cRef);											
		CDataSource		*m_pObj;											
		
		STDMETHODIMP IfValidSecObject(SEC_OBJECT  *pObject);

	public:       
		CImpIObjectAccessControl( CDataSource *pObj )				
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	
		~CImpIObjectAccessControl()														
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
			DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef));
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}
        STDMETHODIMP GetObjectAccessRights( SEC_OBJECT  *pObject,
											ULONG  *pcAccessEntries,
											EXPLICIT_ACCESS_W **prgAccessEntries);
        
        STDMETHODIMP GetObjectOwner( SEC_OBJECT  *pObject,TRUSTEE_W  ** ppOwner);
        
        STDMETHODIMP IsObjectAccessAllowed(	SEC_OBJECT *pObject,
											EXPLICIT_ACCESS_W *pAccessEntry,
											BOOL  *pfResult);
        
        STDMETHODIMP SetObjectAccessRights(	SEC_OBJECT  *pObject,
											ULONG cAccessEntries,
											EXPLICIT_ACCESS_W *prgAccessEntries);
        
        STDMETHODIMP SetObjectOwner( SEC_OBJECT  *pObject,TRUSTEE_W  *pOwner);
        
};



class CImpISecurityInfo : public ISecurityInfo 
{
	private:      
		DEBUGCODE(ULONG m_cRef);											
		CDataSource		*m_pObj;											
		
		STDMETHODIMP GetCurTrustee(TRUSTEE_W ** ppTrustee);

	public:       
		CImpISecurityInfo( CDataSource *pObj )				
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	
		~CImpISecurityInfo()														
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
			DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef));
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

        STDMETHODIMP GetCurrentTrustee(TRUSTEE_W ** ppTrustee);
        
        STDMETHODIMP GetObjectTypes(ULONG  *cObjectTypes,GUID  **gObjectTypes);
        
        STDMETHODIMP GetPermissions(GUID ObjectType,ACCESS_MASK  *pPermissions);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\dbsess.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider 
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CDBSession base object and contained interface definitions
//
//////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _DBSESS_H_
#define _DBSESS_H_

//////////////////////////////////////////////////////////////////////////////////////////////////

class   CImpIGetDataSource;
class   CImpIOpenRowset;
class	CImpISessionProperties;
class	CImpITableDefinition;
class	CImplIBindRsrc;
class   CImpIDBSchemaRowset;
class	CImplIIndexDefinition;
class	CImplIAlterTable;
class	CBinder;
class	CImpITransactionLocal;
class	CBaseRowObj;
								//99/04/12
typedef CImpIGetDataSource*		PIMPIGETDATASOURCE;
typedef CImpIOpenRowset*		PIMPIOPENROWSET;
typedef CImpISessionProperties*	PIMPISESSIONPROPERTIES;
typedef CImpITableDefinition*	PIMPITABLEDEFINITION;		//99/04/1288
typedef CImplIBindRsrc*			PIMPIBINDSRC;
typedef CImplIIndexDefinition*	PIMPINDEXDEF;
typedef	CImplIAlterTable*		PIMPIALTERTABLE;
typedef CImpITransactionLocal *	PIMPITRANSACTIONLOCAL;

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Containing class for all interfaces on the DBSession Object
//
//////////////////////////////////////////////////////////////////////////////////////////////////

class CDBSession : public CBaseObj		
{
	//===============================================================
    // contained interfaces are friends
	//===============================================================
    friend class CImpIGetDataSource;
    friend class CImpIOpenRowset;
    friend class CImpIDataSource;
    friend class CImpISessionProperties;
	friend class CImpITableDefinition;					
	friend class CImplIBindRsrc;					
	friend class CImpIDBCreateCommand;
	friend class CImplIIndexDefinition;
	friend class CBinder;
	friend class CImpITransactionLocal;

	protected: 
		
        ULONG                       m_nOpenedRowset;				// number of rows & rowsets opened
        PCUTILPROP                  m_pUtilProp;					// Utility object to manage properties
        PIMPIOPENROWSET             m_pIOpenRowset;					// contained IOpenRowset
		PIMPIGETDATASOURCE			m_pIGetDataSource;				// contained IGetDataSource
		PIMPISESSIONPROPERTIES		m_pISessionProperties;			// contained ISessionProperties
		PIMPITABLEDEFINITION		m_pITableDefinition;			// contained ITableDefinition
		PIMPIBINDSRC				m_pIBindResource;				// Pointer to bindresource
        CImpIDBSchemaRowset *       m_pISchemaRowset;
        CImpIDBCreateCommand *	    m_pIDBCreateCommand;	        // Contained IDBCreateCommand
		PIMPINDEXDEF				m_pIIndexDefinition;			// Contained IIndexDefinition
		PIMPIALTERTABLE				m_pIAlterTable;					// Contained IAlterTable
		PIMPISUPPORTERRORINFO		m_pISupportErrorInfo;			// contained ISupportErrorInfo
		PIMPITRANSACTIONLOCAL		m_pITransLocal;					// contained ITransactionLocal interface

		BOOL						m_bTxnStarted;					// flag to indicate if Txn has started or not
		ISOLEVEL					m_TxnIsoLevel;
		XACTUOW						m_TxnGuid;						// unit of work identifying the transaction

		CFlexArray					m_OpenedRowsets;



        HRESULT CreateCommand(IUnknown *pUnkOuter, REFGUID guidTemp,IUnknown ** ppUnk);
		HRESULT CreateRow(IUnknown *pUnkOuter, WCHAR *pstrURL,REFGUID guidTemp,IUnknown ** ppUnk);
		HRESULT CreateRowset(IUnknown *pUnkOuter, WCHAR *pstrURL, REFGUID guidTemp,IUnknown ** ppUnk);
		BOOL	CheckIfValidDataSrc();
		HRESULT AddInterfacesForISupportErrorInfo();

		BOOL	IsTransactionActive() { return m_bTxnStarted; }
		void	SetTransactionActive(BOOL bActive) { m_bTxnStarted = bActive; }

		void	SetIsolationLevel(ISOLEVEL isoLevel) { m_TxnIsoLevel = isoLevel; }
		ISOLEVEL GetIsolationLevel()	{ return m_TxnIsoLevel; }
		HRESULT	GenerateNewUOW(GUID &guidTrans);
		XACTUOW	GetCurrentUOW() { return m_TxnGuid; }
		void	SetAllOpenRowsetToZoombieState();



	public:
		
		 CDBSession(LPUNKNOWN);
		~CDBSession(void);

		LPUNKNOWN		m_pISessionCache;							//data cache session (synchronized with this session)
		PCDATASOURCE	m_pCDataSource;					// parent data source object

		HRESULT FInit( CDataSource	*pCDataSource );	// Intitialization Routine

		inline void DecRowsetCount(void){if(this->m_nOpenedRowset) this->m_nOpenedRowset--;};	// inline to dec rowset count
		STDMETHODIMP			QueryInterface(REFIID, LPVOID *);
		STDMETHODIMP_(ULONG)	AddRef(void);
		STDMETHODIMP_(ULONG)	Release(void);

		inline void RowsetDestroyed() { m_nOpenedRowset = 0; };
		
		HRESULT GetDataSrcProperty(DBPROPID propId , VARIANT & varValue);
		void AddRowset(CBaseRowObj * pRowset);								// add rowset to list of open rowset
		void RemoveRowset(CBaseRowObj * pRowset);							// deletes the rowset from list of open rowset
		// 07/12/2000
		// NTRaid : 142348
		HRESULT ExecuteQuery(CQuery *pQuery) { return m_pCDataSource->m_pWbemWrap->ExecuteQuery(pQuery);}
};

typedef CDBSession *PCDBSESSION;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Contained IGetDataSource class
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CImpIGetDataSource : public IGetDataSource     
{
	private:        
		DEBUGCODE(ULONG m_cRef);											
		CDBSession		*m_pObj;											

	public:         
		CImpIGetDataSource( CDBSession *pObj )			
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	
		~CImpIGetDataSource()														
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

       
		STDMETHODIMP  GetDataSource( REFIID, IUnknown** );
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// contained IOpenRowset class
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CImpIOpenRowset : public IOpenRowset   
{
	private:      
		DEBUGCODE(ULONG m_cRef);											
		CDBSession		*m_pObj;											

		BOOL GetIRowProp(ULONG cPropSet, DBPROPSET[]);

	public:       
		CImpIOpenRowset( CDBSession *pObj )			
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	
		~CImpIOpenRowset()													
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

       
		STDMETHODIMP  OpenRowset( IUnknown*, DBID*, DBID*, REFIID, ULONG, DBPROPSET[], IUnknown** );
};


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Contained ISessionProperties class
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CImpISessionProperties : public ISessionProperties
{
	friend class CBinder;					

	private:        
		DEBUGCODE(ULONG m_cRef);											
		CDBSession		*m_pObj;											

		CDBSession * GetSessionPtr() { return m_pObj; }		// This function is to give the session object pointer 
															// to the binder object

	public:        
		CImpISessionProperties( CDBSession *pObj )					
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	
		~CImpISessionProperties()														
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

        STDMETHODIMP GetProperties
		        	(
						ULONG				cPropertySets,		
				      	const DBPROPIDSET	rgPropertySets[], 	
			        	ULONG*              pcProperties, 	
					 	DBPROPSET**			prgProperties 	    
		        	);


        STDMETHODIMP	SetProperties
					 	(
							ULONG				cProperties,		
						 	DBPROPSET			rgProperties[] 	    
						);
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Contained ITableDefinition class
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpITableDefinition : public ITableDefinition     
{
	private:        
		DEBUGCODE(ULONG m_cRef);											
		CDBSession		*m_pObj;											

	public:         

		CImpITableDefinition( CDBSession *pObj )			
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;
		}																	
		~CImpITableDefinition()													
		{
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

        STDMETHODIMP CreateTable( IUnknown __RPC_FAR *pUnkOuter,
								DBID __RPC_FAR *pTableID,
								DBORDINAL cColumnDescs,
								const DBCOLUMNDESC __RPC_FAR rgColumnDescs[  ],
								REFIID riid, ULONG cPropertySets,
								DBPROPSET __RPC_FAR rgPropertySets[  ],
								DBID __RPC_FAR *__RPC_FAR *ppTableID,
								IUnknown __RPC_FAR *__RPC_FAR *ppRowset);
        
        STDMETHODIMP DropTable( DBID __RPC_FAR *pTableID);
        
        STDMETHODIMP AddColumn(  DBID __RPC_FAR *pTableID,
								 DBCOLUMNDESC __RPC_FAR *pColumnDesc,
                                 DBID __RPC_FAR *__RPC_FAR *ppColumnID);
        
        STDMETHODIMP DropColumn( DBID __RPC_FAR *pTableID, DBID __RPC_FAR *pColumnID);
};



class CImplIBindRsrc : public IBindResource
{
private:
		CDBSession		*m_pObj;											
		DEBUGCODE(ULONG m_cRef);

		BOOL CheckBindURLFlags(DBBINDURLFLAG dwBindURLFlags , REFGUID rguid);	// Function to check if proper flags are
																				// are set for the require object
		// To check if URL Matches the requested type of object
		BOOL CheckIfProperURL(BSTR & strUrl,REFGUID rguid,DBBINDURLSTATUS * pdwBindStatus);

		HRESULT BindURL(IUnknown *         pUnkOuter,
					 LPCOLESTR             pwszURL,
					 DBBINDURLFLAG         dwBindURLFlags,
					 REFGUID               rguid,
					 REFIID                riid,
					 DBIMPLICITSESSION *   pImplSession,
					 DBBINDURLSTATUS *     pdwBindStatus,
					 IUnknown **           ppUnk);
		

	public: 
		CImplIBindRsrc( CDBSession *pObj )				
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImplIBindRsrc()													
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP Bind(   
						   IUnknown *            pUnkOuter,
						   LPCOLESTR             pwszURL,
						   DBBINDURLFLAG         dwBindURLFlags,
						   REFGUID               rguid,
						   REFIID                riid,
						   IAuthenticate *       pAuthenticate,
						   DBIMPLICITSESSION *   pImplSession,
						   DBBINDURLSTATUS *     pdwBindStatus,
						   IUnknown **           ppUnk);

};

class CImplIIndexDefinition : public IIndexDefinition
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
		CDBSession		*m_pObj;											

	public: 
		
		CImplIIndexDefinition( CDBSession		*pObj )			
		{																
			DEBUGCODE(m_cRef = 0L);
			m_pObj		= pObj;											
		}																
		~CImplIIndexDefinition()											
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP CreateIndex(	DBID *                    pTableID,
									DBID *                    pIndexID,
									DBORDINAL                 cIndexColumnDescs,
									const DBINDEXCOLUMNDESC   rgIndexColumnDescs[],
									ULONG                     cPropertySets,
									DBPROPSET                 rgPropertySets[],
									DBID **                   ppIndexID);

		STDMETHODIMP DropIndex( DBID * pTableID, DBID * pIndexID);

};



class CImplIAlterTable : public IAlterTable
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
		CDBSession		*m_pObj;											

	HRESULT CheckIfSupported(DBCOLUMNDESCFLAGS   ColumnDescFlags);


	public: 
		
		CImplIAlterTable( CDBSession		*pObj )			
		{																
			DEBUGCODE(m_cRef = 0L);
			m_pObj		= pObj;											
		}																
		~CImplIAlterTable()											
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP AlterColumn(DBID *              pTableID,
								DBID *              pColumnID,
								DBCOLUMNDESCFLAGS   ColumnDescFlags,
								DBCOLUMNDESC *      pColumnDesc);

		STDMETHODIMP AlterTable(DBID *      pTableID,
								DBID *      pNewTableID,
								ULONG       cPropertySets,
								DBPROPSET   rgPropertySet[]);


};


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Hashs a token and returns TRUE iff the token is a statement keywpord.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIDBCreateCommand : public IDBCreateCommand	
{
    public: 
    	CImpIDBCreateCommand(PCDBSESSION pCDBSession)
        {
		    m_pCDBSession = pCDBSession;
            DEBUGCODE(m_cRef = 0);
		}
	    ~CImpIDBCreateCommand() {}

	STDMETHODIMP_(ULONG) AddRef(void)
	{																
		DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
		return m_pCDBSession->GetOuterUnknown()->AddRef();								
	}								
	
	STDMETHODIMP_(ULONG) Release(void)
	{
		DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
	   if( lRef < 0 ){
		   ASSERT("Reference count on Object went below 0!")
	   })
	
		return m_pCDBSession->GetOuterUnknown()->Release();								
	}

	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
	{																	
		return m_pCDBSession->GetOuterUnknown()->QueryInterface(riid, ppv);					
	}

    STDMETHODIMP CreateCommand( IUnknown*	punkOuter, REFIID riid,	IUnknown **ppCommand );

    private: 
		CDBSession		*m_pCDBSession;											
		DEBUGCODE(ULONG m_cRef);											
};

typedef CImpIDBCreateCommand *PIMPIDBCREATECOMMAND;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Class declaration for implementing ITransactionLocal interface
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpITransactionLocal : public ITransactionLocal
{
    public: 
    	CImpITransactionLocal(PCDBSESSION pCDBSession)
        {
		    m_pCDBSession = pCDBSession;
            DEBUGCODE(m_cRef = 0);
		}
	    ~CImpITransactionLocal() {}

	STDMETHODIMP_(ULONG) AddRef(void)
	{																
		DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
		return m_pCDBSession->GetOuterUnknown()->AddRef();								
	}								
	
	STDMETHODIMP_(ULONG) Release(void)
	{
		DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
	   if( lRef < 0 ){
		   ASSERT("Reference count on Object went below 0!")
	   })
	
		return m_pCDBSession->GetOuterUnknown()->Release();								
	}

	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
	{																	
		return m_pCDBSession->GetOuterUnknown()->QueryInterface(riid, ppv);					
	}

    STDMETHODIMP Commit (BOOL fRetaining,
						DWORD grfTC,
						DWORD grfRM);
    
    STDMETHODIMP Abort (BOID  *pboidReason,
						BOOL fRetaining,
						BOOL fAsync);
    
    STDMETHODIMP GetTransactionInfo (XACTTRANSINFO  *pinfo);
    
    STDMETHODIMP GetOptionsObject (ITransactionOptions  ** ppOptions);
    
    STDMETHODIMP StartTransaction( ISOLEVEL isoLevel,
									ULONG isoFlags,
									ITransactionOptions *pOtherOptions,
									ULONG  *pulTransactionLevel);

    private: 
		CDBSession		*m_pCDBSession;											
		DEBUGCODE(ULONG m_cRef);											

		HRESULT GetFlagsForIsolation(ISOLEVEL isoLevel,LONG &lFlag);
};

typedef CImpITransactionLocal *PIMPITRANSACTIONLOCAL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\dbsess.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//
//  CDBSession object implementation
//
// NTRaid:: 139685 Transaction support removed
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor for this class
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
CDBSession::CDBSession(  LPUNKNOWN pUnkOuter )  : CBaseObj(BOT_SESSION, pUnkOuter)
{
	//==========================================================================
	// Initialize simple member vars
	//==========================================================================
	m_nOpenedRowset		= 0;
	m_bTxnStarted		= FALSE;

	//==========================================================================
	// Initially, NULL all contained interfaces
	//==========================================================================
	m_pIGetDataSource		= NULL;
	m_pIOpenRowset			= NULL;
    m_pISchemaRowset        = NULL;
	m_pIDBCreateCommand     = NULL;
	m_pISessionProperties	= NULL;
	m_pUtilProp				= NULL;
	m_pITableDefinition		= NULL;					
	m_pISessionCache		= NULL;
	m_pIBindResource		= NULL;
	m_pIIndexDefinition		= NULL;
	m_pIAlterTable			= NULL;
	m_pISupportErrorInfo	= NULL;
	m_pITransLocal			= NULL;
	//==========================================================================
	// Pointer to parent object
	//==========================================================================
	m_pCDataSource		= NULL;

	memset(&m_TxnGuid , 0 , sizeof(XACTUOW));

	//==========================================================================
	// Increment global object count.
	//==========================================================================
	InterlockedIncrement(&g_cObj);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor for this class
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
CDBSession:: ~CDBSession ( void  )
{
	//===========================================================================
    // Free properties management object
	//===========================================================================
    SAFE_DELETE_PTR( m_pUtilProp );

	//===========================================================================
    // Free contained interfaces
	//===========================================================================
    SAFE_DELETE_PTR( m_pIGetDataSource );
    SAFE_DELETE_PTR( m_pIOpenRowset );
    SAFE_DELETE_PTR( m_pISchemaRowset );
    SAFE_DELETE_PTR( m_pIDBCreateCommand );
    SAFE_DELETE_PTR( m_pISessionProperties );
    SAFE_DELETE_PTR( m_pITableDefinition );
	SAFE_DELETE_PTR(m_pIBindResource);
	SAFE_DELETE_PTR(m_pIIndexDefinition);
	SAFE_DELETE_PTR(m_pIAlterTable);
	SAFE_DELETE_PTR(m_pISupportErrorInfo);
//	SAFE_DELETE_PTR(m_pITransLocal);
	
	
	m_pCDataSource->RemoveSession();
	m_pCDataSource->GetOuterUnknown()->Release();

	//===========================================================================
    // Decrement global object count.
	//===========================================================================
    InterlockedDecrement(&g_cObj);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Initialize the command Object
//
//  Did the Initialization Succeed
//        TRUE		Initialization succeeded
//        FALSE		Initialization failed
//////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDBSession::FInit ( CDataSource  *pCDataSource   )
{
	HRESULT hr = E_OUTOFMEMORY;
	//===========================================================================
	// Establish parent object pointer
	//===========================================================================
	assert( pCDataSource );
	m_pCDataSource	= pCDataSource;
	m_pCDataSource->GetOuterUnknown()->AddRef();

	//===========================================================================
	// Allocate properties management object
	//===========================================================================
	m_pUtilProp = new CUtilProp;

	// NTRaid: 136443
	// 07/05/00
	if(m_pUtilProp == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	if(SUCCEEDED(hr = m_pUtilProp->FInit(SESSIONPROP)))
	{
		//===========================================================================
		// Allocate contained interface objects
		//===========================================================================
		m_pIGetDataSource		= new CImpIGetDataSource( this );
		m_pIOpenRowset			= new CImpIOpenRowset( this );
		m_pISchemaRowset    	= new CImpIDBSchemaRowset( this );
		m_pIDBCreateCommand    	= new CImpIDBCreateCommand( this );
		m_pISessionProperties	= new CImpISessionProperties( this );
		m_pITableDefinition		= new CImpITableDefinition( this );
		m_pIBindResource		= new CImplIBindRsrc( this );
		m_pIIndexDefinition		= new CImplIIndexDefinition( this );
		m_pIAlterTable			= new CImplIAlterTable( this );
		m_pISupportErrorInfo	= new CImpISupportErrorInfo(this);
		// Removing transaction support as per alanbos mail ( core is removing the support)
		// 06/30/2000
	//	m_pITransLocal			= new CImpITransactionLocal(this);

		if( m_pIGetDataSource && m_pIOpenRowset && m_pIDBCreateCommand && m_pISchemaRowset && m_pISessionProperties && 	
						m_pITableDefinition && m_pIBindResource && m_pIIndexDefinition && m_pIAlterTable) // && m_pITransLocal)
		{
			hr = S_OK;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	if(SUCCEEDED(hr))
	{
		hr = AddInterfacesForISupportErrorInfo();
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to add interfaces to ISupportErrorInfo interface
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDBSession::AddInterfacesForISupportErrorInfo()
{
	HRESULT hr = S_OK;

	if(	SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IGetDataSource))		&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IOpenRowset))			&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IDBSchemaRowset))		&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_ISessionProperties))	&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_ITableDefinition))		&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IBindResource))			&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IDBCreateCommand))		&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IIndexDefinition))		&&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_ITransactionLocal)))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IAlterTable);
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Returns a pointer to a specified interface. Callers use QueryInterface to determine which interfaces 
//  the called object supports.
//
//  HRESULT indicating the status of the method
//       S_OK           Interface is supported and ppvObject is set.
//       E_NOINTERFACE  Interface is not supported by the object
//       E_INVALIDARG   One or more arguments are invalid.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDBSession::QueryInterface (   REFIID riid,        // IN | Interface ID of the interface being queried for.
											LPVOID * ppv    )   // OUT | Pointer to interface that was instantiated
{
	HRESULT hr = E_INVALIDARG;

	if(CheckIfValidDataSrc() == FALSE)
		return g_pCError->PostHResult(hr,&IID_IUnknown);
	
	//============================================================================
    // Is the pointer bad?
	//============================================================================
    if (ppv != NULL){

		//========================================================================
		//  Place NULL in *ppv in case of failure
		//========================================================================
		*ppv = NULL;

		//========================================================================
		//  This is the non-delegating IUnknown implementation
		//========================================================================
		if (riid == IID_IUnknown)
			*ppv = (LPVOID) this;
		else if (riid == IID_IGetDataSource)
			*ppv = (LPVOID) m_pIGetDataSource;
		else if (riid == IID_IOpenRowset)
			*ppv = (LPVOID) m_pIOpenRowset;
		else if (riid == IID_IDBSchemaRowset)
			*ppv = (LPVOID) m_pISchemaRowset;
		else if (riid == IID_ISessionProperties)
			*ppv = (LPVOID) m_pISessionProperties;
		else if (riid == IID_ITableDefinition)				
			*ppv = (LPVOID) m_pITableDefinition;
		else if (riid == IID_IBindResource)				
			*ppv = (LPVOID) m_pIBindResource;
        else if ( riid == IID_IDBCreateCommand )
    		*ppv = (LPVOID)m_pIDBCreateCommand;
		else if ( riid == IID_IIndexDefinition)
			*ppv = (LPVOID)m_pIIndexDefinition;
		else if ( riid == IID_IAlterTable)
			*ppv = (LPVOID)m_pIAlterTable;
	// Removing transaction support as per alanbos mail ( core is removing the support)
	// 06/30/2000
//		else if ( riid == IID_ITransactionLocal || riid == IID_ITransaction)
//			*ppv = (LPVOID)m_pITransLocal;
		else if ( riid == IID_ISupportErrorInfo)
			*ppv = (LPVOID)m_pISupportErrorInfo;
	
		

		//========================================================================
		//  If we're going to return an interface, AddRef it first
		//========================================================================
		if (*ppv){

			((LPUNKNOWN) *ppv)->AddRef();
			hr = S_OK;
		}
		else{
			hr = E_NOINTERFACE;
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Increments a persistence count for the object
//
//  Current reference count
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CDBSession::AddRef (  void   )
{
    return InterlockedIncrement((long *)&m_cRef);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Decrements a persistence count for the object and if persistence count is 0, the object destroys itself.
//
//  Current reference count
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CDBSession::Release (  void    )
{
     if (!InterlockedDecrement((long *)&m_cRef)){
        delete this;
        return 0;
    }
    return m_cRef;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Gets a particular datasource property
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDBSession::GetDataSrcProperty(DBPROPID propId , VARIANT & varValue)
{
    return m_pCDataSource->GetDataSrcProperty(propId,varValue);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Creates a new command called by IBindResource implementation of the session
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDBSession::CreateCommand(IUnknown *pUnkOuter, REFGUID riid,IUnknown ** ppCommand)
{
	HRESULT		hr		= S_OK;
	CCommand*	pcmd	= NULL;


	if(CheckIfValidDataSrc() == FALSE)
	{
		hr = E_INVALIDARG;
	}
	else
	{

		//=========================================================================
		// Initialize output param
		//=========================================================================
		if (ppCommand)
		{
			*ppCommand = NULL;
		}

		//=========================================================================
		// Check Function Arguments
		//=========================================================================
		if( ppCommand == NULL )
		{
			hr = E_INVALIDARG;
		}
		else
		//=========================================================================
		// The outer object must explicitly ask for IUnknown
		//=========================================================================
		if (pUnkOuter != NULL && riid != IID_IUnknown)
		{
			hr = DB_E_NOAGGREGATION;
		}
		else
		{

			try
			{
				//=========================================================================
				// This is the outer unknown from the user, for the new Command,
				// not to be confused with the outer unknown of this DBSession object.
				//=========================================================================
				pcmd = new CCommand(this, pUnkOuter);
			}
			catch(...)
			{
				SAFE_DELETE_PTR(pcmd);
				throw;
			}
			if (pcmd)
			{
		/*        //=====================================================================
				// Need to increment usage count since passed out to  CCommand
				//=====================================================================
				m_pCDBSession->AddRef();
		*/
				//=====================================================================
				// Initialize the command
				//=====================================================================
				hr = pcmd->FInit();
				if( SUCCEEDED(hr) )
				{
					hr = pcmd->QueryInterface( riid, (void **) ppCommand );
					if( SUCCEEDED(hr) )
					{
						// If everything is fine then set the datasource persist info to dirty 
						m_pCDataSource->SetPersistDirty();
					}

					//=================================================================
					// Need to drop through on error, so command object is destroyed
					//=================================================================
				}
				else
				{
					SAFE_DELETE_PTR(pcmd);
				}
			}
			else
			{
				//=====================================================================
				// Since Ctor failed, it cannot know to Release pUnkOuter, 
				// so we must do it here since we are owner.
				//=====================================================================
				if (pUnkOuter)
				{
					pUnkOuter->Release();
				}
				hr = E_OUTOFMEMORY;
			}
		
		}	// else for NOAGGREGATION

	}	// else for INVALID_ARG

	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Creates a new Row called by IBindResource implementation of the session
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDBSession::CreateRow(IUnknown *pUnkOuter, WCHAR *pstrURL,REFGUID guidTemp,IUnknown ** ppUnk)
{
	HRESULT		hr			= E_FAIL;
	CRow *		pNewRow		= NULL;
	DBPROPSET *	pPropSet	= NULL;
	BSTR		strTable;
	BSTR		strPath;
	CURLParser  urlParser;
	
	strPath = Wmioledb_SysAllocString(pstrURL);
	// Modified on 06/09/00
	// Bug while getting a row from ADO Row object
//	urlParser.SetPath(strPath);
	urlParser.SetURL(strPath);
	SysFreeString(strPath);

	if(CheckIfValidDataSrc() == FALSE)
	{
		hr = E_INVALIDARG;
	}
	else
	{

		//===================================
		// Get the path of the object
		//===================================
		if(SUCCEEDED(hr = urlParser.GetPathWithEmbededInstInfo(strPath)))
		{
			//===================================
			// Get the class name 
			//===================================
			// NTRaid:134967
			// 07/11/2000
			if(SUCCEEDED(hr) && SUCCEEDED(hr = m_pCDataSource->GetConnectionInitProperties(&pPropSet)))
			{
				hr = GetClassName(&urlParser,pPropSet,strTable,m_pCDataSource->m_pWbemWrap);

				//==========================================================================
				//  Free memory we allocated to get the namespace property above
				//==========================================================================
				CPropertyMemoryMgr::FreeDBPROPSET( 1, pPropSet);
			}

			try
			{
				pNewRow = new CRow(pUnkOuter,this);
			}
			catch(...)
			{
				SAFE_DELETE_PTR(pNewRow);
				throw;
			}

			if(SUCCEEDED(hr) && SUCCEEDED(hr = pNewRow->InitRow(strPath,strTable)))
			{
				hr = pNewRow->QueryInterface(guidTemp,(void **)ppUnk);
			}
			//=====================================================
			// Free the strings allocated by the URLParser class
			//=====================================================
			SysFreeString(strTable);
			SysFreeString(strPath);

			if(FAILED(hr))
			{
				SAFE_DELETE_PTR(pNewRow);
				*ppUnk = NULL;
			}
		}
	
	}	// INVALIDARG

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Creates a new Rowset called by IBindResource implementation of the session
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CDBSession::CreateRowset(IUnknown *pUnkOuter, WCHAR *pstrURL, REFGUID guidTemp,IUnknown ** ppUnk)
{
	HRESULT hr = E_FAIL;
	
	ULONG		cPropSets = 0;
	DBPROPSET*	prgPropertySets = NULL;
	BSTR		strTableName = NULL;
	CURLParser  urlParser;
	DBPROPSET *	pPropSet	= NULL;
	
	{
		CBSTR strTemp;
		strTemp.SetStr(pstrURL);
		urlParser.SetURL(pstrURL);
	}

	if(CheckIfValidDataSrc() == FALSE)
	{
		hr =E_INVALIDARG;
	}
	else
	{

		DBPROPIDSET rgPropIDSet[1];
		rgPropIDSet[0].cPropertyIDs		= 0;
		rgPropIDSet[0].guidPropertySet	= DBPROPSET_ROWSET;

		//===============================
		// Get the properties
		//===============================
		if(SUCCEEDED(hr = m_pUtilProp->GetProperties(PROPSET_ROWSET,0,rgPropIDSet, &cPropSets,&prgPropertySets)))
		{
			//====================================================
			// Get the class name and initialize the tableID
			//====================================================
			// NTRaid:134967
			// 07/11/2000
			if( SUCCEEDED(hr = m_pCDataSource->GetConnectionInitProperties(&pPropSet)) )
			{
				hr = GetClassName(&urlParser,pPropSet,strTableName,m_pCDataSource->m_pWbemWrap);

				if (SUCCEEDED(hr))
				{

					DBID tableID;
					memset(&tableID , 0 , sizeof(DBID));
					tableID.eKind = DBKIND_NAME;
					tableID.uName.pwszName = strTableName;

					//===============================
					// Open the rowset
					//===============================
					hr = m_pIOpenRowset->OpenRowset(pUnkOuter,&tableID,NULL,guidTemp,cPropSets,prgPropertySets,ppUnk);

					SAFE_FREE_SYSSTRING(strTableName);
				}

				//==========================================================================
				//  Free memory we allocated to get the namespace property above
				//==========================================================================
				CPropertyMemoryMgr::FreeDBPROPSET( 1, pPropSet);
			}

			//==========================================================================
			//  Free memory we allocated to by GetProperties
			//==========================================================================
			m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropSets, prgPropertySets);
		}
	}

	return hr;
}

BOOL CDBSession::CheckIfValidDataSrc()
{
	if(m_pCDataSource != NULL && m_pCDataSource->m_fDSOInitialized == TRUE)
		return TRUE;


	return FALSE;

}

HRESULT CDBSession::GenerateNewUOW(GUID &guidTrans)
{
	HRESULT hr = S_OK;
	assert (sizeof(XACTUOW) == sizeof(GUID));
	if(SUCCEEDED(hr = CoCreateGuid(&guidTrans)))
	{
		memcpy(&m_TxnGuid.rgb,&guidTrans,sizeof(GUID));
	}
	return hr;
}

void CDBSession::AddRowset(CBaseRowObj * pRowset)
{
	m_nOpenedRowset++;
	m_OpenedRowsets.Add(pRowset);
}

void CDBSession::RemoveRowset(CBaseRowObj * pRowset)
{
	m_nOpenedRowset--;
	for( int i = 0 ; i < m_OpenedRowsets.Size(); i++)
	{
		if(pRowset == (CBaseRowObj *) m_OpenedRowsets.GetAt(i))
		{
			m_OpenedRowsets.RemoveAt(i);
			break;
		}
	}
	m_OpenedRowsets.Add(pRowset);
}

void CDBSession::SetAllOpenRowsetToZoombieState()
{
	CBaseRowObj * pRowObj = NULL;
	m_nOpenedRowset--;
	for( int i = 0 ; i < m_OpenedRowsets.Size(); i++)
	{
		pRowObj = (CBaseRowObj *) m_OpenedRowsets.GetAt(i);
		if(pRowObj != NULL)
		{
			pRowObj->SetStatusToZoombie();
		}
		pRowObj = NULL;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieve an interface pointer on the session object
//
//  
//		 S_OK				Session Object Interface returned
//		 E_INVALIDARG		ppDataSource was NULL
//		 E_NOINTERFACE		IID not supported
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIGetDataSource::GetDataSource(	REFIID		riid,			//  IN  IID desired
												IUnknown**	ppDataSource	//  OUT ptr to interface
	)
{
	HRESULT hr = E_INVALIDARG;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	//========================================================================
	// Check Function Arguments
	//========================================================================
	if( ppDataSource != NULL ){
	
		assert(m_pObj->m_pCDataSource);
		assert(m_pObj->m_pCDataSource->GetOuterUnknown());
	
		//====================================================================
		//Handle Aggregated DataSource (if aggregated)
		//====================================================================
		hr = m_pObj->m_pCDataSource->GetOuterUnknown()->QueryInterface(riid, (LPVOID*)ppDataSource);
	}
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IGetDataSource);

	CATCH_BLOCK_HRESULT(hr,L"IGetDataSource::GetDataSource");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Returns current settings of all properties in the DBPROPFLAGS_SESSION property group
//  HRESULT
//       S_OK           The method succeeded
//       E_INVALIDARG   pcProperties or prgPropertyInfo was NULL
//       E_OUTOFMEMORY  Out of memory
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpISessionProperties::GetProperties (
	    ULONG				cPropertySets,		// IN   count of restiction guids
		const DBPROPIDSET	rgPropertySets[],	// IN   restriction guids
		ULONG*              pcProperties,		// OUT  count of properties returned
		DBPROPSET**			prgProperties		// OUT  property information returned
    )
{
    assert( m_pObj );
    assert( m_pObj->m_pUtilProp );
	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	g_pCError->ClearErrorInfo();

	//========================================================================
	// Check Arguments
	//========================================================================
	hr = m_pObj->m_pUtilProp->GetPropertiesArgChk(PROPSET_SESSION, cPropertySets, 
								rgPropertySets, pcProperties, prgProperties);
	if ( !FAILED(hr) ){

		//========================================================================
		// just pass this call on to the utility object that manages our 
		// properties
		//========================================================================
		hr = m_pObj->m_pUtilProp->GetProperties( PROPSET_SESSION,cPropertySets,rgPropertySets,pcProperties, prgProperties );
	}
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ISessionProperties);

	CATCH_BLOCK_HRESULT(hr,L"ISessionProperties::GetProperties ");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Set properties in the DBPROPFLAGS_SESSION property group
//
//  HRESULT
//       E_INVALIDARG   cProperties was not equal to 0 and rgProperties was NULL
//       E_NOTIMPL		this method is not implemented
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP    CImpISessionProperties::SetProperties (   ULONG		cProperties, DBPROPSET	rgProperties[] )
{
 	HRESULT hr = S_OK;

    assert( m_pObj );
    assert( m_pObj->m_pUtilProp );

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());
	
	// Clear Error information
	g_pCError->ClearErrorInfo();

	//========================================================================
	// Quick return if the Count of Properties is 0
	//========================================================================
	if( cProperties != 0 ){

		//====================================================================
		// Check Arguments for use by properties
		//====================================================================
		hr = m_pObj->m_pUtilProp->SetPropertiesArgChk(cProperties, rgProperties);
		if( !FAILED(hr) ){

			//====================================================================
		    // just pass this call on to the utility object that manages our properties
			//====================================================================
			hr = m_pObj->m_pUtilProp->SetProperties( PROPSET_SESSION,cProperties, rgProperties);
		}
	}
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ISessionProperties);

	CATCH_BLOCK_HRESULT(hr,L"ISessionProperties::GetProperties ");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\dllmain.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// The module contains the DLL Entry and Exit points
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define DECLARE_GLOBALS
//===============================================================================
//  Don't include everything from windows.h, but always bring in OLE 2 support
//===============================================================================
//#define WIN32_LEAN_AND_MEAN
#define INC_OLE2

//===============================================================================
//  Make sure constants get initialized
//===============================================================================
#define INITGUID
#define DBINITCONSTANTS

//===============================================================================
// Basic Windows and OLE everything
//===============================================================================
#include <windows.h>


//===============================================================================
//  OLE DB headers
//===============================================================================
#include "oledb.h"
#include "oledberr.h"

//===============================================================================
//	Data conversion library header
//===============================================================================
#include "msdadc.h"

//===============================================================================
// Guids for data conversion library
//===============================================================================
#include "msdaguid.h"


//===============================================================================
//  GUIDs
//===============================================================================
#include "guids.h"

//===============================================================================
//	OLEDB RootBinder
//===============================================================================
#include "msdasc.h"

//===============================================================================
//  Common project stuff
//===============================================================================

#include "headers.h"
#include "classfac.h"
#include "binderclassfac.h"
#include "binder.h"

//===============================================================================
//  Globals
//===============================================================================
LONG g_cObj;						// # of outstanding objects
LONG g_cLock;						// # of explicit locks set
DWORD g_cAttachedProcesses;			// # of attached processes
DWORD g_dwPageSize;					// System page size
long glGlobalErrorInit = 0;

BOOL CGlobals::m_bInitialized = FALSE;
STDAPI DllUnregisterServer( void  );
//===============================================================================
// Static vars
//===============================================================================
/*
static const WCHAR * s_strDllName = L"WMIOLEDB";
static const struct{

	PWSTR strRegKey;
	PWSTR  strValueName;
	DWORD  dwType;
	PWSTR  strValue;
} s_rgRegInfo[] =
{
	
    { L"WMIOLEDB", NULL, REG_SZ, L"Microsoft WMI OLE DB Provider" },
    { L"WMIOLEDB\\Clsid", NULL, REG_SZ, L"{FD8D9C02-265E-11d2-98D9-00A0C9B7CBFE}" },
    { L"CLSID\\{FD8D9C02-265E-11d2-98D9-00A0C9B7CBFE}", NULL, REG_SZ, L"WMIOLEDB" },
	{ L"CLSID\\{FD8D9C02-265E-11d2-98D9-00A0C9B7CBFE}", L"OLEDB_SERVICES", REG_DWORD, L"-1" },
    { L"CLSID\\{FD8D9C02-265E-11d2-98D9-00A0C9B7CBFE}\\ProgID", NULL, REG_SZ, L"WMIOLEDB" },
    { L"CLSID\\{FD8D9C02-265E-11d2-98D9-00A0C9B7CBFE}\\VersionIndependentProgID", NULL, REG_SZ, L"WMIOLEDB" },

	{ L"CLSID\\{FD8D9C02-265E-11d2-98D9-00A0C9B7CBFE}\\InprocServer32", NULL, REG_SZ, L"%s" },
	{ L"CLSID\\{FD8D9C02-265E-11d2-98D9-00A0C9B7CBFE}\\InprocServer32", L"ThreadingModel", REG_SZ, L"Both" },
	{ L"CLSID\\{FD8D9C02-265E-11d2-98D9-00A0C9B7CBFE}\\OLE DB Provider", NULL, REG_SZ, L"Microsoft WMI OLE DB Provider" },

	{ L"CLSID\\{FD8D9C02-265E-11d2-98D9-00A0C9B7CBFE}\\ExtendedErrors", NULL, REG_SZ, L"Extended Error Service" },
	{ L"CLSID\\{FD8D9C02-265E-11d2-98D9-00A0C9B7CBFE}\\ExtendedErrors\\{80C4A61D-CB78-46fd-BD8F-8BF45BE46A4C}", NULL, REG_SZ, L"WMIOLEDB Error Lookup" },

    { L"WMIOLEDB.ErrorLookup", NULL, REG_SZ, L"WMIOLEDB Error Lookup" },
    { L"WMIOLEDB.ErrorLookup\\Clsid", NULL, REG_SZ, L"{80C4A61D-CB78-46fd-BD8F-8BF45BE46A4C}" },
    { L"CLSID\\{80C4A61D-CB78-46fd-BD8F-8BF45BE46A4C}", NULL, REG_SZ, L"WMIOLEDB.ErrorLookup" },
    { L"CLSID\\{80C4A61D-CB78-46fd-BD8F-8BF45BE46A4C}\\ProgID", NULL, REG_SZ, L"WMIOLEDB.ErrorLookup" },
    { L"CLSID\\{80C4A61D-CB78-46fd-BD8F-8BF45BE46A4C}\\VersionIndependentProgID", NULL, REG_SZ, L"WMIOLEDB.ErrorLookup" },

	{ L"CLSID\\{80C4A61D-CB78-46fd-BD8F-8BF45BE46A4C}\\InprocServer32", NULL, REG_SZ, L"%s" },
	{ L"CLSID\\{80C4A61D-CB78-46fd-BD8F-8BF45BE46A4C}\\InprocServer32", L"ThreadingModel", REG_SZ, L"Both" },

    { L"WMIOLEDB.RootBinder", NULL, REG_SZ, L"Microsoft WMI OLE DB Root Binder" },
    { L"WMIOLEDB.RootBinder\\Clsid", NULL, REG_SZ, L"{CDCEDB81-5FEC-11d3-9D1C-00C04F5F1164}" },
    { L"CLSID\\{CDCEDB81-5FEC-11d3-9D1C-00C04F5F1164}", NULL, REG_SZ, L"WMIOLEDB.RootBinder" },
    { L"CLSID\\{CDCEDB81-5FEC-11d3-9D1C-00C04F5F1164}\\ProgID", NULL, REG_SZ, L"WMIOLEDB.RootBinder" },
    { L"CLSID\\{CDCEDB81-5FEC-11d3-9D1C-00C04F5F1164}\\VersionIndependentProgID", NULL, REG_SZ, L"WMIOLEDB.RootBinder" },

	{ L"CLSID\\{CDCEDB81-5FEC-11d3-9D1C-00C04F5F1164}\\InprocServer32", NULL, REG_SZ, L"%s" },
	{ L"CLSID\\{CDCEDB81-5FEC-11d3-9D1C-00C04F5F1164}\\InprocServer32", L"ThreadingModel", REG_SZ, L"Both" },
	{ L"CLSID\\{CDCEDB81-5FEC-11d3-9D1C-00C04F5F1164}\\OLE DB Binder", NULL, REG_SZ, L"Microsoft WMI OLE DB Root Binder" },

    { L"WMIOLEDB.Enumerator", NULL, REG_SZ, L"Microsoft WMI OLE DB Enumerator" },
    { L"WMIOLEDB.Enumerator\\Clsid", NULL, REG_SZ, L"{E14321B2-67C0-11d3-B3B4-00104BCC48C4}" },
    { L"CLSID\\{E14321B2-67C0-11d3-B3B4-00104BCC48C4}", NULL, REG_SZ, L"WMIOLEDB.Enumerator" },
    { L"CLSID\\{E14321B2-67C0-11d3-B3B4-00104BCC48C4}\\ProgID", NULL, REG_SZ, L"WMIOLEDB.Enumerator" },
    { L"CLSID\\{E14321B2-67C0-11d3-B3B4-00104BCC48C4}\\VersionIndependentProgID", NULL, REG_SZ, L"WMIOLEDB.Enumerator" },

	{ L"CLSID\\{E14321B2-67C0-11d3-B3B4-00104BCC48C4}\\InprocServer32", NULL, REG_SZ, L"%s" },
	{ L"CLSID\\{E14321B2-67C0-11d3-B3B4-00104BCC48C4}\\InprocServer32", L"ThreadingModel", REG_SZ, L"Both" },
	{ L"CLSID\\{E14321B2-67C0-11d3-B3B4-00104BCC48C4}\\OLE DB Enumerator", NULL, REG_SZ, L"Microsoft WMI OLE DB Enumerator" },

};
*/

static CTString s_strDllName;

static const struct{

	UINT	uRegKey;
	UINT	uValueName;
	DWORD	dwType;
	UINT	uValue;
} s_rgRegInfo[] =
{
	
    { IDS_PROGID,			0,				REG_SZ,		IDS_DESCRIPTION },
    { IDS_PROGCLSID,		0,				REG_SZ,		IDS_CLSID },
    { IDS_CLSIDKEY,			0,				REG_SZ,		IDS_PROGID},
	{ IDS_CLSIDKEY,			IDS_OLEDBSER,	REG_DWORD,	-1 },
    { IDS_PROGIDKEY,		0,				REG_SZ,		IDS_PROGID },
    { IDS_VIPROGIDKEY,		0,				REG_SZ,		IDS_PROGID },

	{ IDS_INPROCSER,		0,				REG_SZ,		IDS_STRFORMAT },
	{ IDS_INPROCSER,		IDS_THREADMODEL,REG_SZ,		IDS_BOTHTHREADMODEL },
	{ IDS_OLEDBPROVKEY,		0,				REG_SZ,		IDS_DESCRIPTION},

	{ IDS_EXTERROR,			0,				REG_SZ,		IDS_EXTERRDESC },
	{ IDS_EXTERRORCLSIDKEY, 0,				REG_SZ,		IDS_ERRLOOKUPDESC },

    { IDS_EL_PROGID,		0,				REG_SZ,		IDS_ERRLOOKUPDESC },
    { IDS_EL_PROGCLSID,		0,				REG_SZ,		IDS_EL_CLSID },
    { IDS_EL_CLSIDKEY,		0,				REG_SZ,		IDS_EL_PROGID },
    { IDS_EL_CLSPROGID,		0,				REG_SZ,		IDS_EL_PROGID },
    { IDS_EL_CLSVIPROGID,	0,				REG_SZ,		IDS_EL_PROGID },

	{ IDS_EL_INPROCSERKEY,	0,				REG_SZ,		IDS_STRFORMAT },
	{ IDS_EL_INPROCSERKEY,	IDS_THREADMODEL,REG_SZ,		IDS_BOTHTHREADMODEL},

    { IDS_RB_PROGID,		0,				REG_SZ,		IDS_RB_DESC },
    { IDS_RB_PROGCLSID,		0,				REG_SZ,		IDS_RB_CLSID },
    { IDS_RB_CLSIDKEY,		0,				REG_SZ,		IDS_RB_PROGID },
    { IDS_RB_CLSPROGID,		0,				REG_SZ,		IDS_RB_PROGID },
    { IDS_RB_CLSVIPROGID,	0,				REG_SZ,		IDS_RB_PROGID },

	{ IDS_RB_INPROCSERKEY,	0,				REG_SZ,		IDS_STRFORMAT},
	{ IDS_RB_INPROCSERKEY,	IDS_THREADMODEL,REG_SZ,		IDS_BOTHTHREADMODEL },
	{ IDS_RB_ROOTBINDER,	0,				REG_SZ,		IDS_RB_DESC},

    { IDS_EN_PROGID,		0,				REG_SZ,		IDS_EN_DESC },
    { IDS_EN_PROGCLSID,		0,				REG_SZ,		IDS_EN_CLSID },
    { IDS_EN_CLSIDKEY,		0,				REG_SZ,		IDS_EN_PROGID },
    { IDS_EN_CLSPROGID,		0,				REG_SZ,		IDS_EN_PROGID },
    { IDS_EN_CLSVIPROGID,	0,				REG_SZ,		IDS_EN_PROGID },

	{ IDS_EN_INPROCSERKEY,	0,				REG_SZ,		IDS_STRFORMAT },
	{ IDS_EN_INPROCSERKEY,	IDS_THREADMODEL,REG_SZ,		IDS_BOTHTHREADMODEL },
	{ IDS_EN_ENUMERATOR,	0,				REG_SZ,		IDS_EN_DESC },

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Verify and create the objects if requiered
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT VerifyGlobalErrorHandling()
{
    HRESULT hr = S_OK;

    if( InterlockedIncrement(&glGlobalErrorInit) == 1 ){
    	
		g_pCError = new CError;

        if( g_pCError ){
            hr = g_pCError->FInit();
            if( hr == S_OK ){
           	    hr = CoGetClassObject(CLSID_EXTENDEDERRORINFO, CLSCTX_INPROC_SERVER, NULL,  IID_IClassFactory,(void **) & g_pErrClassFact);
            }
        }
        else{
            LogMessage("Could not instantiate internal error handling object\n");
		    hr = E_FAIL;
        }
    }
    if( hr != S_OK ){
        glGlobalErrorInit = 0;
    }
	else
	{
		g_pErrClassFact->LockServer(TRUE);
	}
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Release the error releated interfaces and object
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ReleaseGlobalErrorHandling()
{
    HRESULT hr = E_FAIL;

    if( InterlockedDecrement(&glGlobalErrorInit) == 0 ){
        if( g_pCError ){
			if(g_pErrClassFact)
			{
				g_pErrClassFact->LockServer(FALSE);
			}
            SAFE_RELEASE_PTR(g_pErrClassFact);
            SAFE_DELETE_PTR(g_pCError);
            hr = S_OK;
        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Registering the Root Binder object of the Provider
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT RegisterRootBinder()
{
	HRESULT hr = S_OK;
	IRegisterProvider *pRegisterProvider = NULL;

	if(SUCCEEDED(hr = CoCreateInstance(CLSID_RootBinder, NULL,CLSCTX_INPROC_SERVER,   IID_IRegisterProvider ,(void **)&pRegisterProvider)))
	{
		hr = pRegisterProvider->SetURLMapping(UMIURLPREFIX,0,CLSID_WMIOLEDB_ROOTBINDER);
		hr = pRegisterProvider->SetURLMapping(WMIURLPREFIX,0,CLSID_WMIOLEDB_ROOTBINDER);
		pRegisterProvider->Release();
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Unregistering the Root Binder object of the Provider
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT UnRegisterRootBinder()
{
	HRESULT hr = S_OK;
	IRegisterProvider *pRegisterProvider = NULL;

	if(SUCCEEDED(hr = CoCreateInstance(CLSID_RootBinder, NULL, CLSCTX_INPROC_SERVER,   IID_IRegisterProvider ,(void **)&pRegisterProvider)))
	{
		hr = pRegisterProvider->UnregisterProvider(UMIURLPREFIX,0,CLSID_WMIOLEDB_ROOTBINDER);
		hr = pRegisterProvider->UnregisterProvider(WMIURLPREFIX,0,CLSID_WMIOLEDB_ROOTBINDER);
		pRegisterProvider->Release();
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  DLL Entry point where Instance and Thread attach/detach notifications takes place.
//  OLE is initialized and the IMalloc Interface pointer is obtained.
//
//  Boolean Flag
//       TRUE		Successful initialization
//       FALSE		Failure to intialize
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DllMain(		HINSTANCE   hInstDLL,   // IN Application Instance Handle
							DWORD       fdwReason,  // IN Indicated Process or Thread activity
							LPVOID      lpvReserved // IN Reserved...
    )
{
    BOOL        fRetVal = FALSE;

    CSetStructuredExceptionHandler seh;

//	TRY_BLOCK;

	switch (fdwReason)
	{

		LogMessage("Inside DllMain");

		case DLL_PROCESS_ATTACH:
			{
				//==================================================================
				// Assume successfully initialized
				//==================================================================
				fRetVal = TRUE;
				//==================================================================
				// Do one-time initialization when first process attaches
				//==================================================================
				if (!g_cAttachedProcesses)
				{
					g_hInstance = hInstDLL;

					// Initialize the global variables
					g_cgGlobals.Init();
				}
				//==============================================================
				// Do per-process initialization here...
				// Remember that another process successfully attached
				//==============================================================
				g_cAttachedProcesses++;
				break;
			}


		case DLL_PROCESS_DETACH:
			{
				//==============================================================
				// Do per-process clean up here...
				// Remember that a process has detached
				//==============================================================
				g_cAttachedProcesses--;
				break;
			}

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
			{
				fRetVal = TRUE;
				break;
			}
	
	}	// switch

//	CATCH_BLOCK_BOOL(fRetVal,L"DllMain");

    return fRetVal;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  This function is exposed to OLE so that the classfactory can be obtained.
//
//  HRESULT indicating status of routine
//       S_OK                       The object was retrieved successfully.
//       CLASS_E_CLASSNOTAVAILABLE  DLL does not support class.
//       E_OUTOFMEMORY              Out of memory.
//       E_INVALIDARG               One or more arguments are invalid.
//       E_UNEXPECTED               An unexpected error occurred.
//       OTHER						Other HRESULTs returned by called functions
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CALLBACK DllGetClassObject( REFCLSID    rclsid, // IN CLSID of the object class to be loaded
									REFIID      riid,   // IN Interface on object to be instantiated
									LPVOID *    ppvObj  // OUT Pointer to interface that was instantiated
								  )
{
//    CClassFactory * pClassFactory;
    IClassFactory * pClassFactory = NULL;
    HRESULT         hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//=======================================================================
	// Check for valid ppvObj pointer
	//=======================================================================
	if (!ppvObj){
		hr = E_INVALIDARG;
		LogMessage("DllGetClassObject failed with invalid argument");
	}
	else
	{
		//===================================================================
		// In case we fail, we need to zero output arguments
		//===================================================================
		*ppvObj = NULL;

		//===================================================================
		// We only service CLSID_WMIOLEDB
		//===================================================================
		if (!(rclsid == CLSID_WMIOLEDB || rclsid == CLSID_WMIOLEDB_ROOTBINDER ||
				rclsid == CLSID_WMIOLEDB_ENUMERATOR || rclsid == CLSID_WMIOLEDB_ERRORLOOOKUP))
		{
			hr = CLASS_E_CLASSNOTAVAILABLE;
			LogMessage("DllGetClassObject failed with CLSID_WMIOLEDB not available - Not registered?");
		}
		else{
			//===============================================================
			// We only support the IUnknown and IClassFactory interfaces
			//===============================================================
			if (riid != IID_IUnknown &&	riid != IID_IClassFactory){
				hr = E_NOINTERFACE;
				LogMessage("DllGetClassObject failed with no interface");
			}
			else{

				try
				{
					//===========================================================
					// Create our ClassFactory object
					//===========================================================
					if( rclsid == CLSID_WMIOLEDB ){
						pClassFactory = new CDataSourceClassFactory();
					}
					else if( rclsid == CLSID_WMIOLEDB_ENUMERATOR ){
						pClassFactory = new  CEnumeratorClassFactory();
					}
					else if( rclsid ==  CLSID_WMIOLEDB_ROOTBINDER ){
   						pClassFactory = new CBinderClassFactory();
					}
					else if( rclsid ==  CLSID_WMIOLEDB_ERRORLOOOKUP ){
   						pClassFactory = new CErrorLookupClassFactory();
					}
				}
				catch(...)
				{
					SAFE_DELETE_PTR(pClassFactory);
					throw;
				}
	
				if (pClassFactory == NULL){
					hr = E_OUTOFMEMORY;
					LogMessage("DllGetClassObject failed - out of memory");
				}
				else{
					//=======================================================
					// Get the desired interface on this object
					//=======================================================
					hr = pClassFactory->QueryInterface( riid, ppvObj );
					if (!SUCCEEDED( hr )){
						SAFE_DELETE_PTR( pClassFactory );
						LogMessage("DllGetClassObject failed - return code:",hr);
					}
   				}
			}
		}
	}

	CATCH_BLOCK_HRESULT(hr,L"DllGetClassObject");

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Indicates whether the DLL is no longer in use and can be unloaded.
//
//  HRESULT indicating status of routine
//       S_OK		 DLL can be unloaded now.
//       S_FALSE	 DLL cannot be unloaded now.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow( void )
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

//    if(!(!g_cObj && !g_cLock))
    if(g_cObj || g_cLock)
	{
        hr = S_FALSE;
	}

	CATCH_BLOCK_HRESULT(hr,L"DllCanUnloadNow");

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//     Adds necessary keys to the registry.
//
//  Returns one of the following
//		NOERROR     Registration succeeded
//		E_FAIL      Something didn't work
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer( void )
{
    HKEY        hk;
    HMODULE     hModule = 0;
    DWORD       dwDisposition;
    LONG        stat;
	TCHAR		strFileName[MAX_PATH+1];
    TCHAR       strOutBuff[300+1];
	HRESULT		hr = S_OK;
	CTString	strKey,strValueName,strValue;
	DWORD		dwValue;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	hModule = GetModuleHandle(s_strDllName );
	//================================================================
    // Get the full path name for this DLL.
	//================================================================
    if (hModule == NULL)
	{
		hr = E_FAIL;
        LogMessage("DllRegisterServer: GetModuleHandle failed");
	}
	else
	if (0 == GetModuleFileName( hModule, strFileName, sizeof( strFileName ) / sizeof(TCHAR)))
	{
        hr = E_FAIL;
        LogMessage("DllRegisterServer: GetModuleFileName failed");
	}
	else
	{

		//============================================================
		// Make a clean start
		//============================================================
		
		//============================================================
	    // Loop through s_rgRegInfo, and put everything in it.
		// Every entry is based on HKEY_CLASSES_ROOT.
   		//============================================================
		for (ULONG i=0; i < NUMELEM( s_rgRegInfo ); i++)
		{
			// NTRaid: 136432 , 136436
			// 07/05/00
			if(SUCCEEDED(hr =strValue.LoadStr(s_rgRegInfo[i].uValue))  &&
			SUCCEEDED(hr =strKey.LoadStr(s_rgRegInfo[i].uRegKey)) &&
			SUCCEEDED(hr =strValueName.LoadStr(s_rgRegInfo[i].uValueName)))
			{
				//========================================================
				// Fill in any "%s" arguments with the name of this DLL.
				//========================================================
				if (s_rgRegInfo[i].dwType == REG_DWORD)
				{
					dwValue = (DWORD)s_rgRegInfo[i].uValue;
				}
				else
				{
					_stprintf( strOutBuff, strValue, strFileName );
				}

				//========================================================
				// Create the Key.  If it exists, we open it.
				// Thus we can still change the value below.
         			//========================================================
				stat = RegCreateKeyEx(	HKEY_CLASSES_ROOT, 
										strKey,
										0,  
										NULL,
										REG_OPTION_NON_VOLATILE,
										KEY_ALL_ACCESS,
										NULL,  
										&hk,   
										&dwDisposition );

				if (stat != ERROR_SUCCESS){
					hr = E_FAIL ;
					LogMessage("DllRegisterServer: failed to create key");
					LogMessage(strKey);
        		}
				else{

					stat = RegSetValueEx(	hk,
											strValueName,					
											0,								
											s_rgRegInfo[i].dwType,			
											s_rgRegInfo[i].dwType == REG_DWORD ? (BYTE *) &dwValue :(BYTE *) strOutBuff,
											s_rgRegInfo[i].dwType == REG_SZ ? (_tcslen( strOutBuff ) + 1) * sizeof(TCHAR) :sizeof(DWORD));
					RegCloseKey( hk );
					if (stat != ERROR_SUCCESS){
						LogMessage("DllRegisterServer: failed to set value");
						LogMessage(strValueName);
						hr = E_FAIL;
					}
				}
			}
			else
			{
				// remove all the registry entries
				DllUnregisterServer();
				break;
			}
		}
	}

	if(SUCCEEDED(hr))
	{
		//=========================================================
		// Register the root binder object of the provider
		//=========================================================
		hr = RegisterRootBinder();
	}

	CATCH_BLOCK_HRESULT(hr,L"DllUnregisterServer");

    return hr;
}


STDAPI DllUnregisterServer( void  )
{
    int     i;
    int     iNumErrors = 0;
	LONG	stat;
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;
	CTString	strKey;

	TRY_BLOCK;

	//==========================================================
	// UnRegister the root binder object of the provider
	//==========================================================
	UnRegisterRootBinder();

	//=========================================================================
    // Delete all table entries.  Loop in reverse order, since they
    // are entered in a basic-to-complex order.
    // We cannot delete a key that has subkeys.
    // Ignore errors.
	//=========================================================================
    for (i=NUMELEM( s_rgRegInfo ) - 1; i >= 0; i--) 
	{
		// NTRaid: 136432 , 136436
		// 07/05/00
		if(SUCCEEDED(hr = strKey.LoadStr(s_rgRegInfo[i].uRegKey)))
		{
			stat = RegDeleteKey( HKEY_CLASSES_ROOT, strKey );
			if ((stat != ERROR_SUCCESS) && 	(stat != ERROR_FILE_NOT_FOUND) ){
				iNumErrors++;
				hr = E_FAIL;
				LogMessage("DllUnregisterServer failed");
			}
		}
		else
		{
			break;
		}
    }

	CATCH_BLOCK_HRESULT(hr,L"DllUnregisterServer");

	return hr;
}

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Removes keys to the registry.
//
//  Returns NOERROR
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer( void  )
{
    int     i;
    int     iNumErrors = 0;
	LONG	stat;
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//==========================================================
	// UnRegister the root binder object of the provider
	//==========================================================
	UnRegisterRootBinder();

	//=========================================================================
    // Delete all table entries.  Loop in reverse order, since they
    // are entered in a basic-to-complex order.
    // We cannot delete a key that has subkeys.
    // Ignore errors.
	//=========================================================================
    for (i=NUMELEM( s_rgRegInfo ) - 1; i >= 0; i--) {
		stat = RegDeleteKeyW( HKEY_CLASSES_ROOT, s_rgRegInfo[i].strRegKey );
        if ((stat != ERROR_SUCCESS) && 	(stat != ERROR_FILE_NOT_FOUND) ){
            iNumErrors++;
			hr = E_FAIL;
            LogMessage("DllUnregisterServer failed");
		}
    }

	CATCH_BLOCK_HRESULT(hr,L"DllUnregisterServer");

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//     Adds necessary keys to the registry.
//
//  Returns one of the following
//		NOERROR     Registration succeeded
//		E_FAIL      Something didn't work
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer( void )
{
    HKEY        hk;
    HMODULE     hModule;
    DWORD       dwDisposition;
    LONG        stat;
	WCHAR		strFileName[MAX_PATH+1];
    WCHAR        strOutBuff[300+1];
	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;
	//================================================================
    // Get the full path name for this DLL.
	//================================================================
    if (NULL == (hModule = GetModuleHandleW( s_strDllName ))){
		hr = E_FAIL;
        LogMessage("DllRegisterServer: GetModuleHandle failed");
	}
	else if (0 == GetModuleFileNameW( hModule, strFileName, sizeof( strFileName ) / sizeof( char ))){
        hr = E_FAIL;
        LogMessage("DllRegisterServer: GetModuleFileName failed");
	}
	else{

		//============================================================
		// Make a clean start
		//============================================================
		
//	    DllUnregisterServer();
		DWORD dwType = REG_DWORD;
		//============================================================
	    // Loop through s_rgRegInfo, and put everything in it.
		// Every entry is based on HKEY_CLASSES_ROOT.
   		//============================================================
		for (ULONG i=0; i < NUMELEM( s_rgRegInfo ); i++){

			//========================================================
			// Fill in any "%s" arguments with the name of this DLL.
			//========================================================
			if (s_rgRegInfo[i].dwType == REG_DWORD)
			{
				*(DWORD*)strOutBuff = _wtol( s_rgRegInfo[i].strValue );
			}
			else
			{
				wsprintfW( strOutBuff, s_rgRegInfo[i].strValue, strFileName );
			}

			//========================================================
			// Create the Key.  If it exists, we open it.
			// Thus we can still change the value below.
       		//========================================================
			stat = RegCreateKeyExW( HKEY_CLASSES_ROOT, s_rgRegInfo[i].strRegKey,
														0,  // dwReserved
														NULL,   // lpszClass
														REG_OPTION_NON_VOLATILE,
														KEY_ALL_ACCESS, // security access mask
														NULL,   // lpSecurityAttributes
														&hk,    // phkResult
														&dwDisposition );
			if (stat != ERROR_SUCCESS){
				hr = E_FAIL ;
                LogMessage("DllRegisterServer: failed to create key");
                LogMessage(s_rgRegInfo[i].strRegKey);
        	}
			else{

				stat = RegSetValueExW(hk,s_rgRegInfo[i].strValueName,	// lpszValueName
										0,								// dwReserved
										s_rgRegInfo[i].dwType,			// fdwType
										(BYTE *) strOutBuff,			// value
										s_rgRegInfo[i].dwType == REG_SZ ?
										(wcslen( strOutBuff ) + 1) * sizeof(WCHAR) :		// cbData, including null terminator
										sizeof(DWORD));					
				RegCloseKey( hk );
				if (stat != ERROR_SUCCESS){
                    LogMessage("DllRegisterServer: failed to set value");
                    LogMessage(s_rgRegInfo[i].strValueName);
					hr = E_FAIL;
				}
			}
		}
	}

	//=========================================================
	// Register the root binder object of the provider
	//=========================================================
	hr = RegisterRootBinder();

	CATCH_BLOCK_HRESULT(hr,L"DllUnregisterServer");

    return hr;
}

*/

/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////
CGlobals::CGlobals()
{
    g_pIMalloc				= NULL;		// OLE2 task memory allocator
    g_pIDataConvert			= NULL;		// IDataConvert pointer
    g_pCError				= NULL;
    g_pErrClassFact			= NULL;
	g_bIsAnsiOS				= FALSE;
	g_pIWbemPathParser		= FALSE;	// class factory pointer for Parser object
	g_pIWbemCtxClassFac		= NULL;
}

/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////
CGlobals::~CGlobals()
{

	//==================================================================
	//  Clean up the global error handling
	//==================================================================
	ReleaseGlobalErrorHandling();

	//==============================================================
    // Clean up when the last process is going away
	//==============================================================
	m_CsGlobalError.Delete();

    //==============================================================
	// Delete internal error handler
	//==============================================================
	SAFE_DELETE_PTR( g_pCError )
	SAFE_RELEASE_PTR(g_pIDataConvert);

	if(g_pIWbemPathParser)
	{
		g_pIWbemPathParser->LockServer(FALSE);
	}
	SAFE_RELEASE_PTR(g_pIWbemPathParser);

	SAFE_RELEASE_PTR(g_pIWbemCtxClassFac);

	//==========================================================
	// Release the memory allocator object.
	//==========================================================
	SAFE_RELEASE_PTR(g_pIMalloc)
}

/////////////////////////////////////////////////////////////////////////////
// Initialize global variables
/////////////////////////////////////////////////////////////////////////////
HRESULT CGlobals::Init()
{
	HRESULT hr = S_OK;
    SYSTEM_INFO SystemInformation;

	if(!m_bInitialized)
	{
		s_strDllName.LoadStr(IDS_WMIOLEDBDLLNAME);
		//==================================================================
		//  Initialize the global error handling
		//==================================================================
		VerifyGlobalErrorHandling();

		m_CsGlobalError.Init();


		//==============================================================
		// Get the OLE task memory allocator; we'll use it to allocate
		// all memory that we return to the client
		//==============================================================
		hr = CoGetMalloc( MEMCTX_TASK, &g_pIMalloc );
		if (!g_pIMalloc || !SUCCEEDED( hr )){
			LogMessage("CoGetMalloc failed in CGlobals::Init");
		}
		else
		{
			//==============================================================
			// Get the system page size
			//==============================================================
			if (!g_dwPageSize)
			{
				GetSystemInfo( &SystemInformation );
				g_dwPageSize = SystemInformation.dwPageSize;
			}

			//========================================================
			// Determine if we are a unicode or non-unicode OS
			//========================================================
			g_bIsAnsiOS		= !OnUnicodeSystem();
			m_bInitialized	= TRUE;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\errinf.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Error Routines
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"

#define ERROR_GUID_ARRAYSIZE				5
// NTRaid : 111781
// 06/13/00
#define ERROR_DESCRIPTION_SIZE				512

static const ULONG INITIAL_ERROR_QUEUE_SIZE = 10;


CImpISupportErrorInfo::CImpISupportErrorInfo( IUnknown* pUnkOuter) 
{
	m_cRef			= 0L;
	m_pUnkOuter		= pUnkOuter;
	m_cpErrInt		= 0;
	m_rgpErrInt		= NULL;
	m_cAllocGuid	= 0;
}

CImpISupportErrorInfo::~CImpISupportErrorInfo()
{
	SAFE_DELETE_ARRAY(m_rgpErrInt);		
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpISupportErrorInfo::AddRef(void)
{
    InterlockedIncrement((long*)&m_cRef);
	return m_pUnkOuter->AddRef();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpISupportErrorInfo::Release(void)
{
    InterlockedDecrement((long*)&m_cRef);
    return m_pUnkOuter->Release();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpISupportErrorInfo::QueryInterface( REFIID riid, LPVOID *	ppv	)	
{
	return m_pUnkOuter->QueryInterface(riid, ppv);
}

// Modifications done for
// NTRaid:111765
HRESULT CImpISupportErrorInfo::AddInterfaceID(REFIID riid)
{
	HRESULT hr = S_OK;

	if(m_rgpErrInt == NULL)
	{
		m_rgpErrInt		= new GUID*[ERROR_GUID_ARRAYSIZE];

		if(m_rgpErrInt)
		{
			m_cAllocGuid	= ERROR_GUID_ARRAYSIZE;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	if(m_cpErrInt >= m_cAllocGuid)
	{
		GUID **pTemp = m_rgpErrInt;
		m_rgpErrInt  = NULL;

		m_rgpErrInt		= new GUID*[m_cAllocGuid + ERROR_GUID_ARRAYSIZE];
		if(m_rgpErrInt)
		{
			memset(m_rgpErrInt ,0, (m_cAllocGuid + ERROR_GUID_ARRAYSIZE) * sizeof(GUID*));
			memcpy(m_rgpErrInt ,pTemp, m_cAllocGuid * sizeof(GUID*));
			m_cAllocGuid += ERROR_GUID_ARRAYSIZE;
			SAFE_DELETE_ARRAY(pTemp);
		}
		else
		{
			m_rgpErrInt = pTemp;
			hr = E_OUTOFMEMORY;
		}
		
	}
	
	if(m_rgpErrInt && SUCCEEDED(hr))
	{
		m_rgpErrInt[m_cpErrInt++] = (GUID *)&riid;
		hr = S_OK;
	}


	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Indicates whether a OLE DB Interface can return OLE DB error objects
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpISupportErrorInfo::InterfaceSupportsErrorInfo(	REFIID	riid )
{
	ULONG ul;
	HRESULT hr = S_FALSE;

    //==========================================================================
	// See if the interface asked about, actually creates an error object.
    //==========================================================================
	for(ul=0; ul<m_cpErrInt; ul++){

		if ( (*(m_rgpErrInt[ul])) == riid )
		{
			hr = S_OK;
			break;
		}
	}
	return hr;
}	
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor for this class
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning (disable:4355)
CErrorLookup::CErrorLookup(	LPUNKNOWN 	pUnkOuter )	: m_IErrorLookup(this), CBaseObj(BOT_ERROR,pUnkOuter)
{
}
#pragma warning (default:4355)

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to a specified interface. Callers use QueryInterface to determine which interfaces
// the called object supports. 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CErrorLookup::QueryInterface(	REFIID riid, LPVOID * ppv)
{
	if ( ppv == NULL )
		return E_INVALIDARG;
    //=========================================================
	//	This is the non-delegating IUnknown implementation
    //=========================================================
	if ( riid == IID_IUnknown )
		*ppv = (LPVOID)this;
	else if ( riid == IID_IErrorLookup )
		*ppv = (LPVOID)&m_IErrorLookup;
	else{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	((LPUNKNOWN)*ppv)->AddRef();
	return S_OK;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Increments a persistence count for the object
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CErrorLookup::AddRef(void)
{
	ULONG cRef = InterlockedIncrement( (long*) &m_cRef);
	return cRef;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrements a persistence count for the object and if persistence count is 0, the object destroys 
// itself.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CErrorLookup::Release (void)
{
	ULONG cRef = InterlockedDecrement( (long*) &m_cRef);
	if ( !cRef ){
		delete this;
		return 0;
	}
	return cRef;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Increments a reference count for the object.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpIErrorLookup::AddRef(void)
{
    InterlockedIncrement((long*)&m_cRef);
	return m_pCErrorLookup->AddRef();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Decrement the object's reference count and deletes the object when the new reference count is zero.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpIErrorLookup::Release(void)
{
    InterlockedDecrement((long*)&m_cRef);
	return  m_pCErrorLookup->Release();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to a specified interface. Callers use QueryInterface to determine which interfaces
// the called object supports. 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIErrorLookup::QueryInterface(	REFIID riid, LPVOID *	ppv)	
{
	return  m_pCErrorLookup->QueryInterface(riid, ppv);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Retrieve the error message and source based on the HRESULT and the provider specific error number
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIErrorLookup::GetErrorDescription(	HRESULT		hrError,
	                                                DWORD		dwLookupId,
	                                                DISPPARAMS*	pdispparams,
	                                                LCID		lcid,		
	                                                BSTR*		ppwszSource,
	                                                BSTR*		ppwszDescription )
{
	HRESULT		hr = NOERROR;
	int			cchBuffer;
	// NTRaid : 111781
	// 06/13/00
	WCHAR		wszBuffer[ERROR_DESCRIPTION_SIZE];

    //=========================================================
	// Check the Arguments
    //=========================================================
    if ( !ppwszSource || !ppwszDescription )
	{
		hr = E_INVALIDARG;
    }
	else
	{
		//=========================================================
		// Initialize return values
		//=========================================================
		*ppwszSource = NULL;
		*ppwszDescription = NULL;

		// Check the Locale
	//	if ( lcid != GetSystemDefaultLCID() )
	//		return DB_E_NOLOCALE;

		wcscpy(wszBuffer,L"");
		WMIOledb_LoadStringW(IDS_WMIOLEDBDES,wszBuffer,ERROR_DESCRIPTION_SIZE);
		//=========================================================
		// Store source name
		//=========================================================
		*ppwszSource = Wmioledb_SysAllocString(wszBuffer);
		if ( *ppwszSource == NULL )
		{
			hr = E_OUTOFMEMORY;
		}
		else
		//=========================================================
		// If the lookup id was to be looked up in the resource dll
		// of the error collection, make sure we just return NULL
		// for the error description.
		//=========================================================
		if ( (dwLookupId &= ~IDENTIFIER_SDK_MASK) == 0 )
		{
			hr = S_OK;
		}
		else
		//=========================================================
		// After this point make sure to exit to goto 
		// the FAILED(hr) code or drop through to the return hr,
		// as to make sure memory is freed if need be.
		// Determine if it is a static or dynamic string
		//=========================================================
		if ( dwLookupId & ERR_STATIC_STRING )
		{
			wcscpy(wszBuffer,L"");
			// NTRaid : 111781
			// 06/13/00
//			cchBuffer = LoadStringW(g_hInstance, (UINT)(dwLookupId & ~(ERR_STATIC_STRING)), wszBuffer,ERROR_DESCRIPTION_SIZE);  
			cchBuffer = WMIOledb_LoadStringW( (UINT)(dwLookupId & ~(ERR_STATIC_STRING)), wszBuffer,ERROR_DESCRIPTION_SIZE);

			//=====================================================
			// Convert to a BSTR
			//=====================================================
			if (cchBuffer)
			{
				*ppwszDescription = Wmioledb_SysAllocString(wszBuffer);
				if ( *ppwszDescription == NULL )
				{
					hr = E_OUTOFMEMORY;
				}
			}
		}
		else
		{
			hr = g_pCError->GetErrorDescription(dwLookupId, ppwszDescription);
		}

		if ( FAILED(hr) )
		{

			//=====================================================
			// If allocation done, make sure that it is freed
			//=====================================================
			if ( ppwszSource )
			{
				SysFreeString(*ppwszSource);
				*ppwszSource = NULL;
			}
			if ( ppwszDescription )
			{
				SysFreeString(*ppwszDescription);
				*ppwszDescription = NULL;
			}
		}

	}		// else for if(check valid parameters)

	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Retrieve the error message and source based on the HRESULT and the provider specific error number
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIErrorLookup::GetHelpInfo(	HRESULT	hrError,DWORD dwLookupId, LCID lcid,
                                        	BSTR* ppwszHelpFile, DWORD*	pdwHelpContext	)
{
	HRESULT hr = S_OK;
    //=====================================================
	// Check the Arguments
    //=====================================================
	if ( !ppwszHelpFile || !pdwHelpContext )
	{
		hr = E_INVALIDARG;
	}
	else
	{

		//=====================================================
		// Initialize return values
		//=====================================================
		*ppwszHelpFile = NULL;
		*pdwHelpContext = 0;

		//=====================================================
 		// Check the Locale
		//=====================================================
		if ( lcid != GetSystemDefaultLCID() )
		{
			hr = DB_E_NOLOCALE;
		}
	}

    //=====================================================
	// We currently can't return any help file context or 
    // names. So, we will just return S_OK.
    //=====================================================
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Method to be called to release non static error messages.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIErrorLookup::ReleaseErrors( const DWORD	dwDynamicErrorID )
{
	HRESULT hr = S_OK;
    //=====================================================
	// Check the Arguments
    //=====================================================
	if ( dwDynamicErrorID == 0 )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		g_pCError->RemoveErrors(dwDynamicErrorID);
	}
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor for this class
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning (disable:4355)
CImpIWMIErrorInfo::CImpIWMIErrorInfo( PERRORSTUFF	pErrStuff )	
{

    //=====================================================
	//	Initialize simple member vars
    //=====================================================
	m_cRef = 0L;
	m_hObjCollection = ULONG(-1);
	
    //=====================================================
	// Store values
    //=====================================================
	m_pErrStuff = pErrStuff;

    //=====================================================
	// Since the memory is created and owned by WMIoledb, 
    // we need to make sure that this DLL is not unloaded,
    // else we will clean up the handed out pointer
    //=====================================================
	InterlockedIncrement(&g_cObj);
}
#pragma warning (default:4355)
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor for this class
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
CImpIWMIErrorInfo::~CImpIWMIErrorInfo (void)
{
    //=====================================================
	// For Abnormal Termination,Remove self from Collection
    //=====================================================
	g_pCError->RemoveFromCollection(m_hObjCollection);

    //=====================================================
	// If this object has been released, we can now 
    // decrement our object count
    //=====================================================
	InterlockedDecrement(&g_cObj);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to a specified interface. Callers use QueryInterface to determine which interfaces
// the called object supports. 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIWMIErrorInfo::QueryInterface(	REFIID riid, LPVOID * ppv)
{
	HRESULT hr = E_NOINTERFACE;

    if ( ppv == NULL ){
		hr = E_INVALIDARG;
    }
	else
    //=====================================================
    //	This is the non-delegating IUnknown implementation
    //=====================================================
	if ( (riid == IID_IUnknown) || (riid == IID_IErrorInfo) ){
		*ppv = (LPVOID)this;
	}
	else{
		*ppv = NULL;
	}

    //=====================================================
	//	If we're going to return an interface, AddRef first
    //=====================================================
	if (*ppv){
		((LPUNKNOWN)*ppv)->AddRef();
		hr = S_OK;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Increments a persistence count for the object
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpIWMIErrorInfo::AddRef(void)
{
	ULONG cRef = InterlockedIncrement( (long*) &m_cRef);
	return cRef;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrements a persistence count for the object and if persistence count is 0,object destroys itself.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpIWMIErrorInfo::Release (void)
{
	ULONG cRef = InterlockedDecrement( (long*) &m_cRef);
	if ( !cRef ){
		delete this;
		return 0;
	}
	return cRef;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Return the WMIstate associated with this custom error object. 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIWMIErrorInfo::GetWMIInfo(	BSTR*	pbstrMsg,	LONG*	plNativeError	)
{
	HRESULT hr = S_OK;
    //=====================================================
	// Check arguments
    //=====================================================
	if ( !pbstrMsg || !plNativeError)
	{
		hr = E_INVALIDARG;
	}
	else
	{

		//=====================================================
		// Initialize return values
		//=====================================================
		*pbstrMsg = Wmioledb_SysAllocString(NULL);
		*plNativeError = 0;

		//=====================================================
		// Handle WMIState
		//=====================================================
    
		if ( wcslen(m_pErrStuff->pwszMessage) > 0 )
		{
			//=================================================
			// If string is not NULL,then we can allocate it
			//=================================================
			*pbstrMsg = Wmioledb_SysAllocString(m_pErrStuff->pwszMessage);
			if ( *pbstrMsg == NULL )
			{
				hr = E_OUTOFMEMORY;
			}
		}

		//=====================================================
		// Handle Native Error Code.
		//=====================================================
		*plNativeError = m_pErrStuff->lNative;
	}

	return hr;
}	
///////////////////////////////////////////////////////////////////////////////////////////////////////
CError::CError(	)
{
    //=====================================================
	// Note that this is NOT a first-class object: it is 
    // NOT given away outside this DLL.  So we do not want
    // to alter global object count.
    //=====================================================

	// Clear variables
	m_pWMIErrorInfoCollection = NULL;
	m_prgErrorDex		= NULL;
	m_cErrorsUsed		= 0;
	m_dwId				= 0;
	m_ulNext			= 1;

    //=====================================================
	// Initialize ErrorInfo with constant information
    //=====================================================
	m_ErrorInfo.clsid = CLSID_WMIOLEDB;
	m_ErrorInfo.dispid = NULL;

	m_pcsErrors = new CCriticalSection(TRUE);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
CError::~CError()
{
	ULONG 				iElems; 
	ULONG 				cElems;
	ULONG				ul;
	PIMPIWMIERRORINFO	pIWMIErrorInfo;

	m_pcsErrors->Enter();

    //=====================================================
	// Release the general Object
    //=====================================================
    if ( m_pWMIErrorInfoCollection ){

		cElems = m_pWMIErrorInfoCollection->Size();

        //=================================================
		// Loop through stored object handles and release.
        //=================================================
		for(iElems=0; iElems<cElems; iElems++){

		    pIWMIErrorInfo = (PIMPIWMIERRORINFO )m_pWMIErrorInfoCollection->GetAt(iElems);
			if ( pIWMIErrorInfo != NULL )
			{
				delete pIWMIErrorInfo;
			}
		}
	
		delete m_pWMIErrorInfoCollection;
	}

    //=====================================================
	// Cleanup and error information hanging off the 
    // pointer array
    //=====================================================
	if ( m_prgErrorDex ){

		for(ul=0; ul<m_cErrors; ul++){

			if ( m_prgErrorDex[ul] ){

				delete[] m_prgErrorDex[ul];
				m_prgErrorDex[ul] = NULL;
			}
		}
		delete[] m_prgErrorDex;
	}
	m_pcsErrors->Leave();


    SAFE_DELETE_PTR(m_pcsErrors);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// If this initialization routine fails, it is the callers responsibility to delete this object.  
// The destructor will then clean up any allocated resources
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CError::FInit()
{
	HRESULT hr = S_OK;

	//=============================================================
	// Create array of pointers into the heap
	//=============================================================
	m_prgErrorDex = new PERRORSTUFF[INITIAL_SIZE_FOR_ERRORSTUFF];

	if ( NULL == m_prgErrorDex )
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		m_cErrors = INITIAL_SIZE_FOR_ERRORSTUFF;
		memset(m_prgErrorDex, 0, INITIAL_SIZE_FOR_ERRORSTUFF * sizeof(PERRORSTUFF));

		//=============================================================
		// Create WMI Error Object Collection
		//=============================================================
		m_pWMIErrorInfoCollection = new CFlexArray;

		if ( NULL == m_pWMIErrorInfoCollection )
		{
			hr = E_OUTOFMEMORY;
		}

	}
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Remove the Error Information for a particular DynamicId.  This could be one or more elements of the 
// ERRORSTUFF array and their associated pwszMessages on the Heap.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
void CError::RemoveErrors( DWORD	dwDynamicId )
{
	ULONG ul;

    //=============================================================
	// At the creation of the CAutoBlock object a critical section 
    // is entered. This is because the method manipulates shared 
    // structures access to which must be serialized . 
    // The criticalsection is left when this method terminate
    // and the destructor for CAutoBlock is called. 
    //=============================================================
	CAutoBlock Crit(m_pcsErrors);

	for(ul=0; ul<m_cErrors; ul++){

		if ( m_prgErrorDex[ul] && m_prgErrorDex[ul]->dwDynamicId == dwDynamicId ){

			delete[] m_prgErrorDex[ul];
			m_prgErrorDex[ul] = NULL;
			m_cErrorsUsed--;

            //=====================================================
			// For each error description that we cache, we have 
            // up'd the object count to make sure that we stay 
            // alive while there is a possibility the error
            //  collection could call back into us for this desc.  
            // Here is where we decrement that count upon
			// release of the error message.
            //=====================================================
			InterlockedDecrement(&g_cObj);
		}
   	}
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// Retrieve the WMI Server Error Message from the cache
//
////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CError::GetErrorDescription(ULONG ulDex, BSTR* ppwszDescription	)
{

    HRESULT hr = S_OK;

    //======================================================
    //  Enter critical section
    //======================================================
	CAutoBlock Crit(m_pcsErrors);

    //======================================================
    //  
    //======================================================
	if (ulDex < m_cErrors && m_prgErrorDex[ulDex]){

		PERRORSTUFF pErrorStuff = m_prgErrorDex[ulDex];
		if (wcslen(pErrorStuff->pwszMessage) > 0 ){

            //======================================================
			// return the message from WMI 
            //======================================================
			*ppwszDescription = Wmioledb_SysAllocString(pErrorStuff->pwszMessage);
            if (*ppwszDescription == NULL){
				hr = E_OUTOFMEMORY;
            }
		}
		else{

            //======================================================
			// return the standard error
            //======================================================
			WCHAR rgwchBuff[MAX_PATH+1];
			WCHAR *pwsz = rgwchBuff;
			int cwch = LoadStringW(g_hInstance, pErrorStuff->uStringId, rgwchBuff, NUMELEM(rgwchBuff));			
			*ppwszDescription = Wmioledb_SysAllocString(pwsz);
            if (*ppwszDescription == NULL){
				hr = E_OUTOFMEMORY;
            }
		}
	}
	else{
		*ppwszDescription = NULL;
		hr = DB_E_BADLOOKUPID;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Retrieve the IErrorInfo and IErrorRecords pointers whether from automation or from creating a new 
// instance
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CError::GetErrorInterfaces(	IErrorInfo**	ppIErrorInfo, IErrorRecords**	ppIErrorRecords	)
{
	HRESULT	hr = S_OK;

	*ppIErrorInfo = NULL;
	*ppIErrorRecords = NULL;
    //=============================================================
	//Obtain the error object or create a new one if none exists
    //=============================================================
	// NTRaid:111806
	// 06/07/00
	hr = GetErrorInfo(0, ppIErrorInfo);
	if (SUCCEEDED(hr) && !*ppIErrorInfo){

		hr = g_pErrClassFact->CreateInstance(NULL, IID_IErrorInfo, (LPVOID*)ppIErrorInfo);
	}
	
	if(SUCCEEDED(hr))
	{
		//=============================================================
		// Obtain the IErrorRecord Interface
		//=============================================================
		hr = (*ppIErrorInfo)->QueryInterface(IID_IErrorRecords, (LPVOID*)ppIErrorRecords);

		//=============================================================
		// On a failure retrieving IErrorRecords, we need to release
		// the IErrorInfo interface
		//=============================================================
		if ( FAILED(hr) ){
			(*ppIErrorInfo)->Release();
			*ppIErrorInfo = NULL;
		}
	}
		
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Determine the next free index of the PERRORSTUFF array. 
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CError::FindFreeDex( ULONG*	ulDex	)
{
	PERRORSTUFF*	pNew	= NULL;
	HRESULT			hr		= S_OK;

    //===========================================================================
	// Check if we need to expand the buffer
    // Since we do not use element 0, we need to reallocate when at m_cErrors - 1
    //===========================================================================
	if ( m_cErrorsUsed == (m_cErrors - 1))
	{
		try
		{
			pNew = new PERRORSTUFF[m_cErrors + INCREMENT_BY_FOR_ERRORSTUFF];
		}
		catch(...)
		{
			SAFE_DELETE_PTR(pNew);
			throw;
		}
		if ( pNew )	
		{

    	    //===================================================================
            // Copy old pointers to new array
    	    //===================================================================
			memcpy(pNew, m_prgErrorDex, m_cErrors * sizeof(PERRORSTUFF));
			memset((pNew + m_cErrors), 0, INCREMENT_BY_FOR_ERRORSTUFF * sizeof(PERRORSTUFF));

    	    //===================================================================
			// Set the new array size
    	    //===================================================================
			m_ulNext = m_cErrors; 
			m_cErrors += INCREMENT_BY_FOR_ERRORSTUFF;
			delete[] m_prgErrorDex;
			m_prgErrorDex = pNew;		
		}
    	else
		{
			*ulDex = 0;
			hr = E_OUTOFMEMORY;
		}
	}
	
	if(SUCCEEDED(hr))
	{
		//===========================================================================
		// Loop through looking for unused index
		//===========================================================================
		while( 1 ){

			//=======================================================================
			// If we are at the top of our buffer rap back to the begining
			//=======================================================================
			if (m_ulNext == m_cErrors)
			{
				m_ulNext = 1;
			}
			else if (NULL == m_prgErrorDex[m_ulNext])
			{
				m_cErrorsUsed++;
				*ulDex = m_ulNext++;
				break;
			}
			else
			{
				m_ulNext++;
			}
		}
	}
	
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Creates error records for the WMI errors encountered. The WMIState and Native error code are 
// stored in a custom interface, where as the description is returned by the standard IErrorInfo 
// interface.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CError::PostWMIErrors( HRESULT hrErr, const IID* piid, CErrorData* pErrData	)
{

	HRESULT				hr = S_OK;
	IErrorInfo*			pIErrorInfo = NULL;
	IErrorRecords*		pIErrorRecords = NULL;
	PIMPIWMIERRORINFO	pWMIError = NULL;
	ULONG				iElems;
	ULONG				cElems;
	PERRORSTUFF			pErrStuff;
	DWORD				dwDex;

    //===========================================================================
    //  Enter critical section
    //===========================================================================
	CAutoBlock Crit(m_pcsErrors);

    //===========================================================================
	// We cannot Init the Datasource object without this pointer being set, so it
    // should exist at this point
	// Get the # errors 
    //===========================================================================
	cElems = pErrData->Size();
	if (0 == cElems){
		if (FAILED(hrErr))
			g_pCError->PostHResult(hrErr, piid);
		hr = S_OK;
	}
    else{

        //=======================================================================
        // Obtain the error object or create a new one if none exists
        //=======================================================================
        if ( SUCCEEDED(hr = GetErrorInterfaces(&pIErrorInfo, &pIErrorRecords)) ){

            //===================================================================
	        // Assign static information across each error record added
            //===================================================================
	        m_ErrorInfo.hrError = hrErr;
	        m_ErrorInfo.iid = *piid;
	        m_ErrorInfo.dispid = NULL;

            //===================================================================
	        // Increment Dynamic Id;
            //===================================================================
	        m_dwId++;

            //===================================================================
	        // Loop through an array of indexes into the error array
            //===================================================================
	        for (iElems=0; iElems<cElems; iElems++){

                //===============================================================
		        // Get the error stuff
	            //===============================================================
    	        pErrData->SetAt(iElems,(void**)&pErrStuff);

	            //===============================================================
    	        // Save the dynamic id
	            //===============================================================
    	        pErrStuff->dwDynamicId = m_dwId;

	            //===============================================================
    	        // Save WMI Server error code
	            //===============================================================
    	        m_ErrorInfo.dwMinor = DWORD(pErrStuff->lNative);

	            //===============================================================
    	        // Determine index to store heap pointer
	            //===============================================================
                if ( SUCCEEDED(hr = FindFreeDex(&dwDex)) ){

					try
					{
						//===========================================================
    					// Create the custom  error object
						//===========================================================
						pWMIError = new CImpIWMIErrorInfo(pErrStuff);
					}
					catch(...)
					{
						SAFE_DELETE_PTR(pWMIError);
						throw;
					}
		            if ( pWMIError == NULL ){
			            hr = E_OUTOFMEMORY;
                    }
                    else{
    		            pWMIError->AddRef();	
                        if ( SUCCEEDED(hr = pWMIError->FInit()) ){

                            //===================================================
		                    // Add the record to the Error Service Object
                            //===================================================
		                    hr = pIErrorRecords->AddErrorRecord(&m_ErrorInfo, dwDex, NULL,(IUnknown*) pWMIError, m_dwId);
                            if ( SUCCEEDED(hr) ){

                                //===============================================
    		                    // Release the custom Error Object
                                //===============================================
	    	                    pWMIError->Release();
		                        pWMIError = NULL;

                                //===============================================
		                        // Save the pointer to the error stuff
                                //===============================================
		                        m_prgErrorDex[dwDex] = pErrStuff;

                                //===============================================
		                        // For each error description that we cache, we 
                                // have up'd the the object count to make sure 
                                // that we stay alive while there is a 
                                // possibility the errorcollection could call back 
                                // into us for this description.  Here is where we 
                                // increment that count.
                                //===============================================
		                        InterlockedIncrement(&g_cObj);
                            }
                        }
		            }
                }
	        
                //================================================================
	            // Pass the error object to the Ole Automation DLL
                //================================================================
	            hr = SetErrorInfo(0, pIErrorInfo);
            }
        }
    }

    //============================================================================
	// Release the interfaces to transfer ownership to the Ole Automation DLL
    //============================================================================
	SAFE_RELEASE_PTR(pWMIError);
	SAFE_RELEASE_PTR(pIErrorRecords);
	SAFE_RELEASE_PTR(pIErrorInfo);

    //============================================================================
	// Free the error data
    //============================================================================
	pErrData->FreeErrors();
	
    return hr;		
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This method is used to post an HRESULT that is to be looked up in the resource fork of the error collection
// object.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CError::PostHResult( HRESULT hrErr,	const IID*	piid )
{
	HRESULT				hr = S_OK;
	IErrorInfo*			pIErrorInfo = NULL;
	IErrorRecords*		pIErrorRecords = NULL;


    //==================================================================
    //  Enter critical section
    //==================================================================
	CAutoBlock Crit(m_pcsErrors);

	//==================================================================
	// Obtain the error object or create a new one if none exists
    //==================================================================
	if ( SUCCEEDED(hr = GetErrorInterfaces(&pIErrorInfo, &pIErrorRecords)) )
	{
		//==================================================================
		// Assign static information across each error record added
		//==================================================================
		m_ErrorInfo.hrError = hrErr;
		m_ErrorInfo.iid = *piid;
		m_ErrorInfo.dispid = NULL;
		m_ErrorInfo.dwMinor = 0;

		//==================================================================
		// Add the record to the Error Service Object
		//==================================================================
		hr = pIErrorRecords->AddErrorRecord(&m_ErrorInfo,IDENTIFIER_SDK_ERROR,NULL,(IUnknown*)NULL,0);
		if ( SUCCEEDED(hr) )
		{
			//==================================================================
			// Pass the error object to the Ole Automation DLL
			//==================================================================
			hr = SetErrorInfo(0, pIErrorInfo);
		}
	}

    //==================================================================
	// Release the interfaces to transfer ownership to the Ole Automation DLL
    //==================================================================
	SAFE_RELEASE_PTR(pIErrorRecords);
	SAFE_RELEASE_PTR(pIErrorInfo);

    return hrErr;		
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This method is used to post static strings to the error objects.  The static strings are stored in the 
// resource fork, and thus an id needs to  be specified. 
//
// @devnote If the error object is not our implementation of IID_IErrorInfo, we will not be able to load 
// IErrorRecord and add our records.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CError::PostError(	HRESULT hrErr, const IID*	piid, DWORD dwIds, DISPPARAMS* pdispparams )
{
	HRESULT				hr = S_OK;
	IErrorInfo*			pIErrorInfo = NULL;
	IErrorRecords*		pIErrorRecords = NULL;

    //====================================================================
    //  Enter critical section
    //====================================================================
	CAutoBlock Crit(m_pcsErrors);

    //====================================================================
	// Obtain the error object or create a new one if none exists
    //====================================================================
	if ( SUCCEEDED(hr = GetErrorInterfaces(&pIErrorInfo, &pIErrorRecords)) )
	{
		//====================================================================
		// Assign static information across each error record added
		//====================================================================
		m_ErrorInfo.hrError = hrErr;
		m_ErrorInfo.iid = *piid;
		m_ErrorInfo.dispid = NULL;
		m_ErrorInfo.dwMinor = 0;

		//====================================================================
		// Add the record to the Error Service Object
		//====================================================================
		hr = pIErrorRecords->AddErrorRecord(&m_ErrorInfo, (dwIds | ERR_STATIC_STRING), 	pdispparams, NULL, 0);
		if ( SUCCEEDED(hr) )
		{
			//====================================================================
			// Pass the error object to the Ole Automation DLL
			//====================================================================
			hr = SetErrorInfo(0, pIErrorInfo);
		}

	}
    //====================================================================
	// Release the interfaces to transfer ownership to the Ole Automation DLL
    //====================================================================
	SAFE_RELEASE_PTR(pIErrorRecords);
	SAFE_RELEASE_PTR(pIErrorInfo);

	return hr;		
}
////////////////////////////////////////////////////////////////////////////////////////////////
//
// This method is used to post static strings to the error objects.  
//
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CError::PostErrorMessage( HRESULT	hrErr,	const IID*	piid, UINT	uStringId,	LPCWSTR pwszMessage	)		
{

	PERRORSTUFF			pErrStuff = NULL;
	ULONG				cwch = wcslen(pwszMessage);
	HRESULT				hr = S_OK;
	IErrorInfo*			pIErrorInfo = NULL;
	IErrorRecords*		pIErrorRecords = NULL;
	PIMPIWMIERRORINFO	pWMIError = NULL;
	DWORD				dwDex;

	//==========================================================
	// CS because the method manipulates shared structures 
    // access to which must be serialized . 
	//==========================================================
	CAutoBlock Crit(m_pcsErrors);
	
	try
	{
		pErrStuff = (PERRORSTUFF) new BYTE[sizeof(ERRORSTUFF)+(cwch+2)*sizeof(WCHAR)];
	}
	catch(...)
	{
		SAFE_DELETE_ARRAY(pErrStuff);
		throw;
	}
	if (!pErrStuff)	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		//==========================================================
		// Initialize error stuff
		//==========================================================
		pErrStuff->dwDynamicId = 0;
		pErrStuff->uStringId = uStringId;
		pErrStuff->hr = S_OK;
		pErrStuff->lNative = 0;
		pErrStuff->wLineNumber = 0;

		AllocateAndCopy(pErrStuff->pwszMessage, (unsigned short*)pwszMessage);
		//==========================================================
		// We cannot Init the Datasource object without this pointer
		// being set, so it should exist at this point
		// Obtain the error object or create new one if none exists
		//==========================================================
		if ( SUCCEEDED(hr = GetErrorInterfaces(&pIErrorInfo, &pIErrorRecords)) )
		{
   			//==========================================================
			// Assign static information across each error record added
			//==========================================================
			m_ErrorInfo.hrError = hrErr;
			m_ErrorInfo.iid = *piid;
			m_ErrorInfo.dispid = NULL;
			m_ErrorInfo.dwMinor = 0;

			//==========================================================
			// Increment Dynamic Id and save it
			//==========================================================
			pErrStuff->dwDynamicId = ++m_dwId;

			//==========================================================
			// Determine index to store heap pointer
			//==========================================================
			if ( SUCCEEDED(hr = FindFreeDex(&dwDex)) )
			{
				try
				{
					//==========================================================
					// Create the custom  error object
					//==========================================================
					pWMIError = new CImpIWMIErrorInfo(pErrStuff);
				}
				catch(...)
				{
					SAFE_DELETE_ARRAY(pErrStuff);
					SAFE_DELETE_PTR(pErrStuff);
					throw;
				}

				if ( pWMIError == NULL ){
					hr = E_OUTOFMEMORY;
				}
				else
				{
					//==========================================================
					// Give the object existence
					//==========================================================
					pWMIError->AddRef();	
					if ( SUCCEEDED(hr = pWMIError->FInit()) )
					{
						//==========================================================
						// Add the record to the Error Service Object
						//==========================================================
						if(SUCCEEDED(hr = pIErrorRecords->AddErrorRecord(&m_ErrorInfo, dwDex, NULL,	(IUnknown*)pWMIError, m_dwId)))
						{
							//==========================================================
							// Release the custom Error Object
							//==========================================================
							pWMIError->Release();
							pWMIError = NULL;


   							//==========================================================
							// Save the pointer to the error stuff
							//==========================================================
							m_prgErrorDex[dwDex] = pErrStuff;

							//==========================================================
							// For each error description that we cache, we have up'd the 
							// the object count to make sure that we stay alive while there is
							// a possibility the errorcollection could call back into us for 
							// this description.  Here is where we increment that count.
							//==========================================================
							InterlockedIncrement(&g_cObj);
							
							//==========================================================
							// Pass the error object to the Ole Automation DLL
							//==========================================================
							hr = SetErrorInfo(0, pIErrorInfo);
						
						} // if Succeeded(AddErrorRecord(())
					
					}	// if (succeeded(pWMIError->FInit))
				
				}	// if allocation of pWMIError is successful
			
			}	// if(succeeded(FindFreeDex))
		
		}	// if succeeded(GetErrorInterfaces)

	}	// if propert allocation
	//==========================================================
	// Release the interfaces to transfer ownership to
	//==========================================================
	SAFE_DELETE_ARRAY(pErrStuff);
	SAFE_DELETE_PTR(pErrStuff);
	SAFE_RELEASE_PTR(pWMIError);
	SAFE_RELEASE_PTR(pIErrorRecords);
	SAFE_RELEASE_PTR(pIErrorInfo);

	return hr;		
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Frees error information and empties the array
//        
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CError::FreeErrors()
{
	ULONG		iElems;
	ULONG		cElems;
	BYTE*		pb;

	cElems = Size();

	for (iElems=0; iElems<cElems; iElems++){

        pb = (BYTE*) m_pWMIErrorInfoCollection->GetAt(iElems);
        if (pb){
			delete[] pb;
        }
	}
	m_pWMIErrorInfoCollection->Empty();
}
//**********************************************************************************************************
//
//**********************************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////////////////
CErrorData::CErrorData()
{
    //
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
CErrorData::~CErrorData()
{
   FreeErrors();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CErrorData::FreeErrors()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\extbuff.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Class Definitions for CExtBuffer Class
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _EXTBUFF_H_
#define _EXTBUFF_H_

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Forward Declaration
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FAR CExtBuffer;
typedef CExtBuffer FAR *LPEXTBUFFER;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Allocates and manages fixed sized block memory routines
// 
// ext or pext
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FAR CExtBuffer
{			
	private: 
		
		ULONG    m_cbItem;						// Current count of items
		ULONG    m_cItem;						// Item size, in bytes
		ULONG    m_cbReserved;					// Reserved byte count
		ULONG    m_cbAlloc;						// Allocated byte count
		ULONG    m_dbAlloc;						// increment value
		BYTE     *m_rgItem;						// Ptr to beginning of buffer
		

	private:
		
		CExtBuffer( const CExtBuffer & p);		// Not implemented; private so dcl prevents generation.
		CExtBuffer& operator=(const CExtBuffer & p);

	public:	
		CExtBuffer ( void );
		~CExtBuffer ( void );
		
		void * operator[] (ULONG nIndex);		// Calculated data pointer from index value

		STDMETHODIMP 	FInit (ULONG cItemMax, ULONG cbItem, ULONG cbPage);		// Initialize the fixed size buffer
		STDMETHODIMP 	InsertIntoExtBuffer (VOID* pvItem, ULONG &hItem);		// Add new items to the buffer
		STDMETHODIMP    GetItemOfExtBuffer (HACCESSOR hItem,	VOID* pvItem);		// Retrieve items from buffer
		STDMETHODIMP    GetFirstLastItemH (HACCESSOR &hItemFirst, HACCESSOR &hItemLast);// Get usage extent indexes
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\extbuff.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// This class provides an array-based access to a big block of memory. You pass in the fixed size of each element
// to the constructor. 
// Get (read)  an element with GetItemOfExtBuffer.
// Set (write) an element with InsertIntoExtBuffer.
// You must also pass in the system page size (found with GetSystemInfo). 'hItem' is the index into the array, 
// beginning with 1. The array always contains m_cItem elements.
//
// GetItemOfExtBuffer returns element hItem, where hItem=1 is the first element.
// (Copies block to caller's memory.)
//
// InsertIntoExtBuffer always appends elements to the tail of the array,
// and returns the index of the newly appended element.
// (So adding first element will return 1.)
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "extbuff.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor for this class
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CExtBuffer::CExtBuffer ( void )
{
    m_cItem   = 0;
    m_cbAlloc = 0;
    m_rgItem  = NULL;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor for this class
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CExtBuffer:: ~CExtBuffer ( void  )
{
    if (m_cbAlloc){
        VirtualFree((VOID *) m_rgItem, m_cbAlloc, MEM_DECOMMIT );
	}

    if (m_rgItem){
        VirtualFree((VOID *) m_rgItem, 0, MEM_RELEASE );
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Allocate and Initialize Buffer
//
// HRESULT indicating routines status
//      S_OK			Initialization succeeded
//      E_OUTOFMEMORY	Not enough memory to allocate buffer
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtBuffer::FInit (   ULONG cItemMax,     // IN  Maximum number of items ever
								   ULONG cbItem,       // IN  Size of each item, in bytes
								   ULONG cbPage )      // IN  Size of system page size (from SysInfo)
{
    BYTE  *pb=NULL;
	HRESULT hr = S_OK;

    m_cbReserved = ((cbItem *cItemMax) / cbPage + 1) *cbPage;
    m_rgItem = (BYTE *) VirtualAlloc( NULL, m_cbReserved, MEM_RESERVE, PAGE_READWRITE );

    if (m_rgItem == NULL){
        hr = E_OUTOFMEMORY;
	}
	else{

		m_cbItem  = cbItem;
		m_dbAlloc = (cbItem / cbPage + 1) *cbPage;
		pb = (BYTE *) VirtualAlloc( m_rgItem, m_dbAlloc, MEM_COMMIT, PAGE_READWRITE );
		if (pb == NULL){
			VirtualFree((VOID *) m_rgItem, 0, MEM_RELEASE );
			m_rgItem = NULL;
			hr = E_OUTOFMEMORY;
		}
		else{
			m_cbAlloc = m_dbAlloc;
		}
	}

    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Retrieves a pointer to the value at given index
//
// If index is within the range of 1 to m_cItems then a valid pointer is returned, else NULL is returned.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void* CExtBuffer::operator[] ( ULONG hItem )          // IN Index of element in buffer
{
	//====================================================================
    // Return ptr to element [n], where n = 1...m_cItem.
	// Returns NULL if 'n' is out of range.
    //
    // You must use InsertIntoExtBuffer to add new elements.
    // Thereafter you can use this operator to retrieve the address of the item.
    // (You can't delete an element, but you can overwrite its space.)
	//====================================================================

    if (1 <= hItem && hItem <= m_cItem)
        return m_rgItem + (hItem - 1) *m_cbItem;
    else
        return NULL;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Add Data to the fixed buffers and return the index it was added at.
//
//  HRESULT indicating routines status
//        S_OK				Data copied successfully
//        E_OUTOFMEMORY		Not enough memory to allocate buffer
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtBuffer::InsertIntoExtBuffer (	VOID* pvItem,       // IN  Pointer to buffer to copy
												ULONG &hItem )      // OUT Index of where data was placed
{
	HRESULT hr = S_OK;
    ULONG cbOffset;

    cbOffset = m_cItem*m_cbItem;
    if ((cbOffset + m_cbItem) > m_cbAlloc){

        BYTE *pb;

        if ((m_cbAlloc + m_dbAlloc) > m_cbReserved){
            pb = NULL;
		}
        else{
            pb = (BYTE *) VirtualAlloc( m_rgItem + m_cbAlloc, m_dbAlloc, MEM_COMMIT, PAGE_READWRITE );
		}
        if (pb == NULL){
            hr = E_OUTOFMEMORY;
        }
		else{
			m_cbAlloc += m_dbAlloc;
        }
	}

	if( S_OK == hr ){
		memcpy((m_rgItem + cbOffset), (BYTE *) pvItem, m_cbItem );
		m_cItem++;
		hItem = m_cItem;
	}

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Obtain a pointer to the data at a given index into the buffer
//
//  HRESULT indicating routines status
//        S_OK | pvItem contains a pointer to the data requested
//        E_INVALIDARG | Invalid Index passed in
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CExtBuffer::GetItemOfExtBuffer( HACCESSOR hItem,        // IN		Index of item to get
											 VOID* pvItem   )    // OUT		Pointer to block at index
{
	HRESULT hr = S_OK;

    if ((hItem > m_cItem) || (hItem == 0) ){
        hr = E_INVALIDARG;
	}
	else{
		memcpy((BYTE *) pvItem, (m_rgItem + (hItem - 1) *m_cbItem), m_cbItem );
	}

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Get the extents of the currently allocated buffers
//
//  HRESULT indicating routines status
//        S_OK  Extents were obtained successfuly
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtBuffer::GetFirstLastItemH( HACCESSOR &hItemFirst,      // OUT  First item allocated
											HACCESSOR &hItemLast       )// OUT  Last item allocated
{
    hItemFirst = 1;
    hItemLast  = m_cItem;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\enumerat.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Enumeration Routines
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "command.h"
#include "schema.h"
#include "enumerat.h"

#define NAMESPACE_SEPARATOR L"\\"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// The module contains the DLL Entry and Exit points, plus the OLE ClassFactory class for RootBinder object.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//#define DECLARE_GLOBALS
//===============================================================================
//  Don't include everything from windows.h, but always bring in OLE 2 support
//===============================================================================
//#define WIN32_LEAN_AND_MEAN
#define INC_OLE2

//===============================================================================
//  Make sure constants get initialized
//===============================================================================
#define INITGUID
#define DBINITCONSTANTS

//===============================================================================
// Basic Windows and OLE everything
//===============================================================================
#include <windows.h>


//===============================================================================
//  OLE DB headers
//===============================================================================
#include "oledb.h"
#include "oledberr.h"

//===============================================================================
//	Data conversion library header
//===============================================================================
#include "msdadc.h"

//===============================================================================
// Guids for data conversion library
//===============================================================================
#include "msdaguid.h"


//===============================================================================
//  GUIDs
//===============================================================================
#include "guids.h"

//===============================================================================
//  Common project stuff
//===============================================================================

#include "headers.h"
#include "binderclassfac.h"

//===============================================================================
//  Globals
//===============================================================================
extern LONG g_cObj;						// # of outstanding objects
extern LONG g_cLock;						// # of explicit locks set
extern DWORD g_cAttachedProcesses;			// # of attached processes
extern DWORD g_dwPageSize;					// System page size

///////////////////////////////////////////////////////////////////////////////////////////////////////
static const GUID* x_rgEnumeratorErrInt[] = 
	{
	&IID_IParseDisplayName,
	&IID_ISourcesRowset,
	};
static const ULONG x_cEnumeratorErrInt	= NUMELEM(x_rgEnumeratorErrInt);
///////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning (disable:4355)

CEnumeratorNameSpace :: CEnumeratorNameSpace(LPUNKNOWN	pUnkOuter):	CBaseObj(BOT_ENUMERATOR,pUnkOuter),
                                                                    m_ISourcesRowset(this),
		                                                            m_IParseDisplayName(this)
		                                                            
{
	m_dwStatus = 0;
	m_pCDataSource = NULL;
	m_pCDBSession = NULL;
    m_pISupportErrorInfo = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning (default:4355)
CEnumeratorNameSpace :: ~CEnumeratorNameSpace (void)
{
	//==============================
    // Release the session
	//==============================
    SAFE_RELEASE_PTR(m_pCDBSession);

	//==============================
	// Release the data source
	//==============================
	SAFE_RELEASE_PTR(m_pCDataSource);

}
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CEnumeratorNameSpace::CreateDataSource()
{

	HRESULT hr = E_FAIL;
	IDBInitialize *	pInitialize		= NULL;
	IDBProperties *	pDBProperties	= NULL;

	DBPROPSET	rgPropertySets[1];
	DBPROPIDSET rgPropIDSet[1];

	DBPROP		rgprop[1];
	VARIANT		varValue;

	ULONG		cPropSets = 1;
	CDataSource	*pDataSource = NULL;

	memset(&rgprop[0],0,sizeof(DBPROP));
	memset(&rgPropertySets[0],0,sizeof(DBPROPSET));

	VariantInit(&varValue);

	try
	{
		//========================================================
		// Allocate a new datasource object
		//========================================================
		pDataSource = new CDataSource( NULL );
	}
	catch(...)
	{
		SAFE_RELEASE_PTR(pDataSource);
		throw;
	}

    if( !pDataSource ){
        hr = E_OUTOFMEMORY;
    }
	else
	{
   		hr = pDataSource->QueryInterface(IID_IUnknown,(void **)&m_pCDataSource);

		//========================================================
		//  Initialize the data source
		//========================================================
		if(SUCCEEDED(hr = ((CDataSource*)m_pCDataSource)->FInit())){

			if(!(FAILED(hr = m_pCDataSource->QueryInterface(IID_IDBProperties ,(void **)&pDBProperties))))
			{
				rgPropIDSet[0].cPropertyIDs		= 0;
				rgPropIDSet[0].guidPropertySet	= DBPROPSET_DBINIT;

				//================================================================================
				// Get the properties set before....
				//================================================================================
	//			hr = m_pUtilProp->GetProperties(0,0,rgPropIDSet, &cPropSets,&prgPropertySets);

	//			hr = pDBProperties->SetProperties(cPropSets,prgPropertySets);
	//			if(FAILED(hr)){
	//				return hr;
	//			}

				//================================================================================
				// Always use the root namespace, & set the DBPROP_INIT_DATASOURCE property
				//================================================================================
				CVARIANT v(ROOT_NAMESPACE);
				rgprop[0].dwPropertyID   = DBPROP_INIT_DATASOURCE;
				rgprop[0].vValue.vt		 = VT_BSTR;
				rgprop[0].vValue.bstrVal = v;

				rgPropertySets[0].rgProperties		= &rgprop[0];
				rgPropertySets[0].cProperties		= 1;
				rgPropertySets[0].guidPropertySet	= DBPROPSET_DBINIT;

				if(SUCCEEDED(hr = pDBProperties->SetProperties(1,rgPropertySets)))
				{																	
					//================================================================================
					// Get the pointer to IDBInitialize interface
					//================================================================================
					if(SUCCEEDED(hr = m_pCDataSource->QueryInterface(IID_IDBInitialize, (void **)&pInitialize)))
					{
						//============================================================================
						// Initialize the Datasource object
						//============================================================================
						hr = pInitialize->Initialize();
					}                

//					SAFE_RELEASE_PTR(m_pCDataSource);
				
				} // succeeded of SetProperties
			
			} // succeeeded of QI
		
		} // if(((CDataSource*)m_pCDataSource)-FInit()>)

	}  // Else for if( !m_pCDataSource )

	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Initializes enumerator object. Instantiate interface implementation objects.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEnumeratorNameSpace::Initialize(void)
{
	const IID*	piid = &IID_ISourcesRowset;
	HRESULT		hr = S_OK;

	if (!(m_dwStatus & ENK_DIDINIT)){
        //=========================================================
		// Allocate and initialize a DataSource object
        //=========================================================
        if( SUCCEEDED(hr == CreateDataSource()) ){

            //=====================================================
	    	// Allocate and initialize a Session object
            //=====================================================
        	IDBCreateSession *pDBCreateSession = NULL;

			m_pISupportErrorInfo = new CImpISupportErrorInfo(this);
	        assert(m_pCDataSource != NULL);
			// NTRaid:136454
			// 07/05/00
			if(m_pISupportErrorInfo)
			{
        		hr = m_pCDataSource->QueryInterface(IID_IDBCreateSession,(void **)&pDBCreateSession);
				if( S_OK == hr ){ 
					//===============================================
					// Create session
					//===============================================
					hr = pDBCreateSession->CreateSession(m_pUnkOuter,IID_IUnknown,&m_pCDBSession);
					if( hr == S_OK ){
    					m_dwStatus |= ENK_DIDINIT;
						m_pCDBSession->AddRef();
					}
				}
				if(pDBCreateSession){
					pDBCreateSession->Release();
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;	
			}
	    }
		if(SUCCEEDED(hr))
		{
			hr = AddInterfacesForISupportErrorInfo();
		}
	}

	if(hr != S_OK ){
		g_pCError->PostWMIErrors(hr, piid,GetDataSource()->GetErrorDataPtr());
        SAFE_RELEASE_PTR(m_pCDataSource);
        SAFE_RELEASE_PTR(m_pCDBSession);
	}
	else{
		g_pCError->PostHResult(hr, piid);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to add interfaces to ISupportErrorInfo interface
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CEnumeratorNameSpace::AddInterfacesForISupportErrorInfo()
{
	HRESULT hr = S_OK;

	if(SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_ISourcesRowset)))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IParseDisplayName);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEnumeratorNameSpace::AddRef(void)
{
	return InterlockedIncrement( (long*) &m_cRef);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEnumeratorNameSpace::Release(void)
{
	ULONG cRef = InterlockedDecrement( (long*) &m_cRef);
	if ( !cRef )
		delete this;
	return cRef;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEnumeratorNameSpace::QueryInterface( REFIID riid,	LPVOID *ppv	)
{
	HRESULT hr = S_OK;
    //===========================================
	// Is the pointer bad?
    //===========================================
	if ( ppv == NULL ) 
	{
		hr = E_INVALIDARG;
	}
	{

		//===========================================
		//	This is the non-delegating IUnknown 
		//  implementation
		//===========================================
		if ( riid == IID_IUnknown )
			*ppv = (LPVOID)this;
		else if ( riid == IID_ISourcesRowset )
			*ppv = (LPVOID)&m_ISourcesRowset;
		else if ( riid == IID_IParseDisplayName )
			*ppv = (LPVOID)&m_IParseDisplayName;
		else if ( riid == IID_ISupportErrorInfo )
			*ppv = (LPVOID)m_pISupportErrorInfo;
		else
			//=======================================
    		//	Place NULL in *ppv in case of failure
			//=======================================
			*ppv = NULL;

		if ( *ppv ){
			((LPUNKNOWN)*ppv)->AddRef();
			hr = S_OK;
		}
		else
		{
			hr = E_NOINTERFACE;
		}
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpISourcesRowset::AddRef(void)
{
    InterlockedIncrement((long*)&m_cRef);
	return m_pCEnumeratorNameSpace->AddRef();
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpISourcesRowset::Release(void)
{
    InterlockedDecrement((long*)&m_cRef);
	return m_pCEnumeratorNameSpace->Release();
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpISourcesRowset::QueryInterface( REFIID	riid, LPVOID *	ppv	)	
{
	return m_pCEnumeratorNameSpace->QueryInterface(riid, ppv);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Instantiate a rowset with a list of data sources.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpISourcesRowset::GetSourcesRowset( IUnknown* pUnkOuter,	REFIID	riid, ULONG cPropertySets,DBPROPSET rgPropertySets[], IUnknown** ppIRowset	)
{
	HRESULT	hr = E_INVALIDARG;
	CSchema_ISourcesRowset	*pCSchema = NULL;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //=====================================================================
    //  Check parameters
    //=====================================================================
    assert( m_pCEnumeratorNameSpace );

    //=====================================================================
    // NULL out-params in case of error
    //=====================================================================

    //===============================================================
	// Clear previous Error Object for this thread
    //===============================================================
	g_pCError->ClearErrorInfo();

	if(ppIRowset)
	{
		*ppIRowset = NULL;
	}
    //=====================================================================
    // Check Arguments
    //=====================================================================
    if ( riid == IID_NULL){
        hr = E_NOINTERFACE ;
    }
	else
    if ( (pUnkOuter) && (riid != IID_IUnknown) ){   	    // We do not allow the riid to be anything other than IID_IUnknown for aggregation
		hr = DB_E_NOAGGREGATION ;
    }
	else
	{
		//===============================================================
		// Serialize access to this object.
		//===============================================================
		CAutoBlock block(m_pCEnumeratorNameSpace->GetCriticalSection());


		//===============================================================
		// Spec-defined error checks.
		//===============================================================
		if (!ppIRowset || (cPropertySets && !rgPropertySets)){
			hr = E_INVALIDARG ; 
		}
		else{
			//===========================================================
			// The outer object must explicitly ask for IUnknown
			//===========================================================
			if (pUnkOuter != NULL && riid != IID_IUnknown){
				hr = DB_E_NOAGGREGATION;
			}
			else{
				if (SUCCEEDED(hr = m_pCEnumeratorNameSpace->Initialize())){
	
					try
					{
       					pCSchema =	new CSchema_ISourcesRowset(pUnkOuter,m_pCEnumeratorNameSpace->GetSession());
					}
					catch(...)
					{
						SAFE_DELETE_PTR(pCSchema);
						throw;
					}

					if (!pCSchema){
						hr = E_OUTOFMEMORY;
					}
					else{
						hr = pCSchema->FInit(cPropertySets, rgPropertySets, riid, pUnkOuter, ppIRowset,NULL);
					}
				}
			}
		}

		if( FAILED(hr ) ){
			SAFE_RELEASE_PTR( pCSchema );
			*ppIRowset = NULL;
		}
	
	} // else

	hr = hr != S_OK ? g_pCError->PostHResult(hr,&IID_ISourcesRowset): hr;

	CATCH_BLOCK_HRESULT(hr,L"ISourcesRowset::GetSourcesRowset");
    return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//       CImpIParseDisplayName 
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpIParseDisplayName::AddRef(void)
{

    InterlockedIncrement((long*)&m_cRef);
	return m_pCEnumeratorNameSpace->AddRef();
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpIParseDisplayName::Release(void)
{
    InterlockedDecrement((long*)&m_cRef);
	return m_pCEnumeratorNameSpace->Release();
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIParseDisplayName::QueryInterface(	REFIID riid, LPVOID * ppv )	
{
	return m_pCEnumeratorNameSpace->QueryInterface(riid, ppv);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function creates moniker according to the name passed to it.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIParseDisplayName::ParseDisplayName( IBindCtx	*pbc,       WCHAR *pwszDisplayName,
                                                      ULONG		*pchEaten,  IMoniker	**ppIMoniker)
{
    //===========================================================
    //
	//  Instantiate Data Source Object.
	//  Set all interesting properties.
	//  Initialize object.
	//  Create pointer moniker and pass it out.
    //
	//  Need to find out a way to use IBindCtx.
    //
    //===========================================================

	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	if (ppIMoniker)
	{
		*ppIMoniker = NULL;
	}
	if (!pwszDisplayName || !pchEaten){
		hr = MK_E_NOOBJECT;
//		return g_pCError->PostHResult((MK_E_NOOBJECT), &IID_IParseDisplayName);
	}
	else
    if (!ppIMoniker){
		hr = E_UNEXPECTED;
//		return g_pCError->PostHResult((E_UNEXPECTED),&IID_IParseDisplayName);
	}
	else
	{
		IClassFactory * pIClassFact=NULL;
		IDBProperties * pIDBProps=NULL;
		IUnknown	  * pIUnknown=NULL;

		//===========================================================
		//Define Property Structures.
		//===========================================================
		ULONG				cPropertySets;	
		DBPROPSET			rgPropertySet[1];
		DBPROP				rgProperties[1];		

		//===========================================================
		// Clear Error Messages on current thread
		//===========================================================
		g_pCError->ClearErrorInfo();

		//===========================================================
		// Initialize property values
		//===========================================================
		VariantInit(&rgProperties[0].vValue);
		hr = CoCreateInstance( CLSID_WMIOLEDB,NULL,	CLSCTX_INPROC_SERVER, IID_IDBProperties, (void**)&pIDBProps);

		CURLParser urlParser;
		CBSTR strTemp,strKey;
		VARIANT	varKeyVal;
		int lSizeToAlloc = 0;
		WCHAR *pstrNamespace	= NULL;
		VariantInit(&varKeyVal);

		strTemp.SetStr(pwszDisplayName);
		urlParser.SetPath(strTemp);
		strTemp.Clear();

		urlParser.GetNameSpace((BSTR &)strTemp);
		strKey.SetStr(L"Name");
		// Get the Name of the NameSpace
		urlParser.GetKeyValue(strKey,varKeyVal);

		lSizeToAlloc = (SysStringLen(varKeyVal.bstrVal) + 
						SysStringLen(strTemp) + 
						wcslen(NAMESPACE_SEPARATOR) + 1 ) * sizeof(WCHAR);

		try
		{
			pstrNamespace = new WCHAR[lSizeToAlloc];
		}
		catch(...)
		{
			SAFE_DELETE_ARRAY(pstrNamespace);
			throw;
		}

		if(!pstrNamespace)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			// Frame the Namespace string
			memset(pstrNamespace,0,lSizeToAlloc * sizeof(WCHAR));
			memcpy(pstrNamespace,strTemp,SysStringLen(strTemp) * sizeof(WCHAR));
			wcscat(pstrNamespace,NAMESPACE_SEPARATOR);
			memcpy((pstrNamespace + wcslen(pstrNamespace)),varKeyVal.bstrVal,SysStringLen(varKeyVal.bstrVal) * sizeof(WCHAR));

			if (SUCCEEDED(hr)){
				//=======================================================
				//Set Init properties.
				//=======================================================
				cPropertySets = 1;
				rgPropertySet[0].rgProperties		=	rgProperties;
				rgPropertySet[0].cProperties		=	1;
				rgPropertySet[0].guidPropertySet	=	DBPROPSET_DBINIT;

				rgProperties[0].dwPropertyID	=	DBPROP_INIT_DATASOURCE;
				rgProperties[0].dwOptions		=	DBPROPOPTIONS_REQUIRED;
				rgProperties[0].colid			=	DB_NULLID;
				rgProperties[0].vValue.vt		=	VT_BSTR;
				V_BSTR(&rgProperties[0].vValue)	=	Wmioledb_SysAllocString(pstrNamespace);

				//=======================================================
				//Set properties.
				//=======================================================
				hr = pIDBProps->SetProperties(cPropertySets,rgPropertySet);
				if (SUCCEEDED (hr)){

    				pIDBProps->QueryInterface (IID_IUnknown,(LPVOID *) &pIUnknown);
					if (SUCCEEDED(hr)){
						//===============================================
						//Create this object Moniker.
						//===============================================
						hr = CreatePointerMoniker(pIUnknown, ppIMoniker);
						if (FAILED(hr)){
							*ppIMoniker = NULL; 
						}
					}
				}
			}
		}

		SAFE_DELETE_ARRAY(pstrNamespace);

		//===========================================================
		// Clear property values
		//===========================================================
		VariantClear(&rgProperties[0].vValue);
		SAFE_RELEASE_PTR(pIClassFact);
		SAFE_RELEASE_PTR(pIDBProps);
		SAFE_RELEASE_PTR(pIUnknown);
	}

	hr = hr != S_OK ? g_pCError->PostHResult(hr,&IID_ISourcesRowset): hr;

	CATCH_BLOCK_HRESULT(hr,L"IParseDisplayName::ParseDisplayName");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\flexarry.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CFlexArray & CWStringArray class implementation - THis implementation is taken
//										 from Winmgmt\common and modified
// 
// Module Name : Flexarry.cpp
///////////////////////////////////////////////////////////////////////////////////

  

#include "headers.h"
#include "corex.h"

//***************************************************************************
//
//  CFlexArray::CFlexArray
//
//  Constructs the array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(
    int nSize, 
    int nGrowByPercent
    )
{
    m_nExtent = nSize;
    m_nSize = 0;
    m_nGrowByPercent = nGrowByPercent;
    if(nSize > 0)
    {
        m_pArray = (void**)g_pIMalloc->Alloc(sizeof(void *) * nSize);

		// Check for allocation failures
		if ( NULL == m_pArray )
		{
			throw CX_MemoryException();
		}
    }
    else
        m_pArray = NULL;
}
    
//***************************************************************************
//
//  CFlexArray::~CFlexArray
//
//***************************************************************************
// ok
CFlexArray::~CFlexArray()
{
    g_pIMalloc->Free(m_pArray);
}


//***************************************************************************
//
//  Copy constructor.
//  
//  Copies the pointers, not their contents.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(CFlexArray &Src)
{
    m_pArray = 0;
    m_nSize = 0;
    m_nExtent = 0;
    m_nGrowByPercent = 0;

    *this = Src;
}

//***************************************************************************
//
//  operator =
//
//  Assignment operator.
//
//  Arenas are not copied.  This allows transfer of arrays between arenas.
//  Arrays are copied by pointer only.
//
//***************************************************************************
// ok

CFlexArray& CFlexArray::operator=(CFlexArray &Src)
{
    m_nSize   = Src.m_nSize;
    m_nExtent = Src.m_nExtent;
    m_nGrowByPercent = Src.m_nGrowByPercent;

//	CWin32DefaultArena::WbemMemFree(m_pArray);
	delete [] m_pArray;
    if(m_nExtent > 0)
    {
        m_pArray = (void**)g_pIMalloc->Alloc(sizeof(void *) * m_nExtent);
//           (void**)CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * m_nExtent);

		// Check for allocation failures
		if ( NULL == m_pArray )
		{
			throw CX_MemoryException();
		}

    }
    else
        m_pArray = NULL;
    memcpy(m_pArray, Src.m_pArray, sizeof(void *) * m_nSize);
        
    return *this;    
}

//***************************************************************************
//
//  CFlexArray::RemoveAt
//
//  Removes the element at the specified location.  Does not
//  actually delete the pointer. Shrinks the array over the top of
//  the 'doomed' element.
//
//  Parameters:
//  <nIndex>    The location of the element.
//    
//  Return value:
//  range_error     The index is not legal.
//  no_error        Success.
//  
//***************************************************************************
// ok

int CFlexArray::RemoveAt(int nIndex)
{
    if (nIndex >= m_nSize)
        return range_error;

	// Account for the index being 0 based and size being 1 based
	MoveMemory( &m_pArray[nIndex], &m_pArray[nIndex+1], ( ( m_nSize - nIndex ) - 1 ) * sizeof(void *) );
	
    m_nSize--;
    m_pArray[m_nSize] = 0;

    return no_error;
}

int CFlexArray::EnsureExtent(int nExtent)
{
    if(m_nExtent < nExtent)
    {
        m_nExtent = nExtent;
        if(m_pArray)
		{
			register void** pTmp = (void **)g_pIMalloc->Realloc(m_pArra