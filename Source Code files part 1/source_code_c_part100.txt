ate ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgResourceCreate, this, 0 );
    } // else if: IClusCfgResourceCreate
    else if ( IsEqualIID( riidIn, IID_IPrivatePostCfgResource ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IPrivatePostCfgResource, this, 0 );
    } // else if: IPrivatePostCfgResource
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CCreateServices::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCreateServices::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCreateServices::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CCreateServices::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCreateServices::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCreateServices::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CCreateServices::Release

//****************************************************************************
//
//  IClusCfgResourceCreate
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyBinary(
//        LPCWSTR       pcszNameIn
//      , const DWORD   cbSizeIn
//      , const BYTE *  pbyteIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyBinary(
      LPCWSTR       pcszNameIn
    , const DWORD   cbSizeIn
    , const BYTE *  pbyteIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT         hr = S_OK;
    CClusPropList   cpl( TRUE );        // always add the property.
    DWORD           sc;
    const BYTE *    pPrevValue = NULL;  // always have no previous value.
    DWORD           cbPrevValue = 0;

    //
    //  Parameter validation
    //
    if ( ( pcszNameIn == NULL ) || ( pbyteIn == NULL ) || ( cbSizeIn == 0 ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    sc = TW32( cpl.ScAddProp( pcszNameIn, pbyteIn, cbSizeIn, pPrevValue, cbPrevValue ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES, cpl ) );

Cleanup:

    HRETURN( hr );

} //*** CCreateServices::SetPropertyBinary

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyDWORD(
//      LPCWSTR     pcszNameIn,
//      const DWORD dwDWORDIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyDWORD( LPCWSTR pcszNameIn, const DWORD dwDWORDIn )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT         hr = S_OK;
    CClusPropList   cpl( TRUE );    // always add the property.
    DWORD           sc;
    DWORD           nPrevValue = 0; // always have no previous value.

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    sc = TW32( cpl.ScAddProp( pcszNameIn, dwDWORDIn, nPrevValue ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES, cpl ) );

Cleanup:

    HRETURN( hr );

} //*** CCreateServices::SetPropertyDWORD

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyString(
//        LPCWSTR pcszNameIn
//      , LPCWSTR pcszStringIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyString(
      LPCWSTR pcszNameIn
    , LPCWSTR pcszStringIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT         hr = S_OK;
    CClusPropList   cpl( TRUE );        // always add the property.
    DWORD           sc;
    LPCWSTR         pPrevValue = NULL;  // always have no previous value.

    //
    //  Parameter validation
    //
    if ( ( pcszNameIn == NULL ) || ( pcszStringIn == NULL ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    sc = TW32( cpl.ScAddProp( pcszNameIn, pcszStringIn, pPrevValue ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES, cpl ) );

Cleanup:

    HRETURN( hr );

} //*** CCreateServices::SetPropertyString

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyExpandString(
//        LPCWSTR pcszNameIn
//      , LPCWSTR pcszStringIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyExpandString(
      LPCWSTR pcszNameIn
    , LPCWSTR pcszStringIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT         hr = S_OK;
    CClusPropList   cpl( TRUE );        // always add the property.
    DWORD           sc;
    LPCWSTR         pPrevValue = NULL;  // always have no previous value.

    //
    //  Parameter validation
    //
    if ( ( pcszNameIn == NULL ) || ( pcszStringIn == NULL ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    sc = TW32( cpl.ScAddExpandSzProp( pcszNameIn, pcszStringIn, pPrevValue ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES, cpl ) );

Cleanup:

    HRETURN( hr );

} //*** CCreateServices::SetPropertyExpandString

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyMultiString(
//        LPCWSTR     pcszNameIn
//      , const DWORD cbSizeIn
//      , LPCWSTR     pcszStringIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyMultiString(
      LPCWSTR     pcszNameIn
    , const DWORD cbSizeIn
    , LPCWSTR     pcszStringIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT         hr = S_OK;
    CClusPropList   cpl( TRUE );        // always add the property.
    DWORD           sc;
    LPCWSTR         pPrevValue = NULL;  // always have no previous value.

    //
    //  Parameter validation
    //
    if ( ( pcszNameIn == NULL ) || ( pcszStringIn == NULL ) || ( cbSizeIn == 0 ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    sc = TW32( cpl.ScAddMultiSzProp( pcszNameIn, pcszStringIn, pPrevValue ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES, cpl ) );

Cleanup:

    HRETURN( hr );

} //*** CCreateServices::SetPropertyMultiString

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyUnsignedLargeInt(
//        LPCWSTR               pcszNameIn
//      , const ULARGE_INTEGER  ulIntIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyUnsignedLargeInt(
      LPCWSTR               pcszNameIn
    , const ULARGE_INTEGER  ulIntIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT         hr = S_OK;
    CClusPropList   cpl( TRUE );        // always add the property.
    DWORD           sc;
    ULONGLONG       ullPrevValue = 0;   // always have no previous value.

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    sc = TW32( cpl.ScAddProp( pcszNameIn, ulIntIn.QuadPart, ullPrevValue ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES, cpl ) );

Cleanup:

    HRETURN( hr );

} //*** CCreateServices::SetPropertyUnsignedLargeInt

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyLong(
//        LPCWSTR       pcszNameIn
//      , const LONG    lLongIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyLong(
      LPCWSTR       pcszNameIn
    , const LONG    lLongIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT         hr = S_OK;
    CClusPropList   cpl( TRUE );    // always add the property.
    DWORD           sc;
    LONG            lPrevValue = 0; // always have no previous value.

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    sc = TW32( cpl.ScAddProp( pcszNameIn, lLongIn, lPrevValue ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES, cpl ) );

Cleanup:

    HRETURN( hr );

} //*** CCreateServices::SetPropertyLong

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertySecurityDescriptor(
//      LPCWSTR pcszNameIn,
//      const SECURITY_DESCRIPTOR * pcsdIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertySecurityDescriptor(
    LPCWSTR pcszNameIn,
    const SECURITY_DESCRIPTOR * pcsdIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CCreateServices::SetPropertySecurityDescriptor

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyLargeInt(
//        LPCWSTR               pcszNameIn
//      , const LARGE_INTEGER   lIntIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyLargeInt(
      LPCWSTR               pcszNameIn
    , const LARGE_INTEGER   lIntIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT         hr = S_OK;
    CClusPropList   cpl( TRUE );        // always add the property.
    DWORD           sc;
    LONGLONG        llPrevValue = 0;    // always have no previous value.

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    sc = TW32( cpl.ScAddProp( pcszNameIn, lIntIn.QuadPart, llPrevValue ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES, cpl ) );

Cleanup:

    HRETURN( hr );

} //*** CCreateServices::SetPropertyLargeInt

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SendResourceControl(
//      DWORD   dwControlCode,
//      LPVOID  lpInBuffer,
//      DWORD   cbInBufferSize
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SendResourceControl(
    DWORD   dwControlCode,
    LPVOID  lpInBuffer,
    DWORD   cbInBufferSize
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT         hr = S_OK;
    CClusPropList   cpl( TRUE );    // always add the property.
    DWORD           sc;

    sc = TW32( cpl.ScCopy( (PCLUSPROP_LIST) lpInBuffer, cbInBufferSize ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( m_presentry->StoreClusterResourceControl( dwControlCode, cpl ) );

Cleanup:

    HRETURN( hr );

} //*** CCreateServices::SendResourceControl


//****************************************************************************
//
//  IPrivatePostCfgResource
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetEntry(
//      CResourceEntry * presentryIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetEntry(
    CResourceEntry * presentryIn
    )
{
    TraceFunc( "[IPrivatePostCfgResource]" );

    HRESULT hr = S_OK;

    Assert( presentryIn != NULL );

    m_presentry = presentryIn;

    HRETURN( hr );

} //*** CCreateServices::SetEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\evictservices.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EvictServices.h
//
//  Description:
//      EvictServices implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "GroupHandle.h"
#include "ResourceEntry.h"
#include "IPrivatePostCfgResource.h"
#include "EvictServices.h"

DEFINE_THISCLASS("CEvictServices")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEvictServices::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictServices::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CEvictServices *    pes = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pes = new CEvictServices;
    if ( pes == NULL )
    {
        hr = E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pes->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;

    hr = THR( pes->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pes != NULL )
    {
        pes->Release();
    }

    HRETURN( hr );

} //*** CEvictServices::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CEvictServices::CEvictServices
//
//////////////////////////////////////////////////////////////////////////////
CEvictServices::CEvictServices( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEvictServices::CEvictServices

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEvictServices::HrInit
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictServices::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // Resource
    Assert( m_presentry == NULL );

    HRETURN( hr );

} //*** CEvictServices::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CEvictServices::~CEvictServices
//
//////////////////////////////////////////////////////////////////////////////
CEvictServices::~CEvictServices( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEvictServices::~CEvictServices


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictServices::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEvictServices::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgResourceEvict * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgResourceEvict ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgResourceEvict, this, 0 );
    } // else if: IClusCfgResourceEvict
    else if ( IsEqualIID( riidIn, IID_IPrivatePostCfgResource ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IPrivatePostCfgResource, this, 0 );
    } // else if: IPrivatePostCfgResource
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEvictServices::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEvictServices::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEvictServices::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEvictServices::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEvictServices::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEvictServices::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CEvictServices::Release


//****************************************************************************
//
//  IPrivatePostCfgResource
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEvictServices::SetEntry( 
//      CResourceEntry * presentryIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CEvictServices::SetEntry( 
    CResourceEntry * presentryIn
    )
{
    TraceFunc( "[IPrivatePostCfgResource]" );

    HRESULT hr = S_OK;
    
    m_presentry = presentryIn;

    HRETURN( hr );

} //*** CEvictServices::SetEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\evictservices.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EvictServices.h
//
//  Description:
//      EvictServices implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CEvictServices
    : public IClusCfgResourceEvict
    , public IPrivatePostCfgResource
{
private:    // data
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    //  IPrivatePostCfgResource
    CResourceEntry *    m_presentry;    //  List entry that the service is to modify.

private:    // methods
    CEvictServices( void );
    ~CEvictServices( void );

    HRESULT HrInit( void );

public:     // methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IPrivatePostCfgResource
    STDMETHOD( SetEntry )( CResourceEntry * presentryIn );

}; //*** class CEvictServices
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\iprivatepostcfgresource.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      IPrivatePostCfgResource.h
//
//  Description:
//      IPrivatePostCfgResource interface definition.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class
IPrivatePostCfgResource
:   public  IUnknown
{
public:
    //////////////////////////////////////////////////////////////////////////
    //
    //  PRIVATE
    //  STDMETHOD
    //  IPrivatePostCfgResource::SetEntry(
    //      CResourceEntry * presentryIn 
    //      )
    //
    //  Description:
    //      Tells the resource service which entry it is to be modifying.
    //
    //  Arguments:
    //      presentryIn
    //          The entry in which the resource service is going to modifying.
    //
    //  Return Values:
    //      S_OK
    //          The call succeeded.
    //
    //      other HRESULTs
    //          The call failed.
    //
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD( SetEntry )( CResourceEntry * presentryIn ) PURE;

}; // class IPrivatePostCfgResource
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\ipostcfgmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      IPostCfgManager.h
//
//  Description:
//      IPostCfgManager interface definition.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 21-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class
IPostCfgManager : public IUnknown
{
public:
    //////////////////////////////////////////////////////////////////////////
    //
    //  STDMETHOD
    //  IPostCfgManager::CommitChanges(
    //      IEnumClusCfgManagedResources    * peccmrIn,
    //      IClusCfgClusterInfo *             pccciIn
    //      )
    //
    //  Description:
    //      Tells the Post Configuration Manager to create the resource types,
    //      groups and managed resources.
    //
    //  Arguments:
    //      peccmrIn
    //          The enumerator of the managed resources to create.
    //
    //      pccciIn
    //          The cluster configuration information object.
    //
    //  Return Values:
    //      S_OK
    //          The call succeeded.
    //
    //      other HRESULTs
    //          The call failed.
    //
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD( CommitChanges )( IEnumClusCfgManagedResources    * peccmrIn,
                                IClusCfgClusterInfo *             pccciIn
                                ) PURE;

}; // interface IPostCfgManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
#endif // DBG==1 || _DEBUG

//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <Pragmas.h>

#include <windows.h>
#include <objbase.h>
#include <shlwapi.h>
#include <ComCat.h>
#include <commctrl.h>
#include <clusapi.h>
#include <clusudef.h>

#include <Common.h>
#include <Debug.h>
#include <CriticalSection.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <Guids.h>

#include <ClusCfgGuids.h>
#include <ClusCfgDef.h>
#include <ClusCfgServer.h>
#include <LoadString.h>
#include <PropList.h>
#include "PostCfgGuids.h"
#include "PostCfgStrings.h"

#include <strsafe.h>


//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\grouphandle.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      GroupHandle.h
//
//  Description:
//      CGroupHandle implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CGroupHandle
class CGroupHandle
    : public IUnknown
{
private:
    // IUnknown
    LONG                m_cRef;

    //  IPrivateGroupHandle
    HGROUP              m_hGroup;       //  Cluster Group Handle

private: // Methods
    CGroupHandle( void );
    ~CGroupHandle( void );
    STDMETHOD( HrInit )( HGROUP hGroupIn );

public: // Methods
    static HRESULT S_HrCreateInstance( CGroupHandle ** ppunkOut, HGROUP hGroupIn );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IPrivateGroupHandle
    STDMETHOD( SetHandle )( HGROUP hGroupIn );
    STDMETHOD( GetHandle )( HGROUP * phGroupOut );

}; //*** class CGroupHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\postcfgguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      PostCfgGuids.h
//
//  Description:
//      This file defines the guids used by PostConfig.
//
//  Documentation:
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2001
//      Ozan Ozhan   (Ozano)  10-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <InitGuid.h>

//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////

//
//  Minor Task IDs
//

// {EB14D973-5260-42c8-BDC5-2C463EFC3BFE}
DEFINE_GUID( TASKID_Minor_Init_MapResTypeGuidToName,
0xeb14d973, 0x5260, 0x42c8, 0xbd, 0xc5, 0x2c, 0x46, 0x3e, 0xfc, 0x3b, 0xfe);

// {E6B4712F-D3C5-4a23-A13E-82249CED7263}
DEFINE_GUID( TASKID_Minor_Init_OutOfMemory,
0xe6b4712f, 0xd3c5, 0x4a23, 0xa1, 0x3e, 0x82, 0x24, 0x9c, 0xed, 0x72, 0x63);

// {0B01B239-72AC-42cd-8083-616E1F79A852}
DEFINE_GUID( TASKID_Minor_Initialize_QI,
0xb01b239, 0x72ac, 0x42cd, 0x80, 0x83, 0x61, 0x6e, 0x1f, 0x79, 0xa8, 0x52);

// {145C7029-B56F-41d3-A667-7B1ADEE65C39}
DEFINE_GUID( TASKID_Minor_CommitChanges_QI_Resources,
0x145c7029, 0xb56f, 0x41d3, 0xa6, 0x67, 0x7b, 0x1a, 0xde, 0xe6, 0x5c, 0x39);

// {B3C49A4C-41F2-40bc-870D-30AA31C5D44E}
DEFINE_GUID( TASKID_Minor_CommitChanges_QI_ClusterInfo,
0xb3c49a4c, 0x41f2, 0x40bc, 0x87, 0xd, 0x30, 0xaa, 0x31, 0xc5, 0xd4, 0x4e);

// {770C99BD-2127-481a-A529-8E194CD206A6}
DEFINE_GUID( TASKID_Minor_CommitChanges_GetCommitMode,
0x770c99bd, 0x2127, 0x481a, 0xa5, 0x29, 0x8e, 0x19, 0x4c, 0xd2, 0x6, 0xa6);

// {F4367721-F216-4a1a-807E-A17EDE71B7F4}
DEFINE_GUID( TASKID_Minor_CommitChanges_CoCreate_ResTypeService,
0xf4367721, 0xf216, 0x4a1a, 0x80, 0x7e, 0xa1, 0x7e, 0xde, 0x71, 0xb7, 0xf4);

// {B057ACFF-74C6-4129-A2A8-942D55393FAF}
DEFINE_GUID( TASKID_Minor_CommitChanges_SetParameters,
0xb057acff, 0x74c6, 0x4129, 0xa2, 0xa8, 0x94, 0x2d, 0x55, 0x39, 0x3f, 0xaf);

// {83149573-151E-4bb6-8594-28EFDC058E48}
DEFINE_GUID( TASKID_Minor_CommitChanges_OpenCluster,
0x83149573, 0x151e, 0x4bb6, 0x85, 0x94, 0x28, 0xef, 0xdc, 0x5, 0x8e, 0x48);

// {1744FBF0-9B5D-4846-98B2-5B95C86B0D29}
DEFINE_GUID( TASKID_Minor_PreCreate_Reset,
0x1744fbf0, 0x9b5d, 0x4846, 0x98, 0xb2, 0x5b, 0x95, 0xc8, 0x6b, 0xd, 0x29);

// {A4D1F1EE-71C4-4a10-AA4E-DEC05F37A0F2}
DEFINE_GUID( TASKID_Minor_PreCreate_CPreCreateServices,
0xa4d1f1ee, 0x71c4, 0x4a10, 0xaa, 0x4e, 0xde, 0xc0, 0x5f, 0x37, 0xa0, 0xf2);

// {36A14852-D2B2-460d-A5F4-52A244E19ADE}
DEFINE_GUID( TASKID_Minor_PreCreate_CPreCreateServices_QI,
0x36a14852, 0xd2b2, 0x460d, 0xa5, 0xf4, 0x52, 0xa2, 0x44, 0xe1, 0x9a, 0xde);

// {D3C86111-25F2-49fe-A1F9-91622A120E9C}
DEFINE_GUID( TASKID_Minor_PreCreate_LoadString_Querying,
0xd3c86111, 0x25f2, 0x49fe, 0xa1, 0xf9, 0x91, 0x62, 0x2a, 0x12, 0xe, 0x9c);

// {C9EF05D3-235C-49ae-B237-0C83F69F125C}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_Next,
0xc9ef05d3, 0x235c, 0x49ae, 0xb2, 0x37, 0xc, 0x83, 0xf6, 0x9f, 0x12, 0x5c);

// {2C02D6FB-8847-4b78-B9A8-BA5BCB81A77E}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_GetName,
0x2c02d6fb, 0x8847, 0x4b78, 0xb9, 0xa8, 0xba, 0x5b, 0xcb, 0x81, 0xa7, 0x7e);

// {5BCE21E7-2FE0-4a52-986A-3CBA1B4A5895}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_IsManaged,
0x5bce21e7, 0x2fe0, 0x4a52, 0x98, 0x6a, 0x3c, 0xba, 0x1b, 0x4a, 0x58, 0x95);

// {9DAA8CDA-1004-4543-BCFF-4ECF774AA8A7}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_IsManaged_False,
0x9daa8cda, 0x1004, 0x4543, 0xbc, 0xff, 0x4e, 0xcf, 0x77, 0x4a, 0xa8, 0xa7);

// {A01A352F-1E7B-4bd8-B160-A273ECA8CE6E}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_QI_pccmrc,
0xa01a352f, 0x1e7b, 0x4bd8, 0xb1, 0x60, 0xa2, 0x73, 0xec, 0xa8, 0xce, 0x6e);

// {53F01DD7-99BB-46e7-9859-7E582E7AECEB}
DEFINE_GUID( TASKID_PreCreate_EnumResources_IsQuorumDevice_S_OK,
0x53f01dd7, 0x99bb, 0x46e7, 0x98, 0x59, 0x7e, 0x58, 0x2e, 0x7a, 0xec, 0xeb);

// {E632F148-25B3-4108-931B-DE6D1B990290}
DEFINE_GUID( TASKID_PreCreate_EnumResources_IsQuorumDevice_Failed,
0xe632f148, 0x25b3, 0x4108, 0x93, 0x1b, 0xde, 0x6d, 0x1b, 0x99, 0x2, 0x90);

// {E466C438-35C6-4d4b-A5ED-31E5AD12F7A7}
DEFINE_GUID( TASKID_PreCreate_EnumResources_SetAssociatedResouce,
0xe466c438, 0x35c6, 0x4d4b, 0xa5, 0xed, 0x31, 0xe5, 0xad, 0x12, 0xf7, 0xa7);

// {B54ED2B2-4762-4d33-A8D1-191DD3933758}
DEFINE_GUID( TASKID_PreCreate_EnumResources_SetName,
0xb54ed2b2, 0x4762, 0x4d33, 0xa8, 0xd1, 0x19, 0x1d, 0xd3, 0x93, 0x37, 0x58);

// {A7E8FD12-9B3F-44d0-82A9-2400164087EC}
DEFINE_GUID( TASKID_PreCreate_EnumResources_SetEntry,
0xa7e8fd12, 0x9b3f, 0x44d0, 0x82, 0xa9, 0x24, 0x0, 0x16, 0x40, 0x87, 0xec);

// {D2E0B087-CE86-4ceb-9295-DCA723994925}
DEFINE_GUID( TASKID_Minor_PreCreate_PreCreate_E_NOTIMPL,
0xd2e0b087, 0xce86, 0x4ceb, 0x92, 0x95, 0xdc, 0xa7, 0x23, 0x99, 0x49, 0x25);

// {ADA0F04E-D162-4cb8-A1E1-6695C6A2D010}
DEFINE_GUID( TASKID_Minor_PreCreate_Succeeded,
0xada0f04e, 0xd162, 0x4cb8, 0xa1, 0xe1, 0x66, 0x95, 0xc6, 0xa2, 0xd0, 0x10);

// {389D9670-1408-4cca-A527-E5EAD5680B43}
DEFINE_GUID( TASKID_Minor_PreCreate_Finished,
0x389d9670, 0x1408, 0x4cca, 0xa5, 0x27, 0xe5, 0xea, 0xd5, 0x68, 0xb, 0x43);

// {3B387B9F-9D23-49ff-A010-5E1A2C618663}
DEFINE_GUID( TASKID_Minor_CreateGroups_Begin,
0x3b387b9f, 0x9d23, 0x49ff, 0xa0, 0x10, 0x5e, 0x1a, 0x2c, 0x61, 0x86, 0x63);

// {625DE61F-1678-4e97-A7E6-17578AD106B4}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetCountOfTypeDependencies,
0x625de61f, 0x1678, 0x4e97, 0xa7, 0xe6, 0x17, 0x57, 0x8a, 0xd1, 0x6, 0xb4);

// {26E49D7F-15EF-40c3-8792-537328FF9E1D}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetTypeDependencyPtr,
0x26e49d7f, 0x15ef, 0x40c3, 0x87, 0x92, 0x53, 0x73, 0x28, 0xff, 0x9e, 0x1d);

// {ECEFA23F-6A16-4fa4-83B7-B9EBE1566C66}
DEFINE_GUID( TASKID_Minor_CreateGroups_FormatString_NetName,
0xecefa23f, 0x6a16, 0x4fa4, 0x83, 0xb7, 0xb9, 0xeb, 0xe1, 0x56, 0x6c, 0x66);

// {4AE83FA3-CA8D-4997-97D0-2E8C43A68314}
DEFINE_GUID( TASKID_Minor_CreateGroups_AddTypeDependency,
0x4ae83fa3, 0xca8d, 0x4997, 0x97, 0xd0, 0x2e, 0x8c, 0x43, 0xa6, 0x83, 0x14);

// {0527E435-5B42-4a2c-9334-EA918C3892E0}
DEFINE_GUID( TASKID_Minor_CreateGroups_FormatString_IPAddress,
0x527e435, 0x5b42, 0x4a2c, 0x93, 0x34, 0xea, 0x91, 0x8c, 0x38, 0x92, 0xe0);

// {13F32529-0BA2-4ff6-84FE-7982D4002D64}
DEFINE_GUID( TASKID_Minor_CreateGroups_NetName_AddDependent,
0x13f32529, 0xba2, 0x4ff6, 0x84, 0xfe, 0x79, 0x82, 0xd4, 0x0, 0x2d, 0x64);

// {1C3A7C27-E6E7-4a39-B630-70B8B4D6E6D8}
DEFINE_GUID( TASKID_Minor_CreateGroups_IPAddress_AddDependent,
0x1c3a7c27, 0xe6e7, 0x4a39, 0xb6, 0x30, 0x70, 0xb8, 0xb4, 0xd6, 0xe6, 0xd8);

// {022D8BF0-93EB-4dc9-B11E-3772B8BE43B5}
DEFINE_GUID( TASKID_Minor_CreateGroups_QuorumDisk_AddDependent,
0x22d8bf0, 0x93eb, 0x4dc9, 0xb1, 0x1e, 0x37, 0x72, 0xb8, 0xbe, 0x43, 0xb5);

// {5B9958C4-DC00-474f-86CB-8B893F0FE8FB}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetTypePtr,
0x5b9958c4, 0xdc00, 0x474f, 0x86, 0xcb, 0x8b, 0x89, 0x3f, 0xf, 0xe8, 0xfb);

// {9B69E548-0334-4c4b-888E-12574174B99D}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetClassTypePtr,
0x9b69e548, 0x334, 0x4c4b, 0x88, 0x8e, 0x12, 0x57, 0x41, 0x74, 0xb9, 0x9d);

// {0AA1F2BD-CC88-4bf5-87B3-A1953C731AC1}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetFlags,
0xaa1f2bd, 0xcc88, 0x4bf5, 0x87, 0xb3, 0xa1, 0x95, 0x3c, 0x73, 0x1a, 0xc1);

// {7B64039A-79B2-4086-ABF2-5E1520DACE8C}
DEFINE_GUID( TASKID_Minor_CreateGroups_SetFlags,
0x7b64039a, 0x79b2, 0x4086, 0xab, 0xf2, 0x5e, 0x15, 0x20, 0xda, 0xce, 0x8c);

// {4FB598B1-D9EE-4f75-B274-B639941839A3}
DEFINE_GUID( TASKID_Minor_CreateGroups_Resource_AddDependent,
0x4fb598b1, 0xd9ee, 0x4f75, 0xb2, 0x74, 0xb6, 0x39, 0x94, 0x18, 0x39, 0xa3);

// {E7ECD079-1AC8-43c5-A577-0826500A4262}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetName,
0xe7ecd079, 0x1ac8, 0x43c5, 0xa5, 0x77, 0x8, 0x26, 0x50, 0xa, 0x42, 0x62);

// {04989473-AE35-4a5d-A35F-C502C1E87E8B}
DEFINE_GUID( TASKID_Minor_CreateGroups_MissingDependent,
0x4989473, 0xae35, 0x4a5d, 0xa3, 0x5f, 0xc5, 0x2, 0xc1, 0xe8, 0x7e, 0x8b);

// {CA40367F-04AB-44d1-86C9-7E28318AD868}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetAssociateResource,
0xca40367f, 0x4ab, 0x44d1, 0x86, 0xc9, 0x7e, 0x28, 0x31, 0x8a, 0xd8, 0x68);

// {0FE4B1B0-24C1-46c5-87E5-DE6DF8446895}
DEFINE_GUID( TASKID_Minor_CreateGroups_QI_pccmri,
0xfe4b1b0, 0x24c1, 0x46c5, 0x87, 0xe5, 0xde, 0x6d, 0xf8, 0x44, 0x68, 0x95);

// {677F301F-74A9-4176-9D89-7A505AD2DFE6}
DEFINE_GUID( TASKID_Minor_CreateGroups_SetManaged,
0x677f301f, 0x74a9, 0x4176, 0x9d, 0x89, 0x7a, 0x50, 0x5a, 0xd2, 0xdf, 0xe6);

// {CA048D82-325F-4566-904C-99FB67BE46B9}
DEFINE_GUID( TASKID_Minor_CreateGroups_Creating,
0xca048d82, 0x325f, 0x4566, 0x90, 0x4c, 0x99, 0xfb, 0x67, 0xbe, 0x46, 0xb9);

// {6E6830D6-E2A4-4324-BE48-DE7874ABA52E}
DEFINE_GUID( TASKID_Minor_CreateGroups_OpenClusterGroup,
0x6e6830d6, 0xe2a4, 0x4324, 0xbe, 0x48, 0xde, 0x78, 0x74, 0xab, 0xa5, 0x2e);

// {413D510B-73BF-4230-AE1F-A5A8963B5401}
DEFINE_GUID( TASKID_Minor_CreateGroups_Create_CGroupHandle,
0x413d510b, 0x73bf, 0x4230, 0xae, 0x1f, 0xa5, 0xa8, 0x96, 0x3b, 0x54, 0x1);

// {7029A765-0ED6-49d3-952B-24974ACA3FA2}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetCountOfTypeDependencies2,
0x7029a765, 0xed6, 0x49d3, 0x95, 0x2b, 0x24, 0x97, 0x4a, 0xca, 0x3f, 0xa2);

// {265219CA-B5C3-4978-A9C6-254C5EDF9654}
DEFINE_GUID( TASKID_Minor_CreateGroups_FormatString_Group,
0x265219ca, 0xb5c3, 0x4978, 0xa9, 0xc6, 0x25, 0x4c, 0x5e, 0xdf, 0x96, 0x54);

// {D302B68A-0743-4f66-9258-2DE440BB8092}
DEFINE_GUID( TASKID_Minor_CreateGroups_CreateClusterGroup,
0xd302b68a, 0x743, 0x4f66, 0x92, 0x58, 0x2d, 0xe4, 0x40, 0xbb, 0x80, 0x92);

// {E8CFA468-ED52-415c-A682-311648AA7026}
DEFINE_GUID( TASKID_Minor_CreateGroups_OnlineClusterGroup,
0xe8cfa468, 0xed52, 0x415c, 0xa6, 0x82, 0x31, 0x16, 0x48, 0xaa, 0x70, 0x26);

// {42F93B4E-0AB4-4851-983A-D792A5D24094}
DEFINE_GUID( TASKID_Minor_CreateGroups_Create_CGroupHandle2,
0x42f93b4e, 0xab4, 0x4851, 0x98, 0x3a, 0xd7, 0x92, 0xa5, 0xd2, 0x40, 0x94);

// {3122D49C-9FA4-44a1-8DC3-FFBF79AE630C}
DEFINE_GUID( TASKID_Minor_CreateGroups_Created,
0x3122d49c, 0x9fa4, 0x44a1, 0x8d, 0xc3, 0xff, 0xbf, 0x79, 0xae, 0x63, 0xc);

// {9AEA3DE8-220A-4a76-8A70-B3271EFF63BA}
DEFINE_GUID( TASKID_Minor_CreateGroups_Finished,
0x9aea3de8, 0x220a, 0x4a76, 0x8a, 0x70, 0xb3, 0x27, 0x1e, 0xff, 0x63, 0xba);

// {AF9FE752-2F27-473a-A7B0-86CEFDE922CA}
DEFINE_GUID( TASKID_Minor_CreateResources_LoadString_Creating,
0xaf9fe752, 0x2f27, 0x473a, 0xa7, 0xb0, 0x86, 0xce, 0xfd, 0xe9, 0x22, 0xca);

// {A9282CC8-F6C9-4b38-BADE-2F1CEE657E7B}
DEFINE_GUID( TASKID_Minor_CreateResources_Starting,
0xa9282cc8, 0xf6c9, 0x4b38, 0xba, 0xde, 0x2f, 0x1c, 0xee, 0x65, 0x7e, 0x7b);

// {3F08ABDA-13FD-4f02-B4B4-925FF239C206}
DEFINE_GUID( TASKID_Minor_CreateResources_Finished,
0x3f08abda, 0x13fd, 0x4f02, 0xb4, 0xb4, 0x92, 0x5f, 0xf2, 0x39, 0xc2, 0x6);

// {93779961-39A9-4cdf-BECC-04F1410640D5}
DEFINE_GUID( TASKID_Minor_PostCreateResources_LoadString_Starting,
0x93779961, 0x39a9, 0x4cdf, 0xbe, 0xcc, 0x4, 0xf1, 0x41, 0x6, 0x40, 0xd5);

// {997EEAB6-01F1-45b9-BC96-E2E728E32CCC}
DEFINE_GUID( TASKID_Minor_PostCreateResources_Starting,
0x997eeab6, 0x1f1, 0x45b9, 0xbc, 0x96, 0xe2, 0xe7, 0x28, 0xe3, 0x2c, 0xcc);

// {ABE9C1C8-13CC-44dc-B4D3-8B803DE38358}
DEFINE_GUID( TASKID_Minor_PostCreateResources_Finished,
0xabe9c1c8, 0x13cc, 0x44dc, 0xb4, 0xd3, 0x8b, 0x80, 0x3d, 0xe3, 0x83, 0x58);

// {4F5EAD56-5172-4b2a-97A8-6812ADAE2F9C}
DEFINE_GUID( TASKID_Minor_FindNextSharedStorage_GetClassTypePtr,
0x4f5ead56, 0x5172, 0x4b2a, 0x97, 0xa8, 0x68, 0x12, 0xad, 0xae, 0x2f, 0x9c);

// {EFB1E60B-2967-43ea-8309-41912038B7A7}
DEFINE_GUID( TASKID_Minor_FindNextSharedStorage_GetFlags,
0xefb1e60b, 0x2967, 0x43ea, 0x83, 0x9, 0x41, 0x91, 0x20, 0x38, 0xb7, 0xa7);

// {68984825-C701-4470-AD63-5BC2F336848E}
DEFINE_GUID( TASKID_Minor_HrAttemptToAssignStorageToResource_NoMoreStorage,
0x68984825, 0xc701, 0x4470, 0xad, 0x63, 0x5b, 0xc2, 0xf3, 0x36, 0x84, 0x8e);

// {EBCDD0EB-2073-4f14-BD27-90AB30A8E586}
DEFINE_GUID( TASKID_Minor_HrAttemptToAssignStorageToResource_SetFlags,
0xebcdd0eb, 0x2073, 0x4f14, 0xbd, 0x27, 0x90, 0xab, 0x30, 0xa8, 0xe5, 0x86);

// {2BCED0CA-CEFD-47c2-8740-AB02A6D3DBFB}
DEFINE_GUID( TASKID_Minor_HrAttemptToAssignStorageToResource_AddDependent,
0x2bced0ca, 0xcefd, 0x47c2, 0x87, 0x40, 0xab, 0x2, 0xa6, 0xd3, 0xdb, 0xfb);

// {FE025462-CFCE-4fed-ACB5-3DDBD9811AF0}
DEFINE_GUID( TASKID_Minor_HrMovedDependentsToAnotherResource_GetCountOfDependents,
0xfe025462, 0xcfce, 0x4fed, 0xac, 0xb5, 0x3d, 0xdb, 0xd9, 0x81, 0x1a, 0xf0);

// {A03679D1-5E6C-40d5-88D9-2B147DFFD000}
DEFINE_GUID( TASKID_Minor_HrMovedDependentsToAnotherResource_GetDependent,
0xa03679d1, 0x5e6c, 0x40d5, 0x88, 0xd9, 0x2b, 0x14, 0x7d, 0xff, 0xd0, 0x0);

// {741F73BA-8B43-464f-BBC3-C7AFB9E232A3}
DEFINE_GUID( TASKID_Minor_HrMovedDependentsToAnotherResource_AddDependent,
0x741f73ba, 0x8b43, 0x464f, 0xbb, 0xc3, 0xc7, 0xaf, 0xb9, 0xe2, 0x32, 0xa3);

// {31641A0B-AC8E-4856-AD83-811103EF4451}
DEFINE_GUID( TASKID_Minor_HrMovedDependentsToAnotherResource_ClearDependents,
0x31641a0b, 0xac8e, 0x4856, 0xad, 0x83, 0x81, 0x11, 0x3, 0xef, 0x44, 0x51);

// {401343DB-742F-493b-81C2-C272A01E9685}
DEFINE_GUID( TASKID_Minor_HrSetGroupOnResourceAndItsDependents_SetGroupHandle,
0x401343db, 0x742f, 0x493b, 0x81, 0xc2, 0xc2, 0x72, 0xa0, 0x1e, 0x96, 0x85);

// {CF60103B-2393-478e-82F0-BD1041097D9E}
DEFINE_GUID( TASKID_Minor_HrSetGroupOnResourceAndItsDependents_GetCountOfDependents,
0xcf60103b, 0x2393, 0x478e, 0x82, 0xf0, 0xbd, 0x10, 0x41, 0x9, 0x7d, 0x9e);

// {2179E00E-00AE-432b-8910-F9DF3B8C4701}
DEFINE_GUID( TASKID_Minor_HrSetGroupOnResourceAndItsDependents_GetDependent,
0x2179e00e, 0xae, 0x432b, 0x89, 0x10, 0xf9, 0xdf, 0x3b, 0x8c, 0x47, 0x1);

// {71C819A2-59D4-4a20-8A06-695BFC5A3B50}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetGroupHandle,
0x71c819a2, 0x59d4, 0x4a20, 0x8a, 0x6, 0x69, 0x5b, 0xfc, 0x5a, 0x3b, 0x50);

// {220CBC7E-F52C-4fb0-AC58-D6DAA7F3330E}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_Create_CGroupHandle,
0x220cbc7e, 0xf52c, 0x4fb0, 0xac, 0x58, 0xd6, 0xda, 0xa7, 0xf3, 0x33, 0xe);

// {F3E4E9A6-E114-4718-9EC7-1DB72154BA6B}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OpenClusterGroup,
0xf3e4e9a6, 0xe114, 0x4718, 0x9e, 0xc7, 0x1d, 0xb7, 0x21, 0x54, 0xba, 0x6b);

// {348C670F-06C7-41f8-8EFB-15C2F8DD4E11}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetClusterResourceState,
0x348c670f, 0x6c7, 0x41f8, 0x8e, 0xfb, 0x15, 0xc2, 0xf8, 0xdd, 0x4e, 0x11);

// {9961A93D-1112-4121-949D-7A43DAF77BD7}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetCountOfDependents,
0x9961a93d, 0x1112, 0x4121, 0x94, 0x9d, 0x7a, 0x43, 0xda, 0xf7, 0x7b, 0xd7);

// {84710A53-2DE0-49ac-8BA1-3202F3FAC6E8}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetDependent,
0x84710a53, 0x2de0, 0x49ac, 0x8b, 0xa1, 0x32, 0x2, 0xf3, 0xfa, 0xc6, 0xe8);

// {3590BB47-0B80-4a7a-A27A-F27728742FA1}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OutOfMemory,
0x3590bb47, 0xb80, 0x4a7a, 0xa2, 0x7a, 0xf2, 0x77, 0x28, 0x74, 0x2f, 0xa1);

// {F1DF0EA2-EF0A-4adc-90D5-FE5870B737D4}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_ReplaceTokens,
0xf1df0ea2, 0xef0a, 0x4adc, 0x90, 0xd5, 0xfe, 0x58, 0x70, 0xb7, 0x37, 0xd4);

// {D25F1C89-6452-42aa-93F9-93F0721CCF23}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Create_CCreateServices,
0xd25f1c89, 0x6452, 0x42aa, 0x93, 0xf9, 0x93, 0xf0, 0x72, 0x1c, 0xcf, 0x23);

// {9F3C4CA9-CFCB-4e19-886C-4569172D4D9F}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Create_CCreateServices_QI,
0x9f3c4ca9, 0xcfcb, 0x4e19, 0x88, 0x6c, 0x45, 0x69, 0x17, 0x2d, 0x4d, 0x9f);

// {A3555B22-732C-416a-BB51-51F21FD8DC09}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_SetEntry,
0xa3555b22, 0x732c, 0x416a, 0xbb, 0x51, 0x51, 0xf2, 0x1f, 0xd8, 0xdc, 0x9);

// {26699073-04DA-4b24-9138-B8FFA4CC25CA}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_IsConfigured,
0x26699073, 0x4da, 0x4b24, 0x91, 0x38, 0xb8, 0xff, 0xa4, 0xcc, 0x25, 0xca);

// {4BCEF420-01B6-4237-B0ED-E75F4E91C160}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_SetConfigured,
0x4bcef420, 0x1b6, 0x4237, 0xb0, 0xed, 0xe7, 0x5f, 0x4e, 0x91, 0xc1, 0x60);

// {C91BFB6C-5AF3-451b-886A-BC3C54B51F93}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_GetName,
0xc91bfb6c, 0x5af3, 0x451b, 0x88, 0x6a, 0xbc, 0x3c, 0x54, 0xb5, 0x1f, 0x93);

// {72058AEF-0B59-4eef-9EA0-37449B22636D}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_GetGroupHandle,
0x72058aef, 0xb59, 0x4eef, 0x9e, 0xa0, 0x37, 0x44, 0x9b, 0x22, 0x63, 0x6d);

// {D976AB04-40FD-4afb-A989-B52FE2EC1A45}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_GetHandle,
0xd976ab04, 0x40fd, 0x4afb, 0xa9, 0x89, 0xb5, 0x2f, 0xe2, 0xec, 0x1a, 0x45);

// {1F229FDE-D692-40bc-9DA9-C625033421D8}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_GetAssociatedResource,
0x1f229fde, 0xd692, 0x40bc, 0x9d, 0xa9, 0xc6, 0x25, 0x3, 0x34, 0x21, 0xd8);

// {3BB6DCD7-8BAC-4858-815E-F83D9625CE82}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Create_Failed,
0x3bb6dcd7, 0x8bac, 0x4858, 0x81, 0x5e, 0xf8, 0x3d, 0x96, 0x25, 0xce, 0x82);

// {34731F38-4B93-426c-9188-3463693D302D}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_GetTypePtr,
0x34731f38, 0x4b93, 0x426c, 0x91, 0x88, 0x34, 0x63, 0x69, 0x3d, 0x30, 0x2d);

// {D00DDDF7-4B8F-48d2-B5FC-AA174FF43B46}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_PcszLookupTypeNameByGUID,
0xd00dddf7, 0x4b8f, 0x48d2, 0xb5, 0xfc, 0xaa, 0x17, 0x4f, 0xf4, 0x3b, 0x46);

// {EC8EB861-EFDA-4d0d-9420-0C4EA69536FA}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_InvalidData_GetTypePtr,
0xec8eb861, 0xefda, 0x4d0d, 0x94, 0x20, 0xc, 0x4e, 0xa6, 0x95, 0x36, 0xfa);

// {A2BB1F77-F8C8-4658-B849-9A2CCAC9642D}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_NetworkName_QI_pccrc,
0xa2bb1f77, 0xf8c8, 0x4658, 0xb8, 0x49, 0x9a, 0x2c, 0xca, 0xc9, 0x64, 0x2d);

// {3812CC1D-103D-4ca9-8AE6-ADA8804EFBA5}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_NetworkName_SetPropertyString,
0x3812cc1d, 0x103d, 0x4ca9, 0x8a, 0xe6, 0xad, 0xa8, 0x80, 0x4e, 0xfb, 0xa5);

// {9F64F1C0-6B4E-41fd-9995-4C7331B064EA}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_IPAddress_QI_pccrc,
0x9f64f1c0, 0x6b4e, 0x41fd, 0x99, 0x95, 0x4c, 0x73, 0x31, 0xb0, 0x64, 0xea);

// {45455DEB-2B1B-4834-86D9-2018D382CF25}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_NothingNew,
0x45455deb, 0x2b1b, 0x4834, 0x86, 0xd9, 0x20, 0x18, 0xd3, 0x82, 0xcf, 0x25);

// {6FF6610B-7EF1-4dbd-A1B9-9959FB590AE6}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetCountOfDependents,
0x6ff6610b, 0x7ef1, 0x4dbd, 0xa1, 0xb9, 0x99, 0x59, 0xfb, 0x59, 0xa, 0xe6);

// {1E32E142-10EC-4d17-ADF9-26B2826CE2E7}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetDependent,
0x1e32e142, 0x10ec, 0x4d17, 0xad, 0xf9, 0x26, 0xb2, 0x82, 0x6c, 0xe2, 0xe7);

// {4AD23667-65C4-42cc-82EA-E1A5137536FC}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetName,
0x4ad23667, 0x65c4, 0x42cc, 0x82, 0xea, 0xe1, 0xa5, 0x13, 0x75, 0x36, 0xfc);

// {43CE9A36-7CE7-4e22-87F7-D481F37867DB}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetHResource,
0x43ce9a36, 0x7ce7, 0x4e22, 0x87, 0xf7, 0xd4, 0x81, 0xf3, 0x78, 0x67, 0xdb);

// {B861DFAF-DB48-4f28-A84E-9510B8F3976F}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_AddClusterResourceDependency,
0xb861dfaf, 0xdb48, 0x4f28, 0xa8, 0x4e, 0x95, 0x10, 0xb8, 0xf3, 0x97, 0x6f);

// {111C9950-9E61-4733-80D5-06C58631D423}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_Succeeded,
0x111c9950, 0x9e61, 0x4733, 0x80, 0xd5, 0x6, 0xc5, 0x86, 0x31, 0xd4, 0x23);

// {AFD6FEDC-BC4F-4cd6-8CFE-0D0458DF15DF}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_IsConfigured,
0xafd6fedc, 0xbc4f, 0x4cd6, 0x8c, 0xfe, 0xd, 0x4, 0x58, 0xdf, 0x15, 0xdf);

// {CA02A3CF-121A-4231-882F-CAF8DB761D25}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_SetConfigured,
0xca02a3cf, 0x121a, 0x4231, 0x88, 0x2f, 0xca, 0xf8, 0xdb, 0x76, 0x1d, 0x25);

// {079D7A3A-E23F-48d5-BF92-7D7A9FD273C6}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_GetName,
0x79d7a3a, 0xe23f, 0x48d5, 0xbf, 0x92, 0x7d, 0x7a, 0x9f, 0xd2, 0x73, 0xc6);

// {D7F92431-5E00-4f77-8A3F-70A7EF394127}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_OpenClusterResource,
0xd7f92431, 0x5e00, 0x4f77, 0x8a, 0x3f, 0x70, 0xa7, 0xef, 0x39, 0x41, 0x27);

// {DC2961C2-E31C-486d-8349-962FD670B688}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_OpenClusterResourcePending,
0xdc2961c2, 0xe31c, 0x486d, 0x83, 0x49, 0x96, 0x2f, 0xd6, 0x70, 0xb6, 0x88);

// {FA3957AC-F30C-4d67-8DBC-70D28C922A92}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceStateUnknown,
0xfa3957ac, 0xf30c, 0x4d67, 0x8d, 0xbc, 0x70, 0xd2, 0x8c, 0x92, 0x2a, 0x92);

// {C09CF48A-3D3D-4012-83DA-7191C9237BAE}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceOffline,
0xc09cf48a, 0x3d3d, 0x4012, 0x83, 0xda, 0x71, 0x91, 0xc9, 0x23, 0x7b, 0xae);

// {21A09A70-8EE2-4785-9DEC-97EDBEB45FE2}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceFailed,
0x21a09a70, 0x8ee2, 0x4785, 0x9d, 0xec, 0x97, 0xed, 0xbe, 0xb4, 0x5f, 0xe2);

// {DCD49407-576F-48f3-8458-D5B3A2C382A6}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_OnlineClusterResource_Failed,
0xdcd49407, 0x576f, 0x48f3, 0x84, 0x58, 0xd5, 0xb3, 0xa2, 0xc3, 0x82, 0xa6);

// {77F9FF91-5860-4d6c-862A-92B02116D7CB}
DEFINE_GUID( TASKID_HrPostCreateResourceAndDependents_GetClusterQuorumResource_Failed,
0x77f9ff91, 0x5860, 0x4d6c, 0x86, 0x2a, 0x92, 0xb0, 0x21, 0x16, 0xd7, 0xcb);

// {6CE388C2-A01C-4b5a-8AAD-F4FCF5EAAF06}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_SetClusterQuorumResource,
0x6ce388c2, 0xa01c, 0x4b5a, 0x8a, 0xad, 0xf4, 0xfc, 0xf5, 0xea, 0xaf, 0x6);

// {BB0551C3-CDA5-405f-A261-35B27FA5E0A7}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_SetClusterQuorumResource_Succeeded,
0xbb0551c3, 0xcda5, 0x405f, 0xa2, 0x61, 0x35, 0xb2, 0x7f, 0xa5, 0xe0, 0xa7);

// {058BFA08-E687-410b-BD86-E42E269E82ED}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_FormatMessage_SetQuorum,
0x58bfa08, 0xe687, 0x410b, 0xbd, 0x86, 0xe4, 0x2e, 0x26, 0x9e, 0x82, 0xed);

// {E93C6B14-2F68-43c7-94DA-9543000F4D07}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_GetAssociatedResource,
0xe93c6b14, 0x2f68, 0x43c7, 0x94, 0xda, 0x95, 0x43, 0x0, 0xf, 0x4d, 0x7);

// {A771D973-E9BA-4266-BF49-7A6F8475CFAA}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_Create_CPostCreateServices,
0xa771d973, 0xe9ba, 0x4266, 0xbf, 0x49, 0x7a, 0x6f, 0x84, 0x75, 0xcf, 0xaa);

// {A991E33C-D8F6-4281-A1EF-BEFA5BDE0A07}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_Create_CPostCreateServices_QI_ppcr,
0xa991e33c, 0xd8f6, 0x4281, 0xa1, 0xef, 0xbe, 0xfa, 0x5b, 0xde, 0xa, 0x7);

// {2C9F4269-5FA0-4506-91EA-FD29224F0A09}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_SetEntry,
0x2c9f4269, 0x5fa0, 0x4506, 0x91, 0xea, 0xfd, 0x29, 0x22, 0x4f, 0xa, 0x9);

// {FD517153-B577-420d-A6E6-0B5DE9C4E351}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_E_NOTIMPL,
0xfd517153, 0xb577, 0x420d, 0xa6, 0xe6, 0xb, 0x5d, 0xe9, 0xc4, 0xe3, 0x51);

// {FAFA10F6-1DFD-46d8-BD64-A649B29BF411}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_Failed,
0xfafa10f6, 0x1dfd, 0x46d8, 0xbd, 0x64, 0xa6, 0x49, 0xb2, 0x9b, 0xf4, 0x11);

// {D45B9470-45BB-4add-B05C-4BB5DE303EE0}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_Succeeded,
0xd45b9470, 0x45bb, 0x4add, 0xb0, 0x5c, 0x4b, 0xb5, 0xde, 0x30, 0x3e, 0xe0);

// {0EFCF386-D992-4223-B87F-849F6F3C47BD}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_NotNeeded,
0xefcf386, 0xd992, 0x4223, 0xb8, 0x7f, 0x84, 0x9f, 0x6f, 0x3c, 0x47, 0xbd);

// {1733454E-5747-4831-BCA7-11E0671A4FBA}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_GetCountOfDependents,
0x1733454e, 0x5747, 0x4831, 0xbc, 0xa7, 0x11, 0xe0, 0x67, 0x1a, 0x4f, 0xba);

// {B0D040AB-7FB3-4404-AC3E-1B15C61B4D0F}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_GetDependent,
0xb0d040ab, 0x7fb3, 0x4404, 0xac, 0x3e, 0x1b, 0x15, 0xc6, 0x1b, 0x4d, 0xf);

// {FAFF1E59-9012-4143-AFCE-69B953FD4FDD}
DEFINE_GUID( TASKID_Minor_HrNotifyMemberSetChangeListeners_CoCreate_StdComponentCategoriesMgr,
0xfaff1e59, 0x9012, 0x4143, 0xaf, 0xce, 0x69, 0xb9, 0x53, 0xfd, 0x4f, 0xdd);

// {9A84E38B-52C1-4591-982E-D6515FCB90C9}
DEFINE_GUID( TASKID_Minor_HrNotifyMemberSetChangeListeners_EnumClassesOfCategories,
0x9a84e38b, 0x52c1, 0x4591, 0x98, 0x2e, 0xd6, 0x51, 0x5f, 0xcb, 0x90, 0xc9);

// {A93FE316-0894-4a80-83A3-880962450ADA}
DEFINE_GUID( TASKID_Minor_HrNotifyMemberSetChangeListeners_Next,
0xa93fe316, 0x894, 0x4a80, 0x83, 0xa3, 0x88, 0x9, 0x62, 0x45, 0xa, 0xda);

// {59ADF6E8-3EBC-463d-BABF-0D9F1B363D9F}
DEFINE_GUID( TASKID_Minor_HrNotifyMemberSetChangeListeners_HrProcessMemberSetChangeListener,
0x59adf6e8, 0x3ebc, 0x463d, 0xba, 0xbf, 0xd, 0x9f, 0x1b, 0x36, 0x3d, 0x9f);

// {6D8CF7D7-B09C-42dd-946F-0E7BBD702C35}
DEFINE_GUID( TASKID_Minor_HrProcessMemberSetChangeListener_CoCreate_Listener,
0x6d8cf7d7, 0xb09c, 0x42dd, 0x94, 0x6f, 0xe, 0x7b, 0xbd, 0x70, 0x2c, 0x35);

// {497FDB97-5A16-46e7-9A10-E8ABFDBD42D2}
DEFINE_GUID( TASKID_Minor_HrProcessMemberSetChangeListener_Notify,
0x497fdb97, 0x5a16, 0x46e7, 0x9a, 0x10, 0xe8, 0xab, 0xfd, 0xbd, 0x42, 0xd2);

// {085E2A1D-335E-46a8-9F71-B83998C59C77}
DEFINE_GUID( TASKID_Minor_HrConfigureResTypes_CoCreate_CategoriesMgr,
0x85e2a1d, 0x335e, 0x46a8, 0x9f, 0x71, 0xb8, 0x39, 0x98, 0xc5, 0x9c, 0x77);

// {BD3CA031-912E-430e-8B99-1E0E457EAA26}
DEFINE_GUID( TASKID_Minor_HrConfigureResTypes_Enum,
0xbd3ca031, 0x912e, 0x430e, 0x8b, 0x99, 0x1e, 0xe, 0x45, 0x7e, 0xaa, 0x26);

// {EF9DF26D-748A-4b89-87F8-760F6CC903C0}
DEFINE_GUID( TASKID_Minor_HrConfigureResTypes_Next,
0xef9df26d, 0x748a, 0x4b89, 0x87, 0xf8, 0x76, 0xf, 0x6c, 0xc9, 0x3, 0xc0);

// {A06BDBAA-CC10-4e04-8C45-646CFB55E56E}
DEFINE_GUID( TASKID_Minor_HrConfigureResTypes_HrProcessResType,
0xa06bdbaa, 0xcc10, 0x4e04, 0x8c, 0x45, 0x64, 0x6c, 0xfb, 0x55, 0xe5, 0x6e);

// {13915CAB-E9E3-4e2c-8AEA-2EDDB6FB0589}
DEFINE_GUID( TASKID_Minor_HrProcessResType_CoCreate_ResTypeClsid,
0x13915cab, 0xe9e3, 0x4e2c, 0x8a, 0xea, 0x2e, 0xdd, 0xb6, 0xfb, 0x5, 0x89);

// {5E3C6D32-2631-4b13-8BDF-C644DC73EE2C}
DEFINE_GUID( TASKID_Minor_HrProcessResType_QI_pcci,
0x5e3c6d32, 0x2631, 0x4b13, 0x8b, 0xdf, 0xc6, 0x44, 0xdc, 0x73, 0xee, 0x2c);

// {264074E3-65E1-4d44-9A14-C4593C816F1F}
DEFINE_GUID( TASKID_Minor_HrProcessResType_Initialize,
0x264074e3, 0x65e1, 0x4d44, 0x9a, 0x14, 0xc4, 0x59, 0x3c, 0x81, 0x6f, 0x1f);

// {E01E4DBD-336F-40aa-B25B-708BB5EB2E62}
DEFINE_GUID( TASKID_Minor_HrProcessResType_GetTypeName,
0xe01e4dbd, 0x336f, 0x40aa, 0xb2, 0x5b, 0x70, 0x8b, 0xb5, 0xeb, 0x2e, 0x62);

// {5DC20322-81F1-4112-A1E9-C21B29CE11DA}
DEFINE_GUID( TASKID_Minor_HrProcessResType_AboutToConfigureType,
0x5dc20322, 0x81f1, 0x4112, 0xa1, 0xe9, 0xc2, 0x1b, 0x29, 0xce, 0x11, 0xda);

// {EE6D7073-3DCE-47c1-B6BC-5A70D5C07F8E}
DEFINE_GUID( TASKID_Minor_HrProcessResType_CommitChanges,
0xee6d7073, 0x3dce, 0x47c1, 0xb6, 0xbc, 0x5a, 0x70, 0xd5, 0xc0, 0x7f, 0x8e);

// {20952BFB-1BA0-4fa9-A29A-5AD71B917836}
DEFINE_GUID( TASKID_Minor_HrProcessResType_GetTypeGUID,
0x20952bfb, 0x1ba0, 0x4fa9, 0xa2, 0x9a, 0x5a, 0xd7, 0x1b, 0x91, 0x78, 0x36);

// {ADF325A5-1B9C-42eb-B450-E0982C13C145}
DEFINE_GUID( TASKID_Minor_HrProcessResType_HrMapResTypeGUIDToName,
0xadf325a5, 0x1b9c, 0x42eb, 0xb4, 0x50, 0xe0, 0x98, 0x2c, 0x13, 0xc1, 0x45);

// {2AC4FA49-4CFC-4abc-A501-B98A3FDB8FAD}
DEFINE_GUID( TASKID_Minor_HrProcessResType_NoGuid,
0x2ac4fa49, 0x4cfc, 0x4abc, 0xa5, 0x1, 0xb9, 0x8a, 0x3f, 0xdb, 0x8f, 0xad);

// {E6C5CB87-DB90-4ac7-AE72-1D33C009F11A}
DEFINE_GUID( TASKID_HrMapResTypeGUIDToName_InvalidArg,
0xe6c5cb87, 0xdb90, 0x4ac7, 0xae, 0x72, 0x1d, 0x33, 0xc0, 0x9, 0xf1, 0x1a);

// {905FE364-0D87-4196-A6BC-C380EA2E7162}
DEFINE_GUID( TASKID_HrMapResTypeGUIDToName_OutOfMemory_NewMap,
0x905fe364, 0xd87, 0x4196, 0xa6, 0xbc, 0xc3, 0x80, 0xea, 0x2e, 0x71, 0x62);

// {1CD5A0E3-A2F9-4981-87A6-B65F35EEDF0B}
DEFINE_GUID( TASKID_HrMapResTypeGUIDToName_OutOfMemory_TypeName,
0x1cd5a0e3, 0xa2f9, 0x4981, 0x87, 0xa6, 0xb6, 0x5f, 0x35, 0xee, 0xdf, 0xb);

// {B4AEF793-57B0-4ad5-ADCB-8D4778B55697}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_LoadString_LocateExistingQuorum,
0xb4aef793, 0x57b0, 0x4ad5, 0xad, 0xcb, 0x8d, 0x47, 0x78, 0xb5, 0x56, 0x97);

// {81A54EB8-B4C3-4390-982A-E6739D4D8D84}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_OutOfMemory,
0x81a54eb8, 0xb4c3, 0x4390, 0x98, 0x2a, 0xe6, 0x73, 0x9d, 0x4d, 0x8d, 0x84);

// {A42EFFD3-D165-4d05-81C5-201C43235CF9}
DEFINE_GUID( TASKID_Minor_HrGetCoreClusterResourceNames_GetResourceName,
0xa42effd3, 0xd165, 0x4d05, 0x81, 0xc5, 0x20, 0x1c, 0x43, 0x23, 0x5c, 0xf9);

// {8BE2BCE1-D605-4c5c-8D23-9F7BB90AD3E8}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_IP_SetName,
0x8be2bce1, 0xd605, 0x4c5c, 0x8d, 0x23, 0x9f, 0x7b, 0xb9, 0xa, 0xd3, 0xe8);

// {7EB2D7B4-6FE9-45e1-AB7E-D2A325C44068}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_IP_SetType,
0x7eb2d7b4, 0x6fe9, 0x45e1, 0xab, 0x7e, 0xd2, 0xa3, 0x25, 0xc4, 0x40, 0x68);

// {8587CA58-B046-42a6-8EE3-E7D6E23AC41B}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_IP_SetClassType,
0x8587ca58, 0xb046, 0x42a6, 0x8e, 0xe3, 0xe7, 0xd6, 0xe2, 0x3a, 0xc4, 0x1b);

// {1AA31CCC-12A4-409b-925B-67FDF399BD61}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_IP_SetFlags,
0x1aa31ccc, 0x12a4, 0x409b, 0x92, 0x5b, 0x67, 0xfd, 0xf3, 0x99, 0xbd, 0x61);

// {45148990-9648-4be0-8122-5B6FF302C7B7}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_IP_SetHResource,
0x45148990, 0x9648, 0x4be0, 0x81, 0x22, 0x5b, 0x6f, 0xf3, 0x2, 0xc7, 0xb7);

// {DB491103-3EE8-4d31-9F91-478548C9828E}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_SetName,
0xdb491103, 0x3ee8, 0x4d31, 0x9f, 0x91, 0x47, 0x85, 0x48, 0xc9, 0x82, 0x8e);

// {1A1EB096-74B3-4169-A14A-73FE0F710E7F}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_SetType,
0x1a1eb096, 0x74b3, 0x4169, 0xa1, 0x4a, 0x73, 0xfe, 0xf, 0x71, 0xe, 0x7f);

// {B5C400E7-0827-473b-B4B7-697976E7DA96}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_SetClassType,
0xb5c400e7, 0x827, 0x473b, 0xb4, 0xb7, 0x69, 0x79, 0x76, 0xe7, 0xda, 0x96);

// {C973FCA2-3E37-4a30-8B27-CBAABFDB5699}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_SetFlags,
0xc973fca2, 0x3e37, 0x4a30, 0x8b, 0x27, 0xcb, 0xaa, 0xbf, 0xdb, 0x56, 0x99);

// {4022DB05-0EC7-4bbf-B47F-BE6017529B2D}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_AddTypeDependency,
0x4022db05, 0xec7, 0x4bbf, 0xb4, 0x7f, 0xbe, 0x60, 0x17, 0x52, 0x9b, 0x2d);

// {F72888A8-AB7D-4e69-B602-84A1B3F850EC}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_SetHResource,
0xf72888a8, 0xab7d, 0x4e69, 0xb6, 0x2, 0x84, 0xa1, 0xb3, 0xf8, 0x50, 0xec);

// {1382A7B9-9E7F-49dd-99B1-7B71520E716C}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetName,
0x1382a7b9, 0x9e7f, 0x49dd, 0x99, 0xb1, 0x7b, 0x71, 0x52, 0xe, 0x71, 0x6c);

// {6859B087-B309-4b23-A9F7-89B201DCA838}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetType,
0x6859b087, 0xb309, 0x4b23, 0xa9, 0xf7, 0x89, 0xb2, 0x1, 0xdc, 0xa8, 0x38);

// {5C696EBC-E7F1-4386-9898-5EB5507D1BCD}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetClassType,
0x5c696ebc, 0xe7f1, 0x4386, 0x98, 0x98, 0x5e, 0xb5, 0x50, 0x7d, 0x1b, 0xcd);

// {34F4E188-A8C4-4148-9735-50EEA7D01CF7}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetFlags,
0x34f4e188, 0xa8c4, 0x4148, 0x97, 0x35, 0x50, 0xee, 0xa7, 0xd0, 0x1c, 0xf7);

// {072BD24E-AECF-4b6a-A5CE-CBE87D205FDC}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetHResource,
0x72bd24e, 0xaecf, 0x4b6a, 0xa5, 0xce, 0xcb, 0xe8, 0x7d, 0x20, 0x5f, 0xdc);

// {989E8A0F-8303-4f90-A86E-AE98F0EE3FF6}
DEFINE_GUID( TASKID_Minor_HrAddSpecialResource_SetName,
0x989e8a0f, 0x8303, 0x4f90, 0xa8, 0x6e, 0xae, 0x98, 0xf0, 0xee, 0x3f, 0xf6);

// {58878B7E-E298-48de-A2E5-C369A3FA4916}
DEFINE_GUID( TASKID_Minor_HrAddSpecialResource_SetType,
0x58878b7e, 0xe298, 0x48de, 0xa2, 0xe5, 0xc3, 0x69, 0xa3, 0xfa, 0x49, 0x16);

// {AA216E27-79AB-4d91-99B6-EBE8608E08A2}
DEFINE_GUID( TASKID_Minor_HrAddSpecialResource_SetClassType,
0xaa216e27, 0x79ab, 0x4d91, 0x99, 0xb6, 0xeb, 0xe8, 0x60, 0x8e, 0x8, 0xa2);

// {A482F18F-E935-4173-B5BE-72A2260BA118}
DEFINE_GUID( TASKID_Minor_HrAddSpecialResource_OutOfMemory,
0xa482f18f, 0xe935, 0x4173, 0xb5, 0xbe, 0x72, 0xa2, 0x26, 0xb, 0xa1, 0x18);

// {E7524063-8582-4e3e-85DA-0870546FBA78}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_GetName,
0xe7524063, 0x8582, 0x4e3e, 0x85, 0xda, 0x8, 0x70, 0x54, 0x6f, 0xba, 0x78);

// {365E90E9-EE39-4c5c-8F05-5D2F55F60CB1}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_CreateClusterResource,
0x365e90e9, 0xee39, 0x4c5c, 0x8f, 0x5, 0x5d, 0x2f, 0x55, 0xf6, 0xc, 0xb1);

// {80232E1F-A383-49dc-BC6F-FB5EC78591B4}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_CreateClusterResource_Successful,
0x80232e1f, 0xa383, 0x49dc, 0xbc, 0x6f, 0xfb, 0x5e, 0xc7, 0x85, 0x91, 0xb4);

// {48189324-673A-4fb6-9171-9C5939515EE1}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_FoundExistingResource,
0x48189324, 0x673a, 0x4fb6, 0x91, 0x71, 0x9c, 0x59, 0x39, 0x51, 0x5e, 0xe1);

// {9379E242-E26B-40ee-A025-0D3D7B525FD6}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_ChangeClusterResourceGroup,
0x9379e242, 0xe26b, 0x40ee, 0xa0, 0x25, 0xd, 0x3d, 0x7b, 0x52, 0x5f, 0xd6);

// {0466DF38-0715-43cf-B74D-6D055F316B1A}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_SetHResource,
0x466df38, 0x715, 0x43cf, 0xb7, 0x4d, 0x6d, 0x5, 0x5f, 0x31, 0x6b, 0x1a);

// {04B5E793-3A69-43e1-9FE8-8443FEAC725E}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_Configure,
0x4b5e793, 0x3a69, 0x43e1, 0x9f, 0xe8, 0x84, 0x43, 0xfe, 0xac, 0x72, 0x5e);

// {AC28D932-39DC-4504-A9E5-F650A12AABC5}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_LoadString_CreatingResource,
0xac28d932, 0x39dc, 0x4504, 0xa9, 0xe5, 0xf6, 0x50, 0xa1, 0x2a, 0xab, 0xc5);

// {F4A50885-A4B9-4c4d-B67C-9E4DD94A315E}
DEFINE_GUID( CLSID_TaskType,
0xf4a50885, 0xa4b9, 0x4c4d, 0xb6, 0x7c, 0x9e, 0x4d, 0xd9, 0x4a, 0x31, 0x5e);

// {FF5C9A64-4B2F-4f66-B20C-E0D1A5F29E2A}
DEFINE_GUID( TASKID_Minor_CreateGroups_Get_CoreClusterGroup,
0xff5c9a64, 0x4b2f, 0x4f66, 0xb2, 0xc, 0xe0, 0xd1, 0xa5, 0xf2, 0x9e, 0x2a);

// {008B56BA-4AAD-4250-9041-FB990433196D}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_IsLocalQuorum,
0x8b56ba, 0x4aad, 0x4250, 0x90, 0x41, 0xfb, 0x99, 0x4, 0x33, 0x19, 0x6d);

// {93FDC1E1-9DA2-4ac7-AF49-55F6D85E192E}
DEFINE_GUID( TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_InvalidParam,
0x93fdc1e1, 0x9da2, 0x4ac7, 0xaf, 0x49, 0x55, 0xf6, 0xd8, 0x5e, 0x19, 0x2e);

// {1715FCDF-7D0B-4fa2-AAE7-49655971303D}
DEFINE_GUID( TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_OfflineQuorum,
0x1715fcdf, 0x7d0b, 0x4fa2, 0xaa, 0xe7, 0x49, 0x65, 0x59, 0x71, 0x30, 0x3d);

// {9BD5019D-6488-405b-A814-A883939E7BBE}
DEFINE_GUID( TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_NotifPort,
0x9bd5019d, 0x6488, 0x405b, 0xa8, 0x14, 0xa8, 0x83, 0x93, 0x9e, 0x7b, 0xbe);

// {943E1145-36B7-4594-BFD3-409A0B83AB18}
DEFINE_GUID( TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_RegNotification,
0x943e1145, 0x36b7, 0x4594, 0xbf, 0xd3, 0x40, 0x9a, 0xb, 0x83, 0xab, 0x18);

// {67268D88-8CF6-4445-AF9E-6FA5D14B130F}
DEFINE_GUID( TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_TimeOut,
0x67268d88, 0x8cf6, 0x4445, 0xaf, 0x9e, 0x6f, 0xa5, 0xd1, 0x4b, 0x13, 0xf);

// {83260FA2-0E5D-43db-88CC-84E62A0E6C2B}
DEFINE_GUID( TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_OfflineQuorum2,
0x83260fa2, 0xe5d, 0x43db, 0x88, 0xcc, 0x84, 0xe6, 0x2a, 0xe, 0x6c, 0x2b);

// {1B465541-AB01-4e5b-B7A2-E24865B835D4}
DEFINE_GUID( TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_DeleteQuorum,
0x1b465541, 0xab01, 0x4e5b, 0xb7, 0xa2, 0xe2, 0x48, 0x65, 0xb8, 0x35, 0xd4);

// {401D2FE8-9A53-4cf9-935A-C97ADB986195}
DEFINE_GUID( TASKID_Minor_CResourceType_GetTypeName_InvalidParam,
0x401d2fe8, 0x9a53, 0x4cf9, 0x93, 0x5a, 0xc9, 0x7a, 0xdb, 0x98, 0x61, 0x95);

// {FC0E4B75-F195-4723-979B-5069BFDD1B57}
DEFINE_GUID( TASKID_Minor_CResourceType_GetTypeName_AllocTypeName,
0xfc0e4b75, 0xf195, 0x4723, 0x97, 0x9b, 0x50, 0x69, 0xbf, 0xdd, 0x1b, 0x57);

// {D4B3DE52-4C0A-4f1b-A6F6-AE95AD01700A}
DEFINE_GUID( TASKID_Minor_CResourceType_GetTypeGUID_InvalidParam,
0xd4b3de52, 0x4c0a, 0x4f1b, 0xa6, 0xf6, 0xae, 0x95, 0xad, 0x1, 0x70, 0xa);


// {9C7A0060-5607-4962-9643-F1FD7121A1D6}
DEFINE_GUID( TASKID_Minor_CResourceEntry_Configure_Private,
0x9c7a0060, 0x5607, 0x4962, 0x96, 0x43, 0xf1, 0xfd, 0x71, 0x21, 0xa1, 0xd6);

// {F8AA441A-FC0F-43f9-805C-3DB4E9D5ED0C}
DEFINE_GUID( TASKID_Minor_CResourceEntry_Configure_Common,
0xf8aa441a, 0xfc0f, 0x43f9, 0x80, 0x5c, 0x3d, 0xb4, 0xe9, 0xd5, 0xed, 0xc);

// {C01B49B7-41E2-4701-9EDA-FBDF64C7F84B}
DEFINE_GUID( TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_OpenRegistry,
0xc01b49b7, 0x41e2, 0x4701, 0x9e, 0xda, 0xfb, 0xdf, 0x64, 0xc7, 0xf8, 0x4b);

// {DC895995-C114-466f-BCDE-E0D4A43F7048}
DEFINE_GUID( TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_ReadRegistry,
0xdc895995, 0xc114, 0x466f, 0xbc, 0xde, 0xe0, 0xd4, 0xa4, 0x3f, 0x70, 0x48);

// {DABF58E4-6A82-4a1e-9797-EC97F2D321D0}
DEFINE_GUID( TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_AllocateMem,
0xdabf58e4, 0x6a82, 0x4a1e, 0x97, 0x97, 0xec, 0x97, 0xf2, 0xd3, 0x21, 0xd0);

// {B7F2C945-0F1F-466e-9E84-9F7C40134D0F}
DEFINE_GUID( TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_ReadRegistry2,
0xb7f2c945, 0xf1f, 0x466e, 0x9e, 0x84, 0x9f, 0x7c, 0x40, 0x13, 0x4d, 0xf);

// {7BDC020C-A423-451f-A8EF-D03459700CBE}
DEFINE_GUID( TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_MatchCriterion,
0x7bdc020c, 0xa423, 0x451f, 0xa8, 0xef, 0xd0, 0x34, 0x59, 0x70, 0xc, 0xbe);

// {C7952E03-60C0-4a88-8C5F-215B99629C60}
DEFINE_GUID( TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_FindFile,
0xc7952e03, 0x60c0, 0x4a88, 0x8c, 0x5f, 0x21, 0x5b, 0x99, 0x62, 0x9c, 0x60);

// {88069043-4C43-4b15-AF52-517D0B4DB539}
DEFINE_GUID( TASKID_Minor_CResTypeServices_SetParameters_ClusPtr_Invalid,
0x88069043, 0x4c43, 0x4b15, 0xaf, 0x52, 0x51, 0x7d, 0xb, 0x4d, 0xb5, 0x39);

// {734581B5-16CC-4bbf-BCFF-D84707BE97AF}
DEFINE_GUID( TASKID_Minor_CResTypeServices_Create_Cluster_Handle,
0x734581b5, 0x16cc, 0x4bbf, 0xbc, 0xff, 0xd8, 0x47, 0x7, 0xbe, 0x97, 0xaf);

// {D3B10E74-4862-47ea-ABA5-E5E9CBA22662}
DEFINE_GUID( TASKID_Minor_CResTypeServices_Create_Cluster_Handle_NULL,
0xd3b10e74, 0x4862, 0x47ea, 0xab, 0xa5, 0xe5, 0xe9, 0xcb, 0xa2, 0x26, 0x62);

// {4836C986-C2E9-4b30-9DDD-3F05DF4EDDA2}
DEFINE_GUID( TASKID_Minor_CResTypeServices_Create_ResType_Invalid,
0x4836c986, 0xc2e9, 0x4b30, 0x9d, 0xdd, 0x3f, 0x5, 0xdf, 0x4e, 0xdd, 0xa2);

// {40C96DC8-54CB-4a85-BBD4-02EEBD78F4AA}
DEFINE_GUID( TASKID_Minor_CResTypeServices_Create_Commit_Mode,
0x40c96dc8, 0x54cb, 0x4a85, 0xbb, 0xd4, 0x2, 0xee, 0xbd, 0x78, 0xf4, 0xaa);

// {7585C207-BB23-4825-99A1-7ED2039F0790}
DEFINE_GUID( TASKID_Minor_CResTypeServices_Create_Resource_Type,
0x7585c207, 0xbb23, 0x4825, 0x99, 0xa1, 0x7e, 0xd2, 0x3, 0x9f, 0x7, 0x90);

// {2A23BDAB-328C-4bdd-AB63-2176572DC2D6}
DEFINE_GUID( TASKID_Minor_CResTypeServices_RegisterAdminExtensions_Cluster_Handle,
0x2a23bdab, 0x328c, 0x4bdd, 0xab, 0x63, 0x21, 0x76, 0x57, 0x2d, 0xc2, 0xd6);

// {E2F87E53-0453-4315-8E33-8530A12331B7}
DEFINE_GUID( TASKID_Minor_CResTypeServices_RegisterAdminExtensions_Cluster_Handle_NULL,
0xe2f87e53, 0x453, 0x4315, 0x8e, 0x33, 0x85, 0x30, 0xa1, 0x23, 0x31, 0xb7);

// {634A5E7C-C11E-440b-A318-507BEB0FB609}
DEFINE_GUID( TASKID_Minor_CResTypeServices_RegisterAdminExtensions_ResType_Invalid,
0x634a5e7c, 0xc11e, 0x440b, 0xa3, 0x18, 0x50, 0x7b, 0xeb, 0xf, 0xb6, 0x9);

// {62D5E1F4-5A4D-4e24-AB34-5C028CD68E02}
DEFINE_GUID( TASKID_Minor_CResTypeServices_RegisterAdminExtensions_Alloc_Mem,
0x62d5e1f4, 0x5a4d, 0x4e24, 0xab, 0x34, 0x5c, 0x2, 0x8c, 0xd6, 0x8e, 0x2);

// {40D5DE8A-661C-4208-86E1-5EA636FE2544}
DEFINE_GUID( TASKID_Minor_CResTypeServices_RegisterAdminExtensions_ClassId,
0x40d5de8a, 0x661c, 0x4208, 0x86, 0xe1, 0x5e, 0xa6, 0x36, 0xfe, 0x25, 0x44);

// {6562CE10-BF65-4eac-AB52-1ED002D129F4}
DEFINE_GUID( TASKID_Minor_CResTypeServices_RegisterAdminExtensions_Alloc_Mem2,
0x6562ce10, 0xbf65, 0x4eac, 0xab, 0x52, 0x1e, 0xd0, 0x2, 0xd1, 0x29, 0xf4);

// {BB79EF82-C259-44e7-B7FF-D63DCBDD6FEC}
DEFINE_GUID( TASKID_Minor_CResTypeServices_RegisterAdminExtensions_Configure,
0xbb79ef82, 0xc259, 0x44e7, 0xb7, 0xff, 0xd6, 0x3d, 0xcb, 0xdd, 0x6f, 0xec);

// {BC7F9911-52CA-41aa-B299-5C03AD9024E1}
DEFINE_GUID( TASKID_Minor_CPostCfgManager_CommitChanges_TypeSafeQI,
0xbc7f9911, 0x52ca, 0x41aa, 0xb2, 0x99, 0x5c, 0x3, 0xad, 0x90, 0x24, 0xe1);

// {A1825B45-7C6C-44c2-AF59-F79F92B776F3}
DEFINE_GUID( TASKID_Minor_CPostCfgManager_CommitChanges_Initialize,
0xa1825b45, 0x7c6c, 0x44c2, 0xaf, 0x59, 0xf7, 0x9f, 0x92, 0xb7, 0x76, 0xf3);

// {BD2C8DAE-B4BC-4e2d-87F3-ACF0072EC22F}
DEFINE_GUID( TASKID_Minor_PreCreate_CResourceEntry,
0xbd2c8dae, 0xb4bc, 0x4e2d, 0x87, 0xf3, 0xac, 0xf0, 0x7, 0x2e, 0xc2, 0x2f);

// {0F794FDA-33E3-46ca-AF13-48979C8950D6}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_CResourceEntry,
0xf794fda, 0x33e3, 0x46ca, 0xaf, 0x13, 0x48, 0x97, 0x9c, 0x89, 0x50, 0xd6);

// {706D8B92-C020-48af-9BB6-2E01A3A4B0BE}
DEFINE_GUID( TASKID_Minor_HrAddSpecialResource_CResourceEntry,
0x706d8b92, 0xc020, 0x48af, 0x9b, 0xb6, 0x2e, 0x1, 0xa3, 0xa4, 0xb0, 0xbe);

// {5B3561D3-BC25-4934-8D39-FD7516F720F5}
DEFINE_GUID( TASKID_Minor_EvictCleanupResources_Starting,
0x5b3561d3, 0xbc25, 0x4934, 0x8d, 0x39, 0xfd, 0x75, 0x16, 0xf7, 0x20, 0xf5);

// {4F922103-5B9B-4c44-AA7E-7A66CEB0F350}
DEFINE_GUID( TASKID_Minor_EvictCleanup_Reset,
0x4f922103, 0x5b9b, 0x4c44, 0xaa, 0x7e, 0x7a, 0x66, 0xce, 0xb0, 0xf3, 0x50);

// {8AF38ACB-3FAF-4637-B188-4DF43A183217}
DEFINE_GUID( TASKID_Minor_EvictCleanup_EnumResources_Next,
0x8af38acb, 0x3faf, 0x4637, 0xb1, 0x88, 0x4d, 0xf4, 0x3a, 0x18, 0x32, 0x17);

// {470809EF-5684-4d9f-88AE-9EAB93502B3F}
DEFINE_GUID( TASKID_Minor_EvictCleanup_EnumResources_GetName,
0x470809ef, 0x5684, 0x4d9f, 0x88, 0xae, 0x9e, 0xab, 0x93, 0x50, 0x2b, 0x3f);

// {D5F817EC-6447-4d35-AE40-A608DC9C08CB}
DEFINE_GUID( TASKID_Minor_EvictCleanup_EnumResources_QI_pccmrc,
0xd5f817ec, 0x6447, 0x4d35, 0xae, 0x40, 0xa6, 0x8, 0xdc, 0x9c, 0x8, 0xcb);

// {20E568F2-840D-468e-8810-61E42D3EEDF2}
DEFINE_GUID( TASKID_Minor_EvictCleanup_E_NOTIMPL,
0x20e568f2, 0x840d, 0x468e, 0x88, 0x10, 0x61, 0xe4, 0x2d, 0x3e, 0xed, 0xf2);

// {F9FB4A99-494E-4626-9B1D-33EED7967FAE}
DEFINE_GUID( TASKID_Minor_Resource_Failed_Evict,
0xf9fb4a99, 0x494e, 0x4626, 0x9b, 0x1d, 0x33, 0xee, 0xd7, 0x96, 0x7f, 0xae);

// {F354B83C-B3E0-4c40-B119-B8967707BFA9}
DEFINE_GUID( TASKID_Minor_EvictCleanup_Succeeded,
0xf354b83c, 0xb3e0, 0x4c40, 0xb1, 0x19, 0xb8, 0x96, 0x77, 0x7, 0xbf, 0xa9);

// {DF02F233-31DD-4c00-8D7B-8AB9F1AE8540}
DEFINE_GUID( TASKID_Minor_EvictCleanupResources_Finishing,
0xdf02f233, 0x31dd, 0x4c00, 0x8d, 0x7b, 0x8a, 0xb9, 0xf1, 0xae, 0x85, 0x40);

// {1080E6D1-CA8D-467e-A5F6-F7B554D650C9}
DEFINE_GUID( TASKID_Minor_Configuring_Generic_Script_Resource_Type,
0x1080e6d1, 0xca8d, 0x467e, 0xa5, 0xf6, 0xf7, 0xb5, 0x54, 0xd6, 0x50, 0xc9 );

// {64157205-3ECC-4880-B1A4-1BA9EB82BDD7}
DEFINE_GUID( TASKID_Minor_Configuring_Majority_Node_Set_Resource_Type,
0x64157205, 0x3ecc, 0x4880, 0xb1, 0xa4, 0x1b, 0xa9, 0xeb, 0x82, 0xbd, 0xd7);

// {4F6BD1A1-9440-4d4c-A9E0-9943E7B34D30}
DEFINE_GUID( TASKID_Minor_Creating_Resource,
0x4f6bd1a1, 0x9440, 0x4d4c, 0xa9, 0xe0, 0x99, 0x43, 0xe7, 0xb3, 0x4d, 0x30 );

// {1E981583-8F20-4c94-82B8-AD10043293CA}
DEFINE_GUID( TASKID_Minor_Locate_Existing_Quorum_Device,
0x1e981583, 0x8f20, 0x4c94, 0x82, 0xb8, 0xad, 0x10, 0x4, 0x32, 0x93, 0xca );

// {16C4CB07-F3A0-4b16-8064-167810D876D0}
DEFINE_GUID( TASKID_Minor_Delete_LocalQuorum,
0x16c4cb07, 0xf3a0, 0x4b16, 0x80, 0x64, 0x16, 0x78, 0x10, 0xd8, 0x76, 0xd0 );

// {A0293F49-7721-4a0e-B59D-F7BCA0DB790A}
DEFINE_GUID( TASKID_Minor_Set_Quorum_Device,
0xa0293f49, 0x7721, 0x4a0e, 0xb5, 0x9d, 0xf7, 0xbc, 0xa0, 0xdb, 0x79, 0xa );

// {58C977AB-7B70-4d9e-988C-F521DA5F3829}
DEFINE_GUID( TASKID_Minor_Starting_Resources,
0x58c977ab, 0x7b70, 0x4d9e, 0x98, 0x8c, 0xf5, 0x21, 0xda, 0x5f, 0x38, 0x29 );

// {0C08485E-D16A-4a20-9E2C-B5D608F085C0}
DEFINE_GUID( TASKID_Minor_Resource_Failed_PostCreate,
0xc08485e, 0xd16a, 0x4a20, 0x9e, 0x2c, 0xb5, 0xd6, 0x8, 0xf0, 0x85, 0xc0 );

// {FBF36AFB-D025-4552-BA42-F3B462B66F77}
DEFINE_GUID( TASKID_Minor_Resource_Failed_PreCreate,
0xfbf36afb, 0xd025, 0x4552, 0xba, 0x42, 0xf3, 0xb4, 0x62, 0xb6, 0x6f, 0x77 );

// {C4F4E13D-55BB-4c43-A0FD-7BFF6E620F52}
DEFINE_GUID( TASKID_Minor_Querying_For_Resource_Dependencies,
0xc4f4e13d, 0x55bb, 0x4c43, 0xa0, 0xfd, 0x7b, 0xff, 0x6e, 0x62, 0xf, 0x52 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\grouphandle.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      GroupHandle.cpp
//
//  Description:
//      Object Manager implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "GroupHandle.h"

DEFINE_THISCLASS("CGroupHandle")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CGroupHandle::S_HrCreateInstance(
//      CGroupHandle ** ppunkOut,
//      HGROUP      hGroupIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CGroupHandle::S_HrCreateInstance(
    CGroupHandle ** ppunkOut,
    HGROUP      hGroupIn
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    CGroupHandle *  pgh = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pgh = new CGroupHandle;
    if ( pgh == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    hr = THR( pgh->HrInit( hGroupIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    *ppunkOut = pgh;
    (*ppunkOut)->AddRef();

Cleanup:

    if ( pgh != NULL )
    {
        pgh->Release();
    }

    HRETURN( hr );

} //*** CGroupHandle::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CGroupHandle::CGroupHandle
//
//////////////////////////////////////////////////////////////////////////////
CGroupHandle::CGroupHandle( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CGroupHandle::CGroupHandle

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CGroupHandle::HrInit( 
//      HGROUP hGroupIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CGroupHandle::HrInit( 
    HGROUP hGroupIn 
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IPrivateGroupHandle
    Assert( m_hGroup == NULL );

    m_hGroup = hGroupIn;

    HRETURN( hr );

} //*** CGroupHandle::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CGroupHandle::~CGroupHandle
//
//////////////////////////////////////////////////////////////////////////////
CGroupHandle::~CGroupHandle( void )
{
    TraceFunc( "" );

    if ( m_hGroup != NULL )
    {
        CloseClusterGroup( m_hGroup );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CGroupHandle::~CGroupHandle


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupHandle::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CGroupHandle::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IUnknown * >( this );
    } // if: IUnknown
#if 0
    else if ( IsEqualIID( riidIn, IID_IGroupHandle ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IGroupHandle, this, 0 );
    } // else if: IGroupHandle
#endif
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CGroupHandle::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CGroupHandle::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CGroupHandle::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CGroupHandle::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CGroupHandle::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CGroupHandle::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CGroupHandle::Release


//****************************************************************************
//
//  IPrivateGroupHandle
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CGroupHandle::SetHandle( 
//      HGROUP hGroupIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CGroupHandle::SetHandle( 
    HGROUP hGroupIn 
    )
{
    TraceFunc( "[IPrivateGroupHandle]" );

    HRESULT hr = S_OK;

    m_hGroup = hGroupIn;

    HRETURN( hr );

} //*** CGroupHandle::SetHandle

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CGroupHandle::GetHandle( 
//      HGROUP * phGroupOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CGroupHandle::GetHandle( 
    HGROUP * phGroupOut 
    )
{
    TraceFunc( "[IPrivateGroupHandle]" );

    HRESULT hr = S_OK;

    Assert( phGroupOut != NULL );

    *phGroupOut = m_hGroup;

    HRETURN( hr );

} //*** CGroupHandle::GetHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\postcfgmgr.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      PostCfgManager.cpp
//
//  Description:
//      CPostCfgManager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB)     09-JUN-2000
//      Ozan Ozhan    (OzanO)     10-JUN-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "Guids.h"
#include <clusudef.h>
#include "GroupHandle.h"
#include "ResourceEntry.h"
#include "IPostCfgManager.h"
#include "IPrivatePostCfgResource.h"
#include "PostCfgMgr.h"
#include "CreateServices.h"
#include "PostCreateServices.h"
#include "PreCreateServices.h"
#include "ResTypeServices.h"
#include "..\Wizard\Resource.h"
#include "ClusCfgPrivate.h"
#include <ResApi.h>
#include <ClusterUtils.h>

DEFINE_THISCLASS("CPostCfgManager")

#define RESOURCE_INCREMENT  25

//
//  Failure code.
//

#define SSR_LOG_ERR( _major, _minor, _hr, _msg ) \
    {   \
        THR( SendStatusReport( m_bstrNodeName, _major, _minor, 0, 0, 0, _hr, _msg, NULL, NULL ) );   \
    }

#define SSR_LOG1( _major, _minor, _hr, _fmt, _bstr, _arg1 ) \
    {   \
        HRESULT hrTemp; \
        THR( HrFormatStringIntoBSTR( _fmt, &_bstr, _arg1 ) ); \
        hrTemp = THR( SendStatusReport( m_bstrNodeName, _major, _minor, 0, 1, 1, _hr, _bstr, NULL, NULL ) );   \
        if ( FAILED( hrTemp ) )\
        {   \
            _hr = hrTemp;   \
        }   \
    }

#define SSR_LOG2( _major, _minor, _hr, _fmt, _bstr, _arg1, _arg2 ) \
    {   \
        HRESULT hrTemp; \
        THR( HrFormatStringIntoBSTR( _fmt, &_bstr, _arg1, _arg2 ) ); \
        hrTemp = THR( SendStatusReport( m_bstrNodeName, _major, _minor, 0, 1, 1, _hr, _bstr, NULL, NULL ) );   \
        if ( FAILED( hrTemp ) )\
        {   \
            _hr = hrTemp;   \
        }   \
    }


//
// Structure that holds the mapping for well known resource types.
//

struct SResTypeGUIDPtrAndName
{
    const GUID *    m_pcguidTypeGUID;
    const WCHAR *   m_pszTypeName;
};


// Mapping of well known resource type GUIDs to the type names.
const SResTypeGUIDPtrAndName gc_rgWellKnownResTypeMap[] =
{
    {
        &RESTYPE_PhysicalDisk,
        CLUS_RESTYPE_NAME_PHYS_DISK
    },
    {
        &RESTYPE_IPAddress,
        CLUS_RESTYPE_NAME_IPADDR
    },
    {
        &RESTYPE_NetworkName,
        CLUS_RESTYPE_NAME_NETNAME
    },
    {
        &RESTYPE_LocalQuorum,
        CLUS_RESTYPE_NAME_LKQUORUM
    }
};

// Size of the above array.
const int gc_cWellKnownResTypeMapSize = ARRAYSIZE( gc_rgWellKnownResTypeMap );


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CPostCfgManager *   ppcm = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    ppcm = new CPostCfgManager;
    if ( ppcm == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( ppcm->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ppcm->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ppcm != NULL )
    {
        ppcm->Release();
    }

    HRETURN( hr );

} //*** CPostCfgManager::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CPostCfgManager::CPostCfgManager
//
//////////////////////////////////////////////////////////////////////////////
CPostCfgManager::CPostCfgManager( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CPostCfgManager::CPostCfgManager

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPostCfgManager::HrInit
//
//  Description:
//      Initialize the object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK    - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrInit( void )
{
    TraceFunc( "" );

    ULONG idxMapEntry;

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    Assert( m_pcccb == NULL );
    Assert( m_lcid == 0 );

    //  IPostCfgManager
    Assert( m_peccmr == NULL );
    Assert( m_pccci == NULL );

    Assert( m_cAllocedResources == 0 );
    Assert( m_cResources == 0 );
    Assert( m_rgpResources == NULL );

    Assert( m_idxIPAddress == 0 );
    Assert( m_idxClusterName == 0 );
    Assert( m_idxQuorumResource == 0 );
    Assert( m_idxLastStorage == 0 );

    Assert( m_hCluster == NULL );

    Assert( m_pgnResTypeGUIDNameMap == NULL );
    Assert( m_idxNextMapEntry == 0 );
    Assert( m_cMapSize == 0 );
    Assert( m_ecmCommitChangesMode == cmUNKNOWN );

    m_cNetName = 1;
    m_cIPAddress = 1;

    // Set the boolean flag, m_fIsQuorumChanged to FALSE.
    m_fIsQuorumChanged = FALSE;


    //  Default allocation for mappings
    m_cMapSize = 20;
    m_pgnResTypeGUIDNameMap = new SResTypeGUIDAndName[ m_cMapSize ];
    if ( m_pgnResTypeGUIDNameMap == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_Init_OutOfMemory
            , hr
            , L"Out of memory"
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_Init_OutOfMemory
            , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
            , IDS_REF_MINOR_ERROR_OUT_OF_MEMORY
            , hr
            );

        goto Cleanup;
    }

    // Prefill the resource type GUID to name map with well known entries.
    for ( idxMapEntry = 0; idxMapEntry < gc_cWellKnownResTypeMapSize; ++idxMapEntry )
    {
        hr = THR(
            HrMapResTypeGUIDToName(
                  *gc_rgWellKnownResTypeMap[ idxMapEntry ].m_pcguidTypeGUID
                , gc_rgWellKnownResTypeMap [ idxMapEntry ].m_pszTypeName
                )
            );

        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_Init_MapResTypeGuidToName
                , hr
                , L"Mapping resource type GUID to name failed."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG1(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_INIT_MAPRESTYPEGUIDTONAME
                , IDS_REF_MINOR_INIT_MAPRESTYPEGUIDTONAME
                , hr
                , gc_rgWellKnownResTypeMap [ idxMapEntry ].m_pszTypeName
                );
            break;
        } // if: there was an error creating a mapping
    } // for

    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CPostCfgManager::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CPostCfgManager::~CPostCfgManager
//
//////////////////////////////////////////////////////////////////////////////
CPostCfgManager::~CPostCfgManager( void )
{
    TraceFunc( "" );

    ULONG idxMapEntry;

    if ( m_peccmr != NULL )
    {
        m_peccmr->Release();
    }

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pccci != NULL )
    {
        m_pccci->Release();
    }

    if ( m_rgpResources != NULL )
    {
        while ( m_cAllocedResources  != 0 )
        {
            m_cAllocedResources --;
            delete m_rgpResources[ m_cAllocedResources ];
        }

        TraceFree( m_rgpResources );
    }

    if ( m_hCluster != NULL )
    {
        CloseCluster( m_hCluster );
    }

    // Free the resource type GUID to name map entries
    for ( idxMapEntry = 0; idxMapEntry < m_idxNextMapEntry; ++idxMapEntry )
    {
        delete m_pgnResTypeGUIDNameMap[ idxMapEntry ].m_pszTypeName;
    } // for: iterate through the map, freeing each entry

    // Free the map itself.
    delete [] m_pgnResTypeGUIDNameMap;

    TraceSysFreeString( m_bstrNodeName );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CPostCfgManager::~CPostCfgManager


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPostCfgManager::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPostCfgManager::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IPostCfgManager * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IPostCfgManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IPostCfgManager, this, 0 );
    } // else if: IPostCfgManager
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CPostCfgManager::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPostCfgManager::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CPostCfgManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CPostCfgManager::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPostCfgManager::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CPostCfgManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CPostCfgManager::Release


//****************************************************************************
//
//  IClusCfgInitialize
//
//****************************************************************************


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPostCfgManager::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      punkCallbackIn
//          Pointer to the IUnknown interface of a component that implements
//          the IClusCfgCallback interface.
//
//      lcidIn
//          Locale id for this component.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPostCfgManager::Initialize(
      IUnknown *   punkCallbackIn
    , LCID         lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );

    HRESULT hr = S_OK;

    IClusCfgCallback * pcccb = NULL;

    if ( punkCallbackIn != NULL )
    {
        hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &pcccb ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_Initialize_QI, hr, L"Failed QI for IClusCfgCallback." );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_Initialize_QI
                , IDS_TASKID_MINOR_ERROR_INIT_POSTCFGMGR
                , IDS_REF_MINOR_ERROR_INIT_POSTCFGMGR
                , hr
                );

            goto Cleanup;
        }
    }

    m_lcid = lcidIn;

    //  Release any previous callback.
    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    //  Give ownership away
    m_pcccb = pcccb;
    pcccb = NULL;

#if defined(DEBUG)
    if ( m_pcccb != NULL )
    {
        m_pcccb = TraceInterface( L"CPostCfgManager!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );
    }
#endif // DEBUG

Cleanup:
    if ( pcccb != NULL )
    {
        pcccb->Release();
    }

    HRETURN( hr );

} //*** CPostCfgManager::Initialize


//****************************************************************************
//
//  IPostCfgManager
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CPostCfgManager::CommitChanges(
//      IEnumClusCfgManagedResources    * peccmrIn,
//      IClusCfgClusterInfo *             pccciIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPostCfgManager::CommitChanges(
    IEnumClusCfgManagedResources    * peccmrIn,
    IClusCfgClusterInfo *             pccciIn
    )
{
    TraceFunc( "[IPostCfgManager]" );

    HRESULT                                 hr;
    DWORD                                   dw;
    IClusCfgResTypeServicesInitialize *     pccrtsiResTypeServicesInit = NULL;
    IClusCfgInitialize *                    pcci = NULL;
    //  Validate parameters
    Assert( peccmrIn != NULL );
    Assert( pccciIn != NULL );

    //
    //  Grab our interfaces.
    //

    if ( m_peccmr != NULL )
    {
        m_peccmr->Release();
    }
    hr = THR( peccmrIn->TypeSafeQI( IEnumClusCfgManagedResources, &m_peccmr ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_CommitChanges_QI_Resources, hr, L"Failed QI for IEnumClusCfgManagedResources." );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CommitChanges_QI_Resources
            , IDS_TASKID_MINOR_ERROR_COMMIT_CHANGES
            , IDS_REF_MINOR_ERROR_COMMIT_CHANGES
            , hr
            );

        goto Cleanup;
    }

    if ( m_pccci != NULL )
    {
        m_pccci->Release();
    }
    hr = THR( pccciIn->TypeSafeQI( IClusCfgClusterInfo, &m_pccci ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_CommitChanges_QI_ClusterInfo, hr, L"Failed QI for IClusCfgClusterInfo." );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CommitChanges_QI_ClusterInfo
            , IDS_TASKID_MINOR_ERROR_COMMIT_CHANGES
            , IDS_REF_MINOR_ERROR_COMMIT_CHANGES
            , hr
            );

        goto Cleanup;
    }

    //
    // Are we creating, adding nodes, or have we been evicted?
    //

    hr = STHR( pccciIn->GetCommitMode( &m_ecmCommitChangesMode ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_CommitChanges_GetCommitMode, hr, L"Failed to get commit mode" );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CommitChanges_GetCommitMode
            , IDS_TASKID_MINOR_ERROR_COMMIT_MODE
            , IDS_REF_MINOR_ERROR_COMMIT_MODE
            , hr
            );

        goto Cleanup;
    }

    //
    // Create an instance of the resource type services component
    //
    hr = THR(
        HrCoCreateInternalInstance(
              CLSID_ClusCfgResTypeServices
            , NULL
            , CLSCTX_INPROC_SERVER
            , __uuidof( pccrtsiResTypeServicesInit )
            , reinterpret_cast< void ** >( &pccrtsiResTypeServicesInit )
            )
        );

    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_CommitChanges_CoCreate_ResTypeService
            , hr
            , L"[PC-PostCfg] Error occurred trying to create the resource type services component"
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CommitChanges_CoCreate_ResTypeService
            , IDS_TASKID_MINOR_ERROR_CREATE_RESOURCE_SERVICE
            , IDS_REF_MINOR_ERROR_CREATE_RESOURCE_SERVICE
            , hr
            );

        goto Cleanup;
    } // if: we could not create the resource type services component

    hr = THR( pccrtsiResTypeServicesInit->TypeSafeQI( IClusCfgInitialize, &pcci ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_CPostCfgManager_CommitChanges_TypeSafeQI
            , hr
            , L"[PC-PostCfg] Error occurred trying to QI for IClusCfgInitialize."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CPostCfgManager_CommitChanges_TypeSafeQI
            , IDS_TASKID_MINOR_ERROR_GET_ICLUSCFGINIT
            , IDS_REF_MINOR_ERROR_GET_ICLUSCFGINIT
            , hr
            );

        goto Cleanup;
    }

    hr = THR( pcci->Initialize( static_cast< IClusCfgCallback * >( this ) , m_lcid ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_CPostCfgManager_CommitChanges_Initialize
            , hr
            , L"[PC-PostCfg] Error occurred trying to call of Initialize function of IClusCfgInitialize."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CPostCfgManager_CommitChanges_Initialize
            , IDS_TASKID_MINOR_ERROR_CALL_INITIALIZE
            , IDS_REF_MINOR_ERROR_CALL_INITIALIZE
            , hr
            );

        goto Cleanup;
    }

    // This interface is no longer needed.
    pcci->Release();
    pcci = NULL;

    // Initialize the resource type services component.
    hr = THR( pccrtsiResTypeServicesInit->SetParameters( m_pccci ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_CommitChanges_SetParameters
            , hr
            , L"[PC-PostCfg] Error occurred trying to initialize the resource type services component."
            );

        STATUS_REPORT_REF_POSTCFG(
             TASKID_Major_Configure_Resources
           , TASKID_Minor_CommitChanges_SetParameters
           , IDS_TASKID_MINOR_ERROR_INIT_RESOURCE_SERVICE
           , IDS_REF_MINOR_ERROR_INIT_RESOURCE_SERVICE
           , hr
          );
        goto Cleanup;
    } // if: we could not initialize the resource type services component

    if ( ( m_ecmCommitChangesMode == cmCREATE_CLUSTER ) || ( m_ecmCommitChangesMode == cmADD_NODE_TO_CLUSTER ) )
    {
        //
        //  Make sure we have all we need to be successful!
        //

        if ( m_hCluster == NULL )
        {
            m_hCluster = OpenCluster( NULL );
            if ( m_hCluster == NULL )
            {
                dw = GetLastError();
                hr = HRESULT_FROM_WIN32( TW32( dw ) );

                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_CommitChanges_OpenCluster
                    , hr
                    , L"[PC-PostCfg] Failed to get cluster handle. Aborting."
                    );

                STATUS_REPORT_REF_POSTCFG(
                      TASKID_Major_Configure_Resources
                    , TASKID_Minor_CommitChanges_OpenCluster
                    , IDS_TASKID_MINOR_ERROR_CLUSTER_HANDLE
                    , IDS_REF_MINOR_ERROR_CLUSTER_HANDLE
                    , hr
                    );

                goto Cleanup;
            }
        } // if: cluster not open yet

        //
        // Configure resource types.
        //
        hr = THR( HrConfigureResTypes( pccrtsiResTypeServicesInit ) );
        if ( FAILED( hr ) )
        {
           goto Cleanup;
        }

        //
        //  Create the resource instances.
        //

        hr = THR( HrPreCreateResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( HrCreateGroups() );
        if ( FAILED( hr ) )
        {
            //
            //  MUSTDO: gpease  28-SEP-2000
            //          For Beta1 will we ignore errors in group creation
            //          and abort the process.
            //
            hr = S_OK;
            goto Cleanup;
        }

        hr = THR( HrCreateResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( HrPostCreateResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        // Notify any components registered on this computer, of a cluster
        // member set change ( form, join or evict ).
        //
        hr = THR( HrNotifyMemberSetChangeListeners() );
        if ( FAILED( hr ) )
        {
           goto Cleanup;
        }

    } // if: we are forming or joining
    else if ( m_ecmCommitChangesMode == cmCLEANUP_NODE_AFTER_EVICT )
    {
        //
        // Notify any components registered on this computer, of a cluster
        // member set change ( form, join or evict ).
        //
        hr = THR( HrNotifyMemberSetChangeListeners() );
        if ( FAILED( hr ) )
        {
           goto Cleanup;
        }

        //
        // Cleanup managed resources.
        //
        hr = THR( HrEvictCleanupResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        // Configure resource types.
        //
        hr = THR( HrConfigureResTypes( pccrtsiResTypeServicesInit ) );
        if ( FAILED( hr ) )
        {
           goto Cleanup;
        }

    } // else if: we have just been evicted

Cleanup:

    if ( pccrtsiResTypeServicesInit != NULL )
    {
        pccrtsiResTypeServicesInit->Release();
    } // if: we had created the resource type services component

    if ( pcci != NULL )
    {
        pcci->Release();
    } // if:

    HRETURN( hr );

} //*** CPostCfgManager::CommitChanges



//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************

STDMETHODIMP
CPostCfgManager::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;
    FILETIME    ft;

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    if ( m_pcccb != NULL )
    {
        hr = STHR( m_pcccb->SendStatusReport(
                         pcszNodeNameIn != NULL ? pcszNodeNameIn : m_bstrNodeName
                       , clsidTaskMajorIn
                       , clsidTaskMinorIn
                       , ulMinIn
                       , ulMaxIn
                       , ulCurrentIn
                       , hrStatusIn
                       , pcszDescriptionIn
                       , pftTimeIn
                       , pcszReferenceIn
                       ) );
    }

    HRETURN( hr );

} //*** CPostCfgManager::SendStatusReport

//****************************************************************************
//
//  Private methods
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrPreCreateResources( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrPreCreateResources( void )
{
    TraceFunc( "" );

    CResourceEntry * presentry;

    HRESULT hr = S_OK;

    BSTR    bstrName         = NULL;
    BSTR    bstrNotification = NULL;
    BSTR    bstrTemp         = NULL;

    IClusCfgManagedResourceInfo *   pccmri       = NULL;
    IClusCfgManagedResourceCfg *    pccmrc       = NULL;
    IUnknown *                      punkServices = NULL;
    IPrivatePostCfgResource *       ppcr         = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    LogMsg( "[PC-PreCreate] Starting pre-create..." );

    hr = THR( HrPreInitializeExistingResources() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Make sure the enumer is in the state we think it is.
    //

    hr = STHR( m_peccmr->Reset() );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_PreCreate_Reset, hr, L"Enumeration of managed resources failed to reset." );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_PreCreate_Reset
            , IDS_TASKID_MINOR_ERROR_ENUM_MANAGEDRES
            , IDS_REF_MINOR_ERROR_ENUM_MANAGEDRES
            , hr
            );

        goto Cleanup;
    }

    hr = THR( CPreCreateServices::S_HrCreateInstance( &punkServices ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
            TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_PreCreate_CPreCreateServices
            , hr
            , L"[PC-PreCreate] Failed to create services object. Aborting."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_PreCreate_CPreCreateServices
            , IDS_TASKID_MINOR_ERROR_CREATE_SERVICE
            , IDS_REF_MINOR_ERROR_CREATE_SERVICE
            , hr
            );

        goto Cleanup;
    }

    hr = THR( punkServices->TypeSafeQI( IPrivatePostCfgResource, &ppcr ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_PreCreate_CPreCreateServices_QI
            , hr
            , L"[PC-PreCreate] Failed to create services object. Aborting."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_PreCreate_CPreCreateServices_QI
            , IDS_TASKID_MINOR_ERROR_CREATE_SERVICE
            , IDS_REF_MINOR_ERROR_CREATE_SERVICE
            , hr
            );

        goto Cleanup;
    }

    //
    //  Update the UI layer.
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_QUERYING_FOR_RESOURCE_DEPENDENCIES, &bstrNotification ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_PreCreate_LoadString_Querying, hr, L"Failed the load string for querying resource dependencies." );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_PreCreate_LoadString_Querying
            , IDS_TASKID_MINOR_ERROR_LOADSTR_RES_DEP
            , IDS_REF_MINOR_ERROR_LOADSTR_RES_DEP
            , hr
            );

        goto Cleanup;
    }

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Querying_For_Resource_Dependencies,
                                0,
                                5,
                                0,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
    // ignore failure

    //
    //  Loop thru the resources, requesting the resources to PreCreate()
    //  themselves. This will cause the resources to callback into the
    //  services object and store class type and resource type information
    //  as well as any required dependencies the resource might have.
    //

    for( ;; )
    {
        //
        //  Cleanup. We put this here because of error conditions below.
        //
        TraceSysFreeString( bstrName );
        bstrName = NULL;

        TraceSysFreeString( bstrTemp );
        bstrTemp = NULL;

        if ( pccmri != NULL )
        {
            pccmri->Release();
            pccmri = NULL;
        }
        if ( pccmrc != NULL )
        {
            pccmrc->Release();
            pccmrc = NULL;
        }

        //
        //  Ask to get the next resource.
        //

        hr = STHR( m_peccmr->Next( 1, &pccmri, NULL ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_PreCreate_EnumResources_Next
                , hr
                , L"[PC-PreCreate] Getting next managed resource failed. Aborting."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Minor_Querying_For_Resource_Dependencies
                , IDS_TASKID_MINOR_ERROR_MANAGED_RESOURCE
                , IDS_REF_MINOR_ERROR_MANAGED_RESOURCE
                , hr
                );
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit loop
        }

        //
        //  Retrieve its name for logging, etc. We will ultimately store this in the
        //  resource entry to be reused (ownership will be transferred).
        //

        hr = THR( pccmri->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_PreCreate_EnumResources_GetName
                , hr
                , L"[PC-PreCreate] Failed to retrieve a resource's name. Skipping."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Minor_Querying_For_Resource_Dependencies
                , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_NAME
                , IDS_REF_MINOR_ERROR_GET_RESOURCE_NAME
                , hr
                );

            continue;
        }

        //
        //  Check to see if the resource wants to be managed or not.
        //

        hr = STHR( pccmri->IsManaged() );
        if ( FAILED( hr ) )
        {
            SSR_LOG1(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_PreCreate_EnumResources_IsManaged
                , hr
                , L"[PC-PreCreate] %1!ws!: Failed to determine if it is to be managed. Skipping."
                , bstrNotification
                , bstrName
                );

            STATUS_REPORT_MINOR_REF_POSTCFG1(
                  TASKID_Minor_Querying_For_Resource_Dependencies
                , IDS_TASKID_MINOR_ERROR_DETERMINE_MANAGED
                , IDS_REF_MINOR_ERROR_DETERMINE_MANAGED
                , hr
                , bstrName
                );

            continue;
        }

        if ( hr == S_FALSE )
        {
            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_PreCreate_EnumResources_IsManaged_False,
                      hr,
                      L"[PC-PreCreate] %1!ws!: Resource does not want to be managed. Skipping.",
                      bstrNotification,
                      bstrName
                      );

            // No need to report this to the UI level.
            continue;
        }
/*
        hr = STHR( HrIsLocalQuorum( bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_PreCreate_EnumResources_IsLocalQuorum,
                      hr,
                      L"Error occured trying to determine if the resource was the local quorum resource.",
                      bstrNotification,
                      bstrName
                      );
            continue;
        } // if:

        //
        //  Ignore the local quorum resource since it is special and won't need its own group.
        //
        if ( hr == S_OK )
        {
            continue;
        } // if:
*/
        //
        //  Get the config interface for this resource (if any).
        //

        hr = THR( pccmri->TypeSafeQI( IClusCfgManagedResourceCfg, &pccmrc ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG1(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_PreCreate_EnumResources_QI_pccmrc
                , hr
                , L"[PC-PreCreate] %1!ws!: Failed QI for IClusCfgManagedResourceCfg. Skipping."
                , bstrNotification
                , bstrName
                );

            STATUS_REPORT_MINOR_REF_POSTCFG1(
                  TASKID_Minor_Querying_For_Resource_Dependencies
                , IDS_TASKID_MINOR_ERROR_MANAGED_RES_CONFIG
                , IDS_REF_MINOR_ERROR_MANAGED_RES_CONFIG
                , hr
                , bstrName
                );

            continue;
        }

        //
        //  Grow the resource list if nessecary.
        //

        if ( m_cResources == m_cAllocedResources )
        {
            ULONG               idxNewCount = m_cAllocedResources + RESOURCE_INCREMENT;
            CResourceEntry **   plistNew;

            plistNew = (CResourceEntry **) TraceAlloc( 0, sizeof( CResourceEntry *) * idxNewCount );
            if ( plistNew == NULL )
            {
                LogMsg( "[PC-PreCreate] Out of memory. Aborting." );
                hr = THR( E_OUTOFMEMORY );
                STATUS_REPORT_REF_POSTCFG(
                      TASKID_Minor_Querying_For_Resource_Dependencies
                    , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OutOfMemory
                    , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
                    , IDS_REF_MINOR_ERROR_OUT_OF_MEMORY
                    , hr
                    );

                goto Cleanup;
            }

            CopyMemory( plistNew, m_rgpResources, sizeof(CResourceEntry *) * m_cAllocedResources );
            TraceFree( m_rgpResources );
            m_rgpResources = plistNew;

            for ( ; m_cAllocedResources < idxNewCount; m_cAllocedResources ++ )
            {
                hr = THR( CResourceEntry::S_HrCreateInstance( &m_rgpResources[ m_cAllocedResources ], m_pcccb, m_lcid ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_PreCreate_CResourceEntry
                        , hr
                        , L"[PC-PreCreate] Failed to create resource entry object. Aborting."
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG(
                          TASKID_Minor_Querying_For_Resource_Dependencies
                        , IDS_TASKID_MINOR_ERROR_CREATE_RESENTRY
                        , IDS_REF_MINOR_ERROR_CREATE_RESENTRY
                        , hr
                        );

                    goto Cleanup;
                }
            }
        }

        //
        //  Check to see if this resource is the quorum resource. If it is, point the services
        //  object to the quorum resource entry (m_idxQuorumResource).
        //

        hr = STHR( pccmri->IsQuorumResource() );
        if ( hr == S_OK )
        {
            presentry = m_rgpResources[ m_idxQuorumResource ];

            SSR_LOG1(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_PreCreate_EnumResources_IsQuorumDevice_S_OK
                , hr
                , L"[PC-PreCreate] %1!ws!: Setting this resource to be the quorum device."
                , bstrNotification
                , bstrName
                );

            STATUS_REPORT_MINOR_POSTCFG1(
                  TASKID_Minor_Querying_For_Resource_Dependencies
                , IDS_TASKID_MINOR_SETTING_QUORUM_DEVICE
                , hr
                , bstrName
                );

            //
            //  We need to release the previous quorum's resource handle.
            //

            THR( presentry->SetHResource( NULL ) );
            //  We don't care if this fails... we'll overwrite it later.

            //
            //  BUG 447944 - Quorum Resource is moved on an add.
            //  George Potts (GPotts) Sep 11 2001
            //
            //  Set the quorum changed flag here.  This flag indicates whether the quorum
            //  resource has changed or not.  For initialization PostCfg assumes that it's
            //  a Local Quorum resource, which it will continue to use if no other
            //  quorum was later selected (via code (phys disk) or user (drop down box)).
            //  At this point in the code we've detected that the Local Quorum resource is
            //  not going to be the quorum.  By setting this flag we indicate that PostCfg
            //  is to later call SetClusterQuorumResource.  If we're not in create mode
            //  we use the quorum resource that the cluster started with, and the if
            //  statement that we're in updates our internal table to reflect that.
            //  If we are in create mode then we will need to update the quorum on the
            //  vanilla Local Quorum cluster that we always create first.
            //  If we don't put the if around the assignment below PostCfg wrongly thinks that
            //  the quorum has changed (when in fact it hasn't) and SetClusterQuorumResource
            //  will be called.  The downsides of not using the if below are an uneccessary
            //  call is made and we call it with NULL so that the root path is overwritten.
            //

            if ( m_ecmCommitChangesMode == cmCREATE_CLUSTER )
            {
                m_fIsQuorumChanged = TRUE;
            }
        }
        else
        {
            presentry = m_rgpResources[ m_cResources ];

            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_PreCreate_EnumResources_IsQuorumDevice_Failed
                    , hr
                    , L"IsQuorumDevice() function failed."
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG1(
                      TASKID_Minor_Querying_For_Resource_Dependencies
                    , IDS_TASKID_MINOR_ERROR_IS_QUORUM_RESOURCE
                    , IDS_REF_MINOR_ERROR_IS_QUORUM_RESOURCE
                    , hr
                    , bstrName
                    );
            }
        }

        //
        //  Setup the new entry.
        //

        hr = THR( presentry->SetAssociatedResource( pccmrc ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_PreCreate_EnumResources_SetAssociatedResouce
                , hr
                , L"SetAssociatedResource() function failed."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG1(
                  TASKID_Minor_Querying_For_Resource_Dependencies
                , IDS_TASKID_MINOR_ERROR_SET_ASSOC_RESOURCE
                , IDS_REF_MINOR_ERROR_SET_ASSOC_RESOURCE
                , hr
                , bstrName
                );

            continue;
        }

        //
        //  Make a local copy of bstrName for logging purposes then
        //  give ownership away.
        //

        bstrTemp = TraceSysAllocString( bstrName );
        hr = THR( presentry->SetName( bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_PreCreate_EnumResources_SetName, hr, L"SetName() function failed." );

            STATUS_REPORT_MINOR_REF_POSTCFG1(
                  TASKID_Minor_Querying_For_Resource_Dependencies
                , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_NAME
                , IDS_REF_MINOR_ERROR_SET_RESOURCE_NAME
                , hr
                , bstrName
                );

            continue;
        }

        //  We gave ownership away when we called SetName() above.
        bstrName = bstrTemp;
        bstrTemp = NULL;

        //
        //  Point the PreCreate services to the resource entry.
        //

        hr = THR( ppcr->SetEntry( presentry ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_PreCreate_EnumResources_SetEntry, hr, L"SetEntry() function failed." );

            STATUS_REPORT_MINOR_REF_POSTCFG1(
                  TASKID_Minor_Querying_For_Resource_Dependencies
                , IDS_TASKID_MINOR_ERROR_SETENTRY
                , IDS_REF_MINOR_ERROR_SETENTRY
                , hr
                , bstrName
                );

            continue;
        }

        //
        //  Ask the resource to configure itself. Every resource that wants to be
        //  created in the default cluster must implement PreCreate(). Those that
        //  return E_NOTIMPL will be ignored.
        //

        //  Don't wrap - this can fail with E_NOTIMPL.
        hr = pccmrc->PreCreate( punkServices );
        if ( FAILED( hr ) )
        {
            if ( hr == E_NOTIMPL )
            {
                SSR_LOG1(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_PreCreate_PreCreate_E_NOTIMPL
                    , hr
                    , L"[PC-PreCreate] %1!ws!: Failed. Resource returned E_NOTIMPL. This resource will not be created. Skipping."
                    , bstrNotification
                    , bstrName
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG1(
                      TASKID_Minor_Querying_For_Resource_Dependencies
                    , IDS_TASKID_MINOR_ERROR_RES_NOT_CREATED
                    , IDS_REF_MINOR_ERROR_RES_NOT_CREATED
                    , hr
                    , bstrName
                    );
            }
            else
            {
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_Resource_Failed_PreCreate,
                          hr,
                          L"[PC-PreCreate] %1!ws! failed PreCreate().",
                          bstrNotification,
                          bstrName
                          );

                STATUS_REPORT_MINOR_REF_POSTCFG1(
                      TASKID_Minor_Querying_For_Resource_Dependencies
                    , IDS_TASKID_MINOR_RESOURCE_FAILED_PRECREATE
                    , IDS_REF_MINOR_RESOURCE_FAILED_PRECREATE
                    , hr
                    , bstrName
                    );

                if ( hr == E_ABORT )
                {
                    goto Cleanup;
                    //  ignore failure
                }
            }

            continue;
        }

        if ( presentry != m_rgpResources[ m_idxQuorumResource ] )
        {
            m_cResources ++;
        }

        SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                  TASKID_Minor_PreCreate_Succeeded,
                  hr,
                  L"[PC-PreCreate] %1!ws!: Succeeded.",
                  bstrNotification,
                  bstrName
                  );

    } // for: ever

    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
              TASKID_Minor_PreCreate_Finished,
              hr,
              L"[PC-PreCreate] Finished.",
              bstrNotification,
              bstrName
              );

#if defined(DEBUG)
    // DebugDumpDepencyTree();
#endif

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Querying_For_Resource_Dependencies,
                                0,
                                5,
                                5,
                                S_OK,
                                NULL,    // don't need to update string
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
    //  ignore failure

    hr = S_OK;

Cleanup:
    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrTemp );

    if ( pccmri != NULL )
    {
        pccmri->Release();
    }
    if ( pccmrc != NULL )
    {
        pccmrc->Release();
    }
    if ( punkServices != NULL )
    {
        punkServices->Release();
    }
    if ( ppcr != NULL )
    {
        ppcr->Release();
    }

    HRETURN( hr );

} //*** CPostCfgManager::HrPreCreateResources

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrCreateGroups( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrCreateGroups( void )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    DWORD                   dwStatus;
    ULONG                   cGroup;
    HGROUP                  hGroup = NULL;
    CGroupHandle *          pgh = NULL;
    ULONG                   idxResource;
    ULONG                   idxMatchDepedency;
    ULONG                   idxMatchResource;
    const CLSID *           pclsidType = NULL;
    const CLSID *           pclsidClassType = NULL;
    EDependencyFlags        dfFlags;
    CResourceEntry *        presentry = NULL;
    HCLUSENUM               hClusEnum = NULL;
    BSTR                    bstrGroupName = NULL;
    BSTR                    bstrNotification = NULL;
    DWORD                   sc;
    HRESOURCE               hCoreResourceArray[ 3 ] = { NULL, NULL, NULL};
    HRESOURCE               hCoreResource = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    Assert( m_idxLastStorage == 0 );

    m_idxLastStorage = m_idxQuorumResource;

    //
    //  Phase 1: Figure out the dependency tree.
    //

    hr = S_OK;
    SSR_LOG_ERR(
          TASKID_Major_Client_And_Server_Log
        , TASKID_Minor_CreateGroups_Begin
        , hr
        , L"[PC-Grouping] Figuring out dependency tree to determine grouping."
        );

    STATUS_REPORT_POSTCFG(
          TASKID_Major_Configure_Resources
        , TASKID_Minor_CreateGroups_Begin
        , IDS_TASKID_MINOR_FIGURE_DEPENDENCY_TREE
        , hr
        );

    for ( idxResource = 0; idxResource < m_cResources; idxResource ++ )
    {
        CResourceEntry * presentryResource = m_rgpResources[ idxResource ];
        ULONG cDependencies;

        hr = THR( presentryResource->GetCountOfTypeDependencies( &cDependencies ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_CreateGroups_GetCountOfTypeDependencies
                , hr
                , L"Failed to get the count of resource type dependencies."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Minor_CreateGroups_Begin
                , IDS_TASKID_MINOR_ERROR_COUNT_OF_DEPENDENCY
                , IDS_REF_MINOR_ERROR_COUNT_OF_DEPENDENCY
                , hr
                );

            continue;
        }

        for ( idxMatchDepedency = 0; idxMatchDepedency < cDependencies; idxMatchDepedency ++ )
        {
            BOOL             fFoundMatch        = FALSE;
            const CLSID *    pclsidMatchType;
            EDependencyFlags dfMatchFlags;

            hr = THR( presentryResource->GetTypeDependencyPtr( idxMatchDepedency,
                                                               &pclsidMatchType,
                                                               &dfMatchFlags
                                                               ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_CreateGroups_GetTypeDependencyPtr, hr, L"Failed to get type dependency pointer" );

                STATUS_REPORT_MINOR_REF_POSTCFG(
                      TASKID_Minor_CreateGroups_Begin
                    , IDS_TASKID_MINOR_ERROR_DEPENDENCY_PTR
                    , IDS_REF_MINOR_ERROR_DEPENDENCY_PTR
                    , hr
                    );

                continue;
            }

            //
            //  See if it is one of the "well known" types.
            //

            //
            //  We special case storage class device because we want to spread as many
            //  resources across as many storage devices as possible. This helps prevent
            //  the ganging of resources into one large group.
            //

            if ( *pclsidMatchType == RESCLASSTYPE_StorageDevice )
            {
                //
                //  The below THR may fire in certain configurations. Please validate
                //  the configuration before removing the THR.
                //
                //  If it returns E_FAIL, we should fall thru and attempt "normal"
                //  resource negociations.
                //
                hr = THR( HrAttemptToAssignStorageToResource( idxResource, dfMatchFlags ) );
                if ( SUCCEEDED( hr ) )
                {
                    fFoundMatch = TRUE;
                }
                else if ( FAILED( hr ) )
                {
                    if ( hr != E_FAIL )
                    {
                        goto Cleanup;
                    }
                }
            }
            else if ( *pclsidMatchType == RESTYPE_NetworkName )
            {
                BSTR    bstrName = NULL;

                hr = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_NETNAMEFORMAT, &bstrName, m_cNetName ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_FormatString_NetName
                        , hr
                        , L"[PC-Grouping] Failed to create name for net name resource. Aborting."
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_NET_RESOURCE_NAME
                        , IDS_REF_MINOR_ERROR_NET_RESOURCE_NAME
                        , hr
                        );

                    goto Cleanup;
                }

                hr = THR( HrAddSpecialResource( bstrName,
                                                &RESTYPE_NetworkName,
                                                &RESCLASSTYPE_NetworkName
                                                ) );
                if ( FAILED( hr ) )
                {
                    continue;
                }

                presentry = m_rgpResources[ m_cResources - 1 ];

                //  Net name depends on an IP address.
                hr = THR( presentry->AddTypeDependency( &RESTYPE_IPAddress, dfSHARED ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_AddTypeDependency
                        , hr
                        , L"Failed to add type dependency."
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_TYPE_DEPENDENCY
                        , IDS_REF_MINOR_ERROR_TYPE_DEPENDENCY
                        , hr
                        );

                    continue;
                }

                hr = THR( presentry->AddDependent( idxResource, dfMatchFlags ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_Resource_AddDependent
                        , hr
                        , L"Failed to add a dependent entry."
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_ADD_DEPENDENT
                        , IDS_REF_MINOR_ERROR_ADD_DEPENDENT
                        , hr
                        );

                    continue;
                }

                fFoundMatch = TRUE;

            }
            else if ( *pclsidMatchType == RESTYPE_IPAddress )
            {
                BSTR    bstrName = NULL;

                hr = THR( HrFormatStringIntoBSTR( g_hInstance,
                                                  IDS_IPADDRESSFORMAT,
                                                  &bstrName,
                                                  FIRST_IPADDRESS( m_cIPAddress ),
                                                  SECOND_IPADDRESS( m_cIPAddress ),
                                                  THIRD_IPADDRESS( m_cIPAddress ),
                                                  FOURTH_IPADDRESS( m_cIPAddress )
                                                  ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_FormatString_IPAddress
                        , hr
                        , L"[PC-Grouping] Failed to create name for IP address resource. Aborting."
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_IP_RESOURCE_NAME
                        , IDS_REF_MINOR_ERROR_IP_RESOURCE_NAME
                        , hr
                        );

                    goto Cleanup;
                }

                hr = THR( HrAddSpecialResource( bstrName, &RESTYPE_IPAddress, &RESCLASSTYPE_IPAddress ) );
                if ( FAILED( hr ) )
                {
                    continue;
                }

                m_cIPAddress ++;

                presentry = m_rgpResources[ m_cResources - 1 ];

                hr = THR( presentry->AddDependent( idxResource, dfMatchFlags ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_Resource_AddDependent
                        , hr
                        , L"Failed to add a dependent entry."
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_ADD_DEPENDENT
                        , IDS_REF_MINOR_ERROR_ADD_DEPENDENT
                        , hr
                        );

                    continue;
                }

                fFoundMatch = TRUE;
            }
            else if ( *pclsidMatchType == RESTYPE_ClusterNetName )
            {
                presentry = m_rgpResources[ m_idxClusterName ];

                hr = THR( presentry->AddDependent( idxResource, dfMatchFlags ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_NetName_AddDependent
                        , hr
                        , L"Failed to add a dependent entry."
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_ADD_DEPENDENT
                        , IDS_REF_MINOR_ERROR_ADD_DEPENDENT
                        , hr
                        );

                    continue;
                }

                fFoundMatch = TRUE;
            }
            else if ( *pclsidMatchType == RESTYPE_ClusterIPAddress )
            {
                presentry = m_rgpResources[ m_idxIPAddress ];

                hr = THR( presentry->AddDependent( idxResource, dfMatchFlags ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_IPAddress_AddDependent
                        , hr
                        , L"Failed to add a dependent entry."

                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_ADD_DEPENDENT
                        , IDS_REF_MINOR_ERROR_ADD_DEPENDENT
                        , hr
                        );

                    continue;
                }

                fFoundMatch = TRUE;
            }
            else if ( *pclsidMatchType == RESTYPE_ClusterQuorum )
            {
                presentry = m_rgpResources[ m_idxQuorumResource ];

                hr = THR( presentry->AddDependent( idxResource, dfMatchFlags ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_QuorumDisk_AddDependent
                        , hr
                        , L"Failed to add a dependent entry."
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_ADD_DEPENDENT
                        , IDS_REF_MINOR_ERROR_ADD_DEPENDENT
                        , hr
                        );

                    continue;
                }

                fFoundMatch = TRUE;
            }

            //
            //  Check out the resources to see if it matches any of them.
            //

            if ( !fFoundMatch )
            {
                //
                //  We can always start at the quorum resource because the resource with indexes
                //  below that are handled in the special case code above.
                //

                for ( idxMatchResource = m_idxQuorumResource; idxMatchResource < m_cResources; idxMatchResource ++ )
                {
                    presentry = m_rgpResources[ idxMatchResource ];

                    hr = THR( presentry->GetTypePtr( &pclsidType ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_LOG_ERR(
                              TASKID_Major_Client_And_Server_Log
                            , TASKID_Minor_CreateGroups_GetTypePtr
                            , hr
                            , L"Failed to get resource type pointer."
                            );

                        STATUS_REPORT_MINOR_REF_POSTCFG(
                              TASKID_Minor_CreateGroups_Begin
                            , IDS_TASKID_MINOR_ERROR_GET_RESTYPE_PTR
                            , IDS_REF_MINOR_ERROR_GET_RESTYPE_PTR
                            , hr
                            );

                        continue;
                    }

                    hr = THR( presentry->GetClassTypePtr( &pclsidClassType ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_LOG_ERR(
                              TASKID_Major_Client_And_Server_Log
                            , TASKID_Minor_CreateGroups_GetClassTypePtr
                            , hr
                            , L"Failed to get resource class type pointer."
                            );

                        STATUS_REPORT_MINOR_REF_POSTCFG(
                              TASKID_Minor_CreateGroups_Begin
                            , IDS_TASKID_MINOR_ERROR_GET_CLASSTYPE_PTR
                            , IDS_REF_MINOR_ERROR_GET_CLASSTYPE_PTR
                            , hr
                            );

                        continue;
                    }

                    hr = THR( presentry->GetFlags( &dfFlags ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_LOG_ERR(
                              TASKID_Major_Client_And_Server_Log
                            , TASKID_Minor_CreateGroups_GetFlags
                            , hr
                            , L"Failed to get resource flags."
                            );

                        STATUS_REPORT_MINOR_REF_POSTCFG(
                              TASKID_Minor_CreateGroups_Begin
                            , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_FLAGS
                            , IDS_REF_MINOR_ERROR_GET_RESOURCE_FLAGS
                            , hr
                            );

                        continue;
                    }

                    //
                    //  Try matching it to the resource type.
                    //

                    if ( *pclsidType      == *pclsidMatchType
                      || *pclsidClassType == *pclsidMatchType
                       )
                    {
                        if ( ! ( dfFlags & dfEXCLUSIVE )
                          ||     ( ( dfFlags & dfSHARED )
                                && ( dfMatchFlags & dfSHARED )
                                 )
                           )
                        {
                            hr = THR( presentry->SetFlags( dfMatchFlags ) );
                            if ( FAILED( hr ) )
                            {
                                SSR_LOG_ERR(
                                      TASKID_Major_Client_And_Server_Log
                                    , TASKID_Minor_CreateGroups_SetFlags
                                    , hr
                                    , L"Failed to set resource flags."
                                    );

                                STATUS_REPORT_MINOR_REF_POSTCFG(
                                      TASKID_Minor_CreateGroups_Begin
                                    , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_FLAGS
                                    , IDS_REF_MINOR_ERROR_SET_RESOURCE_FLAGS
                                    , hr
                                    );

                                continue;
                            }

                            hr = THR( presentry->AddDependent( idxResource, dfMatchFlags ) );
                            if ( FAILED( hr ) )
                            {
                                SSR_LOG_ERR(
                                      TASKID_Major_Client_And_Server_Log
                                    , TASKID_Minor_CreateGroups_Resource_AddDependent
                                    , hr
                                    , L"Failed to add a dependent entry."
                                    );

                                STATUS_REPORT_MINOR_REF_POSTCFG(
                                      TASKID_Minor_CreateGroups_Begin
                                    , IDS_TASKID_MINOR_ERROR_ADD_DEPENDENT
                                    , IDS_REF_MINOR_ERROR_ADD_DEPENDENT
                                    , hr
                                    );

                                continue;
                            }

                            fFoundMatch = TRUE;

                            break;  // exit loop
                        }
                    }

                } // for: idxMatchResource

            } // if: not fFoundMatch

            //
            //  If we didn't match the dependency, unmark the resource from being managed.
            //

            if ( !fFoundMatch )
            {
                BSTR    bstrName;
                IClusCfgManagedResourceInfo * pccmri;
                IClusCfgManagedResourceCfg * pccmrc;

                //
                //  KB:     gpease  17-JUN-2000
                //          No need to free bstrName because the resource entry controls
                //          the lifetime - we're just borrowing it.
                //
                hr = THR( presentryResource->GetName( &bstrName ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_GetName
                        , hr
                        , L"Failed to get resource name."
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_NAME
                        , IDS_REF_MINOR_ERROR_GET_RESOURCE_NAME
                        , hr
                        );

                    continue;
                }

                hr = S_FALSE;

                SSR_LOG1(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_CreateGroups_MissingDependent
                    , hr
                    , L"[PC-Grouping] %1!ws!: Missing dependent resource. This resource will not be configured."
                    , bstrNotification
                    , bstrName
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG1(
                      TASKID_Minor_CreateGroups_Begin
                    , IDS_TASKID_MINOR_ERROR_MISSING_DEPENDENT_RES
                    , IDS_REF_MINOR_ERROR_MISSING_DEPENDENT_RES
                    , hr
                    , bstrName
                    );

                hr = THR( presentryResource->GetAssociatedResource( &pccmrc ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_GetAssociateResource
                        , hr
                        , L"Failed to get an associated resource."
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG1(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_GET_ASSOC_RESOURCE
                        , IDS_REF_MINOR_ERROR_GET_ASSOC_RESOURCE
                        , hr
                        , bstrName
                        );

                    continue;
                }

                hr = THR( pccmrc->TypeSafeQI( IClusCfgManagedResourceInfo, &pccmri ) );
                pccmrc->Release();     //  release promptly.
                if ( FAILED( hr ) )
                {
                    SSR_LOG1(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_QI_pccmri
                        , hr
                        , L"[PC-Grouping] %1!ws!: Resource failed to QI for IClusCfgManagedResourceInfo."
                        , bstrNotification
                        , bstrName
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG1(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_MANAGED_RES_INFO
                        , IDS_REF_MINOR_ERROR_MANAGED_RES_INFO
                        , hr
                        , bstrName
                        );

                    continue;
                }

                hr = THR( pccmri->SetManaged( FALSE ) );
                pccmri->Release();     //  release promptly.
                if ( FAILED( hr ) )
                {
                    SSR_LOG1(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_SetManaged
                        , hr
                        , L"[PC-Grouping] %1!ws!: Resource failed SetManaged( FALSE )."
                        , bstrNotification
                        , bstrName
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG1(
                          TASKID_Minor_CreateGroups_Begin
                        , IDS_TASKID_MINOR_ERROR_SET_MANAGED_FALSE
                        , IDS_REF_MINOR_ERROR_SET_MANAGED_FALSE
                        , hr
                        , bstrName
                        );
                }
            }

        } // for: idxDepedency

    } // for: idxResource

#if defined(DEBUG)
    // DebugDumpDepencyTree();
#endif

    hr = S_OK;
    SSR_LOG_ERR(
          TASKID_Major_Client_And_Server_Log
        , TASKID_Minor_CreateGroups_Creating
        , hr
        , L"[PC-Grouping] Creating groups."
        );

    STATUS_REPORT_POSTCFG(
          TASKID_Major_Configure_Resources
        , TASKID_Minor_CreateGroups_Creating
        , IDS_TASKID_MINOR_CREATING_GROUP
        , hr
        );

    //
    //  For each of the core resources get the group that it's a member of and
    //  update our component to reflect that. No two core resources have to be
    //  in the same group.
    //

    sc = TW32( ResUtilGetCoreClusterResources( m_hCluster, &hCoreResourceArray[0], &hCoreResourceArray[1], &hCoreResourceArray[2] ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );

        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_CreateGroups_Get_CoreClusterGroup
            , hr
            , L"[PC-Grouping] Failed to get core resource handles. Aborting."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Minor_CreateGroups_Creating
            , TASKID_Minor_CreateGroups_Get_CoreClusterGroup
            , IDS_TASKID_MINOR_ERROR_GET_COREGROUP_HANDLE
            , IDS_REF_MINOR_ERROR_GET_COREGROUP_HANDLE
            , hr
            );

        goto Cleanup;
    }

    for ( idxResource = 0; idxResource <= m_idxQuorumResource; idxResource ++ )
    {
        hCoreResource = hCoreResourceArray[ idxResource ];
        Assert( hCoreResource != NULL );
        hr = THR( HrGetClusterResourceState( hCoreResource, NULL, &bstrGroupName, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        CloseClusterResource( hCoreResource );
        hCoreResource = NULL;

        hGroup = OpenClusterGroup( m_hCluster, bstrGroupName );
        if ( hGroup == NULL )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            SSR_LOG1(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_CreateGroups_OpenClusterGroup
                , hr
                , L"[PC-Grouping] Failed OpenClusterGroup('%1!ws!'). Aborting."
                , bstrNotification
                , bstrGroupName
                );

            STATUS_REPORT_REF_POSTCFG1(
                  TASKID_Minor_CreateGroups_Creating
                , TASKID_Minor_CreateGroups_OpenClusterGroup
                , IDS_TASKID_MINOR_ERROR_OPEN_GROUP
                , IDS_REF_MINOR_ERROR_OPEN_GROUP
                , hr
                , bstrGroupName
                );

            goto Cleanup;
        }

        //
        //  Wrap it up and give ownership away.
        //

        hr = THR( CGroupHandle::S_HrCreateInstance( &pgh, hGroup ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_CreateGroups_Create_CGroupHandle
                , hr
                , L"Failed to create group handle instance."
                );

            STATUS_REPORT_REF_POSTCFG1(
                  TASKID_Minor_CreateGroups_Creating
                , TASKID_Minor_CreateGroups_Create_CGroupHandle
                , IDS_TASKID_MINOR_ERROR_CREATE_GROUP_HANDLE
                , IDS_REF_MINOR_ERROR_CREATE_GROUP_HANDLE
                , hr
                , bstrGroupName
                );

            goto Cleanup;
        }

        hGroup = NULL;

        hr = THR( HrSetGroupOnResourceAndItsDependents( idxResource, pgh ) );
        if ( FAILED( hr ) )
        {
            // If this failed it already updated the UI and logged an error.
            goto Cleanup;
        }

        TraceSysFreeString( bstrGroupName );
        bstrGroupName = NULL;

        if ( pgh != NULL )
        {
            pgh->Release();
            pgh = NULL;
        }
    } // for: each core resource update the view of what group it is in.

    //
    //  Loop thru the resources looking for groups.
    //

    cGroup = 0;
    for ( idxResource = m_idxQuorumResource + 1; idxResource < m_cResources; idxResource ++ )
    {
        CResourceEntry * presentryResource = m_rgpResources[ idxResource ];
        ULONG   cDependencies;

        if ( pgh != NULL )
        {
            pgh->Release();
            pgh = NULL;
        }

        hr = THR( presentryResource->GetCountOfTypeDependencies( &cDependencies ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_CreateGroups_GetCountOfTypeDependencies2
                , hr
                , L"Failed to get the count of resource type dependencies."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Minor_CreateGroups_Creating
                , IDS_TASKID_MINOR_ERROR_COUNT_OF_DEPENDENCY
                , IDS_REF_MINOR_ERROR_COUNT_OF_DEPENDENCY
                , hr
                );

            continue;
        }

        //
        //  Don't consider resources that have indicated that the depend on
        //  somebody else.
        //

        if ( cDependencies != 0 )
        {
            continue;
        }

        //
        //  See if any of the dependent resource has already has a group assigned
        //  to it.  This allows for multiple roots to be combined into a single
        //  group due to lower dependencies.
        //

        // Don't create a group for the local quoum resource!
        hr = STHR( HrFindGroupFromResourceOrItsDependents( idxResource, &pgh ) );
        if ( FAILED( hr ) )
        {
            continue;
        }

        if ( hr == S_FALSE )
        {
            //
            //  We need to create a new group.
            //

            //
            //  Create a name for our group.
            //
            for( ;; )
            {
                hr = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_GROUP_X, &bstrGroupName, cGroup ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_FormatString_Group
                        , hr
                        , L"[PC-Grouping] Failed to create group name. Aborting."
                        );

                    STATUS_REPORT_MINOR_REF_POSTCFG(
                          TASKID_Minor_CreateGroups_Creating
                        , IDS_TASKID_MINOR_ERROR_CREATE_NAME
                        , IDS_REF_MINOR_ERROR_CREATE_NAME
                        , hr
                        );

                    goto Cleanup;
                }

                //
                //  Create the group in the cluster.
                //

                hGroup = CreateClusterGroup( m_hCluster, bstrGroupName );
                if ( hGroup == NULL )
                {
                    dwStatus = GetLastError();

                    switch ( dwStatus )
                    {
                    case ERROR_OBJECT_ALREADY_EXISTS:
                        cGroup ++;
                        break;  // keep looping

                    default:
                        hr = HRESULT_FROM_WIN32( TW32( dwStatus ) );

                        SSR_LOG1(
                              TASKID_Major_Client_And_Server_Log
                            , TASKID_Minor_CreateGroups_CreateClusterGroup
                            , hr
                            , L"[PC-Grouping] %1!ws!: Failed to create group. Aborting."
                            , bstrNotification
                            , bstrGroupName
                            );

                        STATUS_REPORT_MINOR_REF_POSTCFG1(
                              TASKID_Minor_CreateGroups_Creating
                            , IDS_TASKID_MINOR_ERROR_CREATE_GROUP
                            , IDS_REF_MINOR_ERROR_CREATE_GROUP
                            , hr
                            , bstrGroupName
                            );

                        goto Cleanup;
                    }
                }
                else
                {
                    break;
                }
            }

            //
            // Bring the group online to set its persistent state to Online.
            //

            dwStatus = TW32( OnlineClusterGroup( hGroup, NULL ) );
            if ( dwStatus != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( dwStatus );

                SSR_LOG1(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_CreateGroups_OnlineClusterGroup
                    , hr
                    , L"[PC-Grouping] %1!ws!: Failed to bring group online. Aborting."
                    , bstrNotification
                    , bstrGroupName
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG1(
                      TASKID_Minor_CreateGroups_Creating
                    , IDS_TASKID_MINOR_ERROR_GROUP_ONLINE
                    , IDS_REF_MINOR_ERROR_GROUP_ONLINE
                    , hr
                    , bstrGroupName
                    );

                goto Cleanup;
            }

            //
            //  Wrap the handle for ref counting.
            //

            hr = THR( CGroupHandle::S_HrCreateInstance( &pgh, hGroup ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_CreateGroups_Create_CGroupHandle2
                    , hr
                    , L"Failed to create group handle instance."
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG1(
                      TASKID_Minor_CreateGroups_Creating
                    , IDS_TASKID_MINOR_ERROR_CREATE_GROUP_HANDLE
                    , IDS_REF_MINOR_ERROR_CREATE_GROUP_HANDLE
                    , hr
                    , bstrGroupName
                    );

                goto Cleanup;
            }

            hGroup = NULL;

            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_CreateGroups_Created,
                      hr,
                      L"[PC-Grouping] %1!ws!: Group created.",
                      bstrNotification,
                      bstrGroupName
                      );

            cGroup ++;
        }

        hr = THR( HrSetGroupOnResourceAndItsDependents( idxResource, pgh ) );
        if ( FAILED( hr ) )
        {
            continue;
        }

    } // for: idxResource

    hr = S_OK;

    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
             TASKID_Minor_CreateGroups_Finished,
             hr,
             L"[PC-Grouping] Finished."
             );

#if defined(DEBUG)
    // DebugDumpDepencyTree();
#endif

Cleanup:

    if ( hCoreResource != NULL )
    {
        CloseClusterResource( hCoreResource );
    } // if:

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrGroupName );

    if ( hClusEnum != NULL )
    {
        TW32( ClusterCloseEnum( hClusEnum ) );
    }

    if ( hGroup != NULL )
    {
        BOOL fRet;
        fRet = CloseClusterGroup( hGroup );
        Assert( fRet );
    }

    if ( pgh != NULL )
    {
        pgh->Release();
    }

    HRETURN( hr );

} //*** CPostCfgManager::HrCreateGroups

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrCreateResources( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrCreateResources( void )
{
    TraceFunc( "" );

    ULONG   idxResource;

    HRESULT hr;

    BSTR    bstrNotification = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    //
    //  Make a message using the name.
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_CREATING_RESOURCE, &bstrNotification ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_CreateResources_LoadString_Creating
            , hr
            , L"Failed to load a string for creating resource."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CreateResources_LoadString_Creating
            , IDS_TASKID_MINOR_ERROR_LOADSTRING
            , IDS_REF_MINOR_ERROR_LOADSTRING
            , hr
            );

        goto Cleanup;
    }

    //
    //  Tell the UI what we are doing.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Creating_Resource,
                                0,
                                m_cResources,
                                0,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
    {
        goto Cleanup;
    }
    //  ignore failure

    hr = S_OK;
    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
             TASKID_Minor_CreateResources_Starting,
             hr,
             L"[PC-Create] Starting..."
             );

    for ( idxResource = m_idxQuorumResource; idxResource < m_cResources; idxResource ++ )
    {

        hr = THR( HrCreateResourceAndDependents( idxResource ) );
        if ( FAILED( hr ) )
        {
            continue;
        }

    } // for: idxResource

    hr = S_OK;
    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
             TASKID_Minor_CreateResources_Finished,
             hr,
             L"[PC-Create] Finished."
             );

    //
    //  Tell the UI what we are doing.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Creating_Resource,
                                0,
                                m_cResources,
                                m_cResources,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );


Cleanup:
    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} //*** CPostCfgManager::HrCreateResources

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrPostCreateResources( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrPostCreateResources( void )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   idxResource;

    BSTR    bstrNotification = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    //
    //  Tell the UI what's going on.
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_STARTING_RESOURCES, &bstrNotification ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_PostCreateResources_LoadString_Starting
            , hr
            , L"Failed the load string for starting resources."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_PostCreateResources_LoadString_Starting
            , IDS_TASKID_MINOR_ERROR_LOADSTRING
            , IDS_REF_MINOR_ERROR_LOADSTRING
            , hr
            );

        goto Cleanup;
    }

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Starting_Resources,
                                0,
                                m_cResources + 2,
                                0,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
    {
        goto Cleanup;
    }
    //  ignore failure

    hr = S_OK;
    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
             TASKID_Minor_PostCreateResources_Starting,
             hr,
             L"[PC-PostCreate] Starting..."
             );

    //
    //  Reset the configure flag on every resource.
    //

    for( idxResource = 0; idxResource < m_cResources ; idxResource ++ )
    {
        hr = THR( m_rgpResources[ idxResource ]->SetConfigured( FALSE ) );
        if ( FAILED( hr ) )
        {
            continue;
        }

    } // for: idxResource

    //
    //  Loop thru the resource calling PostCreate().
    //

    m_cResourcesConfigured = 0;
    for( idxResource = 0; idxResource < m_cResources ; idxResource ++ )
    {
        hr = THR( HrPostCreateResourceAndDependents( idxResource ) );
        if ( FAILED( hr ) )
        {
            continue;
        }

    } // for: ever

    hr = S_OK;

    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
             TASKID_Minor_PostCreateResources_Finished,
             hr,
             L"[PC-PostCreate] Finished."
             );

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Starting_Resources,
                                0,
                                m_cResources + 2,
                                m_cResources + 2,
                                S_OK,
                                NULL,    // don't need to change text
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
    //  ignore failure

Cleanup:
    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} //*** CPostCfgManager::HrPostCreateResources

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPostCfgManager::HrEvictCleanupResources
//
//  Description:
//      Call the EvictCleanup method on each managed resource.
//      This method is only called during an evict cleanup pass and there
//      isn't any UI to display status reports.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrEvictCleanupResources( void )
{
    TraceFunc( "" );

    HRESULT                         hr          = S_OK;
    IClusCfgManagedResourceInfo *   pccmri      = NULL;
    IClusCfgManagedResourceCfg *    pccmrc      = NULL;
    BSTR                            bstrName    = NULL;
    BSTR                            bstrMsg     = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    hr = S_OK;
    SSR_LOG_ERR(
          TASKID_Major_Client_And_Server_Log
        , TASKID_Minor_EvictCleanupResources_Starting
        , hr
        , L"[PC-EvictCleanup] Starting..."
        );

    //
    //  Make sure the enumerator is in the state we think it is.
    //

    hr = STHR( m_peccmr->Reset() );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_EvictCleanup_Reset
            , hr
            , L"[PC-EvictCleanup] Failed to reset the enumerator."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_EvictCleanup_Reset
            , IDS_TASKID_MINOR_ERROR_CLEANUP_RESET
            , IDS_REF_MINOR_ERROR_CLEANUP_RESET
            , hr
            );

        goto Cleanup;
    } // if: failed to reset the enumerator

    //
    //  Loop thru the resources calling EvictCleanup().
    //

    for( ;; )
    {
        //
        //  Cleanup. We put this here because of error conditions below.
        //

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        if ( pccmri != NULL )
        {
            pccmri->Release();
            pccmri = NULL;
        }
        if ( pccmrc != NULL )
        {
            pccmrc->Release();
            pccmrc = NULL;
        }

        //
        //  Ask to get the next resource.
        //

        hr = STHR( m_peccmr->Next( 1, &pccmri, NULL ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_EvictCleanup_EnumResources_Next
                , hr
                , L"[PC-EvictCleanup] Getting next managed resource failed. Aborting."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_NEXT_MANAGED
                , IDS_REF_MINOR_ERROR_NEXT_MANAGED
                , hr
                );

            goto Cleanup;
        } // if: failed to get the next entry from the enumerator

        if ( hr == S_FALSE )
        {
            break;  // exit loop
        }

        //
        //  Retrieve its name for logging, etc.
        //

        hr = THR( pccmri->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_EvictCleanup_EnumResources_GetName
                , hr
                , L"[PC-EvictCleanup] Failed to retrieve a resource's name. Skipping."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_NAME
                , IDS_REF_MINOR_ERROR_GET_RESOURCE_NAME
                , hr
                );

            continue;
        } // if: failed to get the name of the resource

        TraceMemoryAddBSTR( bstrName );

        //
        //  Get the config interface for this resource (if any).
        //

        hr = THR( pccmri->TypeSafeQI( IClusCfgManagedResourceCfg, &pccmrc ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG1(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_EvictCleanup_EnumResources_QI_pccmrc
                , hr
                , L"[PC-EvictCleanup] %1!ws!: Failed QI for IClusCfgManagedResourceCfg. Skipping."
                , bstrMsg
                , bstrName
                );


            STATUS_REPORT_MINOR_REF_POSTCFG1(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_MANAGED_RES_CONFIG
                , IDS_REF_MINOR_ERROR_MANAGED_RES_CONFIG
                , hr
                , bstrName
                );

            continue;
        } // if: failed to get the IClusCfgManagedResourceCfg interface

        //
        // Ask the resource to clean itself up.
        //

        // Don't wrap - this can fail with E_NOTIMPL.
        hr = pccmrc->Evict( NULL );
        if ( FAILED( hr ) )
        {
            if ( hr == E_NOTIMPL )
            {
                SSR_LOG1(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_EvictCleanup_E_NOTIMPL
                    , hr
                    , L"[PC-EvictCleanup] %1!ws!: Failed. Resource returned E_NOTIMPL. This resource will not be cleaned up. Skipping."
                    , bstrMsg
                    , bstrName
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG1(
                      TASKID_Major_Configure_Resources
                    , IDS_TASKID_MINOR_ERROR_RES_NOT_CLEANED
                    , IDS_REF_MINOR_ERROR_RES_NOT_CLEANED
                    , hr
                    , bstrName
                    );

            } // if: resource doesn't support this method
            else
            {
                SSR_LOG1(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_Resource_Failed_Evict
                    , hr
                    , L"[PC-EvictCleanup] %1!ws! failed Evict()."
                    , bstrMsg
                    , bstrName
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG1(
                      TASKID_Major_Configure_Resources
                    , IDS_TASKID_MINOR_ERROR_EVICT
                    , IDS_REF_MINOR_ERROR_EVICT
                    , hr
                    , bstrName
                    );


            } // else: resource's Evict method failed
            continue;
        } // if: Evict on resource failed

        SSR_LOG1(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_EvictCleanup_Succeeded
            , hr
            , L"[PC-EvictCleanup] %1!ws!: Succeeded."
            , bstrMsg
            , bstrName
            );

    } // for ever looping through the managed resource enumerator

    // Failures don't really matter.  We don't want them to abort the
    // evict cleanup process.
    hr = S_OK;

    SSR_LOG_ERR(
          TASKID_Major_Client_And_Server_Log
        , TASKID_Minor_EvictCleanupResources_Finishing
        , hr
        , L"[PC-EvictCleanup] Finished."
        );

Cleanup:

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrMsg );

    if ( pccmrc != NULL )
    {
        pccmrc->Release();
    }
    if ( pccmri != NULL )
    {
        pccmri->Release();
    }

    HRETURN( hr );

} //*** CPostCfgManager::HrEvictCleanupResources

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrFindNextSharedStorage(
//      ULONG idxSeedIn,
//      ULONG * pidxOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrFindNextSharedStorage(
    ULONG * pidxInout
    )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   idxNextDiskResource;

    const CLSID *    pclsidClassType;
    CResourceEntry * presentry;
    EDependencyFlags dfFlags;

    BOOL    fFirstPass = TRUE;

    Assert( pidxInout != NULL );

    for( idxNextDiskResource = *pidxInout + 1
       ; fFirstPass && idxNextDiskResource != *pidxInout
       ; idxNextDiskResource ++
       )
    {
        if ( idxNextDiskResource >= m_cResources )
        {
            fFirstPass = FALSE;
            idxNextDiskResource = m_idxQuorumResource;
        }

        presentry = m_rgpResources[ idxNextDiskResource ];

        hr = THR( presentry->GetClassTypePtr( &pclsidClassType ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_FindNextSharedStorage_GetClassTypePtr
                , hr
                , L"Failed to get resource class type pointer."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_GET_CLASSTYPE_PTR
                , IDS_REF_MINOR_ERROR_GET_CLASSTYPE_PTR
                , hr
                );

            continue;
        }

        //  Skip non-storage class devices
        if ( *pclsidClassType != RESCLASSTYPE_StorageDevice )
            continue;

        hr = THR( presentry->GetFlags( &dfFlags ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_FindNextSharedStorage_GetFlags
                , hr
                , L"Failed to get resource flags."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_FLAGS
                , IDS_REF_MINOR_ERROR_GET_RESOURCE_FLAGS
                , hr
                );

            continue;
        }

        if ( ! ( dfFlags & dfEXCLUSIVE ) )
        {
            *pidxInout = idxNextDiskResource;

            hr = S_OK;

            goto Cleanup;
        }

    } // for: fFirstPass && idxNextDiskResource

    hr = THR( E_FAIL );

Cleanup:
    HRETURN( hr );

} //*** CPostCfgManager::HrFindNextSharedStorage

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrAttemptToAssignStorageToResource(
//      ULONG   idxResource
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrAttemptToAssignStorageToResource(
    ULONG            idxResourceIn,
    EDependencyFlags dfResourceFlagsIn
    )
{
    TraceFunc1( "idxResource = %u", idxResourceIn );

    HRESULT hr;

    ULONG   idxStorage;
    CResourceEntry * presentry;

    //
    //  Find the next available shared storage resource.
    //

    idxStorage = m_idxLastStorage;

    hr = THR( HrFindNextSharedStorage( &idxStorage ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  If the resource wants exclusive rights the the disk, then the quorum
    //  resource can not be used. The quorum device must always have SHARED
    //  access to it.
    //

    if ( ( dfResourceFlagsIn & dfEXCLUSIVE )
      && ( idxStorage == m_idxQuorumResource )
       )
    {
        hr = THR( HrFindNextSharedStorage( &idxStorage ) );
        if ( idxStorage == m_idxQuorumResource )
        {
            //
            //  There must not be anymore storage devices available for exclusive
            //  access. Return failure.
            //

            hr = THR( E_FAIL );

            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrAttemptToAssignStorageToResource_NoMoreStorage
                , hr
                , L"There must not be anymore storage devices available for exclusive access."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_HrAttemptToAssignStorageToResource_NoMoreStorage
                , IDS_TASKID_MINOR_ERROR_AVAILABLE_STORAGE
                , IDS_REF_MINOR_ERROR_AVAILABLE_STORAGE
                , hr
                );

            goto Cleanup;
        }
    }

    presentry = m_rgpResources[ idxStorage ];

    //
    //  Set the dependency flags.
    //

    hr = THR( presentry->SetFlags( dfResourceFlagsIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrAttemptToAssignStorageToResource_SetFlags
            , hr
            , L"Failed to set the dependency flags."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrAttemptToAssignStorageToResource_SetFlags
            , IDS_TASKID_MINOR_ERROR_SET_RES_DEP_FLAGS
            , IDS_REF_MINOR_ERROR_SET_RES_DEP_FLAGS
            , hr
            );

        goto Cleanup;
    }

    //
    //  If the resource wants exclusive access to the storage resource, move
    //  any existing SHARED dependents to another resource. There will always
    //  be at least one SHARED resource because the quorum disk can't not be
    //  assigned to EXCLUSIVE access.
    //

    if ( dfResourceFlagsIn & dfEXCLUSIVE )
    {
        ULONG idxNewStorage = idxStorage;

        hr = THR( HrFindNextSharedStorage( &idxNewStorage ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( HrMovedDependentsToAnotherResource( idxStorage, idxNewStorage ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    //
    //  Add the resource as a dependent of this storage resource.
    //

    hr = THR( presentry->AddDependent( idxResourceIn, dfResourceFlagsIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrAttemptToAssignStorageToResource_AddDependent
            , hr
            , L"Failed to add a dependent."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrAttemptToAssignStorageToResource_AddDependent
            , IDS_TASKID_MINOR_ERROR_ADD_DEPENDENT
            , IDS_REF_MINOR_ERROR_ADD_DEPENDENT
            , hr
            );

        goto Cleanup;
    }

    m_idxLastStorage = idxStorage;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} //*** CPostCfgManager::HrAttemptToAssignStorageToResource


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrMovedDependentsToAnotherResource(
//      ULONG idxSourceIn,
//      ULONG idxDestIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrMovedDependentsToAnotherResource(
    ULONG idxSourceIn,
    ULONG idxDestIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    ULONG               cDependents;
    ULONG               idxDependent;
    EDependencyFlags    dfFlags;
    CResourceEntry  *   presentrySrc;
    CResourceEntry  *   presentryDst;

    //
    //  Move the shared resources to another shared disk.
    //

    presentrySrc = m_rgpResources[ idxSourceIn ];
    presentryDst = m_rgpResources[ idxDestIn ];

    hr = THR( presentrySrc->GetCountOfDependents( &cDependents ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrMovedDependentsToAnotherResource_GetCountOfDependents
            , hr
            , L"Failed to get the count of dependents."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrMovedDependentsToAnotherResource_GetCountOfDependents
            , IDS_TASKID_MINOR_ERROR_COUNT_OF_DEPENDENTS
            , IDS_REF_MINOR_ERROR_COUNT_OF_DEPENDENTS
            , hr
            );

        goto Cleanup;
    }

    for ( ; cDependents != 0 ; )
    {
        cDependents --;

        hr = THR( presentrySrc->GetDependent( cDependents, &idxDependent, &dfFlags ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrMovedDependentsToAnotherResource_GetDependent
                , hr
                , L"Failed to get a resource dependent."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_GET_DEPENDENT
                , IDS_REF_MINOR_ERROR_GET_DEPENDENT
                , hr
                );

            goto Cleanup;
        }

        hr = THR( presentryDst->AddDependent( idxDependent, dfFlags ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrMovedDependentsToAnotherResource_AddDependent
                , hr
                , L"Failed to add a dependent."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_ADD_DEPENDENT
                , IDS_REF_MINOR_ERROR_ADD_DEPENDENT
                , hr
                );

            goto Cleanup;
        }

    } // for: cDependents

    hr = THR( presentrySrc->ClearDependents() );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrMovedDependentsToAnotherResource_ClearDependents
            , hr
            , L"Failed to clear the resource dependents."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrMovedDependentsToAnotherResource_ClearDependents
            , IDS_TASKID_MINOR_ERROR_CLEAR_DEPENDENT
            , IDS_REF_MINOR_ERROR_CLEAR_DEPENDENT
            , hr
            );

        goto Cleanup;
    }

Cleanup:
    HRETURN( hr );

} //*** CPostCfgManager::HrMovedDependentsToAnotherResource

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrSetGroupOnResourceAndItsDependents(
//      ULONG           idxResourceIn,
//      CGroupHandle *  pghIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrSetGroupOnResourceAndItsDependents(
    ULONG   idxResourceIn,
    CGroupHandle * pghIn
    )
{
    TraceFunc1( "idxResourceIn = %u", idxResourceIn );

    HRESULT hr;
    ULONG   cDependents;
    ULONG   idxDependent;

    EDependencyFlags dfDependent;
    CResourceEntry * presentry;

    presentry = m_rgpResources[ idxResourceIn ];

    hr = THR( presentry->SetGroupHandle( pghIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrSetGroupOnResourceAndItsDependents_SetGroupHandle
            , hr
            , L"Failed to set group handle."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrSetGroupOnResourceAndItsDependents_SetGroupHandle
            , IDS_TASKID_MINOR_ERROR_SET_GROUP_HANDLE
            , IDS_REF_MINOR_ERROR_SET_GROUP_HANDLE
            , hr
            );

        goto Cleanup;
    }

    //
    //  Follow the depents list.
    //

    hr = THR( presentry->GetCountOfDependents( &cDependents ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrSetGroupOnResourceAndItsDependents_GetCountOfDependents
            , hr
            , L"Failed to get the count of dependents."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrSetGroupOnResourceAndItsDependents_GetCountOfDependents
            , IDS_TASKID_MINOR_ERROR_COUNT_OF_DEPENDENTS
            , IDS_REF_MINOR_ERROR_COUNT_OF_DEPENDENTS
            , hr
            );

        goto Cleanup;
    }

    for ( ; cDependents != 0 ; )
    {
        cDependents --;

        hr = THR( presentry->GetDependent( cDependents, &idxDependent, &dfDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrSetGroupOnResourceAndItsDependents_GetDependent
                , hr
                , L"Failed to get a resource dependent."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_GET_DEPENDENT
                , IDS_REF_MINOR_ERROR_GET_DEPENDENT
                , hr
                );

            continue;
        }

        hr = THR( HrSetGroupOnResourceAndItsDependents( idxDependent, pghIn ) );
        if ( FAILED( hr ) )
        {
            continue;
        }

    } // for: cDependents

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} //*** CPostCfgManager::HrSetGroupOnResourceAndItsDependents

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrFindGroupFromResourceOrItsDependents(
//      ULONG    idxResourceIn,
//      CGroupHandle ** ppghOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrFindGroupFromResourceOrItsDependents(
    ULONG    idxResourceIn,
    CGroupHandle ** ppghOut
    )
{
    TraceFunc1( "idxResourceIn = %u", idxResourceIn );

    HRESULT hr;
    ULONG   cDependents;
    ULONG   idxDependent;
    BSTR    bstrName;   // don't free
    BSTR    bstrGroup  = NULL;

    HRESOURCE   hResource;
    HRESOURCE   hResourceToClose = NULL;
    HGROUP      hGroup           = NULL;

    EDependencyFlags dfDependent;
    CResourceEntry * presentry;

    BSTR    bstrNotification = NULL;

    Assert( ppghOut != NULL );

    presentry = m_rgpResources[ idxResourceIn ];

    //
    //  See if we already have a cached version of the group handle.
    //

    hr = THR( presentry->GetGroupHandle( ppghOut) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
            TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetGroupHandle
            , hr
            , L"GetGroupHandle() failed."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetGroupHandle
            , IDS_TASKID_MINOR_ERROR_GET_GROUP_HANDLE
            , IDS_REF_MINOR_ERROR_GET_GROUP_HANDLE
            , hr
            );

        goto Cleanup;
    }

    if ( hr == S_OK && *ppghOut != NULL )
    {
        goto Cleanup;
    }

    //
    //  Else, see if we can located an existing resource and group.
    //

    //   don't wrap - this can fail with H_R_W32( ERROR_INVALID_DATA )
    hr = presentry->GetHResource( &hResource );
    if ( FAILED( hr ) )
    {
        Assert( hr == HRESULT_FROM_WIN32( ERROR_INVALID_DATA ) );
        Assert( hResource == NULL );

        //  Just borrowing it's name.... don't free
        hr = THR( presentry->GetName( &bstrName ) );
        if ( hr == S_OK )
        {
            hResourceToClose = OpenClusterResource( m_hCluster, bstrName );
            hResource = hResourceToClose;
        }
    }
    else
    {
        //  Just borrowing its name.... don't free.
        //  We may use the name later on if we need to report an error,
        //  so it's not a big deal if we fail to retrieve is here.
        hr = THR( presentry->GetName( &bstrName ) );
    }

    if ( hResource != NULL )
    {
        CLUSTER_RESOURCE_STATE crs;
        DWORD   cbGroup = 200;

ReAllocGroupName:
        bstrGroup = TraceSysAllocStringLen( NULL, cbGroup );
        if ( bstrGroup == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OutOfMemory
                , hr
                , L"Out of Memory."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OutOfMemory
                , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
                , IDS_REF_MINOR_ERROR_OUT_OF_MEMORY
                , hr
                );

            goto Cleanup;
        }

        crs = GetClusterResourceState( hResource, NULL, NULL, bstrGroup, &cbGroup );
        if ( crs != ClusterResourceStateUnknown )
        {
            hGroup = OpenClusterGroup( m_hCluster, bstrGroup );
            if ( hGroup != NULL )
            {
                hr = THR( CGroupHandle::S_HrCreateInstance( ppghOut, hGroup ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_Create_CGroupHandle
                        , hr
                        , L"Failed to create group handle instance."
                        );

                    STATUS_REPORT_REF_POSTCFG1(
                          TASKID_Major_Configure_Resources
                        , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_Create_CGroupHandle
                        , IDS_TASKID_MINOR_ERROR_CREATE_GROUP_HANDLE
                        , IDS_REF_MINOR_ERROR_CREATE_GROUP_HANDLE
                        , hr
                        , bstrGroup
                        );

                    goto Cleanup;
                }

                hGroup = NULL;  // gave ownership away above
                goto Cleanup;
            } // if: error creating the group
            else
            {
                DWORD sc = TW32( GetLastError() );
                hr = HRESULT_FROM_WIN32( sc );
                SSR_LOG1(
                    TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OpenClusterGroup
                    , hr
                    , L"[PC-Grouping] %1!ws!: OpenClusterGroup() failed. Aborting."
                    , bstrNotification
                    , bstrGroup
                    );

                STATUS_REPORT_REF_POSTCFG1(
                      TASKID_Major_Configure_Resources
                    , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OpenClusterGroup
                    , IDS_TASKID_MINOR_ERROR_OPEN_GROUP
                    , IDS_REF_MINOR_ERROR_OPEN_GROUP
                    , hr
                    , bstrGroup
                    );

                goto Cleanup;
            } // else: error opening the group
        } // if: resource state is known
        else
        {
            DWORD sc = GetLastError();
            switch ( sc )
            {
                case ERROR_MORE_DATA:
                    cbGroup += sizeof( WCHAR ); // add terminating NULL
                    TraceSysFreeString( bstrGroup );
                    goto ReAllocGroupName;

                default:
                    hr = HRESULT_FROM_WIN32( TW32( sc ) );
                    SSR_LOG1(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetClusterResourceState
                        , hr
                        , L"[PC-Grouping] %1!ws!: GetClusterResourceState() failed. Aborting."
                        , bstrNotification
                        , bstrName
                        );

                    STATUS_REPORT_REF_POSTCFG1(
                          TASKID_Major_Configure_Resources
                        , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetClusterResourceState
                        , IDS_TASKID_MINOR_ERROR_RESOURCE_STATE
                        , IDS_REF_MINOR_ERROR_RESOURCE_STATE
                        , hr
                        , bstrName
                        );

                    goto Cleanup;
            } // switch: status code
        } // else: resource state is not known
    } // if: resource is open

    //  else the resource might not exist... continue....

    //
    //  Follow the depents list.
    //

    hr = THR( presentry->GetCountOfDependents( &cDependents ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetCountOfDependents
            , hr
            , L"Failed to get the count of dependents."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetCountOfDependents
            , IDS_TASKID_MINOR_ERROR_COUNT_OF_DEPENDENTS
            , IDS_REF_MINOR_ERROR_COUNT_OF_DEPENDENTS
            , hr
            );

        goto Cleanup;
    }

    for ( ; cDependents != 0 ; )
    {
        cDependents --;

        hr = THR( presentry->GetDependent( cDependents, &idxDependent, &dfDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetDependent
                , hr
                , L"Failed to get a resource dependent."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_GET_DEPENDENT
                , IDS_REF_MINOR_ERROR_GET_DEPENDENT
                , hr
                );

            goto Cleanup;
        }

        hr = STHR( HrFindGroupFromResourceOrItsDependents( idxDependent, ppghOut) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_OK && *ppghOut != NULL )
        {
            goto Cleanup;
        }

    } // for: cDependents

    //
    //  Failed to find an existing group.
    //

    hr = S_FALSE;
    *ppghOut = NULL;

Cleanup:

    if ( hResourceToClose != NULL )
    {
        CloseClusterResource( hResourceToClose );
    }
    if ( hGroup != NULL )
    {
        CloseClusterGroup( hGroup );
    }

    TraceSysFreeString( bstrGroup );
    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} //*** CPostCfgManager::HrFindGroupFromResourceOrItsDependents

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrCreateResourceAndDependents(
//      ULONG       idxResourceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrCreateResourceAndDependents(
    ULONG       idxResourceIn
    )
{
    TraceFunc1( "idxResourceIn = %u", idxResourceIn );

    HRESULT     hr;
    BSTR        bstrName;   // don't free! - this is the resource's copy
    BSTR        bstrNameProp = NULL;
    ULONG       cDependents;
    ULONG       idxDependent;
    HGROUP      hGroup;     // don't close! - this is the resource's copy
    HRESOURCE   hResource = NULL;
    const CLSID * pclsidResType;

    CGroupHandle * pgh;

    EDependencyFlags dfDependent;

    BSTR    bstrNotification = NULL;

    IClusCfgManagedResourceCfg *    pccmrc = NULL;

    CResourceEntry * presentry = m_rgpResources[ idxResourceIn ];

    IUnknown *                      punkServices = NULL;
    IPrivatePostCfgResource *       ppcr         = NULL;
    IClusCfgResourceCreate *        pccrc        = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    //
    //  Create a service object for this resource.
    //

    hr = THR( CCreateServices::S_HrCreateInstance( &punkServices ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceAndDependents_Create_CCreateServices
            , hr
            , L"[PC-Create] Failed to create services object. Aborting."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Minor_Creating_Resource
            , TASKID_Minor_HrCreateResourceAndDependents_Create_CCreateServices
            , IDS_TASKID_MINOR_ERROR_CREATE_SERVICE
            , IDS_REF_MINOR_ERROR_CREATE_SERVICE
            , hr
            );

        goto Cleanup;
    }

    hr = THR( punkServices->TypeSafeQI( IPrivatePostCfgResource, &ppcr ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceAndDependents_Create_CCreateServices_QI
            , hr
            , L"Failed to QI for IPrivatePostCfgResource."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Minor_Creating_Resource
            , TASKID_Minor_HrCreateResourceAndDependents_Create_CCreateServices_QI
            , IDS_TASKID_MINOR_ERROR_CREATE_SERVICE
            , IDS_REF_MINOR_ERROR_CREATE_SERVICE
            , hr
            );

        goto Cleanup;
    }

    hr = THR( ppcr->SetEntry( presentry ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceAndDependents_SetEntry
            , hr
            , L"Failed to set a private post configuration resource entry."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Minor_Creating_Resource
            , TASKID_Minor_HrCreateResourceAndDependents_SetEntry
            , IDS_TASKID_MINOR_ERROR_POST_SETENTRY
            , IDS_REF_MINOR_ERROR_POST_SETENTRY
            , hr
            );

        goto Cleanup;
    }

    //
    //  See if it was configured in a previous pass.
    //

    hr = STHR( presentry->IsConfigured() );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceAndDependents_IsConfigured
            , hr
            , L"Failed to query if resource is configured."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Minor_Creating_Resource
            , TASKID_Minor_HrCreateResourceAndDependents_IsConfigured
            , IDS_TASKID_MINOR_ERROR_ISCONFIGURED
            , IDS_REF_MINOR_ERROR_ISCONFIGURED
            , hr
            );

        goto Cleanup;
    }

    if ( hr == S_FALSE )
    {
        //
        //  Make sure that Create() is not called again because of recursion.
        //

        hr = THR( presentry->SetConfigured( TRUE ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_SetConfigured
                , hr
                , L"Failed to set resource as configured."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Minor_Creating_Resource
                , TASKID_Minor_HrCreateResourceAndDependents_SetConfigured
                , IDS_TASKID_MINOR_ERROR_SETCONFIGURED
                , IDS_REF_MINOR_ERROR_SETCONFIGURED
                , hr
                );

            goto Cleanup;
        }

        //
        //  Grab some useful information: name, group handle, ...
        //

        hr = THR( presentry->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_GetName
                , hr
                , L"Failed to get resource name."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Minor_Creating_Resource
                , TASKID_Minor_HrCreateResourceAndDependents_GetName
                , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_NAME
                , IDS_REF_MINOR_ERROR_GET_RESOURCE_NAME
                , hr
                );

            goto Cleanup;
        }

        hr = THR( presentry->GetGroupHandle( &pgh) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_GetGroupHandle
                , hr
                , L"Failed to get a group handle pointer."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Minor_Creating_Resource
                , TASKID_Minor_HrCreateResourceAndDependents_GetGroupHandle
                , IDS_TASKID_MINOR_ERROR_GET_GROUP_HANDLE_PTR
                , IDS_REF_MINOR_ERROR_GET_GROUP_HANDLE_PTR
                , hr
                );

            goto Cleanup;
        }

        hr = THR( pgh->GetHandle( &hGroup ) );
        pgh->Release();    // release promptly
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_GetHandle
                , hr
                , L"Failed to get a group handle."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Minor_Creating_Resource
                , TASKID_Minor_HrCreateResourceAndDependents_GetHandle
                , IDS_TASKID_MINOR_ERROR_GET_GROUP_HANDLE
                , IDS_REF_MINOR_ERROR_GET_GROUP_HANDLE
                , hr
                );

            goto Cleanup;
        }

        //
        //  Some resource that we pre-create don't have an associated managed resource.
        //  Skip "creating" them but do create their dependents. Note that "special"
        //  resources are create below in the else statement.
        //

        //  Don't wrap - this can fail with Win32 ERROR_INVALID_DATA if the pointer is invalid.
        hr = presentry->GetAssociatedResource( &pccmrc );
        if ( FAILED( hr ) && hr != HRESULT_FROM_WIN32( ERROR_INVALID_DATA ) )
        {
            THR( hr );
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_GetAssociatedResource
                , hr
                , L"Failed to get an associated resource."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Minor_Creating_Resource
                , TASKID_Minor_HrCreateResourceAndDependents_GetAssociatedResource
                , IDS_TASKID_MINOR_ERROR_GET_ASSOC_RES
                , IDS_REF_MINOR_ERROR_GET_ASSOC_RES
                , hr
                );

            goto Cleanup;
        }

        if ( SUCCEEDED( hr ) )
        {
            //  Don't wrap - this can fail with E_NOTIMPL.
            hr = pccmrc->Create( punkServices );
            if ( FAILED( hr ) )
            {
                if ( hr == E_NOTIMPL )
                {
                    hr = S_OK;  // ignore the error.

                } // if: E_NOTIMPL
                else
                {

                    SSR_LOG1(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrCreateResourceAndDependents_Create_Failed
                        , hr
                        , L"[PC-Create] %1!ws!: Create() failed. Its dependents may not be created. Skipping."
                        , bstrNotification
                        , bstrName
                        );

                    STATUS_REPORT_REF_POSTCFG1(
                          TASKID_Minor_Creating_Resource
                        , TASKID_Minor_HrCreateResourceAndDependents_Create_Failed
                        , IDS_TASKID_MINOR_ERROR_CREATE_FAILED
                        , IDS_REF_MINOR_ERROR_CREATE_FAILED
                        , hr
                        , bstrName
                        );

                    if ( hr == E_ABORT )
                        goto Cleanup;
                        //  ignore failure

                } // else: other failure

            } // if: failure

            if ( SUCCEEDED( hr ) )
            {
                LPCWSTR pcszResType;    // don't free.

                hr = THR( presentry->GetTypePtr( &pclsidResType ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrCreateResourceAndDependents_GetTypePtr
                        , hr
                        , L"Failed to get resource type pointer."
                        );

                    STATUS_REPORT_REF_POSTCFG(
                          TASKID_Minor_Creating_Resource
                        , TASKID_Minor_HrCreateResourceAndDependents_GetTypePtr
                        , IDS_TASKID_MINOR_ERROR_GET_RESTYPE_PTR
                        , IDS_REF_MINOR_ERROR_GET_RESTYPE_PTR
                        , hr
                        );

                    goto Cleanup;
                }

                pcszResType = PcszLookupTypeNameByGUID( *pclsidResType );
                if ( pcszResType == NULL )
                {
                    hr = HRESULT_FROM_WIN32 ( ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND );

                    SSR_LOG1(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrCreateResourceAndDependents_PcszLookupTypeNameByGUID
                        , hr
                        , L"[PC-Create] %1!ws!: Resource cannot be created because the resource type is not registered. Its dependents may not be created. Skipping."
                        , bstrNotification
                        , bstrName
                        );

                    STATUS_REPORT_REF_POSTCFG1(
                          TASKID_Minor_Creating_Resource
                        , TASKID_Minor_HrCreateResourceAndDependents_PcszLookupTypeNameByGUID
                        , IDS_TASKID_MINOR_RESTYPE_NOT_REGISTERED
                        , IDS_REF_MINOR_RESTYPE_NOT_REGISTERED
                        , hr
                        , bstrName
                        );
                }
                else
                {
                    hr = THR( HrCreateResourceInstance( idxResourceIn, hGroup, pcszResType, &hResource ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;
                }

            } // if: success

        } // if: interface
        else
        {
            //
            //  See if it is one of the "special" types that we can generate on the fly.
            //

            const CLSID * pclsidType;

            hr = THR( presentry->GetTypePtr( &pclsidType ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrCreateResourceAndDependents_InvalidData_GetTypePtr
                    , hr
                    , L"Failed to get resource type pointer."
                    );

                STATUS_REPORT_REF_POSTCFG(
                      TASKID_Minor_Creating_Resource
                    , TASKID_Minor_HrCreateResourceAndDependents_InvalidData_GetTypePtr
                    , IDS_TASKID_MINOR_ERROR_GET_RESTYPE_PTR
                    , IDS_REF_MINOR_ERROR_GET_RESTYPE_PTR
                    , hr
                    );

                goto Cleanup;
            }

            if ( *pclsidType == RESTYPE_NetworkName )
            {
                //
                //  Create a new network name resource.
                //

                hr = THR( punkServices->TypeSafeQI( IClusCfgResourceCreate, &pccrc ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrCreateResourceAndDependents_NetworkName_QI_pccrc
                        , hr
                        , L"Failed to QI for IClusCfgResourceCreate."
                        );

                    STATUS_REPORT_REF_POSTCFG(
                          TASKID_Minor_Creating_Resource
                        , TASKID_Minor_HrCreateResourceAndDependents_NetworkName_QI_pccrc
                        , IDS_TASKID_MINOR_ERROR_RESOURCE_CREATE
                        , IDS_REF_MINOR_ERROR_RESOURCE_CREATE
                        , hr
                        );

                    goto Cleanup;
                }

                //
                //  Replace the spaces in the resource name with underscores (spaces can't
                //  be used in a computer name).
                //
                bstrNameProp = TraceSysAllocString( bstrName );
                if ( bstrNameProp == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    SSR_LOG_ERR(
                          TASKID_Minor_Creating_Resource
                        , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OutOfMemory
                        , hr
                        , L"Out of Memory."
                        );

                    STATUS_REPORT_REF_POSTCFG(
                          TASKID_Minor_Creating_Resource
                        , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OutOfMemory
                        , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
                        , IDS_REF_MINOR_ERROR_OUT_OF_MEMORY
                        , hr
                        );

                    goto Cleanup;
                }

                hr = THR( HrReplaceTokens( bstrNameProp, L" ", L'_', NULL ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Minor_Creating_Resource
                        ,TASKID_Minor_HrFindGroupFromResourceOrItsDependents_ReplaceTokens
                        ,hr
                        , L"HrReplaceTokens failed. Using resource name for private Name prop."
                        );
                }

                hr = THR( pccrc->SetPropertyString( L"Name", bstrNameProp ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrCreateResourceAndDependents_NetworkName_SetPropertyString
                        , hr
                        , L"Failed to set name property of resurce."
                        );

                    STATUS_REPORT_REF_POSTCFG1(
                          TASKID_Minor_Creating_Resource
                        , TASKID_Minor_HrCreateResourceAndDependents_NetworkName_SetPropertyString
                        , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_NAME
                        , IDS_REF_MINOR_ERROR_SET_RESOURCE_NAME
                        , hr
                        , bstrName
                        );

                    goto Cleanup;
                }

                hr = THR( HrCreateResourceInstance( idxResourceIn, hGroup, L"Network Name", &hResource ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            }
            else if ( *pclsidType == RESTYPE_IPAddress )
            {
                //
                //  Create a new IP address resource.
                //

                hr = THR( punkServices->TypeSafeQI( IClusCfgResourceCreate, &pccrc ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrCreateResourceAndDependents_IPAddress_QI_pccrc
                        , hr
                        , L"Failed to QI for IClusCfgResourceCreate."
                        );

                    STATUS_REPORT_REF_POSTCFG(
                          TASKID_Minor_Creating_Resource
                        , TASKID_Minor_HrCreateResourceAndDependents_IPAddress_QI_pccrc
                        , IDS_TASKID_MINOR_ERROR_RESOURCE_CREATE
                        , IDS_REF_MINOR_ERROR_RESOURCE_CREATE
                        , hr
                        );

                    goto Cleanup;
                }

                //
                //  TODO:   gpease  21-JUN-2000
                //          Since we do not have a way to generate an appropriate IP address,
                //          we don't set any properties. This will cause it to fail to come
                //          online.
                //

                hr = THR( HrCreateResourceInstance( idxResourceIn, hGroup, L"IP Address", &hResource ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            }
            else
            {
                //
                //  else... the resource is one of the pre-created resources that BaseCluster
                //  created. Log and continue creating its dependents.
                //

                hr = S_OK;
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_HrCreateResourceAndDependents_NothingNew,
                          hr,
                          L"[PC-Create] %1!ws!: Nothing new to create. Configuring dependents.",
                          bstrNotification,
                          bstrName
                          );
            }

        } // else: no interface

    } // if: not created
    else
    {
        hr = THR( presentry->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_GetName
                , hr
                , L"Failed to get resource name."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Minor_Creating_Resource
                , TASKID_Minor_HrCreateResourceAndDependents_GetName
                , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_NAME
                , IDS_REF_MINOR_ERROR_GET_RESOURCE_NAME
                , hr
                );

            goto Cleanup;
        }

        hr = THR( presentry->GetHResource( &hResource ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_GetHandle
                , hr
                , L"Failed to get resource handle."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Minor_Creating_Resource
                , TASKID_Minor_HrCreateResourceAndDependents_GetHandle
                , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_HANDLE
                , IDS_REF_MINOR_ERROR_GET_RESOURCE_HANDLE
                , hr
                );

            goto Cleanup;
        }

    } // else: already created

    //
    //  Now that we created the resource instance, we need to create its dependents.
    //

    hr = THR( presentry->GetCountOfDependents( &cDependents ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetCountOfDependents
            , hr
            , L"Failed to get the count of dependents."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Minor_Creating_Resource
            , TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetCountOfDependents
            , IDS_TASKID_MINOR_ERROR_COUNT_OF_DEPENDENTS
            , IDS_REF_MINOR_ERROR_COUNT_OF_DEPENDENTS
            , hr
            );

        goto Cleanup;
    }

    for( ; cDependents != 0; )
    {
        DWORD            dw;
        BSTR             bstrDependent;
        HRESOURCE        hResourceDependent;
        CResourceEntry * presentryDependent;

        cDependents --;

        hr = THR( presentry->GetDependent( cDependents, &idxDependent, &dfDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetDependent
                , hr
                , L"Failed to get a resource dependent."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Minor_Creating_Resource
                , IDS_TASKID_MINOR_ERROR_GET_DEPENDENT
                , IDS_REF_MINOR_ERROR_GET_DEPENDENT
                , hr
                );

            continue;
        }

        hr = THR( HrCreateResourceAndDependents( idxDependent ) );
        if ( FAILED( hr ) )
        {
            continue;
        }

        //
        //  Add the dependencies on the resource.
        //

        presentryDependent = m_rgpResources[ idxDependent ];

        hr = THR( presentryDependent->GetName( &bstrDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetName
                , hr
                , L"Failed to get dependent resource name."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Minor_Creating_Resource
                , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_NAME
                , IDS_REF_MINOR_ERROR_GET_RESOURCE_NAME
                , hr
                );

            continue;
        }

        hr = THR( presentryDependent->GetHResource( &hResourceDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetHResource
                , hr
                , L"Failed to get dependent resource handle."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Minor_Creating_Resource
                , IDS_TASKID_MINOR_ERROR_DEP_RESOURCE_HANDLE
                , IDS_REF_MINOR_ERROR_DEP_RESOURCE_HANDLE
                , hr
                );

            continue;
        }

        // don't wrap - this might fail with ERROR_DEPENDENCY_ALREADY_EXISTS
        dw = AddClusterResourceDependency( hResourceDependent, hResource );
        if ( ( dw != ERROR_SUCCESS ) && ( dw != ERROR_DEPENDENCY_ALREADY_EXISTS ) )
        {
            hr = HRESULT_FROM_WIN32( TW32( dw ) );
            SSR_LOG2(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_Dependents_AddClusterResourceDependency
                , hr
                , L"[PC-Create] %1!ws!: Could not set dependency on %2!ws!."
                , bstrNotification
                , bstrDependent
                , bstrName
                );

            STATUS_REPORT_MINOR_REF_POSTCFG2(
                  TASKID_Minor_Creating_Resource
                , IDS_TASKID_MINOR_ERROR_ADD_RESOURCE_DEPENDENCY
                , IDS_REF_MINOR_ERROR_ADD_RESOURCE_DEPENDENCY
                , hr
                , bstrDependent
                , bstrName
                );
        }
        else
        {
            hr = S_OK;
            SSR_LOG2( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_HrCreateResourceAndDependents_Dependents_Succeeded,
                      hr,
                      L"[PC-Create] %1!ws!: Successfully set dependency set on %2!ws!.",
                      bstrNotification,
                      bstrDependent,
                      bstrName
                      );
        }

    } // for: cDependents

    hr = S_OK;

Cleanup:
    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrNameProp );

    if ( pccmrc != NULL )
    {
        pccmrc->Release();
    }

    if ( punkServices != NULL )
    {
        punkServices->Release();
    }

    if ( ppcr != NULL )
    {
        ppcr->Release();
    }

    if ( pccrc != NULL )
    {
        pccrc->Release();
    }

    HRETURN( hr );

} //*** CPostCfgManager::HrCreateResourceAndDependents

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrPostCreateResourceAndDependents(
//      ULONG       idxResourceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrPostCreateResourceAndDependents(
    ULONG       idxResourceIn
    )
{
    TraceFunc1( "idxResourceIn = %u", idxResourceIn );
    Assert( m_ecmCommitChangesMode != cmUNKNOWN );

    DWORD   sc;

    HRESULT hr;
    BSTR    bstrName;   // don't free
    ULONG   cDependents;
    ULONG   idxDependent;

    HRESOURCE   hResource;

    EDependencyFlags dfDependent;

    BSTR    bstrNotification = NULL;
    BSTR    bstrLocalQuorumNotification = NULL;

    IClusCfgManagedResourceCfg *    pccmrc = NULL;

    CResourceEntry * presentry = m_rgpResources[ idxResourceIn ];

    IUnknown *                      punkServices = NULL;
    IPrivatePostCfgResource *       ppcr         = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    hr = STHR( presentry->IsConfigured() );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPostCreateResourceAndDependents_IsConfigured
            , hr
            , L"Failed to query if resource is configured."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Minor_Starting_Resources
            , TASKID_Minor_HrPostCreateResourceAndDependents_IsConfigured
            , IDS_TASKID_MINOR_ERROR_ISCONFIGURED
            , IDS_REF_MINOR_ERROR_ISCONFIGURED
            , hr
            );

        goto Cleanup;
    }

    if ( hr == S_FALSE )
    {
        //
        //  Make sure that PostCreate() is not called again because of recursion.
        //

        hr = THR( presentry->SetConfigured( TRUE ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrPostCreateResourceAndDependents_SetConfigured
                , hr
                , L"Failed to set resource as configured."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Minor_Starting_Resources
                , TASKID_Minor_HrPostCreateResourceAndDependents_SetConfigured
                , IDS_TASKID_MINOR_ERROR_SETCONFIGURED
                , IDS_REF_MINOR_ERROR_SETCONFIGURED
                , hr
                );

            goto Cleanup;
        }

        //
        //  Grab the name of the resource for logging.
        //

        hr = THR( presentry->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrPostCreateResourceAndDependents_GetName
                , hr
                , L"Failed to get resource name."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Minor_Starting_Resources
                , TASKID_Minor_HrPostCreateResourceAndDependents_GetName
                , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_NAME
                , IDS_REF_MINOR_ERROR_GET_RESOURCE_NAME
                , hr
                );

            goto Cleanup;
        }

        //
        //  Bring the resource online.
        //

        hr = presentry->GetHResource( &hResource );
        if ( SUCCEEDED( hr ) )
        {
            //  Don't wrap - can return ERROR_IO_PENDING.
            sc = OnlineClusterResource( hResource );
            switch ( sc )
            {
            case ERROR_SUCCESS:
                hr = S_OK;

                SSR_LOG1(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrPostCreateResourceAndDependents_OpenClusterResource
                    , hr
                    , L"[PC-PostCreate] %1!ws!: Resource brought online successfully."
                    , bstrNotification
                    , bstrName
                    );

                STATUS_REPORT_MINOR_POSTCFG1(
                      TASKID_Minor_Starting_Resources
                    , IDS_TASKID_MINOR_RESOURCE_ONLINE
                    , hr
                    , bstrName
                    );

                break;

            case ERROR_IO_PENDING:
                {
                    CLUSTER_RESOURCE_STATE crs = ClusterResourceOnlinePending;
                    HRESULT                hr2 = S_OK;

                    hr = HRESULT_FROM_WIN32( sc );

                    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                              TASKID_Minor_HrPostCreateResourceAndDependents_OpenClusterResourcePending,
                              hr2,
                              L"[PC-PostCreate] %1!ws!: Online pending...",
                              bstrNotification,
                              bstrName
                              );

                    for( ; crs == ClusterResourceOnlinePending ; )
                    {
                        crs = GetClusterResourceState( hResource,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       NULL
                                                       );

                        switch ( crs )
                        {
                        case ClusterResourceOnline:
                            hr = S_OK;

                            SSR_LOG1(
                                  TASKID_Major_Client_And_Server_Log
                                , TASKID_Minor_HrPostCreateResourceAndDependents_OpenClusterResource
                                , hr
                                , L"[PC-PostCreate] %1!ws!: Resource brought online successfully."
                                , bstrNotification
                                , bstrName
                                );

                            STATUS_REPORT_MINOR_POSTCFG1(
                                  TASKID_Minor_Starting_Resources
                                , IDS_TASKID_MINOR_RESOURCE_ONLINE
                                , hr
                                , bstrName
                                );
                            break;

                        case ClusterResourceInitializing:
                            crs = ClusterResourceOnlinePending;
                            // fall thru

                        case ClusterResourceOnlinePending:
                            Sleep( 500 );   // sleep a 1/2 second
                            break;

                        case ClusterResourceStateUnknown:
                            sc = GetLastError();
                            hr = HRESULT_FROM_WIN32( TW32( sc ) );

                            SSR_LOG1(
                                  TASKID_Major_Client_And_Server_Log
                                , TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceStateUnknown
                                , hr
                                , L"[PC-PostCreate] %1!ws!: Resource failed to come online. Dependent resources might fail too."
                                , bstrNotification
                                , bstrName
                                );

                            STATUS_REPORT_MINOR_REF_POSTCFG1(
                                  TASKID_Minor_Starting_Resources
                                , IDS_TASKID_MINOR_RESOURCE_FAIL_ONLINE
                                , IDS_REF_MINOR_RESOURCE_FAIL_ONLINE
                                , hr
                                , bstrName
                                );

                            break;

                        case ClusterResourceOfflinePending:
                        case ClusterResourceOffline:
                            hr = THR( E_FAIL );

                            SSR_LOG1(
                                  TASKID_Major_Client_And_Server_Log
                                , TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceOffline
                                , hr
                                , L"[PC-PostCreate] %1!ws!: Resource went offline. Dependent resources might fail too."
                                , bstrNotification
                                , bstrName
                                );

                            STATUS_REPORT_MINOR_REF_POSTCFG1(
                                  TASKID_Minor_Starting_Resources
                                , IDS_TASKID_MINOR_RESOURCE_WENT_OFFLINE
                                , IDS_REF_MINOR_RESOURCE_WENT_OFFLINE
                                , hr
                                , bstrName
                                );

                            break;

                        case ClusterResourceFailed:
                            hr = E_FAIL;

                            SSR_LOG1(
                                  TASKID_Major_Client_And_Server_Log
                                , TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceFailed
                                , hr
                                , L"[PC-PostCreate] %1!ws!: Resource failed. Check Event Log. Dependent resources might fail too."
                                , bstrNotification
                                , bstrName
                                );

                            STATUS_REPORT_MINOR_REF_POSTCFG1(
                                  TASKID_Minor_Starting_Resources
                                , IDS_TASKID_MINOR_RESOURCE_FAILED
                                , IDS_REF_MINOR_RESOURCE_FAILED
                                , hr
                                , bstrName
                                );

                            break;

                        } // switch: crs

                    } // for: crs
                }
                break;

            default:
                hr = HRESULT_FROM_WIN32( TW32( sc ) );

                SSR_LOG1(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrPostCreateResourceAndDependents_OnlineClusterResource_Failed
                    , hr
                    , L"[PC-PostCreate] %1!ws!: Resource failed to come online. Dependent resources might fail too."
                    , bstrNotification
                    , bstrName
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG1(
                      TASKID_Minor_Starting_Resources
                    , IDS_TASKID_MINOR_RESOURCE_FAIL_ONLINE
                    , IDS_REF_MINOR_RESOURCE_FAIL_ONLINE
                    , hr
                    , bstrName
                    );

                break;

            } // switch: sc

        } // if: hResource

        //
        //  Set it to the quorum resource if marked so.
        //

        if ( SUCCEEDED( hr ) && idxResourceIn == m_idxQuorumResource && m_fIsQuorumChanged )
        {
            DWORD   cchResName = 0;
            DWORD   cchDevName = 0;
            DWORD   dwMaxQuorumLogSize = 0;

            //
            // First, get the old max quorum log size.  If we fail use the default log size.
            //
            sc = TW32( GetClusterQuorumResource(
                            m_hCluster,
                            NULL,
                            &cchResName,
                            NULL,
                            &cchDevName,
                            &dwMaxQuorumLogSize
                        ) );

            if ( sc != ERROR_SUCCESS )
            {
                SSR_LOG1(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_HrPostCreateResourceAndDependents_GetClusterQuorumResource_Failed
                    , sc
                    , L"[PC-PostCreate] Failed to retrieve the current max log size. Defaulting to %1!d!."
                    , bstrNotification
                    , CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG(
                      TASKID_Minor_Starting_Resources
                    , IDS_TASKID_MINOR_ERROR_GET_QUORUM_LOG_SIZE
                    , IDS_REF_MINOR_ERROR_GET_QUORUM_LOG_SIZE
                    , sc
                    );

                dwMaxQuorumLogSize = CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE;
            }

            sc = TW32( SetClusterQuorumResource( hResource, NULL, dwMaxQuorumLogSize ) );
            if ( sc != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( sc );
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_HrPostCreateResourceAndDependents_SetClusterQuorumResource,
                          hr,
                          L"[PC-PostCreate] %1!ws!: Failure setting resource to be the quorum resource.",
                          bstrNotification,
                          bstrName
                          );

                STATUS_REPORT_MINOR_REF_POSTCFG1(
                      TASKID_Minor_Starting_Resources
                    , IDS_TASKID_MINOR_ERROR_SET_QUORUM_RES
                    , IDS_REF_MINOR_ERROR_SET_QUORUM_RES
                    , hr
                    , bstrName
                    );
            }
            else
            {
                SSR_LOG1(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrPostCreateResourceAndDependents_SetClusterQuorumResource_Succeeded
                    , hr
                    , L"[PC-PostCreate] %1!ws!: Successfully set as quorum resource."
                    , bstrNotification
                    , bstrName
                    );
            }

            //
            //  Create a notification about setting the quorum resource.
            //

            hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                               IDS_TASKID_MINOR_SET_QUORUM_DEVICE,
                                               &bstrNotification,
                                               bstrName
                                               ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrPostCreateResourceAndDependents_FormatMessage_SetQuorum
                    , hr
                    , L"Failed to format a message for quorum resource."
                    );

                STATUS_REPORT_POSTCFG(
                      TASKID_Major_Configure_Resources
                    , TASKID_Minor_HrPostCreateResourceAndDependents_FormatMessage_SetQuorum
                    , IDS_TASKID_MINOR_ERROR_FORMAT_STRING
                    , hr
                    );

                //  ignore the failure.
            }

            //
            //  Send a status that we found the quorum device.
            //

            hr = THR( SendStatusReport( NULL,
                                        TASKID_Major_Configure_Resources,
                                        TASKID_Minor_Set_Quorum_Device,
                                        5,
                                        5,
                                        5,
                                        HRESULT_FROM_WIN32( sc ),
                                        bstrNotification,
                                        NULL,
                                        NULL
                                        ) );
            if ( hr == E_ABORT )
            {
                goto Cleanup;
            }
                //  ignore failure


            // Do this only if the quorum has changed.
            if ( ( sc == ERROR_SUCCESS ) && ( m_ecmCommitChangesMode == cmCREATE_CLUSTER ) && ( m_fIsQuorumChanged == TRUE ) )
            {
                TraceFlow( "We are forming a cluster and the quorum resouce has changed - trying to delete the local quorum resource." );

                m_dwLocalQuorumStatusMax = 62; // one status message, base-zero offset (1), plus up to 60 one-second retries

                //
                // If we are here, we are forming and we have successfully set a new quorum resource.
                // So, delete the local quorum resource.
                //

                // Create a notification about deleting the local quorum resource.
                hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_DELETING_LOCAL_QUORUM_RESOURCE, &bstrLocalQuorumNotification ) );
                //  ignore the failure.

                //  Send a status that we are deleting the quorum device.
                hr = THR( SendStatusReport( NULL,
                                            TASKID_Major_Configure_Resources,
                                            TASKID_Minor_Delete_LocalQuorum,
                                            0,
                                            m_dwLocalQuorumStatusMax,
                                            0,
                                            HRESULT_FROM_WIN32( sc ),
                                            bstrLocalQuorumNotification,
                                            NULL,
                                            NULL
                                            ) );

                //
                // KB:  GPotts  01-May-2002
                //
                // This will enumerate all Local Quorum resources and delete them.  We're assuming
                // that only one will be created and thus only one will be deleted since we're executing
                // inside an 'if mode == create' block.  If the create behavior changes in the future
                // to create multiple LQ resources then the SendStatusReport calls here and in the
                // S_ScDeleteLocalQuorumResource function will need to modified accordingly to
                // reflect a more appropriate max count and properly track the current count.
                //
                sc = TW32(
                    ResUtilEnumResourcesEx(
                          m_hCluster
                        , NULL
                        , CLUS_RESTYPE_NAME_LKQUORUM
                        , S_ScDeleteLocalQuorumResource
                        , this
                        )
                    );

                if ( sc != ERROR_SUCCESS )
                {
                    LogMsg( "[PC-PostCfg] An error occurred trying to enumerate local quorum resources (sc=%#08x).", sc );

                    STATUS_REPORT_MINOR_POSTCFG(
                          TASKID_Minor_Starting_Resources
                        , IDS_TASKID_MINOR_ERROR_ENUM_QUORUM
                        , hr
                        );

                } // if: an error occurred trying to enumerate all local quorum resources
                else
                {
                    LogMsg( "[PC-PostCfg] Successfully deleted the local quorum resource." );
                } // if: we successfully deleted the localquorum resource

                //  Complete the status that we are deleting the quorum device.
                hr = THR( SendStatusReport( NULL,
                                            TASKID_Major_Configure_Resources,
                                            TASKID_Minor_Delete_LocalQuorum,
                                            0,
                                            m_dwLocalQuorumStatusMax,
                                            m_dwLocalQuorumStatusMax,
                                            HRESULT_FROM_WIN32( sc ),
                                            NULL,    // don't update text
                                            NULL,
                                            NULL
                                            ) );

            } // if: we are forming a cluster and there have been no errors setting the quorum resource

            hr = THR( SendStatusReport( NULL,
                                        TASKID_Major_Configure_Resources,
                                        TASKID_Minor_Locate_Existing_Quorum_Device,
                                        10,
                                        10,
                                        10,
                                        hr,
                                        NULL,    // don't update text
                                        NULL,
                                        NULL
                                        ) );
            if ( hr == E_ABORT )
                goto Cleanup;
                //  ignore failure

        }

        //
        //  Some resource that we pre-create don't have an associated
        //  managed resource. Skip "creating" them but do create their
        //  dependents.
        //

        //  Don't wrap - this can fail with Win32 ERROR_INVALID_DATA if the pointer is invalid.
        hr = presentry->GetAssociatedResource( &pccmrc );
        if ( FAILED( hr ) && hr != HRESULT_FROM_WIN32( ERROR_INVALID_DATA ) )
        {
            THR( hr );
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrPostCreateResourceAndDependents_GetAssociatedResource
                , hr
                , L"Failed to get an associated resource."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Minor_Starting_Resources
                , IDS_TASKID_MINOR_ERROR_GET_ASSOC_RES
                , IDS_REF_MINOR_ERROR_GET_ASSOC_RES
                , hr
                );

            goto Error;
        }

        if ( SUCCEEDED( hr ) )
        {
            //
            //  Create a service object for this resource.
            //

            hr = THR( CPostCreateServices::S_HrCreateInstance( &punkServices ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrPostCreateResourceAndDependents_Create_CPostCreateServices,
                         hr,
                         L"[PC-PostCreate] Failed to create services object. Aborting."
                         );

                STATUS_REPORT_MINOR_REF_POSTCFG(
                      TASKID_Minor_Starting_Resources
                    , IDS_TASKID_MINOR_ERROR_CREATE_SERVICE
                    , IDS_REF_MINOR_ERROR_CREATE_SERVICE
                    , hr
                    );

                goto Error;
            }

            hr = THR( punkServices->TypeSafeQI( IPrivatePostCfgResource, &ppcr ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrPostCreateResourceAndDependents_Create_CPostCreateServices_QI_ppcr
                    , hr
                    , L"[PC-PostCreate] Failed to get IPrivatePostCfgResource. Aborting."
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG(
                      TASKID_Minor_Starting_Resources
                    , IDS_TASKID_MINOR_ERROR_CREATE_SERVICE
                    , IDS_REF_MINOR_ERROR_CREATE_SERVICE
                    , hr
                    );

                goto Error;
            }

            hr = THR( ppcr->SetEntry( presentry ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrPostCreateResourceAndDependents_SetEntry
                    , hr
                    , L"[PC-PostCreate] Failed to set entry for private post configuration resource."
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG(
                      TASKID_Minor_Starting_Resources
                    , IDS_TASKID_MINOR_ERROR_POST_SETENTRY
                    , IDS_REF_MINOR_ERROR_POST_SETENTRY
                    , hr
                    );

                goto Error;
            }

            //  Don't wrap - this can fail with E_NOTIMPL.
            hr = pccmrc->PostCreate( punkServices );
            if ( FAILED( hr ) )
            {
                if ( hr == E_NOTIMPL )
                {
                    SSR_LOG1(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_E_NOTIMPL
                        , hr
                        , L"[PC-PostCreate] %1!ws!: PostCreate() returned E_NOTIMPL. Ignoring."
                        , bstrNotification
                        , bstrName
                         );

                } // if: E_NOTIMPL
                else
                {
                    SSR_LOG1(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_Failed
                        , hr
                        , L"[PC-PostCreate] %1!ws!: PostCreate() failed. Ignoring."
                        , bstrNotification
                        , bstrName
                        );


                    STATUS_REPORT_REF_POSTCFG1(
                          TASKID_Minor_Starting_Resources
                        , TASKID_Minor_Resource_Failed_PostCreate
                        , IDS_TASKID_MINOR_RESOURCE_FAILED_POSTCREATE
                        , IDS_REF_MINOR_RESOURCE_FAILED_POSTCREATE
                        , hr
                        , bstrName
                        );

                } // else: other failure

            } // if: failure
            else
            {
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_Succeeded,
                          hr,
                          L"[PC-PostCreate] %1!ws!: PostCreate() succeeded.",
                          bstrNotification,
                          bstrName
                          );

            } // else: success

        } // if: inteface
        else
        {
            if ( hr == HRESULT_FROM_WIN32( ERROR_INVALID_DATA ) )
            {
                hr = S_OK;
            }

            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_NotNeeded,
                      hr,
                      L"[PC-PostCreate] %1!ws!: No PostCreate() needed. Configuring dependents.",
                      bstrNotification,
                      bstrName
                      );

        } // else: no interface

    } // if: not created

    //
    //  Now that we created the resource instance, we need to create its dependents.
    //

    hr = THR( presentry->GetCountOfDependents( &cDependents ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPostCreateResourceAndDependents_GetCountOfDependents
            , hr
            , L"[PC-PostCreate] Failed to get count of resource instance dependents."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Minor_Starting_Resources
            , TASKID_Minor_HrPostCreateResourceAndDependents_GetCountOfDependents
            , IDS_TASKID_MINOR_ERROR_COUNT_OF_DEPENDENTS
            , IDS_REF_MINOR_ERROR_COUNT_OF_DEPENDENTS
            , hr
            );

        goto Error;
    }

    for( ; cDependents != 0; )
    {
        cDependents --;

        hr = THR( presentry->GetDependent( cDependents, &idxDependent, &dfDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrPostCreateResourceAndDependents_GetDependent
                , hr
                , L"[PC-PostCreate] Failed to get a resource dependent."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Minor_Starting_Resources
                , IDS_TASKID_MINOR_ERROR_GET_DEPENDENT
                , IDS_REF_MINOR_ERROR_GET_DEPENDENT
                , hr
                );

            continue;
        }

        hr = THR( HrPostCreateResourceAndDependents( idxDependent ) );
        if ( FAILED( hr ) )
            continue;

    } // for: cDependents

    //
    //  Update the UI layer.
    //

    m_cResourcesConfigured++;
    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Starting_Resources,
                                0,
                                m_cResources + 2,
                                m_cResourcesConfigured,
                                S_OK,
                                NULL,    // don't need to change text
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
    {
        //  ignore failure
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    if ( pccmrc != NULL )
    {
        pccmrc->Release();
    }

    if ( punkServices != NULL )
    {
        punkServices->Release();
    }

    if ( ppcr != NULL )
    {
        ppcr->Release();
    }

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrLocalQuorumNotification );

    HRETURN( hr );

Error:

    m_cResourcesConfigured++;
    THR( SendStatusReport( NULL,
                           TASKID_Major_Configure_Resources,
                           TASKID_Minor_Starting_Resources,
                           0,
                           m_cResources + 2,
                           m_cResourcesConfigured,
                           hr,
                           NULL,    // don't need to change text
                           NULL,
                           NULL
                           ) );
    goto Cleanup;

} //*** CPostCfgManager::HrPostCreateResourceAndDependents


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CPostCfgManager::HrNotifyMemberSetChangeListeners
//
//  Description:
//      Notify all components on the local computer registered to get
//      notification of cluster member set change (form, join or evict).
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the notifications.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrNotifyMemberSetChangeListeners( void )
{
    TraceFunc( "" );

    const UINT          uiCHUNK_SIZE = 16;

    HRESULT             hr = S_OK;
    ICatInformation *   pciCatInfo = NULL;
    IEnumCLSID *        plceListenerClsidEnum = NULL;

    ULONG               cReturned = 0;
    CATID               rgCatIdsImplemented[ 1 ];

    //  Validate state
    Assert( m_pccci != NULL );

    rgCatIdsImplemented[ 0 ] = CATID_ClusCfgMemberSetChangeListeners;

    //
    // Enumerate all the enumerators registered in the
    // CATID_ClusCfgMemberSetChangeListeners category
    //
    hr = THR(
            CoCreateInstance(
                  CLSID_StdComponentCategoriesMgr
                , NULL
                , CLSCTX_SERVER
                , IID_ICatInformation
                , reinterpret_cast< void ** >( &pciCatInfo )
                )
            );

    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrNotifyMemberSetChangeListeners_CoCreate_StdComponentCategoriesMgr
            , hr
            , L"Error occurred trying to get a pointer to the enumerator of the CATID_ClusCfgMemberSetChangeListeners category."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrNotifyMemberSetChangeListeners_CoCreate_StdComponentCategoriesMgr
            , IDS_TASKID_MINOR_ERROR_COMPONENT_CATEGORY_MGR
            , IDS_REF_MINOR_ERROR_COMPONENT_CATEGORY_MGR
            , hr
            );

        goto Cleanup;
    } // if: we could not get a pointer to the ICatInformation interface

    // Get a pointer to the enumerator of the CLSIDs that belong to
    // the CATID_ClusCfgMemberSetChangeListeners category.
    hr = THR(
        pciCatInfo->EnumClassesOfCategories(
              1
            , rgCatIdsImplemented
            , 0
            , NULL
            , &plceListenerClsidEnum
            )
        );

    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrNotifyMemberSetChangeListeners_EnumClassesOfCategories
            , hr
            , L"Error occurred trying to get a pointer to the enumerator of the CATID_ClusCfgMemberSetChangeListeners category."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrNotifyMemberSetChangeListeners_EnumClassesOfCategories
            , IDS_TASKID_MINOR_ERROR_COMPONENT_ENUM_CLASS
            , IDS_REF_MINOR_ERROR_COMPONENT_ENUM_CLASS
            , hr
            );

        goto Cleanup;
    } // if: we could not get a pointer to the IEnumCLSID interface

    // Enumerate the CLSIDs of the registered enumerators
    do
    {
        CLSID   rgListenerClsidArray[ uiCHUNK_SIZE ];
        ULONG   idxCLSID;

        hr = STHR(
            plceListenerClsidEnum->Next(
                  uiCHUNK_SIZE
                , rgListenerClsidArray
                , &cReturned
                )
            );

        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrNotifyMemberSetChangeListeners_Next,
                         hr,
                         L"Error occurred trying enumerate member set listener enumerators."
                         );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_NEXT_LISTENER
                , IDS_REF_MINOR_ERROR_NEXT_LISTENER
                , hr
                );

            break;
        } // if: we could not get a pointer to the IEnumCLSID interface

        // hr may be S_FALSE here, so reset it.
        hr = S_OK;

        for ( idxCLSID = 0; idxCLSID < cReturned; ++idxCLSID )
        {
            hr = THR( HrProcessMemberSetChangeListener( rgListenerClsidArray[ idxCLSID ] ) );
            if ( FAILED( hr ) )
            {
                // The processing of one of the listeners failed.
                // Log the error, but continue processing other listeners.
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrNotifyMemberSetChangeListeners_HrProcessMemberSetChangeListener
                    , hr
                    , L"Error occurred trying to process a member set change listener. Ignoring. Other listeners will be processed."
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG(
                      TASKID_Major_Configure_Resources
                    , IDS_TASKID_MINOR_ERROR_PROCESS_LISTENER
                    , IDS_REF_MINOR_ERROR_PROCESS_LISTENER
                    , hr
                    );

                hr = S_OK;
            } // if: this listener failed
        } // for: iterate through the returned CLSIDs
    }
    while( cReturned > 0 ); // while: there are still CLSIDs to be enumerated

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: something went wrong in the loop above

Cleanup:

    //
    // Cleanup code
    //

    if ( pciCatInfo != NULL )
    {
        pciCatInfo->Release();
    } // if: we had obtained a pointer to the ICatInformation interface

    if ( plceListenerClsidEnum != NULL )
    {
        plceListenerClsidEnum->Release();
    } // if: we had obtained a pointer to the enumerator of listener CLSIDs

    HRETURN( hr );

} //*** CPostCfgManager::HrNotifyMemberSetChangeListeners


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CPostCfgManager::HrProcessMemberSetChangeListener
//
//  Description:
//      This function notifies a listener of cluster member set changes.
//
//  Arguments:
//      rclsidListenerClsidIn
//          CLSID of the listener component.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the notification.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrProcessMemberSetChangeListener(
      const CLSID & rclsidListenerClsidIn
    )
{
    TraceFunc( "" );

    HRESULT                             hr = S_OK;
    IClusCfgMemberSetChangeListener *   pccmclListener = NULL;
    IClusCfgInitialize *                picci = NULL;

    TraceMsgGUID( mtfFUNC, "The CLSID of this listener is ", rclsidListenerClsidIn );

    //
    // Create the listener represented by the CLSID passed in
    //
    hr = THR(
            CoCreateInstance(
                  rclsidListenerClsidIn
                , NULL
                , CLSCTX_INPROC_SERVER
                , __uuidof( pccmclListener )
                , reinterpret_cast< void ** >( &pccmclListener )
                )
            );

    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrProcessMemberSetChangeListener_CoCreate_Listener
            , hr
            , L"Error occurred trying to get a pointer to the the member set change listener."
            );

        STATUS_REPORT_MINOR_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_GET_LISTENER_PTR
            , IDS_REF_MINOR_ERROR_GET_LISTENER_PTR
            , hr
            );

        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgMemberSetChangeListener interface

    //
    //  If the component wants to be initialized, i.e. they implement
    //  IClusCfgInitiaze, then we should initialize them.  If they
    //  don't want to be initialized then skip it.
    //

    hr = pccmclListener->TypeSafeQI( IClusCfgInitialize, &picci );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( picci->Initialize( m_pcccb, m_lcid ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if: Interface found.
    else if ( hr == E_NOINTERFACE )
    {
        //
        //  Component does not want to be initialized.
        //

        hr = S_OK;
    } // else if: No interface.
    else
    {
        //
        //  QI failed with an unexpected error.
        //

        THR( hr );
        goto Cleanup;
    } // else: QI failed.

    hr = THR( pccmclListener->Notify( m_pccci ) );

    if ( FAILED( hr ) )
    {
        // The processing of this listeners failed.
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrProcessMemberSetChangeListener_Notify
            , hr
            , L"Error occurred trying to notify a listener."
            );

        STATUS_REPORT_MINOR_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_NOTIFY_LISTENER
            , IDS_REF_MINOR_ERROR_NOTIFY_LISTENER
            , hr
            );

        goto Cleanup;
    } // if: this listeners failed

Cleanup:

    //
    // Cleanup code
    //

    if ( picci != NULL )
    {
        picci->Release();
    } // if:

    if ( pccmclListener != NULL )
    {
        pccmclListener->Release();
    } // if: we had obtained a pointer to the listener interface

    HRETURN( hr );

} //*** CPostCfgManager::HrProcessMemberSetChangeListener


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CPostCfgManager::HrConfigureResTypes
//
//  Description:
//      Enumerate all components on the local computer registered for resource
//      type configuration.
//
//  Arguments:
//      IUnknown * punkResTypeServicesIn
//          A pointer to the IUnknown interface on a component that provides
//          services that help configure resource types.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the enumeration.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrConfigureResTypes( IUnknown * punkResTypeServicesIn )
{
    TraceFunc( "" );

    const UINT          uiCHUNK_SIZE = 16;

    HRESULT             hr = S_OK;
    ICatInformation *   pciCatInfo = NULL;
    IEnumCLSID *        prceResTypeClsidEnum = NULL;

    ULONG               cReturned = 0;
    CATID               rgCatIdsImplemented[ 1 ];

    //  Validate state
    Assert( m_pccci != NULL );

    rgCatIdsImplemented[ 0 ] = CATID_ClusCfgResourceTypes;

    //
    // Enumerate all the enumerators registered in the
    // CATID_ClusCfgResourceTypes category
    //
    hr = THR(
            CoCreateInstance(
                  CLSID_StdComponentCategoriesMgr
                , NULL
                , CLSCTX_SERVER
                , IID_ICatInformation
                , reinterpret_cast< void ** >( &pciCatInfo )
                )
            );

    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrConfigureResTypes_CoCreate_CategoriesMgr
            , hr
            , L"Error occurred trying to get a pointer to the enumerator of the CATID_ClusCfgResourceTypes category."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrConfigureResTypes_CoCreate_CategoriesMgr
            , IDS_TASKID_MINOR_ERROR_COMPONENT_CATEGORY_MGR
            , IDS_REF_MINOR_ERROR_COMPONENT_CATEGORY_MGR
            , hr
            );

        goto Cleanup;
    } // if: we could not get a pointer to the ICatInformation interface

    // Get a pointer to the enumerator of the CLSIDs that belong to the CATID_ClusCfgResourceTypes category.
    hr = THR(
        pciCatInfo->EnumClassesOfCategories(
              1
            , rgCatIdsImplemented
            , 0
            , NULL
            , &prceResTypeClsidEnum
            )
        );

    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
            TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrConfigureResTypes_Enum
            , hr
            , L"Error occurred trying to get a pointer to the enumerator of the CATID_ClusCfgResourceTypes category."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrConfigureResTypes_Enum
            , IDS_TASKID_MINOR_ERROR_COMPONENT_ENUM_CLASS
            , IDS_REF_MINOR_ERROR_COMPONENT_ENUM_CLASS
            , hr
            );

        goto Cleanup;
    } // if: we could not get a pointer to the IEnumCLSID interface

    // Enumerate the CLSIDs of the registered resource types
    do
    {
        CLSID   rgResTypeCLSIDArray[ uiCHUNK_SIZE ];
        ULONG   idxCLSID;

        cReturned = 0;
        hr = STHR(
            prceResTypeClsidEnum->Next(
                  uiCHUNK_SIZE
                , rgResTypeCLSIDArray
                , &cReturned
                )
            );

        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrConfigureResTypes_Next
                , hr
                , L"Error occurred trying enumerate resource type configuration components."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_NEXT_LISTENER
                , IDS_REF_MINOR_ERROR_NEXT_LISTENER
                , hr
                );

            break;
        } // if: we could not get the next set of CLSIDs

        // hr may be S_FALSE here, so reset it.
        hr = S_OK;

        for ( idxCLSID = 0; idxCLSID < cReturned; ++idxCLSID )
        {
            hr = THR( HrProcessResType( rgResTypeCLSIDArray[ idxCLSID ], punkResTypeServicesIn ) );

            if ( FAILED( hr ) )
            {
                LPWSTR  pszCLSID = NULL;
                BSTR    bstrNotification = NULL;

                THR( StringFromCLSID( rgResTypeCLSIDArray[ idxCLSID ], &pszCLSID ) );

                // The processing of one of the resource types failed.
                // Log the error, but continue processing other resource types.
                SSR_LOG1(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrConfigureResTypes_HrProcessResType
                    , hr
                    , L"[PC-ResType] Error occurred trying to process a resource type. Ignoring. Other resource types will be processed. The CLSID of the failed resource type is %1!ws!."
                    , bstrNotification
                    , pszCLSID
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG1(
                      TASKID_Major_Configure_Resources
                    , IDS_TASKID_MINOR_ERROR_PROCESS_RESOURCE_TYPE
                    , IDS_REF_MINOR_ERROR_PROCESS_RESOURCE_TYPE
                    , hr
                    , pszCLSID
                    );

                TraceSysFreeString( bstrNotification );
                CoTaskMemFree( pszCLSID );

                hr = S_OK;
            } // if: this enumerator failed
        } // for: iterate through the returned CLSIDs
    }
    while( cReturned > 0 ); // while: there are still CLSIDs to be enumerated

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: something went wrong in the loop above

Cleanup:

    //
    // Cleanup code
    //

    if ( pciCatInfo != NULL )
    {
        pciCatInfo->Release();
    } // if: we had obtained a pointer to the ICatInformation interface

    if ( prceResTypeClsidEnum != NULL )
    {
        prceResTypeClsidEnum->Release();
    } // if: we had obtained a pointer to the enumerator of resource type CLSIDs

    HRETURN( hr );

} //*** CPostCfgManager::HrConfigureResTypes


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CPostCfgManager::HrProcessResType
//
//  Description:
//      This function instantiates a resource type configuration component
//      and calls the appropriate methods.
//
//  Arguments:
//      rclsidResTypeCLSIDIn
//          CLSID of the resource type configuration component
//
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface on the resource type services
//          component. This interface provides methods that help configure
//          resource types.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the processing of the resource type.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrProcessResType(
        const CLSID &   rclsidResTypeCLSIDIn
      , IUnknown *      punkResTypeServicesIn
    )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    IClusCfgResourceTypeInfo *      pcrtiResTypeInfo = NULL;
    BSTR                            bstrResTypeName = NULL;
    GUID                            guidResTypeGUID;
    BSTR                            bstrNotification = NULL;

    TraceMsgGUID( mtfFUNC, "The CLSID of this resource type is ", rclsidResTypeCLSIDIn );

    //
    // Create the component represented by the CLSID passed in
    //
    hr = THR(
            CoCreateInstance(
                  rclsidResTypeCLSIDIn
                , NULL
                , CLSCTX_INPROC_SERVER
                , __uuidof( pcrtiResTypeInfo )
                , reinterpret_cast< void ** >( &pcrtiResTypeInfo )
                )
            );

    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrProcessResType_CoCreate_ResTypeClsid
            , hr
            , L"[PC-ResType] Error occurred trying to create the resource type configuration component."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrProcessResType_CoCreate_ResTypeClsid
            , IDS_TASKID_MINOR_ERROR_CREATE_RESOURCE_CONFIG
            , IDS_REF_MINOR_ERROR_CREATE_RESOURCE_CONFIG
            , hr
            );

        goto Cleanup;
    } // if: we could not create the resource type configuration component

    //
    // Initialize the newly created component
    //
    {
        IClusCfgInitialize * pcci = NULL;
        HRESULT hrTemp;

        // Check if this component supports the callback interface.
        hrTemp = THR( pcrtiResTypeInfo->QueryInterface< IClusCfgInitialize >( &pcci ) );

        if ( FAILED( hrTemp ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrProcessResType_QI_pcci,
                         hrTemp,
                         L"Error occurred trying to get a pointer to the IClusCfgInitialize interface. This resource type does not support initialization."
                         );
        } // if: the callback interface is not supported
        else
        {
            // Initialize this component.
            hr = THR( pcci->Initialize( static_cast< IClusCfgCallback * >( this ), m_lcid ) );

            // This interface is no longer needed.
            pcci->Release();

            // Did initialization succeed?
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrProcessResType_Initialize
                    , hr
                    , L"Error occurred trying initialize a resource type configuration component."
                    );

                STATUS_REPORT_REF_POSTCFG(
                      TASKID_Major_Configure_Resources
                    , TASKID_Minor_HrProcessResType_Initialize
                    , IDS_TASKID_MINOR_ERROR_INIT_RESOURCE_CONFIG
                    , IDS_REF_MINOR_ERROR_INIT_RESOURCE_CONFIG
                    , hr
                    );

                goto Cleanup;
            } // if: the initialization failed
        } // else: the callback interface is supported
    }


    // Get the name of the current resource type.
    hr = THR( pcrtiResTypeInfo->GetTypeName( &bstrResTypeName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrProcessResType_GetTypeName
            , hr
            , L"Error occurred trying to get the name of a resource type."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrProcessResType_GetTypeName
            , IDS_TASKID_MINOR_ERROR_GET_RESTYPE_NAME
            , IDS_REF_MINOR_ERROR_GET_RESTYPE_NAME
            , hr
            );

        goto Cleanup;
    } // if: we could not get the resource type name

    TraceMemoryAddBSTR( bstrResTypeName );

    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
              TASKID_Minor_HrProcessResType_AboutToConfigureType,
              hr,
              L"[PC-ResType] %1!ws!: About to configure resource type...",
              bstrNotification,
              bstrResTypeName
              );

    // Configure this resource type.
    hr = THR( pcrtiResTypeInfo->CommitChanges( m_pccci, punkResTypeServicesIn ) );

    if ( FAILED( hr ) )
    {
        SSR_LOG1(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrProcessResType_CommitChanges
            , hr
            , L"[PC-ResType] %1!ws!: Error occurred trying to configure the resource type."
            , bstrNotification
            , bstrResTypeName
            );

        STATUS_REPORT_REF_POSTCFG1(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrProcessResType_CommitChanges
            , IDS_TASKID_MINOR_ERROR_CONFIG_RESOURCE_TYPE
            , IDS_REF_MINOR_ERROR_CONFIG_RESOURCE_TYPE
            , hr
            , bstrResTypeName
            );

        goto Cleanup;
    } // if: this resource type configuration failed

    // Get and store the resource type GUID
    hr = STHR( pcrtiResTypeInfo->GetTypeGUID( &guidResTypeGUID ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG1(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrProcessResType_GetTypeGUID
            , hr
            , L"[PC-ResType] %1!ws!: Error occurred trying to get the resource type GUID."
            , bstrNotification
            , bstrResTypeName
            );

        STATUS_REPORT_REF_POSTCFG1(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrProcessResType_GetTypeGUID
            , IDS_TASKID_MINOR_ERROR_RESOURCE_TYPE_GUID
            , IDS_REF_MINOR_ERROR_RESOURCE_TYPE_GUID
            , hr
            , bstrResTypeName
            );

        goto Cleanup;
    } // if: this resource type configuration failed

    if ( hr == S_OK )
    {
        TraceMsgGUID( mtfFUNC, "The GUID of this resource type is", guidResTypeGUID );

        hr = THR( HrMapResTypeGUIDToName( guidResTypeGUID, bstrResTypeName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrProcessResType_HrMapResTypeGUIDToName
                , hr
                , L"Error occurred trying to create a mapping between a GUID and a name"
                );

            STATUS_REPORT_REF_POSTCFG1(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_HrProcessResType_HrMapResTypeGUIDToName
                , IDS_TASKID_MINOR_ERROR_MAPPING_GUID_AND_NAME
                , IDS_REF_MINOR_ERROR_MAPPING_GUID_AND_NAME
                , hr
                , bstrResTypeName
                );

            // Something went wrong with our code - we cannot continue.
            goto Cleanup;
        } // if: we could not add the mapping
    } // if: this resource type has a GUID
    else
    {
        // Reset hr
        hr = S_OK;

        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                     TASKID_Minor_HrProcessResType_NoGuid,
                     hr,
                     L"This resource type does not have a GUID associated with it."
                     );

    } // else: this resource type does not have a GUID

Cleanup:

    //
    // Cleanup code
    //

    if ( pcrtiResTypeInfo != NULL )
    {
        pcrtiResTypeInfo->Release();
    } // if: we had obtained a pointer to the resource type info interface

    TraceSysFreeString( bstrResTypeName );
    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} //*** CPostCfgManager::HrProcessResType

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CPostCfgManager::HrMapResTypeGUIDToName
//
//  Description:
//      Create a mapping between a resource type GUID and a resource type name.
//
//  Arguments:
//      rcguidTypeGuidIn
//          Resource type GUID which is to be mapped to a resource type name.
//
//      pcszTypeNameIn
//          The resource type name to map the above GUID to.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          If something went wrong
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrMapResTypeGUIDToName(
      const GUID & rcguidTypeGuidIn
    , const WCHAR * pcszTypeNameIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    ULONG   cchTypeNameSize;
    WCHAR * pszTypeName;

    //
    // Validate the parameters
    //

    // Validate the parameters
    if ( ( pcszTypeNameIn == NULL ) || ( *pcszTypeNameIn == L'\0' ) )
    {
        hr = THR( E_INVALIDARG );
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_HrMapResTypeGUIDToName_InvalidArg
            , hr
            , L"An empty resource type name can not be added to the map."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_HrMapResTypeGUIDToName_InvalidArg
            , IDS_TASKID_MINOR_ERROR_EMPTY_RESTYPE_NAME
            , IDS_REF_MINOR_ERROR_EMPTY_RESTYPE_NAME
            , hr
            );

        goto Cleanup;
    } // if: the resource type name is empty


    // Check if the existing map buffer is big enough to hold another entry.
    if ( m_idxNextMapEntry >= m_cMapSize )
    {
        // Double the size of the map buffer
        ULONG                       cNewMapSize = m_cMapSize * 2;
        ULONG                       idxMapEntry;
        SResTypeGUIDAndName *       pgnNewMap = new SResTypeGUIDAndName[ cNewMapSize ];

        if ( pgnNewMap == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_HrMapResTypeGUIDToName_OutOfMemory_NewMap
                , hr
                , L"Memory allocation failed trying to add a new resource type GUID to name map entry."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_HrMapResTypeGUIDToName_OutOfMemory_NewMap
                , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
                , IDS_REF_MINOR_ERROR_OUT_OF_MEMORY
                , hr
                );

            goto Cleanup;
        } // if: memory allocation failed

        // Copy the contents of the old buffer to the new one.
        for ( idxMapEntry = 0; idxMapEntry < m_idxNextMapEntry; ++idxMapEntry )
        {
            pgnNewMap[ idxMapEntry ] = m_pgnResTypeGUIDNameMap[ idxMapEntry ];
        } // for: iterate through the existing map

        // Update the member variables
        delete [] m_pgnResTypeGUIDNameMap;
        m_pgnResTypeGUIDNameMap = pgnNewMap;
        m_cMapSize = cNewMapSize;

    } // if: the map buffer is not big enough for another entry

    //
    // Add the new entry to the map
    //

    // Since resource type names are unlimited we won't use the strsafe functions here.
    cchTypeNameSize = (ULONG)(wcslen( pcszTypeNameIn ) + 1);
    pszTypeName = new WCHAR[ cchTypeNameSize ];
    if ( pszTypeName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_HrMapResTypeGUIDToName_OutOfMemory_TypeName
            , hr
            , L"Memory allocation failed trying to add a new resource type GUID to name map entry."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_HrMapResTypeGUIDToName_OutOfMemory_TypeName
            , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
            , IDS_REF_MINOR_ERROR_OUT_OF_MEMORY
            , hr
            );

        goto Cleanup;
    } // if: memory allocation failed

    // This call can't fail - the dest buffer is the same size as the src buffer, including the NULL.
    StringCchCopyNW( pszTypeName, cchTypeNameSize, pcszTypeNameIn, cchTypeNameSize );

    m_pgnResTypeGUIDNameMap[ m_idxNextMapEntry ].m_guidTypeGUID = rcguidTypeGuidIn;
    m_pgnResTypeGUIDNameMap[ m_idxNextMapEntry ].m_pszTypeName = pszTypeName;
    ++m_idxNextMapEntry;

Cleanup:

    HRETURN( hr );

} //*** CPostCfgManager::HrMapResTypeGUIDToName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPostCfgManager::PcszLookupTypeNameByGUID
//
//  Description:
//      Given a resource type GUID this function finds the resource type name
//      if any.
//
//  Arguments:
//      rcguidTypeGuidIn
//          Resource type GUID which is to be mapped to a resource type name.
//
//  Return Values:
//      Pointer to the name of the resource type
//          If the type GUID maps to name
//
//      NULL
//          If there is no type name associated with the input GUID
//
//--
//////////////////////////////////////////////////////////////////////////////
const WCHAR *
CPostCfgManager::PcszLookupTypeNameByGUID(
      const GUID & rcguidTypeGuidIn
    )
{
    TraceFunc( "" );

    ULONG           idxCurrentMapEntry;
    const WCHAR *   pcszTypeName = NULL;

    TraceMsgGUID( mtfFUNC, "Trying to look up the the type name of resource type ", rcguidTypeGuidIn );

    for ( idxCurrentMapEntry = 0; idxCurrentMapEntry < m_idxNextMapEntry; ++idxCurrentMapEntry )
    {
        if ( IsEqualGUID( rcguidTypeGuidIn, m_pgnResTypeGUIDNameMap[ idxCurrentMapEntry ].m_guidTypeGUID ) != FALSE )
        {
            // A mapping has been found.
            pcszTypeName = m_pgnResTypeGUIDNameMap[ idxCurrentMapEntry ].m_pszTypeName;
            TraceMsg( mtfFUNC, "The name of the type is '%s'", pcszTypeName );
            break;
        } // if: this GUID has been found in the map
    } // for: iterate through the existing entries in the map

    if ( pcszTypeName == NULL )
    {
        TraceMsg( mtfFUNC, "The input GUID does not map to any resource type name." );
    } // if: this GUID does not exist in the map

    RETURN( pcszTypeName );

} //*** CPostCfgManager::PcszLookupTypeNameByGUID

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrPreInitializeExistingResources
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrPreInitializeExistingResources( void )
{
    TraceFunc( "" );

    HRESULT     hr;

    CResourceEntry *   presentry;

    BSTR        bstrNotification = NULL;
    BSTR        bstrClusterNameResourceName = NULL;
    BSTR        bstrClusterIPAddressResourceName = NULL;
    BSTR        bstrClusterQuorumResourceName = NULL;
    HRESOURCE   hClusterNameResource = NULL;
    HRESOURCE   hClusterIPAddressResource = NULL;
    HRESOURCE   hClusterQuorumResource = NULL;

    Assert( m_rgpResources == NULL );
    Assert( m_cAllocedResources == 0 );
    Assert( m_cResources == 0 );

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_LOCATE_EXISTING_QUORUM_DEVICE, &bstrNotification ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_LoadString_LocateExistingQuorum
            , hr
            , L"Failed the load string for locating existing quorum resource."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_LoadString_LocateExistingQuorum
            , IDS_TASKID_MINOR_ERROR_LOADSTR_QUORUM_RES
            , IDS_REF_MINOR_ERROR_LOADSTR_QUORUM_RES
            , hr
            );

        goto Cleanup;
    }

    m_rgpResources = (CResourceEntry **) TraceAlloc( 0, sizeof(CResourceEntry *) * RESOURCE_INCREMENT );
    if ( m_rgpResources == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_OutOfMemory
            , hr
            , L"Out of memory"
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_OutOfMemory
            , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
            , IDS_REF_MINOR_ERROR_OUT_OF_MEMORY
            , hr
            );

    } // if:

    for ( ; m_cAllocedResources < RESOURCE_INCREMENT; m_cAllocedResources ++ )
    {
        hr = THR( CResourceEntry::S_HrCreateInstance( &m_rgpResources[ m_cAllocedResources ], m_pcccb, m_lcid ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrPreInitializeExistingResources_CResourceEntry
                , hr
                , L"[PC-Create] Failed to create resource entry object. Aborting."
                );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_CREATE_RESENTRY
                , IDS_REF_MINOR_ERROR_CREATE_RESENTRY
                , hr
                );

            goto Cleanup;
        }
    } // for:

    Assert( m_cAllocedResources == RESOURCE_INCREMENT );

    //
    //  Create default resources such as Cluster IP, Cluster Name resource, and Quorum Device
    //

    Assert( m_cResources == 0 );

    //
    //  Get the core resources and their names.
    //
    hr = THR( HrGetCoreClusterResourceNames(
              &bstrClusterNameResourceName
            , &hClusterNameResource
            , &bstrClusterIPAddressResourceName
            , &hClusterIPAddressResource
            , &bstrClusterQuorumResourceName
            , &hClusterQuorumResource
            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
    //
    //  Add Cluster IP Address resource
    //

    m_idxIPAddress = m_cResources;

    presentry = m_rgpResources[ m_cResources ];

    //  This give ownership of bstrClusterIPAddressResourceName away
    hr = THR( presentry->SetName( bstrClusterIPAddressResourceName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetName
            , hr
            , L"Failed to set 'cluster ip' resource name."
            );

        STATUS_REPORT_REF_POSTCFG1(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetName
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_NAME
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_NAME
            , hr
            , bstrClusterIPAddressResourceName
            );

        goto Cleanup;
    }

    bstrClusterIPAddressResourceName = NULL;

    hr = THR( presentry->SetType( &RESTYPE_ClusterIPAddress ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetType
            , hr
            , L"Failed to set 'cluster ip' resource type."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetType
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_TYPE
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_TYPE
            , hr
            );

        goto Cleanup;
    }

    hr = THR( presentry->SetClassType( &RESCLASSTYPE_IPAddress ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetClassType
            , hr
            , L"Failed to set 'cluster ip' resource class type."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetClassType
            , IDS_TASKID_MINOR_ERROR_SET_RESCLASS_TYPE
            , IDS_REF_MINOR_ERROR_SET_RESCLASS_TYPE
            , hr
            );

        goto Cleanup;
    }

    hr = THR( presentry->SetFlags( dfSHARED ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetFlags
            , hr
            , L"Failed to set 'cluster ip' resource flags."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetFlags
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_FLAGS
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_FLAGS
            , hr
            );

        goto Cleanup;
    }

    hr = THR( presentry->SetHResource( hClusterIPAddressResource ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetHResource
            , hr
            , L"Failed to set 'cluster ip' resource handle."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetHResource
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_HANDLE
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_HANDLE
            , hr
            );

        goto Cleanup;
    }

    hClusterIPAddressResource = NULL;

    m_cResources ++;

    //
    //  Add Cluster Name resource
    //

    m_idxClusterName = m_cResources;

    presentry = m_rgpResources[ m_cResources ];

    //  This give ownership of bstrClusterNameResourceName away
    hr = THR( presentry->SetName( bstrClusterNameResourceName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetName
            , hr
            , L"Failed to set 'cluster name' resource name."
            );

        STATUS_REPORT_REF_POSTCFG1(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetName
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_NAME
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_NAME
            , hr
            , bstrClusterNameResourceName
            );

        goto Cleanup;
    }

    bstrClusterNameResourceName = NULL;

    hr = THR( presentry->SetType( &RESTYPE_ClusterNetName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetType
            , hr
            , L"Failed to set 'cluster name' resource type."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetType
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_TYPE
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_TYPE
            , hr
            );

        goto Cleanup;
    }

    hr = THR( presentry->SetClassType( &RESCLASSTYPE_NetworkName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetClassType
            , hr
            , L"Failed to set 'cluster name' resource class type."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetClassType
            , IDS_TASKID_MINOR_ERROR_SET_RESCLASS_TYPE
            , IDS_REF_MINOR_ERROR_SET_RESCLASS_TYPE
            , hr
            );

        goto Cleanup;
    }

    hr = THR( presentry->SetFlags( dfSHARED ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetFlags
            , hr
            , L"Failed to set 'cluster name' resource flags."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetFlags
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_FLAGS
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_FLAGS
            , hr
            );

        goto Cleanup;
    }

    //  Add the dependency on the IP address.
    hr = THR( presentry->AddTypeDependency( &RESTYPE_ClusterIPAddress, dfSHARED ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_AddTypeDependency
            , hr
            , L"Failed to add type dependency for 'cluster name' resource."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_Name_AddTypeDependency
            , IDS_TASKID_MINOR_ERROR_TYPE_DEPENDENCY
            , IDS_REF_MINOR_ERROR_TYPE_DEPENDENCY
            , hr
            );

        goto Cleanup;
    }

    hr = THR( presentry->SetHResource( hClusterNameResource ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetHResource
            , hr
            , L"Failed to set 'cluster name' resource handle."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetHResource
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_HANDLE
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_HANDLE
            , hr
            );

        goto Cleanup;
    }

    hClusterNameResource = NULL;

    m_cResources ++;

    //
    //  Add Quorum resource
    //

    //
    //  KB:     gpease  19-JUN-2000
    //          Anything before the quorum device will be considered to be
    //          in the Cluster Group.
    //

    m_idxQuorumResource = m_cResources;

    presentry = m_rgpResources[ m_cResources ];

    //  This give ownership of bstrClusterQuorumResourceName away
    hr = THR( presentry->SetName( bstrClusterQuorumResourceName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetName
            , hr
            , L"Failed to set quorum resource name."
            );

        STATUS_REPORT_REF_POSTCFG1(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetName
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_NAME
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_NAME
            , hr
            , bstrClusterQuorumResourceName
            );

        goto Cleanup;
    }

    bstrClusterQuorumResourceName = NULL;
/*
    hr = THR( presentry->SetType( &RESTYPE_ClusterQuorumDisk ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetType
            , hr
            , L"Failed to set quorum resource type."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetType
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_TYPE
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_TYPE
            , hr
            );

        goto Cleanup;
    }
*/
    hr = THR( presentry->SetClassType( &RESCLASSTYPE_StorageDevice ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetClassType
            , hr
            , L"Failed to set quorum resource class type."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetClassType
            , IDS_TASKID_MINOR_ERROR_SET_RESCLASS_TYPE
            , IDS_REF_MINOR_ERROR_SET_RESCLASS_TYPE
            , hr
            );

        goto Cleanup;
    }

    hr = THR( presentry->SetFlags( dfSHARED ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetFlags
            , hr
            , L"Failed to set quorum resource flags."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetFlags
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_FLAGS
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_FLAGS
            , hr
            );

        goto Cleanup;
    }

    hr = THR( presentry->SetHResource( hClusterQuorumResource ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetHResource
            , hr
            , L"Failed to set quorum resource handle."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetHResource
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_HANDLE
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_HANDLE
            , hr
            );

        goto Cleanup;
    }

    hClusterQuorumResource = NULL;

    m_cResources ++;

    //
    //  Make sure that the default resource allocation can hold all the
    //  default resources.
    //

    AssertMsg( m_cResources <= m_cAllocedResources, "Default resource allocation needs to be bigger!" );

    goto Cleanup;

Cleanup:

    //
    //  Send a status that we found the quorum device.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Locate_Existing_Quorum_Device,
                                10,
                                10,
                                10,
                                hr,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
        //  ignore failure

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrClusterNameResourceName );
    TraceSysFreeString( bstrClusterIPAddressResourceName );
    TraceSysFreeString( bstrClusterQuorumResourceName );

    if ( hClusterNameResource != NULL )
    {
        CloseClusterResource( hClusterNameResource );
    } // if:

    if ( hClusterIPAddressResource != NULL )
    {
        CloseClusterResource( hClusterIPAddressResource );
    } // if:

    if ( hClusterQuorumResource != NULL )
    {
        CloseClusterResource( hClusterQuorumResource );
    } // if:

    HRETURN( hr );

} //*** CPostCfgManager::HrPreInitializeExistingResources


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrAddSpecialResource(
//      BSTR            bstrNameIn,
//      const CLSID *   pclsidTypeIn,
//      const CLSID *   pclsidClassTypeIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrAddSpecialResource(
    BSTR            bstrNameIn,
    const CLSID *   pclsidTypeIn,
    const CLSID *   pclsidClassTypeIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    CResourceEntry * presentry;

    //
    //  Grow the resource list if nessecary.
    //

    if ( m_cResources == m_cAllocedResources )
    {
        ULONG   idxNewCount = m_cAllocedResources + RESOURCE_INCREMENT;
        CResourceEntry ** pnewList;

        pnewList = (CResourceEntry **) TraceAlloc( 0, sizeof( CResourceEntry * ) * idxNewCount );
        if ( pnewList == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrAddSpecialResource_OutOfMemory
                , hr
                , L"Out of memory"
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_HrAddSpecialResource_OutOfMemory
                , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
                , IDS_REF_MINOR_ERROR_OUT_OF_MEMORY
                , hr
                );

            goto Cleanup;
        }

        CopyMemory( pnewList, m_rgpResources, sizeof(CResourceEntry *) * m_cAllocedResources );
        TraceFree( m_rgpResources );
        m_rgpResources = pnewList;

        for ( ; m_cAllocedResources < idxNewCount ; m_cAllocedResources ++ )
        {
            hr = THR( CResourceEntry::S_HrCreateInstance( &m_rgpResources[ m_cAllocedResources ], m_pcccb, m_lcid ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrAddSpecialResource_CResourceEntry
                    , hr
                    , L"[PC-Create] Failed to create resource entry object. Aborting."
                    );

                STATUS_REPORT_MINOR_REF_POSTCFG(
                      TASKID_Major_Configure_Resources
                    , IDS_TASKID_MINOR_ERROR_CREATE_RESENTRY
                    , IDS_REF_MINOR_ERROR_CREATE_RESENTRY
                    , hr
                    );

                goto Cleanup;
            }
        }
    }

    presentry = m_rgpResources[ m_cResources ];

    //
    //  Setup the new entry.
    //

    hr = THR( presentry->SetName( bstrNameIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrAddSpecialResource_SetName
            , hr
            , L"Failed to set special resource name."
            );

        STATUS_REPORT_REF_POSTCFG1(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrAddSpecialResource_SetName
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_NAME
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_NAME
            , hr
            , bstrNameIn
            );

        goto Cleanup;
    }

    hr = THR( presentry->SetType( pclsidTypeIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrAddSpecialResource_SetType
            , hr
            , L"Failed to set special resource type."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrAddSpecialResource_SetType
            , IDS_TASKID_MINOR_ERROR_SET_RESOURCE_TYPE
            , IDS_REF_MINOR_ERROR_SET_RESOURCE_TYPE
            , hr
            );

        goto Cleanup;
    }

    hr = THR( presentry->SetClassType( pclsidClassTypeIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrAddSpecialResource_SetClassType
            , hr
            , L"Failed to set special resource class type."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrAddSpecialResource_SetClassType
            , IDS_TASKID_MINOR_ERROR_SET_RESCLASS_TYPE
            , IDS_REF_MINOR_ERROR_SET_RESCLASS_TYPE
            , hr
            );

        goto Cleanup;
    }

    m_cResources ++;

Cleanup:

    HRETURN( hr );

} //*** CPostCfgManager::HrAddSpecialResource


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrCreateResourceInstance(
//      ULONG       idxResourceIn,
//      HGROUP      hGroupIn,
//      LPCWSTR     pszResTypeIn,
//      HRESOURCE * phResourceOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrCreateResourceInstance(
    ULONG       idxResourceIn,
    HGROUP      hGroupIn,
    LPCWSTR     pszResTypeIn,
    HRESOURCE * phResourceOut
    )
{
    TraceFunc3( "idxResourceIn = %u, hGroupIn = %p, pszResTypeIn = '%ws'",
                idxResourceIn, hGroupIn, pszResTypeIn );

    HRESULT     hr;
    DWORD       dw;
    BSTR        bstrName;   // don't free

    CResourceEntry * presentry;

    BSTR        bstrNotification = NULL;

    Assert( phResourceOut != NULL );
    Assert( idxResourceIn < m_cResources );
    Assert( hGroupIn != NULL );

    presentry = m_rgpResources[ idxResourceIn ];

    hr = THR( presentry->GetName( &bstrName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceInstance_GetName
            , hr
            , L"Failed to get resource instance name."
            );

        STATUS_REPORT_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrCreateResourceInstance_GetName
            , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_NAME
            , IDS_REF_MINOR_ERROR_GET_RESOURCE_NAME
            , hr
            );

        goto Cleanup;
    }

    //
    //  Tell the UI what we are doing.
    //

    hr = THR( SendStatusReport(
                    NULL
                  , TASKID_Major_Configure_Resources
                  , TASKID_Minor_Creating_Resource
                  , 0
                  , m_cResources
                  , idxResourceIn
                  , S_OK
                  , NULL
                  , NULL
                  , NULL
                  ) );

    if ( hr == E_ABORT )
    {
        goto Cleanup;
    }

    //
    //  See if the resource already exists. We need to do this because the user
    //  might have clicked "Retry" in the UI. We don't want to create another
    //  instance of existing resources.
    //

    *phResourceOut = OpenClusterResource( m_hCluster, bstrName );
    if ( *phResourceOut == NULL )
    {
        //
        //  Create a new resource instance.
        //

        *phResourceOut = CreateClusterResource( hGroupIn, bstrName, pszResTypeIn, 0 );
        if ( *phResourceOut == NULL )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );

            SSR_LOG1(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceInstance_CreateClusterResource
                , hr
                , L"[PC-Create] %1!ws!: CreateClusterResource failed. Its dependents may not be created. Skipping."
                , bstrNotification
                , bstrName
                );

            STATUS_REPORT_REF_POSTCFG1(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_HrCreateResourceInstance_CreateClusterResource
                , IDS_TASKID_MINOR_ERROR_CREATE_RESOURCE
                , IDS_REF_MINOR_ERROR_CREATE_RESOURCE
                , hr
                , bstrName
                );

            goto Cleanup;

        } // if: failure

        SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                  TASKID_Minor_HrCreateResourceInstance_CreateClusterResource_Successful,
                  hr,
                  L"[PC-Create] %1!ws!: Resource created successfully.",
                  bstrNotification,
                  bstrName
                  );
    }
    else
    {
        SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                  TASKID_Minor_HrCreateResourceInstance_FoundExistingResource,
                  hr,
                  L"[PC-Create] %1!ws!: Found existing resource.",
                  bstrNotification,
                  bstrName
                  );

        //
        //  Make sure the resource is in the group we think it is.
        //
        //  don't wrap - this can fail with ERROR_ALREADY_EXISTS.
        dw = ChangeClusterResourceGroup( *phResourceOut, hGroupIn );
        if ( dw == ERROR_ALREADY_EXISTS )
        {
            //  no-op. It's the way we want it.
        }
        else if ( dw != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dw );

            SSR_LOG1(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceInstance_ChangeClusterResourceGroup
                , hr
                , L"[PC-Create] %1!ws!: Can't move existing resource to proper group. Configuration may not work."
                , bstrNotification
                , bstrName
                );

            STATUS_REPORT_REF_POSTCFG1(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_HrCreateResourceInstance_ChangeClusterResourceGroup
                , IDS_TASKID_MINOR_ERROR_MOVE_RESOURCE
                , IDS_REF_MINOR_ERROR_MOVE_RESOURCE
                , hr
                , bstrName
                );
        }
    }

    //
    //  Store off the resource handle.
    //

    hr = THR( presentry->SetHResource( *phResourceOut ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceInstance_SetHResource
            , hr
            , L"Failed to get resource instance handle."
            );

        STATUS_REPORT_REF_POSTCFG1(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_HrCreateResourceInstance_SetHResource
            , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_HANDLE
            , IDS_REF_MINOR_ERROR_GET_RESOURCE_HANDLE
            , hr
            , bstrName
            );

        goto Cleanup;
    }

    //
    //  Configure resource.
    //

    hr = THR( presentry->Configure() );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceInstance_Configure
            , hr
            , L"Failed to configure resource instance."
            );
        //  ignore the error and continue.
    }

    //
    //  Make a message using the name.
    //

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                       IDS_TASKID_MINOR_CREATING_RESOURCE,
                                       &bstrNotification,
                                       bstrName
                                       ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceInstance_LoadString_CreatingResource
            , hr
            , L"Failed to format message for creating resource."
            );
        goto Cleanup;
    }

    //
    //  Tell the UI what we are doing.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Client_And_Server_Log,   // informative only
                                TASKID_Minor_Creating_Resource,
                                0,
                                2,
                                2,
                                hr, // log the error on the client side
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
    {
        goto Cleanup;
    }
        //  ignore failure

    //
    //  TODO:   gpease  24-AUG-2000
    //          What to do if we have a failure?? For now I think we should keep going!
    //

    hr = S_OK;

Cleanup:

    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} //*** CPostCfgManager::HrCreateResourceInstance


//////////////////////////////////////////////////////////////////////////////
//
//  CPostCfgManager::S_ScDeleteLocalQuorumResource
//
//////////////////////////////////////////////////////////////////////////////
DWORD
CPostCfgManager::S_ScDeleteLocalQuorumResource(
      HCLUSTER      hClusterIn
    , HRESOURCE     hSelfIn
    , HRESOURCE     hLQuorumIn
    , PVOID         pvParamIn
    )
{
    TraceFunc( "" );

    DWORD                   sc = ERROR_SUCCESS;
    signed long             slOfflineTimeOut = 60; // seconds
    CLUSTER_RESOURCE_STATE  crs;
    HCHANGE                 hc = reinterpret_cast< HCHANGE >( INVALID_HANDLE_VALUE );
    CPostCfgManager *       pcpcmThis = reinterpret_cast< CPostCfgManager * >( pvParamIn );
    DWORD                   dwStatusCurrent = 0;
    HRESULT                 hr;

    //
    // Check if the this pointer is valid.
    //
    if ( pvParamIn == NULL )
    {
        // If the pointer is invalid, set it to a valid address and continue.
        hr = HRESULT_FROM_WIN32( TW32( ERROR_INVALID_PARAMETER ) );
        LogMsg( "[PC] Error: An invalid parameter was received while trying to delete the Local Quorum resource." );

        STATUS_REPORT_PTR_POSTCFG(
              pcpcmThis
            , TASKID_Major_Configure_Resources
            , TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_InvalidParam
            , IDS_TASKID_MINOR_ERROR_INVALID_PARAM
            , hr
            );

        goto Cleanup;
    }

    // Get the state of the resource.
    crs = GetClusterResourceState( hLQuorumIn, NULL, NULL, NULL, NULL );

    // Check if it is offline - if it is, then we can proceed to deleting it.
    if ( crs == ClusterResourceOffline )
    {
        TraceFlow( "The Local Quorum resource is already offline." );
        goto Cleanup;
    }

    TraceFlow( "Trying to take the Local Quorum resource offline." );

    // If we are here, the resource is not yet offline. Instruct it to go offline.
    sc = OfflineClusterResource( hLQuorumIn );
    if ( ( sc != ERROR_SUCCESS ) && ( sc != ERROR_IO_PENDING ) )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        LogMsg( "[PC] Error %#08x occurred trying to take the Local Quorum resource offline.", sc );

        STATUS_REPORT_PTR_POSTCFG(
              pcpcmThis
            , TASKID_Major_Configure_Resources
            , TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_OfflineQuorum
            , IDS_TASKID_MINOR_ERROR_OFFLINE_QUORUM
            , hr
            );

        goto Cleanup;
    } // if: an error occurred trying to take the resource offline

    if ( sc == ERROR_IO_PENDING )
    {
        TraceFlow1( "Waiting %d seconds for the Local Quorum resource to go offline.", slOfflineTimeOut );

        // Create a notification port for resource state changes
        hc = CreateClusterNotifyPort(
              reinterpret_cast< HCHANGE >( INVALID_HANDLE_VALUE )
            , hClusterIn
            , CLUSTER_CHANGE_RESOURCE_STATE
            , NULL
            );

        if ( hc == NULL )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( "[PC] Error %#08x occurred trying to create a cluster notification port.", hr );

            STATUS_REPORT_PTR_POSTCFG(
                  pcpcmThis
                , TASKID_Major_Configure_Resources
                , TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_NotifPort
                , IDS_TASKID_MINOR_ERROR_NOTIFICATION_PORT
                , hr
                );

            goto Cleanup;
        } // if: we could not create a notification port

        sc = TW32( RegisterClusterNotify( hc, CLUSTER_CHANGE_RESOURCE_STATE, hLQuorumIn, NULL ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( "[PC] Error %#08x occurred trying to register for cluster notifications.", hr );

            STATUS_REPORT_PTR_POSTCFG(
                  pcpcmThis
                , TASKID_Major_Configure_Resources
                , TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_RegNotification
                , IDS_TASKID_MINOR_ERROR_REGISTER_NOTIFICATION
                , hr
                );

            goto Cleanup;
        } // if:

        // Change the status report range.
        dwStatusCurrent = 0;

        // Wait for slOfflineTimeOut seconds for the resource to go offline.
        for ( ; slOfflineTimeOut > 0; --slOfflineTimeOut )
        {
            DWORD   dwFilterType;

            crs = GetClusterResourceState( hLQuorumIn, NULL, NULL, NULL, NULL );
            if ( crs == ClusterResourceOffline )
            {
                TraceFlow1( "The local quorum resource has gone offline with %d seconds to spare.", slOfflineTimeOut );
                break;
            } // if: the resource is now offline

            sc = GetClusterNotify( hc, NULL, &dwFilterType, NULL, NULL, 1000 ); // wait for one second
            if ( ( sc != ERROR_SUCCESS ) && ( sc != WAIT_TIMEOUT ) )
            {

                hr = HRESULT_FROM_WIN32( TW32( sc ) );
                LogMsg( "[PC] Error %#08x occurred trying wait for a resource state change notification.", hr );

                STATUS_REPORT_PTR_POSTCFG(
                      pcpcmThis
                    , TASKID_Major_Configure_Resources
                    , TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_TimeOut
                    , IDS_TASKID_MINOR_ERROR_STATE_CHANGE_TIMEOUT
                    , hr
                    );

                goto Cleanup;
            } // if: something went wrong

           // Reset sc, since it could be WAIT_TIMEOUT here
           sc = ERROR_SUCCESS;

           Assert( dwFilterType == CLUSTER_CHANGE_RESOURCE_STATE );

            //  Send a status report that we are deleting the quorum device.
            ++dwStatusCurrent;
            THR(
                pcpcmThis->SendStatusReport(
                      NULL
                    , TASKID_Major_Configure_Resources
                    , TASKID_Minor_Delete_LocalQuorum
                    , 0
                    , pcpcmThis->m_dwLocalQuorumStatusMax
                    , dwStatusCurrent
                    , HRESULT_FROM_WIN32( sc )
                    , NULL    // don't update text
                    , NULL
                    , NULL
                    )
                );
        } // for: loop while the timeout has not expired
    } // if:
    else
    {
        crs = ClusterResourceOffline;   // the resource went offline immediately.
    } // else:

    //
    // If we are here, then one of two things could have happened:
    // 1. The resource has gone offline
    // 2. The timeout has expired
    // Check to see which of the above is true.
    //

    if ( crs != ClusterResourceOffline )
    {
        // We cannot be here if the timeout has not expired.
        Assert( slOfflineTimeOut <= 0 );

        LogMsg( "[PC] Error: The Local Quorum resource could not be taken offline." );
        sc = TW32( WAIT_TIMEOUT );
        hr = HRESULT_FROM_WIN32( sc );

        STATUS_REPORT_PTR_POSTCFG(
              pcpcmThis
            , TASKID_Major_Configure_Resources
            , TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_OfflineQuorum2
            , IDS_TASKID_MINOR_ERROR_OFFLINE_QUORUM
            , hr
            );

        goto Cleanup;
    } // if: the timeout has expired

    // If we are here, the resource is offline.
    TraceFlow( "The Local Quorum resource is offline." );

    if ( pcpcmThis != NULL )
    {
        //  Send a status report that we are deleting the quorum device.
        ++dwStatusCurrent;
        THR(
            pcpcmThis->SendStatusReport(
                  NULL
                , TASKID_Major_Configure_Resources
                , TASKID_Minor_Delete_LocalQuorum
                , 0
                , pcpcmThis->m_dwLocalQuorumStatusMax
                , dwStatusCurrent
                , HRESULT_FROM_WIN32( sc )
                , NULL    // don't update text
                , NULL
                , NULL
                )
            );
    } // if: the this pointer is valid

    // If we are here, the resource is offline - now delete it.
    sc = TW32( DeleteClusterResource( hLQuorumIn ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( "[PC] Error %#08x occurred trying to delete the Local Quorum resource.", hr );

        STATUS_REPORT_PTR_POSTCFG(
              pcpcmThis
            , TASKID_Major_Configure_Resources
            , TASKID_Minor_CPostCfgManager_S_ScDeleteLocalQuorumResource_DeleteQuorum
            , IDS_TASKID_MINOR_ERROR_DELETE_QUORUM
            , hr
            );

    } // if: we could not delete the resource
    else
    {
        LogMsg( "[PC] The Local Quorum resource has been deleted." );
    } // else: the resource has been deleted

    //  Send a status report that we are deleting the quorum device.
    ++dwStatusCurrent;
    THR(
        pcpcmThis->SendStatusReport(
              NULL
            , TASKID_Major_Configure_Resources
            , TASKID_Minor_Delete_LocalQuorum
            , 0
            , pcpcmThis->m_dwLocalQuorumStatusMax
            , dwStatusCurrent
            , HRESULT_FROM_WIN32( sc )
            , NULL    // don't update text
            , NULL
            , NULL
            )
        );

Cleanup:

    //
    // Cleanup
    //
    if ( hc != INVALID_HANDLE_VALUE )
    {
        CloseClusterNotifyPort( hc );
    } // if: we had created a cluster notification port

    W32RETURN( sc );

} //*** CPostCfgManager::S_ScDeleteLocalQuorumResource

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrGetCoreClusterResourceNames(
//        BSTR *    pbstrClusterNameResourceOut
//      , BSTR *    pbstrClusterIPAddressNameOut
//      , BSTR *    pbstrClusterQuorumResourceNameOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrGetCoreClusterResourceNames(
      BSTR *        pbstrClusterNameResourceNameOut
    , HRESOURCE *   phClusterNameResourceOut
    , BSTR *        pbstrClusterIPAddressNameOut
    , HRESOURCE *   phClusterIPAddressResourceOut
    , BSTR *        pbstrClusterQuorumResourceNameOut
    , HRESOURCE *   phClusterQuorumResourceOut
    )
{
    TraceFunc( "" );
    Assert( m_hCluster != NULL );
    Assert( pbstrClusterNameResourceNameOut != NULL );
    Assert( phClusterNameResourceOut != NULL );
    Assert( pbstrClusterIPAddressNameOut != NULL );
    Assert( phClusterIPAddressResourceOut != NULL );
    Assert( pbstrClusterQuorumResourceNameOut != NULL );
    Assert( phClusterQuorumResourceOut != NULL );

    HRESULT     hr = S_OK;
    WCHAR *     pszName = NULL;
    DWORD       cchName = 33;
    DWORD       cch;
    HRESOURCE   hClusterIPAddressResource = NULL;
    HRESOURCE   hClusterNameResource = NULL;
    HRESOURCE   hClusterQuorumResource = NULL;
    DWORD       sc;
    BSTR *      pbstr = NULL;
    HRESOURCE   hResource = NULL;
    int         idx;

    sc = TW32( ResUtilGetCoreClusterResources( m_hCluster, &hClusterNameResource, &hClusterIPAddressResource, &hClusterQuorumResource ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[PC] Error getting core resources. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    Assert( hClusterNameResource != NULL );
    Assert( hClusterIPAddressResource != NULL );
    Assert( hClusterQuorumResource != NULL );

    pszName = new WCHAR[ cchName ];
    if ( pszName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( idx = 0; idx < 3; )
    {
        switch ( idx )
        {
            case 0:
            {
                hResource = hClusterNameResource;
                pbstr = pbstrClusterNameResourceNameOut;
                break;
            } // case:

            case 1:
            {
                hResource = hClusterIPAddressResource;
                pbstr = pbstrClusterIPAddressNameOut;
                break;
            } // case:

            case 2:
            {
                hResource = hClusterQuorumResource;
                pbstr = pbstrClusterQuorumResourceNameOut;
                break;
            } // case:
        } // switch:

        //
        //  Reset cch to be the allocated value...
        //

        cch = cchName;

        sc = ResUtilGetResourceName( hResource, pszName, &cch );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszName;
            pszName = NULL;

            cch++;
            cchName = cch;

            pszName = new WCHAR[ cchName ];
            if ( pszName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            sc = ResUtilGetResourceName( hResource, pszName, &cch );
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            *pbstr = TraceSysAllocString( pszName );
            if ( *pbstr == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            pbstr = NULL;
            hr = S_OK;
            idx++;
            continue;
        } // if: ERROR_SUCCESS
        else
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrGetCoreClusterResourceNames_GetResourceName
                , hr
                , L"Failed to get a resource name."
                );

            STATUS_REPORT_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_HrGetCoreClusterResourceNames_GetResourceName
                , IDS_TASKID_MINOR_ERROR_GET_RESOURCE_NAME
                , IDS_REF_MINOR_ERROR_GET_RESOURCE_NAME
                , hr
                );

            switch ( idx )
            {
                case 0:
                {
                    LogMsg( L"[PC] Error getting the name of the cluster name resource. (hr = %#08x)", hr );
                    break;
                } // case:

                case 1:
                {
                    LogMsg( L"[PC] Error getting the name of the cluster IP address resource. (hr = %#08x)", hr );
                    break;
                } // case:

                case 2:
                {
                    LogMsg( L"[PC] Error getting the name of the cluster quorum resource. (hr = %#08x)", hr );
                    break;
                } // case:
            } // switch:

            goto Cleanup;
        } // else: sc != ERROR_SUCCESS
    } // for:

    Assert( sc == ERROR_SUCCESS )

    //
    //  Give ownership to the caller
    //

    *phClusterNameResourceOut = hClusterNameResource;
    hClusterNameResource = NULL;

    *phClusterIPAddressResourceOut = hClusterIPAddressResource;
    hClusterIPAddressResource = NULL;

    *phClusterQuorumResourceOut = hClusterQuorumResource;
    hClusterQuorumResource = NULL;

Cleanup:

    if ( hClusterNameResource != NULL )
    {
        CloseClusterResource( hClusterNameResource );
    } // if:

    if ( hClusterIPAddressResource != NULL )
    {
        CloseClusterResource( hClusterIPAddressResource );
    } // if:

    if ( hClusterQuorumResource != NULL )
    {
        CloseClusterResource( hClusterQuorumResource );
    } // if:

    if ( pbstr != NULL )
    {
        TraceSysFreeString( *pbstr );
    } // if:

    delete [] pszName;

    HRETURN( hr );

} //*** CPostCfgManager::HrGetCoreClusterResourceNames

/*
//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrIsLocalQuorum( BSTR  bstrNameIn )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrIsLocalQuorum( BSTR  bstrNameIn )
{
    TraceFunc( "" );
    Assert( bstrNameIn != NULL );

    HRESULT hr = S_FALSE;
    BSTR    bstrLocalQuorum = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_LOCAL_QUORUM_DISPLAY_NAME, &bstrLocalQuorum ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( ClRtlStrICmp( bstrNameIn, bstrLocalQuorum ) == 0 )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    } // else:

Cleanup:

    TraceSysFreeString( bstrLocalQuorum );

    HRETURN( hr );

} //*** CPostCfgManager::HrIsLocalQuorum
*/

#if defined(DEBUG)
//////////////////////////////////////////////////////////////////////////////
//
//  void
//  CPostCfgManager::DebugDumpDepencyTree( void )
//
//////////////////////////////////////////////////////////////////////////////
void
CPostCfgManager::DebugDumpDepencyTree( void )
{
    TraceFunc( "" );

    ULONG   idxResource;
    ULONG   cDependents;
    ULONG   idxDependent;
    BSTR    bstrName;   // don't free

    CResourceEntry * presentry;
    EDependencyFlags dfDependent;

    for ( idxResource = 0; idxResource < m_cResources ; idxResource ++ )
    {
        presentry = m_rgpResources[ idxResource ];

        THR( presentry->GetName( &bstrName ) );

        DebugMsgNoNewline( "%ws(#%u) -> ", bstrName, idxResource );

        THR( presentry->GetCountOfDependents( &cDependents ) );

        for ( ; cDependents != 0 ; )
        {
            cDependents --;

            THR( presentry->GetDependent( cDependents, &idxDependent, &dfDependent ) );

            THR( m_rgpResources[ idxDependent ]->GetName( &bstrName ) );

            DebugMsgNoNewline( "%ws(#%u) ", bstrName, idxDependent );

        } // for: cDependents

        DebugMsg( L"" );

    } // for: idxResource

    TraceFuncExit();

} //*** CPostCfgManager::DebugDumpDepencyTree

#endif // #if defined(DEBUG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\postcfgmgr.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      PostCfgManager.h
//
//  Description:
//      CPostCfgManager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 09-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CPostCfgManager
//
//  Description:
//      The class CPostCfgManager inplements the PostCfgManager
//      interface.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CPostCfgManager
    : public IPostCfgManager        // private
    , public IClusCfgInitialize
    , public IClusCfgCallback
{
private:
    //
    // Private types
    //

    // Stucture for one entry in the resource type GUID to resource type name map.
    struct SResTypeGUIDAndName
    {
        GUID            m_guidTypeGUID;
        WCHAR *         m_pszTypeName;
    }; //*** SResTypeGUIDAndName

    // IUnknown
    LONG                            m_cRef;                     //  Reference counter

    // Pointer to the callback interface.
    IClusCfgCallback *              m_pcccb;                    //  Callback to the client

    // The locale id
    LCID                            m_lcid;                     //  Local ID of the client

    //  IPostCfgManager
    IEnumClusCfgManagedResources *  m_peccmr;                   //  Enumer of managed resources
    IClusCfgClusterInfo *           m_pccci;                    //  Cluster configuration list
    ULONG                           m_cResources;               //  Count of resources in list
    ULONG                           m_cAllocedResources;        //  Count of alloc'ed resources
    CResourceEntry **               m_rgpResources;             //  List of pointers to Resource Entries
    ULONG                           m_idxIPAddress;             //  Cluster IP Address resource index
    ULONG                           m_idxClusterName;           //  Cluster Name resource index
    ULONG                           m_idxQuorumResource;        //  Quorum resource index
    ULONG                           m_idxLastStorage;           //  Last storage resource examined
    HCLUSTER                        m_hCluster;                 //  Cluster handle
    ULONG                           m_cNetName;                 //  Net Name instance counter
    ULONG                           m_cIPAddress;               //  IP Address instance counter
    SResTypeGUIDAndName *           m_pgnResTypeGUIDNameMap;    //  Map between resource type GUID and its name
    ULONG                           m_idxNextMapEntry;          //  Index of the first free map entry
    ULONG                           m_cMapSize;                 //  Count of the number of elements in the map buffer.
    DWORD                           m_dwLocalQuorumStatusMax;   //  The max of the status report range for local quorum deletion.
    DWORD                           m_cResourcesConfigured;     //  The number of resources that have been configured (for logging)
    ECommitMode                     m_ecmCommitChangesMode;     //  What are we doing, create cluster, adding nodes, or cleaning up?
    BOOL                            m_fIsQuorumChanged;         //  Set this flag if a better quorum resource has been found.
    BSTR                            m_bstrNodeName;

private: // Methods
    CPostCfgManager( void );
    ~CPostCfgManager( void );

    // Private copy constructor to prevent copying.
    CPostCfgManager( const CPostCfgManager & nodeSrc );

    // Private assignment operator to prevent copying.
    const CPostCfgManager & operator = ( const CPostCfgManager & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrPreCreateResources( void );
    HRESULT HrCreateGroups( void );
    HRESULT HrCreateResources( void );
    HRESULT HrPostCreateResources( void );
    HRESULT HrEvictCleanupResources( void );
    HRESULT HrFindNextSharedStorage( ULONG * pidxInout );
    HRESULT HrAttemptToAssignStorageToResource( ULONG idxResourceIn, EDependencyFlags dfResourceFlagsIn );
    HRESULT HrMovedDependentsToAnotherResource( ULONG idxSourceIn, ULONG idxDestIn );
    HRESULT HrSetGroupOnResourceAndItsDependents( ULONG idxResourceIn, CGroupHandle * pghIn );
    HRESULT HrFindGroupFromResourceOrItsDependents( ULONG idxResourceIn, CGroupHandle ** pghOut );
    HRESULT HrCreateResourceAndDependents( ULONG idxResourceIn );
    HRESULT HrPostCreateResourceAndDependents( ULONG idxResourceIn );
    HRESULT HrPreInitializeExistingResources( void );
    HRESULT HrAddSpecialResource( BSTR  bstrNameIn, const CLSID * pclsidTypeIn, const CLSID * pclsidClassTypeIn );
    HRESULT HrCreateResourceInstance( ULONG idxResourceIn, HGROUP hGroupIn, LPCWSTR pszResTypeIn, HRESOURCE * phResourceOut );
    HRESULT HrGetCoreClusterResourceNames(
                                      BSTR *        pbstrClusterNameResourceNameOut
                                    , HRESOURCE *   phClusterNameResourceOut
                                    , BSTR *        pbstrClusterIPAddressNameOut
                                    , HRESOURCE *   phClusterIPAddressResourceOut
                                    , BSTR *        pbstrClusterQuorumResourceNameOut
                                    , HRESOURCE *   phClusterQuorumResourceOut
                                    );
    //HRESULT HrIsLocalQuorum( BSTR  bstrNameIn );

    // Enumerate all components on the local computer registered for resource type
    // configuration.
    HRESULT HrConfigureResTypes( IUnknown * punkResTypeServicesIn );

    // Instantiates a resource type configuration component and calls the appropriate methods.
    HRESULT HrProcessResType( const CLSID & rclsidResTypeCLSIDIn, IUnknown * punkResTypeServicesIn );

    // Notify all components on the local computer registered to get
    // notification of cluster member set change (create, add node or evict).
    HRESULT HrNotifyMemberSetChangeListeners( void );

    // Instantiates cluster member set change listener and notifies it.
    HRESULT HrProcessMemberSetChangeListener( const CLSID & rclsidListenerClsidIn );

    // Create a mapping between a resource type GUID and a resource type name.
    HRESULT HrMapResTypeGUIDToName( const GUID & rcguidTypeGuidIn, const WCHAR * pcszTypeNameIn );

    //  Given a resource type GUID this function finds the resource type name if any.
    const WCHAR * PcszLookupTypeNameByGUID( const GUID & rcguidTypeGuidIn );

    // Callback function used to delete the local quorum resource.
    static DWORD S_ScDeleteLocalQuorumResource( HCLUSTER hClusterIn , HRESOURCE hSelfIn, HRESOURCE hCurrentResourceIn, PVOID pvParamIn );

#if defined(DEBUG)
    void
        DebugDumpDepencyTree( void );
#endif // DEBUG

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IPostCfgManager - private
    STDMETHOD( CommitChanges )( IEnumClusCfgManagedResources * peccmrIn, IClusCfgClusterInfo * pccciIn );

    //  IClusCfgInitialize
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //  IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** class CPostCfgManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\postcfgstrings.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      PostCfgStrings.h
//
//  Description:
//      Contains the definition of the string ids used by this library.
//      This file will be included in the main resource header of the project.
//
//  Maintained By:
//      Galen Barbee (GalenB) 16-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

#include <ResourceIdRanges.h>

/////////////////////////////////////////////////////////////////////
// Strings
/////////////////////////////////////////////////////////////////////

#define IDS_GENSCRIPT_DISPLAY_NAME                                                              ( ID_POSTCFG_START + 1 )
#define IDS_CONFIGURING_RESTYPE                                                                 ( ID_POSTCFG_START + 2 )
#define IDS_TASKID_MINOR_CREATING_RESOURCE                                                      ( ID_POSTCFG_START + 3 )
#define IDS_TASKID_MINOR_LOCATE_EXISTING_QUORUM_DEVICE                                          ( ID_POSTCFG_START + 4 )
#define IDS_TASKID_MINOR_SET_QUORUM_DEVICE                                                      ( ID_POSTCFG_START + 5 )
#define IDS_TASKID_MINOR_STARTING_RESOURCES                                                     ( ID_POSTCFG_START + 6 )
#define IDS_TASKID_MINOR_RESOURCE_FAILED_POSTCREATE                                             ( ID_POSTCFG_START + 7 )
//#define                                                                                         ( ID_POSTCFG_START + 8 )
#define IDS_TASKID_MINOR_RESOURCE_FAILED_PRECREATE                                              ( ID_POSTCFG_START + 9 )
#define IDS_DELETING_LOCAL_QUORUM_RESOURCE                                                      ( ID_POSTCFG_START + 10 )
//#define                                                                                         ( ID_POSTCFG_START + 11 )
#define IDS_TASKID_MINOR_RESOURCE_FAILED_POSTCREATE_LOG                                         ( ID_POSTCFG_START + 12 )
#define IDS_TASKID_MINOR_QUERYING_FOR_RESOURCE_DEPENDENCIES                                     ( ID_POSTCFG_START + 13 )
#define IDS_TASKID_MINOR_INIT_MAPRESTYPEGUIDTONAME                                              ( ID_POSTCFG_START + 14 )
#define IDS_MAJORITYNODESET_DISPLAY_NAME                                                        ( ID_POSTCFG_START + 15 )
//#define                                                                                         ( ID_POSTCFG_START + 16 )
#define IDS_TASKID_MINOR_RESOURCE_ONLINE                                                        ( ID_POSTCFG_START + 17 )
#define IDS_TASKID_MINOR_ERROR_CREATE_RESOURCE_SERVICE                                          ( ID_POSTCFG_START + 18 )
#define IDS_TASKID_MINOR_ERROR_INIT_RESOURCE_SERVICE                                            ( ID_POSTCFG_START + 19 )
#define IDS_TASKID_MINOR_ERROR_CLUSTER_HANDLE                                                   ( ID_POSTCFG_START + 20 )
#define IDS_TASKID_MINOR_ERROR_CREATE_SERVICE                                                   ( ID_POSTCFG_START + 21 )
#define IDS_TASKID_MINOR_SETTING_QUORUM_DEVICE                                                  ( ID_POSTCFG_START + 22 )
#define IDS_TASKID_MINOR_ERROR_MANAGED_RESOURCE                                                 ( ID_POSTCFG_START + 23 )
#define IDS_TASKID_MINOR_ERROR_RES_NOT_CREATED                                                  ( ID_POSTCFG_START + 24 )
#define IDS_TASKID_MINOR_ERROR_NET_RESOURCE_NAME                                                ( ID_POSTCFG_START + 25 )
#define IDS_TASKID_MINOR_ERROR_IP_RESOURCE_NAME                                                 ( ID_POSTCFG_START + 26 )
#define IDS_TASKID_MINOR_ERROR_MISSING_DEPENDENT_RES                                            ( ID_POSTCFG_START + 27 )
#define IDS_TASKID_MINOR_ERROR_GET_COREGROUP_HANDLE                                             ( ID_POSTCFG_START + 28 )
#define IDS_TASKID_MINOR_ERROR_OPEN_GROUP                                                       ( ID_POSTCFG_START + 29 )
#define IDS_TASKID_MINOR_ERROR_CREATE_NAME                                                      ( ID_POSTCFG_START + 30 )
#define IDS_TASKID_MINOR_ERROR_CREATE_GROUP                                                     ( ID_POSTCFG_START + 31 )
#define IDS_TASKID_MINOR_ERROR_GROUP_ONLINE                                                     ( ID_POSTCFG_START + 32 )
#define IDS_TASKID_MINOR_ERROR_AVAILABLE_STORAGE                                                ( ID_POSTCFG_START + 33 )
#define IDS_TASKID_MINOR_RESTYPE_NOT_REGISTERED                                                 ( ID_POSTCFG_START + 34 )
#define IDS_TASKID_MINOR_RESOURCE_FAIL_ONLINE                                                   ( ID_POSTCFG_START + 35 )
#define IDS_TASKID_MINOR_RESOURCE_WENT_OFFLINE                                                  ( ID_POSTCFG_START + 36 )
#define IDS_TASKID_MINOR_RESOURCE_FAILED                                                        ( ID_POSTCFG_START + 37 )
#define IDS_TASKID_MINOR_ERROR_PROCESS_RESOURCE_TYPE                                            ( ID_POSTCFG_START + 38 )
#define IDS_TASKID_MINOR_ERROR_CREATE_RESOURCE_CONFIG                                           ( ID_POSTCFG_START + 39 )
#define IDS_TASKID_MINOR_ERROR_INIT_RESOURCE_CONFIG                                             ( ID_POSTCFG_START + 40 )
#define IDS_TASKID_MINOR_ERROR_GET_RESTYPE_NAME                                                 ( ID_POSTCFG_START + 41 )
#define IDS_TASKID_MINOR_ERROR_CONFIG_RESOURCE_TYPE                                             ( ID_POSTCFG_START + 42 )
#define IDS_TASKID_MINOR_ERROR_RESOURCE_TYPE_GUID                                               ( ID_POSTCFG_START + 43 )
#define IDS_TASKID_MINOR_ERROR_MAPPING_GUID_AND_NAME                                            ( ID_POSTCFG_START + 44 )
#define IDS_TASKID_MINOR_ERROR_CREATE_RESOURCE                                                  ( ID_POSTCFG_START + 45 )
#define IDS_TASKID_MINOR_ERROR_MOVE_RESOURCE                                                    ( ID_POSTCFG_START + 46 )
#define IDS_TASKID_MINOR_ERROR_RESTYPE_INVALID                                                  ( ID_POSTCFG_START + 47 )
#define IDS_TASKID_MINOR_ERROR_RESTYPE_NAME                                                     ( ID_POSTCFG_START + 48 )
#define IDS_TASKID_MINOR_ERROR_RESTYPE_TEXT                                                     ( ID_POSTCFG_START + 49 )
#define IDS_TASKID_MINOR_ERROR_RESTYPE_CLUSINFO                                                 ( ID_POSTCFG_START + 50 )
#define IDS_TASKID_MINOR_ERROR_COMMIT_MODE                                                      ( ID_POSTCFG_START + 51 )
#define IDS_TASKID_MINOR_ERROR_COMMIT_RESTYPE                                                   ( ID_POSTCFG_START + 52 )
#define IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY                                                    ( ID_POSTCFG_START + 53 )
#define IDS_TASKID_MINOR_ERROR_INIT_POSTCFGMGR                                                  ( ID_POSTCFG_START + 54 )
#define IDS_TASKID_MINOR_ERROR_COMMIT_CHANGES                                                   ( ID_POSTCFG_START + 55 )
#define IDS_TASKID_MINOR_ERROR_ENUM_MANAGEDRES                                                  ( ID_POSTCFG_START + 56 )
#define IDS_TASKID_MINOR_ERROR_LOADSTR_RES_DEP                                                  ( ID_POSTCFG_START + 57 )
#define IDS_TASKID_MINOR_ERROR_GET_RESOURCE_NAME                                                ( ID_POSTCFG_START + 58 )
#define IDS_TASKID_MINOR_ERROR_DETERMINE_MANAGED                                                ( ID_POSTCFG_START + 59 )
#define IDS_TASKID_MINOR_ERROR_MANAGED_RES_CONFIG                                               ( ID_POSTCFG_START + 60 )
#define IDS_TASKID_MINOR_ERROR_IS_QUORUM_RESOURCE                                               ( ID_POSTCFG_START + 61 )
#define IDS_TASKID_MINOR_ERROR_SET_ASSOC_RESOURCE                                               ( ID_POSTCFG_START + 62 )
#define IDS_TASKID_MINOR_ERROR_SET_RESOURCE_NAME                                                ( ID_POSTCFG_START + 63 )
#define IDS_TASKID_MINOR_ERROR_SETENTRY                                                         ( ID_POSTCFG_START + 64 )
#define IDS_TASKID_MINOR_ERROR_COUNT_OF_DEPENDENCY                                              ( ID_POSTCFG_START + 65 )
#define IDS_TASKID_MINOR_ERROR_DEPENDENCY_PTR                                                   ( ID_POSTCFG_START + 66 )
#define IDS_TASKID_MINOR_ERROR_TYPE_DEPENDENCY                                                  ( ID_POSTCFG_START + 67 )
#define IDS_TASKID_MINOR_ERROR_ADD_DEPENDENT                                                    ( ID_POSTCFG_START + 68 )
#define IDS_TASKID_MINOR_ERROR_GET_RESTYPE_PTR                                                  ( ID_POSTCFG_START + 69 )
#define IDS_TASKID_MINOR_ERROR_GET_CLASSTYPE_PTR                                                ( ID_POSTCFG_START + 70 )
#define IDS_TASKID_MINOR_ERROR_GET_RESOURCE_FLAGS                                               ( ID_POSTCFG_START + 71 )
#define IDS_TASKID_MINOR_ERROR_SET_RESOURCE_FLAGS                                               ( ID_POSTCFG_START + 72 )
#define IDS_TASKID_MINOR_ERROR_GET_ASSOC_RESOURCE                                               ( ID_POSTCFG_START + 73 )
#define IDS_TASKID_MINOR_ERROR_MANAGED_RES_INFO                                                 ( ID_POSTCFG_START + 74 )
#define IDS_TASKID_MINOR_ERROR_SET_MANAGED_FALSE                                                ( ID_POSTCFG_START + 75 )
#define IDS_TASKID_MINOR_ERROR_CREATE_GROUP_HANDLE                                              ( ID_POSTCFG_START + 76 )
#define IDS_TASKID_MINOR_ERROR_LOADSTRING                                                       ( ID_POSTCFG_START + 77 )
#define IDS_TASKID_MINOR_ERROR_SET_RES_DEP_FLAGS                                                ( ID_POSTCFG_START + 78 )
#define IDS_TASKID_MINOR_ERROR_COUNT_OF_DEPENDENTS                                              ( ID_POSTCFG_START + 79 )
#define IDS_TASKID_MINOR_ERROR_GET_DEPENDENT                                                    ( ID_POSTCFG_START + 80 )
#define IDS_TASKID_MINOR_ERROR_CLEAR_DEPENDENT                                                  ( ID_POSTCFG_START + 81 )
#define IDS_TASKID_MINOR_ERROR_SET_GROUP_HANDLE                                                 ( ID_POSTCFG_START + 82 )
#define IDS_TASKID_MINOR_ERROR_GET_GROUP_HANDLE                                                 ( ID_POSTCFG_START + 83 )
#define IDS_TASKID_MINOR_ERROR_RESOURCE_STATE                                                   ( ID_POSTCFG_START + 84 )
#define IDS_TASKID_MINOR_ERROR_POST_SETENTRY                                                    ( ID_POSTCFG_START + 85 )
#define IDS_TASKID_MINOR_ERROR_ISCONFIGURED                                                     ( ID_POSTCFG_START + 86 )
#define IDS_TASKID_MINOR_ERROR_SETCONFIGURED                                                    ( ID_POSTCFG_START + 87 )
#define IDS_TASKID_MINOR_ERROR_GET_GROUP_HANDLE_PTR                                             ( ID_POSTCFG_START + 88 )
#define IDS_TASKID_MINOR_ERROR_GET_ASSOC_RES                                                    ( ID_POSTCFG_START + 89 )
#define IDS_TASKID_MINOR_ERROR_CREATE_FAILED                                                    ( ID_POSTCFG_START + 90 )
#define IDS_TASKID_MINOR_ERROR_RESOURCE_CREATE                                                  ( ID_POSTCFG_START + 91 )
#define IDS_TASKID_MINOR_ERROR_DEP_RESOURCE_HANDLE                                              ( ID_POSTCFG_START + 92 )
#define IDS_TASKID_MINOR_ERROR_ADD_RESOURCE_DEPENDENCY                                          ( ID_POSTCFG_START + 93 )
#define IDS_TASKID_MINOR_ERROR_SET_QUORUM_RES                                                   ( ID_POSTCFG_START + 94 )
#define IDS_TASKID_MINOR_ERROR_COMPONENT_CATEGORY_MGR                                           ( ID_POSTCFG_START + 95 )
#define IDS_TASKID_MINOR_ERROR_COMPONENT_ENUM_CLASS                                             ( ID_POSTCFG_START + 96 )
#define IDS_TASKID_MINOR_ERROR_NEXT_LISTENER                                                    ( ID_POSTCFG_START + 97 )
#define IDS_TASKID_MINOR_ERROR_PROCESS_LISTENER                                                 ( ID_POSTCFG_START + 98 )
#define IDS_TASKID_MINOR_ERROR_GET_LISTENER_PTR                                                 ( ID_POSTCFG_START + 99 )
#define IDS_TASKID_MINOR_ERROR_NOTIFY_LISTENER                                                  ( ID_POSTCFG_START + 100 )
#define IDS_TASKID_MINOR_ERROR_EMPTY_RESTYPE_NAME                                               ( ID_POSTCFG_START + 101 )
#define IDS_TASKID_MINOR_ERROR_LOADSTR_QUORUM_RES                                               ( ID_POSTCFG_START + 102 )
#define IDS_TASKID_MINOR_ERROR_SET_RESOURCE_TYPE                                                ( ID_POSTCFG_START + 103 )
#define IDS_TASKID_MINOR_ERROR_SET_RESCLASS_TYPE                                                ( ID_POSTCFG_START + 104 )
#define IDS_TASKID_MINOR_ERROR_GET_RESOURCE_HANDLE                                              ( ID_POSTCFG_START + 105 )
#define IDS_TASKID_MINOR_ERROR_SET_RESOURCE_HANDLE                                              ( ID_POSTCFG_START + 106 )
#define IDS_TASKID_MINOR_FIGURE_DEPENDENCY_TREE                                                 ( ID_POSTCFG_START + 107 )
#define IDS_TASKID_MINOR_CREATING_GROUP                                                         ( ID_POSTCFG_START + 108 )
#define IDS_TASKID_MINOR_ERROR_PRIV_RESCONTROL                                                  ( ID_POSTCFG_START + 109 )
#define IDS_TASKID_MINOR_ERROR_COMMON_RESCONTROL                                                ( ID_POSTCFG_START + 110 )
#define IDS_TASKID_MINOR_ERROR_INVALID_PARAM                                                    ( ID_POSTCFG_START + 111 )
#define IDS_TASKID_MINOR_ERROR_CONFIG_RES_TYPE                                                  ( ID_POSTCFG_START + 112 )
#define IDS_TASKID_MINOR_ERROR_CREATE_RES_TYPE                                                  ( ID_POSTCFG_START + 113 )
#define IDS_TASKID_MINOR_ERROR_UNREG_COMPONENT                                                  ( ID_POSTCFG_START + 114 )
#define IDS_TASKID_MINOR_ERROR_OFFLINE_QUORUM                                                   ( ID_POSTCFG_START + 115 )
#define IDS_TASKID_MINOR_ERROR_NOTIFICATION_PORT                                                ( ID_POSTCFG_START + 116 )
#define IDS_TASKID_MINOR_ERROR_REGISTER_NOTIFICATION                                            ( ID_POSTCFG_START + 117 )
#define IDS_TASKID_MINOR_ERROR_ENUM_QUORUM                                                      ( ID_POSTCFG_START + 118 )
#define IDS_TASKID_MINOR_ERROR_OPEN_REGISTRY                                                    ( ID_POSTCFG_START + 119 )
#define IDS_TASKID_MINOR_ERROR_READ_REGISTRY                                                    ( ID_POSTCFG_START + 120 )
#define IDS_TASKID_MINOR_ERROR_MATCH_CRITERION                                                  ( ID_POSTCFG_START + 121 )
#define IDS_TASKID_MINOR_ERROR_FIND_FILE                                                        ( ID_POSTCFG_START + 122 )
#define IDS_TASKID_MINOR_ERROR_INVALID_CLUSTER_HANDLE                                           ( ID_POSTCFG_START + 123 )
#define IDS_TASKID_MINOR_ERROR_EXTENSION_CLASSID                                                ( ID_POSTCFG_START + 124 )
#define IDS_TASKID_MINOR_ERROR_CONFIG_EXTENSION                                                 ( ID_POSTCFG_START + 125 )
#define IDS_TASKID_MINOR_ERROR_STATE_CHANGE_TIMEOUT                                             ( ID_POSTCFG_START + 126 )
#define IDS_TASKID_MINOR_ERROR_DELETE_QUORUM                                                    ( ID_POSTCFG_START + 127 )
#define IDS_TASKID_MINOR_ERROR_GET_ICLUSCFGINIT                                                 ( ID_POSTCFG_START + 128 )
#define IDS_TASKID_MINOR_ERROR_CALL_INITIALIZE                                                  ( ID_POSTCFG_START + 129 )
#define IDS_TASKID_MINOR_ERROR_CREATE_RESENTRY                                                  ( ID_POSTCFG_START + 130 )
#define IDS_TASKID_MINOR_ERROR_CLEANUP_RESET                                                    ( ID_POSTCFG_START + 131 )
#define IDS_TASKID_MINOR_ERROR_NEXT_MANAGED                                                     ( ID_POSTCFG_START + 132 )
#define IDS_TASKID_MINOR_ERROR_RES_NOT_CLEANED                                                  ( ID_POSTCFG_START + 133 )
#define IDS_TASKID_MINOR_ERROR_EVICT                                                            ( ID_POSTCFG_START + 134 )
#define IDS_TASKID_MINOR_ERROR_FORMAT_STRING                                                    ( ID_POSTCFG_START + 135 )
#define IDS_NETNAMEFORMAT                                                                       ( ID_POSTCFG_START + 136 )
#define IDS_IPADDRESSFORMAT                                                                     ( ID_POSTCFG_START + 137 )
#define IDS_GROUP_X                                                                             ( ID_POSTCFG_START + 138 )
#define IDS_TASKID_MINOR_SETTING_PRIVATE_PROPERTIES                                             ( ID_POSTCFG_START + 139 )
#define IDS_TASKID_MINOR_SETTING_COMMON_PROPERTIES                                              ( ID_POSTCFG_START + 140 )
#define IDS_TASKID_MINOR_ERROR_GET_QUORUM_LOG_SIZE                                              ( ID_POSTCFG_START + 141 )

/////////////////////////////////////////////////////////////////////
//  Reference IDs
/////////////////////////////////////////////////////////////////////

#define IDS_REF_MINOR_RESOURCE_FAILED_POSTCREATE                                                ( ID_POSTCFG_START + 207 )
#define IDS_REF_MINOR_RESOURCE_FAILED_CREATE                                                    ( ID_POSTCFG_START + 208 )
#define IDS_REF_MINOR_RESOURCE_FAILED_PRECREATE                                                 ( ID_POSTCFG_START + 209 )
#define IDS_REF_MINOR_INIT_MAPRESTYPEGUIDTONAME                                                 ( ID_POSTCFG_START + 214 )
#define IDS_REF_MINOR_ERROR_CREATE_RESOURCE_SERVICE                                             ( ID_POSTCFG_START + 218 )
#define IDS_REF_MINOR_ERROR_INIT_RESOURCE_SERVICE                                               ( ID_POSTCFG_START + 219 )
#define IDS_REF_MINOR_ERROR_CLUSTER_HANDLE                                                      ( ID_POSTCFG_START + 220 )
#define IDS_REF_MINOR_ERROR_CREATE_SERVICE                                                      ( ID_POSTCFG_START + 221 )
//#define                                                      ( ID_POSTCFG_START + 222 )
#define IDS_REF_MINOR_ERROR_MANAGED_RESOURCE                                                    ( ID_POSTCFG_START + 223 )
#define IDS_REF_MINOR_ERROR_RES_NOT_CREATED                                                     ( ID_POSTCFG_START + 224 )
#define IDS_REF_MINOR_ERROR_NET_RESOURCE_NAME                                                   ( ID_POSTCFG_START + 225 )
#define IDS_REF_MINOR_ERROR_IP_RESOURCE_NAME                                                    ( ID_POSTCFG_START + 226 )
#define IDS_REF_MINOR_ERROR_MISSING_DEPENDENT_RES                                               ( ID_POSTCFG_START + 227 )
#define IDS_REF_MINOR_ERROR_GET_COREGROUP_HANDLE                                                ( ID_POSTCFG_START + 228 )
#define IDS_REF_MINOR_ERROR_OPEN_GROUP                                                          ( ID_POSTCFG_START + 229 )
#define IDS_REF_MINOR_ERROR_CREATE_NAME                                                         ( ID_POSTCFG_START + 230 )
#define IDS_REF_MINOR_ERROR_CREATE_GROUP                                                        ( ID_POSTCFG_START + 231 )
#define IDS_REF_MINOR_ERROR_GROUP_ONLINE                                                        ( ID_POSTCFG_START + 232 )
#define IDS_REF_MINOR_ERROR_AVAILABLE_STORAGE                                                   ( ID_POSTCFG_START + 233 )
#define IDS_REF_MINOR_RESTYPE_NOT_REGISTERED                                                    ( ID_POSTCFG_START + 234 )
#define IDS_REF_MINOR_RESOURCE_FAIL_ONLINE                                                      ( ID_POSTCFG_START + 235 )
#define IDS_REF_MINOR_RESOURCE_WENT_OFFLINE                                                     ( ID_POSTCFG_START + 236 )
#define IDS_REF_MINOR_RESOURCE_FAILED                                                           ( ID_POSTCFG_START + 237 )
#define IDS_REF_MINOR_ERROR_PROCESS_RESOURCE_TYPE                                               ( ID_POSTCFG_START + 238 )
#define IDS_REF_MINOR_ERROR_CREATE_RESOURCE_CONFIG                                              ( ID_POSTCFG_START + 239 )
#define IDS_REF_MINOR_ERROR_INIT_RESOURCE_CONFIG                                                ( ID_POSTCFG_START + 240 )
#define IDS_REF_MINOR_ERROR_GET_RESTYPE_NAME                                                    ( ID_POSTCFG_START + 241 )
#define IDS_REF_MINOR_ERROR_CONFIG_RESOURCE_TYPE                                                ( ID_POSTCFG_START + 242 )
#define IDS_REF_MINOR_ERROR_RESOURCE_TYPE_GUID                                                  ( ID_POSTCFG_START + 243 )
#define IDS_REF_MINOR_ERROR_MAPPING_GUID_AND_NAME                                               ( ID_POSTCFG_START + 244 )
#define IDS_REF_MINOR_ERROR_CREATE_RESOURCE                                                     ( ID_POSTCFG_START + 245 )
#define IDS_REF_MINOR_ERROR_MOVE_RESOURCE                                                       ( ID_POSTCFG_START + 246 )
#define IDS_REF_MINOR_ERROR_RESTYPE_INVALID                                                     ( ID_POSTCFG_START + 247 )
#define IDS_REF_MINOR_ERROR_RESTYPE_NAME                                                        ( ID_POSTCFG_START + 248 )
#define IDS_REF_MINOR_ERROR_RESTYPE_TEXT                                                        ( ID_POSTCFG_START + 249 )
#define IDS_REF_MINOR_ERROR_RESTYPE_CLUSINFO                                                    ( ID_POSTCFG_START + 250 )
#define IDS_REF_MINOR_ERROR_COMMIT_MODE                                                         ( ID_POSTCFG_START + 251 )
#define IDS_REF_MINOR_ERROR_COMMIT_RESTYPE                                                      ( ID_POSTCFG_START + 252 )
#define IDS_REF_MINOR_ERROR_OUT_OF_MEMORY                                                       ( ID_POSTCFG_START + 253 )
#define IDS_REF_MINOR_ERROR_INIT_POSTCFGMGR                                                     ( ID_POSTCFG_START + 254 )
#define IDS_REF_MINOR_ERROR_COMMIT_CHANGES                                                      ( ID_POSTCFG_START + 255 )
#define IDS_REF_MINOR_ERROR_ENUM_MANAGEDRES                                                     ( ID_POSTCFG_START + 256 )
#define IDS_REF_MINOR_ERROR_LOADSTR_RES_DEP                                                     ( ID_POSTCFG_START + 257 )
#define IDS_REF_MINOR_ERROR_GET_RESOURCE_NAME                                                   ( ID_POSTCFG_START + 258 )
#define IDS_REF_MINOR_ERROR_DETERMINE_MANAGED                                                   ( ID_POSTCFG_START + 259 )
#define IDS_REF_MINOR_ERROR_MANAGED_RES_CONFIG                                                  ( ID_POSTCFG_START + 260 )
#define IDS_REF_MINOR_ERROR_IS_QUORUM_RESOURCE                                                  ( ID_POSTCFG_START + 261 )
#define IDS_REF_MINOR_ERROR_SET_ASSOC_RESOURCE                                                  ( ID_POSTCFG_START + 262 )
#define IDS_REF_MINOR_ERROR_SET_RESOURCE_NAME                                                   ( ID_POSTCFG_START + 263 )
#define IDS_REF_MINOR_ERROR_SETENTRY                                                            ( ID_POSTCFG_START + 264 )
#define IDS_REF_MINOR_ERROR_COUNT_OF_DEPENDENCY                                                 ( ID_POSTCFG_START + 265 )
#define IDS_REF_MINOR_ERROR_DEPENDENCY_PTR                                                      ( ID_POSTCFG_START + 266 )
#define IDS_REF_MINOR_ERROR_TYPE_DEPENDENCY                                                     ( ID_POSTCFG_START + 267 )
#define IDS_REF_MINOR_ERROR_ADD_DEPENDENT                                                       ( ID_POSTCFG_START + 268 )
#define IDS_REF_MINOR_ERROR_GET_RESTYPE_PTR                                                     ( ID_POSTCFG_START + 269 )
#define IDS_REF_MINOR_ERROR_GET_CLASSTYPE_PTR                                                   ( ID_POSTCFG_START + 270 )
#define IDS_REF_MINOR_ERROR_GET_RESOURCE_FLAGS                                                  ( ID_POSTCFG_START + 271 )
#define IDS_REF_MINOR_ERROR_SET_RESOURCE_FLAGS                                                  ( ID_POSTCFG_START + 272 )
#define IDS_REF_MINOR_ERROR_GET_ASSOC_RESOURCE                                                  ( ID_POSTCFG_START + 273 )
#define IDS_REF_MINOR_ERROR_MANAGED_RES_INFO                                                    ( ID_POSTCFG_START + 274 )
#define IDS_REF_MINOR_ERROR_SET_MANAGED_FALSE                                                   ( ID_POSTCFG_START + 275 )
#define IDS_REF_MINOR_ERROR_CREATE_GROUP_HANDLE                                                 ( ID_POSTCFG_START + 276 )
#define IDS_REF_MINOR_ERROR_LOADSTRING                                                          ( ID_POSTCFG_START + 277 )
#define IDS_REF_MINOR_ERROR_SET_RES_DEP_FLAGS                                                   ( ID_POSTCFG_START + 278 )
#define IDS_REF_MINOR_ERROR_COUNT_OF_DEPENDENTS                                                 ( ID_POSTCFG_START + 279 )
#define IDS_REF_MINOR_ERROR_GET_DEPENDENT                                                       ( ID_POSTCFG_START + 280 )
#define IDS_REF_MINOR_ERROR_CLEAR_DEPENDENT                                                     ( ID_POSTCFG_START + 281 )
#define IDS_REF_MINOR_ERROR_SET_GROUP_HANDLE                                                    ( ID_POSTCFG_START + 282 )
#define IDS_REF_MINOR_ERROR_GET_GROUP_HANDLE                                                    ( ID_POSTCFG_START + 283 )
#define IDS_REF_MINOR_ERROR_RESOURCE_STATE                                                      ( ID_POSTCFG_START + 284 )
#define IDS_REF_MINOR_ERROR_POST_SETENTRY                                                       ( ID_POSTCFG_START + 285 )
#define IDS_REF_MINOR_ERROR_ISCONFIGURED                                                        ( ID_POSTCFG_START + 286 )
#define IDS_REF_MINOR_ERROR_SETCONFIGURED                                                       ( ID_POSTCFG_START + 287 )
#define IDS_REF_MINOR_ERROR_GET_GROUP_HANDLE_PTR                                                ( ID_POSTCFG_START + 288 )
#define IDS_REF_MINOR_ERROR_GET_ASSOC_RES                                                       ( ID_POSTCFG_START + 289 )
#define IDS_REF_MINOR_ERROR_CREATE_FAILED                                                       ( ID_POSTCFG_START + 290 )
#define IDS_REF_MINOR_ERROR_RESOURCE_CREATE                                                     ( ID_POSTCFG_START + 291 )
#define IDS_REF_MINOR_ERROR_DEP_RESOURCE_HANDLE                                                 ( ID_POSTCFG_START + 292 )
#define IDS_REF_MINOR_ERROR_ADD_RESOURCE_DEPENDENCY                                             ( ID_POSTCFG_START + 293 )
#define IDS_REF_MINOR_ERROR_SET_QUORUM_RES                                                      ( ID_POSTCFG_START + 294 )
#define IDS_REF_MINOR_ERROR_COMPONENT_CATEGORY_MGR                                              ( ID_POSTCFG_START + 295 )
#define IDS_REF_MINOR_ERROR_COMPONENT_ENUM_CLASS                                                ( ID_POSTCFG_START + 296 )
#define IDS_REF_MINOR_ERROR_NEXT_LISTENER                                                       ( ID_POSTCFG_START + 297 )
#define IDS_REF_MINOR_ERROR_PROCESS_LISTENER                                                    ( ID_POSTCFG_START + 298 )
#define IDS_REF_MINOR_ERROR_GET_LISTENER_PTR                                                    ( ID_POSTCFG_START + 299 )
#define IDS_REF_MINOR_ERROR_NOTIFY_LISTENER                                                     ( ID_POSTCFG_START + 300 )
#define IDS_REF_MINOR_ERROR_EMPTY_RESTYPE_NAME                                                  ( ID_POSTCFG_START + 301 )
#define IDS_REF_MINOR_ERROR_LOADSTR_QUORUM_RES                                                  ( ID_POSTCFG_START + 302 )
#define IDS_REF_MINOR_ERROR_SET_RESOURCE_TYPE                                                   ( ID_POSTCFG_START + 303 )
#define IDS_REF_MINOR_ERROR_SET_RESCLASS_TYPE                                                   ( ID_POSTCFG_START + 304 )
#define IDS_REF_MINOR_ERROR_GET_RESOURCE_HANDLE                                                 ( ID_POSTCFG_START + 305 )
#define IDS_REF_MINOR_ERROR_SET_RESOURCE_HANDLE                                                 ( ID_POSTCFG_START + 306 )
#define IDS_REF_MINOR_ERROR_PRIV_RESCONTROL                                                     ( ID_POSTCFG_START + 309 )
#define IDS_REF_MINOR_ERROR_COMMON_RESCONTROL                                                   ( ID_POSTCFG_START + 310 )
#define IDS_REF_MINOR_ERROR_INVALID_PARAM                                                       ( ID_POSTCFG_START + 311 )
#define IDS_REF_MINOR_ERROR_CONFIG_RES_TYPE                                                     ( ID_POSTCFG_START + 312 )
#define IDS_REF_MINOR_ERROR_CREATE_RES_TYPE                                                     ( ID_POSTCFG_START + 313 )
#define IDS_REF_MINOR_ERROR_UNREG_COMPONENT                                                     ( ID_POSTCFG_START + 314 )
#define IDS_REF_MINOR_ERROR_OFFLINE_QUORUM                                                      ( ID_POSTCFG_START + 315 )
#define IDS_REF_MINOR_ERROR_NOTIFICATION_PORT                                                   ( ID_POSTCFG_START + 316 )
#define IDS_REF_MINOR_ERROR_REGISTER_NOTIFICATION                                               ( ID_POSTCFG_START + 317 )
#define IDS_REF_MINOR_ERROR_ENUM_QUORUM                                                         ( ID_POSTCFG_START + 318 )
#define IDS_REF_MINOR_ERROR_OPEN_REGISTRY                                                       ( ID_POSTCFG_START + 319 )
#define IDS_REF_MINOR_ERROR_READ_REGISTRY                                                       ( ID_POSTCFG_START + 320 )
#define IDS_REF_MINOR_ERROR_MATCH_CRITERION                                                     ( ID_POSTCFG_START + 321 )
#define IDS_REF_MINOR_ERROR_FIND_FILE                                                           ( ID_POSTCFG_START + 322 )
#define IDS_REF_MINOR_ERROR_INVALID_CLUSTER_HANDLE                                              ( ID_POSTCFG_START + 323 )
#define IDS_REF_MINOR_ERROR_EXTENSION_CLASSID                                                   ( ID_POSTCFG_START + 324 )
#define IDS_REF_MINOR_ERROR_CONFIG_EXTENSION                                                    ( ID_POSTCFG_START + 325 )
#define IDS_REF_MINOR_ERROR_STATE_CHANGE_TIMEOUT                                                ( ID_POSTCFG_START + 326 )
#define IDS_REF_MINOR_ERROR_DELETE_QUORUM                                                       ( ID_POSTCFG_START + 327 )
#define IDS_REF_MINOR_ERROR_GET_ICLUSCFGINIT                                                    ( ID_POSTCFG_START + 328 )
#define IDS_REF_MINOR_ERROR_CALL_INITIALIZE                                                     ( ID_POSTCFG_START + 329 )
#define IDS_REF_MINOR_ERROR_CREATE_RESENTRY                                                     ( ID_POSTCFG_START + 330 )
#define IDS_REF_MINOR_ERROR_CLEANUP_RESET                                                       ( ID_POSTCFG_START + 331 )
#define IDS_REF_MINOR_ERROR_NEXT_MANAGED                                                        ( ID_POSTCFG_START + 332 )
#define IDS_REF_MINOR_ERROR_RES_NOT_CLEANED                                                     ( ID_POSTCFG_START + 333 )
#define IDS_REF_MINOR_ERROR_EVICT                                                               ( ID_POSTCFG_START + 334 )
#define IDS_REF_MINOR_ERROR_FORMAT_STRING                                                       ( ID_POSTCFG_START + 335 )
#define IDS_REF_MINOR_ERROR_GET_QUORUM_LOG_SIZE                                                 ( ID_POSTCFG_START + 336 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\precreateservices.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      PreCreateServices.h
//
//  Description:
//      PreCreateServices implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CPreCreateServices
    : public IClusCfgResourcePreCreate
    , public IPrivatePostCfgResource
{
private:    // data
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    //  IPrivatePostCfgResource
    CResourceEntry *    m_presentry;    //  List entry that the service is to modify.

private:    // methods
    CPreCreateServices( void );
    ~CPreCreateServices( void );

    HRESULT HrInit( void );

public:     // methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgResourcePreCreate
    STDMETHOD( SetDependency )( LPCLSID pclsidDepResTypeIn, DWORD dfIn );
    STDMETHOD( SetType )( LPCLSID pclsidIn );
    STDMETHOD( SetClassType )( LPCLSID pclsidIn );

    //  IPrivatePostCfgResource
    STDMETHOD( SetEntry )( CResourceEntry * presentryIn );

}; //*** class CPreCreateServices
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\proplist.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CClusPropList.cpp
//
//  Description:
//      Sucks in the CClusPropList library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 14-JUN-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <ClusApi.h>
#include <PropList.h>

#include "PropListSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\postcreateservices.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      PostCreateServices.h
//
//  Description:
//      PostCreateServices implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "GroupHandle.h"
#include "ResourceEntry.h"
#include "IPrivatePostCfgResource.h"
#include "PostCreateServices.h"

DEFINE_THISCLASS("CPostCreateServices")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCreateServices::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCreateServices::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CPostCreateServices *   ppcs = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    ppcs = new CPostCreateServices;
    if ( ppcs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( ppcs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ppcs->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ppcs != NULL )
    {
        ppcs->Release();
    }

    HRETURN( hr );

} //*** CPostCreateServices::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CPostCreateServices::CPostCreateServices
//
//////////////////////////////////////////////////////////////////////////////
CPostCreateServices::CPostCreateServices( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CPostCreateServices::CPostCreateServices

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCreateServices::HrInit
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCreateServices::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // Resource
    Assert( m_presentry == NULL );

    HRETURN( hr );

} //*** CPostCreateServices::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CPostCreateServices::~CPostCreateServices
//
//////////////////////////////////////////////////////////////////////////////
CPostCreateServices::~CPostCreateServices( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CPostCreateServices::~CPostCreateServices


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPostCreateServices::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPostCreateServices::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgResourcePostCreate * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgResourcePostCreate ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgResourcePostCreate, this, 0 );
    } // else if: IClusCfgResourcePostCreate
    else if ( IsEqualIID( riidIn, IID_IPrivatePostCfgResource ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IPrivatePostCfgResource, this, 0 );
    } // else if: IPrivatePostCfgResource
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CPostCreateServices::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPostCreateServices::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CPostCreateServices::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CPostCreateServices::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPostCreateServices::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CPostCreateServices::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CPostCreateServices::Release


//****************************************************************************
//
//  IClusCfgResourcePostCreate
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPostCreateServices::ChangeName( 
//      LPCWSTR pcszNameIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPostCreateServices::ChangeName( 
    LPCWSTR pcszNameIn 
    )
{
    TraceFunc1( "[IClusCfgResourcePostCreate] pcszNameIn = '%s'", pcszNameIn );

    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CPostCreateServices::ChangeName

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPostCreateServices::SendResourceControl( 
//      DWORD dwControlCode,
//      LPVOID lpInBuffer,
//      DWORD cbInBufferSize,
//      LPVOID lpOutBuffer,
//      DWORD cbOutBufferSize,
//      LPDWORD lpcbBytesReturned 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPostCreateServices::SendResourceControl( 
    DWORD dwControlCode,
    LPVOID lpInBuffer,
    DWORD cbInBufferSize,
    LPVOID lpOutBuffer,
    DWORD cbOutBufferSize,
    LPDWORD lpcbBytesReturned 
    )
{
    TraceFunc( "[IClusCfgResourcePostCreate]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CPostCreateServices::SendResourceControl

//****************************************************************************
//
//  IPrivatePostCfgResource
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPostCreateServices::SetEntry( 
//      CResourceEntry * presentryIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPostCreateServices::SetEntry( 
    CResourceEntry * presentryIn
    )
{
    TraceFunc( "[IPrivatePostCfgResource]" );

    HRESULT hr = S_OK;
    
    m_presentry = presentryIn;

    HRETURN( hr );

} //*** CPostCreateServices::SetEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\postcreateservices.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      PostCreateServices.h
//
//  Description:
//      PostCreateServices implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Geoffrey Pease  (GPease)    15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CPostCreateServices
    : public IClusCfgResourcePostCreate
    , public IPrivatePostCfgResource
{
private:    // data
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    //  IPrivatePostCfgResource
    CResourceEntry *    m_presentry;    //  List entry that the service is to modify.

private:    // methods
    CPostCreateServices( void );
    ~CPostCreateServices( void );

    HRESULT HrInit( void );

public:     // methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IClusCfgResourcePostCreate
    STDMETHOD( ChangeName )( LPCWSTR pcszNameIn );
    STDMETHOD( SendResourceControl )( DWORD dwControlCode,
                                      LPVOID lpInBuffer,
                                      DWORD cbInBufferSize,
                                      LPVOID lpOutBuffer,
                                      DWORD cbOutBufferSize,
                                      LPDWORD lpcbBytesReturned 
                                      );

    //  IPrivatePostCfgResource
    STDMETHOD( SetEntry )( CResourceEntry * presentryIn );

}; //*** class CPostCreateServices
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\precreateservices.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      PreCreateServices.h
//
//  Description:
//      PreCreateServices implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Geoffrey Pease  (GPease)    15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "GroupHandle.h"
#include "ResourceEntry.h"
#include "IPrivatePostCfgResource.h"
#include "PreCreateServices.h"

DEFINE_THISCLASS("CPreCreateServices")

#define DEPENDENCY_INCREMENT    5

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPreCreateServices::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPreCreateServices::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CPreCreateServices *    ppcs = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    ppcs = new CPreCreateServices;
    if ( ppcs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( ppcs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ppcs->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ppcs != NULL )
    {
        ppcs->Release();
    }

    HRETURN( hr );

} //*** CPreCreateServices::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CPreCreateServices::CPreCreateServices
//
//////////////////////////////////////////////////////////////////////////////
CPreCreateServices::CPreCreateServices( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CPreCreateServices::CPreCreateServices

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPreCreateServices::HrInit
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPreCreateServices::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // Resource
    Assert( m_presentry == NULL );

    HRETURN( hr );

} //*** CPreCreateServices::HrInit

//////////////////////////////////////////////////////////////////////////////
//
//  CPreCreateServices::~CPreCreateServices
//
//////////////////////////////////////////////////////////////////////////////
CPreCreateServices::~CPreCreateServices( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CPreCreateServices::~CPreCreateServices


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPreCreateServices::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPreCreateServices::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgResourcePreCreate * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgResourcePreCreate ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgResourcePreCreate, this, 0 );
    } // else if: IClusCfgResourcePreCreate
    else if ( IsEqualIID( riidIn, IID_IPrivatePostCfgResource ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IPrivatePostCfgResource, this, 0 );
    } // else if: IPrivatePostCfgResource
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CPreCreateServices::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPreCreateServices::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CPreCreateServices::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CPreCreateServices::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPreCreateServices::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CPreCreateServices::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CPreCreateServices::Release


//****************************************************************************
//
//  IClusCfgResourcePreCreate
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPreCreateServices::SetType( 
//      CLSID * pclsidIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPreCreateServices::SetType( 
    CLSID * pclsidIn
    )
{
    TraceFunc( "[IClusCfgResourcePreCreate]" );

    HRESULT hr;

    Assert( m_presentry != NULL );

    hr = THR( m_presentry->SetType( pclsidIn ) );

    HRETURN( hr );

} //*** CPreCreateServices::SetType

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPreCreateServices::SetClassType( 
//      CLSID * pclsidIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPreCreateServices::SetClassType( 
    CLSID * pclsidIn
    )
{
    TraceFunc( "[IClusCfgResourcePreCreate]" );

    HRESULT hr;

    Assert( m_presentry != NULL );

    hr = THR( m_presentry->SetClassType( pclsidIn ) );

    HRETURN( hr );

} //*** CPreCreateServices::SetClassType

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPreCreateServices::SetDependency( 
//      LPCLSID pclsidDepResTypeIn, 
//      DWORD dfIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPreCreateServices::SetDependency( 
    LPCLSID pclsidDepResTypeIn, 
    DWORD dfIn 
    )
{
    TraceFunc( "[IClusCfgResourcePreCreate]" );

    HRESULT hr;

    Assert( m_presentry != NULL );

    hr = THR( m_presentry->AddTypeDependency( pclsidDepResTypeIn, (EDependencyFlags) dfIn ) );

    HRETURN( hr );

} //*** CPreCreateServices::SetDependency


//****************************************************************************
//
//  IPrivatePostCfgResource
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPreCreateServices::SetEntry( 
//      CResourceEntry * presentryIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPreCreateServices::SetEntry( 
    CResourceEntry * presentryIn
    )
{
    TraceFunc( "[IPrivatePostCfgResource]" );

    HRESULT hr = S_OK;
    
    m_presentry = presentryIn;

    HRETURN( hr );

} //*** CPreCreateServices::SetEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\resourceentry.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ResourceEntry.h
//
//  Description:
//      ResourceEntry implementation.
//
//  Maintained By:
//      Galen Barbee   (GalenB) 14-JUN-2000
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class
CResourceEntry
{
private:    // data
    // Pointer to the callback interface.
    IClusCfgCallback *          m_pcccCallback;

    // The locale id
    LCID                        m_lcid;

    //  IResourceEntry
    typedef struct _SDependencyEntry {
        CLSID               clsidType;
        EDependencyFlags    dfFlags;
        BOOL                fDependencyMet;

    } DependencyEntry;

    typedef struct _SDependentEntry {
        ULONG               idxResource;
        EDependencyFlags    dfFlags;

    } DependentEntry;

    BOOL                            m_fConfigured:1;            //  Configured flag

    BSTR                            m_bstrName;                 //  Name of the resource
    IClusCfgManagedResourceCfg *    m_pccmrcResource;           //  Config interface to resource instance

    CLSID                           m_clsidType;                //  Resource type
    CLSID                           m_clsidClassType;           //  Resource class type

    EDependencyFlags                m_dfFlags;                  //  Dependency flags set on resource

    ULONG                           m_cAllocedDependencies;     //  Alloced dependencies
    ULONG                           m_cDependencies;            //  Count of dependencies
    DependencyEntry *               m_rgDependencies;           //  Dependencies  list

    ULONG                           m_cAllocedDependents;       //  Alloced dependents
    ULONG                           m_cDependents;              //  Count of dependents
    DependentEntry *                m_rgDependents;             //  Dependents list

    CGroupHandle *                  m_groupHandle;              //  Group handle reference object
    HRESOURCE                       m_hResource;                //  Resource handle

    CClusPropList                   m_cplPrivProps;             //  Private Properties list
    CClusPropList                   m_cplCommonProps;           //  Common Properties list

    STDMETHOD( HrInit )( IClusCfgCallback * pcccCallback, LCID lcidIn );

public:     // methods
    CResourceEntry( void );
    ~CResourceEntry( void );

    // IUnknown
    //STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    //STDMETHOD_( ULONG, AddRef )( void );
    //STDMETHOD_( ULONG, Release )( void );

    static HRESULT S_HrCreateInstance( CResourceEntry ** ppcreOut, IClusCfgCallback * pcccCallback, LCID lcidIn);

    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

    //  IResourceEntry
    STDMETHOD( SetName )( BSTR bstrIn );
    STDMETHOD( GetName )( BSTR * pbstrOut );

    STDMETHOD( SetAssociatedResource )( IClusCfgManagedResourceCfg * pccmrcIn );
    STDMETHOD( GetAssociatedResource )( IClusCfgManagedResourceCfg ** ppccmrcOut );

    STDMETHOD( SetType )( const CLSID * pclsidIn );
    STDMETHOD( GetType )( CLSID * pclsidOut );
    STDMETHOD( GetTypePtr )( const CLSID ** ppclsidOut );

    STDMETHOD( SetClassType )( const CLSID * pclsidIn );
    STDMETHOD( GetClassType )( CLSID * pclsidOut );
    STDMETHOD( GetClassTypePtr )( const CLSID ** ppclsidOut );

    STDMETHOD( SetFlags )( EDependencyFlags dfIn );
    STDMETHOD( GetFlags )( EDependencyFlags * pdfOut );

    STDMETHOD( AddTypeDependency )( const CLSID * pclsidIn, EDependencyFlags dfIn );
    STDMETHOD( GetCountOfTypeDependencies )( ULONG * pcOut );
    STDMETHOD( GetTypeDependency )( ULONG idxIn, CLSID * pclsidOut, EDependencyFlags * dfOut );
    STDMETHOD( GetTypeDependencyPtr )( ULONG idxIn, const CLSID ** ppclsidOut, EDependencyFlags * dfOut );

    STDMETHOD( AddDependent )( ULONG idxIn, EDependencyFlags dfFlagsIn );
    STDMETHOD( GetCountOfDependents )( ULONG * pcOut );
    STDMETHOD( GetDependent )( ULONG idxIn, ULONG * pidxOut, EDependencyFlags * pdfOut );
    STDMETHOD( ClearDependents )( void );

    STDMETHOD( SetGroupHandle )( CGroupHandle * pghIn );
    STDMETHOD( GetGroupHandle )( CGroupHandle ** ppghOut );

    STDMETHOD( SetHResource )( HRESOURCE hResourceIn );
    STDMETHOD( GetHResource )( HRESOURCE * phResourceOut );

    STDMETHOD( SetConfigured )( BOOL fConfiguredIn );
    STDMETHOD( IsConfigured )( void );

    STDMETHOD( StoreClusterResourceControl )( DWORD dwClusCtlIn, CClusPropList & rcplIn );
    STDMETHOD( Configure )( void );

}; // class CResourceEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\resourceentry.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ResourceEntry.h
//
//  Description:
//      ResourceEntry implementation.
//
//  Maintained By:
//      Ozan Ozhan     (OzanO)  10-JUL-2001
//      Galen Barbee   (GalenB) 14-JUN-2001
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "GroupHandle.h"
#include "ResourceEntry.h"

DEFINE_THISCLASS("CResourceEntry")

#define DEPENDENCY_INCREMENT    10

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  CResourceEntry::CResourceEntry( void )
//
//////////////////////////////////////////////////////////////////////////////
CResourceEntry::CResourceEntry( void )
    : m_pcccCallback( NULL )
    , m_lcid( LOCALE_SYSTEM_DEFAULT )
{
    TraceFunc( "" );

    Assert( m_fConfigured == FALSE );

    Assert( m_bstrName == NULL );
    Assert( m_pccmrcResource == NULL );

    Assert( m_clsidType == IID_NULL );
    Assert( m_clsidClassType == IID_NULL );

    Assert( m_dfFlags == dfUNKNOWN );

    Assert( m_cAllocedDependencies == 0 );
    Assert( m_cDependencies == 0 );
    Assert( m_rgDependencies == NULL );

    Assert( m_cAllocedDependents == 0 );
    Assert( m_cDependents == 0 );
    Assert( m_rgDependents == NULL );

    Assert( m_groupHandle == NULL );
    Assert( m_hResource == NULL );

    TraceFuncExit();

} //*** CResourceEntry::CResourceEntry

//////////////////////////////////////////////////////////////////////////////
//
//  CResourceEntry::~CResourceEntry
//
//////////////////////////////////////////////////////////////////////////////
CResourceEntry::~CResourceEntry( void )
{
    TraceFunc( "" );

    // Release the callback interface
    if ( m_pcccCallback != NULL )
    {
        m_pcccCallback->Release();
    } // if: the callback interface pointer is not NULL

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    if ( m_rgDependencies != NULL )
    {
        TraceFree( m_rgDependencies );
    }

    if ( m_rgDependents != NULL )
    {
        THR( ClearDependents() );
    }

    if ( m_groupHandle != NULL )
    {
        m_groupHandle->Release();
    }

    if ( m_hResource != NULL )
    {
        CloseClusterResource( m_hResource );
    }

    TraceFuncExit();

} //*** CResourceEntry::~CResourceEntry

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceEntry::S_HrCreateInstance
//
//  Description:
//      Creates a CResourceEntry instance.
//
//  Arguments:
//      pcrtiResTypeInfoIn
//          Pointer to structure that contains information about this
//          resource type.
//
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceEntry::S_HrCreateInstance(
      CResourceEntry  ** ppcreOut
    , IClusCfgCallback * pcccCallback
    , LCID               lcidIn
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CResourceEntry *    pResEntry = NULL;

    Assert( ppcreOut != NULL );
    if ( ppcreOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pResEntry = new CResourceEntry;
    if ( pResEntry == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pResEntry->HrInit( pcccCallback, lcidIn ) );
    if ( FAILED( hr ) )
    {
        delete pResEntry;
        goto Cleanup;
    }

    *ppcreOut = pResEntry;

Cleanup:


    HRETURN( hr );

} //*** CResourceEntry::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::HrInit(
//      IClusCfgCallback * pcccCallback
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::HrInit(
      IClusCfgCallback * pcccCallback
    , LCID               lcidIn

    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    pcccCallback->AddRef();
    m_pcccCallback = pcccCallback;

    m_lcid = lcidIn;

    HRETURN( hr );

} //*** CResourceEntry::HrInit


//****************************************************************************
//
// STDMETHODIMP
// CResourceEntry::SendStatusReport(
//       LPCWSTR    pcszNodeNameIn
//     , CLSID      clsidTaskMajorIn
//     , CLSID      clsidTaskMinorIn
//     , ULONG      ulMinIn
//     , ULONG      ulMaxIn
//     , ULONG      ulCurrentIn
//     , HRESULT    hrStatusIn
//     , LPCWSTR    pcszDescriptionIn
//     , FILETIME * pftTimeIn
//     , LPCWSTR    pcszReferenceIn
//     )
//
//****************************************************************************

STDMETHODIMP
CResourceEntry::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;
    FILETIME    ft;

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    if ( m_pcccCallback != NULL )
    {
        hr = STHR( m_pcccCallback->SendStatusReport(
                  pcszNodeNameIn
                , clsidTaskMajorIn
                , clsidTaskMinorIn
                , ulMinIn
                , ulMaxIn
                , ulCurrentIn
                , hrStatusIn
                , pcszDescriptionIn
                , pftTimeIn
                , pcszReferenceIn
                ) );
    }

    HRETURN( hr );

} //*** CResourceEntry::SendStatusReport


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetName(
//      BSTR bstrIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetName(
    BSTR bstrIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( bstrIn != NULL );

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    m_bstrName = bstrIn;

    HRETURN( hr );

} //*** CResourceEntry::SetName


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetName(
//      BSTR * pbstrOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetName(
    BSTR * pbstrOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pbstrOut != NULL );

    *pbstrOut = m_bstrName;

    HRETURN( hr );

} //*** CResourceEntry::GetName


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetAssociatedResource(
//      IClusCfgManagedResourceCfg * pccmrcIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetAssociatedResource(
    IClusCfgManagedResourceCfg * pccmrcIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    if ( m_pccmrcResource != NULL )
    {
        m_pccmrcResource->Release();
    }

    m_pccmrcResource = pccmrcIn;
    m_pccmrcResource->AddRef();

    HRETURN( hr );

} //*** CResourceEntry::SetAssociatedResource


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetAssociatedResource(
//      IClusCfgManagedResourceCfg ** ppccmrcOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetAssociatedResource(
    IClusCfgManagedResourceCfg ** ppccmrcOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr;

    if ( m_pccmrcResource != NULL )
    {
        *ppccmrcOut = m_pccmrcResource;
        (*ppccmrcOut)->AddRef();

        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }

    HRETURN( hr );

} //*** CResourceEntry::GetAssociatedResource


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetType(
//      const CLSID * pclsidIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetType(
    const CLSID * pclsidIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    m_clsidType = * pclsidIn;

    HRETURN( hr );

} //*** CResourceEntry::SetType


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetType(
//      CLSID * pclsidOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetType(
    CLSID * pclsidOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    *pclsidOut = m_clsidType;

    HRETURN( hr );

} //*** CResourceEntry::GetType


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetTypePtr(
//      const CLSID ** ppclsidOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetTypePtr(
    const CLSID ** ppclsidOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( ppclsidOut != NULL );

    *ppclsidOut = &m_clsidType;

    HRETURN( hr );

} //*** CResourceEntry:: GetTypePtr


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetClassType(
//      const CLSID * pclsidIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetClassType(
    const CLSID * pclsidIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    m_clsidClassType = *pclsidIn;

    HRETURN( hr );

} //*** CResourceEntry::SetClassType


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetClassType(
//      CLSID * pclsidOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetClassType(
    CLSID * pclsidOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    *pclsidOut = m_clsidClassType;

    HRETURN( hr );

} //*** CResourceEntry::GetClassType


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetClassTypePtr(
//      const CLSID ** ppclsidOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetClassTypePtr(
    const CLSID ** ppclsidOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( ppclsidOut != NULL );

    *ppclsidOut = &m_clsidClassType;

    HRETURN( hr );

} //*** CResourceEntry::GetClassTypePtr


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetFlags(
//      EDependencyFlags dfIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetFlags(
    EDependencyFlags dfIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    m_dfFlags = dfIn;

    HRETURN( hr );

} //*** CResourceEntry::SetFlags


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetFlags(
//      EDependencyFlags * pdfOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetFlags(
    EDependencyFlags * pdfOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pdfOut != NULL );

    *pdfOut = m_dfFlags;

    HRETURN( hr );

} //*** CResourceEntry::GetFlags


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::AddTypeDependency(
//      const CLSID * pclsidIn,
//      EDependencyFlags dfIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::AddTypeDependency(
    const CLSID * pclsidIn,
    EDependencyFlags dfIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    if ( m_cAllocedDependencies == 0 )
    {
        m_rgDependencies = (DependencyEntry *) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(DependencyEntry) * DEPENDENCY_INCREMENT );
        if ( m_rgDependencies == NULL )
            goto OutOfMemory;

        m_cAllocedDependencies = DEPENDENCY_INCREMENT;
        Assert( m_cDependencies == 0 );
    }
    else if ( m_cDependencies == m_cAllocedDependencies )
    {
        DependencyEntry * pdepends;

        pdepends = (DependencyEntry *) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(DependencyEntry) * ( m_cAllocedDependencies + DEPENDENCY_INCREMENT ) );
        if ( pdepends == NULL )
            goto OutOfMemory;

        CopyMemory( pdepends, m_rgDependencies, sizeof(DependencyEntry) * m_cAllocedDependencies );

        TraceFree( m_rgDependencies );

        m_rgDependencies = pdepends;
    }

    m_rgDependencies[ m_cDependencies ].clsidType = *pclsidIn;
    m_rgDependencies[ m_cDependencies ].dfFlags   = (EDependencyFlags) dfIn;

    m_cDependencies++;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CResourceEntry::AddTypeDependency


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetCountOfTypeDependencies(
//      ULONG * pcOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetCountOfTypeDependencies(
    ULONG * pcOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pcOut != NULL );

    *pcOut = m_cDependencies;

    HRETURN( hr );

} //*** CResourceEntry::GetCountOfTypeDependencies


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetTypeDependency(
//      ULONG idxIn,
//      const CLSID * pclsidOut,
//      EDependencyFlags * dfOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetTypeDependency(
    ULONG idxIn,
    CLSID * pclsidOut,
    EDependencyFlags * dfOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pclsidOut != NULL );
    Assert( dfOut != NULL );
    Assert( idxIn < m_cDependencies );

    *pclsidOut = m_rgDependencies[ idxIn ].clsidType;
    *dfOut     = m_rgDependencies[ idxIn ].dfFlags;

    HRETURN( hr );

} //*** CResourceEntry::GetTypeDependency


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetTypeDependencyPtr(
//      ULONG idxIn,
//      const CLSID ** ppclsidOut,
//      EDependencyFlags * dfOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetTypeDependencyPtr(
    ULONG idxIn,
    const CLSID ** ppclsidOut,
    EDependencyFlags * dfOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( ppclsidOut != NULL );
    Assert( dfOut != NULL );
    Assert( idxIn < m_cDependencies );

    *ppclsidOut = &m_rgDependencies[ idxIn ].clsidType;
    *dfOut      =  m_rgDependencies[ idxIn ].dfFlags;

    HRETURN( hr );

} //*** CResourceEntry::GetTypeDependencyPtr


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::AddDependent(
//      ULONG            idxIn,
//      EDependencyFlags dfFlagsIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::AddDependent(
    ULONG            idxIn,
    EDependencyFlags dfFlagsIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    if ( m_cAllocedDependents == 0 )
    {
        m_rgDependents = (DependentEntry *) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(DependentEntry) * DEPENDENCY_INCREMENT );
        if ( m_rgDependents == NULL )
            goto OutOfMemory;

        m_cAllocedDependents = DEPENDENCY_INCREMENT;
        Assert( m_cDependents == 0 );
    } // if: no dependency buffer allocated yet
    else if ( m_cDependents == m_cAllocedDependents )
    {
        DependentEntry * pdepends;

        pdepends = (DependentEntry *) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(DependentEntry) * ( m_cAllocedDependents + DEPENDENCY_INCREMENT ) );
        if ( pdepends == NULL )
            goto OutOfMemory;

        CopyMemory( pdepends, m_rgDependents, sizeof(DependentEntry) * m_cAllocedDependents );

        TraceFree( m_rgDependents );

        m_rgDependents = pdepends;
    } // else if: no space left in the dependency buffer

    m_rgDependents[ m_cDependents ].idxResource = idxIn;
    m_rgDependents[ m_cDependents ].dfFlags     = dfFlagsIn;

    m_cDependents++;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CResourceEntry::AddDependent


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetCountOfDependents(
//      ULONG * pcOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetCountOfDependents(
    ULONG * pcOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pcOut != NULL );

    *pcOut = m_cDependents;

    HRETURN( hr );

} //*** CResourceEntry::GetCountOfDependents


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetDependent(
//      ULONG idxIn,
//      ULONG * pidxOut
//      EDependencyFlags * pdfOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetDependent(
    ULONG idxIn,
    ULONG * pidxOut,
    EDependencyFlags * pdfOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( idxIn < m_cDependents );
    Assert( pidxOut != NULL );
    Assert( pdfOut != NULL );

    *pidxOut = m_rgDependents[ idxIn ].idxResource;
    *pdfOut  = m_rgDependents[ idxIn ].dfFlags;

    HRETURN( hr );

} //*** CResourceEntry::GetDependent

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::ClearDependents( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::ClearDependents( void )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    TraceFree( m_rgDependents );

    m_cAllocedDependents = 0;
    m_cDependents = 0;

    HRETURN( hr );

} //*** CResourceEntry::ClearDependents

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetGroupHandle(
//      HGROUP hGroupIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetGroupHandle(
    CGroupHandle * pghIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pghIn != NULL );

    if ( m_groupHandle != NULL )
    {
        m_groupHandle->Release();
    }

    m_groupHandle = pghIn;
    m_groupHandle->AddRef();

    HRETURN( hr );

} //*** CResourceEntry::SetGroupHandle


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetGroupHandle(
//      CGroupHandle ** pghIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetGroupHandle(
    CGroupHandle ** pghOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pghOut != NULL );

    *pghOut = m_groupHandle;
    if ( *pghOut != NULL )
    {
        (*pghOut)->AddRef();
    }

    HRETURN( hr );

} //*** CResourceEntry::GetGroupHandle


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetHResource(
//      HRESOURCE hResourceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetHResource(
    HRESOURCE hResourceIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    if ( m_hResource != NULL )
    {
        BOOL bRet;
        bRet = CloseClusterResource( m_hResource );
        //  This shouldn't fail - and what would we do if it did?
        Assert( bRet );
    }

    m_hResource = hResourceIn;

    HRETURN( hr );

} //*** CResourceEntry::SetHResource


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetHResource(
//      HRESOURCE * phResourceOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetHResource(
    HRESOURCE * phResourceOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( phResourceOut != NULL );

    *phResourceOut = m_hResource;

    if ( *phResourceOut == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }

    HRETURN( hr );

} //*** CResourceEntry::GetHResource

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetConfigured(
//      BOOL fConfiguredIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetConfigured(
    BOOL fConfiguredIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    m_fConfigured = fConfiguredIn;

    HRETURN( hr );

} //*** CResourceEntry::SetConfigured

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::IsConfigured( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::IsConfigured( void )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr;

    if ( m_fConfigured )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CResourceEntry::IsConfigured

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::StoreClusterResourceControl(
//        DWORD           dwClusCtlIn
//      , CClusPropList & rcplIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::StoreClusterResourceControl(
      DWORD             dwClusCtlIn
    , CClusPropList &   rcplIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;
    DWORD   sc;

    if ( dwClusCtlIn == CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES )
    {
        sc = TW32( m_cplPrivProps.ScAppend( rcplIn ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:
    }
    else if ( dwClusCtlIn == CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES )
    {
        sc = TW32( m_cplCommonProps.ScAppend( rcplIn ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:
    }
    else
    {
        hr = THR( E_INVALIDARG );
    } // else:

Cleanup:

    HRETURN( hr );

} //*** CResourceEntry::StoreClusterResourceControl

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceEntry::Configure
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Other HRESULTs based on return values from ClusterResourceControl.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::Configure( void )
{
    TraceFunc( "[IResourceEntry]" );
    Assert( m_hResource != NULL );

    HRESULT         hr = S_OK;
    DWORD           sc;
    CLUSPROP_LIST * pcpl = NULL;
    size_t          cbcpl;

    //
    //  Set private properties
    //

    if ( m_cplPrivProps.BIsListEmpty() == FALSE )
    {
        pcpl = m_cplPrivProps.Plist();
        Assert( pcpl != NULL );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResourceEntry_Configure_Private
            , IDS_TASKID_MINOR_SETTING_PRIVATE_PROPERTIES
            , hr
            );

        cbcpl = m_cplPrivProps.CbPropList();

        sc = ClusterResourceControl(
                      m_hResource
                    , NULL
                    , CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES
                    , pcpl
                    , static_cast< DWORD >( cbcpl )
                    , NULL
                    , NULL
                    , NULL
                    );
        if ( sc == ERROR_RESOURCE_PROPERTIES_STORED )
        {
            LogMsg( "[PC-ResourceEntry] Private properties set successfully for resource '%ws'.  Status code = ERROR_RESOURCE_PROPERTIES_STORED.", m_bstrName );
            sc = ERROR_SUCCESS;
        }
        else if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
            LogMsg( "[PC-ResourceEntry] ClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES ) failed for resource '%ws'. (sc=%#08x)", m_bstrName, sc );

            STATUS_REPORT_MINOR_POSTCFG1(
                  TASKID_Minor_CResourceEntry_Configure_Private
                , IDS_TASKID_MINOR_ERROR_PRIV_RESCONTROL
                , hr
                , m_bstrName
                );

            goto Cleanup;
        } // else if: error setting private properties
    } // if: there are private properties to set

    //
    //  Set common properties.
    //

    if ( m_cplCommonProps.BIsListEmpty() == FALSE )
    {
        pcpl = m_cplCommonProps.Plist();
        Assert( pcpl != NULL );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResourceEntry_Configure_Common
            , IDS_TASKID_MINOR_SETTING_COMMON_PROPERTIES
            , hr
            );

        cbcpl = m_cplCommonProps.CbPropList();

        sc = ClusterResourceControl(
                      m_hResource
                    , NULL
                    , CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES
                    , pcpl
                    , static_cast< DWORD >( cbcpl )
                    , NULL
                    , NULL
                    , NULL
                    );
        if ( sc == ERROR_RESOURCE_PROPERTIES_STORED )
        {
            LogMsg( "[PC-ResourceEntry] Common properties set successfully for resource '%ws'.  Status code = ERROR_RESOURCE_PROPERTIES_STORED.", m_bstrName );
            sc = ERROR_SUCCESS;
        }
        else if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
            LogMsg( "[PC-ResourceEntry] ClusterResourceControl( CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES ) failed for resource '%ws'. (sc=%#08x)", m_bstrName, sc );

            STATUS_REPORT_MINOR_POSTCFG1(
                  TASKID_Minor_CResourceEntry_Configure_Common
                , IDS_TASKID_MINOR_ERROR_COMMON_RESCONTROL
                , hr
                , m_bstrName
                );

            goto Cleanup;
        } // else if: error setting common properties
    } // if: there are common properties to set

Cleanup:

    HRETURN( hr );

} //*** CResourceEntry::Configure
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\resourcetype.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ResourceType.cpp
//
//  Description:
//      This file contains the implementation of the CResourceType
//      base class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (VVasu)     15-JUN-2000
//      Ozan Ozhan      (OzanO)     10-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "Pch.h"

// The header file for this class
#include "ResourceType.h"

// For g_hInstance
#include "Dll.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CResourceType" );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::S_HrCreateInstance
//
//  Description:
//      Creates a CResourceType instance.
//
//  Arguments:
//      pcrtiResTypeInfoIn
//          Pointer to structure that contains information about this
//          resource type.
//
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::S_HrCreateInstance(
      CResourceType *               pResTypeObjectIn
    , const SResourceTypeInfo *     pcrtiResTypeInfoIn
    , IUnknown **                   ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // Initialize the new object.
    hr = THR( pResTypeObjectIn->HrInit( pcrtiResTypeInfoIn ) );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: the object could not be initialized

    hr = THR( pResTypeObjectIn->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pResTypeObjectIn != NULL )
    {
        pResTypeObjectIn->Release();
    } // if: the pointer to the resource type object is not NULL

    HRETURN( hr );

} //*** CResourceType::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::CResourceType
//
//  Description:
//      Constructor of the CResourceType class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourceType::CResourceType( void )
    : m_cRef( 1 )
    , m_pcccCallback( NULL )
    , m_lcid( LOCALE_SYSTEM_DEFAULT )
    , m_bstrResTypeDisplayName( NULL )
    , m_bstrStatusReportText( NULL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CResourceType::CResourceType


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::~CResourceType
//
//  Description:
//      Destructor of the CResourceType class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourceType::~CResourceType( void )
{
    TraceFunc( "" );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    // Release the callback interface
    if ( m_pcccCallback != NULL )
    {
        m_pcccCallback->Release();
    } // if: the callback interface pointer is not NULL

    //
    // Free any memory allocated by this object.
    //

    TraceSysFreeString( m_bstrResTypeDisplayName );
    TraceSysFreeString( m_bstrStatusReportText );

    TraceFuncExit();

} //*** CResourceType::~CResourceType


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CResourceType::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      rclsidCLSIDIn
//          CLSID of this class.
//
//      picrIn
//          Pointer to an ICatRegister interface to be used for the
//          registration.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::S_RegisterCatIDSupport(
      const GUID &    rclsidCLSIDIn
    , ICatRegister *  picrIn
    , BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
    } // if: the input pointer to the ICatRegister interface is invalid
    else
    {
        CATID   rgCatId[ 1 ];

        rgCatId[ 0 ] = CATID_ClusCfgResourceTypes;

        if ( fCreateIn )
        {
            hr = THR( picrIn->RegisterClassImplCategories( rclsidCLSIDIn, ARRAYSIZE( rgCatId ), rgCatId ) );
        } // if:
    } // else: the input pointer to the ICatRegister interface is valid

    HRETURN( hr );

} //*** CResourceType::S_RegisterCatIDSupport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResourceType::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CResourceType::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResourceType::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count decremented to zero

    CRETURN( cRef );

} //*** CResourceType::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceType::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgResourceTypeInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgResourceTypeInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgResourceTypeInfo, this, 0 );
    } // else if: IClusCfgResourceTypeInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgStartupListener ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgStartupListener, this, 0 );
    } // if: IClusCfgStartupListener
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CResourceType::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      punkCallbackIn
//          Pointer to the IUnknown interface of a component that implements
//          the IClusCfgCallback interface.
//
//      lcidIn
//          Locale id for this component.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceType::Initialize(
      IUnknown *   punkCallbackIn
    , LCID         lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    // Release the callback interface
    if ( m_pcccCallback != NULL )
    {
        m_pcccCallback->Release();
        m_pcccCallback = NULL;
    } // if: the callback interface pointer is not NULL

    if ( punkCallbackIn != NULL )
    {
        // Query for the IClusCfgCallback interface.
        hr = THR( punkCallbackIn->QueryInterface< IClusCfgCallback >( &m_pcccCallback ) );
    } // if: the callback punk is not NULL

    HRETURN( hr );

} //*** CResourceType::Initialize


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::HrInit
//
//  Description:
//      Second phase of a two phase constructor.
//
//  Arguments:
//      pcrtiResTypeInfoIn
//          Pointer to a resource type info structure that contains information
//          about this resource type, like the type name, the dll name, etc.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::HrInit( const SResourceTypeInfo * pcrtiResTypeInfoIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    Assert( m_cRef == 1 );

    //
    // Validate and store the resource type info pointer.
    //
    if ( pcrtiResTypeInfoIn == NULL )
    {
        LogMsg( "[PC] The information about this resource type is invalid (pcrtiResTypeInfoIn == NULL)." );
        hr = THR( E_POINTER );

        STATUS_REPORT_MINOR_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_RESTYPE_INVALID
            , IDS_REF_MINOR_ERROR_RESTYPE_INVALID
            , hr
            );

        goto Cleanup;
    } // if: the resource type info pointer is invalid

    m_pcrtiResTypeInfo = pcrtiResTypeInfoIn;

    // Make sure that all the required data is present
    if (    ( m_pcrtiResTypeInfo->m_pcszResTypeName == NULL )
         || ( m_pcrtiResTypeInfo->m_pcszResDllName == NULL )
         || ( m_pcrtiResTypeInfo->m_pcguidMinorId == NULL )
       )
    {
        LogMsg( "[PC] The information about this resource type is invalid (one or more members of the SResourceTypeInfo structure are invalid)." );
        hr = THR( E_INVALIDARG );

        STATUS_REPORT_MINOR_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_RESTYPE_INVALID
            , IDS_REF_MINOR_ERROR_RESTYPE_INVALID
            , hr
            );

        goto Cleanup;
    } // if: any of the members of m_pcrtiResTypeInfo are invalid

    //
    // Load and store the resource type display name string.
    // Note, the locale id of this string does not depend on the
    // locale id of the user, but on the default locale id of this computer.
    // For example, even if a Japanese administrator is configuring
    // this computer (whose default locale id is English), the resource
    // type display name should be stored in the cluster database in
    // English, not Japanese.
    //
    hr = THR( HrLoadStringIntoBSTR( g_hInstance, pcrtiResTypeInfoIn->m_uiResTypeDisplayNameStringId, &m_bstrResTypeDisplayName ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[PC] Error %#08x occurred trying to get the resource type display name.", hr );

        STATUS_REPORT_MINOR_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_RESTYPE_NAME
            , IDS_REF_MINOR_ERROR_RESTYPE_NAME
            , hr
            );

        goto Cleanup;
    } // if: an error occurred trying to load the resource type display name string


    //
    // Load and format the status message string
    //

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                       IDS_CONFIGURING_RESTYPE,
                                       &m_bstrStatusReportText,
                                       m_bstrResTypeDisplayName
                                       ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[PC] Error %#08x occurred trying to get the status report text.", hr );

        STATUS_REPORT_MINOR_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_RESTYPE_TEXT
            , IDS_REF_MINOR_ERROR_RESTYPE_TEXT
            , hr
            );

        goto Cleanup;
    } // if: an error occurred trying to load the status report format string

Cleanup:

    HRETURN( hr );

} //*** CResourceType::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::CommitChanges
//
//  Description:
//      This method is called to inform a component that this computer has
//      either joined or left a cluster. During this call, a component typically
//      performs operations that are required to configure this resource type.
//
//      If the node has just become part of a cluster, the cluster
//      service is guaranteed to be running when this method is called.
//      Querying the punkClusterInfoIn allows the resource type to get more
//      information about the event that caused this method to be called.
//
//  Arguments:
//      punkClusterInfoIn
//          The resource should QI this interface for services provided
//          by the caller of this function. Typically, the component that
//          this punk refers to also implements the IClusCfgClusterInfo
//          interface.
//
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface of a component that provides
//          methods that help configuring a resource type. For example,
//          during a join or a form, this punk can be queried for the
//          IClusCfgResourceTypeCreate interface, which provides methods
//          for resource type creation.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs.
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::CommitChanges(
      IUnknown * punkClusterInfoIn
    , IUnknown * punkResTypeServicesIn
    )
{
    TraceFunc( "[IClusCfgResourceTypeInfo]" );

    HRESULT                         hr = S_OK;
    IClusCfgClusterInfo *           pClusterInfo = NULL;
    ECommitMode                     ecmCommitChangesMode = cmUNKNOWN;

    LogMsg( "[PC] Configuring resource type '%s'.", m_pcrtiResTypeInfo->m_pcszResTypeName );

    //
    // Validate parameters
    //
    if ( punkClusterInfoIn == NULL )
    {
        LogMsg( "[PC] The information about this resource type is invalid (punkClusterInfoIn == NULL )." );
        hr = THR( E_POINTER );

        STATUS_REPORT_MINOR_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_RESTYPE_INVALID
            , IDS_REF_MINOR_ERROR_RESTYPE_INVALID
            , hr
            );

        goto Cleanup;
    } // if: one of the arguments is NULL


    // Send a status report
    if ( m_pcccCallback != NULL )
    {
        hr = THR(
            m_pcccCallback->SendStatusReport(
                  NULL
                , TASKID_Major_Configure_Resource_Types
                , *m_pcrtiResTypeInfo->m_pcguidMinorId
                , 0
                , 1
                , 0
                , hr
                , m_bstrStatusReportText
                , NULL
                , NULL
                )
            );
    } // if: the callback pointer is not NULL

    if ( FAILED( hr ) )
    {
        LogMsg( "[PC] Error %#08x occurred trying to send a status report.", hr );

        STATUS_REPORT_MINOR_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_RESTYPE_TEXT
            , IDS_REF_MINOR_ERROR_RESTYPE_TEXT
            , hr
            );

        goto Cleanup;
    } // if: we could not send a status report


    // Get a pointer to the IClusCfgClusterInfo interface.
    hr = THR( punkClusterInfoIn->QueryInterface< IClusCfgClusterInfo >( &pClusterInfo ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[PC] Error %#08x occurred trying to get information about the cluster.", hr );

        STATUS_REPORT_MINOR_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_RESTYPE_CLUSINFO
            , IDS_REF_MINOR_ERROR_RESTYPE_CLUSINFO
            , hr
            );

        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgClusterInfo interface


    // Find out what event caused this call.
    hr = STHR( pClusterInfo->GetCommitMode( &ecmCommitChangesMode ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[PC] Error %#08x occurred trying to find out the commit mode.", hr );

        STATUS_REPORT_MINOR_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_COMMIT_MODE
            , IDS_REF_MINOR_ERROR_COMMIT_MODE
            , hr
            );

        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgClusterInfo interface

    // Check what action is required.
    if ( ecmCommitChangesMode == cmCREATE_CLUSTER )
    {
        LogMsg( "[PC] Commit Mode is cmCREATE_CLUSTER."  );

        // Perform the actions required during cluster creation.
        hr = THR( HrProcessCreate( punkResTypeServicesIn ) );
    } // if: a cluster has been created
    else if ( ecmCommitChangesMode == cmADD_NODE_TO_CLUSTER )
    {
        LogMsg( "[PC] Commit Mode is cmADD_NODE_TO_CLUSTER."  );

        // Perform the actions required during node addition.
        hr = THR( HrProcessAddNode( punkResTypeServicesIn ) );
    } // else if: a node has been added to the cluster
    else if ( ecmCommitChangesMode == cmCLEANUP_NODE_AFTER_EVICT )
    {
        LogMsg( "[PC] Commit Mode is cmCLEANUP_NODE_AFTER_EVICT."  );

        // Perform the actions required after node eviction.
        hr = THR( HrProcessCleanup( punkResTypeServicesIn ) );
    } // else if: this node has been removed from the cluster
    else
    {
        // If we are here, then neither create cluster, add node, or cleanup are set.
        // There is nothing that need be done here.

        LogMsg( "[PC] We are neither creating a cluster, adding nodes nor cleanup up after evict. There is nothing to be done (CommitMode = %d).", ecmCommitChangesMode );
    } // else: some other operation has been committed

    // Has something gone wrong?
    if ( FAILED( hr ) )
    {
        LogMsg( "[PC] Error %#08x occurred trying to commit resource type '%s'.", hr, m_pcrtiResTypeInfo->m_pcszResTypeName );

        STATUS_REPORT_MINOR_REF_POSTCFG1(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_COMMIT_RESTYPE
            , IDS_REF_MINOR_ERROR_COMMIT_RESTYPE
            , hr
            , m_pcrtiResTypeInfo->m_pcszResTypeName
            );

        goto Cleanup;
    } // if: an error occurred trying to commit this resource type

Cleanup:

    // Complete the status report
    if ( m_pcccCallback != NULL )
    {
        HRESULT hrTemp = THR(
            m_pcccCallback->SendStatusReport(
                  NULL
                , TASKID_Major_Configure_Resource_Types
                , *m_pcrtiResTypeInfo->m_pcguidMinorId
                , 0
                , 1
                , 1
                , hr
                , m_bstrStatusReportText
                , NULL
                , NULL
                )
            );

        if ( FAILED( hrTemp ) )
        {
            if ( hr == S_OK )
            {
                hr = hrTemp;
            } // if: no error has occurred so far, consider this as an error.

            LogMsg( "[PC] Error %#08x occurred trying to send a status report.", hrTemp );

            STATUS_REPORT_MINOR_REF_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_RESTYPE_TEXT
                , IDS_REF_MINOR_ERROR_RESTYPE_TEXT
                , hrTemp
                );

        } // if: we could not send a status report
    } // if: the callback pointer is not NULL

    //
    // Free allocated resources
    //

    if ( pClusterInfo != NULL )
    {
        pClusterInfo->Release();
    } // if: we got a pointer to the IClusCfgClusterInfo interface

    HRETURN( hr );

} //*** CResourceType::CommitChanges

//****************************************************************************
//
// STDMETHODIMP
// CResourceType::SendStatusReport(
//       LPCWSTR    pcszNodeNameIn
//     , CLSID      clsidTaskMajorIn
//     , CLSID      clsidTaskMinorIn
//     , ULONG      ulMinIn
//     , ULONG      ulMaxIn
//     , ULONG      ulCurrentIn
//     , HRESULT    hrStatusIn
//     , LPCWSTR    pcszDescriptionIn
//     , FILETIME * pftTimeIn
//     , LPCWSTR    pcszReferenceIn
//     )
//
//****************************************************************************

STDMETHODIMP
CResourceType::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;
    FILETIME    ft;

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    if ( m_pcccCallback != NULL )
    {
        hr = STHR( m_pcccCallback->SendStatusReport(
                         pcszNodeNameIn
                       , clsidTaskMajorIn
                       , clsidTaskMinorIn
                       , ulMinIn
                       , ulMaxIn
                       , ulCurrentIn
                       , hrStatusIn
                       , pcszDescriptionIn
                       , pftTimeIn
                       , pcszReferenceIn
                       ) );
    }

    HRETURN( hr );

} //*** CResourceType::SendStatusReport

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::GetTypeName
//
//  Description:
//      Get the resource type name of this resource type.
//
//  Arguments:
//      pbstrTypeNameOut
//          Pointer to the BSTR that holds the name of the resource type.
//          This BSTR has to be freed by the caller using the function
//          SysFreeString().
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::GetTypeName( BSTR * pbstrTypeNameOut )
{
    TraceFunc( "[IClusCfgResourceTypeInfo]" );

    HRESULT     hr = S_OK;

    TraceFlow1( "Getting the type name of resouce type '%s'.", m_pcrtiResTypeInfo->m_pcszResTypeName );

    if ( pbstrTypeNameOut == NULL )
    {
        LogMsg( "[PC] An invalid parameter was specified (output pointer is NULL)." );
        hr = THR( E_INVALIDARG );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResourceType_GetTypeName_InvalidParam
            , IDS_TASKID_MINOR_ERROR_INVALID_PARAM
            , hr
            );

        goto Cleanup;
    } // if: the output pointer is NULL

    *pbstrTypeNameOut = SysAllocString( m_pcrtiResTypeInfo->m_pcszResTypeName );

    if ( *pbstrTypeNameOut == NULL )
    {
        LogMsg( "[PC] An error occurred trying to return the resource type name." );

        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResourceType_GetTypeName_AllocTypeName
            , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
            , hr
            );

        goto Cleanup;
    } // if: the resource type name could not be copied to the outpu

Cleanup:

    HRETURN( hr );

} //*** CResourceType::GetTypeName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::GetTypeGUID
//
//  Description:
//       Get the globally unique identifier of this resource type.
//
//  Arguments:
//       pguidGUIDOut
//           Pointer to the GUID object which will receive the GUID of this
//           resource type.
//
//  Return Values:
//      S_OK
//          The call succeeded and the *pguidGUIDOut contains the type GUID.
//
//      S_FALSE
//          The call succeeded but this resource type does not have a GUID.
//          The value of *pguidGUIDOut is undefined after this call.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::GetTypeGUID( GUID * pguidGUIDOut )
{
    TraceFunc( "[IClusCfgResourceTypeInfo]" );

    HRESULT     hr = S_OK;

    TraceFlow1( "Getting the type GUID of resouce type '%s'.", m_pcrtiResTypeInfo->m_pcszResTypeName );

    if ( pguidGUIDOut == NULL )
    {
        LogMsg( "[PC] An invalid parameter was specified (output pointer is NULL)." );
        hr = THR( E_INVALIDARG );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResourceType_GetTypeGUID_InvalidParam
            , IDS_TASKID_MINOR_ERROR_INVALID_PARAM
            , hr
            );

         goto Cleanup;
    } // if: the output pointer is NULL

    if ( m_pcrtiResTypeInfo->m_pcguidTypeGuid != NULL )
    {
        *pguidGUIDOut = *m_pcrtiResTypeInfo->m_pcguidTypeGuid;
        TraceMsgGUID( mtfALWAYS, "The GUID of this resource type is ", (*m_pcrtiResTypeInfo->m_pcguidTypeGuid) );
    } // if: this resource type has a type GUID
    else
    {
        memset( pguidGUIDOut, 0, sizeof( *pguidGUIDOut ) );
        hr = S_FALSE;
    } // else: this resource type does not have a type GUID

Cleanup:

    HRETURN( hr );

} //*** CResourceType::GetTypeGUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::HrCreateResourceType
//
//  Description:
//       Create the resource type represented by this object.
//
//  Arguments:
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface of a component that provides
//          methods that help configuring a resource type. For example,
//          during a join or a form, this punk can be queried for the
//          IClusCfgResourceTypeCreate interface, which provides methods
//          for resource type creation.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::HrCreateResourceType( IUnknown * punkResTypeServicesIn )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    IClusCfgResourceTypeCreate *    pResTypeCreate = NULL;

    //
    // Validate parameters
    //
    if ( punkResTypeServicesIn == NULL )
    {
        LogMsg( "[PC] The information about this resource type is invalid (punkResTypeServicesIn == NULL)." );
        hr = THR( E_POINTER );

        STATUS_REPORT_MINOR_REF_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_RESTYPE_INVALID
            , IDS_REF_MINOR_ERROR_RESTYPE_INVALID
            , hr
            );

        goto Cleanup;
    } // if: the arguments is NULL

    // Get a pointer to the IClusCfgResourceTypeCreate interface.
    hr = THR( punkResTypeServicesIn->QueryInterface< IClusCfgResourceTypeCreate >( &pResTypeCreate ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[PC] Error %#08x occurred trying to configure the resource type.", hr );

        STATUS_REPORT_MINOR_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_CONFIG_RES_TYPE
            , hr
            );

        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgResourceTypeCreate interface

    // Create the resource type
    hr = THR(
        pResTypeCreate->Create(
              m_pcrtiResTypeInfo->m_pcszResTypeName
            , m_bstrResTypeDisplayName
            , m_pcrtiResTypeInfo->m_pcszResDllName
            , m_pcrtiResTypeInfo->m_dwLooksAliveInterval
            , m_pcrtiResTypeInfo->m_dwIsAliveInterval
            )
        );

    if ( FAILED( hr ) )
    {
        LogMsg( "[PC] Error %#08x occurred trying to create resource type '%s'.", hr, m_pcrtiResTypeInfo->m_pcszResTypeName );

        STATUS_REPORT_MINOR_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_CREATE_RES_TYPE
            , hr
            );

        goto Cleanup;
    } // if: an error occurred trying to create this resource type

    LogMsg( "[PC] Resource type '%s' successfully created.", m_pcrtiResTypeInfo->m_pcszResTypeName  );

    if ( m_pcrtiResTypeInfo->m_cclsidAdminExtCount != 0 )
    {
        hr = THR(
            pResTypeCreate->RegisterAdminExtensions(
                  m_pcrtiResTypeInfo->m_pcszResTypeName
                , m_pcrtiResTypeInfo->m_cclsidAdminExtCount
                , m_pcrtiResTypeInfo->m_rgclisdAdminExts
            )
        );

        if ( FAILED( hr ) )
        {
            // If we could not set the admin extenstions property,
            // we will consider the creation of the resource type
            // to be a success. So, we just log the error and continue.
            LogMsg( "[PC] Error %#08x occurred trying to configure the admin extensions for the resource type '%s'.", hr, m_pcrtiResTypeInfo->m_pcszResTypeName );
            hr = S_OK;
        } // if: RegisterAdminExtension() failed

    } // if: this resource type has admin extensions
    else
    {
        TraceFlow( "This resource type does not have admin extensions." );
    } // else: this resource type does not have admin extensions

Cleanup:

    if ( pResTypeCreate != NULL )
    {
        pResTypeCreate->Release();
    } // if: we got a pointer to the IClusCfgResourceTypeCreate interface

    HRETURN( hr );

} //*** CResourceType::HrCreateResourceType



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::Notify
//
//  Description:
//      This method is called to inform a component that the cluster service
//      has started on this computer.
//
//      This component is registered for the cluster service startup notification
//      as a part of the cluster service upgrade. This method creates the
//      required resource type and deregisters from this notification.
//
//  Arguments:
//      IUnknown * punkIn
//          The component that implements this Punk may also provide services
//          that are useful to the implementor of this method. For example,
//          this component usually implements the IClusCfgResourceTypeCreate
//          interface.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::Notify( IUnknown * punkIn )
{
    TraceFunc( "[IClusCfgStartupListener]" );

    HRESULT                         hr = S_OK;
    ICatRegister *                  pcrCatReg = NULL;
    const SResourceTypeInfo *       pcrtiResourceTypeInfo = PcrtiGetResourceTypeInfoPtr();

    LogMsg( "[PC] Resoure type '%s' received notification of cluster service startup.", pcrtiResourceTypeInfo->m_pcszResTypeName );

    // Create this resource type
    hr = THR( HrCreateResourceType( punkIn ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[PC] Error %#08x occurred trying to create resource type '%s'.", hr, pcrtiResourceTypeInfo->m_pcszResTypeName );

        STATUS_REPORT_MINOR_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_CREATE_RES_TYPE
            , hr
            );

        goto Cleanup;
    } // if: an error occurred trying to create this resource type

    LogMsg( "[PC] Configuration of resoure type '%s' successful. Trying to deregister from startup notifications.", pcrtiResourceTypeInfo->m_pcszResTypeName );

    hr = THR(
        CoCreateInstance(
              CLSID_StdComponentCategoriesMgr
            , NULL
            , CLSCTX_INPROC_SERVER
            , __uuidof( pcrCatReg )
            , reinterpret_cast< void ** >( &pcrCatReg )
            )
        );

    if ( FAILED( hr ) )
    {
        LogMsg( "[PC] Error %#08x occurred trying to deregister this component from any more cluster startup notifications.", hr );

        STATUS_REPORT_MINOR_POSTCFG(
              TASKID_Major_Configure_Resources
            , IDS_TASKID_MINOR_ERROR_UNREG_COMPONENT
            , hr
            );

        goto Cleanup;
    } // if: we could not create the StdComponentCategoriesMgr component

    {
        CATID   rgCatId[ 1 ];

        rgCatId[ 0 ] = CATID_ClusCfgStartupListeners;

        hr = THR( pcrCatReg->UnRegisterClassImplCategories( *( pcrtiResourceTypeInfo->m_pcguidClassId ) , ARRAYSIZE( rgCatId ), rgCatId ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "[PC] Error %#08x occurred trying to deregister this component from any more cluster startup notifications.", hr );

            STATUS_REPORT_MINOR_POSTCFG(
                  TASKID_Major_Configure_Resources
                , IDS_TASKID_MINOR_ERROR_UNREG_COMPONENT
                , hr
                );

            goto Cleanup;
        } // if: we could not deregister this component from startup notifications
    }

    LogMsg( "[PC] Successfully deregistered from startup notifications." );

Cleanup:

    //
    // Free allocated resources
    //

    if ( pcrCatReg != NULL )
    {
        pcrCatReg->Release();
    } // if: we got a pointer to the ICatRegister interface

    HRETURN( hr );

} //*** CResourceType::Notify
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\resourcetype.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResourceType.h
//
//  Description:
//      This file contains the declaration of the CResourceType
//      class. This class handles the configuration of a resource type
//      when the local computer forms or joins a cluster or when it is
//      evicted from a cluster. This class is the base class of other
//      resource type configuration classes.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      CResourceType.cpp
//
//  Maintained By:
//      Vij Vasu (VVasu) 14-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For the GUID structure
#include <guiddef.h>

// For IClusCfgResourceTypeInfo and IClusCfgInitialize
#include "ClusCfgServer.h"


//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

// A structure that holds information required to create a resource type.
struct SResourceTypeInfo
{
    const GUID *      m_pcguidClassId;                      // Class id of this component
    const WCHAR *     m_pcszResTypeName;                    // Pointer to the resource type name
    UINT              m_uiResTypeDisplayNameStringId;       // String id of the resource type display name
    const WCHAR *     m_pcszResDllName;                     // Pointer to the name or full path to the resource type DLL
    DWORD             m_dwLooksAliveInterval;               // The looks-alive poll interval
    DWORD             m_dwIsAliveInterval;                  // The is-alive poll interval
    const CLSID *     m_rgclisdAdminExts;                   // Pointer to an array of cluster admin extension class ids
    UINT              m_cclsidAdminExtCount;                // Number of elements in the above array
    const GUID *      m_pcguidTypeGuid;                     // The resource type GUID. This can be NULL.
    const GUID *      m_pcguidMinorId;                      // The minor id of the status report sent by this resource type
}; //*** SResourceTypeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResourceType
//
//  Description:
//      This class handles the configuration of a resource type
//      when the local computer forms or joins a cluster or when it is
//      evicted from a cluster. This class is the base class of other
//      resource type configuration classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CResourceType
    : public IClusCfgResourceTypeInfo
    , public IClusCfgStartupListener
    , public IClusCfgInitialize
{
public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgResourceTypeInfo methods
    //////////////////////////////////////////////////////////////////////////

    // Indicate that the resource type configuration needs to be performed.
    STDMETHOD( CommitChanges )(
          IUnknown * punkClusterInfoIn
        , IUnknown * punkResTypeServicesIn
        );

    // Get the resource type name of this resource type.
    STDMETHOD( GetTypeName )(
        BSTR *  pbstrTypeNameOut
        );

    // Get the globally unique identifier of this resource type.
    STDMETHOD( GetTypeGUID )(
        GUID * pguidGUIDOut
        );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgStartupListener methods
    //////////////////////////////////////////////////////////////////////////

    // Do the tasks that need to be done when the cluster service starts on this
    // computer.
    STDMETHOD( Notify )(
          IUnknown * punkIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgInitialize methods
    //////////////////////////////////////////////////////////////////////////

    // Initialize this object.
    STDMETHOD( Initialize )(
          IUnknown *   punkCallbackIn
        , LCID         lcidIn
        );

    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

protected:
    //////////////////////////////////////////////////////////////////////////
    //  Protected static functions
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance(
          CResourceType *               pResTypeObjectIn
        , const SResourceTypeInfo *     pcrtiResTypeInfoIn
        , IUnknown **                   ppunkOut
        );

    // Registers this class with the categories that it belongs to.
    static HRESULT S_RegisterCatIDSupport( 
          const GUID &      rclsidCLSIDIn
        , ICatRegister *    picrIn
        , BOOL              fCreateIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  Protected virtual functions
    //////////////////////////////////////////////////////////////////////////

    // The tasks that need to be performed after cluster creation are done here.
    // This method can be overridden by derived classes to change the behavior during
    // commit. In this class, the resource type is created during commit.
    virtual HRESULT HrProcessCreate( IUnknown * punkResTypeServicesIn )
    {
        return HrCreateResourceType( punkResTypeServicesIn );
    }

    // The tasks that need to be performed after node addition are done here.
    // This method can be overridden by derived classes to change the behavior during
    // commit. In this class, the resource type is created during commit.
    virtual HRESULT HrProcessAddNode( IUnknown * punkResTypeServicesIn )
    {
        return HrCreateResourceType( punkResTypeServicesIn );
    }

    // The tasks that need to be performed after node eviction are done here.
    // This method can be overridden by derived classes to change the behavior during
    // commit. In this class, nothing is done by this function.
    virtual HRESULT HrProcessCleanup( IUnknown * punkResTypeServicesIn )
    {
        // As of now, then there is nothing that need be done here.
        // If needed, code for evict processing may be added here in the future.
        return S_OK;
    }

    // This function creates the resource type represented by this object.
    virtual HRESULT HrCreateResourceType( IUnknown * punkResTypeServicesIn );


    //////////////////////////////////////////////////////////////////////////
    //  Protected accessor functions
    //////////////////////////////////////////////////////////////////////////
    
    // Get the pointer to the resource type info structure
    const SResourceTypeInfo * PcrtiGetResourceTypeInfoPtr( void )
    {
        return m_pcrtiResTypeInfo;
    } //*** RtiGetResourceTypeInfo()

    // Get the resource type display name
    const WCHAR * PcszGetTypeDisplayName( void )
    {
        return m_bstrResTypeDisplayName;
    } //*** PcszGetTypeDisplayName()


    //
    // Protected constructors, destructor and assignment operator.
    // All of these methods are protected for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CResourceType( void );

    // Destructor.
    virtual ~CResourceType( void );

    // Copy constructor.
    CResourceType( const CResourceType & );

    // Assignment operator.
    CResourceType & operator =( const CResourceType & );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Second phase of a two phase constructor.
    HRESULT HrInit(
        const SResourceTypeInfo *     pcrtiResTypeInfoIn
        );

    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG                        m_cRef;

    // Pointer to the callback interface.
    IClusCfgCallback *          m_pcccCallback;

    // The locale id
    LCID                        m_lcid;

    // The display name of this resource type.
    BSTR                        m_bstrResTypeDisplayName;

    // The text sent with the status report sent by this resource type
    BSTR                        m_bstrStatusReportText;

    // Pointer to structure that contains information about this resource type.
    const SResourceTypeInfo *   m_pcrtiResTypeInfo;

}; //*** class CResourceType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\test\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CITrackerSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\test\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\test\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InterfaceTableSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\test\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\restypegenscript.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ResTypeGenScript.cpp
//
//  Description:
//      This file contains the implementation of the CResTypeGenScript
//      class.
//
//  Maintained By:
//      Galen Barbee (Galen) 15-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "Pch.h"

// The header file for this class
#include "ResTypeGenScript.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CResTypeGenScript" );


//////////////////////////////////////////////////////////////////////////////
// Global Variable Definitions
//////////////////////////////////////////////////////////////////////////////

// Clsid of the admin extension for the generic script resource type
DEFINE_GUID( CLSID_CoCluAdmEx, 0x4EC90FB0, 0xD0BB, 0x11CF, 0xB5, 0xEF, 0x00, 0xA0, 0xC9, 0x0A, 0xB5, 0x05 );


//////////////////////////////////////////////////////////////////////////////
// Class Variable Definitions
//////////////////////////////////////////////////////////////////////////////

// Structure containing information about this resource type.
const SResourceTypeInfo CResTypeGenScript::ms_rtiResTypeInfo =
{
      &CLSID_ClusCfgResTypeGenScript
    , CLUS_RESTYPE_NAME_GENSCRIPT
    , IDS_GENSCRIPT_DISPLAY_NAME
    , L"clusres.dll"
    , 5000
    , 60000
    , &CLSID_CoCluAdmEx
    , 1
    , &RESTYPE_GenericScript
    , &TASKID_Minor_Configuring_Generic_Script_Resource_Type
};


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGenScript::S_HrCreateInstance
//
//  Description:
//      Creates a CResTypeGenScript instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeGenScript::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CResTypeGenScript *     prtgs = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    // Allocate memory for the new object.
    prtgs = new CResTypeGenScript();
    if ( prtgs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: out of memory

    hr = THR( BaseClass::S_HrCreateInstance( prtgs, &ms_rtiResTypeInfo, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    prtgs = NULL;

Cleanup:

    delete prtgs;

    HRETURN( hr );

} //*** CResTypeGenScript::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGenScript::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      picrIn
//          Pointer to an ICatRegister interface to be used for the
//          registration.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeGenScript::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr =  THR(
        BaseClass::S_RegisterCatIDSupport(
              *( ms_rtiResTypeInfo.m_pcguidClassId )
            , picrIn
            , fCreateIn
            )
        );

    HRETURN( hr );

} //*** CResTypeGenScript::S_RegisterCatIDSupport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\restypegenscript.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResTypeGenScript.h
//
//  Description:
//      This file contains the declaration of the CResTypeGenScript
//      class. This class handles the configuration of the generic script
//      resource type when the local computer forms or joins a cluster
//      or when it is evicted from a cluster.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      CResTypeGenScript.cpp
//
//  Maintained By:
//      Vij Vasu (VVasu) 14-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class of this class
#include "ResourceType.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResTypeGenScript
//
//  Description:
//      This class handles the configuration of the generic script resource type
//      when the local computer forms or joins a cluster or when it is
//      evicted from a cluster. Almost all the functionality of this class is
//      provided by the base class - all this class does is provide the right 
//      data to the base class.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CResTypeGenScript
    : public CResourceType
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Public class methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // Registers this class with the categories that it belongs to.
    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructor and destructor
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CResTypeGenScript( void ) {}

    // Destructor.
    virtual ~CResTypeGenScript( void ) {}


private:

    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CResourceType  BaseClass;

    //////////////////////////////////////////////////////////////////////////
    // Private class variables
    //////////////////////////////////////////////////////////////////////////

    // Information about this resource type
    static const SResourceTypeInfo   ms_rtiResTypeInfo;

}; //*** class CResTypeGenScript
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\restypeservices.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ResTypeServices.h
//
//  Description:
//      This file contains the declaration of the CResTypeServices
//      class. This class provides functions that help components that
//      want to create resource types at the time of cluster configuration.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      CResTypeServices.cpp
//
//  Maintained By:
//      Vij Vasu (VVasu) 14-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For the cluster API functions and types
#include <ClusApi.h>

// For IClusCfgResourceTypeCreate
#include "ClusCfgServer.h"

// For IClusCfgResTypeServicesInitialize
#include "ClusCfgPrivate.h"



//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResTypeServices
//
//  Description:
//      This class provides functions that help components that want to
//      configure resource types at the time of cluster configuration.
//--
//////////////////////////////////////////////////////////////////////////////
class CResTypeServices
    : public IClusCfgResourceTypeCreate
    , public IClusCfgResTypeServicesInitialize
    , public IClusCfgInitialize
{
public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgResourceTypeCreate methods
    //////////////////////////////////////////////////////////////////////////

    // Create a resource type
    STDMETHOD( Create )(
          const WCHAR *     pcszResTypeNameIn
        , const WCHAR *     pcszResTypeDisplayNameIn
        , const WCHAR *     pcszResDllNameIn
        , DWORD             dwLooksAliveIntervalIn
        , DWORD             dwIsAliveIntervalIn
        );

    // Register the cluster administrator extensions for a resource type.
    STDMETHOD( RegisterAdminExtensions )(
          const WCHAR *       pcszResTypeNameIn
        , ULONG               cExtClsidCountIn
        , const CLSID *       rgclsidExtClsidsIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgResTypeServicesInitialize methods
    //////////////////////////////////////////////////////////////////////////

    // Create a resource type
    STDMETHOD( SetParameters )( IClusCfgClusterInfo * pccciIn );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgInitialize methods
    //////////////////////////////////////////////////////////////////////////

    // Initialize this object.
    STDMETHOD( Initialize )(
          IUnknown *   punkCallbackIn
        , LCID         lcidIn
        );

    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

    //////////////////////////////////////////////////////////////////////////
    //  Other member functions
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    //
    // Private constructors, destructor and assignment operator.
    // All of these methods are private for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CResTypeServices( void );

    // Destructor.
    ~CResTypeServices( void );

    // Private copy constructor to prevent copying.
    CResTypeServices( const CResTypeServices & );

    // Private assignment operator to prevent copying.
    CResTypeServices & operator =( const CResTypeServices & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG                        m_cRef;

    // Pointer to the callback interface.
    IClusCfgCallback *          m_pcccCallback;

    // The locale id
    LCID                        m_lcid;

    // Pointer to the interface that provides information about the cluster
    // being configured.
    IClusCfgClusterInfo *       m_pccciClusterInfo;

    // Handle to cluster being configured.
    HCLUSTER                    m_hCluster;

    // Have we tried to open the handle to the cluster?
    bool                        m_fOpenClusterAttempted;

    // Synchronize access to this instance.
    CCriticalSection            m_csInstanceGuard;

}; //*** class CResTypeServices
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\restypemajoritynodeset.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ResTypeMajorityNodeSet.cpp
//
//  Description:
//      This file contains the implementation of the CResTypeMajorityNodeSet
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      CResTypeMajorityNodeSet.h
//
//  Maintained By:
//      Galen Barbee (Galen) 15-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "pch.h"

// For CLUS_RESTYPE_NAME_MAJORITYNODESET
#include <clusudef.h>

// For NetShareDel()
#include <lmshare.h>

// The header file for this class
#include "ResTypeMajorityNodeSet.h"

// For DwRemoveDirectory()
#include "Common.h"

// For the smart resource handle and pointer templates
#include "SmartClasses.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CResTypeMajorityNodeSet" );

#define MAJORITY_NODE_SET_DIR_WILDCARD L"\\" MAJORITY_NODE_SET_DIRECTORY_PREFIX L"*"


//////////////////////////////////////////////////////////////////////////////
// Global Variable Definitions
//////////////////////////////////////////////////////////////////////////////

// Clsid of the admin extension for the majority node set resource type
DEFINE_GUID( CLSID_CoCluAdmEx, 0x4EC90FB0, 0xD0BB, 0x11CF, 0xB5, 0xEF, 0x00, 0xA0, 0xC9, 0x0A, 0xB5, 0x05 );


//////////////////////////////////////////////////////////////////////////////
// Class Variable Definitions
//////////////////////////////////////////////////////////////////////////////

// Structure containing information about this resource type.
const SResourceTypeInfo CResTypeMajorityNodeSet::ms_rtiResTypeInfo =
{
      &CLSID_ClusCfgResTypeMajorityNodeSet
    , CLUS_RESTYPE_NAME_MAJORITYNODESET
    , IDS_MAJORITYNODESET_DISPLAY_NAME
    , L"clusres.dll"
    , 5000
    , 60000
    , NULL
    , 0
    , &RESTYPE_MajorityNodeSet
    , &TASKID_Minor_Configuring_Majority_Node_Set_Resource_Type
};


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeMajorityNodeSet::S_HrCreateInstance
//
//  Description:
//      Creates a CResTypeMajorityNodeSet instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeMajorityNodeSet::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    CResTypeMajorityNodeSet *   prtmns = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    // Allocate memory for the new object.
    prtmns = new CResTypeMajorityNodeSet();
    if ( prtmns == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: out of memory

    hr = THR( BaseClass::S_HrCreateInstance( prtmns, &ms_rtiResTypeInfo, ppunkOut ) );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    }

    prtmns = NULL;

Cleanup:

    delete prtmns;

    HRETURN( hr );

} //*** CResTypeMajorityNodeSet::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeMajorityNodeSet::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      picrIn
//          Pointer to an ICatRegister interface to be used for the
//          registration.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeMajorityNodeSet::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr =  THR(
        BaseClass::S_RegisterCatIDSupport(
              *( ms_rtiResTypeInfo.m_pcguidClassId )
            , picrIn
            , fCreateIn
            )
        );

    HRETURN( hr );

} //*** CResTypeMajorityNodeSet::S_RegisterCatIDSupport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeMajorityNodeSet::HrProcessCleanup
//
//  Description:
//      Cleans up the shares created by majority node set resource types on this node
//      during node eviction.
//
//  Arguments:
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface of a component that provides
//          methods that help configuring a resource type. For example,
//          during a join or a form, this punk can be queried for the
//          IClusCfgResourceTypeCreate interface, which provides methods
//          for resource type creation.
//
//  Return Values:
//      S_OK
//          Success
//
//      other HRESULTs
//          Cleanup failed
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeMajorityNodeSet::HrProcessCleanup( IUnknown * punkResTypeServicesIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    typedef CSmartResource<
        CHandleTrait<
              HANDLE
            , BOOL
            , FindClose
            , INVALID_HANDLE_VALUE
            >
        > SmartFindFileHandle;

    typedef CSmartResource< CHandleTrait< HKEY, LONG, RegCloseKey, NULL > > SmartRegistryKey;

    typedef CSmartGenericPtr< CPtrTrait< WCHAR > > SmartSz;

    WIN32_FIND_DATA     wfdCurFile;
    SmartRegistryKey    srkNodeDataKey;
    LPWSTR              pszMNSDirsWildcard = NULL;
    DWORD               cbBufferSize    = 0;
    size_t              cchBufferSize   = 0;
    DWORD               dwType          = REG_SZ;
    DWORD               sc              = ERROR_SUCCESS;
    size_t              cchClusterDirNameLen = 0;

    {
        HKEY hTempKey = NULL;

        // Open the node data registry key
        sc = TW32( RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE
                    , CLUSREG_KEYNAME_NODE_DATA
                    , 0
                    , KEY_READ
                    , &hTempKey
                    )
                );

        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( "[PC] Error %#08x occurred trying open the registry key where the cluster install path is stored.", hr );

            STATUS_REPORT_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_OpenRegistry
                , IDS_TASKID_MINOR_ERROR_OPEN_REGISTRY
                , hr
                );

            goto Cleanup;
        } // if: RegOpenKeyEx() failed

        // Store the opened key in a smart pointer for automatic close.
        srkNodeDataKey.Assign( hTempKey );
    }

    // Get the required size of the buffer.
    sc = TW32(
        RegQueryValueExW(
              srkNodeDataKey.HHandle()          // handle to key to query
            , CLUSREG_INSTALL_DIR_VALUE_NAME    // name of value to query
            , 0                                 // reserved
            , NULL                              // address of buffer for value type
            , NULL                              // address of data buffer
            , &cbBufferSize                     // address of data buffer size
            )
        );

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32 ( sc );
        LogMsg( "[PC] Error %#08x occurred trying to read the registry value '%s'.", hr, CLUSREG_INSTALL_DIR_VALUE_NAME );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_ReadRegistry
            , IDS_TASKID_MINOR_ERROR_READ_REGISTRY
            , hr
            );

        goto Cleanup;
    } // if: an error occurred trying to read the CLUSREG_INSTALL_DIR_VALUE_NAME registry value

    // Account for the L"\\MNS.*".  Add an extra character for double-termination (paranoid about MULTI_SZ).
    cbBufferSize += sizeof( MAJORITY_NODE_SET_DIR_WILDCARD ) + sizeof( WCHAR );
    cchBufferSize = cbBufferSize / sizeof( WCHAR );

    // Allocate the required buffer.
    pszMNSDirsWildcard = new WCHAR[ cchBufferSize ];
    if ( pszMNSDirsWildcard == NULL )
    {
        LogMsg( "[PC] An error occurred trying to allocate %d bytes of memory.", cbBufferSize );
        hr = HRESULT_FROM_WIN32 ( TW32( ERROR_NOT_ENOUGH_MEMORY ) );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_AllocateMem
            , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
            , hr
            );

        goto Cleanup;
    } // if: a memory allocation failure occurred

    // Read the value.
    sc = TW32( RegQueryValueExW(
                  srkNodeDataKey.HHandle()                              // handle to key to query
                , CLUSREG_INSTALL_DIR_VALUE_NAME                        // name of value to query
                , 0                                                     // reserved
                , &dwType                                               // address of buffer for value type
                , reinterpret_cast< LPBYTE >( pszMNSDirsWildcard )      // address of data buffer
                , &cbBufferSize                                         // address of data buffer size
                )
            );

    // Make sure the value is double terminated - ReqQueryValueEx doesn't terminate
    // it if the data wasn't set with a null.  Double terminate because of MULTI_SZ (paranoid).
    pszMNSDirsWildcard[ cchBufferSize - 2 ] = L'\0';
    pszMNSDirsWildcard[ cchBufferSize - 1 ] = L'\0';

    // Was the key read properly?
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32 ( sc );
        LogMsg( "[PC] Error %#08x occurred trying to read the registry value '%s'.", hr, CLUSREG_INSTALL_DIR_VALUE_NAME );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_ReadRegistry2
            , IDS_TASKID_MINOR_ERROR_READ_REGISTRY
            , hr
            );

        goto Cleanup;
    } // if: RegQueryValueExW failed.

    // Store the length of the cluster install directory name for later use.
    // We're not using strsafe here because we made sure the string was terminated above.
    cchClusterDirNameLen = (DWORD) wcslen( pszMNSDirsWildcard );

    // Append "\\MNS.*" to the cluster directory name to get the wildcard for the majority node set directories.
    hr = STHR( StringCchCatW(
                  pszMNSDirsWildcard
                , cchBufferSize
                , MAJORITY_NODE_SET_DIR_WILDCARD
                ) );

    TraceFlow1( "The wildcard for the majority node set directories is '%s'.\n", pszMNSDirsWildcard );

    {
        SmartFindFileHandle sffhFindFileHandle( FindFirstFile( pszMNSDirsWildcard, &wfdCurFile ) );
        if ( sffhFindFileHandle.FIsInvalid() )
        {
            sc = GetLastError();
            if ( sc == ERROR_FILE_NOT_FOUND )
            {
                HRESULT hrTemp = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, HRESULT_CODE( sc ) );

                LogMsg( "[PC] No files or directories match the search criterion '%ws'.", pszMNSDirsWildcard );

                STATUS_REPORT_POSTCFG(
                      TASKID_Major_Configure_Resources
                    , TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_MatchCriterion
                    , IDS_TASKID_MINOR_ERROR_MATCH_CRITERION
                    , hrTemp
                    );

                hr = S_OK;
                goto Cleanup;
            }
            else
            {
                TW32( sc );
                hr = HRESULT_FROM_WIN32( sc );

                LogMsg( "[PC] Error %#08x. Find first file failed for '%ws'.", hr, pszMNSDirsWildcard );

                STATUS_REPORT_POSTCFG(
                      TASKID_Major_Configure_Resources
                    , TASKID_Minor_CResTypeMajorityNodeSet_HrProcessCleanup_FindFile
                    , IDS_TASKID_MINOR_ERROR_FIND_FILE
                    , hr
                    );

                goto Cleanup;
            } // else: something else went wrong
        } // if: FindFirstFile failed.

        // We no longer need to have the wildcard string at the end of the cluster install directory.
        // So, remove it and reuse this buffer that contains the cluster install directory.
        pszMNSDirsWildcard[ cchClusterDirNameLen ] = L'\0';

        do
        {
            // If the current file is a directory, delete it.
            if ( ( wfdCurFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
            {
                LPWSTR   pszDirName = NULL;

                TraceFlow1( "Trying to delete Majority Node Set directory '%s'.", wfdCurFile.cFileName );

                //
                // First, stop sharing this directory out.
                //

                // Get a pointer to just the directory name - this is the same as the share name.
                pszDirName =   wfdCurFile.cFileName + ARRAYSIZE( MAJORITY_NODE_SET_DIRECTORY_PREFIX ) - 1;

                sc = NetShareDel( NULL, pszDirName, 0 );
                if ( sc != ERROR_SUCCESS )
                {
                    TW32( sc );

                    LogMsg( "[PC] Error %#08x occurred trying to delete the share '%s'. This is not a fatal error.", sc, pszDirName );

                    // Mask this error and continue with the next directory
                    sc = ERROR_SUCCESS;

                } // if: we could not delete this share
                else
                {
                    LPWSTR  pszMNSDir = NULL;
                    size_t  cchMNSDirPathLen = 0;

                    // Length of directory name, filenme, a backslash to separate them, and a NULL.
                    cchMNSDirPathLen = cchClusterDirNameLen + wcslen( wfdCurFile.cFileName ) + 2;

                    //
                    // Get the full path of the directory.
                    //

                    pszMNSDir = new WCHAR[ cchMNSDirPathLen ];
                    if ( pszMNSDir == NULL )
                    {
                        hr = HRESULT_FROM_WIN32 ( TW32( ERROR_NOT_ENOUGH_MEMORY ) );
                        LogMsg( "[PC] An error occurred trying to allocate memory for %d characters.", cchMNSDirPathLen );

                        STATUS_REPORT_MINOR_POSTCFG(
                              TASKID_Major_Configure_Resources
                            , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
                            , hr
                            );

                        break;
                    } // if: a memory allocation failure occurred

                    // cchMNSDirPathLen is guaranteed to be larger than cchClusterDirNameLen
                    // This is guaranteed to work.
                    hr = THR( StringCchCopyNW( pszMNSDir, cchMNSDirPathLen, pszMNSDirsWildcard, cchClusterDirNameLen ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:

                    // Append the slash to separate the path and filename.
                    hr = THR( StringCchCatW( pszMNSDir, cchMNSDirPathLen, L"\\" ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:

                    // This is also guaranteed to work - pszMNSDir was calculated based on the lengths of these strings.
                    hr = THR( StringCchCatW( pszMNSDir, cchMNSDirPathLen, wfdCurFile.cFileName ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:

                    // Now delete the directory
                    sc = DwRemoveDirectory( pszMNSDir );
                    if ( sc != ERROR_SUCCESS )
                    {
                        TW32( sc );

                        LogMsg( "[PC] Error %#08x occurred trying to delete the dirctory '%s'. This is not a fatal error.", sc, pszMNSDir );

                        // Mask this error and continue with the next directory
                        sc = ERROR_SUCCESS;

                    } // if: we could not delete this share
                    else
                    {
                        LogMsg( "[PC] Successfully deleted directory '%s'.", pszMNSDir );
                    } // else: success!

                    // Cleanup local variables.
                    delete [] pszMNSDir;
                    pszMNSDir = NULL;

                } // else: we have deleted this share

            } // if: the current file is a directory

            if ( FindNextFile( sffhFindFileHandle.HHandle(), &wfdCurFile ) == FALSE )
            {
                sc = GetLastError();
                if ( sc == ERROR_NO_MORE_FILES )
                {
                    // We have deleted all the files in this directory.
                    sc = ERROR_SUCCESS;
                }
                else
                {
                    LogMsg( "[PC] Error %#08x. Find next file failed for '%ws'.", sc, wfdCurFile.cFileName );
                    TW32( sc );
                    hr = HRESULT_FROM_WIN32( sc );
                }

                // If FindNextFile has failed, we are done.
                break;
            } // if: FindNextFile fails.
        }
        while( true ); // loop infinitely.
    }

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc  );
        goto Cleanup;
    } // if: something has gone wrong up there

    // If what we wanted to do in this function was successful, call the base class function.
    hr = THR( BaseClass::HrProcessCleanup( punkResTypeServicesIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    delete [] pszMNSDirsWildcard;

    HRETURN( hr );

} //*** CResTypeMajorityNodeSet::HrProcessCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\restypemajoritynodeset.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResTypeMajorityNodeSet.h
//
//  Description:
//      This file contains the declaration of the CResTypeMajorityNodeSet
//      class. This class handles the configuration of the majority node set
//      resource type when the local computer forms or joins a cluster
//      or when it is evicted from a cluster.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      CResTypeMajorityNodeSet.cpp
//
//  Maintained By:
//      Vij Vasu (VVasu) 14-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class of this class
#include "ResourceType.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResTypeMajorityNodeSet
//
//  Description:
//      This class handles the configuration of the majority node set resource type
//      when the local computer forms or joins a cluster or when it is
//      evicted from a cluster. Almost all the functionality of this class is
//      provided by the base class - all this class does is provide the right 
//      data to the base class.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CResTypeMajorityNodeSet
    : public CResourceType
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Public class methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // Registers this class with the categories that it belongs to.
    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructor and destructor
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CResTypeMajorityNodeSet( void ) {}

    // Destructor.
    virtual ~CResTypeMajorityNodeSet( void ) {}


    //////////////////////////////////////////////////////////////////////////
    //  Protected virtual functions
    //////////////////////////////////////////////////////////////////////////

    // The tasks that need to be performed after node eviction are done here.
    HRESULT HrProcessCleanup( IUnknown * punkResTypeServicesIn );

private:

    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CResourceType  BaseClass;

    //////////////////////////////////////////////////////////////////////////
    // Private class variables
    //////////////////////////////////////////////////////////////////////////

    // Information about this resource type
    static const SResourceTypeInfo   ms_rtiResTypeInfo;

}; //*** class CResTypeMajorityNodeSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\restypeservices.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ResTypeServices.cpp
//
//  Description:
//      This file contains the implementation of the CResTypeServices
//      class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (VVasu)     15-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "Pch.h"

// For UuidToString() and other functions
#include <RpcDce.h>

// The header file for this class
#include "ResTypeServices.h"

//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CResTypeServices" );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::S_HrCreateInstance(
//
//  Description:
//      Creates a CResTypeServices instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeServices::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = E_INVALIDARG;
    CResTypeServices *  prts = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    *ppunkOut = NULL;

    // Allocate memory for the new object.
    prts = new CResTypeServices();
    if ( prts == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: out of memory

    hr = THR( prts->m_csInstanceGuard.HrInitialized() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( prts->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( prts != NULL )
    {
        prts->Release();
    } // if: the pointer to the resource type object is not NULL

    HRETURN( hr );

} //*** CResTypeServices::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::CResTypeServices
//
//  Description:
//      Constructor of the CResTypeServices class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResTypeServices::CResTypeServices( void )
    : m_cRef( 1 )
    , m_pcccCallback( NULL )
    , m_lcid( LOCALE_SYSTEM_DEFAULT )
    , m_pccciClusterInfo( NULL )
    , m_hCluster( NULL )
    , m_fOpenClusterAttempted( false )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CResTypeServices::CResTypeServices


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::~CResTypeServices
//
//  Description:
//      Destructor of the CResTypeServices class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResTypeServices::~CResTypeServices( void )
{
    TraceFunc( "" );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    // Release the callback interface
    if ( m_pcccCallback != NULL )
    {
        m_pcccCallback->Release();
    } // if: the callback interface pointer is not NULL

    // Release the cluster info interface
    if ( m_pccciClusterInfo != NULL )
    {
        m_pccciClusterInfo->Release();
    } // if: the cluster info interface pointer is not NULL

    if ( m_hCluster != NULL )
    {
        CloseCluster( m_hCluster );
    } // if: we had opened a handle to the cluster

    TraceFuncExit();

} //*** CResTypeServices::~CResTypeServices


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      punkCallbackIn
//          Pointer to the IUnknown interface of a component that implements
//          the IClusCfgCallback interface.
//
//      lcidIn
//          Locale id for this component.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResTypeServices::Initialize(
      IUnknown *   punkCallbackIn
    , LCID         lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );

    HRESULT hr = S_OK;

    m_csInstanceGuard.Enter();
    m_lcid = lcidIn;

    Assert( punkCallbackIn != NULL );

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    // Query for the IClusCfgCallback interface.
    hr = THR( punkCallbackIn->QueryInterface< IClusCfgCallback >( &m_pcccCallback ) );

Cleanup:

    m_csInstanceGuard.Leave();
    HRETURN( hr );

} //*** CResTypeServices::Initialize


//****************************************************************************
//
// STDMETHODIMP
// CResTypeServices::SendStatusReport(
//       LPCWSTR    pcszNodeNameIn
//     , CLSID      clsidTaskMajorIn
//     , CLSID      clsidTaskMinorIn
//     , ULONG      ulMinIn
//     , ULONG      ulMaxIn
//     , ULONG      ulCurrentIn
//     , HRESULT    hrStatusIn
//     , LPCWSTR    pcszDescriptionIn
//     , FILETIME * pftTimeIn
//     , LPCWSTR    pcszReferenceIn
//     )
//
//****************************************************************************

STDMETHODIMP
CResTypeServices::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;
    FILETIME    ft;

    m_csInstanceGuard.Enter();

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    if ( m_pcccCallback != NULL )
    {
        hr = STHR( m_pcccCallback->SendStatusReport(
                         pcszNodeNameIn
                       , clsidTaskMajorIn
                       , clsidTaskMinorIn
                       , ulMinIn
                       , ulMaxIn
                       , ulCurrentIn
                       , hrStatusIn
                       , pcszDescriptionIn
                       , pftTimeIn
                       , pcszReferenceIn
                       ) );
    }

    m_csInstanceGuard.Leave();

    HRETURN( hr );

} //*** CResTypeServices::SendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResTypeServices::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CResTypeServices::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResTypeServices::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count decremented to zero

    CRETURN( cRef );

} //*** CResTypeServices::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResTypeServices::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgResourceTypeCreate * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgResourceTypeCreate ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgResourceTypeCreate, this, 0 );
    } // else if:
    else if ( IsEqualIID( riidIn, IID_IClusCfgResTypeServicesInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgResTypeServicesInitialize, this, 0 );
    } // else if:
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CResTypeServices::QueryInterface



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::SetParameters
//
//  Description:
//      Set the parameters required by this component.
//
//  Arguments:
//      pccciIn
//          Pointer to an interface that provides information about the cluster
//          being configured.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeServices::SetParameters( IClusCfgClusterInfo * pccciIn )
{
    TraceFunc( "[IClusCfgResTypeServicesInitialize]" );

    HRESULT hr = S_OK;

    m_csInstanceGuard.Enter();

    //
    // Validate and store the cluster info pointer.
    //
    if ( pccciIn == NULL )
    {
        LogMsg( "The information about this cluster is invalid (pccciIn == NULL)." );
        hr = THR( E_POINTER );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResTypeServices_SetParameters_ClusPtr_Invalid
            , IDS_TASKID_MINOR_ERROR_RESTYPE_INVALID
            , hr
            );

        goto Cleanup;
    } // if: the cluster info pointer is invalid

    // If we already have a valid pointer, release it.
    if ( m_pccciClusterInfo != NULL )
    {
        m_pccciClusterInfo->Release();
    } // if: the pointer we have is not NULL

    // Store the input pointer and addref it.
    m_pccciClusterInfo = pccciIn;
    m_pccciClusterInfo->AddRef();

Cleanup:

    m_csInstanceGuard.Leave();
    HRETURN( hr );

} //*** CResTypeServices::SetParameters


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::Create
//
//  Description:
//      This method creates a cluster resource type.
//
//  Arguments:
//      pcszResTypeNameIn
//          Name of the resource type
//
//      pcszResTypeDisplayNameIn
//          Display name of the resource type
//
//      pcszResDllNameIn
//          Name (with or without path information) of DLL of the resource type.
//
//      dwLooksAliveIntervalIn
//          Looks-alive interval for the resource type (in milliseconds).
//
//      dwIsAliveIntervalIn
//          Is-alive interval for the resource type (in milliseconds).
//
// Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs.
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeServices::Create(
      const WCHAR *     pcszResTypeNameIn
    , const WCHAR *     pcszResTypeDisplayNameIn
    , const WCHAR *     pcszResDllNameIn
    , DWORD             dwLooksAliveIntervalIn
    , DWORD             dwIsAliveIntervalIn
    )
{
    TraceFunc( "[IClusCfgResourceTypeCreate]" );

    HRESULT         hr = S_OK;
    DWORD           sc = ERROR_SUCCESS;
    ECommitMode     ecmCommitChangesMode = cmUNKNOWN;

    m_csInstanceGuard.Enter();

    // Check if we have tried to get the cluster handle. If not, try now.
    if ( ! m_fOpenClusterAttempted )
    {
        m_fOpenClusterAttempted = true;
        m_hCluster = OpenCluster( NULL );
        if ( m_hCluster == NULL )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            LogMsg( "[PC] Error %#08x occurred trying to open a handle to the cluster. Resource type creation cannot proceed.", hr );

            STATUS_REPORT_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_CResTypeServices_Create_Cluster_Handle
                , IDS_TASKID_MINOR_ERROR_CLUSTER_HANDLE
                , hr
                );

            goto Cleanup;
        } // if: OpenCluster() failed
    } // if: we have not tried to open the handle to the cluster before
    else
    {
        if ( m_hCluster == NULL )
        {
            hr = THR( E_HANDLE );
            LogMsg( "[PC] The cluster handle is NULL. Resource type creation cannot proceed." );

            STATUS_REPORT_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_CResTypeServices_Create_Cluster_Handle_NULL
                , IDS_TASKID_MINOR_ERROR_INVALID_CLUSTER_HANDLE
                , hr
                );

            goto Cleanup;
        } // if: the cluster handle is NULL
    } // if: we have tried to open the handle to the cluster


    //
    // Validate the parameters
    //
    if (    ( pcszResTypeNameIn == NULL )
         || ( pcszResTypeDisplayNameIn == NULL )
         || ( pcszResDllNameIn == NULL )
       )
    {
        LogMsg( "[PC] The information about this resource type is invalid (one or more parameters are invalid)." );
        hr = THR( E_POINTER );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResTypeServices_Create_ResType_Invalid
            , IDS_TASKID_MINOR_ERROR_RESTYPE_INVALID
            , hr
            );

        goto Cleanup;
    } // if: the parameters are invalid

    LogMsg( "[PC] Configuring resource type '%ws'.", pcszResTypeNameIn );

    if ( m_pccciClusterInfo != NULL )
    {
        hr = THR( m_pccciClusterInfo->GetCommitMode( &ecmCommitChangesMode ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "[PC] Error %#08x occurred trying to find out commit changes mode of the cluster.", hr );

            STATUS_REPORT_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_CResTypeServices_Create_Commit_Mode
                , IDS_TASKID_MINOR_ERROR_COMMIT_MODE
                , hr
                );

            goto Cleanup;
        } // if: GetCommitMode() failed
    } // if: we have a configuration info interface pointer
    else
    {
        // If we do not have a pointer to the cluster info interface, assume that this is a add node to cluster
        // This way, if the resource type already exists, then we do not throw up an error.
        LogMsg( "[PC] We do not have a cluster configuration info pointer. Assuming that this is an add node to cluster operation." );
        ecmCommitChangesMode = cmADD_NODE_TO_CLUSTER;
    } // else: we don't have a configuration info interface pointer

    // Create the resource type
    // Cannot wrap call with THR() because it can fail with ERROR_ALREADY_EXISTS.
    sc = CreateClusterResourceType(
              m_hCluster
            , pcszResTypeNameIn
            , pcszResTypeDisplayNameIn
            , pcszResDllNameIn
            , dwLooksAliveIntervalIn
            , dwIsAliveIntervalIn
            );

    if ( sc == ERROR_ALREADY_EXISTS )
    {
        // The resource type already existed, so there's nothing left to do.
        LogMsg( "[PC] Resource type '%ws' already exists.", pcszResTypeNameIn );
        sc = ERROR_SUCCESS;
        goto Cleanup;
    } // if: ERROR_ALREADY_EXISTS was returned

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        LogMsg( "[PC] Error %#08x occurred trying to create resource type '%ws'.", sc, pcszResTypeNameIn );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResTypeServices_Create_Resource_Type
            , IDS_TASKID_MINOR_ERROR_CREATE_RES_TYPE
            , hr
            );

        goto Cleanup;
    } // if: an error occurred trying to create this resource type

    LogMsg( "[PC] Resource type '%ws' successfully created.", pcszResTypeNameIn  );

Cleanup:

    m_csInstanceGuard.Leave();
    HRETURN( hr );

} //*** CResTypeServices::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::RegisterAdminExtensions
//
//  Description:
//      This method registers the cluster administrator extensions for
//      a resource type.
//
//  Arguments:
//      pcszResTypeNameIn
//          Name of the resource type against for the extensions are to be
//          registered.
//
//      cExtClsidCountIn
//          Number of extension class ids in the next parameter.
//
//      rgclsidExtClsidsIn
//          Pointer to an array of class ids of cluster administrator extensions.
//          This can be NULL if cExtClsidCountIn is 0.
//
// Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs.
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeServices::RegisterAdminExtensions(
      const WCHAR *       pcszResTypeNameIn
    , ULONG               cExtClsidCountIn
    , const CLSID *       rgclsidExtClsidsIn
    )
{
    TraceFunc( "[IClusCfgResourceTypeCreate]" );

    HRESULT     hr = S_OK;
    DWORD       sc;
    WCHAR **    rgpszClsidStrings = NULL;
    ULONG       idxCurrentString = 0;
    BYTE *      pbClusPropBuffer = NULL;

    size_t      cchClsidMultiSzSize = 0;
    size_t      cbAdmExtBufferSize = 0;

    m_csInstanceGuard.Enter();

    // Check if we have tried to get the cluster handle. If not, try now.
    if ( ! m_fOpenClusterAttempted )
    {
        m_fOpenClusterAttempted = true;
        m_hCluster = OpenCluster( NULL );
        if ( m_hCluster == NULL )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( "[PC] Error %#08x occurred trying to open a handle to the cluster. Resource type creation cannot proceed.", sc );

            STATUS_REPORT_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_CResTypeServices_RegisterAdminExtensions_Cluster_Handle
                , IDS_TASKID_MINOR_ERROR_CLUSTER_HANDLE
                , hr
                );

            goto Cleanup;
        } // if: OpenCluster() failed
    } // if: we have not tried to open the handle to the cluster before
    else
    {
        if ( m_hCluster == NULL )
        {
            hr = THR( E_HANDLE );
            LogMsg( "[PC] The cluster handle is NULL. Resource type creation cannot proceed." );

            STATUS_REPORT_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_CResTypeServices_RegisterAdminExtensions_Cluster_Handle_NULL
                , IDS_TASKID_MINOR_ERROR_INVALID_CLUSTER_HANDLE
                , hr
                );

            goto Cleanup;
        } // if: the cluster handle is NULL
    } // if: we have tried to open the handle to the cluster


    //
    // Validate the parameters
    //

    if ( cExtClsidCountIn == 0 )
    {
        // There is nothing to do
        LogMsg( "[PC] There is nothing to do." );
        goto Cleanup;
    } // if: there are no extensions to register

    if (    ( pcszResTypeNameIn == NULL )
         || ( rgclsidExtClsidsIn == NULL )
       )
    {
        LogMsg( "[PC] The information about this resource type is invalid (one or more parameters is invalid)." );
        hr = THR( E_POINTER );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResTypeServices_RegisterAdminExtensions_ResType_Invalid
            , IDS_TASKID_MINOR_ERROR_RESTYPE_INVALID
            , hr
            );

        goto Cleanup;
    } // if: the parameters are invalid

    LogMsg( "[PC] Registering %d cluster administrator extensions for resource type '%ws'.", cExtClsidCountIn, pcszResTypeNameIn );

    // Allocate an array of pointers to store the string version of the class ids
    rgpszClsidStrings = new WCHAR *[ cExtClsidCountIn ];
    if ( rgpszClsidStrings == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        LogMsg( "[PC] Error: Memory for the string version of the cluster administrator extension class ids could not be allocated." );

        STATUS_REPORT_POSTCFG(
              TASKID_Major_Configure_Resources
            , TASKID_Minor_CResTypeServices_RegisterAdminExtensions_Alloc_Mem
            , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
            , hr
            );

        goto Cleanup;
    } // if: a memory allocation failure occurred

    // Zero out the pointer array
    ZeroMemory( rgpszClsidStrings, sizeof( rgpszClsidStrings[ 0 ] ) * cExtClsidCountIn );

    //
    // Get the string versions of the input class ids
    //
    for( idxCurrentString = 0; idxCurrentString < cExtClsidCountIn; ++idxCurrentString )
    {
        hr = THR( UuidToStringW( const_cast< UUID * >( &rgclsidExtClsidsIn[ idxCurrentString ] ), &rgpszClsidStrings[ idxCurrentString ] ) );
        if ( hr != RPC_S_OK )
        {
            LogMsg( "[PC] Error %#08x occurred trying to get the string version of an extension class id.", hr );

            STATUS_REPORT_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_CResTypeServices_RegisterAdminExtensions_ClassId
                , IDS_TASKID_MINOR_ERROR_EXTENSION_CLASSID
                , hr
                );

            goto Cleanup;
        } // if: we could not convert the current clsid to a string

        // Add the size of the current string to the total size. Include two extra characters for the opening and
        // closing flower braces {} that need to be added to each clsid string.
        cchClsidMultiSzSize += wcslen( rgpszClsidStrings[ idxCurrentString ] ) + 2 + 1;
    } // for: get the string version of each input clsid

    if ( hr != S_OK )
    {
        goto Cleanup;
    } // if: something went wrong in the loop above

    // Account for the extra terminating L'\0' in a multi-sz string
    ++cchClsidMultiSzSize;

    //
    // Construct the property list required to set the admin extension property for this
    // resource type in the cluster database
    //
    {
        CLUSPROP_BUFFER_HELPER  cbhAdmExtPropList;
        size_t                  cbAdminExtensionSize = cchClsidMultiSzSize * sizeof( *rgpszClsidStrings[ 0 ] );

        //
        // Create and store the property list that will be used to
        // register these admin extensions with the cluster.
        //

        // Determine the number of bytes in the propertly list that will be used to
        // set the admin extensions property for this resource type.
        cbAdmExtBufferSize =
              sizeof( cbhAdmExtPropList.pList->nPropertyCount )
            + sizeof( *cbhAdmExtPropList.pName ) + ALIGN_CLUSPROP( sizeof( CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS ) )
            + sizeof( *cbhAdmExtPropList.pMultiSzValue ) + ALIGN_CLUSPROP( cbAdminExtensionSize )
            + sizeof( CLUSPROP_SYNTAX_ENDMARK );

        // Allocate the buffer for this property list.
        pbClusPropBuffer = new BYTE[ cbAdmExtBufferSize ];
        if ( pbClusPropBuffer == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            LogMsg( "[PC] Error: Memory for the property list of cluster administrator extensions could not be allocated." );

            STATUS_REPORT_POSTCFG(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_CResTypeServices_RegisterAdminExtensions_Alloc_Mem2
                , IDS_TASKID_MINOR_ERROR_OUT_OF_MEMORY
                , hr
                );

            goto Cleanup;
        } // if: memory allocation failed

        //
        // Initialize this property list.
        //

        // Pointer cbhAdmExtPropList to the newly allocated memory
        cbhAdmExtPropList.pb = pbClusPropBuffer;

        // There is only one property in this list.
        cbhAdmExtPropList.pList->nPropertyCount = 1;
        ++cbhAdmExtPropList.pdw;

        // Set the name of the property.
        cbhAdmExtPropList.pName->cbLength = sizeof( CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS );
        cbhAdmExtPropList.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
        memcpy( cbhAdmExtPropList.pName->sz, CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS, sizeof( CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS ) );
        cbhAdmExtPropList.pb += sizeof( *cbhAdmExtPropList.pName ) + ALIGN_CLUSPROP( sizeof( CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS ) );

        // Set the value of the property.
        cbhAdmExtPropList.pMultiSzValue->cbLength = (DWORD)cbAdminExtensionSize;
        cbhAdmExtPropList.pMultiSzValue->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_MULTI_SZ;
        {
            WCHAR * pszCurrentString = cbhAdmExtPropList.pMultiSzValue->sz;

            for( idxCurrentString = 0; idxCurrentString < cExtClsidCountIn; ++ idxCurrentString )
            {
                size_t  cchCurrentStringSize = wcslen( rgpszClsidStrings[ idxCurrentString ] ) + 1;

                // Prepend opening brace
                *pszCurrentString = L'{';
                ++pszCurrentString;

                wcsncpy( pszCurrentString, rgpszClsidStrings[ idxCurrentString ], cchCurrentStringSize );
                pszCurrentString += cchCurrentStringSize - 1;

                // Overwrite the terminating '\0' with a closing brace
                *pszCurrentString = L'}';
                ++pszCurrentString;

                // Terminate the current string
                *pszCurrentString = L'\0';
                ++pszCurrentString;

            } // for: copy each of the clsid strings into a contiguous buffer

            // Add the extra L'\0' required by multi-sz strings
            *pszCurrentString = L'\0';
        }
        cbhAdmExtPropList.pb += sizeof( *cbhAdmExtPropList.pMultiSzValue ) + ALIGN_CLUSPROP( cbAdminExtensionSize );

        // Set the end mark for this property list.
        cbhAdmExtPropList.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
    }

    // Set the AdminExtensions common property.
    {
        sc = TW32( ClusterResourceTypeControl(
                      m_hCluster
                    , pcszResTypeNameIn
                    , NULL
                    , CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES
                    , pbClusPropBuffer
                    , (DWORD)cbAdmExtBufferSize
                    , NULL
                    , 0
                    , NULL
                    )
                );

        if ( sc != ERROR_SUCCESS )
        {
            // We could not set the admin extenstions property,
            LogMsg( "[PC] Error %#08x occurred trying to configure the admin extensions for resource type '%ws'.", sc, pcszResTypeNameIn );
            hr = HRESULT_FROM_WIN32( sc );

            STATUS_REPORT_POSTCFG1(
                  TASKID_Major_Configure_Resources
                , TASKID_Minor_CResTypeServices_RegisterAdminExtensions_Configure
                , IDS_TASKID_MINOR_ERROR_CONFIG_EXTENSION
                , hr
                , pcszResTypeNameIn
                );

            goto Cleanup;
        } // if: ClusterResourceTypeControl() failed
    }

Cleanup:

    //
    // Cleanup
    //

    m_csInstanceGuard.Leave();

    if ( rgpszClsidStrings != NULL )
    {
        // Free all the strings that were allocated
        for( idxCurrentString = 0; idxCurrentString < cExtClsidCountIn; ++idxCurrentString )
        {
            if ( rgpszClsidStrings[ idxCurrentString ] != NULL )
            {
                // Free the current string
                RpcStringFree( &rgpszClsidStrings[ idxCurrentString ] );
            } // if: this pointer points to a string
            else
            {
                // If we are here, it means all the strings were not allocated
                // due to some error. No need to free any more strings.
                break;
            } // else: the current string pointer is NULL
        } // for: iterate through the array of pointer and free them

        // Free the array of pointers
        delete [] rgpszClsidStrings;

    } // if: we had allocated the array of strings

    delete [] pbClusPropBuffer;

    HRETURN( hr );

} //*** CResTypeServices::RegisterAdminExtensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\test\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Description:
//      The entry point for the application that launches unattended
//      installation of the cluster. This application parses input parameters,
//      CoCreates the Configuration Wizard Component, passes the parsed
//      parameters and invokes the Wizard. The Wizard may or may not show any
//      UI depending on swithes and the (in)availability of information.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     15-JUN-2000
//      Vijay Vasu (VVasu)          15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>
#include <guids.h>

// {F4A50885-A4B9-4c4d-B67C-9E4DD94A315E}
DEFINE_GUID( CLSID_TaskType,
0xf4a50885, 0xa4b9, 0x4c4d, 0xb6, 0x7c, 0x9e, 0x4d, 0xd9, 0x4a, 0x31, 0x5e);


//
//  KB: Turn this on to run all tests. Some of these might return errors, but none
//      of them should cause the program to crash.
//
//#define TURN_ON_ALL_TESTS

//
//  KB: Turn this on to run a regression pass.
//
#define REGRESSION_PASS


DEFINE_MODULE( "MIDDLETIERTEST" )

//
//  Declarations
//
typedef HRESULT (* PDLLREGISTERSERVER)( void );

//
//  Globals
//
HINSTANCE           g_hInstance = NULL;
LONG                g_cObjects  = 0;
IServiceProvider *  g_psp       = NULL;

BOOL                g_fWait     = FALSE;    // global synchronization

OBJECTCOOKIE        g_cookieCluster = NULL;


//
//  Register the DLL
//
HRESULT
HrRegisterTheDll( void )
{
    TraceFunc( "" );

    HRESULT hr;

    PDLLREGISTERSERVER  pDllRegisterServer;

    HMODULE hLib    = NULL;

    //
    //  Make sure the DLL is properly registered.
    //

    hLib = LoadLibrary( L"..\\..\\..\\..\\dll\\obj\\i386\\ClusCfgServer.dll" );
    if ( hLib == NULL )
        goto Win32Error;

    pDllRegisterServer = reinterpret_cast< PDLLREGISTERSERVER >( GetProcAddress( hLib, "DllRegisterServer" ) );
    if ( pDllRegisterServer == NULL )
        goto Win32Error;

    hr = THR( pDllRegisterServer( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( hLib != NULL )
    {
        FreeLibrary( hLib );
    }

    HRETURN( hr );

Win32Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
    goto Cleanup;
}

//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  main( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int
_cdecl
main( void )
{
    TraceInitializeProcess();

    HRESULT hr;

    BOOL    fFirstTime = TRUE;

    IClusCfgServer * pccs = NULL;
    IEnumClusCfgManagedResources * peccmr = NULL;
    IClusCfgManagedResourceInfo *  pccmri = NULL;

    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if 0
    hr = THR( HrRegisterTheDll( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

    hr = THR( CoCreateInstance( CLSID_ClusCfgServer,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IClusCfgServer, &pccs )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "Succeeded in creating ClusCfgServer." );

    hr = THR( pccs->GetManagedResourcesEnum( &peccmr ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Loop thru making sure everything can be managed.
    //

    for( ;; )
    {
        if ( pccmri != NULL )
        {
            pccmri->Release( );
            pccmri = NULL;
        }

        hr = STHR( peccmr->Next( 1, &pccmri, NULL ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            break;

        hr = THR( pccmri->SetManaged( TRUE ) );
        if ( FAILED( hr ) )
            continue;

        if ( fFirstTime )
        {
            hr = THR( pccmri->SetQuorumedDevice( TRUE ) );
            if ( FAILED( hr ) )
                continue;

            fFirstTime = FALSE;
        }

    } // for: ever

    DebugMsg( "Succeeded in setting all devices to be managed." );

    hr = THR( pccs->CommitChanges( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "Successfully committed changes." );

Cleanup:
    if ( pccs != NULL )
    {
        pccs->Release( );
    }
    if ( peccmr != NULL )
    {
        peccmr->Release( );
    }
    if ( pccmri != NULL )
    {
        pccmri->Release( );
    }

    CoUninitialize( );

    TraceTerminateProcess();

    return 0;

} //*** main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\privateguids\cluscfgprivateguids.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      ClusCfgPrivateGuids.cpp
//
//  Description:
//      Values for private cluster configuration guids.
//
//  Maintained By:
//      John Franco (JFranco) 02-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#include <initguid.h>
#include <Guids.h>
#include <IISClusCfgGuids.h>
#include <cluscfgprivate_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\postcfg\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     15-JUN-2000
//      Vijay Vasu (VVasu)          15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
#endif // DBG==1

#define USES_SYSALLOCSTRING

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>

#include <common.h>
#include <debug.h>
#include <Log.h>
#include <citracker.h>
#include <guids.h>
#include <ObjectCookie.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgcallback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCallback.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgCallback
//      class.
//
//      The class CClusCfgCallback inplements the callback
//      interface between this server and its clients.  It implements the
//      IClusCfgCallback interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CClusCfgCallback.h"

// For CClCfgSrvLogger
#include <Logger.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgCallback" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback class
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgCallback instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the newly created object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCallback::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CClusCfgCallback *  pccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccs = new CClusCfgCallback();
    if ( pccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() succeeded

    hr = THR( pccs->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( pccs != NULL )
    {
        pccs->Release();
    } // if:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgCallback::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    HRETURN( hr );

} //*** CClusCfgCallback::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::CClusCfgCallback
//
//  Description:
//      Constructor of the CClusCfgCallback class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCallback::CClusCfgCallback( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_pccc == NULL );
    Assert( m_hEvent == NULL );

    Assert( m_pcszNodeName == NULL );
    Assert( m_pclsidTaskMajor == NULL );
    Assert( m_pclsidTaskMinor == NULL );
    Assert( m_pulMin == NULL );
    Assert( m_pulMax == NULL );
    Assert( m_pulCurrent == NULL );
    Assert( m_phrStatus == NULL );
    Assert( m_pcszDescription == NULL );
    Assert( m_pftTime == NULL );
    Assert( m_pcszReference == NULL );
    Assert( !m_fPollingMode );
    Assert( m_bstrNodeName == NULL );
    Assert( m_plLogger == NULL );

//
//  Assert the simulated RPC failure variables are in the correct state.
//

#if defined( DEBUG ) && defined( CCS_SIMULATE_RPC_FAILURE )
    Assert( m_cMessages == 0 );
    Assert( m_fDoFailure == false );
#endif

    TraceFuncExit();

} //*** CClusCfgCallback::CClusCfgCallback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::~CClusCfgCallback
//
//  Description:
//      Desstructor of the CClusCfgCallback class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCallback::~CClusCfgCallback( void )
{
    TraceFunc( "" );

    if ( m_hEvent != NULL )
    {
        if ( CloseHandle( m_hEvent ) == false )
        {
            TW32( GetLastError() );
            LogMsg( L"[SRV] Cannot close event handle.  (sc = %#08x)", GetLastError() );
        }
    } // if:

    TraceSysFreeString( m_bstrNodeName );

    if ( m_pccc != NULL )
    {
        m_pccc->Release();
    } // if:

    if ( m_plLogger != NULL )
    {
        m_plLogger->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgCallback::~CClusCfgCallback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::SendStatusReport(
    CLSID           clsidTaskMajorIn,
    CLSID           clsidTaskMinorIn,
    ULONG           ulMinIn,
    ULONG           ulMaxIn,
    ULONG           ulCurrentIn,
    HRESULT         hrStatusIn,
    const WCHAR *   pcszDescriptionIn
    )
{
    TraceFunc1( "pcszDescriptionIn = '%ls'", pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    FILETIME    ft;

    bstrDescription = TraceSysAllocString( pcszDescriptionIn );
    if ( bstrDescription == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    hr = THR( SendStatusReport(
                            NULL,
                            clsidTaskMajorIn,
                            clsidTaskMinorIn,
                            ulMinIn,
                            ulMaxIn,
                            ulCurrentIn,
                            hrStatusIn,
                            bstrDescription,
                            &ft,
                            NULL
                            ) );

Cleanup:

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** CClusCfgCallback::SendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::SendStatusReport(
    CLSID           clsidTaskMajorIn,
    CLSID           clsidTaskMinorIn,
    ULONG           ulMinIn,
    ULONG           ulMaxIn,
    ULONG           ulCurrentIn,
    HRESULT         hrStatusIn,
    DWORD           dwDescriptionIn
    )
{
    TraceFunc1( "dwDescriptionIn = %d", dwDescriptionIn );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    FILETIME    ft;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, dwDescriptionIn, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    hr = THR( SendStatusReport(
                            NULL,
                            clsidTaskMajorIn,
                            clsidTaskMinorIn,
                            ulMinIn,
                            ulMaxIn,
                            ulCurrentIn,
                            hrStatusIn,
                            bstrDescription,
                            &ft,
                            NULL
                            ) );

Cleanup:

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** CClusCfgCallback::SendStatusReport


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback -- IUnknown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCallback::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    CRETURN( m_cRef );

} //*** CClusCfgCallback::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCallback::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CClusCfgCallback::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::QueryInterface(
    REFIID      riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgCallback * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgPollingCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgPollingCallback, this, 0 );
    } // else if: IClusCfgPollingCallback
    else if ( IsEqualIID( riidIn, IID_IClusCfgSetPollingCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgSetPollingCallback, this, 0 );
    } // else if: IClusCfgSetPollingCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

     QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusCfgCallback::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback -- IClusCfgCallback interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::SendStatusReport(
    LPCWSTR     pcszNodeNameIn,
    CLSID       clsidTaskMajorIn,
    CLSID       clsidTaskMinorIn,
    ULONG       ulMinIn,
    ULONG       ulMaxIn,
    ULONG       ulCurrentIn,
    HRESULT     hrStatusIn,
    LPCWSTR     pcszDescriptionIn,
    FILETIME *  pftTimeIn,
    LPCWSTR     pcszReferenceIn
    )
{
    TraceFunc1( "[IClusCfgCallback] pcszDescriptionIn = '%s'", pcszDescriptionIn == NULL ? TEXT("<null>") : pcszDescriptionIn );

    HRESULT     hr = S_OK;
    FILETIME    ft;
    FILETIME    ftLocal;
    SYSTEMTIME  stLocal;
    BOOL        fRet;
    BSTR        bstrReferenceString = NULL;
    LPCWSTR     pcszReference = NULL;

    if ( pcszNodeNameIn == NULL )
    {
        pcszNodeNameIn = m_bstrNodeName;
    } // if:

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    Assert( pcszNodeNameIn != NULL );
    Assert( pftTimeIn != NULL );

    TraceMsg( mtfFUNC, L"pcszNodeNameIn = %s", pcszNodeNameIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMajorIn ", clsidTaskMajorIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMinorIn ", clsidTaskMinorIn );
    TraceMsg( mtfFUNC, L"ulMinIn = %u", ulMinIn );
    TraceMsg( mtfFUNC, L"ulMaxIn = %u", ulMaxIn );
    TraceMsg( mtfFUNC, L"ulCurrentIn = %u", ulCurrentIn );
    TraceMsg( mtfFUNC, L"hrStatusIn = %#08x", hrStatusIn );
    TraceMsg( mtfFUNC, L"pcszDescriptionIn = '%ws'", ( pcszDescriptionIn ? pcszDescriptionIn : L"<null>" ) );

    fRet = FileTimeToLocalFileTime( pftTimeIn, &ftLocal );
    Assert( fRet == TRUE );

    fRet = FileTimeToSystemTime( &ftLocal, &stLocal );
    Assert( fRet == TRUE );

    TraceMsg(
          mtfFUNC
        , L"pftTimeIn = \"%04u-%02u-%02u %02u:%02u:%02u.%03u\""
        , stLocal.wYear
        , stLocal.wMonth
        , stLocal.wDay
        , stLocal.wHour
        , stLocal.wMinute
        , stLocal.wSecond
        , stLocal.wMilliseconds
        );

    if (    ( pcszReferenceIn == NULL )
        &&  ( hrStatusIn != S_OK )
        &&  ( hrStatusIn != S_FALSE )
        )
    {
        hr = STHR( HrGetReferenceStringFromHResult( hrStatusIn, &bstrReferenceString ) );
        if ( hr == S_OK )
        {
            pcszReference = bstrReferenceString;
        }
    } // if: no reference string was specified
    else
    {
        pcszReference = pcszReferenceIn;
    }

    TraceMsg( mtfFUNC, L"pcszReferenceIn = '%ws'", ( pcszReference ? pcszReference : L"<null>" ) );

    hr = THR( CClCfgSrvLogger::S_HrLogStatusReport(
                      m_plLogger
                    , pcszNodeNameIn
                    , clsidTaskMajorIn
                    , clsidTaskMinorIn
                    , ulMinIn
                    , ulMaxIn
                    , ulCurrentIn
                    , hrStatusIn
                    , pcszDescriptionIn
                    , pftTimeIn
                    , pcszReference
                    ) );

    //  Local logging - don't send up
    if ( IsEqualIID( clsidTaskMajorIn, TASKID_Major_Server_Log ) )
    {
        goto Cleanup;
    } // if:

    if ( m_fPollingMode )
    {
        Assert( m_pccc == NULL );
        TraceMsg( mtfFUNC, L"[SRV] Sending the status message with polling." );

        hr = THR( HrQueueStatusReport(
                                pcszNodeNameIn,
                                clsidTaskMajorIn,
                                clsidTaskMinorIn,
                                ulMinIn,
                                ulMaxIn,
                                ulCurrentIn,
                                hrStatusIn,
                                pcszDescriptionIn,
                                pftTimeIn,
                                pcszReference
                                ) );
    } // if:
    else if ( m_pccc != NULL )
    {
        TraceMsg( mtfFUNC, L"[SRV] Sending the status message without polling." );

        hr = THR( m_pccc->SendStatusReport(
                                pcszNodeNameIn,
                                clsidTaskMajorIn,
                                clsidTaskMinorIn,
                                ulMinIn,
                                ulMaxIn,
                                ulCurrentIn,
                                hrStatusIn,
                                pcszDescriptionIn,
                                pftTimeIn,
                                pcszReference
                                ) );
        if ( hr == E_ABORT )
        {
            LogMsg( L"[SRV] E_ABORT returned from the client." );
        } // if:
    } // else if:
    else
    {
        LogMsg( L"[SRV] Neither a polling callback or a regular callback were found.  No messages are being sent to anyone!" );
    } // else:

Cleanup:

    TraceSysFreeString( bstrReferenceString );

    HRETURN( hr );

} //*** CClusCfgCallback::SendStatusReport


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback -- IClusCfgPollingCallback interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::GetStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::GetStatusReport(
    BSTR *      pbstrNodeNameOut,
    CLSID *     pclsidTaskMajorOut,
    CLSID *     pclsidTaskMinorOut,
    ULONG *     pulMinOut,
    ULONG *     pulMaxOut,
    ULONG *     pulCurrentOut,
    HRESULT *   phrStatusOut,
    BSTR *      pbstrDescriptionOut,
    FILETIME *  pftTimeOut,
    BSTR *      pbstrReferenceOut
    )
{
    TraceFunc( "[IClusCfgPollingCallback]" );

    HRESULT hr;
    DWORD   sc;

//
//  If we are simulating RPC errors then force this function to always fail.
//

#if defined( DEBUG ) && defined( CCS_SIMULATE_RPC_FAILURE )
    if ( m_fDoFailure )
    {
        hr = THR( RPC_E_CALL_REJECTED );
        goto Cleanup;
    } // if:
#endif

    sc = WaitForSingleObject( m_hEvent, 0 );
    if ( sc == WAIT_FAILED )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    //
    //  If sc is WAIT_TIMEOUT then the event is not signaled and there is an SSR
    //  for the client to pick up.
    //

    if ( sc == WAIT_TIMEOUT )
    {
        Assert( *m_pcszNodeName != NULL );
        *pbstrNodeNameOut = SysAllocString( m_pcszNodeName );
        if ( *pbstrNodeNameOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        *pclsidTaskMajorOut     = *m_pclsidTaskMajor;
        *pclsidTaskMinorOut     = *m_pclsidTaskMinor;
        *pulMinOut              = *m_pulMin;
        *pulMaxOut              = *m_pulMax;
        *pulCurrentOut          = *m_pulCurrent;
        *phrStatusOut           = *m_phrStatus;
        *pftTimeOut             = *m_pftTime;

        if ( m_pcszDescription != NULL )
        {
            *pbstrDescriptionOut = SysAllocString( m_pcszDescription );
            if ( *pbstrDescriptionOut == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:
        } // if:
        else
        {
            *pbstrDescriptionOut = NULL;
        } // else:

        if ( m_pcszReference != NULL )
        {
            *pbstrReferenceOut = SysAllocString( m_pcszReference );
            if ( *pbstrReferenceOut == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:
        } // if:
        else
        {
            *pbstrReferenceOut = NULL;
        } // else:

        hr = S_OK;
    } // if: event was not signaled
    else
    {
        hr = S_FALSE;
    } // else: WAIT_OBJECT_0 event was signaled

    goto Cleanup;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgCallback::GetStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::SetHResult
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::SetHResult( HRESULT hrIn )
{
    TraceFunc( "[IClusCfgPollingCallback]" );

    HRESULT hr = S_OK;
    DWORD   sc;

    m_hr = hrIn;

    if ( hrIn != S_OK )
    {
        if ( hrIn == E_ABORT )
        {
            LogMsg( L"[SRV] E_ABORT returned from the client." );
        } // if:
        else
        {
            LogMsg( L"[SRV] SetHResult(). (hrIn = %#08x)", hrIn );
        } // else:
    } // if:

    if ( !SetEvent( m_hEvent ) )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] Could not signal event. (hr = %#08x)", hr );
    } // if:

    HRETURN( hr );

} //*** CClusCfgCallback::SetHResult


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::Initialize
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::Initialize( IUnknown  * punkCallbackIn, LCID lcidIn )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_pccc == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    //
    //  KB: 13 DEC 2000 GalenB
    //
    //  If the passed in callback object is NULL then we had better be doing a polling
    //  callback!
    //
    if ( punkCallbackIn != NULL )
    {
        Assert( !m_fPollingMode );

        hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_pccc ) );
    } // if:
    else
    {
        Assert( m_fPollingMode );
    } // else:

    HRETURN( hr );

} //*** CClusCfgCallback::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback -- IClusCfgSetPollingCallback interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::SetPollingMode
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::SetPollingMode( BOOL fUsePollingModeIn )
{
    TraceFunc( "[IClusCfgPollingCallback]" );

    HRESULT hr = S_OK;

    m_fPollingMode = fUsePollingModeIn;

    HRETURN( hr );

} //*** CClusCfgCallback::SetPollingMode


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCallback::HrInit( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IServiceProvider *  psp = NULL;
    ILogManager *       plm = NULL;

    // IUnknown
    Assert( m_cRef == 1 );

    //
    //  Get a ClCfgSrv ILogger instance.
    //  We can't do logging (e.g. LogMsg) until this is succesful.
    //

    hr = THR( CoCreateInstance(
                      CLSID_ServiceManager
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IServiceProvider
                    , reinterpret_cast< void ** >( &psp )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_LogManager, ILogManager, &plm ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( plm->GetLogger( &m_plLogger ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Create the event in a signaled state.  To prevent MT polling task from grabbing
    //  bad/empty data.
    //
    m_hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
    if ( m_hEvent == NULL )
    {
        DWORD sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] Could not create event. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    //
    // Save off the local computer name.
    //
    hr = THR( HrGetComputerName(
                  ComputerNameDnsFullyQualified
                , &m_bstrNodeName
                , TRUE // fBestEffortIn
                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }

    if ( plm != NULL )
    {
        plm->Release();
    }

    HRETURN( hr );

} //*** CClusCfgCallback::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::HrQueueStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCallback::HrQueueStatusReport(
    LPCWSTR     pcszNodeNameIn,
    CLSID       clsidTaskMajorIn,
    CLSID       clsidTaskMinorIn,
    ULONG       ulMinIn,
    ULONG       ulMaxIn,
    ULONG       ulCurrentIn,
    HRESULT     hrStatusIn,
    LPCWSTR     pcszDescriptionIn,
    FILETIME *  pftTimeIn,
    LPCWSTR     pcszReferenceIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;
    MSG     msg;

    m_pcszNodeName      = pcszNodeNameIn;
    m_pclsidTaskMajor   = &clsidTaskMajorIn;
    m_pclsidTaskMinor   = &clsidTaskMinorIn;
    m_pulMin            = &ulMinIn;
    m_pulMax            = &ulMaxIn;
    m_pulCurrent        = &ulCurrentIn;
    m_phrStatus         = &hrStatusIn;
    m_pcszDescription   = pcszDescriptionIn;
    m_pftTime           = pftTimeIn,
    m_pcszReference     = pcszReferenceIn;

//
//  This code simulates the RPC failure that causes a deadlock between the
//  client and the server.  This deadlock occurs when this object is waiting
//  for the client's TaskPollingCallback to pick up the queued SSR and an RPC
//  failure prevents that from happening.  Since the client task has made a
//  DCOM call into the server side the Wizard appears to hang since that thread
//  is waiting for the remote object to return and that object inturn is
//  waiting in this object for the client to pick up the queued status report.
//

#if defined( DEBUG ) && defined( CCS_SIMULATE_RPC_FAILURE )
    m_cMessages++;

    //
    //  Arbitrary number to cause the simulated RPC failure to occur after some
    //  normal status report traffic has gone by.  This really only works when
    //  doing analysis.  More thought will be needed to make this simulated
    //  failure code work for commit.
    //

    if ( m_cMessages > 10 )
    {
        HANDLE  hEvent = NULL;

        m_fDoFailure = true;

        hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
        if ( hEvent != NULL )
        {
            for ( sc = (DWORD) -1; sc != WAIT_OBJECT_0; )
            {
                while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
                {
                    TranslateMessage( &msg );
                    DispatchMessage( &msg );
                } // while: PeekMessage

                //
                //  Wait for up to twice the normal default timeout...
                //

                sc = MsgWaitForMultipleObjects( 1, &hEvent, FALSE, 2 * CCC_WAIT_TIMEOUT, QS_ALLINPUT );
                if ( ( sc == -1 ) || ( sc == WAIT_FAILED ) )
                {
                    sc = TW32( GetLastError() );
                    hr = HRESULT_FROM_WIN32( sc );
                    LogMsg( L"[SRV] MsgWaitForMultipleObjects failed. (hr = %#08x)", hr );
                    goto Cleanup;
                } // if:
                else if ( sc == WAIT_TIMEOUT )
                {
                    LogMsg( L"[SRV] MsgWaitForMultipleObjects timed out. Returning E_ABORT to the caller (hr = %#08x)", hr );
                    hr = THR( E_ABORT );
                    goto Cleanup;
                } // else if:
            } // for:
        } // if:
    } // if:
#endif

    if ( ResetEvent( m_hEvent ) == FALSE )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] Could not reset event. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    for ( sc = (DWORD) -1; sc != WAIT_OBJECT_0; )
    {
        while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        } // while: PeekMessage

        //
        //  Wait for up to 5 minutes...
        //

        sc = MsgWaitForMultipleObjects( 1, &m_hEvent, FALSE, CCC_WAIT_TIMEOUT, QS_ALLINPUT );
        if ( ( sc == -1 ) || ( sc == WAIT_FAILED ) )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( L"[SRV] MsgWaitForMultipleObjects failed. (hr = %#08x)", hr );
            goto Cleanup;
        } // if:
        else if ( sc == WAIT_TIMEOUT )
        {
            LogMsg( L"[SRV] MsgWaitForMultipleObjects timed out. Returning E_ABORT to the caller (hr = %#08x)", hr );
            hr = THR( E_ABORT );
            goto Cleanup;
        } // else if:
    } // for:

    //
    //  If we end up here then we want to return the status from the client that is
    //  in m_hr...
    //

    hr = m_hr;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgCallback::HrQueueStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgcapabilities.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCapabilities.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgCapabilities class.
//
//      The class CClusCfgCapabilities is the implementations of the
//      IClusCfgCapabilities interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CClusCfgCapabilities.h"
#include <ClusRtl.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgCapabilities" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCapabilities class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgCapabilities instance.
//
//  Arguments:
//      ppunkOut    -
//
//  Return Values:
//      Pointer to CClusCfgCapabilities instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCapabilities::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CClusCfgCapabilities *  pccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccs = new CClusCfgCapabilities();
    if ( pccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccs->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgCapabilities::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccs != NULL )
    {
        pccs->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgCapabilities::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      picrIn
//          Used to register/unregister our CATID support.
//
//      fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCapabilities::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_ClusCfgCapabilities;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_ClusCfgCapabilities, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgCapabilities::S_RegisterCatIDSupport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::CClusCfgCapabilities
//
//  Description:
//      Constructor of the CClusCfgCapabilities class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCapabilities::CClusCfgCapabilities( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );

    TraceFuncExit();

} //*** CClusCfgCapabilities::CClusCfgCapabilities


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::~CClusCfgCapabilities
//
//  Description:
//      Destructor of the CClusCfgCapabilities class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCapabilities::~CClusCfgCapabilities( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgCapabilities::~CClusCfgCapabilities


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCapabilities -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CClusCfgCapabilities::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCapabilities::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    CRETURN( m_cRef );

} //*** CClusCfgCapabilities::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CClusCfgCapabilities::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCapabilities::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CClusCfgCapabilities::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CClusCfgCapabilities::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCapabilities::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgCapabilities * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgCapabilities ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCapabilities, this, 0 );
    } // else if: IClusCfgCapabilities
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusCfgCapabilities::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCapabilities -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgInitialize]
//  CClusCfgCapabilities::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The punkCallbackIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCapabilities::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgCapabilities::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCapabilities class -- IClusCfgCapabilities interfaces.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgCapabilities]
//  CClusCfgCapabilities::CanNodeBeClustered
//
//  Description:
//      Can this node be added to a cluster?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Node can be clustered.
//
//      S_FALSE
//          Node cannot be clustered.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCapabilities::CanNodeBeClustered( void )
{
    TraceFunc( "[IClusCfgCapabilities]" );

    HRESULT hr = S_OK;

    //
    //  Since this only displays a warning there is no need to abort the whole
    //  process if this call fails.
    //
    THR( HrCheckForSFM() );

    hr = STHR( HrIsOSVersionValid() );

    HRETURN( hr );

} //*** CClusCfgCapabilities::CanNodeBeClustered


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCapabilities class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCapabilities::HrInit( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CClusCfgCapabilities::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::HrCheckForSFM
//
//  Description:
//      Checks for Services for Macintosh (SFM) and displays a warning
//      in the UI if found.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCapabilities::HrCheckForSFM( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BOOL    fSFMInstalled = FALSE;
    DWORD   sc;

    sc = TW32( ClRtlIsServicesForMacintoshInstalled( &fSFMInstalled ) );
    if ( sc == ERROR_SUCCESS )
    {
        if ( fSFMInstalled )
        {
            LogMsg( L"[SRV] Services for Macintosh was found on this node." );
            hr = S_FALSE;
            STATUS_REPORT_REF(
                      TASKID_Major_Check_Node_Feasibility
                    , TASKID_Minor_ServicesForMac_Installed
                    , IDS_WARN_SERVICES_FOR_MAC_INSTALLED
                    , IDS_WARN_SERVICES_FOR_MAC_INSTALLED_REF
                    , hr
                    );
        } // if:
    } // if:
    else
    {
        hr = MAKE_HRESULT( 0, FACILITY_WIN32, sc );
        STATUS_REPORT_REF(
                  TASKID_Major_Check_Node_Feasibility
                , TASKID_Minor_ServicesForMac_Installed
                , IDS_WARN_SERVICES_FOR_MAC_FAILED
                , IDS_WARN_SERVICES_FOR_MAC_FAILED_REF
                , hr
                );
    } // else:

    hr = S_OK;

    HRETURN( hr );

} //*** CClusCfgCapabilities::HrCheckForSFM


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::HrIsOSVersionValid
//
//  Description:
//      Can this node be added to a cluster?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Node can be clustered.
//
//      S_FALSE
//          Node cannot be clustered.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCapabilities::HrIsOSVersionValid( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HRESULT hrSSR;
    BOOL    fRet;
    BSTR    bstrMsg = NULL;

    //
    // Get the message to be displayed in the UI for status reports.
    //
    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_VALIDATING_NODE_OS_VERSION, &bstrMsg ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Send the initial status report to be displayed in the UI.
    //
    hrSSR = THR( HrSendStatusReport(
                          m_picccCallback
                        , TASKID_Major_Check_Node_Feasibility
                        , TASKID_Minor_Validating_Node_OS_Version
                        , 0
                        , 1
                        , 0
                        , S_OK
                        , bstrMsg
                        ) );
    if ( FAILED( hrSSR ) )
    {
        hr = hrSSR;
        goto Cleanup;
    } // if:

    //
    // Find out if the OS is valid for clustering.
    //
    fRet = ClRtlIsOSValid();
    if ( ! fRet )
    {
        DWORD sc = TW32( GetLastError() );
        hrSSR = HRESULT_FROM_WIN32( sc );
        hr = S_FALSE;
    } // if:
    else
    {
        hrSSR = S_OK;
    } // else:

    //
    // Send the final status report.
    //
    hrSSR = THR( HrSendStatusReport(
                          m_picccCallback
                        , TASKID_Major_Check_Node_Feasibility
                        , TASKID_Minor_Validating_Node_OS_Version
                        , 0
                        , 1
                        , 1
                        , hrSSR
                        , bstrMsg
                        ) );
    if ( FAILED( hrSSR ) )
    {
        hr = hrSSR;
        goto Cleanup;
    } // if:

Cleanup:

    TraceSysFreeString( bstrMsg );

    HRETURN( hr );

} //*** CClusCfgCapabilities::HrIsOSVersionValid
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgclusterinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CClusCfgClusterInfo.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgClusterInfo
//      class.
//
//      The class CClusCfgClusterInfo is the representation of a
//      cluster. It implements the IClusCfgClusterInfo interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include <PropList.h>
#include <ClusRtl.h>
#include <windns.h>
#include <commctrl.h>
#include <ClusCfgPrivate.h>
#include <ClusterUtils.h>

#include "CClusCfgClusterInfo.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgClusterInfo" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgClusterInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CClusCfgClusterInfo *   pccci = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccci = new CClusCfgClusterInfo();
    if ( pccci == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccci->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccci->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( pccci != NULL )
    {
        pccci->Release();
    } // if:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgClusterInfo::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::CClusCfgClusterInfo
//
//  Description:
//      Constructor of the CClusCfgClusterInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgClusterInfo::CClusCfgClusterInfo( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_bstrName == NULL );
    Assert( m_piccniNetwork == NULL );
    Assert( m_ulIPDottedQuad == 0 );
    Assert( m_ulSubnetDottedQuad == 0 );
    Assert( m_punkServiceAccountCredentials == NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_ecmCommitChangesMode == cmUNKNOWN );
    Assert( m_bstrBindingString == NULL );

    TraceFuncExit();

} //*** CClusCfgClusterInfo::CClusCfgClusterInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::~CClusCfgClusterInfo
//
//  Description:
//      Desstructor of the CClusCfgClusterInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgClusterInfo::~CClusCfgClusterInfo( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    if ( m_piccniNetwork != NULL )
    {
        m_piccniNetwork->Release();
    } // if:

    if ( m_punkServiceAccountCredentials != NULL )
    {
        m_punkServiceAccountCredentials->Release();
    } // if:

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrBindingString );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgClusterInfo::~CClusCfgClusterInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgClusterInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    CRETURN( m_cRef );

} //*** CClusCfgClusterInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgClusterInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CClusCfgClusterInfo::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgClusterInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgClusterInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgClusterInfo, this, 0 );
    } // else if: IClusCfgClusterInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgSetClusterNodeInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgSetClusterNodeInfo, this, 0 );
    } // else if: IClusCfgSetClusterNodeInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgWbemServices ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
    } // else if: IClusCfgWbemServices
    else if ( IsEqualIID( riidIn, IID_IClusCfgClusterInfoEx ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgClusterInfoEx, this, 0 );
    } // else if: IClusCfgClusterInfoEx
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else:

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

     QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusCfgClusterInfo::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetWbemServices(
    IWbemServices * pIWbemServicesIn
    )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Establish_Connection, TASKID_Minor_SetWbemServices_Cluster, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo -- IClusCfgInitialze interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );

    HRESULT     hr = S_OK;
    HRESULT     hrTemp = S_OK;
    HCLUSTER    hCluster = NULL;
    DWORD       sc;
    DWORD       dwState;
    BSTR        bstrDomain = NULL;
    BSTR        bstrClusterName = NULL;
    size_t      cchName;
    size_t      cchClusterName;
    size_t      cchDomain;

    m_lcid = lcidIn;

    Assert( m_picccCallback == NULL );

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( m_fIsClusterNode )
    {
        //
        // Get the cluster state of the node.
        // Ignore the case where the service does not exist so that
        // EvictCleanup can do its job.
        //

        sc = GetNodeClusterState( NULL, &dwState );
        if ( sc == ERROR_SERVICE_DOES_NOT_EXIST )
        {
            LOG_STATUS_REPORT( L"CClusCfgClusterInfo::Initialize() GetNodeClusterState() determined that the cluster service does not exist.", hr );
        }
        else if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
            LOG_STATUS_REPORT( L"CClusCfgClusterInfo::Initialize() GetNodeClusterState() failed.", hr );
            goto Cleanup;
        } // if:

        Assert( ( dwState == ClusterStateRunning ) || ( dwState == ClusterStateNotRunning ) );

        if ( dwState == ClusterStateNotRunning )
        {
            //
            //  Set hrTemp to S_FALSE so a warning is shown in the UI.
            //
            hrTemp = S_FALSE;
            STATUS_REPORT_REF( TASKID_Major_Establish_Connection, TASKID_Minor_Node_Down, IDS_ERROR_NODE_DOWN, IDS_ERROR_NODE_DOWN_REF, hrTemp );
            LogMsg( L"[SRV] The cluster service is down on this node." );

            //
            //  Set hrTemp to HR_S_RPC_S_CLUSTER_NODE_DOWN so we can return this later.
            //
            hrTemp = HR_S_RPC_S_CLUSTER_NODE_DOWN;
            goto ClusterNodeDown;
        } // if:

        hCluster = OpenCluster( NULL );
        if ( hCluster == NULL )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            LOG_STATUS_REPORT( L"CClusCfgClusterInfo::Initialize() OpenCluster() failed.", hr );
            goto Cleanup;
        } // if:

        hr = THR( HrGetClusterInformation( hCluster, &bstrClusterName, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetComputerName(
                          ComputerNamePhysicalDnsDomain
                        , &bstrDomain
                        , FALSE // fBestEffortIn
                        ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        cchClusterName = wcslen( bstrClusterName );
        cchDomain = wcslen( bstrDomain );

        cchName = cchClusterName + cchDomain + 2;   // '.' + UNICODE_NULL

        TraceSysFreeString( m_bstrName );
        m_bstrName = TraceSysAllocStringLen( NULL, (UINT) cchName );
        if ( m_bstrName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            STATUS_REPORT_REF( TASKID_Major_Establish_Connection, TASKID_Minor_Initialize, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
            goto Cleanup;
        } // if:

        hr = THR( StringCchCopyW( m_bstrName, cchName, bstrClusterName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( StringCchCatW( m_bstrName, cchName, L"." ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( StringCchCatW( m_bstrName, cchName, bstrDomain ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrLoadNetworkInfo( hCluster ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

ClusterNodeDown:

        hr = STHR( HrLoadCredentials() );
        if ( SUCCEEDED( hr ) )
        {
            //
            //  If successful then use hrTemp since it may contain a more important status code.
            //
            hr = hrTemp;
            LogMsg( L"[SRV] CClusCfgClusterInfo::Initialize() returning (hr=%#08x)", hr );
        } // if:
    } // if:

Cleanup:

    TraceSysFreeString( bstrDomain );
    TraceSysFreeString( bstrClusterName );

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo -- IClusCfgClusterInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetCommitMode
//
//  Description:
//      Get the mode of processing for this node when commit changes is
//      called.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success.
//
//      E_POINTER
//          pecmCurrentModeOut is NULL.
//
//      Other Win32 error as HRESULT if a failure occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetCommitMode(
    ECommitMode * pecmCurrentModeOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pecmCurrentModeOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pecmCurrentModeOut = m_ecmCommitChangesMode;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetCommitMode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetCommitMode
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetCommitMode(
    ECommitMode ecmCurrentModeIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ecmCommitChangesMode = ecmCurrentModeIn;

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetCommitMode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_ClusterInfo_GetName_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_bstrName == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Get_Cluster_Name
                , IDS_ERROR_CLUSTER_NAME_NOT_FOUND
                , IDS_ERROR_CLUSTER_NAME_NOT_FOUND_REF
                , hr
                );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT     hr;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    TraceSysFreeString( m_bstrName );
    m_bstrName = NULL;

    m_bstrName = TraceSysAllocString( pcszNameIn );
    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetName_Cluster, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetIPAddress
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetIPAddress(
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetIPAddress, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_ulIPDottedQuad == 0 )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Get_Cluster_IP_Address
                , IDS_ERROR_CLUSTER_IP_ADDRESS_NOT_FOUND
                , IDS_ERROR_CLUSTER_IP_ADDRESS_NOT_FOUND_REF
                , hr
                );
        goto Cleanup;
    } // if:

    *pulDottedQuadOut = m_ulIPDottedQuad;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetIPAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetIPAddress
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetIPAddress(
    ULONG ulDottedQuadIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ulIPDottedQuad = ulDottedQuadIn;

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetIPAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetSubnetMask
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetSubnetMask(
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_ClusterInfo_GetSubnetMask, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_ulSubnetDottedQuad == 0 )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Get_Cluster_IP_Subnet
                , IDS_ERROR_CLUSTER_IP_SUBNET_NOT_FOUND
                , IDS_ERROR_CLUSTER_IP_SUBNET_NOT_FOUND_REF
                , hr
                );
        goto Cleanup;
    } // if:

    *pulDottedQuadOut = m_ulSubnetDottedQuad;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetSubnetMask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetSubnetMask
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetSubnetMask(
    ULONG ulDottedQuadIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ulSubnetDottedQuad = ulDottedQuadIn;

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetSubnetMask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetNetworkInfo
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetNetworkInfo(
    IClusCfgNetworkInfo ** ppiccniOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );
    Assert( m_piccniNetwork != NULL );

    HRESULT hr = S_OK;

    if ( ppiccniOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetNetworkInfo, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_piccniNetwork == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Get_Cluster_Networks
                , IDS_ERROR_CLUSTER_NETWORKS_NOT_FOUND
                , IDS_ERROR_CLUSTER_NETWORKS_NOT_FOUND_REF
                , hr
                );
        goto Cleanup;
    } // if:

    *ppiccniOut = TraceInterface( L"CClusCfgNetworkInfo", IClusCfgNetworkInfo, m_piccniNetwork, 0 );
    (*ppiccniOut)->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetNetworkInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetNetworkInfo
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetNetworkInfo(
    IClusCfgNetworkInfo * piccniIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );
    Assert( piccniIn != NULL );

    HRESULT hr = S_OK;

    if ( piccniIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    if ( m_piccniNetwork != NULL )
    {
        m_piccniNetwork->Release();
    } // if:

    m_piccniNetwork = piccniIn;
    m_piccniNetwork->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetNetworkInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetClusterServiceAccountCredentials
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetClusterServiceAccountCredentials(
    IClusCfgCredentials ** ppicccCredentialsOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT     hr;

    if ( ppicccCredentialsOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetClusterServiceAccountCredentials, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_punkServiceAccountCredentials != NULL )
    {
        hr = S_OK;
        LOG_STATUS_REPORT( L"CClusCfgClusterInfo::GetClusterServiceAccountCredentials() skipping object creation.", hr );
        goto SkipCreate;
    } // if:

    hr = THR( HrCoCreateInternalInstance(
                      CLSID_ClusCfgCredentials
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IUnknown
                    , reinterpret_cast< void ** >( &m_punkServiceAccountCredentials )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_punkServiceAccountCredentials = TraceInterface( L"CClusCfgCredentials", IUnknown, m_punkServiceAccountCredentials, 1 );

    hr = THR( HrSetInitialize( m_punkServiceAccountCredentials, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( m_punkServiceAccountCredentials, NULL ) );

SkipCreate:

    if ( SUCCEEDED( hr ) )
    {
        Assert( m_punkServiceAccountCredentials != NULL );
        hr = THR( m_punkServiceAccountCredentials->TypeSafeQI( IClusCfgCredentials, ppicccCredentialsOut ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetClusterServiceAccountCredentials


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetBindingString
//
//  Description:
//      Get the binding string for this cluster.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetBindingString(
    BSTR * pbstrBindingStringOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrBindingStringOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_ClusterInfo_GetBindingString_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_bstrBindingString == NULL )
    {
        hr = S_FALSE;
        LOG_STATUS_REPORT_MINOR(
              TASKID_Minor_GetBindingString_Binding_String_NULL
            , L"The cluster binding string is empty.  If we are adding nodes then this is not correct!"
            , hr );
        goto Cleanup;
    } // if:

    *pbstrBindingStringOut = SysAllocString( m_bstrBindingString );
    if ( *pbstrBindingStringOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetBindingString_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetBindingString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetBindingString
//
//  Description:
//      Set the binding string of this cluster.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetBindingString(
    LPCWSTR pcszBindingStringIn
    )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszBindingStringIn = '%ls'", pcszBindingStringIn == NULL ? L"<null>" : pcszBindingStringIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    //
    //  When creating a cluster there is no cluster binding string.  Therefore it is reasonable
    //  to accept a NULL string as the passed in parameter.
    //
    if ( pcszBindingStringIn == NULL )
    {
        hr = S_FALSE;
        TraceSysFreeString( m_bstrBindingString );
        m_bstrBindingString = NULL;
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetBindingString_Cluster, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = bstr;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetBindingString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetMaxNodeCount
//
//  Description:
//      Get the maximum number of nodes supported in this cluster.
//
//  Arguments:
//      pcMaxNodesOut
//
//  Return Value:
//      S_OK
//          Success;
//
//      E_POINTER
//          pcMaxNodesOut is NULL.
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetMaxNodeCount(
    DWORD * pcMaxNodesOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRETURN( STHR( HrGetMaxNodeCount( pcMaxNodesOut ) ) );

} //*** CClusCfgClusterInfo::GetMaxNodeCount


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo class -- IClusCfgSetClusterNodeInfo Interfaces.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetClusterNodeInfo
//
//  Description:
//      Suck some info off of the passed in node info object.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetClusterNodeInfo(
    IClusCfgNodeInfo * pNodeInfoIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );
    Assert( pNodeInfoIn != NULL );

    HRESULT hr = S_FALSE;

    if ( pNodeInfoIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    hr = STHR( pNodeInfoIn->IsMemberOfCluster() );
    if ( hr == S_OK )
    {
        m_fIsClusterNode = true;
    } // if:
    else if ( hr == S_FALSE )
    {
        m_fIsClusterNode = false;
        hr = S_OK;
    } // else if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetClusterNodeInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo class -- IClusCfgClusterInfoEx Interfaces.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::CheckJoiningNodeVersion
//
//  Description:
//      Check a joining node's version information against that of the cluster.
//
//  Arguments:
//      dwNodeHighestVersionIn
//      dwNodeLowestVersionIn
//
//  Return Value:
//      S_OK
//          The joining node is compatible.
//
//      HRESULT_FROM_WIN32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS )
//          The joining node is NOT compatible.
//
//      Other HRESULT errors.
//
//  Remarks:
//
// Get and verify the sponsor version
//
//
// From Whistler onwards, CsRpcGetJoinVersionData() will return a failure code in its last parameter
// if the version of this node is not compatible with the sponsor version. Prior to this, the last
// parameter always contained a success value and the cluster versions had to be compared subsequent to this
// call. This will, however, still have to be done as long as interoperability with Win2K
// is a requirement, since Win2K sponsors do not return an error in the last parameter.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::CheckJoiningNodeVersion(
      DWORD    dwNodeHighestVersionIn
    , DWORD    dwNodeLowestVersionIn
    )
{
    TraceFunc( "[IClusCfgClusterInfoEx]" );

    HRESULT hr = S_OK;

    hr = THR( HrCheckJoiningNodeVersion(
          NULL
        , dwNodeHighestVersionIn
        , dwNodeLowestVersionIn
        , m_picccCallback
        ) );

    HRETURN( hr );

} //*** CClusCfgClusterInfo::CheckJoiningNodeVersion


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetNodeNames
//
//  Description:
//      Retrieve the names of the nodes currently in the cluster.
//
//  Parameters:
//      pnCountOut
//          On success, *pnCountOut returns the number of nodes in the cluster.
//
//      prgbstrNodeNamesOut
//          On success, an array of BSTRs containing the node names.
//          The caller must free each BSTR with SysFreeString, and free
//          the array with CoTaskMemFree.
//
//  Return Values:
//      S_OK
//          The out parameters contain valid information and the caller
//          must free the array and the BSTRs it contains.
//
//      E_OUTOFMEMORY, and other failures are possible.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetNodeNames(
      long *   pnCountOut
    , BSTR **  prgbstrNodeNamesOut
    )
{
    TraceFunc( "[IClusCfgClusterInfoEx]" );

    HRESULT     hr = S_OK;
    HCLUSTER    hCluster = NULL;

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        DWORD scLastError = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scLastError );
        goto Cleanup;
    } // if

    hr = THR( HrGetNodeNames(
          hCluster
        , pnCountOut
        , prgbstrNodeNamesOut
        ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetNodeNames



//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    m_bstrName = TraceSysAllocString( L"\0" );
    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrInit, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrLoadNetworkInfo
//
//  Description:
//      Load the cluster network info...
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrLoadNetworkInfo(
    HCLUSTER hClusterIn
    )
{
    TraceFunc( "" );
    Assert( hClusterIn != NULL );

    HRESULT     hr = S_OK;
    DWORD       sc;
    HRESOURCE   hIPAddress = NULL;

    sc = TW32( ResUtilGetCoreClusterResources( hClusterIn, NULL, &hIPAddress, NULL ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    Assert( hIPAddress != NULL );

    hr = THR( HrGetIPAddressInfo( hIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    LOG_STATUS_REPORT_MINOR( TASKID_Minor_Server_LoadNetwork_Info, L"LoadNetworkInfo() completed.", hr );

    if ( hIPAddress != NULL )
    {
        CloseClusterResource( hIPAddress );
    } // if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrLoadNetworkInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrGetIPAddressInfo
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrGetIPAddressInfo(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResIn
    )
{
    TraceFunc( "" );
    Assert( hClusterIn != NULL );
    Assert( hResIn != NULL );

    HRESULT     hr = S_FALSE;
    DWORD       sc;
    HRESENUM    hEnum = NULL;
    DWORD       idx;
    WCHAR *     psz = NULL;
    DWORD       cchpsz = 33;
    DWORD       dwType;
    HRESOURCE   hRes = NULL;

    hEnum = ClusterResourceOpenEnum( hResIn, CLUSTER_RESOURCE_ENUM_DEPENDS );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    psz = new WCHAR [ cchpsz ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; )
    {
        sc = TW32( ClusterResourceEnum( hEnum, idx, &dwType, psz, &cchpsz ) );
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            break;
        } // if:

        if ( sc == ERROR_MORE_DATA )
        {
            delete [] psz;
            psz = NULL;

            cchpsz++;

            psz = new WCHAR [ cchpsz ];
            if ( psz == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            hRes = OpenClusterResource( hClusterIn, psz );
            if ( hRes == NULL )
            {
                sc = TW32( GetLastError() );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            } // if:

            hr = STHR( HrIsResourceOfType( hRes, L"IP Address" ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                hr = THR( HrGetIPAddressInfo( hRes ) );             // not recursive!
                break;
            } // if:

            CloseClusterResource( hRes );
            hRes = NULL;

            idx++;
            continue;
        } // if:

        hr = THR( HRESULT_FROM_WIN32( sc ) );       // must be an error!
        goto Cleanup;
    } // for:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrGetIPAddressInfo, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );

Cleanup:

    LOG_STATUS_REPORT_MINOR( TASKID_Minor_Server_Get_ClusterIPAddress_Info_2, L"GetIPAddressInfo() completed.", hr );

    delete [] psz;

    if ( hRes != NULL )
    {
        CloseClusterResource( hRes );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterResourceCloseEnum( hEnum );
    } // if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrGetIPAddressInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrGetIPAddressInfo
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrGetIPAddressInfo(
    HRESOURCE hResIn
    )
{
    TraceFunc( "" );
    Assert( hResIn != NULL );

    HRESULT hr = S_OK;
    DWORD   sc;
    ULONG   ulNetwork;
    WCHAR * psz = NULL;
    BSTR    bstrNetworkName = NULL;

    hr = THR( ::HrGetIPAddressInfo( hResIn, &m_ulIPDottedQuad, &m_ulSubnetDottedQuad, &bstrNetworkName ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT_MINOR( TASKID_Minor_Server_Get_IPAddressResource_Info, L"Could not get the IP address info.", hr );
        goto Cleanup;
    } // if:

    sc = TW32( ClRtlTcpipAddressToString( m_ulIPDottedQuad, &psz ) ); // KB: Allocates to psz using LocalAlloc().
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LOG_STATUS_REPORT_MINOR( TASKID_Minor_Server_Convert_ClusterIPAddress_To_String, L"Could not convert the Cluster IP address to a string.", hr );
        goto Cleanup;
    } // if:

    m_bstrBindingString = TraceSysAllocString( psz );
    if ( m_bstrBindingString == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    LocalFree( psz );
    psz = NULL;

    LOG_STATUS_REPORT_STRING( L"Cluster binding string is '%1!ws!'.", m_bstrBindingString, hr );

    ulNetwork = m_ulIPDottedQuad & m_ulSubnetDottedQuad;

    sc = TW32( ClRtlTcpipAddressToString( ulNetwork, &psz ) ); // KB: Allocates to psz using LocalAlloc().
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LOG_STATUS_REPORT_MINOR( TASKID_Minor_Server_Convert_Network_To_String, L"Could not convert the network address to a string.", hr );
        goto Cleanup;
    } // if:

    hr = THR( HrFindNetworkInfo( bstrNetworkName, psz ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT_STRING_MINOR2( TASKID_Minor_Server_Find_Network, L"Could not find network %1!ws! with address %2!ws!.", bstrNetworkName, psz, hr );
        goto Cleanup;
    } // if:

Cleanup:

    LOG_STATUS_REPORT_MINOR( TASKID_Minor_Server_Get_ClusterIPAddress_Info, L"GetIPAddressInfo() completed.", hr );

    LocalFree( psz );                              // KB: Don't use TraceFree() here! PREFAST may complain but their complaint is bogus.

    TraceSysFreeString( bstrNetworkName );

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrGetIPAddressInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrFindNetworkInfo
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrFindNetworkInfo(
    const WCHAR * pszNetworkNameIn,
    const WCHAR * pszNetworkIn
    )
{
    TraceFunc( "" );
    Assert( pszNetworkNameIn != NULL );
    Assert( pszNetworkIn != NULL );

    HRESULT                 hr;
    IUnknown *              punk = NULL;
    IEnumClusCfgNetworks *  pieccn = NULL;
    ULONG                   cFetched;
    IClusCfgNetworkInfo *   piccni = NULL;
    BSTR                    bstrNetworkName = NULL;
    BSTR                    bstrNetwork = NULL;

    hr = THR( HrCreateNetworksEnum( m_picccCallback, m_lcid, m_pIWbemServices, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &pieccn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        hr = pieccn->Next( 1, &piccni, &cFetched );
        if ( ( hr == S_OK ) && ( cFetched == 1 ) )
        {
            hr = THR( piccni->GetName( &bstrNetworkName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            TraceMemoryAddBSTR( bstrNetworkName );

            hr = THR( piccni->GetUID( &bstrNetwork ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            TraceMemoryAddBSTR( bstrNetwork );

            if ( ( wcscmp( pszNetworkNameIn, bstrNetworkName ) == 0 ) && ( ClRtlStrICmp( pszNetworkIn, bstrNetwork ) == 0 ) )
            {
                if ( m_piccniNetwork != NULL )
                {
                    m_piccniNetwork->Release();
                    m_piccniNetwork = NULL;
                } // if:

                m_piccniNetwork = piccni;
                m_piccniNetwork->AddRef();

                break;
            } // if:

            piccni->Release();
            piccni = NULL;

            TraceSysFreeString( bstrNetworkName );
            bstrNetworkName = NULL;

            TraceSysFreeString( bstrNetwork );
            bstrNetwork = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( cFetched == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            goto Cleanup;
        } // else:
    } // for:

    //
    //  If we didn't find the cluster network in the WMI list of networks then we have a problem.
    //

    Assert( m_piccniNetwork != NULL );
    if ( m_piccniNetwork == NULL )
    {
        hr = THR( ERROR_NETWORK_NOT_AVAILABLE );
        STATUS_REPORT_STRING_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Cluster_Network_Not_Found
                , IDS_ERROR_CLUSTER_NETWORK_NOT_FOUND
                , pszNetworkIn
                , IDS_ERROR_CLUSTER_NETWORK_NOT_FOUND_REF
                , hr
                );
    } // if:

Cleanup:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    if ( pieccn != NULL )
    {
        pieccn->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrNetworkName );
    TraceSysFreeString( bstrNetwork );

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrFindNetworkInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrLoadCredentials
//
//  Description:
//
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK    - Operation completed successfully.
//      S_FALSE - Nothing was done (cluster service doesn't exist).
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrLoadCredentials( void )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    SC_HANDLE                   schSCM = NULL;
    SC_HANDLE                   schClusSvc = NULL;
    DWORD                       sc;
    DWORD                       cbRequired;
    QUERY_SERVICE_CONFIG *      pqsc = NULL;
    DWORD                       cbqsc = 128;
    IClusCfgCredentials *       piccc = NULL;
    IClusCfgSetCredentials *    piccsc = NULL;

    schSCM = OpenSCManager( NULL, NULL, GENERIC_READ );
    if ( schSCM == NULL )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    } // if:

    schClusSvc = OpenService( schSCM, L"ClusSvc", GENERIC_READ );
    if ( schClusSvc == NULL )
    {
        sc = GetLastError();
        if ( sc == ERROR_SERVICE_DOES_NOT_EXIST )
        {
            hr = S_FALSE;
            LogMsg( "[SRV] CClusCfgClusterInfo::HrLoadCredentials() - The cluster service does not exist." );
            goto Cleanup;
        }

        TW32( sc );
        goto Win32Error;
    } // if:

    for ( ; ; )
    {
        pqsc = (QUERY_SERVICE_CONFIG *) TraceAlloc( 0, cbqsc );
        if ( pqsc == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrLoadCredentials, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
            goto Cleanup;
        } // if:

        if ( !QueryServiceConfig( schClusSvc, pqsc, cbqsc, &cbRequired ) )
        {
            sc = GetLastError();
            if ( sc == ERROR_INSUFFICIENT_BUFFER )
            {
                TraceFree( pqsc );
                pqsc = NULL;
                cbqsc = cbRequired;
                continue;
            } // if:
            else
            {
                TW32( sc );
                goto Win32Error;
            } // else:
        } // if:
        else
        {
            break;
        } // else:
    } // for:

    Assert( m_punkServiceAccountCredentials == NULL );

    hr = THR( GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccc->TypeSafeQI( IClusCfgSetCredentials, &piccsc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccsc->SetDomainCredentials( pqsc->lpServiceStartName ) );

    goto Cleanup;

Win32Error:

    hr = HRESULT_FROM_WIN32( sc );

Cleanup:

    if ( schClusSvc != NULL )
    {
        CloseServiceHandle( schClusSvc );
    } // if:

    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
    } // if:

    if ( pqsc != NULL )
    {
        TraceFree( pqsc );
    } // if:

    if ( piccc != NULL )
    {
        piccc->Release();
    } // if:

    if ( piccsc != NULL )
    {
        piccsc->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrLoadCredentials
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgcallback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCallback.h
//
//  Description:
//      This file contains the declaration of the CClusCfgCallback
//      class.
//
//      The class CClusCfgCallback inplements the callback
//      interface between this server and its clients.  It implements the
//      IClusCfgCallback interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgCallback.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

#include <ClusCfgDef.h>


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <ClusCfgPrivate.h>
#include "PrivateInterfaces.h"

// For ILogger
#include <ClusCfgClient.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////

//
//  Timeout for when ClusCfgCallback on the server is waiting for the client
//  to pick up the queued status report.
//

const DWORD CCC_WAIT_TIMEOUT = CC_DEFAULT_TIMEOUT;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgCallback
//
//  Description:
//      The class CClusCfgCallback inplements the callback
//      interface between this server and its clients.
//
//  Interfaces:
//      IClusCfgCallback
//      IClusCfgInitialize
//      IClusCfgPollingCallback
//      IClusCfgSetPollingCallback
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgCallback
    : public IClusCfgCallback
    , public IClusCfgInitialize
    , public IClusCfgPollingCallback
    , public IClusCfgSetPollingCallback
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    IClusCfgCallback *  m_pccc;
    LCID                m_lcid;
    HANDLE              m_hEvent;
    HRESULT             m_hr;
    BOOL                m_fPollingMode;
    BSTR                m_bstrNodeName;

    LPCWSTR             m_pcszNodeName;
    CLSID *             m_pclsidTaskMajor;
    CLSID *             m_pclsidTaskMinor;
    ULONG *             m_pulMin;
    ULONG *             m_pulMax;
    ULONG *             m_pulCurrent;
    HRESULT *           m_phrStatus;
    LPCWSTR             m_pcszDescription;
    FILETIME *          m_pftTime;
    LPCWSTR             m_pcszReference;
    ILogger *           m_plLogger;             // ILogger for doing logging.

//
//  Since actually hitting a stalling RPC problem is rare and hard I decided to write code
//  that would simulate that failure.  These variables are used for that purpose.
//

#if defined( DEBUG ) && defined( CCS_SIMULATE_RPC_FAILURE )
    int                 m_cMessages;            // How many messages have gone through.
    bool                m_fDoFailure;           // When true forces an RPC error.
#endif

    // Private constructors and destructors
    CClusCfgCallback( void );
    ~CClusCfgCallback( void );

    // Private copy constructor to prevent copying.
    CClusCfgCallback( const CClusCfgCallback & rcccSrcIn );

    // Private assignment operator to prevent copying.
    CClusCfgCallback & operator = ( const CClusCfgCallback & rcccSrcIn );

    HRESULT HrInit( void );
    HRESULT HrQueueStatusReport(
                    LPCWSTR     pcszNodeNameIn,
                    CLSID       clsidTaskMajorIn,
                    CLSID       clsidTaskMinorIn,
                    ULONG       ulMinIn,
                    ULONG       ulMaxIn,
                    ULONG       ulCurrentIn,
                    HRESULT     hrStatusIn,
                    LPCWSTR     pcszDescriptionIn,
                    FILETIME *  pftTimeIn,
                    LPCWSTR     pcszReferenceIn
                    );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    STDMETHOD( SendStatusReport )(
                    CLSID           clsidTaskMajorIn,
                    CLSID           clsidTaskMinorIn,
                    ULONG           ulMinIn,
                    ULONG           ulMaxIn,
                    ULONG           ulCurrentIn,
                    HRESULT         hrStatusIn,
                    const WCHAR *   pcszDescriptionIn
                    );

    STDMETHOD( SendStatusReport )(
                    CLSID           clsidTaskMajorIn,
                    CLSID           clsidTaskMinorIn,
                    ULONG           ulMinIn,
                    ULONG           ulMaxIn,
                    ULONG           ulCurrentIn,
                    HRESULT         hrStatusIn,
                    DWORD           dwDescriptionIn
                    );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgCallback Interfaces.
    //

    STDMETHOD( SendStatusReport )(
                    LPCWSTR     pcszNodeNameIn,
                    CLSID       clsidTaskMajorIn,
                    CLSID       clsidTaskMinorIn,
                    ULONG       ulMinIn,
                    ULONG       ulMaxIn,
                    ULONG       ulCurrentIn,
                    HRESULT     hrStatusIn,
                    LPCWSTR     pcszDescriptionIn,
                    FILETIME *  pftTimeIn,
                    LPCWSTR     pcszReference
                    );

    //
    // IClusCfgPollingCallback Interfaces.
    //

    STDMETHOD( GetStatusReport )(
                    BSTR *      pbstrNodeNameOut,
                    CLSID *     pclsidTaskMajorOut,
                    CLSID *     pclsidTaskMinorOut,
                    ULONG *     pulMinOut,
                    ULONG *     pulMaxOut,
                    ULONG *     pulCurrentOut,
                    HRESULT *   phrStatusOut,
                    BSTR *      pbstrDescriptionOut,
                    FILETIME *  pftTimeOut,
                    BSTR *      pbstrReferenceOut
                    );

    STDMETHOD( SetHResult )( HRESULT hrIn );

    //
    // IClusCfgInitialize Interfaces.
    //

    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgSetPollingCallback Interfaces.
    //

    STDMETHOD( SetPollingMode )( BOOL fUsePollingModeIn );

}; //*** Class CClusCfgCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgipaddressinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgIPAddressInfo.h
//
//  Description:
//      This file contains the declaration of the CClusCfgIPAddressInfo
//      class.
//
//      The class CClusCfgIPAddressInfo is the representation of a
//      cluster manageable IP address. It implements the IClusCfgIPAddressInfo
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAR-2000
//
//  Remarks:
//      None.
//
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgIPAddressInfo
//
//  Description:
//      The class CClusCfgIPAddressInfo is the enumeration of
//      cluster manageable devices.
//
//  Interfaces:
//      IClusCfgIPAddressInfo
//      IClusCfgWbemServices
//      IEnumClusCfgIPAddresses
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgIPAddressInfo
    : public IClusCfgIPAddressInfo
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    IWbemServices *     m_pIWbemServices;
    ULONG               m_ulIPAddress;
    ULONG               m_ulIPSubnet;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;

    // Private constructors and destructors
    CClusCfgIPAddressInfo( void );
    ~CClusCfgIPAddressInfo( void );

    // Private copy constructor to prevent copying.
    CClusCfgIPAddressInfo( const CClusCfgIPAddressInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgIPAddressInfo & operator = ( const CClusCfgIPAddressInfo & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrInit( ULONG ulIPAddressIn, ULONG IPSubnetIn );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrCreateInstance( ULONG ulIPAddressIn, ULONG IPSubnetIn, IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgIPAddressInfo Interfaces.
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetIPAddress )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetIPAddress )( ULONG ulDottedQuadIn );

    STDMETHOD( GetSubnetMask )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetSubnetMask )( ULONG ulDottedQuadIn );

}; //*** Class CClusCfgIPAddressInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgcapabilities.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCapabilities.h
//
//  Description:
//      This file contains the declaration of the  CClusCfgCapabilities
//      class.
//
//      The class CClusCfgCapabilities is the implementations of the
//      IClusCfgCapabilities interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgCapabilities.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgCapabilities
//
//  Description:
//      The class CClusCfgCapabilities is the server that provides the
//      functionality to form a cluster and join additional nodes to a cluster.
//
//  Interfaces:
//      IClusCfgCapabilities
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgCapabilities
    : public IClusCfgInitialize
    , public IClusCfgCapabilities
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fCanBeClustered;

    // Private constructors and destructors
    CClusCfgCapabilities( void );
     ~CClusCfgCapabilities( void );

    // Private copy constructor to prevent copying.
    CClusCfgCapabilities( const CClusCfgCapabilities & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgCapabilities & operator = ( const CClusCfgCapabilities & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrCheckForSFM( void );
    HRESULT HrIsOSVersionValid( void );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    //  IClusCfgInitialize
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    //  IClusCfgCapabilities
    //

    STDMETHOD( CanNodeBeClustered )( void );

}; //*** Class CClusCfgCapabilities
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgipaddressinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgIPAddressInfo.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgIPAddressInfo
//       class.
//
//      The class CClusCfgIPAddressInfo represents a cluster manageable
//      network. It implements the IClusCfgIPAddressInfo interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CClusCfgIPAddressInfo.h"
#include <ClusRtl.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgIPAddressInfo" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgIPAddressInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusCfgIPAddressInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgIPAddressInfo::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );

    HRESULT                 hr = S_OK;
    CClusCfgIPAddressInfo * pccipai = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccipai = new CClusCfgIPAddressInfo();
    if ( pccipai == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccipai->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccipai->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgIPAddressInfo::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccipai != NULL )
    {
        pccipai->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgIPAddressInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusCfgIPAddressInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgIPAddressInfo::S_HrCreateInstance(
      ULONG         ulIPAddressIn
    , ULONG         ulIPSubnetIn
    , IUnknown **   ppunkOut
    )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );
    Assert( ulIPAddressIn != 0 );
    Assert( ulIPSubnetIn != 0 );

    HRESULT                 hr = S_OK;
    CClusCfgIPAddressInfo * pccipai = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccipai = new CClusCfgIPAddressInfo();
    if ( pccipai == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccipai->HrInit( ulIPAddressIn, ulIPSubnetIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccipai->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgIPAddressInfo::S_HrCreateInstance( ULONG, ULONG ) failed. (hr = %#08x)", hr );
    } // if:

    if ( pccipai != NULL )
    {
        pccipai->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::CClusCfgIPAddressInfo
//
//  Description:
//      Constructor of the CClusCfgIPAddressInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgIPAddressInfo::CClusCfgIPAddressInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_ulIPAddress == 0 );
    Assert( m_ulIPSubnet == 0 );
    Assert( m_pIWbemServices == NULL );
    Assert( m_picccCallback == NULL );

    TraceFuncExit();

} //*** CClusCfgIPAddressInfo::CClusCfgIPAddressInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::~CClusCfgIPAddressInfo
//
//  Description:
//      Desstructor of the CClusCfgIPAddressInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgIPAddressInfo::~CClusCfgIPAddressInfo( void )
{
    TraceFunc( "" );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgIPAddressInfo::~CClusCfgIPAddressInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgIPAddressInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    CRETURN( m_cRef );

} //*** CClusCfgIPAddressInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgIPAddressInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CClusCfgIPAddressInfo::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgIPAddressInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgIPAddressInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgIPAddressInfo, this, 0 );
    } // else if: IClusCfgIPAddressInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgWbemServices ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
    } // else if: IClusCfgWbemServices
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

     QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusCfgIPAddressInfo::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_IPAddress, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo class -- IClusCfgIPAddressInfo interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::GetUID
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );
    Assert( m_ulIPAddress != 0 );
    Assert( m_ulIPSubnet != 0 );

    HRESULT hr = S_OK;
    ULONG   ulNetwork = ( m_ulIPAddress & m_ulIPSubnet );
    LPWSTR  psz = NULL;
    DWORD   sc;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_IPAddressInfo_GetUID_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    sc = ClRtlTcpipAddressToString( ulNetwork, &psz ); // KB: Allocates to psz using LocalAlloc().
    if ( sc != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( sc ) );
        LOG_STATUS_REPORT( L"CClusCfgIPAddressInfo::GetUID() ClRtlTcpipAddressToString() failed.", hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( psz );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_IPAddressInfo_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

Cleanup:

    if ( psz != NULL )
    {
        LocalFree( psz );                              // KB: Don't use TraceFree() here!
    } // if:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::GetIPAddress
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::GetIPAddress( ULONG * pulDottedQuadOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = S_OK;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetNetworkGetIPAddress, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pulDottedQuadOut = m_ulIPAddress;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::GetIPAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::SetIPAddress
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::SetIPAddress( ULONG ulDottedQuadIn )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = S_OK;

    if ( ulDottedQuadIn == 0  )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    m_ulIPAddress = ulDottedQuadIn;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::SetIPAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::GetSubnetMask
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::GetSubnetMask( ULONG * pulDottedQuadOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = S_OK;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetSubnetMask, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pulDottedQuadOut = m_ulIPSubnet;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::GetSubnetMask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::SetSubnetMask
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::SetSubnetMask( ULONG ulDottedQuadIn )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = S_OK;

    if ( ulDottedQuadIn == 0  )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    m_ulIPSubnet = ulDottedQuadIn;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::SetSubnetMask

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgIPAddressInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      ulIPAddressIn
//      ulIPSubnetIn
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgIPAddressInfo::HrInit( ULONG ulIPAddressIn, ULONG ulIPSubnetIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    m_ulIPAddress = ulIPAddressIn;
    m_ulIPSubnet = ulIPSubnetIn;

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::HrInit( ulIPAddressIn, ulIPSubnetIn )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgclusterinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgClusterInfo.h
//
//  Description:
//      This file contains the declaration of the CClusCfgClusterInfo
//      class.
//
//      The class CClusCfgClusterInfo is the representation of a
//      computer that can be a cluster node. It implements the
//      IClusCfgClusterInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgClusterInfo.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgClusterInfo
//
//  Description:
//      The class CClusCfgClusterInfo is the representation of a
//      cluster.
//
//  Interfaces:
//      IClusCfgClusterInfo
//      IClusCfgInitialize
//      IClusCfgSetClusterNodeInfo
//      IClusCfgWbemServices
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgClusterInfo
    : public IClusCfgClusterInfo
    , public IClusCfgInitialize
    , public IClusCfgSetClusterNodeInfo
    , public IClusCfgWbemServices
    , public IClusCfgClusterInfoEx
{
private:

    //
    // Private member functions and data
    //

    LONG                    m_cRef;
    LCID                    m_lcid;
    IClusCfgCallback *      m_picccCallback;
    BSTR                    m_bstrName;
    ULONG                   m_ulIPDottedQuad;
    ULONG                   m_ulSubnetDottedQuad;
    IClusCfgNetworkInfo *   m_piccniNetwork;
    IUnknown *              m_punkServiceAccountCredentials;
    IWbemServices *         m_pIWbemServices;
    ECommitMode             m_ecmCommitChangesMode;
    BOOL                    m_fIsClusterNode;
    BSTR                    m_bstrBindingString;

    // Private constructors and destructors
    CClusCfgClusterInfo( void );
    ~CClusCfgClusterInfo( void );

    // Private copy constructor to prevent copying.
    CClusCfgClusterInfo( const CClusCfgClusterInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgClusterInfo & operator = ( const CClusCfgClusterInfo & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrLoadNetworkInfo( HCLUSTER hClusterIn );
    HRESULT HrGetIPAddressInfo( HCLUSTER hClusterIn, HRESOURCE hResIn );
    HRESULT HrGetIPAddressInfo( HRESOURCE hResIn );
    HRESULT HrFindNetworkInfo( const WCHAR * pszNetworkNameIn, const WCHAR * pszNetworkIn );
    HRESULT HrLoadCredentials( void );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgIntialize Interfaces.
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgClusterInfo Interfaces.
    //

    STDMETHOD( SetCommitMode )( ECommitMode ecmNewModeIn );

    STDMETHOD( GetCommitMode )( ECommitMode * pecmCurrentModeOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR bstrNameIn );

    STDMETHOD( GetIPAddress )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetIPAddress )( ULONG ulDottedQuadIn );

    STDMETHOD( GetSubnetMask )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetSubnetMask )( ULONG ulDottedQuadIn );

    STDMETHOD( GetNetworkInfo )( IClusCfgNetworkInfo ** ppiccniOut );

    STDMETHOD( SetNetworkInfo )( IClusCfgNetworkInfo * piccniIn );

    STDMETHOD( GetClusterServiceAccountCredentials )( IClusCfgCredentials ** ppicccCredentialsOut );

    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );

    STDMETHOD( SetBindingString )( LPCWSTR bstrBindingStringIn );

    STDMETHOD( GetMaxNodeCount )( DWORD * pcMaxNodesOut );

    //
    // IClusCfgClusterInfoEx Interfaces.
    //

    STDMETHOD( CheckJoiningNodeVersion )( DWORD dwNodeHighestVersionIn, DWORD dwNodeLowestVersionIn );

    STDMETHOD( GetNodeNames )( long * pnCountOut, BSTR ** prgbstrNodeNamesOut );
        
    //
    // IClusCfgSetClusterNodeInfo Interfaces.
    //

    STDMETHOD( SetClusterNodeInfo )( IClusCfgNodeInfo * pNodeInfoIn );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

}; //*** Class CClusCfgClusterInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgnetworkinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgNetworkInfo.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgNetworkInfo
//       class.
//
//      The class CClusCfgNetworkInfo represents a cluster manageable
//      network. It implements the IClusCfgNetworkInfo interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include <PropList.h>
#include <ClusRtl.h>
#include "CClusCfgNetworkInfo.h"
#include "CEnumClusCfgIPAddresses.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgNetworkInfo" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgNetworkInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusCfgNetworkInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CClusCfgNetworkInfo *   pccni = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccni = new CClusCfgNetworkInfo();
    if ( pccni == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccni->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccni->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgNetworkInfo::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccni != NULL )
    {
        pccni->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgNetworkInfo instance.
//
//  Arguments:
//
//
//  Return Values:
//      Pointer to CClusCfgNetworkInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::S_HrCreateInstance(
      HNETWORK          hNetworkIn
    , HNETINTERFACE     hNetInterfaceIn
    , IUnknown *        punkCallbackIn
    , LCID              lcidIn
    , IWbemServices *   pIWbemServicesIn
    , IUnknown **       ppunkOut
    )
{
    TraceFunc( "" );
    Assert( hNetworkIn != NULL );
    Assert( ppunkOut != NULL );

    HRESULT                 hr = S_OK;
    CClusCfgNetworkInfo *   pccni = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    LogMsg( L"[SRV] Creating NetworkInfo object from a cluster network." );

    pccni = new CClusCfgNetworkInfo();
    if ( pccni == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccni->Initialize( punkCallbackIn, lcidIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccni->SetWbemServices( pIWbemServicesIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccni->HrInit( hNetworkIn, hNetInterfaceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccni->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI succeeded

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgNetworkInfo::S_HrCreateInstance( HRESOURCE ) failed. (hr = %#08x)", hr );
    } // if:

    if ( pccni != NULL )
    {
        pccni->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::CClusCfgNetworkInfo
//
//  Description:
//      Constructor of the CClusCfgNetworkInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgNetworkInfo::CClusCfgNetworkInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_pIWbemServices == NULL );
    Assert( m_dwFlags  == 0 );
    Assert( m_bstrName == NULL );
    Assert( m_bstrDescription == NULL );
    Assert( m_bstrDeviceID == NULL );
    Assert( m_punkAddresses == NULL );
    Assert( m_bstrConnectionName == NULL );
    Assert( m_picccCallback == NULL );
    Assert( !m_fIsClusterNetwork );

    TraceFuncExit();

} //*** CClusCfgNetworkInfo::CClusCfgNetworkInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::~CClusCfgNetworkInfo
//
//  Description:
//      Desstructor of the CClusCfgNetworkInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgNetworkInfo::~CClusCfgNetworkInfo( void )
{
    TraceFunc( "" );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_punkAddresses != NULL )
    {
        m_punkAddresses->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrDescription );
    TraceSysFreeString( m_bstrDeviceID );
    TraceSysFreeString( m_bstrConnectionName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgNetworkInfo::~CClusCfgNetworkInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgNetworkInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    CRETURN( m_cRef );

} //*** CClusCfgNetworkInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgNetworkInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CClusCfgNetworkInfo::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgNetworkInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgNetworkInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgNetworkInfo, this, 0 );
    } // else if: IClusCfgNetworkInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgWbemServices ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
    } // else if: IClusCfgWbemServices
    else if ( IsEqualIID( riidIn, IID_IClusCfgSetWbemObject ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgSetWbemObject, this, 0 );
    } // else if: IClusCfgSetWbemObject
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgIPAddresses ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgIPAddresses, this, 0 );
    } // else if: IEnumClusCfgIPAddresses
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgClusterNetworkInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgClusterNetworkInfo, this, 0 );
    } // else if: IClusCfgClusterNetworkInfo
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

     QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusCfgNetworkInfo::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Network, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo -- IClusCfgSetWbemObject interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetWbemObject
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetWbemObject(
      IWbemClassObject *    pNetworkAdapterIn
    , bool *                pfRetainObjectOut
    )
{
    TraceFunc( "[IClusCfgSetWbemObject]" );
    Assert( pNetworkAdapterIn != NULL );
    Assert( pfRetainObjectOut != NULL );

    HRESULT hr = S_OK;
    VARIANT var;

    VariantInit( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"Description", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrDescription = TraceSysAllocString( var.bstrVal );
    if ( m_bstrDescription == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"Name", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrName = TraceSysAllocString( var.bstrVal );
    if ( m_bstrName == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrDeviceID = TraceSysAllocString( var.bstrVal );
    if ( m_bstrDeviceID == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"NetConnectionID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrConnectionName = TraceSysAllocString( var.bstrVal );
    if ( m_bstrConnectionName == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = STHR( HrLoadEnum( pNetworkAdapterIn, pfRetainObjectOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemObject_Network, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );

Cleanup:

    LOG_STATUS_REPORT_STRING( L"Created network adapter '%1!ws!'", ( m_bstrConnectionName != NULL ) ? m_bstrConnectionName : L"<Unknown>", hr );

    VariantClear( &var );

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetWbemObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo -- IClusCfgNetworkInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::GetUID(
    BSTR * pbstrUIDOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                 hr;
    IClusCfgIPAddressInfo * piccipi = NULL;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetUID, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = STHR( GetPrimaryNetworkAddress( &piccipi ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // When there is not a primary network address, we goto cleanup
    //
    if ( ( piccipi == NULL ) && ( hr == S_FALSE ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccipi->GetUID( pbstrUIDOut ) );

Cleanup:

    if ( piccipi != NULL )
    {
        piccipi->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_bstrConnectionName != NULL );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_NetworkInfo_GetName_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrConnectionName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgNetworkInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::GetDescription
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::GetDescription( BSTR * pbstrDescriptionOut )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_bstrDescription != NULL );

    HRESULT hr = S_OK;

    if ( pbstrDescriptionOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_NetworkInfo_GetDescription_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pbstrDescriptionOut = SysAllocString( m_bstrDescription );
    if ( *pbstrDescriptionOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_NetworkInfo_GetDescription_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::GetDescription


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetDescription
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetDescription( LPCWSTR pcszDescriptionIn )
{
    TraceFunc1( "[IClusCfgNetworkInfo] pcszDescriptionIn = '%ls'", pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetDescription


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::GetPrimaryNetworkAddress
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::GetPrimaryNetworkAddress(
    IClusCfgIPAddressInfo ** ppIPAddressOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr;
    ULONG                       cFetched;

    hr = STHR( HrGetPrimaryNetworkAddress( ppIPAddressOut, &cFetched ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( ( hr == S_FALSE ) && ( cFetched == 0 ) )
    {
        STATUS_REPORT_STRING_REF(
              TASKID_Major_Find_Devices
            , TASKID_Minor_Primary_IP_Address
            , IDS_ERROR_PRIMARY_IP_NOT_FOUND
            , m_bstrConnectionName
            , IDS_ERROR_PRIMARY_IP_NOT_FOUND_REF
            , hr
            );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::GetPrimaryNetworkAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetPrimaryNetworkAddress
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetPrimaryNetworkAddress(
    IClusCfgIPAddressInfo * pIPAddressIn
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetPrimaryNetworkAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::IsPublic
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The network is public -- client traffic only.
//
//      S_FALSE
//          The network is not public -- has cluster and client traffic.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::IsPublic( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_dwFlags & eIsPublic )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::IsPublic


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetPublic
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetPublic( BOOL fIsPublicIn )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_OK;

    if ( fIsPublicIn )
    {
        m_dwFlags |= eIsPublic;
    } // if:
    else
    {
        m_dwFlags &= ~eIsPublic;
    } // else:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetPublic


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::IsPrivate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The network is private -- no client traffic.
//
//      S_FALSE
//          The network is not private -- has client traffic.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::IsPrivate( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_dwFlags & eIsPrivate )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::IsPrivate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetPrivate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetPrivate( BOOL fIsPrivateIn )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_OK;

    if ( fIsPrivateIn )
    {
        m_dwFlags |= eIsPrivate;
    } // if:
    else
    {
        m_dwFlags &= ~eIsPrivate;
    } // else:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetPrivate


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo -- IEnumClusCfgIPAddresses interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Next(
    ULONG                       cNumberRequestedIn,
    IClusCfgIPAddressInfo **   rgpIPAddresseInfoOut,
    ULONG *                     pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr;
    IEnumClusCfgIPAddresses *   pccipa;

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pccipa ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = STHR( pccipa->Next( cNumberRequestedIn, rgpIPAddresseInfoOut, pcNumberFetchedOut ) );
        pccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr;
    IEnumClusCfgIPAddresses *   pccipa;

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pccipa ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( pccipa->Skip( cNumberToSkipIn ) );
        pccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Reset( void )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr;
    IEnumClusCfgIPAddresses *   pccipa;

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pccipa ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( pccipa->Reset() );
        pccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Clone(
    IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr;
    IEnumClusCfgIPAddresses *   pccipa;

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pccipa ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( pccipa->Clone( ppEnumClusCfgIPAddressesOut ) );
        pccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr = S_OK;
    IEnumClusCfgIPAddresses *   pccipa = NULL;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pccipa ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccipa->Count( pnCountOut ) );

Cleanup:

    if ( pccipa != NULL )
    {
       pccipa->Release();
    }

    HRETURN( hr );

} //** CClusCfgNetworkInfo::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo class -- IClusCfgClusterNetworkInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrIsClusterNetwork
//
//  Description:
//      Is this network already a cluster network.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          This network is already a cluster network.
//
//      S_FALSE
//          This network is not already a cluster network.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrIsClusterNetwork( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    if ( m_fIsClusterNetwork )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrIsClusterNetwork


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrGetNetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrGetNetUID(
      BSTR *        pbstrUIDOut
    , const CLSID * pclsidMajorIdIn
    , LPCWSTR       pwszNetworkNameIn
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_punkAddresses != NULL );
    Assert( pclsidMajorIdIn != NULL );
    Assert( pwszNetworkNameIn != NULL );

    HRESULT                 hr;
    IClusCfgIPAddressInfo * piccipi = NULL;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetUID, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = STHR( HrGetPrimaryNetAddress( &piccipi, pclsidMajorIdIn, pwszNetworkNameIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // When there is not a primary network address, we goto cleanup
    //
    if ( ( piccipi == NULL ) && ( hr == S_FALSE ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccipi->GetUID( pbstrUIDOut ) );

Cleanup:

    if ( piccipi != NULL )
    {
        piccipi->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrGetNetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrGetPrimaryNetAddress
//
//  Description:
//
//  Arguments:
//      pwszNetworkNameIn
//          Need to pass this in because m_bstrConnectionName doesn't reflect
//          the correct connection.
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrGetPrimaryNetAddress(
      IClusCfgIPAddressInfo ** ppIPAddressOut
    , const CLSID *            pclsidMajorIdIn
    , LPCWSTR                  pwszNetworkNameIn
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_punkAddresses != NULL );
    Assert( pclsidMajorIdIn != NULL );
    Assert( pwszNetworkNameIn != NULL );

    HRESULT hr;
    ULONG   cFetched;

    hr = STHR( HrGetPrimaryNetworkAddress( ppIPAddressOut, &cFetched ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( ( hr == S_FALSE ) && ( cFetched == 0 ) )
    {
        STATUS_REPORT_STRING(
              TASKID_Major_Find_Devices
            , *pclsidMajorIdIn
            , IDS_INFO_NETWORK_CONNECTION_CONCERN
            , pwszNetworkNameIn
            , hr
            );
        STATUS_REPORT_STRING_REF(
              *pclsidMajorIdIn
            , TASKID_Minor_Primary_IP_Address
            , IDS_ERROR_PRIMARY_IP_NOT_FOUND
            , pwszNetworkNameIn
            , IDS_ERROR_PRIMARY_IP_NOT_FOUND_REF
            , hr
            );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrGetPrimaryNetAddress


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    m_dwFlags = ( eIsPrivate | eIsPublic );

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      hNetworkIn
//      hNetInterfaceIn
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrInit(
      HNETWORK      hNetworkIn
    , HNETINTERFACE hNetInterfaceIn
    )
{
    TraceFunc( "[HNETWORK]" );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    CClusPropList           cplNetworkCommon;
    CClusPropList           cplNetworkROCommon;
    CClusPropList           cplNetInterfaceROCommon;
    CLUSPROP_BUFFER_HELPER  cpbh;
    ULONG                   ulIPAddress;
    ULONG                   ulSubnetMask;

    // IUnknown
    Assert( m_cRef == 1 );

    //
    //  Get the network common read only properties
    //
    sc = TW32( cplNetworkROCommon.ScGetNetworkProperties( hNetworkIn, CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    //
    //  Get the network common properties
    //
    sc = TW32( cplNetworkCommon.ScGetNetworkProperties( hNetworkIn, CLUSCTL_NETWORK_GET_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    //
    //  Get the netinterface common read only properties
    //
    sc = TW32( cplNetInterfaceROCommon.ScGetNetInterfaceProperties( hNetInterfaceIn, CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    //
    //  Find the RO property "name" and save it.
    //
    sc = TW32( cplNetworkROCommon.ScMoveToPropertyByName( L"Name" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cplNetworkROCommon.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    //
    //  If the name is empty tell the user and leave.
    //
    if ( ( cpbh.pStringValue->sz != NULL ) && ( cpbh.pStringValue->sz[ 0 ] != L'\0' ) )
    {
        m_bstrConnectionName = TraceSysAllocString( cpbh.pStringValue->sz );
        if ( m_bstrConnectionName == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:
    else
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_INVALID_DATA ) );
        LOG_STATUS_REPORT_MINOR(
                  TASKID_Minor_HrInit_No_Network_Name
                , L"[SRV] A network name was not found in the common read-only properties."
                , hr
                );
        goto Cleanup;
    } // else:

    //
    //  Find the property "description" and save it.
    //
    sc = TW32( cplNetworkCommon.ScMoveToPropertyByName( L"Description" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cplNetworkCommon.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    //
    //  If the description is empty then alloc a space and continue.
    //
    if ( ( cpbh.pStringValue->sz != NULL ) && ( cpbh.pStringValue->sz[ 0 ] != L'\0' ) )
    {
        m_bstrDescription = TraceSysAllocString( cpbh.pStringValue->sz );
        if ( m_bstrDescription == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:
    else
    {
        m_bstrDescription = TraceSysAllocString( L" " );
        if ( m_bstrDescription == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // else:

    //
    //  Find the property "role".
    //
    sc = TW32( cplNetworkCommon.ScMoveToPropertyByName( L"Role" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cplNetworkCommon.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );

    //
    //  Switch on the role value and set the "private" or "public" bits.
    //
    switch ( cpbh.pDwordValue->dw )
    {
        case ClusterNetworkRoleNone :
            m_dwFlags = 0;
            break;

        case ClusterNetworkRoleInternalUse :
            m_dwFlags = eIsPrivate;
            break;

        case ClusterNetworkRoleClientAccess :
            m_dwFlags = eIsPublic;
            break;

        case ClusterNetworkRoleInternalAndClient :
            m_dwFlags = ( eIsPrivate | eIsPublic );
            break;

        //
        //  Should never get here!
        //
        default:
            hr = HRESULT_FROM_WIN32( TW32( ERROR_INVALID_DATA ) );
            LOG_STATUS_REPORT_STRING_MINOR2(
                      TASKID_Minor_HrInit_Unknown_Network_Role
                    , L"[SRV] The Role property on the network '%1!ws!' is set to %d which is unrecognized."
                    , m_bstrConnectionName
                    , cpbh.pDwordValue->dw
                    , hr
                    );
            goto Cleanup;
    } // switch:

    //
    //  Find the RO property address and save it.
    //
    sc = TW32( cplNetInterfaceROCommon.ScMoveToPropertyByName( L"Address" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cplNetInterfaceROCommon.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( cpbh.pStringValue->sz, &ulIPAddress ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    //
    //  Find the RO property AddressMask and save it.
    //
    sc = TW32( cplNetworkROCommon.ScMoveToPropertyByName( L"AddressMask" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cplNetworkROCommon.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( cpbh.pStringValue->sz, &ulSubnetMask ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    hr = THR( HrCreateEnumAndAddIPAddress( ulIPAddress, ulSubnetMask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_fIsClusterNetwork = TRUE;

    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );
    STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrInit_Win32Error, IDS_ERROR_WIN32, IDS_ERROR_WIN32_REF, hr );
    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrInit_OutOfMemory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrInit( hNetworkIn, hNetInterfaceIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrLoadEnum
//
//  Description:
//      Load the contained enumerator
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrLoadEnum(
      IWbemClassObject * pNetworkAdapterIn
    , bool *            pfRetainObjectOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IClusCfgSetWbemObject * piccswo = NULL;

    hr = THR( HrCreateEnum() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( m_punkAddresses->TypeSafeQI( IClusCfgSetWbemObject, &piccswo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( piccswo->SetWbemObject( pNetworkAdapterIn, pfRetainObjectOut ) );

Cleanup:

    if ( piccswo != NULL )
    {
        piccswo->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrLoadEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrCreateEnum
//
//  Description:
//      Create the contained enumerator
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrCreateEnum( void )
{
    TraceFunc( "" );
    Assert( m_punkAddresses == NULL );

    HRESULT     hr;
    IUnknown *  punk = NULL;

    hr = THR( CEnumClusCfgIPAddresses::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CEnumClusCfgIPAddresses", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ))
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_punkAddresses = punk;
    m_punkAddresses->AddRef();

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrCreateEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrCreateEnumAndAddIPAddress
//
//  Description:
//      Add an IPAddress to the contained enumerator.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrCreateEnumAndAddIPAddress(
      ULONG ulIPAddressIn
    , ULONG ulSubnetMaskIn
    )
{
    TraceFunc( "" );
    Assert( m_punkAddresses == NULL );

    HRESULT     hr;
    IUnknown *  punk = NULL;
    IUnknown *  punkCallback = NULL;

    hr = THR( m_picccCallback->TypeSafeQI( IUnknown, &punkCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Have to pass the Initialize interface arguments since new objects will
    //  be created when this call is made.
    //
    hr = THR( CEnumClusCfgIPAddresses::S_HrCreateInstance( ulIPAddressIn, ulSubnetMaskIn, punkCallback, m_lcid, m_pIWbemServices, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CEnumClusCfgIPAddresses", IUnknown, punk, 1 );

    //
    //  This is special -- do not initialize this again.
    //
    //hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    //if ( FAILED( hr ))
    //{
    //    goto Cleanup;
    //} // if:

    //hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    //if ( FAILED( hr ) )
    //{
    //    goto Cleanup;
    //} // if:

    m_punkAddresses = punk;
    m_punkAddresses->AddRef();

Cleanup:

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrCreateEnumAndAddIPAddress



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrGetPrimaryNetworkAddress
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrGetPrimaryNetworkAddress(
      IClusCfgIPAddressInfo ** ppIPAddressOut
    , ULONG *                  pcFetched
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr;
    IEnumClusCfgIPAddresses *   pieccipa = NULL;

    if ( ppIPAddressOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetPrimaryNetworkAddress, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pieccipa ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pieccipa->Reset() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( pieccipa->Next( 1, ppIPAddressOut, pcFetched ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( pieccipa != NULL )
    {
        pieccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrGetPrimaryNetworkAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgpartitioninfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CClusCfgPartitionInfo.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgPartitionInfo
//      class.
//
//      The class CClusCfgPartitionInfo represents a disk partition.
//      It implements the IClusCfgPartitionInfo interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CClusCfgPartitionInfo.h"
#include <StdIo.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgPartitionInfo" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgPartitionInfo instance.
//
//  Arguments:
//      ppunkOut.
//
//  Return Values:
//      Pointer to CClusCfgPartitionInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = THR( S_HrCreateInstance( ppunkOut, NULL ) );

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgPartitionInfo instance.
//
//  Arguments:
//      ppunkOut.
//
//  Return Values:
//      Pointer to CClusCfgPartitionInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::S_HrCreateInstance(
      IUnknown **   ppunkOut
    , BSTR          bstrDeviceIDIn
    )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );

    HRESULT                 hr = S_OK;
    CClusCfgPartitionInfo * pccpi = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( bstrDeviceIDIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    pccpi = new CClusCfgPartitionInfo();
    if ( pccpi == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccpi->HrInit( bstrDeviceIDIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccpi->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgPartitionInfo::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccpi != NULL )
    {
        pccpi->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::CClusCfgPartitionInfo
//
//  Description:
//      Constructor of the CClusCfgPartitionInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgPartitionInfo::CClusCfgPartitionInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_pIWbemServices == NULL );
    Assert( m_bstrName == NULL );
    Assert( m_bstrDescription == NULL );
    Assert( m_bstrUID == NULL );
    Assert( m_prgLogicalDisks == NULL );
    Assert( m_idxNextLogicalDisk == 0 );
    Assert( m_ulPartitionSize == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_bstrDiskDeviceID == NULL );

    TraceFuncExit();

} //*** CClusCfgPartitionInfo::CClusCfgPartitionInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::~CClusCfgPartitionInfo
//
//  Description:
//      Desstructor of the CClusCfgPartitionInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgPartitionInfo::~CClusCfgPartitionInfo( void )
{
    TraceFunc( "" );

    ULONG   idx;

    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrDescription );
    TraceSysFreeString( m_bstrUID );
    TraceSysFreeString( m_bstrDiskDeviceID );

    for ( idx = 0; idx < m_idxNextLogicalDisk; idx++ )
    {
        ((*m_prgLogicalDisks)[ idx ])->Release();
    } // for:

    TraceFree( m_prgLogicalDisks );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgPartitionInfo::~CClusCfgPartitionInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgPartitionInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CClusCfgPartitionInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgPartitionInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CClusCfgPartitionInfo::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgPartitionInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgPartitionInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgPartitionInfo, this, 0 );
    } // else if: IClusCfgPartitionInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgWbemServices ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
    } // else if: IClusCfgWbemServices
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgPartitionProperties ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgPartitionProperties, this, 0 );
    } // else if: IClusCfgPartitionProperties
    else if ( IsEqualIID( riidIn, IID_IClusCfgSetWbemObject ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgSetWbemObject, this, 0 );
    } // else if: IClusCfgSetWbemObject
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

     QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusCfgPartitionInfo::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Partition, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo -- IClusCfgPartitionInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_PartitionInfo_GetUID_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    //
    //  If we don't have a UID then simply return S_FALSE to
    //  indicate that we have no data.
    //

    if ( m_bstrUID == NULL )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( m_bstrUID );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_PartitionInfo_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_PartitionInfo_GetName_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    //
    //  If we don't have a name then simply return S_FALSE to
    //  indicate that we have no data.
    //

    if ( m_bstrName == NULL )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrName );
    if (*pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgPartitionInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetDescription
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetDescription( BSTR * pbstrDescriptionOut )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrDescriptionOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_PartitionInfo_GetDescription_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_bstrDescription == NULL )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    *pbstrDescriptionOut = SysAllocString( m_bstrDescription );
    if (*pbstrDescriptionOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_PartitionInfo_GetDescription_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetDescription


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::SetDescription
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::SetDescription( LPCWSTR pcszDescriptionIn )
{
    TraceFunc1( "[IClusCfgPartitionInfo] pcszDescriptionIn = '%ls'", pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn );

    HRESULT hr;

    if ( pcszDescriptionIn == NULL )
    {
        hr = THR( E_INVALIDARG );
    } // if:
    else
    {
        hr = THR( E_NOTIMPL );
    } // else:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::SetDescription


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT             hr = S_FALSE;
    IWbemClassObject *  pLogicalDisk = NULL;
    VARIANT             var;
    ULONG               idx;
    int                 idxDrive;

    VariantInit( & var );

    if ( pdlmDriveLetterMappingOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetDriveLetterMappings_Partition, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    for ( idx = 0; idx < m_idxNextLogicalDisk; idx++ )
    {
        hr = THR( ((*m_prgLogicalDisks)[ idx ])->TypeSafeQI( IWbemClassObject, &pLogicalDisk ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        VariantClear( &var );

        hr = THR( HrGetWMIProperty( pLogicalDisk, L"Name", VT_BSTR, &var ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        CharUpper( var.bstrVal );

        idxDrive = var.bstrVal[ 0 ] - 'A';

        VariantClear( &var );

        hr = THR( HrGetWMIProperty( pLogicalDisk, L"DriveType", VT_I4, &var ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        pdlmDriveLetterMappingOut->dluDrives[ idxDrive ] = (EDriveLetterUsage) var.iVal;

        pLogicalDisk->Release();
        pLogicalDisk = NULL;
    } // for:

Cleanup:

    VariantClear( &var );

    if ( pLogicalDisk != NULL )
    {
        pLogicalDisk->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::SetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetSize
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetSize( ULONG * pcMegaBytes )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT hr = S_OK;

    if ( pcMegaBytes == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetSize, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pcMegaBytes = m_ulPartitionSize;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetSize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::SetWbemObject
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::SetWbemObject(
      IWbemClassObject *    pPartitionIn
    , bool *                pfRetainObjectOut
    )
{
    TraceFunc( "" );
    Assert( pPartitionIn != NULL );
    Assert( pfRetainObjectOut != NULL );

    HRESULT     hr = S_OK;
    VARIANT     var;
    ULONGLONG   ull = 0;
    int         cch = 0;

    VariantInit( &var );

    hr = THR( HrGetWMIProperty( pPartitionIn, L"Description", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrDescription = TraceSysAllocString( var.bstrVal );
    if ( m_bstrDescription == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pPartitionIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrUID = TraceSysAllocString( var.bstrVal );
    if ( m_bstrUID == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pPartitionIn, L"Name", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrName = TraceSysAllocString( var.bstrVal );
    if ( m_bstrName == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pPartitionIn, L"Size", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    cch = swscanf( var.bstrVal, L"%I64u", &ull );
    Assert( cch > 0 );

    m_ulPartitionSize = (ULONG) ( ull / ( 1024 * 1024 ) );

    hr = THR( HrGetLogicalDisks( pPartitionIn ) );

    *pfRetainObjectOut = true;

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemObject_Partition, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );

Cleanup:

    VariantClear( &var );

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::SetWbemObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo -- IClusCfgPartitionProperties interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::IsThisLogicalDisk
//
//  Description:
//      Does this partition have the passed in logical disk?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success, the partition has the logical disk.
//
//      S_FALSE
//          Success, the partition does not have the logical disk.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::IsThisLogicalDisk( WCHAR cLogicalDiskIn )
{
    TraceFunc( "[IClusCfgPartitionProperties]" );

    HRESULT             hr = S_FALSE;
    DWORD               idx;
    IWbemClassObject *  piwco = NULL;
    VARIANT             var;
    bool                fFoundIt = false;

    VariantInit( &var );

    if ( m_idxNextLogicalDisk == 0 )
    {
        goto Cleanup;
    } // if:

    for ( idx = 0; idx < m_idxNextLogicalDisk; idx++ )
    {
        hr = THR( ((*m_prgLogicalDisks)[ idx ])->TypeSafeQI( IWbemClassObject, &piwco ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetWMIProperty( piwco, L"DeviceID", VT_BSTR, &var ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( cLogicalDiskIn == var.bstrVal[ 0 ] )
        {
            fFoundIt = true;
            break;
        } // if:

        VariantClear( &var );

        piwco->Release();
        piwco = NULL;
    } // for:

    if ( !fFoundIt )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    VariantClear( &var );

    if ( piwco != NULL )
    {
        piwco->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::IsThisLogicalDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::IsNTFS
//
//  Description:
//      Is this an NTFS partition?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success, the partition is NTFS.
//
//      S_FALSE
//          Success, the partition is not NTFS.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::IsNTFS( void )
{
    TraceFunc( "[IClusCfgPartitionProperties]" );

    HRESULT             hr = S_FALSE;
    VARIANT             var;
    ULONG               idx;
    IWbemClassObject *  piwco = NULL;

    VariantInit( &var );

    for ( idx = 0; idx < m_idxNextLogicalDisk; idx++ )
    {
        hr = THR( ((*m_prgLogicalDisks)[ idx ])->TypeSafeQI( IWbemClassObject, &piwco ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        VariantClear( &var );

        hr = HrGetWMIProperty( piwco, L"FileSystem", VT_BSTR, &var );
        if ( ( hr == E_PROPTYPEMISMATCH ) && ( var.vt == VT_NULL ) )
        {
            VariantClear( &var );

            hr = S_FALSE;
            THR( HrGetWMIProperty( piwco, L"DeviceID", VT_BSTR, &var ) );
            STATUS_REPORT_STRING_REF(
                      TASKID_Major_Find_Devices
                    , TASKID_Minor_Phys_Disk_No_File_System
                    , IDS_ERROR_PHYSDISK_NO_FILE_SYSTEM
                    , var.bstrVal
                    , IDS_ERROR_PHYSDISK_NO_FILE_SYSTEM_REF
                    , hr );
            break;
        } // if:
        else if ( FAILED( hr ) )
        {
            THR( hr );
            goto Cleanup;
        } // else if:

        if ( NStringCchCompareCase( var.bstrVal, SysStringLen( var.bstrVal ) + 1, L"NTFS", RTL_NUMBER_OF( L"NTFS" ) ) != 0 )
        {
            VariantClear( &var );

            hr = S_FALSE;
            THR( HrGetWMIProperty( piwco, L"DeviceID", VT_BSTR, &var ) );
            STATUS_REPORT_STRING_REF(
                      TASKID_Major_Find_Devices
                    , TASKID_Minor_Phys_Disk_Not_NTFS
                    , IDS_WARN_PHYSDISK_NOT_NTFS
                    , var.bstrVal
                    , IDS_WARN_PHYSDISK_NOT_NTFS_REF
                    , hr
                    );
            break;
        } // if:

        piwco->Release();
        piwco = NULL;
    } // for:

Cleanup:

    VariantClear( &var );

    if ( piwco != NULL )
    {
        piwco->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::IsNTFS

/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::IsNTFS
//
//  Description:
//      Is this an NTFS partition?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success, the partition is NTFS.
//
//      S_FALSE
//          Success, the partition is not NTFS.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::IsNTFS( void )
{
    TraceFunc( "[IClusCfgPartitionProperties]" );

    HRESULT hr = S_OK;
    WCHAR   szScanFormat[] = { L"Disk #%u, Partition #%u" };
    DWORD   dwDisk;
    DWORD   dwPartition;
    int     cReturned;
    WCHAR   szFormat[] = { L"\\\\\?\\GLOBALROOT\\Device\\Harddisk%u\\Partition%u\\" };
    WCHAR   szBuf[ 64 ];
    BSTR    bstrFileSystem = NULL;

    cReturned = _snwscanf( m_bstrName, wcslen( m_bstrName ), szScanFormat, &dwDisk, &dwPartition );
    if ( cReturned != 2 )
    {
        hr = THR( E_UNEXPECTED );
        goto Cleanup;
    } // if:

    hr = THR( StringCchPrintfW( szBuf, ARRAYSIZE( szBuf ), szFormat, dwDisk, dwPartition + 1 ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetVolumeInformation( szBuf, NULL, &bstrFileSystem ) );
    if ( FAILED( hr ) )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    if ( NStringCchCompareNoCase( bstrFileSystem, SysStringLen( bstrFileSystem ) + 1, L"NTFS", RTL_NUMBER_OF( L"NTFS" ) ) == 0 )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    } // else:

Cleanup:

    TraceSysFreeString( bstrFileSystem );

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::IsNTFS
*/

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetFriendlyName
//
//  Description:
//      Get the friendly name of this partition.  This name will be the
//      logical disk names of all logical disks on this partition.
//
//  Arguments:
//      BSTR * pbstrNameOut
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetFriendlyName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgPartitionProperties]" );

    HRESULT             hr = S_FALSE;
    DWORD               idx;
    IWbemClassObject *  piwco = NULL;
    WCHAR *             psz = NULL;
    WCHAR *             pszTmp = NULL;
    DWORD               cch = 0;
    VARIANT             var;

    VariantInit( &var );

    if ( m_idxNextLogicalDisk == 0 )
    {
        goto Cleanup;
    } // if:

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetFriendlyName, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    for ( idx = 0; idx < m_idxNextLogicalDisk; idx++ )
    {
        hr = THR( ((*m_prgLogicalDisks)[ idx ])->TypeSafeQI( IWbemClassObject, &piwco ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetWMIProperty( piwco, L"DeviceID", VT_BSTR, &var ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        cch += ( UINT ) wcslen( var.bstrVal ) + 2;                      // a space and the '\0'

        pszTmp = (WCHAR *) TraceReAlloc( psz, sizeof( WCHAR ) * cch, HEAP_ZERO_MEMORY );
        if ( pszTmp == NULL  )
        {
            goto OutOfMemory;
        } // if:

        psz = pszTmp;
        pszTmp = NULL;

        hr = THR( StringCchCatW( psz, cch, L" " ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( StringCchCatW( psz, cch, var.bstrVal ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        VariantClear( &var );

        piwco->Release();
        piwco = NULL;
    } // for:

    *pbstrNameOut = TraceSysAllocString( psz );
    if ( *pbstrNameOut == NULL )
    {
        goto OutOfMemory;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetFriendlyName, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );

Cleanup:

    VariantClear( &var );

    if ( piwco != NULL )
    {
        piwco->Release();
    } // if:

    if ( psz != NULL )
    {
        TraceFree( psz );
    } // if:

    if ( pszTmp != NULL )
    {
        free( pszTmp );
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetFriendlyName


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::HrInit(
    BSTR    bstrDeviceIDIn      // = NULL
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    if ( bstrDeviceIDIn != NULL )
    {
        m_bstrDiskDeviceID = TraceSysAllocString( bstrDeviceIDIn );
        if ( m_bstrDiskDeviceID == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
        } // if:
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::HrInit


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo:HrAddLogicalDiskToArray
//
//  Description:
//      Add the passed in logical disk to the array of punks that holds the
//      logical disks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::HrAddLogicalDiskToArray(
    IWbemClassObject * pLogicalDiskIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  punk;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgLogicalDisks, sizeof( IUnknown * ) * ( m_idxNextLogicalDisk + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrAddLogicalDiskToArray, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // else:

    m_prgLogicalDisks = prgpunks;

    hr = THR( pLogicalDiskIn->TypeSafeQI( IUnknown, &punk ) );
    if ( SUCCEEDED( hr ) )
    {
        (*m_prgLogicalDisks)[ m_idxNextLogicalDisk++ ] = punk;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::HrAddLogicalDiskToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo:HrGetLogicalDisks
//
//  Description:
//      Get the logical disks for the passed in partition.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      S_FALSE
//          The file system was not NTFS.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::HrGetLogicalDisks(
    IWbemClassObject * pPartitionIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    VARIANT                 var;
    WCHAR                   szBuf[ 256 ];
    IEnumWbemClassObject *  pLogicalDisks = NULL;
    IWbemClassObject *      pLogicalDisk = NULL;
    ULONG                   ulReturned;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrWQL = NULL;

    VariantInit( &var );

    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrGetLogicalDisks, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    //
    //  Need to enum the logical disk(s) of this partition to determine if it is booted
    //  bootable.
    //
    hr = THR( HrGetWMIProperty( pPartitionIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( StringCchPrintfW(
                      szBuf
                    , ARRAYSIZE( szBuf ), L"Associators of {Win32_DiskPartition.DeviceID='%ws'} where AssocClass=Win32_LogicalDiskToPartition"
                    , var.bstrVal
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    bstrQuery = TraceSysAllocString( szBuf );
    if ( bstrQuery == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrGetLogicalDisks, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pLogicalDisks ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_REF(
              TASKID_Major_Find_Devices
            , TASKID_Minor_WMI_Logical_Disks_Qry_Failed
            , IDS_ERROR_WMI_PHYS_DISKS_QRY_FAILED
            , IDS_ERROR_WMI_PHYS_DISKS_QRY_FAILED_REF
            , hr
            );
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        hr = pLogicalDisks->Next( WBEM_INFINITE, 1, &pLogicalDisk, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            THR( HrLogLogicalDiskInfo( pLogicalDisk, var.bstrVal ) );
            hr = THR( HrAddLogicalDiskToArray( pLogicalDisk ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            pLogicalDisk->Release();
            pLogicalDisk = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING_REF(
                      TASKID_Major_Find_Devices
                    , TASKID_Minor_HrGetLogicalDisks_Next
                    , IDS_ERROR_WQL_QRY_NEXT_FAILED
                    , bstrQuery
                    , IDS_ERROR_WQL_QRY_NEXT_FAILED_REF
                    , hr
                    );
            goto Cleanup;
        } // else:
    } // for:

    goto Cleanup;

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrQuery );
    TraceSysFreeString( bstrWQL );

    if ( pLogicalDisk != NULL )
    {
        pLogicalDisk->Release();
    } // if:

    if ( pLogicalDisks != NULL )
    {
        pLogicalDisks->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::HrGetLogicalDisks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo:HrLogLogicalDiskInfo
//
//  Description:
//      Log the info about the passed in logical disk.
//
//  Arguments:
//      pLogicalDiskIn
//
//      bstrDeviceIDIn
//          The device ID of the current partition to which this logical disk
//          belongs.
//
//  Return Value:
//      S_OK
//          Success
//
//      Other HRESULT errors.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::HrLogLogicalDiskInfo(
      IWbemClassObject *    pLogicalDiskIn
    , BSTR                  bstrDeviceIDIn
    )
{
    TraceFunc( "" );
    Assert( m_bstrDiskDeviceID != NULL );
    Assert( pLogicalDiskIn != NULL );
    Assert( bstrDeviceIDIn != NULL );

    HRESULT hr = S_OK;
    VARIANT var;

    VariantInit( &var );

    if ( ( pLogicalDiskIn == NULL ) || ( bstrDeviceIDIn == NULL ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    hr = THR( HrGetWMIProperty( pLogicalDiskIn, L"Name", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    LOG_STATUS_REPORT_STRING3(
                  L"Found physical disk \"%1!ws!\" with partition \"%2!ws!\" which has the logical disk \"%3!ws!\"."
                , m_bstrDiskDeviceID
                , bstrDeviceIDIn
                , var.bstrVal
                , hr
                );

Cleanup:

    VariantClear( &var );

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::HrLogLogicalDiskInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgserver.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CClusCfgServer.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgServer class.
//
//      The class CClusCfgServer is the implementations of the
//      IClusCfgServer interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 03-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include <ClusRTL.h>
#include "CClusCfgServer.h"
#include "PrivateInterfaces.h"
#include "CClusCfgNodeInfo.h"
#include "CEnumClusCfgManagedResources.h"
#include "CClusCfgCallback.h"
#include "EventName.h"
#include <ClusRtl.h>
#include <windns.h>
#include <ClusterUtils.h>
#include <clusudef.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgServer" );

#define CLEANUP_LOCK_NAME L"Global\\Microsoft Cluster Configuration Cleanup Lock"


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgServer instance.
//
//  Arguments:
//      ppunkOut    -
//
//  Return Values:
//      Pointer to CClusCfgServer instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CClusCfgServer *    pccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    //  KB: Since this is usually the start of the "server" thread,
    //      we will cause it to read its thread settings here.
    //
    TraceInitializeThread( L"ServerThread" );

    pccs = new CClusCfgServer();
    if ( pccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccs->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgServer::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccs != NULL )
    {
        pccs->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::CClusCfgServer
//
//  Description:
//      Constructor of the CClusCfgServer class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgServer::CClusCfgServer( void )
    : m_cRef( 1 )
    , m_pIWbemServices( NULL )
    , m_lcid( LOCALE_NEUTRAL )
    , m_fCanBeClustered( TRUE )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_punkNodeInfo == NULL );
    Assert( m_punkEnumResources == NULL );
    Assert( m_punkNetworksEnum == NULL );
    Assert( m_bstrNodeName == NULL );
    Assert( !m_fUsePolling );
    Assert( m_bstrBindingString == NULL );

    TraceFuncExit();

} //*** CClusCfgServer::CClusCfgServer


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::~CClusCfgServer
//
//  Description:
//      Destructor of the CClusCfgServer class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgServer::~CClusCfgServer( void )
{
    TraceFunc( "" );

    TraceSysFreeString( m_bstrNodeName );
    TraceSysFreeString( m_bstrBindingString );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_punkNodeInfo != NULL )
    {
        m_punkNodeInfo->Release();
    } // if:

    if ( m_punkEnumResources != NULL )
    {
        m_punkEnumResources->Release();
    } // if:

    if ( m_punkNetworksEnum != NULL )
    {
        m_punkNetworksEnum->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgServer::~CClusCfgServer


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgServer::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CClusCfgServer::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgServer::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CClusCfgServer::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgServer * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgServer ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgServer, this, 0 );
    } // else if: IClusCfgServer
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgCapabilities ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCapabilities, this, 0 );
    } // else if: IClusCfgCapabilities
    else if ( IsEqualIID( riidIn, IID_IClusCfgPollingCallbackInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgPollingCallbackInfo, this, 0 );
    } // else if: IClusCfgPollingCallbackInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgVerify ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgVerify, this, 0 );
    } // else if: IClusCfgVerify
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusCfgServer::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The punkCallbackIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback != NULL );

    TraceInitializeThread( L"ClusCfgServerFlags" );

    HRESULT                 hr = S_OK;
    IUnknown *              punk = NULL;
    IClusCfgCallback *      piccc = NULL;       // this is NULL when we are polling callback
    IClusCfgNodeInfo *      piccni = NULL;
    IClusCfgClusterInfo *   piccci = NULL;

//    hr = STHR( HrCheckSecurity() );
//    if ( FAILED( hr ) )
//    {
//        goto Cleanup;
//    } // if:

    m_lcid = lcidIn;

    //
    //  If we are passed a callback object then we need to get its IClusCfgCallback
    //  interface so we can pass it into our callback object when it's initialized
    //  below.
    //
    if ( punkCallbackIn != NULL )
    {
        Assert( !m_fUsePolling );

        hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &piccc ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:
    else
    {
        Assert( m_fUsePolling );

        if ( m_fUsePolling == FALSE )
        {
            hr = THR( E_INVALIDARG );
            goto Cleanup;
        } // if:
    } // else:

    //
    //  Initialize our internal callback object passing it either the passed in
    //  callback object's callback interface or NULL if we are polling.
    //
    hr = THR( m_picccCallback->TypeSafeQI( IUnknown, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, piccc, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  KB: 24-JUL-2000 GalenB
    //
    //  If we are being initialized on this interface then we are going to run this server local
    //  to the node.
    //
    hr = THR( HrInitializeForLocalServer() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Precreate the node info so we can get the cluster info object and determine if the cluster service
    //  is running on this node or not.
    //
    hr = THR( HrCreateClusterNodeInfo() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( m_punkNodeInfo->TypeSafeQI( IClusCfgNodeInfo, &piccni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  This could return HRESUTL_FROM_WIN32( ERROR_CLUSTER_NODE_DOWN ) and that
    //  tells us that the cluster service is not running on this node.  The
    //  middletier needs to know this so it doesn't call us on this node
    //  anymore.
    //
    hr = THR( piccni->GetClusterConfigInfo( &piccci ) );

Cleanup:

    if ( m_picccCallback != NULL )
    {
        STATUS_REPORT( TASKID_Major_Establish_Connection, TASKID_Minor_Server_Initialized, IDS_NOTIFY_SERVER_INITIALIZED, hr );
    } // if:

    if ( piccci != NULL )
    {
        piccci->Release();
    } // if:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    if ( piccc != NULL )
    {
        piccc->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer -- IClusCfgServer interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::GetClusterNodeInfo
//
//  Description:
//      Get information about the computer on which this object is present.
//
//  Arguments:
//      OUT  IClusCfgNodeInfo ** ppClusterNodeInfoOut
//          Catches the node info object.
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The out param was NULL.
//
//      E_OUTOFMEMORY
//          The IClusCfgNodeInfo object could not be allocated.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::GetClusterNodeInfo(
    IClusCfgNodeInfo ** ppClusterNodeInfoOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;

    if ( ppClusterNodeInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF(
                  TASKID_Major_Check_Node_Feasibility
                , TASKID_Minor_GetClusterNodeInfo
                , IDS_ERROR_NULL_POINTER
                , IDS_ERROR_NULL_POINTER_REF
                , hr
                );
        goto Cleanup;
    } // if:

    if ( m_punkNodeInfo != NULL )
    {
        hr = S_OK;
        goto SkipCreate;
    } // if:

    hr = THR( HrCreateClusterNodeInfo() );

SkipCreate:

    if ( SUCCEEDED( hr ) )
    {
        Assert( m_punkNodeInfo != NULL );
        hr = THR( m_punkNodeInfo->TypeSafeQI( IClusCfgNodeInfo, ppClusterNodeInfoOut ) );
    } // if:

Cleanup:

    if ( FAILED( hr ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Check_Node_Feasibility
                , TASKID_Minor_Server_GetClusterNodeInfo
                , IDS_ERROR_NODE_INFO_CREATE
                , IDS_ERROR_NODE_INFO_CREATE_REF
                , hr
                );
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::GetClusterNodeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::GetManagedResourcesEnum
//
//  Description:
//      Get an enumeration of the devices on this computer that can be
//      managed by the cluster service.
//
//  Arguments:
//      OUT  IEnumClusCfgManagedResources **  ppEnumManagedResourcesOut
//          Catches the CEnumClusCfgManagedResources object.
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The out param was NULL.
//
//      E_OUTOFMEMORY
//          The CEnumClusCfgManagedResources object could not be allocated.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::GetManagedResourcesEnum(
    IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;

    if ( ppEnumManagedResourcesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetManagedResourcesEnum, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_punkEnumResources != NULL )
    {
        m_punkEnumResources->Release();
        m_punkEnumResources = NULL;
    } // if:

    hr = THR( CEnumClusCfgManagedResources::S_HrCreateInstance( &m_punkEnumResources ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_punkEnumResources = TraceInterface( L"CEnumClusCfgManagedResources", IUnknown, m_punkEnumResources, 1 );

    hr = THR( HrSetInitialize( m_punkEnumResources, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( m_punkEnumResources, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( m_punkEnumResources->TypeSafeQI( IEnumClusCfgManagedResources, ppEnumManagedResourcesOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Server_GetManagedResourcesEnum
                , IDS_ERROR_MANAGED_RESOURCE_ENUM_CREATE
                , IDS_ERROR_MANAGED_RESOURCE_ENUM_CREATE_REF
                , hr
                );
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::GetManagedResourcesEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::GetNetworksEnum
//
//  Description:
//      Get an enumeration of all the networks on this computer.
//
//  Arguments:
//      OUT  IEnumClusCfgNetworks ** ppEnumNetworksOut
//          Catches the CEnumClusCfgNetworks object.
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The out param was NULL.
//
//      E_OUTOFMEMORY
//          The CEnumClusCfgNetworks object could not be allocated.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::GetNetworksEnum(
    IEnumClusCfgNetworks ** ppEnumNetworksOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;

    if ( ppEnumNetworksOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetNetworksEnum, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_punkNetworksEnum != NULL )
    {
        m_punkNetworksEnum->Release();
        m_punkNetworksEnum = NULL;
    } // if:

    hr = THR( HrCreateNetworksEnum( m_picccCallback, m_lcid, m_pIWbemServices, &m_punkNetworksEnum ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( m_punkNetworksEnum->TypeSafeQI( IEnumClusCfgNetworks, ppEnumNetworksOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Server_GetNetworksEnum
                , IDS_ERROR_NETWORKS_ENUM_CREATE
                , IDS_ERROR_NETWORKS_ENUM_CREATE_REF
                , hr
                );
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::GetNetworksEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::CommitChanges
//
//  Description:
//      Commit the changes to the node.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::CommitChanges( void )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT                 hr = S_OK;
    HRESULT                 hrTemp = S_OK;
    IClusCfgInitialize *    pcci = NULL;
    IClusCfgClusterInfo *   pClusCfgClusterInfo = NULL;
    ECommitMode             ecmCommitChangesMode = cmUNKNOWN;
    IClusCfgNodeInfo *      piccni = NULL;
    IPostCfgManager *       ppcm = NULL;
    IUnknown *              punkCallback = NULL;
    HANDLE                  heventPostCfgCompletion = NULL;
    IEnumClusCfgManagedResources * peccmr = NULL;
    DWORD                 sc = ERROR_SUCCESS;

    MULTI_QI                mqiInterfaces[] =
    {
        { &IID_IClusCfgBaseCluster, NULL, S_OK },
        { &IID_IClusCfgInitialize, NULL, S_OK }
    };

    hr = THR( m_picccCallback->TypeSafeQI( IUnknown, &punkCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // KB:  First, get a pointer to the IClusCfgNodeInfo interface. Use this to get
    // a pointer to the IClusCfgClusterInfo interface to see what action needs
    // to be committed.
    //
    if ( m_punkNodeInfo == NULL )
    {
        hr = THR( GetClusterNodeInfo( &piccni ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:
    else
    {
        hr = THR( m_punkNodeInfo->TypeSafeQI( IClusCfgNodeInfo, &piccni ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: we could not get the pointer to the IClusCfgNodeInfo interface
    } // else:

    hr = THR( piccni->GetClusterConfigInfo( &pClusCfgClusterInfo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the pointer to the IClusCfgClusterInfo interface

    hr = STHR( pClusCfgClusterInfo->GetCommitMode( &ecmCommitChangesMode ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    Assert( ecmCommitChangesMode != cmUNKNOWN );

    //
    // Create and initialize the BaseClusterAction component
    //

    hr = THR( HrCoCreateInternalInstanceEx( CLSID_ClusCfgBaseCluster, NULL, CLSCTX_SERVER, NULL, ARRAYSIZE( mqiInterfaces ), mqiInterfaces ) );
    if ( FAILED( hr ) && ( hr != CO_S_NOTALLINTERFACES ) )
    {
        LOG_STATUS_REPORT( L"Failed to CoCreate Base Cluster Actions", hr );
        goto Cleanup;
    } // if: CoCreateInstanceEx() failed

    hr = THR( mqiInterfaces[ 0 ].hr );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgBaseCluster interface

    //
    // Check if we got a pointer to the IClusCfgInitialize interface
    hr = mqiInterfaces[ 1 ].hr;
    if ( hr == S_OK )
    {
        hr = THR( ((IClusCfgInitialize *) mqiInterfaces[ 1 ].pItf)->Initialize( punkCallback, m_lcid ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: something went wrong during initialization

    } // if: we got a pointer to the IClusCfgInitialize interface
    else
    {
        if ( hr != E_NOINTERFACE )
        {
            goto Cleanup;
        } // if: the interface is supported, but something else went wrong.

    } // if: we did not get a pointer to the IClusCfgInitialize interface

    //
    //  Create and initialize the Post configuration manager
    //

    hr = THR( HrCoCreateInternalInstance( CLSID_ClusCfgPostConfigManager, NULL, CLSCTX_SERVER, TypeSafeParams( IPostCfgManager, &ppcm ) ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Configure_Cluster_Services
                , TASKID_Minor_Cannot_Create_PostCfg_Mgr
                , IDS_ERROR_CANNOT_CREATE_POSTCFG_MGR
                , IDS_ERROR_CANNOT_CREATE_POSTCFG_MGR_REF
                , hr
                );
        goto Cleanup;
    }

    // Check if this component supports the callback interface.
    hrTemp = THR( ppcm->TypeSafeQI( IClusCfgInitialize, &pcci ) );
    if ( FAILED( hrTemp ) )
    {
        LOG_STATUS_REPORT( L"Could not get a pointer to the IClusCfgInitialize interface. This post configuration manager does not support initialization", hr );
    } // if: the callback interface is not supported
    else
    {
        // Initialize this component.
        hr = THR( pcci->Initialize( punkCallback, m_lcid ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"Could not initialize the post configuration manager", hr );
            goto Cleanup;
        } // if: the initialization failed
    } // else: the callback interface is supported

    if ( m_punkEnumResources != NULL )
    {
        hr = THR( m_punkEnumResources->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
    } // if: resource enum is not NULL
    else
    {
        //
        //  If the enumerator is NULL then we are most likely cleaning up a
        //  node.  That also means that we are not creating a cluster or
        //  adding nodes to a cluster.
        //

        Assert( ( ecmCommitChangesMode != cmCREATE_CLUSTER ) && ( ecmCommitChangesMode != cmADD_NODE_TO_CLUSTER) );

        hr = GetManagedResourcesEnum( &peccmr );
        if ( FAILED( hr ) )
        {
            //
            //  If we are cleaning up a node then we don't really care if this
            //  enum loads 100% correctly or not.  Any resources in the enum
            //  that fail to load will simply not participate in the clean up.
            //

            if ( ecmCommitChangesMode == cmCLEANUP_NODE_AFTER_EVICT )
            {
                hr = S_OK;
            } // if: cleaning up a node
            else
            {
                THR( hr );
                goto Cleanup;
            } // else: not cleaning up a node
        } // if: loading the resource enum failed
    } // else: resource enum is NULL


    //
    // If we are here, then the BaseCluster and Post configuration components were successfully
    // created and initialized. Now perform the desired action.
    //

    if ( ( ecmCommitChangesMode == cmCREATE_CLUSTER ) || ( ecmCommitChangesMode == cmADD_NODE_TO_CLUSTER ) )
    {
        if ( !m_fCanBeClustered )
        {
            //
            //  TODO:   01-JUN-2000 GalenB
            //
            //  Need better error code...  What is the major and minor taskids?
            //

            hr = S_FALSE;
            LOG_STATUS_REPORT( L"It was previously determined that this node cannot be clustered.", hr );
            goto Cleanup;
        } // if: this node cannot be part of a cluster

        //
        // If the cluster service is being started for the first time, as a part
        // of adding this node to a cluster (forming or joining), then we have
        // to wait till the post-configuration steps are completed before we
        // can send out notifications. Create an event that indicates that post configuration
        // has completed.
        //

        TraceFlow1( "Trying to create an event named '%s'.", POSTCONFIG_COMPLETE_EVENT_NAME );

        //
        // Create an event in the unsignalled state.
        //

        heventPostCfgCompletion = CreateEvent(
              NULL                                  // event security attributes
            , TRUE                                  // manual-reset event
            , FALSE                                 // create in unsignaled state
            , POSTCONFIG_COMPLETE_EVENT_NAME
            );

        if ( heventPostCfgCompletion == NULL )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            LogMsg( L"[SRV] Error %#08x occurred trying to create an event named '%ws'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            goto Cleanup;
        } // if: we could not get a handle to the event

        sc = TW32( ClRtlSetObjSecurityInfo(
                              heventPostCfgCompletion
                            , SE_KERNEL_OBJECT
                            , EVENT_ALL_ACCESS
                            , EVENT_ALL_ACCESS
                            , 0
                            ) );

        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( "[BC] Error %#08x occurred trying set %s event security.", sc, POSTCONFIG_COMPLETE_EVENT_NAME);
            goto Cleanup;
        } // if: ClRtlSetObjSecurityInfo failed

        //
        //  Reset the event, just as a safetly measure, in case the event already existed before the call above.
        //

        if ( ResetEvent( heventPostCfgCompletion ) == 0 )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            LogMsg( L"[SRV] Error %#08x occurred trying to unsignal an event named '%ws'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            goto Cleanup;
        } // if: ResetEvent() failed()
    } // if: we are forming or joining

    if ( ecmCommitChangesMode == cmCREATE_CLUSTER )
    {
        //
        //  Commit the base cluster
        //

        hr = THR( HrFormCluster( pClusCfgClusterInfo, (( IClusCfgBaseCluster * ) mqiInterfaces[ 0 ].pItf) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        // Point of no return: Send a special message so that CCommitPage::SendStatusReport will "display error messages as warnings".
        //

        if ( m_picccCallback != NULL )
        {
            hr = THR(
                m_picccCallback->SendStatusReport(
                      NULL
                    , TASKID_Major_Configure_Cluster_Services
                    , TASKID_Minor_Errors_To_Warnings_Point
                    , 0
                    , 1
                    , 1
                    , hr
                    , NULL
                    , NULL
                    , NULL
                    )
                );
        } // if: the callback pointer is not NULL

        //
        //  Commit the post configuration steps
        //

        hr = THR( ppcm->CommitChanges( peccmr, pClusCfgClusterInfo ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  Signal the event to indicate that post configuration is complete.
        //

        if ( SetEvent( heventPostCfgCompletion ) == 0 )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            LogMsg( L"[SRV] Error %#08x occurred trying to signal an event named '%ws'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            goto Cleanup;
        } // if: SetEvent() failed()
    } // if: we are forming a cluster.
    else if ( ecmCommitChangesMode == cmADD_NODE_TO_CLUSTER )
    {
        //
        //  Commit the base cluster
        //

        hr = THR( HrJoinToCluster( pClusCfgClusterInfo, (( IClusCfgBaseCluster * ) mqiInterfaces[ 0 ].pItf) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        // Point of no return: Send a special message so that CCommitPage::SendStatusReport will "display error messages as warnings".
        //

        if ( m_picccCallback != NULL )
        {
            hr = THR(
                m_picccCallback->SendStatusReport(
                      NULL
                    , TASKID_Major_Configure_Cluster_Services
                    , TASKID_Minor_Errors_To_Warnings_Point
                    , 0
                    , 1
                    , 1
                    , hr
                    , NULL
                    , NULL
                    , NULL
                    )
                );
        } // if: the callback pointer is not NULL

        //
        //  Commit the post configuration steps
        //

        hr = THR( ppcm->CommitChanges( peccmr, pClusCfgClusterInfo ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  Signal the event to indicate that post configuration is complete.
        //

        if ( SetEvent( heventPostCfgCompletion ) == 0 )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            LogMsg( L"[SRV] Error %#08x occurred trying to signal an event named '%ws'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            goto Cleanup;
        } // if: SetEvent() failed()
    } // else if: we are joining a cluster
    else if ( ecmCommitChangesMode == cmCLEANUP_NODE_AFTER_EVICT )
    {
        //
        //  This node has been evicted - clean it up.
        //

        hr = THR( HrEvictedFromCluster( ppcm, peccmr, pClusCfgClusterInfo, (( IClusCfgBaseCluster * ) mqiInterfaces[ 0 ].pItf) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // else if: we have just been evicted from a cluster

Cleanup:

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if:

    if ( pcci != NULL )
    {
        pcci->Release();
    } // if:

    if ( ppcm != NULL )
    {
        ppcm->Release();
    } // if:

    if ( peccmr != NULL )
    {
        peccmr->Release();
    } // if:

    if ( mqiInterfaces[ 0 ].pItf != NULL )
    {
        mqiInterfaces[ 0 ].pItf->Release();
    } // if:

    if ( mqiInterfaces[ 1 ].pItf != NULL )
    {
        mqiInterfaces[ 1 ].pItf->Release();
    } // if:

    if ( pClusCfgClusterInfo != NULL )
    {
        pClusCfgClusterInfo->Release();
    } // if:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    if ( heventPostCfgCompletion != NULL )
    {
        //
        // If we had created this event, then signal this event to let the
        // startup notification thread proceed.
        //

        SetEvent( heventPostCfgCompletion );
        CloseHandle( heventPostCfgCompletion );
    } // if:

    if ( FAILED( hr ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Configure_Cluster_Services
                , TASKID_Minor_Server_CommitChanges
                , IDS_ERROR_COMMIT_CHANGES
                , IDS_ERROR_COMMIT_CHANGES_REF
                , hr
                );
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::CommitChanges


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::GetBindingString
//
//  Description:
//      Get the binding string for this server.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::GetBindingString( BSTR * pbstrBindingStringOut )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;

    if ( pbstrBindingStringOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Server_GetBindingString_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_bstrBindingString == NULL )
    {
        hr = S_FALSE;
        LOG_STATUS_REPORT_MINOR( TASKID_Minor_Server_GetBindingString_NULL, L"Binding string is NULL.  Must be a local connection.", hr );
        goto Cleanup;
    } // if:

    *pbstrBindingStringOut = SysAllocString( m_bstrBindingString );
    if ( *pbstrBindingStringOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Server_GetBindingString_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgServer::GetBindingString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::SetBindingString
//
//  Description:
//      Set the binding string of this server.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::SetBindingString( LPCWSTR pcszBindingStringIn )
{
    TraceFunc1( "[IClusCfgServer] pcszBindingStringIn = '%ws'", pcszBindingStringIn == NULL ? L"<null>" : pcszBindingStringIn );

    HRESULT     hr = S_OK;
    BSTR        bstr = NULL;

    if ( pcszBindingStringIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetBindingString_Server, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = bstr;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgServer::SetBindingString


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer class -- IClusCfgCapabilities interfaces.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::CanNodeBeClustered
//
//  Description:
//      Can this node be added to a cluster?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Node can be clustered.
//
//      S_FALSE
//          Node cannot be clustered.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::CanNodeBeClustered( void )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT                 hr;
    ICatInformation *       pici = NULL;
    CATID                   rgCatIds[ 1 ];
    IEnumCLSID *            pieclsids = NULL;
    IClusCfgCapabilities *  piccc = NULL;
    CLSID                   clsid;
    ULONG                   cFetched;
    IUnknown *              punk = NULL;

    //
    //  KB: 10-SEP-2000 GalenB
    //
    //  Last ditch effort to clean up a node that is in a bad state before trying
    //  to add it into a cluster.
    //
    hr = STHR( HrHasNodeBeenEvicted() );
    if ( hr == S_OK )
    {
        hr = THR( HrCleanUpNode() ) ;
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // else if:

    rgCatIds[ 0 ] = CATID_ClusCfgCapabilities;

    hr = THR( CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC_SERVER, IID_ICatInformation, (void **) &pici ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"Failed to CoCreate CLSID_StdComponentCategoriesMgr component", hr );
        goto Cleanup;
    }

    hr = THR( pici->EnumClassesOfCategories( 1, rgCatIds, 0, NULL, &pieclsids ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"Failed to get enumerator for the IClusCfgClusterCapabilites components", hr );
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        hr = STHR( pieclsids->Next( 1, &clsid, &cFetched ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"IClusCfgClusterCapabilites component enumerator failed", hr );
            break;
        } // if:

        if ( ( hr == S_FALSE ) && ( cFetched == 0 ) )
        {
            hr = S_OK;
            break;
        } // if:

        hr = THR( HrCoCreateInternalInstance( clsid, NULL, CLSCTX_ALL, IID_IClusCfgCapabilities, (void **) &piccc ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"Failed to CoCreate IClusCfgClusterCapabilites component", hr );
            continue;
        } // if:

        hr = THR( piccc->TypeSafeQI( IUnknown, &punk ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"Failed to QI IClusCfgClusterCapabilites component for IUnknown", hr );
            piccc->Release();
            piccc = NULL;
            continue;
        } // if:

        hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"Failed to initialize IClusCfgClusterCapabilites component", hr );
            piccc->Release();
            piccc = NULL;
            punk->Release();
            punk = NULL;
            continue;
        } // if:

        punk->Release();
        punk = NULL;

        hr = STHR( piccc->CanNodeBeClustered() );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"IClusCfgClusterCapabilites component failed in CanNodeBeClustered()", hr );
            piccc->Release();
            piccc = NULL;
            continue;
        } // if:

        if ( hr == S_FALSE )
        {
            m_fCanBeClustered = false;
        } // if:

        piccc->Release();
        piccc = NULL;
    } // for:

    if ( !m_fCanBeClustered )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( piccc != NULL )
    {
        piccc->Release();
    } // if:

    if ( pieclsids != NULL )
    {
        pieclsids->Release();
    } // if:

    if ( pici != NULL )
    {
        pici->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::CanNodeBeClustered


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer class -- IClusCfgPollingCallbackInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::GetCallback
//
//  Description:
//      Return the pointer to the embedded polling callback object.
//
//  Arguments:
//      ppiccpcOut
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::GetCallback( IClusCfgPollingCallback ** ppiccpcOut )
{
    TraceFunc( "[IClusCfgServer]" );
    Assert( m_picccCallback != NULL );

    HRESULT hr = S_OK;

    if ( ppiccpcOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Establish_Connection, TASKID_Minor_GetCallback, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( m_picccCallback->TypeSafeQI( IClusCfgPollingCallback, ppiccpcOut ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgServer::GetCallback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::SetPollingMode
//
//  Description:
//      Set the polling mode of the callback.
//
//  Arguments:
//      fPollingModeIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::SetPollingMode( BOOL fPollingModeIn )
{
    TraceFunc( "[IClusCfgServer]" );
    Assert( m_picccCallback != NULL );

    HRESULT                         hr = S_OK;
    IClusCfgSetPollingCallback *    piccspc = NULL;

    m_fUsePolling = fPollingModeIn;

    hr = THR( m_picccCallback->TypeSafeQI( IClusCfgSetPollingCallback, &piccspc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccspc->SetPollingMode( m_fUsePolling ) );

Cleanup:

    if ( piccspc != NULL )
    {
        piccspc->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::SetPollingMode


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer class -- IClusCfgVerify interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::VerifyCredentials
//
//  Description:
//      Validate the passed in credentials.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The credentials are valid.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::VerifyCredentials(
    LPCWSTR pcszNameIn,
    LPCWSTR pcszDomainIn,
    LPCWSTR pcszPasswordIn
    )
{
    TraceFunc( "[IClusCfgVerify]" );

    HRESULT         hr = S_OK;
    HANDLE          hToken = NULL;
    DWORD           dwSidSize = 0;
    DWORD           dwDomainSize = 0;
    SID_NAME_USE    snuSidNameUse;
    DWORD           sc;
    BSTR            bstrDomainName = NULL;

    //
    //  Try to find out how much space is required by the SID.  If we don't fail with
    //  insufficient buffer then we know the account exists.
    //

    hr = THR( HrFormatStringIntoBSTR( L"%1!ws!\\%2!ws!", &bstrDomainName, pcszDomainIn, pcszNameIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( LookupAccountName( NULL, bstrDomainName, NULL, &dwSidSize, NULL, &dwDomainSize, &snuSidNameUse ) == FALSE )
    {
        sc = GetLastError();

        if ( sc != ERROR_INSUFFICIENT_BUFFER )
        {
            TW32( sc );
            hr = HRESULT_FROM_WIN32( sc );

            STATUS_REPORT_STRING2_REF(
                      TASKID_Minor_Validating_Credentials
                    , TASKID_Minor_Invalid_Domain_User
                    , IDS_ERROR_INVALID_DOMAIN_USER
                    , pcszNameIn
                    , pcszDomainIn
                    , IDS_ERROR_INVALID_DOMAIN_USER_REF
                    , hr
                    );
            goto Cleanup;
        } // if:
    } // if:

    //
    //  Logon the passed in user to ensure that it is valid.
    //

    if ( !LogonUserW(
              const_cast< LPWSTR >( pcszNameIn )
            , const_cast< LPWSTR >( pcszDomainIn )
            , const_cast< LPWSTR >( pcszPasswordIn )
            , LOGON32_LOGON_NETWORK
            , LOGON32_PROVIDER_DEFAULT
            , &hToken
            ) )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );

        STATUS_REPORT_STRING2_REF(
                  TASKID_Minor_Validating_Credentials
                , TASKID_Minor_Invalid_Credentials
                , IDS_ERROR_INVALID_CREDENTIALS
                , pcszNameIn
                , pcszDomainIn
                , IDS_ERROR_INVALID_CREDENTIALS_REF
                , hr
                );
        goto Cleanup;
    } // if:

Cleanup:

    TraceSysFreeString( bstrDomainName );

    if ( hToken != NULL )
    {
        CloseHandle( hToken );
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::VerifyCredentials


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::VerifyConnectionToCluster
//
//  Description:
//      Verify that that this server is the same as the passed in server.
//
//  Arguments:
//      pcszClusterNameIn
//
//  Return Value:
//      S_OK
//          This is the server.
//
//      S_FALSE
//          This is not the server.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::VerifyConnectionToCluster(
    LPCWSTR pcszClusterNameIn
    )
{
    TraceFunc1( "[IClusCfgVerify] pcszClusterNameIn = '%ws'", pcszClusterNameIn );

    DWORD       sc;
    DWORD       dwClusterState;
    HRESULT     hr = S_OK;
    HCLUSTER    hCluster = NULL;
    BSTR        bstrClusterName = NULL;
    BSTR        bstrLocalFQDN = NULL;
    BSTR        bstrGivenHostname = NULL;
    size_t      idxGivenDomain = 0;
    size_t      idxLocalDomain = 0;

    //
    //  Test arguments
    //

    if ( pcszClusterNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        STATUS_REPORT_REF( TASKID_Minor_Connecting, TASKID_Minor_VerifyConnection_InvalidArg, IDS_ERROR_INVALIDARG, IDS_ERROR_INVALIDARG_REF, hr );
        goto Cleanup;
    } // if:

    //
    //  Gather names necessary for informative status reports.
    //
    hr = THR( HrGetComputerName(
          ComputerNamePhysicalDnsFullyQualified
        , &bstrLocalFQDN
        , FALSE // fBestEffortIn
        ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrFindDomainInFQN( bstrLocalFQDN, &idxLocalDomain ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrFindDomainInFQN( pcszClusterNameIn, &idxGivenDomain ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Get the hostname label from the given name.
    //

    hr = THR( HrExtractPrefixFromFQN( pcszClusterNameIn, &bstrGivenHostname ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  See if we are clustered.
    //

    sc = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if : GetClusterState() failed

    //
    //  If the current cluster node state is neither "running" nor "not running,"
    //  then this node is not part of a cluster.
    //

    if ( ( dwClusterState != ClusterStateNotRunning ) && ( dwClusterState != ClusterStateRunning ) )
    {
        hr = S_FALSE;
        STATUS_REPORT_STRING3(
              TASKID_Minor_Connecting
            , TASKID_Minor_VerifyConnection_MachineNotInCluster
            , IDS_WARN_MACHINE_NOT_IN_CLUSTER
            , bstrGivenHostname
            , pcszClusterNameIn + idxGivenDomain
            , bstrLocalFQDN
            , hr
            );
        goto Cleanup;
    } // if:

    //
    //  If given name is an FQDN, its hostname label needs to match the cluster's.
    //

    hr = STHR( HrFQNIsFQDN( pcszClusterNameIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
    else if ( hr == S_OK )
    {
        //
        //  Open the cluster to get the cluster's name.
        //

        hCluster = OpenCluster( NULL );
        if ( hCluster == NULL )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            STATUS_REPORT_REF(
                  TASKID_Minor_Connecting
                , TASKID_Minor_VerifyConnection_OpenCluster
                , IDS_ERROR_OPEN_CLUSTER_FAILED
                , IDS_ERROR_OPEN_CLUSTER_FAILED_REF
                , hr
                );
            goto Cleanup;
        } // if:

        //
        //  Try to get the cluster's name.
        //

        hr = THR( HrGetClusterInformation( hCluster, &bstrClusterName, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  If they don't match, the client has connected to an unexpected place.
        //

        if ( NBSTRCompareNoCase( bstrGivenHostname, bstrClusterName ) != 0 )
        {
            hr = S_FALSE;
            STATUS_REPORT_STRING3(
                  TASKID_Minor_Connecting
                , TASKID_Minor_VerifyConnection_Cluster_Name_Mismatch
                , IDS_WARN_CLUSTER_NAME_MISMATCH
                , bstrGivenHostname
                , pcszClusterNameIn + idxGivenDomain
                , bstrClusterName
                , hr
                );
            goto Cleanup;
        }
    }
    else if ( hr == S_FALSE )
    {
        //
        //  pcszClusterNameIn is an FQIP.  Nothing to do regarding the hostname prefix in this case,
        //  but reset hr to S_OK to avoid returning bogus errors.
        hr = S_OK;
    }

    //
    //  Make sure we are in the expected domain.
    //
    if ( ClRtlStrICmp( pcszClusterNameIn + idxGivenDomain, bstrLocalFQDN + idxLocalDomain ) != 0 )
    {
        hr = S_FALSE;
        STATUS_REPORT_NODESTRING2(
              pcszClusterNameIn
            , TASKID_Minor_Connecting
            , TASKID_Minor_VerifyConnection_Cluster_Domain_Mismatch
            , IDS_WARN_CLUSTER_DOMAIN_MISMATCH
            , pcszClusterNameIn + idxGivenDomain
            , bstrLocalFQDN + idxLocalDomain
            , hr
            );
        goto Cleanup;
    } // if:

    Assert( hr == S_OK );
    goto Cleanup;

Cleanup:

    if ( hr == S_FALSE )
    {
        LOG_STATUS_REPORT( L"Server name does not match what client is expecting.", hr );
    } // if:
    else if ( hr == S_OK )
    {
        LOG_STATUS_REPORT( L"Server name matches what client is expecting.", hr );
    } // else if:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    TraceSysFreeString( bstrClusterName );
    TraceSysFreeString( bstrLocalFQDN );
    TraceSysFreeString( bstrGivenHostname );

    HRETURN( hr );

} // ClusCfgServer::VerifyConnection


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::VerifyConnectionToNode
//
//  Description:
//      Verify that that this server is the same as the passed in server.
//
//  Arguments:
//      pcszNodeNameIn
//
//  Return Value:
//      S_OK
//          This is the server.
//
//      S_FALSE
//          This is not the server.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::VerifyConnectionToNode(
    LPCWSTR pcszNodeNameIn
    )
{
    TraceFunc1( "[IClusCfgVerify] pcszNodeNameIn = '%ws'", pcszNodeNameIn );

    HRESULT     hr = S_FALSE;

    Assert( m_bstrNodeName != NULL );

    //
    //  Test arguments
    //

    if ( pcszNodeNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    hr = STHR( HrFQNIsFQDN( pcszNodeNameIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_OK )
    {
        if ( ClRtlStrICmp( pcszNodeNameIn, m_bstrNodeName ) != 0 )
        {
            hr = S_FALSE;
            STATUS_REPORT_STRING2(
                  TASKID_Minor_Connecting
                , TASKID_Minor_VerifyConnection_Node_FQDN_Mismatch
                , IDS_WARN_NODE_FQDN_MISMATCH
                , pcszNodeNameIn
                , m_bstrNodeName
                , hr
                );
            goto Cleanup;
        }
    }
    else    //  pcszNodeNameIn is an FQIP, so compare only domains.
    {
        //
        //  pcszNodeNameIn is an FQIP, so compare only domains.
        //

        size_t  idxGivenDomain = 0;
        size_t  idxThisDomain = 0;

        hr = THR( HrFindDomainInFQN( pcszNodeNameIn, &idxGivenDomain ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrFindDomainInFQN( m_bstrNodeName, &idxThisDomain ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( ClRtlStrICmp( pcszNodeNameIn + idxGivenDomain, m_bstrNodeName + idxThisDomain ) == 0 )
        {
            hr = S_OK;
        } // if:
        else
        {
            hr = S_FALSE;
            STATUS_REPORT_NODESTRING2(
                  pcszNodeNameIn
                , TASKID_Minor_Connecting
                , TASKID_Minor_VerifyConnection_Node_Domain_Mismatch
                , IDS_WARN_NODE_DOMAIN_MISMATCH
                , pcszNodeNameIn + idxGivenDomain
                , m_bstrNodeName
                , hr
                );
            goto Cleanup;
        }
    }

Cleanup:

    if ( hr == S_FALSE )
    {
        LogMsg( L"[SRV] VerifyConnection - Server name does not match what client is expecting." );
    } // if:
    else if ( hr == S_OK )
    {
        LogMsg( L"[SRV] VerifyConnection - Server name matches what client is expecting." );
    } // else if:

    HRETURN( hr );

} //*** ClusCfgServer::VerifyConnectionToNode


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrInit( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_FALSE;
    IUnknown *  punk = NULL;

    // IUnknown
    Assert( m_cRef == 1 );

    hr = THR( CClusCfgCallback::S_HrCreateInstance( &punk ) );
    if ( FAILED ( hr ) )
    {
        LogMsg( L"[SRV] Could not create CClusCfgCallback. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] Could not QI callback for a punk. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    //
    //  Save off the local computer name.
    //  If we can't get the fully-qualified name, just get the NetBIOS name.
    //

    hr = THR( HrGetComputerName(
                  ComputerNameDnsFullyQualified
                , &m_bstrNodeName
                , TRUE // fBestEffortIn
                ) );
    if ( FAILED( hr ) )
    {
        THR( hr );
        LogMsg( L"[SRV] An error occurred trying to get the fully-qualified Dns name for the local machine during initialization. (hr = %#08x)", hr );
        goto Cleanup;
    } // if: error getting computer name

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrInitializeForLocalServer
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrInitializeForLocalServer( void )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    IWbemLocator *  pIWbemLocator = NULL;
    BSTR            bstrNameSpace = NULL;

    hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pIWbemLocator );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Establish_Connection
                , TASKID_Minor_HrInitializeForLocalServer_WbemLocator
                , IDS_ERROR_WBEM_LOCATOR_CREATE_FAILED
                , IDS_ERROR_WBEM_LOCATOR_CREATE_FAILED_REF
                , hr
                );
        goto Cleanup;
    } // if:

    bstrNameSpace = TraceSysAllocString( L"\\\\.\\root\\cimv2" );
    if ( bstrNameSpace == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF(
                  TASKID_Major_Establish_Connection
                , TASKID_Minor_HrInitializeForLocalServer_Memory
                , IDS_ERROR_OUTOFMEMORY
                , IDS_ERROR_OUTOFMEMORY_REF
                , hr
                );
        goto Cleanup;
    } // if:

    hr = THR( pIWbemLocator->ConnectServer(
                            bstrNameSpace,
                            NULL,                   // using current account for simplicity
                            NULL,                   // using current password for simplicity
                            NULL,                   // locale
                            0L,                     // securityFlags, reserved must be 0
                            NULL,                   // authority (domain for NTLM)
                            NULL,                   // context
                            &m_pIWbemServices
                            ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Establish_Connection
                , TASKID_Minor_WBEM_Connection_Failure
                , IDS_ERROR_WBEM_CONNECTION_FAILURE
                , IDS_ERROR_WBEM_CONNECTION_FAILURE_REF
                , hr
                );
        goto Cleanup;
    } // if:

    hr = THR( HrSetBlanket() );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT_MINOR(
                  TASKID_Minor_HrInitializeForLocalServer_Blanket
                , L"[SRV] The security rights and impersonation levels cannot be set on the connection to the Windows Management Instrumentation service."
                , hr
                );
        goto Cleanup;
    } // if:

Cleanup:

    TraceSysFreeString( bstrNameSpace );

    if ( pIWbemLocator != NULL )
    {
        pIWbemLocator->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrInitializeForLocalServer


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrSetBlanket
//
//  Description:
//      Adjusts the security blanket on the IWbemServices pointer.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrSetBlanket( void )
{
    TraceFunc( "" );
    Assert( m_pIWbemServices != NULL );

    HRESULT hr = S_FALSE;

    if ( m_pIWbemServices )
    {
        IClientSecurity *   pCliSec;

        hr = THR( m_pIWbemServices->TypeSafeQI( IClientSecurity, &pCliSec ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pCliSec->SetBlanket(
                            m_pIWbemServices,
                            RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE,
                            NULL,
                            RPC_C_AUTHN_LEVEL_CONNECT,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            NULL,
                            EOAC_NONE
                            ) );

            pCliSec->Release();
        } // if:
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrSetBlanket


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrFormCluster
//
//  Description:
//      Form a new cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrFormCluster(
    IClusCfgClusterInfo *   piccciIn,
    IClusCfgBaseCluster *   piccbcaIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    BSTR                    bstrClusterName = NULL;
    BSTR                    bstrClusterBindingString = NULL;
    BSTR                    bstrClusterIPNetwork = NULL;
    ULONG                   ulClusterIPAddress = 0;
    ULONG                   ulClusterIPSubnetMask = 0;
    IClusCfgCredentials *   picccServiceAccount = NULL;
    IClusCfgNetworkInfo *   piccni = NULL;

    //
    // Get the parameters required to form a cluster.
    //

    hr = THR( piccciIn->GetName( &bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the name of the cluster

    TraceMemoryAddBSTR( bstrClusterName );

    hr = STHR( piccciIn->GetBindingString( &bstrClusterBindingString ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the binding string of the cluster.

    TraceMemoryAddBSTR( bstrClusterBindingString );

    hr = THR( piccciIn->GetClusterServiceAccountCredentials( &picccServiceAccount ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the cluster service account credentials

    hr = THR( piccciIn->GetIPAddress( &ulClusterIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the cluster IP address

    hr = THR( piccciIn->GetSubnetMask( &ulClusterIPSubnetMask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the cluster subnet mask

    hr = THR( piccciIn->GetNetworkInfo( &piccni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the network info of the network the cluster name should be on.

    hr = THR( piccni->GetName( &bstrClusterIPNetwork ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the name of the cluster name network.

    TraceMemoryAddBSTR( bstrClusterIPNetwork );

    //
    // Indicate that a cluster should be created when Commit() is called.
    //
    hr = THR( piccbcaIn->SetCreate(
                          bstrClusterName
                        , bstrClusterBindingString
                        , picccServiceAccount
                        , ulClusterIPAddress
                        , ulClusterIPSubnetMask
                        , bstrClusterIPNetwork
                        ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: SetCreate() failed.

    // Initiate cluster creation.
    hr = THR( piccbcaIn->Commit() );

Cleanup:

    TraceSysFreeString( bstrClusterName );
    TraceSysFreeString( bstrClusterBindingString );
    TraceSysFreeString( bstrClusterIPNetwork );

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    if ( picccServiceAccount != NULL )
    {
        picccServiceAccount->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrFormCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrJoinToCluster
//
//  Description:
//      Join a node to a cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrJoinToCluster(
    IClusCfgClusterInfo *   piccciIn,
    IClusCfgBaseCluster *   piccbcaIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    BSTR                    bstrClusterName = NULL;
    BSTR                    bstrClusterBindingString = NULL;
    IClusCfgCredentials *   picccServiceAccount = NULL;

    //
    // Get the parameters required to form a cluster.
    //

    hr = THR( piccciIn->GetName( &bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the name of the cluster

    TraceMemoryAddBSTR( bstrClusterName );

    hr = THR( piccciIn->GetBindingString( &bstrClusterBindingString ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the cluster binding string.

    TraceMemoryAddBSTR( bstrClusterBindingString );

    hr = THR( piccciIn->GetClusterServiceAccountCredentials( &picccServiceAccount ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the cluster service account credentials

    //
    // Indicate that a cluster should be formed when Commit() is called.
    //
    hr = THR( piccbcaIn->SetAdd( bstrClusterName, bstrClusterBindingString, picccServiceAccount ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: SetAdd() failed.

    // Initiate joining of the node to the cluster.
    hr = THR( piccbcaIn->Commit() );

Cleanup:

    TraceSysFreeString( bstrClusterName );
    TraceSysFreeString( bstrClusterBindingString );

    if ( picccServiceAccount != NULL )
    {
        picccServiceAccount->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrJoinToCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrEvictedFromCluster
//
//  Description:
//      Cleanup after a node has been evicted from a cluster. If another cleanup
//      session is in progress, wait for it to complete and then attempt cleanup.
//      In this way, if the other cleanup failed, this will retry it. If it had
//      suceeded, this will do nothing.
//
//      This function first calls the CommitChanges() method of the PostConfigManager
//      (which will inform resource types and memberset listeners that this node
//      has been evicted). It then cleans up the base cluster.
//
//  Arguments:
//      ppcmIn
//          Pointer to the IPostCfgManager interface
//
//      peccmrIn
//          Argument needed by the IPostCfgManager::CommitChanges()
//
//      piccciIn
//          Pointer to the cluster info
//
//      piccbcaIn
//          Pointer to the IClusCfgBaseCluster interface that is used to clean up
//          the base cluster.
//
//  Return Value:
//      S_OK
//          If everything went well
//
//      other HRESULTs
//          If the call failed
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrEvictedFromCluster(
    IPostCfgManager *               ppcmIn,
    IEnumClusCfgManagedResources *  peccmrIn,
    IClusCfgClusterInfo *           piccciIn,
    IClusCfgBaseCluster *           piccbcaIn
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    DWORD           dwStatus = ERROR_SUCCESS;
    HANDLE          hsCleanupLock = NULL;
    HANDLE          heventCleanupComplete = NULL;
    bool            fLockAcquired = false;
    DWORD           dwClusterState;
    HKEY            hNodeStateKey = NULL;
    DWORD           dwEvictState = 1;

    LogMsg( "[SRV] Creating cleanup lock." );

    // First, try and acquire a lock, so that two cleanup operations cannot overlap.
    hsCleanupLock = CreateSemaphore( NULL, 1, 1, CLEANUP_LOCK_NAME );
    if ( hsCleanupLock == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        LogMsg( "[SRV] Error %#08x occurred trying to create the cleanup lock.", hr );
        goto Cleanup;
    } // CreateSemaphore() failed

    LogMsg( "[SRV] Acquiring cleanup lock." );

    do
    {
        // Wait for any message sent or posted to this queue
        // or for our lock to be released.
        dwStatus = MsgWaitForMultipleObjects( 1, &hsCleanupLock, FALSE, CC_DEFAULT_TIMEOUT, QS_ALLINPUT );

        // The result tells us the type of event we have.
        if ( dwStatus == ( WAIT_OBJECT_0 + 1 ) )
        {
            MSG msg;

            // Read all of the messages in this next loop,
            // removing each message as we read it.
            while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
            {
                // If it is a quit message, we are done pumping messages.
                if ( msg.message == WM_QUIT)
                {
                    TraceFlow( "Get a WM_QUIT message. Cleanup message pump loop." );
                    break;
                } // if: we got a WM_QUIT message

                // Otherwise, dispatch the message.
                DispatchMessage( &msg );
            } // while: there are still messages in the window message queue

        } // if: we have a message in the window message queue
        else
        {
            if ( dwStatus == WAIT_OBJECT_0 )
            {
                fLockAcquired = true;
                LogMsg( "[SRV] Cleanup lock acquired." );
                break;
            } // else if: our lock is signaled
            else
            {
                if ( dwStatus == -1 )
                {
                    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                    LogMsg( "[SRV] Error %#08x occurred trying to wait for our lock to be granted.", hr );
                } // if: MsgWaitForMultipleObjects() returned an error
                else
                {
                    hr = THR( HRESULT_FROM_WIN32( dwStatus ) );
                    LogMsg( "[SRV] An error occurred trying to wait for our lock to be granted. Status code is %#08x.", dwStatus );
                } // else: an unexpected value was returned by MsgWaitForMultipleObjects()

                break;
            } // else: an unexpected result
        } // else: MsgWaitForMultipleObjects() exited for a reason other than a waiting message
    }
    while( true ); // do-while: loop infinitely

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not acquire the cleanup lock


    // Check if the install state is correct before invoking post configuration manager.
    // Ignore the case where the service does not exist so that we can do our job.
    dwStatus = GetNodeClusterState( NULL, &dwClusterState );
    if ( dwStatus == ERROR_SERVICE_DOES_NOT_EXIST )
    {
        LogMsg( "[SRV] GetNodeClusterState() determined that the cluster service does not exist." );
    }
    else if ( dwStatus != ERROR_SUCCESS )
    {
        LogMsg( "[SRV] Error %#08x occurred trying to determine the installation state of this node.", dwStatus );
        hr = HRESULT_FROM_WIN32( TW32( dwStatus ) );
        goto Cleanup;
    } // if : GetClusterState() failed

    // Check if this node is part of a cluster.
    if ( ( dwClusterState != ClusterStateNotRunning ) && ( dwClusterState != ClusterStateRunning ) )
    {
        LogMsg( "[SRV] This node is not part of a cluster - no cleanup is necessary." );
        goto Cleanup;
    } // if: this node is not part of a cluster


    //
    // Set a registry value indicating that this node has been evicted.
    // If, for some reason, the cleanup could not be completed, the cluster
    // service will check this flag the next time it comes up and restarts
    // cleanup.
    //

    dwStatus = TW32(
        RegOpenKeyEx(
              HKEY_LOCAL_MACHINE
            , CLUSREG_KEYNAME_NODE_DATA
            , 0
            , KEY_ALL_ACCESS
            , &hNodeStateKey
            )
        );

    if ( dwStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        LogMsg( "[SRV] Error %#08x occurred trying to open a registry key to set a value indicating that this node has been evicted.", dwStatus );
        goto Cleanup;
    } // if: RegOpenKeyEx() has failed

    dwStatus = TW32(
        RegSetValueEx(
              hNodeStateKey
            , CLUSREG_NAME_EVICTION_STATE
            , 0
            , REG_DWORD
            , reinterpret_cast< const BYTE * >( &dwEvictState )
            , sizeof( dwEvictState )
            )
        );

    if ( dwStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        LogMsg( "[SRV] Error %#08x occurred trying to set a registry value indicating that this node has been evicted.", dwStatus );
        goto Cleanup;
    } // if: RegSetValueEx() has failed

    // Commit the post configuration steps first
    hr = THR( ppcmIn->CommitChanges( peccmrIn, piccciIn ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[SRV] Error %#08x occurred during the post configuration step of cleanup.", hr );
        goto Cleanup;
    } // if: post configuration failed

    TraceFlow( "IPostCfgManager::CommitChanges() completed successfully during cleanup." );

    hr = THR( piccbcaIn->SetCleanup() );
    if ( FAILED( hr ) )
    {
        LogMsg( "[SRV] Error %#08x occurred initiating cleanup of the base cluster.", hr );
        goto Cleanup;
    } // if: SetCleanup() failed

    // Initiate the cleanup
    hr = THR( piccbcaIn->Commit() );
    if ( FAILED( hr ) )
    {
        LogMsg( "[SRV] Error %#08x occurred trying to cleanup the base cluster.", hr );
        goto Cleanup;
    } // if: base cluster cleanup failed

    LogMsg( "[SRV] Base cluster successfully cleaned up." );

    // If we are here, then cleanup has completed successfully. If some other process is waiting
    // for cleanup to complete, release that process by signaling an event.

    // Open the event. Note, if this event does not already exist, then it means that nobody is
    // waiting on this event. So, it is ok for OpenEvent to fail.
    heventCleanupComplete = OpenEvent( EVENT_ALL_ACCESS, FALSE, SUCCESSFUL_CLEANUP_EVENT_NAME );
    if ( heventCleanupComplete == NULL )
    {
        dwStatus = GetLastError();
        LogMsg( "[SRV] Status %#08x was returned trying to open the cleanup completion event. This just means that no process is waiting on this event.", dwStatus );
        goto Cleanup;
    } // if: OpenEvent() failed

    if ( PulseEvent( heventCleanupComplete ) == FALSE )
    {
        // Error, but not fatal. hr should still be S_OK.
        dwStatus = TW32( GetLastError() );
        LogMsg( "[SRV] Error %#08x occurred trying to pulse the cleanup completion event. This is not a fatal error.", dwStatus );
        goto Cleanup;
    } // if: PulseEvent() failed

    TraceFlow( "Cleanup completion event has been set." );

Cleanup:

    if ( heventCleanupComplete == NULL )
    {
        CloseHandle( heventCleanupComplete );
    } // if: we had opened the cleanup complete event

    if ( hsCleanupLock != NULL )
    {
        if ( fLockAcquired )
        {
            ReleaseSemaphore( hsCleanupLock, 1, NULL );

            LogMsg( "[SRV] Cleanup lock released." );
        } // if: we have acquired the semaphore but not released it yet

        CloseHandle( hsCleanupLock );
    } // if: we had created a cleanup lock

    if ( hNodeStateKey != NULL )
    {
        RegCloseKey( hNodeStateKey );
    } // if: we had opened the node state registry key

    HRETURN( hr );

} //*** CClusCfgServer::HrEvictedFromCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrHasNodeBeenEvicted
//
//  Description:
//      Has this node been evicted?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The node needs to be cleanedup.
//
//      S_FALSE
//          The node does not need to be cleanup.
//
//      Win32 error as HRESULT.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrHasNodeBeenEvicted( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwClusterState;
    BOOL    fEvicted = false;

    sc = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if : GetClusterState() failed

    //
    //  If the cluster service is not running then we need to check if we should
    //  clean it up or not.
    //
    if ( dwClusterState == ClusterStateNotRunning )
    {
        sc = TW32( ClRtlHasNodeBeenEvicted( &fEvicted ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:

        if ( fEvicted )
        {
            hr = S_OK;
        } // if:
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgServer::HrHasNodeBeenEvicted

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrCleanUpNode
//
//  Description:
//      Cleanup this node because it was evicted.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrCleanUpNode( void )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    IClusCfgEvictCleanup *  pcceEvict = NULL;

    hr = THR(
        CoCreateInstance(
              CLSID_ClusCfgEvictCleanup
            , NULL
            , CLSCTX_LOCAL_SERVER
            , __uuidof( pcceEvict )
            , reinterpret_cast< void ** >( &pcceEvict )
            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: the ClusCfgEvictCleanup object could not be created

    hr = THR( pcceEvict->CleanupLocalNode( 0 ) );   // 0 means "cleanup immediately"
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: an error occurred during cleanup

Cleanup:

    if ( pcceEvict != NULL )
    {
        pcceEvict->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrCleanUpNode


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrCreateClusterNodeInfo
//
//  Description:
//      Create the cluster node info object and store it in the member
//      variable.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrCreateClusterNodeInfo( void )
{
    TraceFunc( "" );
    Assert( m_punkNodeInfo == NULL );

    HRESULT hr = S_OK;

    hr = THR( CClusCfgNodeInfo::S_HrCreateInstance( &m_punkNodeInfo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_punkNodeInfo = TraceInterface( L"CClusCfgNodeInfo", IUnknown, m_punkNodeInfo, 1 );

    hr = THR( HrSetInitialize( m_punkNodeInfo, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( m_punkNodeInfo, m_pIWbemServices ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgServer::HrCreateClusterNodeInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgpartitioninfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgPartitionInfo.h
//
//  Description:
//      This file contains the declaration of the CClusCfgPartitionInfo
//      class.
//
//      The class CClusCfgPartitionInfo represents a disk partition.
//      It implements the IClusCfgPartitionInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgPartitionInfo.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgPartitionInfo
//
//  Description:
//      The class CClusCfgPartitionInfo represents a disk partition.
//
//  Interfaces:
//      IClusCfgPartitionInfo
//      IClusCfgWbemServices
//      IClusCfgSetWbemObject
//      IClusCfgInitialize
//      IClusCfgPartitionProperties
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgPartitionInfo
    : public IClusCfgPartitionInfo
    , public IClusCfgWbemServices
    , public IClusCfgSetWbemObject
    , public IClusCfgInitialize
    , public IClusCfgPartitionProperties
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    BSTR                m_bstrName;
    BSTR                m_bstrUID;
    BSTR                m_bstrDescription;
    IUnknown *          ((*m_prgLogicalDisks)[]);
    ULONG               m_idxNextLogicalDisk;
    ULONG               m_ulPartitionSize;
    BSTR                m_bstrDiskDeviceID;

    // Private constructors and destructors
    CClusCfgPartitionInfo( void );
    ~CClusCfgPartitionInfo( void );

    // Private copy constructor to prevent copying.
    CClusCfgPartitionInfo( const CClusCfgPartitionInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgPartitionInfo & operator = ( const CClusCfgPartitionInfo & nodeSrc );

    HRESULT HrInit( BSTR bstrDeviceIDIn = NULL );
    HRESULT HrAddLogicalDiskToArray( IWbemClassObject * pDiskIn );
    HRESULT HrGetLogicalDisks( IWbemClassObject * pPartitionIn );
    HRESULT HrLogLogicalDiskInfo( IWbemClassObject * pLogicalDiskIn, BSTR bstrDeviceIDIn );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut, BSTR bstrDeviceIDIn );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interface
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgSetWbemObject Interfaces
    //

    STDMETHOD( SetWbemObject )( IWbemClassObject * pPartitionIn, bool * pfRetainObjectOut );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR bstrNameIn );

    STDMETHOD( GetDescription )( BSTR * pbstrDescriptionOut );

    STDMETHOD( SetDescription )( LPCWSTR bstrDescriptionIn );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterUsageOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappingIn );

    STDMETHOD( GetSize )( ULONG * pcMegaBytes );

    //
    // IClusCfgPartitionProperties Interface
    //

    STDMETHOD( IsThisLogicalDisk )( WCHAR cLogicalDisk );

    STDMETHOD( IsNTFS )( void );

    STDMETHOD( GetFriendlyName )( BSTR * pbstrNameOut );

}; //*** Class CClusCfgPartitionInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgnetworkinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CClusCfgNetworkInfo.h
//
//  Description:
//      This file contains the declaration of the CClusCfgNetworkInfo
//      class.
//
//      The class CClusCfgNetworkInfo is the representation of a
//      cluster manageable network. It implements the IClusCfgNetworkInfo
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgNetworkInfo.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//  Remarks:
//      None.
//
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgNetworkInfo
//
//  Description:
//      The class CClusCfgNetworkInfo is the enumeration of
//      cluster manageable devices.
//
//  Interfaces:
//      IClusCfgNetworkInfo
//      IClusCfgNetworkAdapterInfo
//      IClusCfgWbemServices
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgNetworkInfo
    : public IClusCfgNetworkInfo
    , public IClusCfgSetWbemObject
    , public IClusCfgWbemServices
    , public IEnumClusCfgIPAddresses
    , public IClusCfgInitialize
    , public IClusCfgClusterNetworkInfo
{
private:

    enum EStates
    {
        eIsPrivate = 1,
        eIsPublic  = 2
    };

    //
    // Private member functions and data
    //

    LONG                    m_cRef;
    DWORD                   m_dwFlags;
    LCID                    m_lcid;
    BSTR                    m_bstrName;
    BSTR                    m_bstrDescription;
    BSTR                    m_bstrDeviceID;
    BSTR                    m_bstrConnectionName;
    IWbemServices *         m_pIWbemServices;
    IUnknown *              m_punkAddresses;
    IClusCfgCallback *      m_picccCallback;
    BOOL                    m_fNameChanged;
    BOOL                    m_fDescriptionChanged;
    BOOL                    m_fIsClusterNetwork;

    // Private constructors and destructors
    CClusCfgNetworkInfo( void );
    ~CClusCfgNetworkInfo( void );

    // Private copy constructor to prevent copying.
    CClusCfgNetworkInfo( const CClusCfgNetworkInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgNetworkInfo & operator = ( const CClusCfgNetworkInfo & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrInit( HNETWORK hNetworkIn, HNETINTERFACE hNetInterfaceIn );
    HRESULT HrLoadEnum(  IWbemClassObject * pNetworkAdapterIn, bool * pfRetainObjectOut );
    HRESULT HrCreateEnum( void );
    HRESULT HrCreateEnumAndAddIPAddress( ULONG ulIPAddressIn, ULONG ulSubnetMaskIn );
    HRESULT HrGetPrimaryNetworkAddress( IClusCfgIPAddressInfo ** ppIPAddressOut, ULONG * pcFetched );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrCreateInstance(
            HNETWORK        hNetworkIn
          , HNETINTERFACE   hNetInterfaceIn
          , IUnknown *      punkCallbackIn
          , LCID            lcidIn
          , IWbemServices * pIWbemServicesIn
          , IUnknown **     ppunkOut
          );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgNetworkInfo Interfaces.
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );

    STDMETHOD( GetDescription )( BSTR * pbstrDescriptionOut );

    STDMETHOD( SetDescription )( LPCWSTR pcszDescriptionIn );

    STDMETHOD( GetPrimaryNetworkAddress )( IClusCfgIPAddressInfo ** ppIPAddressOut );

    STDMETHOD( SetPrimaryNetworkAddress )( IClusCfgIPAddressInfo * pIPAddressIn );

    STDMETHOD( IsPublic )( void );

    STDMETHOD( SetPublic )( BOOL fIsPublicIn );

    STDMETHOD( IsPrivate )( void );

    STDMETHOD( SetPrivate )( BOOL fIsPrivateIn );

    //
    // IEnumClusCfgIPAddresses Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgIPAddressInfo ** rgpIPAddressInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

    //
    // IClusCfgSetWbemObject
    //

    STDMETHOD( SetWbemObject )( IWbemClassObject * pNetworkAdapterIn, bool * pfRetainObjectOut );

    //
    // IClusCfgClusterNetworkInfo
    //

    STDMETHOD( HrIsClusterNetwork )( void );

    STDMETHOD( HrGetNetUID )( BSTR * pbstrUIDOut, const CLSID * pclsidMajorIdIn, LPCWSTR pwszNetworkNameIn );

    STDMETHOD( HrGetPrimaryNetAddress )( IClusCfgIPAddressInfo ** ppIPAddressOut, const CLSID * pclsidMajorIdIn, LPCWSTR pwszNetworkNameIn );

}; //*** Class CClusCfgNetworkInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgnodeinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CClusCfgNodeInfo.h
//
//  Description:
//      This file contains the declaration of the
//      CClusCfgNodeInfo class.
//
//      The class CClusCfgNodeInfo is the representation of a
//      computer that can be a cluster node. It implements the
//      IClusCfgNodeInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgNodeInfo.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 21-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgNodeInfo
//
//  Description:
//      The class CClusCfgNodeInfo is the representation of a
//      computer that can be a cluster node.
//
//  Interfaces:
//      IClusCfgNodeInfo
//      IClusCfgWbemServices
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgNodeInfo
    : public IClusCfgNodeInfo
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
{
private:
    //
    // Private member functions, structs and data
    //

    struct SSCSIInfo
    {
        UINT    uiSCSIBus;
        UINT    uiSCSIPort;
    };

    struct SDriveLetterUsage
    {
        WCHAR               szDrive[ 4 ];
        EDriveLetterUsage   edluUsage;
        UINT                cDisks;
        SSCSIInfo *         psiInfo;
    };

    LONG                m_cRef;
    BSTR                m_bstrFullDnsName;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    DWORD               m_fIsClusterNode;
    IUnknown *          m_punkClusterInfo;
    SYSTEM_INFO         m_si;
    DWORD               m_cMaxNodes;
    SDriveLetterUsage   m_rgdluDrives[ 26 ];

    // Private constructors and destructors
    CClusCfgNodeInfo( void );
    ~CClusCfgNodeInfo( void );

    // Private copy constructor to prevent copying.
    CClusCfgNodeInfo( const CClusCfgNodeInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgNodeInfo & operator = ( const CClusCfgNodeInfo & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrComputeDriveLetterUsage( WCHAR * pszDrivesIn );
    HRESULT HrComputeSystemDriveLetterUsage( void );
    HRESULT HrSetPageFileEnumIndex( void );
    HRESULT HrSetCrashDumpEnumIndex( void );
    HRESULT HrGetVolumeInfo( void );
    DWORD   ScGetDiskExtents( HANDLE hVolumeIn, VOLUME_DISK_EXTENTS ** ppvdeInout, DWORD * pcbvdeInout );
    DWORD   ScGetSCSIAddressInfo( HANDLE hDiskIn, SCSI_ADDRESS * psaAddressOut );
    DWORD   ScGetStorageDeviceNumber( HANDLE hDiskIn, STORAGE_DEVICE_NUMBER * psdnOut );
    HRESULT HrUpdateSystemBusDrives( void );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgNodeInfo Interfaces
    //

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );

    STDMETHOD( IsMemberOfCluster )( void );

    STDMETHOD( GetClusterConfigInfo )( IClusCfgClusterInfo ** ppClusCfgClusterInfoOut );

    STDMETHOD( GetOSVersion )( DWORD * pdwMajorVersionOut, DWORD * pdwMinorVersionOut, WORD * pwSuiteMaskOut, BYTE * pbProductTypeOut, BSTR * pbstrCSDVersionOut );

    STDMETHOD( GetClusterVersion )( DWORD * pdwNodeHighestVersion, DWORD * pdwNodeLowestVersion );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterUsageOut );

    STDMETHOD( GetMaxNodeCount )( DWORD * pcMaxNodesOut );

    STDMETHOD( GetProcessorInfo )( WORD * pwProcessorArchitectureOut, WORD * pwProcessorLevelOut );

}; //*** Class CClusCfgNodeInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgnodeinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CClusCfgNodeInfo.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgNodeInfo
//       class.
//
//      The class CClusCfgNodeInfo is the representation of a
//      computer that can be a cluster node. It implements the
//      IClusCfgNodeInfo interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 21-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include <ClusRTL.h>
#include "CClusCfgNodeInfo.h"
#include "CClusCfgClusterInfo.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgNodeInfo" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgNodeInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusCfgNodeInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CClusCfgNodeInfo *  pccni = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccni = new CClusCfgNodeInfo();
    if ( pccni == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccni->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccni->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgNodeInfo::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccni != NULL )
    {
        pccni->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::CClusCfgNodeInfo
//
//  Description:
//      Constructor of the CClusCfgNodeInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgNodeInfo::CClusCfgNodeInfo( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
    , m_fIsClusterNode( false )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_bstrFullDnsName == NULL );
    Assert( m_picccCallback == NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_punkClusterInfo == NULL );
    Assert( m_cMaxNodes == 0 );
    Assert( m_rgdluDrives[ 0 ].edluUsage == dluUNKNOWN );
    Assert( m_rgdluDrives[ 0 ].psiInfo == NULL );

    TraceFuncExit();

} //*** CClusCfgNodeInfo::CClusCfgNodeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::~CClusCfgNodeInfo
//
//  Description:
//      Desstructor of the CClusCfgNodeInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgNodeInfo::~CClusCfgNodeInfo( void )
{
    TraceFunc( "" );

    int idx;

    TraceSysFreeString( m_bstrFullDnsName );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    if ( m_punkClusterInfo != NULL )
    {
        m_punkClusterInfo->Release();
    } // if:

    for ( idx = 0; idx < 26; idx++ )
    {
        TraceFree( m_rgdluDrives[ idx ].psiInfo );
    } // for:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgNodeInfo::~CClusCfgNodeInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgNodeInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    CRETURN( m_cRef );

} //*** CClusCfgNodeInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgNodeInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CClusCfgNodeInfo::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgNodeInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgNodeInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgNodeInfo, this, 0 );
    } // else if: IClusCfgNodeInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgWbemServices ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
    } // else if: IClusCfgWbemServices
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusCfgNodeInfo::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo -- IClusCfgWbemServices
//  interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Node, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo -- IClusCfgNodeInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetName
//
//  Description:
//      Return the name of this computer.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_NodeInfo_GetName_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrFullDnsName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetName

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::SetName
//
//  Description:
//      Change the name of this computer.
//
//  Arguments:
//      IN  LPCWSTR  pcszNameIn
//          The new name for this computer.
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgNodeInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusCfgNodeInfo::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::IsMemberOfCluster
//
//  Description:
//      Is this computer a member of a cluster?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          This node is a member of a cluster.
//
//      S_FALSE
//          This node is not member of a cluster.
//
//      Other Win32 errors as HRESULT if GetNodeClusterState() fails.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::IsMemberOfCluster( void )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_FALSE;               // default to not a cluster node.

    if ( m_fIsClusterNode )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::IsMemberOfCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetClusterConfigInfo
//
//  Description:
//      Return the configuration information about the cluster that this
//      conputer belongs to.
//
//  Arguments:
//      OUT  IClusCfgClusterInfo ** ppClusCfgClusterInfoOut
//          Catches the CClusterConfigurationInfo object.
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The out param was NULL.
//
//      E_OUTOFMEMORY
//          The CClusCfgNodeInfo object could not be allocated.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetClusterConfigInfo(
    IClusCfgClusterInfo ** ppClusCfgClusterInfoOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT                         hr = S_OK;
    HRESULT                         hrInit = S_OK;
    IClusCfgSetClusterNodeInfo *    pccsgni = NULL;

    if ( ppClusCfgClusterInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetClusterConfigInfo, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_punkClusterInfo != NULL )
    {
        hr = S_OK;
        LogMsg( L"[SRV] CClusCfgNodeInfo::GetClusterConfigInfo() skipped object creation." );
        goto SkipCreate;
    } // if:

    hr = THR( CClusCfgClusterInfo::S_HrCreateInstance( &m_punkClusterInfo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_punkClusterInfo = TraceInterface( L"CClusCfgClusterInfo", IUnknown, m_punkClusterInfo, 1 );

    //
    //  KB: 01-JUN-200  GalenB
    //
    //  This must be done before the CClusCfgClusterInfo class is initialized.
    //

    hr = THR( m_punkClusterInfo->TypeSafeQI( IClusCfgSetClusterNodeInfo, &pccsgni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccsgni->SetClusterNodeInfo( this ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  KB: 01-JUN-200  GalenB
    //
    //  This must be done after SetClusterNodeInfo() is called, but before Initialize.
    //

    hr = THR( HrSetWbemServices( m_punkClusterInfo, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] Could not set the WBEM services on a CClusCfgClusterInfo object. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    //
    //  KB: 01-JUN-200  GalenB
    //
    //  This must be done after SetClusterNodeInfo() and HrSetWbemServices are called.
    //

    hrInit = STHR( HrSetInitialize( m_punkClusterInfo, m_picccCallback, m_lcid ) );
    hr = hrInit;        // need hrInit later...
    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] Could not initialize CClusCfgClusterInfo object. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

SkipCreate:

    if ( SUCCEEDED( hr ) )
    {
        Assert( m_punkClusterInfo != NULL );
        hr = THR( m_punkClusterInfo->TypeSafeQI( IClusCfgClusterInfo, ppClusCfgClusterInfoOut ) );
    } // if:

Cleanup:

    //
    //  If hrInit is not S_OK then it is most likely HR_S_RPC_S_CLUSTER_NODE_DOWN which
    //  needs to get passed up...  Everything else must have succeeded an hr must be
    //  S_OK too.
    //
    if ( ( hr == S_OK ) && ( hrInit != S_OK ) )
    {
        hr = hrInit;
    } // if:

    LOG_STATUS_REPORT_MINOR( TASKID_Minor_Server_GetClusterInfo, L"GetClusterConfigInfo() completed.", hr );

    if ( pccsgni != NULL )
    {
        pccsgni->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetClusterConfigInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetOSVersion
//
//  Description:
//      What is the OS version on this computer?
//
//  Arguments:
//      None.
//
//  Return Value:
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetOSVersion(
    DWORD * pdwMajorVersionOut,
    DWORD * pdwMinorVersionOut,
    WORD *  pwSuiteMaskOut,
    BYTE *  pbProductTypeOut,
    BSTR *  pbstrCSDVersionOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    OSVERSIONINFOEX osv;
    HRESULT         hr = S_OK;

    osv.dwOSVersionInfoSize = sizeof( osv );

    if ( !GetVersionEx( (OSVERSIONINFO *) &osv ) )
    {
        DWORD   sc;

        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: GetVersionEx() failed

    if ( pdwMajorVersionOut != NULL )
    {
        *pdwMajorVersionOut = osv.dwMajorVersion;
    } // if:

    if ( pdwMinorVersionOut != NULL )
    {
        *pdwMinorVersionOut = osv.dwMinorVersion;
    } // if:

    if ( pwSuiteMaskOut != NULL )
    {
        *pwSuiteMaskOut = osv.wSuiteMask;
    } // if:

    if ( pbProductTypeOut != NULL )
    {
        *pbProductTypeOut = osv.wProductType;
    } // if:

    if ( pbstrCSDVersionOut != NULL )
    {
        *pbstrCSDVersionOut = SysAllocString( osv.szCSDVersion );
        if ( *pbstrCSDVersionOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetOSVersion, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
            goto Cleanup;
        } // if:
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetOSVersion


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetClusterVersion
//
//  Description:
//      Return the cluster version information for the cluster this
//      computer belongs to.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetClusterVersion(
    DWORD * pdwNodeHighestVersion,
    DWORD * pdwNodeLowestVersion
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( ( pdwNodeHighestVersion == NULL ) || ( pdwNodeLowestVersion == NULL ) )
    {
        goto BadParams;
    } // if:

    *pdwNodeHighestVersion = CLUSTER_MAKE_VERSION( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION, VER_PRODUCTBUILD );
    *pdwNodeLowestVersion  = CLUSTER_INTERNAL_PREVIOUS_HIGHEST_VERSION;

    goto Cleanup;

BadParams:

    hr = THR( E_POINTER );
    STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetClusterVersion, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetClusterVersion


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterUsageOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   cchDrives = ( 4 * 26 ) + 1;                         // "C:\<null>" times 26 drive letters
    WCHAR * pszDrives = NULL;
    int     idx;

    pszDrives = new WCHAR[ cchDrives ];
    if ( pszDrives == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = GetLogicalDriveStrings( cchDrives, pszDrives );
    if ( sc == 0 )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( sc > cchDrives )
    {
        delete [] pszDrives;
        pszDrives = NULL;

        cchDrives = sc + 1;

        pszDrives = new WCHAR[ cchDrives ];
        if ( pszDrives == NULL )
        {
            goto OutOfMemory;
        } // if:

        sc = GetLogicalDriveStrings( cchDrives, pszDrives );
        if ( sc == 0 )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:
    } // if:

    hr = THR( HrComputeDriveLetterUsage( pszDrives ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrComputeSystemDriveLetterUsage() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetPageFileEnumIndex() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetCrashDumpEnumIndex() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Load the SCSI bus and port information for each disk in each volume.
    //

    hr = THR( HrGetVolumeInfo() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Scan the drives and find those that are "system" and update any other disks on that bus
    //  to be "??? on system bus".
    //

    hr = THR( HrUpdateSystemBusDrives() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Now that we have our array properly filled out then we need to copy that information
    //  back to the caller.
    //

    for ( idx = 0; idx < 26; idx++ )
    {
        pdlmDriveLetterUsageOut->dluDrives[ idx ] = m_rgdluDrives[ idx ].edluUsage;
    } // for:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetDriveLetterMappings_Node, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );

Cleanup:

    delete [] pszDrives;

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetMaxNodeCount
//
//  Description:
//      Returns the maximun number of nodes for this node's product
//      suite type.
//
//  Notes:
//
//  Parameter:
//      pcMaxNodesOut
//          The maximum number of nodes allowed by this node's product
//          suite type.
//
//  Return Value:
//      S_OK
//          Success.
//
//      other HRESULT
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetMaxNodeCount(
    DWORD * pcMaxNodesOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pcMaxNodesOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pcMaxNodesOut = m_cMaxNodes;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetMaxNodeCount


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetProcessorInfo
//
//  Description:
//      Get the processor information for this node.
//
//  Arguments:
//      pwProcessorArchitectureOut
//          The processor architecture.
//
//      pwProcessorLevelOut
//          The processor level.
//
//  Return Value:
//      S_OK
//          Success.
//
//      other HRESULT
//          The call failed.
//
//  Remarks:
//      See SYSTEM_INFO in MSDN and/or the Platform SDK for more
//      information.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetProcessorInfo(
      WORD *    pwProcessorArchitectureOut
    , WORD *    pwProcessorLevelOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( ( pwProcessorArchitectureOut == NULL ) && ( pwProcessorLevelOut == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( pwProcessorArchitectureOut != NULL )
    {
        *pwProcessorArchitectureOut = m_si.wProcessorArchitecture;
    } // if:

    if ( pwProcessorLevelOut != NULL )
    {
        *pwProcessorLevelOut = m_si.wProcessorLevel;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetProcessorInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK    - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;
    DWORD   dwClusterState;
    DWORD   dwSuiteType;

    // IUnknown
    Assert( m_cRef == 1 );

    hr = THR( HrGetComputerName(
                      ComputerNameDnsFullyQualified
                    , &m_bstrFullDnsName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Get the cluster state of the node.
    // Ignore the case where the service does not exist so that
    // EvictCleanup can do its job.
    //

    sc = GetNodeClusterState( NULL, &dwClusterState );
    if ( ( sc != ERROR_SUCCESS ) && ( sc != ERROR_SERVICE_DOES_NOT_EXIST ) )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        goto Cleanup;
    } // if : GetClusterState() failed

    //
    // If the current cluster node state is running or not running then this node is part of a cluster.
    //
    m_fIsClusterNode = ( dwClusterState == ClusterStateNotRunning ) || ( dwClusterState == ClusterStateRunning );

    GetSystemInfo( &m_si );

    dwSuiteType = ClRtlGetSuiteType();
    Assert( dwSuiteType != 0 );             // we should only run on server SKUs!
    if ( dwSuiteType != 0 )
    {
        m_cMaxNodes = ClRtlGetDefaultNodeLimit( dwSuiteType );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::HrComputeDriveLetterUsage
//
//  Description:
//      Fill the array with the enums that represent the drive letter usage
//      and the drive letter string.
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::HrComputeDriveLetterUsage(
    WCHAR * pszDrivesIn
    )
{
    TraceFunc( "" );
    Assert( pszDrivesIn != NULL );

    HRESULT hr = S_OK;
    WCHAR * pszDrive = pszDrivesIn;
    UINT    uiType;
    int     idx;

    while ( *pszDrive != NULL )
    {
        uiType = GetDriveType( pszDrive );

        CharUpper( pszDrive );
        idx = pszDrive[ 0 ] - 'A';

        hr = THR( StringCchCopyW( m_rgdluDrives[ idx ].szDrive, ARRAYSIZE( m_rgdluDrives[ idx ].szDrive ), pszDrive ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        m_rgdluDrives[ idx ].edluUsage = (EDriveLetterUsage) uiType;

        pszDrive += 4;
    } // while:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::HrComputeDriveLetterUsage


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::HrComputeSystemDriveLetterUsage
//
//  Description:
//      Fill the array with the enums that represent the drive letter usage.
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::HrComputeSystemDriveLetterUsage( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrBootLogicalDisk = NULL;
    BSTR    bstrSystemDevice = NULL;
    BSTR    bstrSystemLogicalDisk = NULL;
    int     idx;

//    hr = THR( HrLoadOperatingSystemInfo( m_picccCallback, m_pIWbemServices, &bstrBootDevice, &bstrSystemDevice ) );
//    if ( FAILED( hr ) )
//    {
//        goto Cleanup;
//    } // if:

    hr = THR( HrGetSystemDevice( &bstrSystemDevice ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = HrConvertDeviceVolumeToLogicalDisk( bstrSystemDevice, &bstrSystemLogicalDisk );
    if ( HRESULT_CODE( hr ) == ERROR_INVALID_FUNCTION )
    {
        //
        //  system volume is an EFI volume on IA64 and won't have a logical disk anyway...
        //
        hr = S_OK;
    } // if:
    else if ( hr == S_OK )
    {
        idx = bstrSystemLogicalDisk[ 0 ] - 'A';
        m_rgdluDrives[ idx ].edluUsage = dluSYSTEM;
    } // else if:

    if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    } // if:

    hr = THR( HrGetBootLogicalDisk( &bstrBootLogicalDisk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    idx = bstrBootLogicalDisk[ 0 ] - 'A';
    m_rgdluDrives[ idx ].edluUsage = dluSYSTEM;

Cleanup:

    TraceSysFreeString( bstrBootLogicalDisk );
    TraceSysFreeString( bstrSystemDevice );
    TraceSysFreeString( bstrSystemLogicalDisk );

    HRETURN( hr );

} //*** CClusCfgNodeInfo::HrComputeSystemDriveLetterUsage


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::HrSetPageFileEnumIndex
//
//  Description:
//      Mark the drives that have paging files on them.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::HrSetPageFileEnumIndex( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    WCHAR   szLogicalDisks[ 26 ];
    int     cLogicalDisks = 0;
    int     idx;
    int     idxDrive;

    hr = THR( HrGetPageFileLogicalDisks( m_picccCallback, m_pIWbemServices, szLogicalDisks, &cLogicalDisks ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    for ( idx = 0; idx < cLogicalDisks; idx++ )
    {
        idxDrive = szLogicalDisks[ idx ] - L'A';
        m_rgdluDrives[ idxDrive ].edluUsage = dluSYSTEM;
    } // for:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::HrSetPageFileEnumIndex


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::HrSetCrashDumpEnumIndex
//
//  Description:
//      Mark the drive that has a crash dump file on it.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::HrSetCrashDumpEnumIndex( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrCrashDumpDrive = NULL;
    int     idx;

    hr = THR( HrGetCrashDumpLogicalDisk( &bstrCrashDumpDrive ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    idx = bstrCrashDumpDrive[ 0 ] - L'A';
    m_rgdluDrives[ idx ].edluUsage = dluSYSTEM;

Cleanup:

    TraceSysFreeString( bstrCrashDumpDrive );

    HRETURN( hr );

} //*** CClusCfgNodeInfo::HrSetCrashDumpEnumIndex


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::HrGetVolumeInfo
//
//  Description:
//      Gather the volume info for the drive letters that we have already
//      have loaded.  We need the drive letter info to promote those drives
//      from their basic type to a system type if there are on the same SCSI
//      bus and port as one of the five kinds of system disks.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      If any if the IOCTL wrapper functions fail then that drive letter will
//      simply not be able to be promoted to a system disk.  This is not a big
//      deal and it's okay to skip gathering the data for those disks.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::HrGetVolumeInfo( void )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    int                     idxDriveLetter;
    WCHAR                   szDevice[ 7 ];
    DWORD                   sc;
    HANDLE                  hVolume = INVALID_HANDLE_VALUE;
    VOLUME_DISK_EXTENTS *   pvde = NULL;
    DWORD                   cbvde = 0;
    SCSI_ADDRESS            saAddress;
    SSCSIInfo *             psi = NULL;

    //
    //  Initialize the disk extents buffer.  This will be re-allocated and re-used.
    //

    cbvde = sizeof( VOLUME_DISK_EXTENTS );
    pvde = (PVOLUME_DISK_EXTENTS) TraceAlloc( 0, cbvde );
    if ( pvde == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    //
    //  Loop through each drive letter.
    //

    for ( idxDriveLetter = 0; idxDriveLetter < 26; idxDriveLetter++ )
    {
        //
        //  Cleanup.
        //

        if ( hVolume != INVALID_HANDLE_VALUE )
        {
            CloseHandle( hVolume );
            hVolume = INVALID_HANDLE_VALUE;
        } // if:

        //
        //  Only need to check where we actually have a drive letter that could be on a system bus.
        //

        if ( ( m_rgdluDrives[ idxDriveLetter ].edluUsage == dluUNKNOWN )
          || ( m_rgdluDrives[ idxDriveLetter ].edluUsage == dluNETWORK_DRIVE )
          || ( m_rgdluDrives[ idxDriveLetter ].edluUsage == dluRAM_DISK ) )
        {
            continue;
        } // if:

        hr = THR( StringCchPrintfW( szDevice, ARRAYSIZE( szDevice ), L"\\\\.\\%c:", m_rgdluDrives[ idxDriveLetter ].szDrive[ 0 ] ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        // Get handle to the disk
        //

        hVolume = CreateFileW( szDevice, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if ( hVolume == INVALID_HANDLE_VALUE )
        {
            //
            //  Log the problem and continue.  Make the HRESULT a warning
            //  HRESULT since we don't want an [ERR] showing up in the log
            //  file.
            //

            sc = TW32( GetLastError() );
            hr = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, sc );
            LOG_STATUS_REPORT_STRING( L"Could not create a handle to drive \"%1!ws!\". Ignoring and device will be skipped.", m_rgdluDrives[ idxDriveLetter ].szDrive, hr );
            continue;
        } // if:

        sc = TW32E( ScGetDiskExtents( hVolume, &pvde, &cbvde ), ERROR_INVALID_FUNCTION );
        switch ( sc )
        {
            //
            //  The volume at the drive letter is not a volume and it may simply be a disk.  See if we can get any SCSI address info...
            //

            case ERROR_INVALID_FUNCTION:
            {
                //
                //  If we got the address info then we need to save if off with the drive letter usage struct.
                //

                sc = ScGetSCSIAddressInfo( hVolume, &saAddress );
                if ( sc == ERROR_SUCCESS )
                {
                    psi = (SSCSIInfo *) TraceAlloc( 0, sizeof( SSCSIInfo ) * 1 );
                    if ( psi == NULL )
                    {
                        hr = THR( E_OUTOFMEMORY );
                        goto Cleanup;
                    } // if:

                    psi->uiSCSIPort = saAddress.PortNumber;
                    psi->uiSCSIBus  = saAddress.PathId;

                    m_rgdluDrives[ idxDriveLetter ].cDisks = 1;
                    m_rgdluDrives[ idxDriveLetter ].psiInfo = psi;
                    psi =NULL;
                } // if:
                else
                {
                    //
                    //  Log the problem and continue.  Make the HRESULT a
                    //  warning HRESULT since we don't want an [ERR]
                    //  showing up in the log file.
                    //

                    hr = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, sc );
                    LOG_STATUS_REPORT_STRING( L"Could not get the SCSI address for drive \"%1!ws!\". Ignoring and skipping this device.", m_rgdluDrives[ idxDriveLetter ].szDrive, hr );
                } // else:

                break;
            } // case: ERROR_INVALID_FUNCTION

            //
            //  The volume at the drive letter may be an multi disk volume so we have to process all of the disks...
            //

            case ERROR_SUCCESS:
            {
                DWORD                   idxExtent;
                HANDLE                  hDisk = INVALID_HANDLE_VALUE;
                STORAGE_DEVICE_NUMBER   sdn;
                BOOL                    fOpenNewDevice = TRUE;
                BOOL                    fRetainSCSIInfo = TRUE;
                WCHAR                   sz[ _MAX_PATH ];

                //
                //  Allocate enough structs to hold the scsi address info for this volume.
                //

                psi = (SSCSIInfo *) TraceAlloc( 0, sizeof( SSCSIInfo ) * pvde->NumberOfDiskExtents );
                if ( psi == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                } // if:

                //
                //  Get the device number for the device that we have open.  If it is not the same as the current device from the
                //  drive extents that we are working on then we need to open another device.  When working with a basic disk the
                //  volume that we already have open is the one disk and we can just use it.  If we are using a multi disk volume
                //  then we have to open each disk in turn.
                //

                sc = ScGetStorageDeviceNumber( hVolume, &sdn );
                if ( sc == ERROR_SUCCESS )
                {
                    if ( ( pvde->NumberOfDiskExtents == 1 ) && ( pvde->Extents[ 0 ].DiskNumber == sdn.DeviceNumber ) )
                    {
                        fOpenNewDevice = FALSE;
                    } // if:
                } // if:

                for ( idxExtent = 0; idxExtent < pvde->NumberOfDiskExtents; idxExtent++ )
                {
                    if ( fOpenNewDevice )
                    {
                        hr = THR( StringCchPrintfW( sz, ARRAYSIZE( sz ), g_szPhysicalDriveFormat, pvde->Extents[ idxExtent ].DiskNumber ) );
                        if ( FAILED( hr ) )
                        {
                            goto Cleanup;
                        } // if:

                        hDisk = CreateFileW( sz, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
                        if ( hDisk == INVALID_HANDLE_VALUE )
                        {
                            //
                            //  Log the problem and continue.  Make the HRESULT
                            //  a warning HRESULT since we don't want an [ERR]
                            //  showing up in the log file.
                            //

                            sc = TW32( GetLastError() );
                            hr = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, sc );
                            LOG_STATUS_REPORT_STRING( L"Could not create a handle to drive \"%1!ws!\". Ignoring and skipping device.", sz, hr );
                            continue;
                        } // if:
                    } // if:

                    sc = TW32( ScGetSCSIAddressInfo( fOpenNewDevice ? hDisk : hVolume, &saAddress ) );
                    if ( sc == ERROR_SUCCESS )
                    {
                        psi[ idxExtent ].uiSCSIPort = saAddress.PortNumber;
                        psi[ idxExtent ].uiSCSIBus  = saAddress.PathId;

                        if ( hDisk != INVALID_HANDLE_VALUE )
                        {
                            VERIFY( CloseHandle( hDisk ) );
                            hDisk = INVALID_HANDLE_VALUE;
                        } // if:
                    } // if:
                    else
                    {
                        //
                        //  Having a multi-device volume that doesn't support
                        //  getting SCSI information seems like an unlikely
                        //  situation.
                        //

                        Assert( pvde->NumberOfDiskExtents == 1 );

                        //
                        //  Log the problem and continue.  Make the HRESULT a warning
                        //  HRESULT since we don't want an [ERR] showing up in the log
                        //  file.
                        //
                        //  An example of a volume that might cause this is a
                        //  USB memory stick.
                        //

                        hr = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, sc );
                        LOG_STATUS_REPORT_STRING( L"Could not get the SCSI address for drive \"%1!ws!\". Ignoring and skipping this device.", m_rgdluDrives[ idxDriveLetter ].szDrive, hr );

                        //
                        //  Tell the block of code below to free the already
                        //  allocated SCSI info.  Let's also leave now...
                        //

                        fRetainSCSIInfo = FALSE;
                        break;
                    } // else:
                } // for: each extent

                //
                //  Should we keep the SCSI information from above?
                //

                if ( fRetainSCSIInfo )
                {
                    m_rgdluDrives[ idxDriveLetter ].cDisks = pvde->NumberOfDiskExtents;
                    m_rgdluDrives[ idxDriveLetter ].psiInfo = psi;
                    psi = NULL;
                } // if: save the SCSI info...
                else
                {
                    //
                    //  Zero out this data for safety.  This information is
                    //  processed later and I want to ensure that code does
                    //  not try to process the SCSI info that we could not
                    //  get for this/these extents.
                    //

                    m_rgdluDrives[ idxDriveLetter ].cDisks = 0;
                    m_rgdluDrives[ idxDriveLetter ].psiInfo = NULL;

                    TraceFree( psi );
                    psi = NULL;
                } // else: do not save the SCSI info...

                break;
            } // case: ERROR_SUCCESS

            default:
                //
                //  Log the problem and continue.  Make the HRESULT a warning
                //  HRESULT since we don't want an [ERR] showing up in the log
                //  file.
                //

                hr = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, sc );
                LOG_STATUS_REPORT_STRING( L"Could not get the drive extents of drive \"%1!ws!\". Ignoring and skipping device.", m_rgdluDrives[ idxDriveLetter ].szDrive, hr );
                break;
        } // switch: sc from ScGetDiskExtents()
    } // for: each drive letter

    //
    //  If we didn't go to cleanup then whatever status may be in hr is no longer interesting and we
    //  should return S_OK to the caller.
    //

    hr = S_OK;

Cleanup:

    TraceFree( psi );
    TraceFree( pvde );

    if ( hVolume != INVALID_HANDLE_VALUE )
    {
        VERIFY( CloseHandle( hVolume ) );
    } // if:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::HrGetVolumeInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::ScGetDiskExtents
//
//  Description:
//      Get the volume extents info.
//
//  Arguments:
//      hVolumeIn
//          The volume to get the extents for.
//
//      ppvdeInout
//          Buffer that holds the disk extents.
//
//      pcbvdeInout
//          Size of the buffer that holds the disk extents.
//
//  Return Value:
//      ERROR_SUCCESS
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CClusCfgNodeInfo::ScGetDiskExtents(
      HANDLE                  hVolumeIn
    , VOLUME_DISK_EXTENTS **  ppvdeInout
    , DWORD *                 pcbvdeInout
    )
{
    TraceFunc( "" );
    Assert( hVolumeIn != INVALID_HANDLE_VALUE );
    Assert( ppvdeInout != NULL );
    Assert( pcbvdeInout != NULL );

    DWORD                   sc = ERROR_SUCCESS;
    DWORD                   cbSize;
    int                     cTemp;
    BOOL                    fRet;
    PVOLUME_DISK_EXTENTS    pvdeTemp = NULL;

    //
    //  Since this buffer is re-used it should be cleaned up.
    //

    ZeroMemory( *ppvdeInout, *pcbvdeInout );

    for ( cTemp = 0; cTemp < 2; cTemp++ )
    {
        fRet = DeviceIoControl(
                              hVolumeIn
                            , IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS
                            , NULL
                            , 0
                            , *ppvdeInout
                            , *pcbvdeInout
                            , &cbSize
                            , FALSE
                            );
        if ( fRet == FALSE )
        {
            sc = GetLastError();
            if ( sc == ERROR_MORE_DATA )
            {
                *pcbvdeInout = sizeof( VOLUME_DISK_EXTENTS ) + ( sizeof( DISK_EXTENT ) * (*ppvdeInout)->NumberOfDiskExtents );

                pvdeTemp = (PVOLUME_DISK_EXTENTS) TraceReAlloc( *ppvdeInout, *pcbvdeInout, HEAP_ZERO_MEMORY );
                if ( pvdeTemp == NULL )
                {
                    sc = TW32( ERROR_OUTOFMEMORY );
                    break;
                } // if:

                *ppvdeInout = pvdeTemp;
                continue;
            } // if:
            else
            {
                break;
            } // else:
        } // if:
        else
        {
            sc = ERROR_SUCCESS;
            break;
        } // else:
    } // for:

    //
    //  Shouldn't go through the loop more than twice!
    //

    Assert( cTemp != 2 );

    HRETURN( sc );

} //*** CClusCfgNodeInfo::ScGetDiskExtents


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::ScGetSCSIAddressInfo
//
//  Description:
//      Get the SCSI info for the passed in drive.
//
//  Arguments:
//      hDiskIn
//          The "disk" to send the IOCTL to.
//
//      psaAddressOut
//          The SCSI address info.
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CClusCfgNodeInfo::ScGetSCSIAddressInfo(
      HANDLE            hDiskIn
    , SCSI_ADDRESS *    psaAddressOut
    )
{
    TraceFunc( "" );
    Assert( hDiskIn != INVALID_HANDLE_VALUE );
    Assert( psaAddressOut != NULL );

    DWORD   sc = ERROR_SUCCESS;
    BOOL    fRet;
    DWORD   cb;

    ZeroMemory( psaAddressOut, sizeof( *psaAddressOut ) );

    fRet = DeviceIoControl(
                  hDiskIn
                , IOCTL_SCSI_GET_ADDRESS
                , NULL
                , 0
                , psaAddressOut
                , sizeof( *psaAddressOut )
                , &cb
                , FALSE
                );
    if ( fRet == FALSE )
    {
        //
        //  Not all devices support this IOCTL and they will be skipped by the caller.
        //  There is no need to make this noisy since a failure is expected.
        //

        sc = GetLastError();
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( sc );

} //*** CClusCfgNodeInfo::ScGetSCSIAddressInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::ScGetStorageDeviceNumber
//
//  Description:
//      Get the device number info for the passed in volume.
//
//  Arguments:
//      hDiskIn
//          The "disk" to send the IOCTL to.
//
//      psdnOut
//          The storage device number.
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CClusCfgNodeInfo::ScGetStorageDeviceNumber(
      HANDLE                    hDiskIn
    , STORAGE_DEVICE_NUMBER *   psdnOut
    )
{
    TraceFunc( "" );
    Assert( hDiskIn != INVALID_HANDLE_VALUE );
    Assert( psdnOut != NULL );

    DWORD   sc = ERROR_SUCCESS;
    BOOL    fRet;
    DWORD   cb;

    ZeroMemory( psdnOut, sizeof( *psdnOut ) );

    fRet = DeviceIoControl(
                  hDiskIn
                , IOCTL_STORAGE_GET_DEVICE_NUMBER
                , NULL
                , 0
                , psdnOut
                , sizeof( *psdnOut )
                , &cb
                , FALSE
                );
    if ( fRet == FALSE )
    {
        sc = GetLastError();
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( sc );

} //*** CClusCfgNodeInfo::ScGetStorageDeviceNumber


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::HrUpdateSystemBusDrives
//
//  Description:
//      Find all the "SYSTEM" drives and mark any other disks on those drives
//      as "??? on system bus".
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::HrUpdateSystemBusDrives( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    int     idxOuter;       // the index of the drives in m_rgdluDrives
    int     idxInner;       // the index of the drives that we are scanning
    DWORD   idxOuterExtents;
    DWORD   idxInnerExtents;
    UINT    uiSCSIPort;
    UINT    uiSCSIBus;

    //
    //  Loop through each drive letter looking for those that are "system".
    //

    for ( idxOuter = 0; idxOuter < 26; idxOuter++ )
    {
        //
        //  We only need to worry about system disks.
        //

        if ( m_rgdluDrives[ idxOuter ].edluUsage != dluSYSTEM )
        {
            continue;
        } // if:

        //
        //  Loop through the the "extents" records which contain the bus and port info for each disk in that volume.
        //

        for ( idxOuterExtents = 0; idxOuterExtents < m_rgdluDrives[ idxOuter ].cDisks; idxOuterExtents++ )
        {
            uiSCSIPort = m_rgdluDrives[ idxOuter ].psiInfo[ idxOuterExtents ].uiSCSIPort;
            uiSCSIBus  = m_rgdluDrives[ idxOuter ].psiInfo[ idxOuterExtents ].uiSCSIBus;

            //
            //  Loop through the drives again to find those that are on the same bus and port as the
            //  disk at idxOuter.
            //

            for ( idxInner = 0; idxInner < 26; idxInner++ )
            {
                //
                //  Skip the index that we are checking.  May need to skip any other disks that are
                //  still marked dluSYSTEM?
                //
                //  Skip any indexes that don't have a drive...
                //

                if ( ( idxInner == idxOuter ) || ( m_rgdluDrives[ idxInner ].edluUsage == dluUNKNOWN ) )
                {
                    continue;
                } // if:

                //
                //  Loop through the port and bus info for the drives on the volume at idxInner.
                //

                for ( idxInnerExtents = 0; idxInnerExtents < m_rgdluDrives[ idxInner ].cDisks; idxInnerExtents++ )
                {
                    if ( ( uiSCSIPort == m_rgdluDrives[ idxInner ].psiInfo[ idxInnerExtents ].uiSCSIPort )
                      && ( uiSCSIBus  == m_rgdluDrives[ idxInner ].psiInfo[ idxInnerExtents ].uiSCSIBus ) )
                    {
                        //
                        //  Promote the usage enum to reflect that it is on the system bus.
                        //
                        //  BTW:  += does not work for enums!
                        //

                        m_rgdluDrives[ idxInner ].edluUsage = (EDriveLetterUsage)( m_rgdluDrives[ idxInner ].edluUsage + dluSTART_OF_SYSTEM_BUS );

                        //
                        //  If any drive in the volume is on a system bus and port then we are done.
                        //

                        break;
                    } // if:
                } // for: each inner extent
            } // for: each inner drive letter
        } // for: each outer extent
    } // for: each outer drive letter

    HRETURN( hr );

} //*** CClusCfgNodeInfo::HrUpdateSystemBusDrives
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cclusproplist.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CClusPropList.cpp
//
//  Description:
//      Sucks in the CClusPropList library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-JUN-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"

#include "PropListSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\ccluscfgserver.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgServer.h
//
//  Description:
//      This file contains the declaration of the  CClusCfgServer
//      class.
//
//      The class CClusCfgServer is the implementations of the
//      IClusCfgServer interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgServer.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 03-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <ClusCfgPrivate.h>
#include "..\PostCfg\IPostCfgManager.h"

//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgServer
//
//  Description:
//      The class CClusCfgServer is the server that provides the
//      functionality to form a cluster and join additional nodes to a cluster.
//
//  Interfaces:
//      IClusCfgServer
//      IClusCfgInitialize
//      IClusCfgCapabilities
//      IClusCfgPollingCallbackInfo
//      IClusCfgVerify
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgServer
    : public IClusCfgServer
    , public IClusCfgInitialize
    , public IClusCfgCapabilities
    , public IClusCfgPollingCallbackInfo
    , public IClusCfgVerify
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    IWbemServices *     m_pIWbemServices;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IUnknown *          m_punkNodeInfo;
    IUnknown *          m_punkEnumResources;
    IUnknown *          m_punkNetworksEnum;
    BOOL                m_fCanBeClustered;
    BOOL                m_fUsePolling;
    BSTR                m_bstrNodeName;
    BSTR                m_bstrBindingString;

    // Private constructors and destructors
    CClusCfgServer( void );
    ~CClusCfgServer( void );

    // Private copy constructor to prevent copying.
    CClusCfgServer( const CClusCfgServer & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgServer & operator = ( const CClusCfgServer & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrInitializeForLocalServer( void );
    HRESULT HrSetBlanket( void );
    HRESULT HrFormCluster( IClusCfgClusterInfo * piccciIn, IClusCfgBaseCluster * piccbcaIn );
    HRESULT HrJoinToCluster( IClusCfgClusterInfo * piccciIn, IClusCfgBaseCluster * piccbcaIn );
    HRESULT HrEvictedFromCluster(
        IPostCfgManager *               ppcmIn,
        IEnumClusCfgManagedResources *  peccmrIn,
        IClusCfgClusterInfo *           piccciIn,
        IClusCfgBaseCluster *           piccbcaIn
        );
    HRESULT HrHasNodeBeenEvicted( void );
    HRESULT HrCleanUpNode( void );
    HRESULT HrCreateClusterNodeInfo( void );

public:
    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    //  IClusCfgInitialize
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgServer Interfaces
    //

    // Get information about the computer on which this object is present.
    STDMETHOD( GetClusterNodeInfo )( IClusCfgNodeInfo ** ppClusterNodeInfoOut );

    // Get an enumeration of the devices on this computer that can be managed by the cluster service.
    STDMETHOD( GetManagedResourcesEnum )( IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut );

    // Get an enumeration of all the networks on this computer.
    STDMETHOD( GetNetworksEnum )( IEnumClusCfgNetworks ** ppEnumNetworksOut );

    // Commit the changes to the node
    STDMETHOD( CommitChanges )( void );

    // Binding String
    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );
    STDMETHOD( SetBindingString )( LPCWSTR pcszBindingStringIn );

    //
    //  IClusCfgCapabilities
    //

    STDMETHOD( CanNodeBeClustered )( void );

    //
    //  IClusCfgPollingCallbackInfo
    //

    STDMETHOD( GetCallback )( IClusCfgPollingCallback ** ppiccpcOut );

    STDMETHOD( SetPollingMode )( BOOL fPollingModeIn );

    //
    //  IClusCfgVerify
    //

    STDMETHOD( VerifyCredentials )( LPCWSTR pcszUserIn, LPCWSTR pcszDomainIn, LPCWSTR pcszPasswordIn );

    STDMETHOD( VerifyConnectionToCluster )( LPCWSTR pcszClusterNameIn );

    STDMETHOD( VerifyConnectionToNode )( LPCWSTR pcszNodeNameIn );

}; //*** Class CClusCfgServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cclusterresource.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusterResource.cpp
//
//  Description:
//      This file contains the definition of the CClusterResource
//       class.
//
//      The class CClusterResource represents a cluster manageable
//      device. It implements the IClusCfgManagedResourceInfo interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CClusterResource.h"
#include <PropList.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusterResource" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::S_HrCreateInstance
//
//  Description:
//      Create a CClusterResource instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusterResource instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterResource::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CClusterResource *  pcr = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pcr = new CClusterResource();
    if ( pcr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pcr->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pcr->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusterResource::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pcr != NULL )
    {
        pcr->Release();
    } // if:

    HRETURN( hr );

} //*** CClusterResource::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::CClusterResource
//
//  Description:
//      Constructor of the CClusterResource class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResource::CClusterResource( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_dwFlags == 0 );
    Assert( m_lcid == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_bstrDescription == NULL );
    Assert( m_bstrType == NULL );

    TraceFuncExit();

} //*** CClusterResource::CClusterResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::~CClusterResource
//
//  Description:
//      Desstructor of the CClusterResource class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResource::~CClusterResource( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_bstrDescription );
    TraceSysFreeString( m_bstrType );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusterResource::~CClusterResource


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusterResource::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CClusterResource::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusterResource::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CClusterResource::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgManagedResourceInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
    } // else if: IClusCfgManagedResourceInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgLoadResource ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgLoadResource, this, 0 );
    } // else if: IClusCfgLoadResource
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

     QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusterResource::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource -- IClusCfgLoadResource interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::LoadResource
//
//  Description:
//      Initialize this component from the cluster resource.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::LoadResource(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResourceIn
    )
{
    TraceFunc( "[IClusCfgLoadResource]" );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    CClusPropList           cpl;
    CLUSPROP_BUFFER_HELPER  cpbh;

    sc = TW32( cpl.ScGetResourceProperties( hResourceIn, CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"Description" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    m_bstrDescription = TraceSysAllocString( cpbh.pStringValue->sz );
    if ( m_bstrDescription == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"Name" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    m_bstrName = TraceSysAllocString( cpbh.pStringValue->sz );
    if ( m_bstrName == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"Type" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    m_bstrType = TraceSysAllocString( cpbh.pStringValue->sz );
    if ( m_bstrType == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( HrIsResourceQuorumCapabile( hResourceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
    else if ( hr == S_OK )
    {
        m_dwFlags |= eIsQuorumCapable;
    }

    // Do this only if the above is true i.e. Device quorum capable...
    if( hr == S_OK )
    {
        hr = THR( HrDetermineQuorumJoinable( hResourceIn ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
        else if ( hr == S_OK )
        {
            m_dwFlags |= eIsQuorumJoinable;
        }
    }

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_LoadResource, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::LoadResource


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////

#if 0 // DEAD CODE: GPease  27-JUL-2000 Method Removed
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::TransferInformation
//
//  Description:
//      Transfer node information from another source.
//
//  Arguments:
//      IN IClusCfgManagedResourceInfo * pccmriIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//  Remarks:
//      none
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::TransferInformation(
    IClusCfgManagedResourceInfo * pccmriIn
    )
{
    TraceFunc( "" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //***  CClusterResource::TransferInformation
*/
#endif // End Dead Code


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_ClusterResource_GetUID_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( m_bstrName );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_ClusterResource_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut != NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::SetName( BSTR bstrNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] bstrNameIn = '%ls'", bstrNameIn == NULL ? L"<null>" : bstrNameIn );

    HRESULT hr = S_OK;

    if ( bstrNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrName );
    m_bstrName = NULL;

    m_bstrName = TraceSysAllocString( bstrNameIn );
    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetName_Cluster_Resource, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::IsManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( S_OK );

} //*** CClusterResource::IsManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::SetManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::SetManaged( BOOL fIsManagedIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusterResource::SetManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::IsQuorumDevice
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is the quorum device.
//
//      S_FALSE
//          The device is not the quorum device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::IsQuorumDevice( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_dwFlags & eIsQuorumDevice )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusterResource::IsQuorumDevice


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::SetQuorumedDevice
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::SetQuorumedDevice( BOOL fIsQuorumDeviceIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusterResource::SetQuorumedDevice


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::IsDeviceJoinable
//
//  Description:
//      Does the Quorumable device allow other nodes to join.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is joinable.
//
//      S_FALSE
//          The device is not joinable.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::IsDeviceJoinable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_dwFlags & eIsQuorumJoinable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusterResource::IsDeviceJoijnable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::SetDeviceJoinable
//
//  Description:
//      Set the joinable flag.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is joinable.
//
//      S_FALSE
//          The device is not joinable.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This method should never be called.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::SetDeviceJoinable( BOOL fIsJoinableIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CClusterResource::SetDeviceJoijnable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::IsQuorumCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is a quorum capable device.
//
//      S_FALSE
//          The device is not a quorum capable device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_dwFlags & eIsQuorumCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusterResource::IsQuorumCapable

//////////////////////////////////////////////////////////////////////////
//
//  CClusterResource::SetQuorumCapable
//
//  Description:
//      Call this to set whether the resource is capable to be the quorum
//      resource or not.
//
//  Parameter:
//      fIsQuorumCapableIn - If TRUE, the resource will be marked as quorum capable.
//
//  Return Values:
//      S_OK
//          Call succeeded.
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::SetQuorumCapable( 
    BOOL fIsQuorumCapableIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusterResource::SetQuorumCapable

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusterResource::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusterResource::SetDriveLetterMappings


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterResource::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CClusterResource::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::HrIsResourceQuorumCapabile
//
//  Description:
//      Is this resource quorum capable?
//
//  Arguments:
//      None.
//
//  Return Value:
//
//      S_OK
//          The resource is quorum capable.
//
//      S_FALSE
//          The resource is not quorum capable.
//
//      Other Win32 error as HRESULT.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterResource::HrIsResourceQuorumCapabile( HRESOURCE hResourceIn )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwFlags;
    DWORD   cbReturned;

    sc = TW32( ClusterResourceControl(
                        hResourceIn,
                        NULL,
                        CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                        &dwFlags,
                        sizeof( dwFlags ),
                        NULL,
                        NULL,
                        &cbReturned
                        ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( dwFlags & ( CLUS_CHAR_QUORUM | CLUS_CHAR_LOCAL_QUORUM | CLUS_CHAR_LOCAL_QUORUM_DEBUG ) )
    {
        hr = S_OK;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::HrIsResourceQuorumCapabile

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::HrDetermineQuorumJoinable
//
//  Description:
//      Is this quorumable resource joinable?
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterResource::HrDetermineQuorumJoinable( HRESOURCE hResourceIn )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwFlags;
    DWORD   cbReturned;

    sc = TW32( ClusterResourceControl(
                        hResourceIn,
                        NULL,
                        CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                        &dwFlags,
                        sizeof( dwFlags ),
                        NULL,
                        NULL,
                        &cbReturned
                        ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( dwFlags & (CLUS_CHAR_QUORUM|CLUS_CHAR_LOCAL_QUORUM_DEBUG))
    {
        hr = S_OK;
    } // if:

Cleanup:

    HRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cclusterresource.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusterResource.h
//
//  Description:
//      This file contains the declaration of the CClusterResource
//      class.
//
//      The class CClusterResource represents a cluster resource.
//      It implements the IClusCfgManagaedResourceInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusterResource.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterResource
//
//  Description:
//      The class CClusterResource represents a cluster storage
//      device.
//
//  Interfaces:
//      IClusCfgManagedResourceInfo
//      IClusCfgInitialize
//      IClusCfgLoadResource
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterResource
    : public IClusCfgManagedResourceInfo
    , public IClusCfgInitialize
    , public IClusCfgLoadResource
{
private:

    enum EStates
    {
        eIsQuorumDevice     = 1,
        eIsQuorumCapable    = 2,
        eIsQuorumJoinable   = 4
    };

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    DWORD               m_dwFlags;
    BSTR                m_bstrName;
    BSTR                m_bstrDescription;
    BSTR                m_bstrType;

    // Private constructors and destructors
    CClusterResource( void );
    ~CClusterResource( void );

    // Private copy constructor to prevent copying.
    CClusterResource( const CClusterResource & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusterResource & operator = ( const CClusterResource & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrIsResourceQuorumCapabile( HRESOURCE hResourceIn );
    HRESULT HrDetermineQuorumJoinable( HRESOURCE hResourceIn );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgLoadResoruce Interfaces
    //

    STDMETHOD( LoadResource )( HCLUSTER hClusterIn, HRESOURCE hResourceIn );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( BSTR bstrNameIn );

    STDMETHOD( IsManaged )( void );

    STDMETHOD( SetManaged )( BOOL fIsManagedIn );

    STDMETHOD( IsQuorumDevice )( void );

    STDMETHOD( SetQuorumedDevice )( BOOL fIsQuorumDeviceIn );

    STDMETHOD( IsQuorumCapable )( void );

    STDMETHOD( SetQuorumCapable )( BOOL fIsQuorumCapableIn );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappings );

    STDMETHOD( IsDeviceJoinable )( void );

    STDMETHOD( SetDeviceJoinable )( BOOL fIsJoinableIn );

}; //*** Class CClusterResource
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cclusterutils.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusterUtils.h
//
//  Description:
//      This file contains the declaration of the CClusterUtils class.
//
//  Documentation:
//
//  Implementation Files:
//      CClusterUtils.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 14-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterUtils
//
//  Description:
//      The class CClusterUtils are cluster utilities.
//
//  Interfaces:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterUtils
{
private:

    //
    // Private member functions and data
    //

    // Private copy constructor to prevent copying.
    CClusterUtils( const CClusterUtils & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusterUtils & operator = ( const CClusterUtils & nodeSrc );

protected:

    // constructors and destructors
    CClusterUtils( void );
    ~CClusterUtils( void );

public:

    HRESULT HrIsGroupOwnedByThisNode( HGROUP hGroupIn, BSTR bstrNodeNameIn );
    HRESULT HrIsNodeClustered( void );
    HRESULT HrEnumNodeResources( BSTR bstrNodeNameIn );
    HRESULT HrLoadGroupResources( HCLUSTER hClusterIn, HGROUP hGroupIn );
    HRESULT HrGetQuorumResourceName( BSTR * pbstrQuorumResourceNameOut );

    virtual HRESULT HrNodeResourceCallback( HCLUSTER hClusterIn, HRESOURCE hResourceIn ) = 0;

}; //*** Class CClusterUtils
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cclusterutils.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusterUtils.cpp
//
//  Description:
//      This file contains the definition of the CClusterUtils
//       class.
//
//  Documentation:
//
//  Header File:
//      CClusterUtils.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 14-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusterUtils" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterUtils class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils::CClusterUtils
//
//  Description:
//      Constructor of the CClusterUtils class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterUtils::CClusterUtils( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CClusterUtils::CClusterUtils


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils::~CClusterUtils
//
//  Description:
//      Desstructor of the CClusterUtils class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterUtils::~CClusterUtils( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CClusterUtils::~CClusterUtils


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils::HrIsGroupOwnedByThisNode
//
//  Description:
//      Is the passed in group owned by the passes in node name?
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The group is owned by the node.
//
//      S_FALSE
//          The group is not owned by the node.
//
//      Win32 Error
//          An error occurred.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterUtils::HrIsGroupOwnedByThisNode(
    HGROUP  hGroupIn,
    BSTR    bstrNodeNameIn
    )
{
    TraceFunc1( "bstrNodeNameIn = '%ls'", bstrNodeNameIn == NULL ? L"<null>" : bstrNodeNameIn );
    Assert( bstrNodeNameIn != NULL );

    HRESULT             hr;
    DWORD               sc;
    WCHAR *             pszNodeName = NULL;
    DWORD               cchNodeName = 33;
    CLUSTER_GROUP_STATE cgs;
    int                 idx;

    pszNodeName = new WCHAR[ cchNodeName ];
    if ( pszNodeName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; idx++ )
    {
        Assert( idx < 2 );

        cgs = GetClusterGroupState( hGroupIn, pszNodeName, &cchNodeName );
        sc = GetLastError();
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszNodeName;
            pszNodeName = NULL;
            cchNodeName++;

            pszNodeName = new WCHAR[ cchNodeName ];
            if ( pszNodeName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            continue;
        } // if:

        if ( cgs == ClusterGroupStateUnknown )
        {
            TW32( sc );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:

        if ( ClRtlStrICmp( bstrNodeNameIn, pszNodeName ) == 0 )
        {
            hr = S_OK;
        } // if:
        else
        {
            hr = S_FALSE;
        } // else:

        break;
    } // for:

Cleanup:

    delete [] pszNodeName;

    HRETURN( hr );

} //*** CClusterUtils::HrIsGroupOwnedByThisNode

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils:HrIsNodeClustered
//
//  Description:
//      Is this node a member of a cluster?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK        - The node is clustered.
//      S_FALSE     - The node is NOT clustered.
//      HRESULT     - Something failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterUtils::HrIsNodeClustered( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwClusterState;

    //
    // Get the cluster state of the node.
    // Ignore the case where the service does not exist so that
    // EvictCleanup can do its job.
    //

    sc = GetNodeClusterState( NULL, &dwClusterState );
    if ( ( sc != ERROR_SUCCESS ) && ( sc != ERROR_SERVICE_DOES_NOT_EXIST ) )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        goto Cleanup;
    } // if : GetClusterState failed

    if ( ( dwClusterState == ClusterStateRunning ) || ( dwClusterState == ClusterStateNotRunning ) )
    {
        hr = S_OK;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusterUtils::HrIsNodeClustered


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils:HrEnumNodeResources
//
//  Description:
//      Enumerate the resources owned by this node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterUtils::HrEnumNodeResources( BSTR bstrNodeNameIn )
{
    TraceFunc1( "bstrNodeNameIn = '%ls'", bstrNodeNameIn == NULL ? L"<null>" : bstrNodeNameIn );

    HRESULT     hr = S_FALSE;
    DWORD       sc;
    DWORD       idx;
    HCLUSTER    hCluster = NULL;
    HCLUSENUM   hEnum = NULL;
    DWORD       dwType;
    WCHAR *     pszGroupName = NULL;
    DWORD       cchGroupName = 33;
    HGROUP      hGroup = NULL;

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_GROUP );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    pszGroupName = new WCHAR[ cchGroupName ];
    if ( pszGroupName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; )
    {
        sc = ClusterEnum( hEnum, idx, &dwType, pszGroupName, &cchGroupName );
        if ( sc == ERROR_SUCCESS )
        {
            hGroup = OpenClusterGroup( hCluster, pszGroupName );
            if ( hGroup == NULL )
            {
                sc = TW32( GetLastError() );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            } // if:

            hr = STHR( HrIsGroupOwnedByThisNode( hGroup, bstrNodeNameIn ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                hr = THR( HrLoadGroupResources( hCluster, hGroup ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:
            } // if:

            CloseClusterGroup( hGroup );
            hGroup = NULL;

            idx++;
            continue;
        } // if:

        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszGroupName;
            pszGroupName = NULL;
            cchGroupName++;

            pszGroupName = new WCHAR[ cchGroupName ];
            if ( pszGroupName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            hr = S_OK;
            break;
        } // if:

        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        break;
    } // for:

Cleanup:

    if ( hGroup != NULL )
    {
        CloseClusterGroup( hGroup );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterCloseEnum( hEnum );
    } // if:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    delete [] pszGroupName;

    HRETURN( hr );

} //*** CClusterUtils::HrEnumNodeResources


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils::HrLoadGroupResources
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterUtils::HrLoadGroupResources(
    HCLUSTER    hClusterIn,
    HGROUP      hGroupIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    DWORD       sc;
    HGROUPENUM  hEnum = NULL;
    WCHAR *     pszResourceName = NULL;
    DWORD       cchResourceName = 33;
    DWORD       dwType;
    DWORD       idx;
    HRESOURCE   hResource = NULL;

    hEnum = ClusterGroupOpenEnum( hGroupIn, CLUSTER_GROUP_ENUM_CONTAINS );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    pszResourceName = new WCHAR[ cchResourceName ];
    if ( pszResourceName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; )
    {
        sc = ClusterGroupEnum( hEnum, idx, &dwType, pszResourceName, &cchResourceName );
        if ( sc == ERROR_SUCCESS )
        {
            hResource = OpenClusterResource( hClusterIn, pszResourceName );
            if ( hResource == NULL )
            {
                sc = TW32( GetLastError() );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            } // if:

            hr = STHR( HrNodeResourceCallback( hClusterIn, hResource ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            CloseClusterResource( hResource );
            hResource = NULL;

            idx++;
            continue;
        } // if:

        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszResourceName;
            pszResourceName = NULL;
            cchResourceName++;

            pszResourceName = new WCHAR[ cchResourceName ];
            if ( pszResourceName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            hr = S_OK;
            break;
        } // if:

        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        break;
    } // for:

Cleanup:

    if ( hResource != NULL )
    {
        CloseClusterResource( hResource );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterGroupCloseEnum( hEnum );
    } // if:

    delete [] pszResourceName;

    HRETURN( hr );

} //*** CClusterUtils::HrLoadGroupResources


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils:HrGetQuorumResourceName
//
//  Description:
//
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterUtils::HrGetQuorumResourceName(
    BSTR * pbstrQuorumResourceNameOut
    )
{
    TraceFunc( "" );
    Assert( pbstrQuorumResourceNameOut != NULL );

    HRESULT     hr = S_OK;
    HCLUSTER    hCluster = NULL;
    DWORD       sc;
    WCHAR *     pszResourceName = NULL;
    DWORD       cchResourceName = 33;
    WCHAR *     pszDeviceName = NULL;
    DWORD       cchDeviceName = 33;
    DWORD       cbQuorumLog;
    int         idx;

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    pszResourceName = new WCHAR[ cchResourceName ];
    if ( pszResourceName == NULL )
    {
        goto OutOfMemory;
    } // if:

    pszDeviceName = new WCHAR[ cchDeviceName ];
    if ( pszDeviceName == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; idx++ )
    {
        Assert( idx < 2 );

        sc = GetClusterQuorumResource( hCluster, pszResourceName, &cchResourceName, pszDeviceName, &cchDeviceName, &cbQuorumLog );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszResourceName;
            pszResourceName = NULL;
            cchResourceName++;

            delete [] pszDeviceName;
            pszDeviceName = NULL;
            cchDeviceName++;

            pszResourceName = new WCHAR[ cchResourceName ];
            if ( pszResourceName == NULL )
            {
                goto OutOfMemory;
            } // if:

            pszDeviceName = new WCHAR[ cchDeviceName ];
            if ( pszDeviceName == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            *pbstrQuorumResourceNameOut = TraceSysAllocString( pszResourceName );
            if ( *pbstrQuorumResourceNameOut == NULL )
            {
                goto OutOfMemory;
            } // if:

            break;
        } // if:

        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // for:

    hr = S_OK;
    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    delete [] pszResourceName;
    delete [] pszDeviceName;

    HRETURN( hr );

} //*** CClusterUtils::HrGetQuorumResourceName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgipaddresses.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgIPAddresses.h
//
//  Description:
//      This file contains the declaration of the CEnumClusCfgIPAddresses
//      class.
//
//      The class CEnumClusCfgIPAddresses is the enumeration of IP
//      addresses. It implements the CEnumClusCfgIPAddresses
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumClusCfgIPAddresses.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumClusCfgIPAddresses
//
//  Description:
//      The class CEnumClusCfgIPAddresses is the enumeration of
//      IP addresses.
//
//  Interfaces:
//      CEnumClusCfgIPAddresses
//      IClusCfgWbemServices
//      IClusCfgInitialize
//      IClusCfgNetworkAdapterInfo
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumClusCfgIPAddresses
    : public IEnumClusCfgIPAddresses
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
    , public IClusCfgSetWbemObject
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    ULONG               m_idxEnumNext;
    IUnknown *          ((*m_prgAddresses)[]);
    ULONG               m_idxNext;
    DWORD               m_cAddresses;

    // Private constructors and destructors
    CEnumClusCfgIPAddresses( void );
    ~CEnumClusCfgIPAddresses( void );

    // Private copy constructor to prevent copying.
    CEnumClusCfgIPAddresses( const CEnumClusCfgIPAddresses & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumClusCfgIPAddresses & operator = ( const CEnumClusCfgIPAddresses & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrInit( ULONG ulIPAddressIn, ULONG IPSubnetIn );
    HRESULT HrGetAdapterConfiguration(  IWbemClassObject * pNetworkAdapterIn );
    HRESULT HrSaveIPAddresses( BSTR bstrAdapterNameIn, IWbemClassObject * pConfigurationIn );
    HRESULT HrAddIPAddressToArray( IUnknown * punkIn );
    HRESULT HrCreateIPAddress( IUnknown ** ppunkOut );
    HRESULT HrCreateIPAddress( ULONG ulIPAddressIn, ULONG ulIPSubnetIn, IUnknown ** ppunkOut );
    HRESULT HrMakeDottedQuad( BSTR bstrDottedQuadIn, ULONG * pulDottedQuadOut );
    HRESULT HrSaveAddressInfo( BSTR bstrAdapterNameIn, SAFEARRAY * pIPAddresses, SAFEARRAY * pIPSubnets );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrCreateInstance(
                ULONG           ulIPAddressIn
              , ULONG           IPSubnetIn
              , IUnknown *      punkCallbackIn
              , LCID            lcidIn
              , IWbemServices * pIWbemServicesIn
              , IUnknown **     ppunkOut
              );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgIPAddresses Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgIPAddressInfo ** rgpIPAddressInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

    //
    // IClusCfgSetWbemObject Interfaces
    //

    STDMETHOD( SetWbemObject )( IWbemClassObject * pNetworkAdapterIn, bool * pfRetainObjectOut );

}; //*** Class CEnumClusCfgIPAddresses
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgipaddresses.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgIPAddresses.cpp
//
//  Description:
//      This file contains the definition of the CEnumClusCfgIPAddresses
//      class.
//
//      The class CEnumClusCfgIPAddresses is the enumeration of IP addresses.
//      It implements the IEnumClusCfgIPAddresses interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CEnumClusCfgIPAddresses.h"
#include "CClusCfgIPAddressInfo.h"
#include <ClusRtl.h>
#include <commctrl.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumClusCfgIPAddresses" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::S_HrCreateInstance
//
//  Description:
//      Create a CEnumClusCfgIPAddresses instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CEnumClusCfgIPAddresses instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    CEnumClusCfgIPAddresses *   peccipa = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    peccipa = new CEnumClusCfgIPAddresses();
    if ( peccipa == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( peccipa->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( peccipa->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumClusCfgIPAddresses::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( peccipa != NULL )
    {
        peccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::S_HrCreateInstance
//
//  Description:
//      Create a CEnumClusCfgIPAddresses instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CEnumClusCfgIPAddresses instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::S_HrCreateInstance(
      ULONG             ulIPAddressIn
    , ULONG             ulIPSubnetIn
    , IUnknown *        punkCallbackIn
    , LCID              lcidIn
    , IWbemServices *   pIWbemServicesIn
    , IUnknown **       ppunkOut
    )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );
    Assert( ulIPAddressIn != 0 );
    Assert( ulIPSubnetIn != 0 );

    HRESULT                     hr = S_OK;
    CEnumClusCfgIPAddresses *   peccipa = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    peccipa = new CEnumClusCfgIPAddresses();
    if ( peccipa == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( peccipa->Initialize( punkCallbackIn, lcidIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( peccipa->SetWbemServices( pIWbemServicesIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( peccipa->HrInit( ulIPAddressIn, ulIPSubnetIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( peccipa->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumClusCfgIPAddresses::S_HrCreateInstance( ULONG, ULONG ) failed. (hr = %#08x)", hr );
    } // if:

    if ( peccipa != NULL )
    {
        peccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::CEnumClusCfgIPAddresses
//
//  Description:
//      Constructor of the CEnumClusCfgIPAddresses class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgIPAddresses::CEnumClusCfgIPAddresses( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_prgAddresses == NULL );
    Assert( m_cAddresses == 0 );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusCfgIPAddresses::CEnumClusCfgIPAddresses


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::~CEnumClusCfgIPAddresses
//
//  Description:
//      Desstructor of the CEnumClusCfgIPAddresses class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgIPAddresses::~CEnumClusCfgIPAddresses( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        ((*m_prgAddresses)[ idx ])->Release();
    } // for:

    TraceFree( m_prgAddresses );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusCfgIPAddresses::~CEnumClusCfgIPAddresses


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgIPAddresses::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumClusCfgIPAddresses::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgIPAddresses::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CEnumClusCfgIPAddresses::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IEnumClusCfgIPAddresses * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgIPAddresses ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgIPAddresses, this, 0 );
    } // else if: IEnumClusCfgIPAddresses
    else if ( IsEqualIID( riidIn, IID_IClusCfgWbemServices ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
    } // else if: IClusCfgWbemServices
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgSetWbemObject ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgSetWbemObject, this, 0 );
    } // else if: IClusCfgSetWbemObject
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

     QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumClusCfgIPAddresses::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Enum_IPAddresses, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses -- IEnumClusCfgIPAddresses interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Next(
    ULONG                       cNumberRequestedIn,
    IClusCfgIPAddressInfo **    rgpIPAddressInfoOut,
    ULONG *                     pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT                 hr = S_FALSE;
    ULONG                   cFetched = 0;
    ULONG                   idx;
    IClusCfgIPAddressInfo * pccipai;

    if ( rgpIPAddressInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_IPAddresses, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    cFetched = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( idx = 0; idx < cFetched; idx++, m_idxEnumNext++ )
    {
        hr = THR( ((*m_prgAddresses)[ m_idxEnumNext ])->TypeSafeQI( IClusCfgIPAddressInfo, &pccipai ) );
        if ( FAILED( hr ) )
        {
            break;
        } // if:

        rgpIPAddressInfoOut[ idx ] = pccipai;
    } // for:

    if ( FAILED( hr ) )
    {
        ULONG   idxStop = idx;

        m_idxEnumNext -= idx;

        for ( idx = 0; idx < idxStop; idx++ )
        {
            (rgpIPAddressInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;
        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Reset( void )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr S_OK;

    m_idxEnumNext = 0;

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Clone(
    IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgIPAddressesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_IPAddresses, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pnCountOut = m_cAddresses;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddress::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses class -- IClusCfgNetworkAdapterInfo Interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::SetWbemObject
//
//  Description:
//      Get the configuration from the passed in adapter and load this
//      enumerator.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::SetWbemObject(
      IWbemClassObject *    pNetworkAdapterIn
    , bool *                pfRetainObjectOut
    )
{
    TraceFunc( "[IClusCfgNetworkAdapterInfo]" );
    Assert( pfRetainObjectOut != NULL );

    HRESULT hr = E_INVALIDARG;

    if ( pNetworkAdapterIn != NULL )
    {
        hr = STHR( HrGetAdapterConfiguration( pNetworkAdapterIn ) );
        *pfRetainObjectOut = true;
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::SetWbemObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      ulIPAddressIn
//      ulIPSubnetIn
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrInit( ULONG ulIPAddressIn, ULONG ulIPSubnetIn )
{
    TraceFunc( "" );

    HRESULT     hr;
    IUnknown *  punk = NULL;

    // IUnknown
    Assert( m_cRef == 1 );

    hr = THR( HrCreateIPAddress( ulIPAddressIn, ulIPSubnetIn, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddIPAddressToArray( punk ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrInit( ulIPAddressIn, ulIPSubnetIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::HrGetAdapterConfiguration
//
//  Description:
//      Get the configuration of the passed in adapter.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrGetAdapterConfiguration(
    IWbemClassObject * pNetworkAdapterIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrWQL = NULL;
    VARIANT                 var;
    WCHAR                   sz[ 256 ];
    IEnumWbemClassObject *  pConfigurations = NULL;
    ULONG                   ulReturned;
    IWbemClassObject *      pConfiguration = NULL;
    int                     cFound = 0;
    BSTR                    bstrAdapterName = NULL;
    int                     idx;
    HRESULT                 hrTemp;
    CLSID                   clsidMinorId;

    VariantInit( &var );

    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( StringCchPrintfW(
                      sz, ARRAYSIZE( sz )
                    , L"Associators of {Win32_NetworkAdapter.DeviceID='%ws'} where AssocClass=Win32_NetworkAdapterSetting"
                    , var.bstrVal
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    bstrQuery = TraceSysAllocString( sz );
    if ( bstrQuery == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"NetConnectionID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    bstrAdapterName = TraceSysAllocString( var.bstrVal );
    if ( bstrAdapterName == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pConfigurations ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_STRING_REF(
                TASKID_Major_Find_Devices,
                TASKID_Minor_WMI_NetworkAdapterSetting_Qry_Failed,
                IDS_ERROR_WMI_NETWORKADAPTERSETTINGS_QRY_FAILED,
                bstrAdapterName,
                IDS_ERROR_WMI_NETWORKADAPTERSETTINGS_QRY_FAILED_REF,
                hr
                );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; idx++ )
    {
        hr = pConfigurations->Next( WBEM_INFINITE, 1, &pConfiguration, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            //
            //  KB: 25-AUG-2000 GalenB
            //
            //  WMI only supports one configuration per adapter!
            //
            Assert( idx < 1 );

            VariantClear( &var );

            hr = THR( HrGetWMIProperty( pConfiguration, L"IPEnabled", VT_BOOL, &var ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  If this configuration is not for TCP/IP then skip it.
            //
            if ( ( var.vt != VT_BOOL ) || ( var.boolVal != VARIANT_TRUE ) )
            {
                hr = S_OK;      // don't want a yellow bang in the UI

                STATUS_REPORT_REF(
                          TASKID_Major_Find_Devices
                        , TASKID_Minor_Not_Managed_Networks
                        , IDS_INFO_NOT_MANAGED_NETWORKS
                        , IDS_INFO_NOT_MANAGED_NETWORKS_REF
                        , hr
                        );

                hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
                if ( FAILED( hrTemp ) )
                {
                    LogMsg( L"[SRV] Could not create a guid for a network adapter that has a non TCP configuration minor task ID" );
                    clsidMinorId = IID_NULL;
                } // if:

                STATUS_REPORT_STRING_REF(
                          TASKID_Minor_Not_Managed_Networks
                        , clsidMinorId
                        , IDS_WARN_NOT_IP_ENABLED
                        , bstrAdapterName
                        , IDS_WARN_NOT_IP_ENABLED_REF
                        , hr
                        );
                continue;
            } // if:

            hr = STHR( HrSaveIPAddresses( bstrAdapterName, pConfiguration ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  KB: 24-AUG-2000 GalenB
            //
            //  If any configuration returns S_FALSE then we skip.
            //
            if ( hr == S_FALSE )
            {
                pConfiguration->Release();
                pConfiguration = NULL;
                continue;
            } // if:

            cFound++;
            pConfiguration->Release();
            pConfiguration = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING_REF(
                      TASKID_Major_Find_Devices
                    , TASKID_Minor_WQL_Qry_Next_Failed
                    , IDS_ERROR_WQL_QRY_NEXT_FAILED
                    , bstrQuery
                    , IDS_ERROR_WQL_QRY_NEXT_FAILED_REF
                    , hr
                    );
            goto Cleanup;
        } // else:
    } // for:

    //
    //  If we didn't find any valid configurations then we should return S_FALSE
    //  to tell the caller to ingore that adpater.
    //
    if ( cFound == 0 )
    {
        hr = S_OK;      // don't want a yellow bang in the UI

        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Not_Managed_Networks
                , IDS_INFO_NOT_MANAGED_NETWORKS
                , IDS_INFO_NOT_MANAGED_NETWORKS_REF
                , hr
                );

        hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
        if ( FAILED( hrTemp ) )
        {
            LogMsg( L"[SRV] Could not create a guid for a network adapter that doesn't have a valid TCP configuration minor task ID" );
            clsidMinorId = IID_NULL;
        } // if:

        STATUS_REPORT_STRING_REF(
                  TASKID_Minor_Not_Managed_Networks
                , clsidMinorId
                , IDS_WARN_NO_VALID_TCP_CONFIGS
                , bstrAdapterName
                , IDS_WARN_NO_VALID_TCP_CONFIGS_REF
                , hr
                );
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrGetAdapterConfiguration, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrQuery );
    TraceSysFreeString( bstrWQL );
    TraceSysFreeString( bstrAdapterName );

    if ( pConfiguration != NULL )
    {
        pConfiguration->Release();
    } // if:

    if ( pConfigurations != NULL )
    {
        pConfigurations->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrGetAdapterConfiguration


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses:HrAddIPAddressToArray
//
//  Description:
//      Add the passed in address to the array of address.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrAddIPAddressToArray( IUnknown * punkIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgAddresses, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrAddIPAddressToArray, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    m_prgAddresses = prgpunks;

    (*m_prgAddresses)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cAddresses += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrAddIPAddressToArray

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::HrMakeDottedQuad
//
//  Description:
//      Take the passed in IP address and convert it into a dotted quad.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      Internet Addresses
//      Values specified using the ".'' notation take one of the following forms:
//
//          a.b.c.d a.b.c a.b a
//
//      When four parts are specified, each is interpreted as a byte of data and
//      assigned, from left to right, to the 4 bytes of an Internet address. When
//      an Internet address is viewed as a 32-bit integer quantity on the
//      Intel architecture, the bytes referred to above appear as "d.c.b.a''.
//      That is, the bytes on an Intel processor are ordered from right to left.
//
//      The parts that make up an address in "." notation can be decimal, octal
//      or hexadecimal as specified in the C language. Numbers that start
//      with "0x" or "0X" imply hexadecimal. Numbers that start with "0" imply
//      octal. All other numbers are interpreted as decimal.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrMakeDottedQuad(
    BSTR    bstrDottedQuadIn,
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrMakeDottedQuad, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( bstrDottedQuadIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        LOG_STATUS_REPORT( L"CEnumClusCfgIPAddresses::HrMakeDottedQuad() was given an invalid argument.", hr );
        goto Cleanup;
    } // if:

    sc = TW32( ClRtlTcpipStringToAddress( bstrDottedQuadIn, pulDottedQuadOut ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        STATUS_REPORT_STRING_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Dotted_Quad_Failed
                , IDS_ERROR_CONVERT_TO_DOTTED_QUAD_FAILED
                , bstrDottedQuadIn
                , IDS_ERROR_CONVERT_TO_DOTTED_QUAD_FAILED_REF
                , hr
                );
        goto Cleanup;
    } // if:

Cleanup:

    RETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrMakeDottedQuad


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::HrSaveIPAddresses
//
//  Description:
//      Add the IP addresses to the array.
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrSaveIPAddresses(
    BSTR                bstrAdapterNameIn,
    IWbemClassObject *  pConfigurationIn
    )
{
    TraceFunc( "" );
    Assert( bstrAdapterNameIn != NULL );
    Assert( pConfigurationIn != NULL );

    HRESULT                 hr;
    VARIANT                 varIPAddress;
    VARIANT                 varIPSubnet;
    long                    lIPAddressesUpperBound;
    long                    lIPAddressesLowerBound;
    long                    lIPSubnetsUpperBound;
    long                    lIPSubnetsLowerBound;
    long                    idx;
    ULONG                   ulIPAddress;
    ULONG                   ulIPSubnet;
    BSTR                    bstrIPAddress = NULL;
    BSTR                    bstrIPSubnet = NULL;
    IUnknown *              punk = NULL;
    IClusCfgIPAddressInfo * piccipai = NULL;

    VariantInit( &varIPAddress );
    VariantInit( &varIPSubnet );

    hr = THR( HrGetWMIProperty( pConfigurationIn, L"IPAddress", ( VT_ARRAY | VT_BSTR ), &varIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetWMIProperty( pConfigurationIn, L"IPSubnet", ( VT_ARRAY | VT_BSTR ), &varIPSubnet ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( SafeArrayGetUBound( varIPAddress.parray, 1, &lIPAddressesUpperBound ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( SafeArrayGetUBound( varIPSubnet.parray, 1, &lIPSubnetsUpperBound ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    Assert( lIPAddressesUpperBound == lIPSubnetsUpperBound );
    if ( lIPAddressesUpperBound != lIPSubnetsUpperBound )
    {
        hr = S_FALSE;
        LOG_STATUS_REPORT( L"[SRV] The IP address and IP subnet upper bound counts are not equal", hr );
        goto Cleanup;
    } // if:

    hr = THR( SafeArrayGetLBound( varIPAddress.parray, 1, &lIPAddressesLowerBound ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( SafeArrayGetLBound( varIPSubnet.parray, 1, &lIPSubnetsLowerBound ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    Assert( lIPAddressesLowerBound == lIPSubnetsLowerBound );
    if ( lIPAddressesLowerBound != lIPSubnetsLowerBound )
    {
        hr = S_FALSE;
        LOG_STATUS_REPORT( L"[SRV] The IP address and IP subnet lower bound counts are not equal", hr );
        goto Cleanup;
    } // if:

    //
    // Loop through the IP addresses and store them in our own enumerator
    // so that they can be returned by calls to the Next() method.
    //

    for ( idx = lIPAddressesLowerBound; idx <= lIPAddressesUpperBound; idx++ )
    {
        hr = THR( SafeArrayGetElement( varIPAddress.parray, &idx, &bstrIPAddress ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        TraceMemoryAddBSTR( bstrIPAddress );

        //
        // It is expected that there is at least one IP address.
        //

        if ( *bstrIPAddress == L'\0' )
        {
            HRESULT hrTemp;
            CLSID   clsidMinorId;

            STATUS_REPORT_REF(
                      TASKID_Major_Find_Devices
                    , TASKID_Minor_Not_Managed_Networks
                    , IDS_INFO_NOT_MANAGED_NETWORKS
                    , IDS_INFO_NOT_MANAGED_NETWORKS_REF
                    , S_OK
                    );

            hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
            if ( FAILED( hrTemp ) )
            {
                LogMsg( L"[SRV] Could not create a guid for a network adapter with no IP addresses minor task ID" );
                clsidMinorId = IID_NULL;
            } // if:

            STATUS_REPORT_STRING_REF(
                      TASKID_Minor_Not_Managed_Networks
                    , clsidMinorId
                    , IDS_WARN_NO_IP_ADDRESSES
                    , bstrAdapterNameIn
                    , IDS_WARN_NO_IP_ADDRESSES_REF
                    , hr
                    );
            goto Cleanup;
        } // end if:

        hr = THR( SafeArrayGetElement( varIPSubnet.parray, &idx, &bstrIPSubnet ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        Assert( bstrIPAddress != NULL );
        Assert( wcslen( bstrIPAddress ) > 0 );

        TraceMemoryAddBSTR( bstrIPSubnet );

        LOG_STATUS_REPORT_STRING2( L"Found IP Address '%1!ws!' with subnet mask '%2!ws!'." , bstrIPAddress, bstrIPSubnet, hr );

        hr = THR( HrMakeDottedQuad( bstrIPAddress, &ulIPAddress ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrMakeDottedQuad( bstrIPSubnet, &ulIPSubnet ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        TraceSysFreeString( bstrIPAddress );
        bstrIPAddress = NULL;

        TraceSysFreeString( bstrIPSubnet );
        bstrIPSubnet  = NULL;

        hr = THR( HrCreateIPAddress( &punk ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( punk->TypeSafeQI( IClusCfgIPAddressInfo, &piccipai ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( piccipai->SetIPAddress( ulIPAddress ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( piccipai->SetSubnetMask( ulIPSubnet ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        piccipai->Release();
        piccipai = NULL;

        hr = THR( HrAddIPAddressToArray( punk ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        punk->Release();
        punk = NULL;
    } // for: each IP address

Cleanup:

    if ( piccipai != NULL )
    {
        piccipai->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrIPAddress );
    TraceSysFreeString( bstrIPSubnet );

    VariantClear( &varIPAddress );
    VariantClear( &varIPSubnet );

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrSaveIPAddresses


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses:HrCreateIPAddress
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrCreateIPAddress( IUnknown ** ppunkOut )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );

    HRESULT     hr;
    IUnknown *  punk = NULL;

    hr = THR( CClusCfgIPAddressInfo::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CClusCfgIPAddressInfo", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    *ppunkOut = punk;
    (*ppunkOut)->AddRef();

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrCreateIPAddress


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses:HrCreateIPAddress
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrCreateIPAddress(
      ULONG         ulIPAddressIn
    , ULONG         ulIPSubnetIn
    , IUnknown **   ppunkOut
    )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );

    HRESULT     hr;
    IUnknown *  punk = NULL;

    hr = THR( CClusCfgIPAddressInfo::S_HrCreateInstance( ulIPAddressIn, ulIPSubnetIn, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CClusCfgIPAddressInfo", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    *ppunkOut = punk;
    (*ppunkOut)->AddRef();

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrCreateIPAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumclusterresources.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CEnumClusterResources.cpp
//
//  Description:
//      This file contains the definition of the CEnumClusterResources
//       class.
//
//      The class CEnumClusterResources is the enumeration of cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CEnumClusterResources.h"
#include "CClusterResource.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumClusterResources" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusterResources class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::S_HrCreateInstance
//
//  Description:
//      Create a CEnumClusterResources instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CEnumClusterResources instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CEnumClusterResources * pecr = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pecr = new CEnumClusterResources();
    if ( pecr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pecr->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pecr->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumClusterResources::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pecr != NULL )
    {
        pecr->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusterResources::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  IUnknown *
//  CEnumClusterResources::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      IN  ICatRegister * picrIn
//          Used to register/unregister our CATID support.
//
//      IN  BOOL fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_EnumPhysicalDisks, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumClusterResources::S_RegisterCatIDSupport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::CEnumClusterResources
//
//  Description:
//      Constructor of the CEnumClusterResources class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusterResources::CEnumClusterResources( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
    , m_fLoadedResources( false )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_prgResources == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( m_cTotalResources == 0 );

    TraceFuncExit();

} //*** CEnumClusterResources::CEnumClusterResources


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::~CEnumClusterResources
//
//  Description:
//      Desstructor of the CEnumClusterResources class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusterResources::~CEnumClusterResources( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgResources)[ idx ] != NULL )
        {
            ((*m_prgResources)[ idx ])->Release();
        } // end if:
    } // for:

    TraceFree( m_prgResources );

    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusterResources::~CEnumClusterResources


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusterResources -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusterResources::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumClusterResources::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusterResources::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CEnumClusterResources::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IEnumClusCfgManagedResources * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgManagedResources ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
    } // else if: IEnumClusCfgManagedResources
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumClusterResources::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusterResources -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    punkCallbackIn
//    lcidIn
//
//  Return Value:
//      S_OK            - Success.
//      E_INVALIDARG    - Required input argument not specified.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Initialize(
      IUnknown *    punkCallbackIn
    , LCID          lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumClusterResources::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusterResources -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           cFetched = 0;
    ULONG                           idx;
    ULONG                           idxOutBuf;
    IClusCfgManagedResourceInfo *   pccsdi;
    IUnknown *                      punk;
    ULONG                           ulStop;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_Cluster_Resources, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedResources )
    {
        hr = THR( HrGetResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    cFetched = ulStop = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( idx = 0, idxOutBuf = 0; idx < ulStop; idx++, m_idxEnumNext++ )
    {
        punk = (*m_prgResources)[ m_idxEnumNext ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccsdi ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            rgpManagedResourceInfoOut[ idxOutBuf++ ] = pccsdi;
        } // if:
        else
        {
            cFetched--;
        } // else:
    } // for:

    if ( FAILED( hr ) )
    {
        ULONG   idxStop = idxOutBuf - 1;

        m_idxEnumNext -= idx;

        for ( idx = 0; idx < idxStop; idx++ )
        {
            (rgpManagedResourceInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;
        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumClusterResources::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumClusterResources::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    m_idxEnumNext = 0;

    HRETURN( S_OK );

} //*** CEnumClusterResources::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgStorageDevicesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_Cluster_Resources, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusterResources::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Count( DWORD * pnCountOut )
{
    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedResources )
    {
        hr = THR( HrGetResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    *pnCountOut = m_cTotalResources;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusterResources::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusterResources class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CEnumClusterResources::HrInit


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::HrGetResources
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::HrGetResources( void )
{
    TraceFunc( "" );
    HRESULT     hr = S_OK;
    BSTR        bstrLocalNetBIOSName = NULL;

    //
    //  Get netbios name for clusapi calls.
    //

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &bstrLocalNetBIOSName, TRUE ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:


    hr = THR( HrEnumNodeResources( bstrLocalNetBIOSName ) );

    if ( FAILED( hr ) )
        goto Cleanup;

    m_fLoadedResources = true;

Cleanup:

    TraceSysFreeString( bstrLocalNetBIOSName );

    HRETURN( hr );

} //*** CEnumClusterResources::HrGetResources


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::HrCreateResourceAndAddToArray
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::HrCreateResourceAndAddToArray(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResourceIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    IUnknown *              punk = NULL;
    IClusCfgLoadResource *  picclr = NULL;

    hr = THR( CClusterResource::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ))
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgLoadResource, &picclr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( picclr->LoadResource( hClusterIn, hResourceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddResourceToArray( punk ) );

Cleanup:

    if ( picclr != NULL )
    {
        picclr->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusterResources::HrCreateResourceAndAddToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources:HrAddResourceToArray
//
//  Description:
//      Add the passed in disk to the array of punks that holds the disks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::HrAddResourceToArray( IUnknown * punkIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]);

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgResources, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrAddResourceToArray, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    m_prgResources = prgpunks;

    (*m_prgResources)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cTotalResources += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusterResources::HrAddResourceToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources:HrNodeResourceCallback
//
//  Description:
//      Called by CClusterUtils::HrEnumNodeResources() when it finds a
//      resource for this node.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::HrNodeResourceCallback(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResourceIn
    )
{
    TraceFunc( "" );

    HRETURN( HrCreateResourceAndAddToArray( hClusterIn, hResourceIn ) );

} //*** CEnumClusterResources::HrNodeResourceCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgnetworks.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgNetworks.h
//
//  Description:
//      This file contains the declaration of the CEnumClusCfgNetworks
//      class.
//
//      The class CEnumClusCfgNetworks is the enumeration of
//      cluster networks. It implements the IEnumClusCfgNetworks interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumClusCfgNetworks.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumClusCfgNetworks
//
//  Description:
//      The class CEnumClusCfgNetworks is the enumeration of cluster networks.
//
//  Interfaces:
//      IEnumClusCfgNetworks
//      IClusCfgWbemServices
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumClusCfgNetworks
    : public IEnumClusCfgNetworks
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    IUnknown *          ((*m_prgNetworks)[]);
    BOOL                m_fLoadedNetworks;
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    DWORD               m_cNetworks;

    // Private constructors and destructors
    CEnumClusCfgNetworks( void );
    ~CEnumClusCfgNetworks( void );

    // Private copy constructor to prevent copying.
    CEnumClusCfgNetworks( const CEnumClusCfgNetworks & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumClusCfgNetworks & operator = ( const CEnumClusCfgNetworks & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrGetNetworks( void );
    HRESULT HrAddNetworkToArray( IUnknown * punkIn );
    HRESULT HrCreateAndAddNetworkToArray( IWbemClassObject * pNetworkIn, const CLSID * pclsidMajorIdIn, LPCWSTR pwszNetworkNameIn );
    HRESULT HrIsThisNetworkUnique( IUnknown * punkIn, IWbemClassObject * pNetworkIn, const CLSID * pclsidMajorIdIn, LPCWSTR pwszNetworkNameIn );
    HRESULT HrCheckForNLBS( void );
    HRESULT HrLoadClusterNetworks( void );
    HRESULT HrLoadClusterNetwork( HNETWORK hNetworkResourceIn, HNETINTERFACE hNetInterfaceIn );
    HRESULT HrFindNetInterface( HNETWORK hNetworkIn, BSTR * pbstrNetInterfaceNameOut );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgNetworks Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgNetworkInfo ** rgpNetworkInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgNetworks ** ppEnumNetworksOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

}; //*** Class CEnumClusCfgNetworks
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgmanagedresources.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgManagedResources.cpp
//
//  Description:
//      This file contains the definition of the CEnumClusCfgManagedResources
//       class.
//
//      The class CEnumClusCfgManagedResources is the enumeration of cluster
//      managed devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CEnumClusCfgManagedResources.h"
#include "CEnumUnknownQuorum.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumClusCfgManagedResources" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::S_HrCreateInstance
//
//  Description:
//      Create a CEnumClusCfgManagedResources instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CEnumClusCfgManagedResources instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    CEnumClusCfgManagedResources *  peccmr = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    peccmr = new CEnumClusCfgManagedResources();
    if ( peccmr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( peccmr->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( peccmr->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumClusCfgManagedResources::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( peccmr != NULL )
    {
        peccmr->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::CEnumClusCfgManagedResources
//
//  Description:
//      Constructor of the CEnumClusCfgManagedResources class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgManagedResources::CEnumClusCfgManagedResources( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    Assert( m_idxNextEnum == 0 );
    Assert( m_idxCurrentEnum == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_prgEnums == NULL );
    Assert( m_cTotalResources == 0);
    Assert( !m_fLoadedDevices );
    Assert( m_bstrNodeName == NULL );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusCfgManagedResources::CEnumClusCfgManagedResources


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::~CEnumClusCfgManagedResources
//
//  Description:
//      Desstructor of the CEnumClusCfgManagedResources class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgManagedResources::~CEnumClusCfgManagedResources( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNextEnum; idx++ )
    {
        Assert( (m_prgEnums[ idx ]).punk != NULL );

        (m_prgEnums[ idx ]).punk->Release();
        TraceSysFreeString( (m_prgEnums[ idx ]).bstrComponentName );
    } // for: each enum in the array...

    TraceFree( m_prgEnums );

    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusCfgManagedResources::~CEnumClusCfgManagedResources


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgManagedResources::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumClusCfgManagedResources::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgManagedResources::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CEnumClusCfgManagedResources::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IEnumClusCfgManagedResources * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgManagedResources ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
    } // else if: IEnumClusCfgManagedResources
    else if ( IsEqualIID( riidIn, IID_IClusCfgWbemServices ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
    } // else if: IClusCfgWbemServices
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

     QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumClusCfgManagedResources::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Enum_Resources, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Next(
      ULONG                           cNumberRequestedIn
    , IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut
    , ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );
    Assert( rgpManagedResourceInfoOut != NULL );
    Assert( ( cNumberRequestedIn <= 1 ) || ( pcNumberFetchedOut != NULL ) );

    HRESULT hr;
    ULONG   cFetched = 0;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_Resources, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    //
    //  pcNumberFetchedOut can only be NULL when the number requested is 1.
    //

    if (   ( pcNumberFetchedOut == NULL )
        && ( cNumberRequestedIn > 1 ) )
    {
        hr = THR( E_INVALIDARG );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_Resources, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_fLoadedDevices == FALSE )
    {
        hr = THR( HrLoadEnum() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    hr = STHR( HrDoNext( cNumberRequestedIn, rgpManagedResourceInfoOut, &cFetched ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Do they want the out count?
    //

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_FALSE;

    if ( cNumberToSkipIn > 0 )
    {
        hr = STHR( HrDoSkip( cNumberToSkipIn ) );
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr;

    hr = STHR( HrDoReset() );

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgManagedResourcesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgManagedResourcesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_Resources, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // else:

    hr = THR( HrDoClone( ppEnumClusCfgManagedResourcesOut ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedDevices )
    {
        hr = THR( HrLoadEnum() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    *pnCountOut = m_cTotalResources;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK    - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrLoadEnum
//
//  Description:
//      Load this enumerator.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrLoadEnum( void )
{
    TraceFunc( "" );
    Assert( m_prgEnums == NULL );

    HRESULT                         hr = S_OK;
    IUnknown *                      punk = NULL;
    ICatInformation *               pici = NULL;
    CATID                           rgCatIds[ 1 ];
    IEnumCLSID *                    pieclsids = NULL;
    IEnumClusCfgManagedResources *  pieccmr = NULL;
    CLSID                           clsid;
    ULONG                           cFetched;
    WCHAR                           szGUID[ 64 ];
    int                             cch;
    BSTR                            bstrComponentName = NULL;

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    hr = THR( CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC_SERVER, IID_ICatInformation, (void **) &pici ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pici->EnumClassesOfCategories( 1, rgCatIds, 0, NULL, &pieclsids ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    for ( ; ; )
    {

        //
        //  Cleanup.
        //

        if ( punk != NULL )
        {
            punk->Release();
            punk = NULL;
        } // if:

        TraceSysFreeString( bstrComponentName );
        bstrComponentName = NULL;

        hr = STHR( pieclsids->Next( 1, &clsid, &cFetched ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  When hr is S_FALSE and the count is 0 then the enum is really
        //  at the end.
        //

        if ( ( hr == S_FALSE ) && ( cFetched == 0 ) )
        {
            hr = S_OK;
            break;
        } // if:

        //
        //  Create a GUID string for logging purposes...
        //

        cch = StringFromGUID2( clsid, szGUID, RTL_NUMBER_OF( szGUID ) );
        Assert( cch > 0 );  // 64 chars should always hold a guid!

        //
        //  Get the best name we have available for the COM component.  If for
        //  any reason we cannot get the name then make one up and continue.
        //

        hr = THR( HrGetDefaultComponentNameFromRegistry( &clsid, &bstrComponentName ) );
        if ( FAILED( hr ) )
        {
            bstrComponentName = TraceSysAllocString( L"<Unknown> component" );
            if ( bstrComponentName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:
        } // if:

        //
        //  If we cannot create the component then log the error and continue.  We should load as many components as we can.
        //

        hr = THR( HrCoCreateInternalInstance( clsid, NULL, CLSCTX_SERVER, IID_IEnumClusCfgManagedResources, (void **) &pieccmr ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT_STRING_MINOR2( TASKID_Minor_MREnum_Cannot_Create_Component, L"Could not create component %1!ws! %2!ws!.", bstrComponentName, szGUID, hr );
            hr = S_OK;
            continue;
        } // if:

        //
        //  If we cannot QI the component then log the error and continue.  We should load as many components as we can.
        //

        hr = THR( pieccmr->TypeSafeQI( IUnknown, &punk ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT_STRING_MINOR2( TASKID_Minor_MREnum_Cannot_QI_Component_For_Punk, L"Could not QI for IUnknown on component %1!ws! %2!ws!.", bstrComponentName, szGUID, hr );
            hr = S_OK;
            continue;
        } // if:

        punk = TraceInterface( L"IEnumClusCfgManagedResources", IUnknown, punk, 1 );

        pieccmr->Release();
        pieccmr = NULL;

        //
        //  If this fails then simply skip it and move on...
        //

        hr = HrInitializeAndSaveEnum( punk, &clsid, bstrComponentName );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT_STRING_MINOR2( TASKID_Minor_MREnum_Cannot_Save_Provider, L"Could not save enumerator component %1!ws! %2!ws!.", bstrComponentName, szGUID, hr );
            hr = S_OK;
            continue;
        } // if:

        if ( hr == S_OK )
        {
            m_fLoadedDevices = TRUE;    // there is at least one provider loaded.
        } // if:
    } // for: each CLSID that implements our CATID...

    hr = STHR( HrLoadUnknownQuorumProvider() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( pieclsids != NULL )
    {
        pieclsids->Release();
    } // if:

    if ( pici != NULL )
    {
        pici->Release();
    } // if:

    if ( pieccmr != NULL )
    {
        pieccmr->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrComponentName );

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrLoadEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrDoNext
//
//  Description:
//      Gets the required number of elements from the contained physical disk
//      and optional 3rd party device enumerations.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrDoNext(
      ULONG                           cNumberRequestedIn
    , IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut
    , ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "" );
    Assert( rgpManagedResourceInfoOut != NULL );
    Assert( pcNumberFetchedOut != NULL );
    Assert( m_prgEnums != NULL );

    HRESULT                         hr = S_FALSE;
    IEnumClusCfgManagedResources *  peccsd = NULL;
    ULONG                           cRequested = cNumberRequestedIn;
    ULONG                           cFetched = 0;
    ULONG                           cTotal = 0;
    IClusCfgManagedResourceInfo **  ppccmriTemp = rgpManagedResourceInfoOut;
    int                             cch;
    WCHAR                           szGUID[ 64 ];

    //
    //  Call each enumerator in the list trying to get the number of requested
    //  items.  Note that we may call the same enumerator more than once in
    //  this loop.  The second call is to ensure that we are really at the
    //  end of the enumerator.
    //

    LOG_STATUS_REPORT_STRING3( L"[SRV] Enumerating resources. Total Requested:%1!d!; Current enum index:%2!d!; Total Enums:%3!d!.", cNumberRequestedIn, m_idxCurrentEnum, m_idxNextEnum, hr );

    while ( m_idxCurrentEnum < m_idxNextEnum )
    {
        //
        //  Cleanup.
        //

        if ( peccsd != NULL )
        {
            peccsd->Release();
            peccsd = NULL;
        } // if:

        cch = StringFromGUID2( (m_prgEnums[ m_idxCurrentEnum ]).clsid, szGUID, RTL_NUMBER_OF( szGUID ) );
        Assert( cch > 0 );  // 64 chars should always hold a guid!

        Assert( (m_prgEnums[ m_idxCurrentEnum ]).punk != NULL );
        hr = THR( (m_prgEnums[ m_idxCurrentEnum ]).punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccsd ) );
        if ( FAILED( hr ) )
        {
            HRESULT hrTemp;

            //
            //  Convert this into a warning in the UI...
            //

            hrTemp = MAKE_HRESULT( SEVERITY_SUCCESS, HRESULT_FACILITY( hr ), HRESULT_CODE( hr ) );

            //
            //  If we cannot QI for the enum then move on to the next one.
            //

            STATUS_REPORT_STRING2_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Enum_Enum_QI_Failed
                , IDS_WARNING_SKIPPING_ENUM
                , (m_prgEnums[ m_idxCurrentEnum ]).bstrComponentName
                , szGUID
                , IDS_WARNING_SKIPPING_ENUM
                , hrTemp
                );

            m_idxCurrentEnum++;
            continue;
        } // if:

        hr = STHR( peccsd->Next( cRequested, ppccmriTemp, &cFetched ) );
        if ( FAILED( hr ) )
        {
            HRESULT hrTemp;

            //
            //  Convert this into a warning in the UI...
            //

            hrTemp = MAKE_HRESULT( SEVERITY_SUCCESS, HRESULT_FACILITY( hr ), HRESULT_CODE( hr ) );

            //
            //  If this enumerator fails for anyreason then we should skip it
            //  and move on to the next one.
            //

            STATUS_REPORT_STRING2_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Enum_Enum_Next_Failed
                , IDS_WARNING_SKIPPING_ENUM
                , (m_prgEnums[ m_idxCurrentEnum ]).bstrComponentName
                , szGUID
                , IDS_WARNING_SKIPPING_ENUM
                , hrTemp
                );

            m_idxCurrentEnum++;
            continue;
        } // if:
        else if ( hr == S_OK )
        {
            cTotal += cFetched;

            //
            //  We can only return S_OK if the number of elements returned is equal to
            //  the number of elements requested.  If the number request is greater than
            //  the number returned then we must return S_FALSE.
            //

            Assert( cNumberRequestedIn == cTotal );
            *pcNumberFetchedOut = cTotal;
            break;
        } // else if: hr == S_OK
        else if ( hr == S_FALSE )
        {
            //
            //  The only time that we can be certain that an enumerator is
            //  empty is to get S_FALSE and no elements returned.  Now that
            //  the current enumerator empty move up to the next one in the
            //  list.
            //

            if ( cFetched == 0 )
            {
                m_idxCurrentEnum++;
                continue;
            } // if:

            //
            //  Update the totals...
            //

            cTotal += cFetched;
            *pcNumberFetchedOut = cTotal;
            cRequested -= cFetched;

            //
            //  If we got some items and still got S_FALSE then we have to
            //  retry the current enumerator.
            //

            if ( cRequested > 0 )
            {
                ppccmriTemp += cFetched;
                continue;
            } // if: Safety check...  Ensure that we still need more elements...
            else
            {
                //
                //  We should not have decremented requested items below zero!
                //

                hr = S_FALSE;
                LOG_STATUS_REPORT_MINOR( TASKID_Minor_MREnum_Negative_Item_Count, L"The managed resources enumerator tried to return more items than asked for.", hr );
                goto Cleanup;
            } // else: Should not get here...
        } // if: hr == S_FALSE
        else
        {
            //
            //  Should not get here as we are in an unknown state...
            //

            LOG_STATUS_REPORT_MINOR( TASKID_Minor_MREnum_Unknown_State, L"The managed resources enumerator encountered an unknown state.", hr );
            goto Cleanup;
        } // else: unexpected hresult...
    } // while: more enumerators in the list

    //
    //  If we haven't honored the complete request then we must return
    //  S_FALSE;
    //

    if ( *pcNumberFetchedOut < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( peccsd != NULL )
    {
        peccsd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrDoNext


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrDoSkip
//
//  Description:
//      Skips the required number of elements in the contained physical disk
//      and optional 3rd party device enumerations.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrDoSkip(
    ULONG cNumberToSkipIn
    )
{
    TraceFunc( "" );
    Assert( m_prgEnums != NULL );

    HRESULT                         hr = S_FALSE;
    IEnumClusCfgManagedResources *  peccsd = NULL;
    ULONG                           cSkipped = 0;

    for ( ; m_idxCurrentEnum < m_idxNextEnum; )
    {
        hr = THR( (m_prgEnums[ m_idxCurrentEnum ]).punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccsd ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        do
        {
            hr = STHR( peccsd->Skip( 1 ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_FALSE )
            {
                m_idxCurrentEnum++;
                break;
            } // if:
        }
        while( cNumberToSkipIn >= (++cSkipped) );

        peccsd->Release();
        peccsd = NULL;

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( cNumberToSkipIn == cSkipped )
        {
            break;
        } // if:
    } // for:

Cleanup:

    if ( peccsd != NULL )
    {
        peccsd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrDoSkip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrDoReset
//
//  Description:
//      Resets the elements in the contained physical disk and optional 3rd
//      party device enumerations.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrDoReset( void )
{
    TraceFunc( "" );

    HRESULT                         hr = S_FALSE;
    IEnumClusCfgManagedResources *  peccsd;
    ULONG                           idx;

    m_idxCurrentEnum = 0;

    for ( idx = m_idxCurrentEnum; idx < m_idxNextEnum; idx++ )
    {
        Assert( m_prgEnums != NULL );

        hr = THR( (m_prgEnums[ idx ]).punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccsd ) );
        if ( FAILED( hr ) )
        {
            break;
        } // if:

        hr = STHR( peccsd->Reset() );
        peccsd->Release();

        if ( FAILED( hr ) )
        {
            break;
        } // if:
    } // for:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrDoReset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrDoClone
//
//  Description:
//      Clones the elements in the contained physical disk and optional 3rd
//      party device enumerations.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrDoClone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgManagedResourcesOut
    )
{
    TraceFunc( "" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrDoClone


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrAddToEnumsArray
//
//  Description:
//      Add the passed in punk to the array of punks that holds the enums.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrAddToEnumsArray(
      IUnknown *    punkIn
    , CLSID *       pclsidIn
    , BSTR          bstrComponentNameIn
    )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );
    Assert( pclsidIn != NULL );
    Assert( bstrComponentNameIn != NULL );

    HRESULT                         hr = S_OK;
    SEnumInfo *                     prgEnums = NULL;
    IEnumClusCfgManagedResources *  pieccmr = NULL;
    DWORD                           nAmountToAdd = 0;

    hr = punkIn->TypeSafeQI( IEnumClusCfgManagedResources, &pieccmr );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pieccmr->Count( &nAmountToAdd );
    if ( FAILED( hr ) )
    {
        WCHAR   szGUID[ 64 ];
        int     cch;
        HRESULT hrTemp;

        //
        //  Convert this into a warning in the UI...
        //

        hrTemp = MAKE_HRESULT( SEVERITY_SUCCESS, HRESULT_FACILITY( hr ), HRESULT_CODE( hr ) );

        cch = StringFromGUID2( *pclsidIn, szGUID, RTL_NUMBER_OF( szGUID ) );
        Assert( cch > 0 );  // 64 chars should always hold a guid!

        STATUS_REPORT_STRING2_REF(
              TASKID_Major_Find_Devices
            , TASKID_Minor_Enum_Enum_Count_Failed
            , IDS_WARNING_SKIPPING_ENUM
            , bstrComponentNameIn
            , szGUID
            , IDS_WARNING_SKIPPING_ENUM
            , hrTemp
            );
        goto Cleanup;
    } // if:

    prgEnums = (SEnumInfo *) TraceReAlloc( m_prgEnums, sizeof( SEnumInfo ) * ( m_idxNextEnum + 1 ), HEAP_ZERO_MEMORY );
    if ( prgEnums == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrAddToEnumsArray, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    m_prgEnums = prgEnums;

    //
    //  Fill in the newly allocated struct.
    //

    (m_prgEnums[ m_idxNextEnum ]).punk = punkIn;
    (m_prgEnums[ m_idxNextEnum ]).punk->AddRef();

    CopyMemory( &((m_prgEnums[ m_idxNextEnum ]).clsid), pclsidIn, sizeof( ( m_prgEnums[ m_idxNextEnum ]).clsid ) );

    //
    //  Capture the component name.  We don't really care if this fails.
    //  Simply show the popup for anyone who may be watching and continue on.
    //

    (m_prgEnums[ m_idxNextEnum ]).bstrComponentName = TraceSysAllocString( bstrComponentNameIn );
    if ( (m_prgEnums[ m_idxNextEnum ]).bstrComponentName == NULL )
    {
        THR( E_OUTOFMEMORY );
    } // if:

    //
    //  Increment the enum index pointer.
    //

    m_idxNextEnum++;

    m_cTotalResources += nAmountToAdd;

Cleanup:

    if ( pieccmr != NULL )
    {
        pieccmr->Release();
    }

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrAddToEnumsArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrLoadUnknownQuorumProvider
//
//  Description:
//      Since we cannot resonable expect every 3rd party quorum vender
//      to write a "provider" for their device for this setup wizard
//      we need a proxy to represent that quorum device.  The "unknown"
//      is just such a proxy.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      If this node is clustered and we do not find a device that is
//      already the quorum then we need to make the "unknown" quorum
//      the quorum device.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrLoadUnknownQuorumProvider( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  punk = NULL;
    BOOL        fNeedQuorum = FALSE;
    BOOL        fQuormIsOwnedByThisNode = FALSE;
    BSTR        bstrQuorumResourceName = NULL;
    BSTR        bstrComponentName = NULL;

    hr = STHR( HrIsClusterServiceRunning() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_OK )
    {
        hr = STHR( HrIsThereAQuorumDevice() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_FALSE )
        {
            fNeedQuorum = TRUE;
        } // if:

        hr = THR( HrGetQuorumResourceName( &bstrQuorumResourceName, &fQuormIsOwnedByThisNode ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    //
    //  If there was not already a quorum, and if this node owns the quorum resource
    //  then we need the unknown quorum proxy to be set as default to the quorum device.
    //
    //  If we are not running on a cluster node then both are false and the unknown
    //  quorum proxy will not be set by default to be the quorum.
    //

    hr = THR( CEnumUnknownQuorum::S_HrCreateInstance( bstrQuorumResourceName, ( fNeedQuorum && fQuormIsOwnedByThisNode ), &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_ENUM_UNKNOWN_QUORUM_COMPONENT_NAME, &bstrComponentName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrInitializeAndSaveEnum( punk, const_cast< CLSID * >( &CLSID_EnumUnknownQuorum ), bstrComponentName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrQuorumResourceName );
    TraceSysFreeString( bstrComponentName );

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrLoadUnknownQuorumProvider


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrIsClusterServiceRunning
//
//  Description:
//      Is this node a member of a cluster and is the serice running?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The node is clustered and the serivce is running.
//
//      S_FALSE
//          The node is not clustered, or the serivce is not running.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrIsClusterServiceRunning( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwClusterState;

    //
    // Get the cluster state of the node.
    // Ignore the case where the service does not exist so that
    // EvictCleanup can do its job.
    //

    sc = GetNodeClusterState( NULL, &dwClusterState );
    if ( ( sc != ERROR_SUCCESS ) && ( sc != ERROR_SERVICE_DOES_NOT_EXIST ) )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        goto Cleanup;
    } // if : GetClusterState() failed

    if ( dwClusterState == ClusterStateRunning )
    {
        hr = S_OK;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrIsClusterServiceRunning


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrIsThereAQuorumDevice
//
//  Description:
//      Is there a quorum device in an enum somewhere?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          There is a quorum device.
//
//      S_FALSE
//          There is not a quorum device.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrIsThereAQuorumDevice( void )
{
    TraceFunc( "" );
    Assert( m_idxCurrentEnum == 0 );

    HRESULT                         hr = S_OK;
    IClusCfgManagedResourceInfo *   piccmri = NULL;
    DWORD                           cFetched;
    bool                            fFoundQuorum = false;

    for ( ; ; )
    {
        hr = STHR( Next( 1, &piccmri, &cFetched ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( ( hr == S_FALSE ) && ( cFetched == 0 ) )
        {
            hr = S_OK;
            break;
        } // if:

        hr = STHR( piccmri->IsQuorumResource() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            fFoundQuorum = true;
            break;
        } // if:

        piccmri->Release();
        piccmri = NULL;
    } // for:

    hr = THR( Reset() );

Cleanup:

    if ( piccmri != NULL )
    {
        piccmri->Release();
    } // if:

    if ( SUCCEEDED( hr ) )
    {
        if ( fFoundQuorum )
        {
            hr = S_OK;
        } // if:
        else
        {
            hr = S_FALSE;
        } // else:
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrIsThereAQuorumDevice


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrInitializeAndSaveEnum
//
//  Description:
//      Initialize the passed in enum and add it to the array of enums.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success.
//
//      S_FALSE
//          The provider was not saved.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrInitializeAndSaveEnum(
      IUnknown *    punkIn
    , CLSID *       pclsidIn
    , BSTR          bstrComponentNameIn
    )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );
    Assert( pclsidIn != NULL );
    Assert( bstrComponentNameIn != NULL );

    HRESULT hr = S_OK;

    //
    //  KB: 13-JUN-2000 GalenB
    //
    //  If S_FALSE is returned don't add this to the array.  S_FALSE
    //  indicates that this enumerator should not be run now.
    //

    hr = STHR( HrSetInitialize( punkIn, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_FALSE )
    {
        goto Cleanup;
    } // if:

    hr = HrSetWbemServices( punkIn, m_pIWbemServices );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddToEnumsArray( punkIn, pclsidIn, bstrComponentNameIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrInitializeAndSaveEnum


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrGetQuorumResourceName
//
//  Description:
//      Get the quorum resource name and return whether or not this node
//      owns the quorum.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrGetQuorumResourceName(
      BSTR *  pbstrQuorumResourceNameOut
    , BOOL * pfQuormIsOwnedByThisNodeOut
    )
{
    TraceFunc( "" );
    Assert( pbstrQuorumResourceNameOut != NULL );
    Assert( pfQuormIsOwnedByThisNodeOut != NULL );

    HRESULT     hr = S_OK;
    DWORD       sc;
    HCLUSTER    hCluster = NULL;
    BSTR        bstrQuorumResourceName = NULL;
    BSTR        bstrNodeName = NULL;
    HRESOURCE   hQuorumResource = NULL;
    BSTR        bstrLocalNetBIOSName = NULL;

    //
    //  Get netbios name for clusapi calls.
    //

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &bstrLocalNetBIOSName, TRUE ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( HrGetClusterQuorumResource( hCluster, &bstrQuorumResourceName, NULL, NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hQuorumResource = OpenClusterResource( hCluster, bstrQuorumResourceName );
    if ( hQuorumResource == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( HrGetClusterResourceState( hQuorumResource, &bstrNodeName, NULL, NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Give ownership away.
    //

    Assert( bstrQuorumResourceName != NULL );
    *pbstrQuorumResourceNameOut = bstrQuorumResourceName;
    bstrQuorumResourceName = NULL;

    *pfQuormIsOwnedByThisNodeOut = ( NBSTRCompareNoCase( bstrLocalNetBIOSName, bstrNodeName ) == 0 );

Cleanup:

    if ( hQuorumResource != NULL )
    {
        CloseClusterResource( hQuorumResource );
    } // if:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    TraceSysFreeString( bstrQuorumResourceName );
    TraceSysFreeString( bstrLocalNetBIOSName );
    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrGetQuorumResourceName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgmanagedresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgManagedResources.h
//
//  Description:
//      This file contains the declaration of the CEnumClusCfgManagedResources
//      class.
//
//      The class CEnumClusCfgManagedResources is the enumeration of cluster
//      managed devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumClusCfgManagedResources.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumClusCfgManagedResources
//
//  Description:
//      The class CEnumClusCfgManagedResources is the enumeration of
//      cluster managed resource enumerations.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgWbemServices
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumClusCfgManagedResources
    : public IEnumClusCfgManagedResources
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
{
private:

    //
    // Private member functions and data
    //

    struct SEnumInfo
    {
        IUnknown *  punk;
        CLSID       clsid;
        BSTR        bstrComponentName;
    };

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    SEnumInfo *         m_prgEnums;
    BOOL                m_fLoadedDevices;
    ULONG               m_idxNextEnum;
    ULONG               m_idxCurrentEnum;
    DWORD               m_cTotalResources;
    BSTR                m_bstrNodeName;

    //
    //  Private constructors and destructors
    //

    CEnumClusCfgManagedResources( void );
    ~CEnumClusCfgManagedResources( void );

    //
    //  Private copy constructor to prevent copying.
    //

    CEnumClusCfgManagedResources( const CEnumClusCfgManagedResources & nodeSrc );

    //
    //  Private assignment operator to prevent copying.
    //

    const CEnumClusCfgManagedResources & operator = ( const CEnumClusCfgManagedResources & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrLoadEnum( void );
    HRESULT HrDoNext( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );
    HRESULT HrAddToEnumsArray( IUnknown * punkIn, CLSID * pclsidIn, BSTR bstrComponentNameIn );
    HRESULT HrDoSkip( ULONG cNumberToSkipIn );
    HRESULT HrDoReset( void );
    HRESULT HrDoClone(  IEnumClusCfgManagedResources ** ppEnumClusCfgManagedResourcesOut );
    HRESULT HrLoadUnknownQuorumProvider( void );
    HRESULT HrIsClusterServiceRunning( void );
    HRESULT HrIsThereAQuorumDevice( void );
    HRESULT HrInitializeAndSaveEnum( IUnknown * punkIn, CLSID * pclsidIn, BSTR bstrComponentNameIn );
    HRESULT HrGetQuorumResourceName( BSTR * pbstrQuorumResourceNameOut , BOOL * pfQuormIsOwnedByThisNodeOut );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgManagedResourcesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

}; //*** Class CEnumClusCfgManagedResources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumclusterresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CEnumClusterResources.h
//
//  Description:
//      This file contains the declaration of the CEnumClusterResources class.
//
//      The class CEnumClusterResources is the enumeration of cluster
//      resources. It implements the IEnumClusCfgMangedResources
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumClusterResources.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumClusterResources
//
//  Description:
//      The class CEnumClusterResources is the enumeration of cluster
//      resources.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgInitialize
//      CClusterUtils
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumClusterResources
    : public IEnumClusCfgManagedResources
    , public IClusCfgInitialize
    , public CClusterUtils
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    BOOL                m_fLoadedResources;
    IClusCfgCallback *  m_picccCallback;
    IUnknown *          ((*m_prgResources)[]);
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    DWORD               m_cTotalResources;

    // Private constructors and destructors
    CEnumClusterResources( void );
    ~CEnumClusterResources( void );

    // Private copy constructor to prevent copying.
    CEnumClusterResources( const CEnumClusterResources & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumClusterResources & operator = ( const CEnumClusterResources & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrGetResources( void );
    HRESULT HrCreateResourceAndAddToArray( HCLUSTER hClusterIn, HRESOURCE hResourceIn );
    HRESULT HrAddResourceToArray( IUnknown * punkIn );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // CClusterUtils
    //

    HRESULT HrNodeResourceCallback( HCLUSTER hClusterIn, HRESOURCE hResourceIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );
    
}; //*** Class CEnumClusterResources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumlocalquorum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CEnumLocalQuorum.cpp
//
//  Description:
//      This file contains the definition of the CEnumLocalQuorum
//       class.
//
//      The class CEnumLocalQuorum is the enumeration of cluster
//      local quorum devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include <PropList.h>
#include "CEnumLocalQuorum.h"
#include "CLocalQuorum.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumLocalQuorum" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumLocalQuorum class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CEnumLocalQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CEnumLocalQuorum *  pelq = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pelq = new CEnumLocalQuorum();
    if ( pelq == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pelq->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pelq->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumLocalQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pelq != NULL )
    {
        pelq->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumLocalQuorum::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  IUnknown *
//  CEnumLocalQuorum::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      IN  ICatRegister * picrIn
//          Used to register/unregister our CATID support.
//
//      IN  BOOL fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_EnumLocalQuorum, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumLocalQuorum::S_RegisterCatIDSupport


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum:HrNodeResourceCallback
//
//  Description:
//      Called by CClusterUtils::HrEnumNodeResources when it finds a
//      resource for this node.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::HrNodeResourceCallback(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResourceIn
    )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    DWORD                           sc;
    CClusPropList                   cplPriv;
    CClusPropList                   cplCommonRO;
    CLUSPROP_BUFFER_HELPER          cpbh;
    BOOL                            fIsQuorum;
    IUnknown *                      punk = NULL;
    IClusCfgManagedResourceInfo *   pcccmri = NULL;
    IClusCfgVerifyQuorum *          piccvq = NULL;

    hr = STHR( HrIsResourceOfType( hResourceIn, L"Local Quorum" ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If this resource is not a local quorum then we simply want to
    //  skip it.
    //
    if ( hr == S_FALSE )
    {
        goto Cleanup;
    } // if:

    hr = STHR( HrIsCoreResource( hResourceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    fIsQuorum = ( hr == S_OK );

    LOG_STATUS_REPORT_STRING( L"This node owns a local quorum resource.  It '%1!ws!' the quorum.", fIsQuorum ? L"is" : L"is not", hr );

    hr = THR( CLocalQuorum::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pcccmri ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If a local quorum resource is found, ie we get here, then the
    //  local quorum resource exists and needs to be managed by befault
    //  by the cluster.
    //

    hr = THR( pcccmri->SetManagedByDefault( TRUE ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If a local quorum resource is found, ie we get here, then the
    //  local quorum resource exists and is in the cluster.
    //

    hr = THR( pcccmri->SetManaged( TRUE ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcccmri->SetQuorumResource( fIsQuorum ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcccmri->TypeSafeQI( IClusCfgVerifyQuorum, &piccvq ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // Find out if the Debug flag is set....
    sc = TW32( cplPriv.ScGetResourceProperties( hResourceIn, CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = cplPriv.ScMoveToPropertyByName( L"Debug" );
    if ( sc == ERROR_NO_MORE_ITEMS )
    {
        hr = THR( piccvq->SetMultiNodeCapable( false ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

    } // if:
    else if ( sc == ERROR_SUCCESS )
    {
        cpbh = cplPriv.CbhCurrentValue();
        Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );

        hr = THR( piccvq->SetMultiNodeCapable( !( cpbh.pDwordValue->dw == 0 ) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // else if:
    else
    {
       TW32( sc );
       goto MakeHr;
    } // else:

    // get the name of this resource.
    sc = TW32( cplCommonRO.ScGetResourceProperties( hResourceIn, CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = cplCommonRO.ScMoveToPropertyByName( L"Name" );
    if ( sc == ERROR_SUCCESS )
    {
        cpbh = cplCommonRO.CbhCurrentValue();
        Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

        hr = THR( pcccmri->SetName( cpbh.pStringValue->sz ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:
    else
    {
       TW32( sc );
       goto MakeHr;
    } // else:

    hr = THR( HrAddResourceToArray( punk ) );

    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );

Cleanup:

    if ( piccvq != NULL )
    {
        piccvq->Release();
    } // if:

    if ( pcccmri != NULL )
    {
        pcccmri->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumLocalQuorum::HrNodeResourceCallback


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumLocalQuorum class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::CEnumLocalQuorum
//
//  Description:
//      Constructor of the CEnumLocalQuorum class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumLocalQuorum::CEnumLocalQuorum( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_prgQuorums == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( !m_fEnumLoaded );
    Assert( m_cQuorumCount == 0 );

    TraceFuncExit();

} //*** CEnumLocalQuorum::CEnumLocalQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::~CEnumLocalQuorum
//
//  Description:
//      Desstructor of the CEnumLocalQuorum class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumLocalQuorum::~CEnumLocalQuorum( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgQuorums)[ idx ] != NULL )
        {
            ((*m_prgQuorums)[ idx ])->Release();
        } // end if:
    } // for:

    TraceFree( m_prgQuorums );

    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumLocalQuorum::~CEnumLocalQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::HrInit( void )
{
    TraceFunc( "" );

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( S_OK );

} //*** CEnumLocalQuorum::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::HrLoadResources
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::HrLoadResources( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrLocalNetBIOSName = NULL;

    //
    //  Get netbios name for clusapi calls.
    //

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &bstrLocalNetBIOSName, TRUE ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:


    //
    //  If the cluster service is running then load any local quorum
    //  resources that we own.
    //
    hr = STHR( HrIsClusterServiceRunning() );
    if ( hr == S_OK )
    {
        hr = THR( HrEnumNodeResources( bstrLocalNetBIOSName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  If this node doesn't own an instance of this resource then we need
        //  to create a dummy resource for MiddleTier analysis.
        //
        if ( m_idxNext == 0 )
        {
            LogMsg( L"[SRV] This node does not own a Local Quorum resource.  Creating a dummy resource." );
            hr = THR( HrCreateDummyObject() );
        } // if:
    } // if:
    else if ( hr == S_FALSE )
    {
        //
        //  If cluster service isn't running then we need to create a dummy resource
        //  for MiddleTier analysis and for EvictCleanup.
        //
        LogMsg( L"[SRV] The cluster service is not running.  Creating a dummy Local Quorum resource." );
        hr = THR( HrCreateDummyObject() );
    } // else if:

Cleanup:

    TraceSysFreeString( bstrLocalNetBIOSName );

    HRETURN( hr );

} //*** CEnumLocalQuorum::HrLoadResources


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum:HrAddResourceToArray
//
//  Description:
//      Add the passed in local quorum to the array of punks that holds the
//      list of local quorums.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::HrAddResourceToArray( IUnknown * punkIn )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgQuorums, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrAddResourceToArray, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    m_prgQuorums = prgpunks;

    (*m_prgQuorums)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cQuorumCount += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumLocalQuorum::HrAddResourceToArray


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::HrCreateDummyObject
//
//  Description:
//      Create a dummy object so the MiddleTier will be happy.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::HrCreateDummyObject( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  punk = NULL;

    hr = THR( CLocalQuorum::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddResourceToArray( punk ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumLocalQuorum::HrCreateDummyObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumLocalQuorum -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumLocalQuorum::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumLocalQuorum::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumLocalQuorum::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CEnumLocalQuorum::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IEnumClusCfgManagedResources * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgManagedResources ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
    } // else if: IEnumClusCfgManagedResources
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING1( hr, riidIn, IID_IClusCfgWbemServices );

} //*** CEnumLocalQuorum::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumLocalQuorum -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    punkCallbackIn
//    lcidIn
//
//  Return Value:
//      S_OK            - Success.
//      E_INVALIDARG    - Required input argument not specified.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Initialize(
      IUnknown *    punkCallbackIn
    , LCID          lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumLocalQuorum::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumLocalQuorum -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           cFetched = 0;
    IClusCfgManagedResourceInfo *   pccsdi;
    IUnknown *                      punk;
    ULONG                           ulStop;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_LocalQuorum, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = STHR( HrLoadResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        m_fEnumLoaded = true;
    } // if:

    ulStop = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( hr = S_OK; ( cFetched < ulStop ) && ( m_idxEnumNext < m_idxNext ); m_idxEnumNext++ )
    {
        punk = (*m_prgQuorums)[ m_idxEnumNext ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccsdi ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            rgpManagedResourceInfoOut[ cFetched++ ] = pccsdi;
        } // if:
    } // for:

    if ( FAILED( hr ) )
    {
        m_idxEnumNext -= cFetched;

        while ( cFetched != 0 )
        {
            (rgpManagedResourceInfoOut[ --cFetched ])->Release();
        } // for:

        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumLocalQuorum::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumLocalQuorum::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    m_idxEnumNext = 0;

    HRETURN( S_OK );

} //*** CEnumLocalQuorum::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgStorageDevicesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_LocalQuorum, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumLocalQuorum::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = STHR( HrLoadResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        m_fEnumLoaded = true;
    } // if:

    *pnCountOut = m_cQuorumCount;

Cleanup:

    HRETURN( hr );

} //*** CEnumLocalQuorum::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgnetworks.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgNetworks.cpp
//
//  Description:
//      This file contains the definition of the CEnumClusCfgNetworks
//       class.
//
//      The class CEnumClusCfgNetworks is the enumeration of cluster
//      networks. It implements the IEnumClusCfgNetworks interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include <PropList.h>
#include "CEnumClusCfgNetworks.h"
#include "CClusCfgNetworkInfo.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumClusCfgNetworks" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::S_HrCreateInstance
//
//  Description:
//      Create a CEnumClusCfgNetworks instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CEnumClusCfgNetworks instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CEnumClusCfgNetworks *  peccn = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    peccn = new CEnumClusCfgNetworks();
    if ( peccn == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( peccn->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( peccn->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumClusCfgNetworks::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( peccn != NULL )
    {
        peccn->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::CEnumClusCfgNetworks
//
//  Description:
//      Constructor of the CEnumClusCfgNetworks class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgNetworks::CEnumClusCfgNetworks( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
    , m_fLoadedNetworks( false )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback ==  NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_prgNetworks == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( m_cNetworks == 0 );

    TraceFuncExit();

} //*** CEnumClusCfgNetworks::CEnumClusCfgNetworks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::~CEnumClusCfgNetworks
//
//  Description:
//      Desstructor of the CEnumClusCfgNetworks class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgNetworks::~CEnumClusCfgNetworks( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        ((*m_prgNetworks)[ idx ])->Release();
    } // for:

    TraceFree( m_prgNetworks );
    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusCfgNetworks::~CEnumClusCfgNetworks


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgNetworks::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumClusCfgNetworks::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgNetworks::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CEnumClusCfgNetworks::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IEnumClusCfgNetworks * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgNetworks ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgNetworks, this, 0 );
    } // else if: IEnumClusCfgNetworks
    else if ( IsEqualIID( riidIn, IID_IClusCfgWbemServices ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
    } // else if: IClusCfgWbemServices
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumClusCfgNetworks::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Enum_Networks, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    punkCallbackIn
//    lcidIn
//
//  Return Value:
//      S_OK    - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Initialize(
      IUnknown *    punkCallbackIn
    , LCID          lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks -- IEnumClusCfgNetworks interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Next(
    ULONG                   cNumberRequestedIn,
    IClusCfgNetworkInfo **  rgpNetworkInfoOut,
    ULONG *                 pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT                 hr = S_FALSE;
    ULONG                   cFetched = 0;
    ULONG                   idx;
    IClusCfgNetworkInfo *   pccni;

    if ( rgpNetworkInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_Networks, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( m_fLoadedNetworks == FALSE )
    {
        hr = THR( HrGetNetworks() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    Assert( m_prgNetworks != NULL );
    Assert( m_idxNext > 0 );

    cFetched = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    //
    // Copy the interfaces to the caller's array.
    //

    for ( idx = 0; idx < cFetched; idx++, m_idxEnumNext++ )
    {
        hr = THR( ((*m_prgNetworks)[ m_idxEnumNext ])->TypeSafeQI( IClusCfgNetworkInfo, &pccni ) );
        if ( FAILED( hr ) )
        {
            break;
        } // if:

        rgpNetworkInfoOut[ idx ] = pccni;

    } // for:

    //
    // If a failure occured, release all the interfaces copied to the caller's
    // array and log the error.
    //

    if ( FAILED( hr ) )
    {
        ULONG   idxStop = idx;
        ULONG   idxError = m_idxEnumNext;

        m_idxEnumNext -= idx;

        for ( idx = 0; idx < idxStop; idx++ )
        {
            (rgpNetworkInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;

        LOG_STATUS_REPORT_STRING_MINOR(
              TASKID_Minor_Next_Failed
            , L"[SRV] Error QI'ing for IClusCfgNetworkInfo on network object at index %d when filling output array."
            , idxError
            , hr
            );

        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Reset( void )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    m_idxEnumNext = 0;

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Clone(
    IEnumClusCfgNetworks ** ppEnumNetworksOut
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    if ( ppEnumNetworksOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_Networks, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedNetworks )
    {
        hr = THR( HrGetNetworks() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    *pnCountOut = m_cNetworks;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrInit

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::HrGetNetworks
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrGetNetworks( void )
{
    TraceFunc( "" );

    HRESULT                 hr = S_FALSE;
    BSTR                    bstrQuery           = NULL;
    BSTR                    bstrAdapterQuery    = NULL;
    IWbemClassObject      * piwcoNetwork        = NULL;
    IWbemClassObject      * pAdapterInfo        = NULL;
    IEnumWbemClassObject  * piewcoNetworks      = NULL;
    INetConnectionManager * pNetConManager      = NULL;
    IEnumNetConnection    * pEnumNetCon         = NULL;
    INetConnection        * pNetConnection      = NULL;
    NETCON_PROPERTIES     * pProps              = NULL;
    ULONG                   cRecordsReturned;
    VARIANT                 varConnectionStatus;
    VARIANT                 varConnectionID;
    VARIANT                 varIndex;
    VARIANT                 varDHCPEnabled;
    DWORD                   sc;
    DWORD                   dwState;
    DWORD                   cNumConnectionsReturned;
    HRESULT                 hrTemp;
    CLSID                   clsidMajorId;
    CLSID                   clsidMinorId;
    BSTR                    bstrWQL = NULL;

    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    sc = TW32( GetNodeClusterState( NULL, &dwState ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( dwState == ClusterStateRunning )
    {
        hr = THR( HrLoadClusterNetworks() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    VariantInit( &varConnectionStatus );
    VariantInit( &varConnectionID );
    VariantInit( &varIndex );
    VariantInit( &varDHCPEnabled );

    //
    // Instantiate a connection manager object to enum the connections
    //
    hr = THR ( CoCreateInstance(
                     CLSID_ConnectionManager
                   , NULL
                   , CLSCTX_ALL
                   , IID_INetConnectionManager
                   , reinterpret_cast< LPVOID * >( &pNetConManager )
                   )
             );

    if ( FAILED( hr ) || ( pNetConManager == NULL ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_CoCreate_NetConnection_Manager_Failed
                , IDS_ERROR_ENUM_NETWORK_CONNECTIONS_FAILED
                , IDS_ERROR_ENUM_NETWORK_CONNECTIONS_FAILED_REF
                , hr
                );
        goto Cleanup;
    }

    //
    // Enumerate the network connections
    //
    hr = THR( pNetConManager->EnumConnections( NCME_DEFAULT, &pEnumNetCon ) );
    if ( ( FAILED( hr ) ) || ( pEnumNetCon == NULL ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Enumerate_Network_Connections_Failed
                , IDS_ERROR_ENUM_NETWORK_CONNECTIONS_FAILED
                , IDS_ERROR_ENUM_NETWORK_CONNECTIONS_FAILED_REF
                , hr
                );
        goto Cleanup;
    } // if:

    hr = pEnumNetCon->Reset();
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Reset_Network_Connections_Enum_Failed
                , IDS_ERROR_ENUM_NETWORK_CONNECTIONS_FAILED
                , IDS_ERROR_ENUM_NETWORK_CONNECTIONS_FAILED_REF
                , hr
                );
        goto Cleanup;
    }

    //
    // Loop through the networks and skip inappropriate networks and form the network array
    //
    for ( ; ; )
    {
        //
        // There are several "continue"s in this loop, so lets make sure we clean up before we start a new loop
        //
        if ( pNetConnection != NULL )
        {
            pNetConnection->Release();
            pNetConnection = NULL;
        } // if:

        if ( piewcoNetworks != NULL )
        {
            piewcoNetworks->Release();
            piewcoNetworks = NULL;
        } // if:

        if ( piwcoNetwork != NULL )
        {
            piwcoNetwork->Release();
            piwcoNetwork = NULL;
        } // if:

        if ( pAdapterInfo != NULL )
        {
            pAdapterInfo->Release();
            pAdapterInfo = NULL;
        } // if:

        //
        // Free network connection properties
        //
        NcFreeNetconProperties( pProps );
        pProps = NULL;

        hr = STHR( pEnumNetCon->Next( 1, &pNetConnection, &cNumConnectionsReturned ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
        else if ( ( hr == S_FALSE ) && ( cNumConnectionsReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:

        Assert( pNetConnection != NULL );

        hr = THR( pNetConnection->GetProperties( &pProps ) );
        if ( ( FAILED( hr ) ) || ( pProps == NULL ) )
        {
            goto Cleanup;
        } // if:

        //
        // Create an ID for this particular network connection. We will use this ID later if there are issues with
        // this network connection.
        //
        hrTemp = THR( CoCreateGuid( &clsidMajorId ) );
        if ( FAILED( hrTemp ) )
        {
            LogMsg( L"[SRV] Could not create a guid for a network connection." );
            clsidMajorId = IID_NULL;
        } // if:

        //
        // Get the NetworkAdapter WMI object with the specified NetConnectionID
        //

        hr = HrFormatStringIntoBSTR( L"Select * from Win32_NetworkAdapter where NetConnectionID='%1!ws!'", &bstrQuery, pProps->pszwName );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        // We are executing a query which we assume will find 1 matching record since NetConnectionID is a unique value
        //
        hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &piewcoNetworks ) );
        if ( FAILED( hr ) )
        {
            STATUS_REPORT_STRING(
                  TASKID_Major_Find_Devices
                , clsidMajorId
                , IDS_INFO_NETWORK_CONNECTION_CONCERN
                , pProps->pszwName
                , hr
                );
            STATUS_REPORT_STRING_REF(
                   clsidMajorId
                 , TASKID_Minor_WMI_NetworkAdapter_Qry_Failed
                 , IDS_ERROR_WMI_NETWORKADAPTER_QRY_FAILED
                 , pProps->pszwName
                 , IDS_ERROR_WMI_NETWORKADAPTER_QRY_FAILED_REF
                 , hr
                );
            goto Cleanup;
        } // if:

        //
        // Get the network returned into piwcoNetwork
        //
        hr = THR( piewcoNetworks->Next( WBEM_INFINITE, 1, &piwcoNetwork, &cRecordsReturned ) );
        if ( FAILED( hr ) )
        {
            STATUS_REPORT_STRING(
                  TASKID_Major_Find_Devices
                , clsidMajorId
                , IDS_INFO_NETWORK_CONNECTION_CONCERN
                , pProps->pszwName
                , hr
                );
            STATUS_REPORT_STRING_REF(
                   clsidMajorId
                , TASKID_Minor_WQL_Network_Qry_Next_Failed
                , IDS_ERROR_WQL_QRY_NEXT_FAILED
                , bstrQuery
                , IDS_ERROR_WQL_QRY_NEXT_FAILED_REF
                , hr
                );
            goto Cleanup;
        } // if:
        else if ( hr == S_FALSE )
        {
            TraceSysFreeString( bstrQuery );
            bstrQuery = NULL;

            hr = S_OK;
            continue;
        }

        TraceSysFreeString( bstrQuery );
        bstrQuery = NULL;

        //
        //  Get the NetConnectionID.  Only "real" hardware adapters will have this as a non-NULL property.
        //
        //  TODO:   31-OCT-2001 Ozano & GalenB
        //
        //  Do we really need this piece of code after we start looping using INetConnection
        //
        hr = HrGetWMIProperty( piwcoNetwork, L"NetConnectionID", VT_BSTR, &varConnectionID );
        if ( ( hr == E_PROPTYPEMISMATCH ) && ( varConnectionID.vt == VT_NULL ) )
        {
            hr = S_OK;      // don't want a yellow bang in the UI

            STATUS_REPORT_REF(
                      TASKID_Major_Find_Devices
                    , TASKID_Minor_Not_Managed_Networks
                    , IDS_INFO_NOT_MANAGED_NETWORKS
                    , IDS_INFO_NOT_MANAGED_NETWORKS_REF
                    , hr
                    );

            hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
            if ( FAILED( hrTemp ) )
            {
                LogMsg( L"[SRV] Could not create a guid for a not connected network minor task ID" );
                clsidMinorId = IID_NULL;
            } // if:

            STATUS_REPORT_STRING_REF(
                      TASKID_Minor_Not_Managed_Networks
                    , clsidMinorId
                    , IDS_WARN_NETWORK_SKIPPED
                    , pProps->pszwName
                    , IDS_WARN_NETWORK_SKIPPED_REF
                    , hr
                    );

            continue;       // skip this adapter
        } // if:
        else if ( FAILED( hr ) )
        {
            THR( hr );
            goto Cleanup;
        } // else if:

        //
        //  Check the connection status of this adapter and skip it if it is not connected.
        //
        hr = THR( HrGetWMIProperty( piwcoNetwork, L"NetConnectionStatus", VT_I4, &varConnectionStatus ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  If the network adapter is not connected then skip it.
        //
        if ( varConnectionStatus.iVal != STATUS_CONNECTED )
        {
            hr = S_OK;      // don't want a yellow bang in the UI

            STATUS_REPORT_REF(
                      TASKID_Major_Find_Devices
                    , TASKID_Minor_Not_Managed_Networks
                    , IDS_INFO_NOT_MANAGED_NETWORKS
                    , IDS_INFO_NOT_MANAGED_NETWORKS_REF
                    , hr
                    );

            hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
            if ( FAILED( hrTemp ) )
            {
                LogMsg( L"[SRV] Could not create a guid for a not connected network minor task ID" );
                clsidMinorId = IID_NULL;
            } // if:

            STATUS_REPORT_STRING2_REF(
                  TASKID_Minor_Not_Managed_Networks
                , clsidMinorId
                , IDS_WARN_NETWORK_NOT_CONNECTED
                , varConnectionID.bstrVal
                , varConnectionStatus.iVal
                , IDS_WARN_NETWORK_NOT_CONNECTED_REF
                , hr
                );

            continue;
        } // if:

        //
        // If it is a bridged network connection, display a warning
        //

        if ( pProps->MediaType == NCM_BRIDGE )
        {
            // This is the virtual bridged network connection
            STATUS_REPORT_STRING(
                  TASKID_Major_Find_Devices
                , clsidMajorId
                , IDS_INFO_NETWORK_CONNECTION_CONCERN
                , pProps->pszwName
                , hr
                );
            hrTemp = S_FALSE;
            STATUS_REPORT_STRING_REF(
                  clsidMajorId
                , TASKID_Minor_Bridged_Network
                , IDS_WARN_NETWORK_BRIDGE_ENABLED
                , pProps->pszwName
                , IDS_WARN_NETWORK_BRIDGE_ENABLED_REF
                , hrTemp
                );
        } // if: ( pProps->MediaType == NCM_BRIDGE )
        else if ( ( pProps->dwCharacter & NCCF_BRIDGED ) == NCCF_BRIDGED )
        {
            // This is one of the end points of a bridged network connection
            STATUS_REPORT_STRING(
                  TASKID_Major_Find_Devices
                , clsidMajorId
                , IDS_INFO_NETWORK_CONNECTION_CONCERN
                , pProps->pszwName
                , hr
                );

            hrTemp = S_FALSE;

            STATUS_REPORT_STRING_REF(
                  clsidMajorId
                , TASKID_Minor_Bridged_Network
                , IDS_WARN_NETWORK_BRIDGE_ENDPOINT
                , pProps->pszwName
                , IDS_WARN_NETWORK_BRIDGE_ENDPOINT_REF
                , hrTemp
                );
            continue; // skip end point connections since they do not have an IP address
        } // else if: ( ( pProps->dwCharacter & NCCF_BRIDGED ) == NCCF_BRIDGED )

        //
        // If it is a firewall enabled network connection, display a warning
        //
        if ( ( pProps->dwCharacter & NCCF_FIREWALLED ) == NCCF_FIREWALLED )
        {
            STATUS_REPORT_STRING(
                  TASKID_Major_Find_Devices
                , clsidMajorId
                , IDS_INFO_NETWORK_CONNECTION_CONCERN
                , pProps->pszwName
                , hr
                );

            hrTemp = S_FALSE;

            STATUS_REPORT_STRING_REF(
                  clsidMajorId
                , TASKID_Minor_Network_Firewall_Enabled
                , IDS_WARN_NETWORK_FIREWALL_ENABLED
                , pProps->pszwName
                , IDS_WARN_NETWORK_FIREWALL_ENABLED_REF
                , hrTemp
                );

        } // if: ( ( pProps->dwCharacter & NCCF_FIREWALLED ) == NCCF_FIREWALLED )

        //
        //  At this stage we should only have real LAN adapters.
        //

        Assert( pProps->MediaType == NCM_LAN );

        //
        // Get the Index No. of this adapter
        //
        hr = THR( HrGetWMIProperty( piwcoNetwork, L"Index", VT_I4, &varIndex ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        // Get the associated NetworkAdapterConfiguration WMI object. First, format the Query string
        //
        hr = HrFormatStringIntoBSTR( L"Win32_NetworkAdapterConfiguration.Index=%1!u!", &bstrAdapterQuery, varIndex.iVal );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        // Then, get the Object
        //
        hr = THR( m_pIWbemServices->GetObject(
                              bstrAdapterQuery
                            , WBEM_FLAG_RETURN_WBEM_COMPLETE
                            , NULL
                            , &pAdapterInfo
                            , NULL
                            ) );
        if ( FAILED ( hr ) )
        {
            goto Cleanup;
        } // if:

        TraceSysFreeString( bstrAdapterQuery );
        bstrAdapterQuery = NULL;

        //
        // Find out if this adapter is DHCP enabled. If it is, send out a warning.
        //
        hr = THR( HrGetWMIProperty( pAdapterInfo, L"DHCPEnabled", VT_BOOL, &varDHCPEnabled ) );
        if ( FAILED ( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( ( varDHCPEnabled.vt == VT_BOOL ) && ( varDHCPEnabled.boolVal == VARIANT_TRUE ) )
        {
            STATUS_REPORT_STRING(
                  TASKID_Major_Find_Devices
                , clsidMajorId
                , IDS_INFO_NETWORK_CONNECTION_CONCERN
                , pProps->pszwName
                , hr
                );
            hr = S_FALSE;
            STATUS_REPORT_STRING_REF(
                  clsidMajorId
                , TASKID_Minor_HrGetNetworks_DHCP_Enabled
                , IDS_WARN_DHCP_ENABLED
                , varConnectionID.bstrVal
                , IDS_WARN_DHCP_ENABLED_REF
                , hr
                );
            if ( FAILED ( hr ) )
            {
                goto Cleanup;
            }
        } // if:

        hr = STHR( HrCreateAndAddNetworkToArray( piwcoNetwork, &clsidMajorId, pProps->pszwName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // for:

    //
    //  Check for any NLB network adapters and if there is one then send a warning status report.
    //
    hr = THR( HrCheckForNLBS() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_idxEnumNext = 0;
    m_fLoadedNetworks = TRUE;

    goto Cleanup;

Cleanup:

    VariantClear( &varConnectionStatus );
    VariantClear( &varConnectionID );
    VariantClear( &varIndex );
    VariantClear( &varDHCPEnabled );

    TraceSysFreeString( bstrWQL );
    TraceSysFreeString( bstrQuery );
    TraceSysFreeString( bstrAdapterQuery );
    NcFreeNetconProperties( pProps );

    if ( piwcoNetwork != NULL )
    {
        piwcoNetwork->Release();
    } // if:

    if ( piewcoNetworks != NULL )
    {
        piewcoNetworks->Release();
    } // if:

    if ( pAdapterInfo != NULL )
    {
        pAdapterInfo->Release();
    } // if:

    if ( pNetConnection != NULL )
    {
        pNetConnection->Release();
    } // if:

    if ( pNetConManager != NULL )
    {
        pNetConManager->Release();
    } // if:

    if ( pEnumNetCon != NULL )
    {
        pEnumNetCon->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrGetNetworks

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks:HrAddNetworkToArray
//
//  Description:
//      Add the passed in Network to the array of punks that holds the Networks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrAddNetworkToArray( IUnknown * punkIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgNetworks, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrAddNetworkToArray, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    m_prgNetworks = prgpunks;

    (*m_prgNetworks)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cNetworks += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrAddNetworkToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::HrCreateAndAddNetworkToArray
//
//  Description:
//      Create a IClusCfgStorageDevice object and add the passed in Network to
//      the array of punks that holds the Networks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrCreateAndAddNetworkToArray(
      IWbemClassObject * pNetworkIn
    , const CLSID *      pclsidMajorIdIn
    , LPCWSTR            pwszNetworkNameIn
    )
{
    TraceFunc( "" );
    Assert( pNetworkIn != NULL );
    Assert( pclsidMajorIdIn != NULL );
    Assert( pwszNetworkNameIn != NULL );

    HRESULT                 hr = S_FALSE;
    IUnknown *              punk = NULL;
    IClusCfgSetWbemObject * piccswo = NULL;
    bool                    fRetainObject = true;

    hr = THR( CClusCfgNetworkInfo::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CClusCfgNetworkInfo", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ))
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgSetWbemObject, &piccswo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( piccswo->SetWbemObject( pNetworkIn, &fRetainObject ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( ( hr == S_OK ) && ( fRetainObject ) )
    {
        hr = STHR( HrIsThisNetworkUnique( punk, pNetworkIn, pclsidMajorIdIn, pwszNetworkNameIn ) );
        if ( hr == S_OK )
        {
            hr = THR( HrAddNetworkToArray( punk ) );
        } // if:
    } // if:

Cleanup:

    if ( piccswo != NULL )
    {
        piccswo->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrCreateAndAddNetworkToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks:HrIsThisNetworkUnique
//
//  Description:
//      Does a network for this IP Address and subnet already exist?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      S_FALSE
//          This network is a duplicate.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrIsThisNetworkUnique(
      IUnknown *           punkIn
    , IWbemClassObject * pNetworkIn
    , const CLSID *      pclsidMajorIdIn
    , LPCWSTR            pwszNetworkNameIn
    )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );
    Assert( pNetworkIn != NULL );
    Assert( pclsidMajorIdIn != NULL );
    Assert( pwszNetworkNameIn != NULL );

    HRESULT                         hr = S_OK;
    ULONG                           idx;
    IClusCfgNetworkInfo *           piccni = NULL;
    IClusCfgNetworkInfo *           piccniSource = NULL;
    BSTR                            bstr = NULL;
    BSTR                            bstrSource = NULL;
    BSTR                            bstrAdapterName = NULL;
    BSTR                            bstrConnectionName = NULL;
    BSTR                            bstrMessage = NULL;
    VARIANT                         var;
    IClusCfgClusterNetworkInfo *    picccni = NULL;
    IClusCfgClusterNetworkInfo *    picccniSource = NULL;

    VariantInit( &var );

    hr = THR( punkIn->TypeSafeQI( IClusCfgNetworkInfo, &piccniSource ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccniSource->TypeSafeQI( IClusCfgClusterNetworkInfo, &picccniSource ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( picccniSource->HrGetNetUID( &bstrSource, pclsidMajorIdIn, pwszNetworkNameIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( ( hr == S_FALSE ) && ( bstrSource == NULL ) )
    {
        LOG_STATUS_REPORT_STRING( L"Unable to get a UID for '%1!ws!'.", pwszNetworkNameIn, hr );
        goto Cleanup;
    } // if:

    TraceMemoryAddBSTR( bstrSource );

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        hr = THR( ((*m_prgNetworks)[ idx ])->TypeSafeQI( IClusCfgNetworkInfo, &piccni ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( piccni->GetUID( &bstr ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( ( hr == S_FALSE ) && ( bstr != NULL ) )
        {
            BSTR bstrTemp = NULL;

            THR( piccni->GetName( &bstrTemp ) );
            LOG_STATUS_REPORT_STRING( L" Unable to get a UID for '%1!ws!'.", ( bstrTemp != NULL ) ? bstrTemp : L"<unknown>", hr );
            SysFreeString( bstrTemp );
            goto Cleanup;
        } // if:

        TraceMemoryAddBSTR( bstr );

        if ( NBSTRCompareCase( bstr, bstrSource ) == 0 )
        {
            hr = THR( piccni->TypeSafeQI( IClusCfgClusterNetworkInfo, &picccni ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = STHR( picccni->HrIsClusterNetwork() );
            picccni->Release();
            picccni = NULL;
            //
            //  If the network in the enum was already a cluster network then we do not need
            //  to warn the user.
            //
            if ( hr == S_OK )
            {
                hr = S_FALSE;       // tell the caller that this is a duplicate network
            } // if:
            else if ( hr == S_FALSE )       // warn the user
            {
                HRESULT hrTemp;
                CLSID   clsidMinorId;

                hr = THR( HrGetWMIProperty( pNetworkIn, L"Name", VT_BSTR, &var ) );
                if ( FAILED( hr ) )
                {
                    bstrAdapterName = NULL;
                } // if:
                else
                {
                    bstrAdapterName = TraceSysAllocString( var.bstrVal );
                } // else:

                VariantClear( &var );

                hr = THR( HrGetWMIProperty( pNetworkIn, L"NetConnectionID", VT_BSTR, &var ) );
                if ( FAILED( hr ) )
                {
                    bstrConnectionName = NULL;
                } // if:
                else
                {
                    bstrConnectionName = TraceSysAllocString( var.bstrVal );
                } // else:

                hr = S_OK;      // don't want a yellow bang in the UI

                STATUS_REPORT_REF(
                          TASKID_Major_Find_Devices
                        , TASKID_Minor_Not_Managed_Networks
                        , IDS_INFO_NOT_MANAGED_NETWORKS
                        , IDS_INFO_NOT_MANAGED_NETWORKS_REF
                        , hr
                        );

                hr = THR( HrFormatMessageIntoBSTR(
                                      g_hInstance
                                    , IDS_ERROR_WMI_NETWORKADAPTER_DUPE_FOUND
                                    , &bstrMessage
                                    , bstrAdapterName != NULL ? bstrAdapterName : L"Unknown"
                                    , bstrConnectionName != NULL ? bstrConnectionName : L"Unknown"
                                    ) );
                if ( FAILED( hr ) )
                {
                    bstrMessage = NULL;
                    hr = S_OK;
                } // if:

                hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
                if ( FAILED( hrTemp ) )
                {
                    LogMsg( L"[SRV] Could not create a guid for a duplicate network minor task ID" );
                    clsidMinorId = IID_NULL;
                } // if:

                hrTemp = THR( HrSendStatusReport(
                                  m_picccCallback
                                , TASKID_Minor_Not_Managed_Networks
                                , clsidMinorId
                                , 0
                                , 1
                                , 1
                                , hr
                                , bstrMessage != NULL ? bstrMessage : L"An adapter with a duplicate IP address and subnet was found."
                                , IDS_ERROR_WMI_NETWORKADAPTER_DUPE_FOUND_REF
                                ) );
                if ( FAILED( hrTemp ) )
                {
                    hr = hrTemp;
                    goto Cleanup;
                } // if:

                // Indicate to the caller that this network is not unique.
                hr = S_FALSE;

            } // else if:

            break;
        } // if: ( NBSTRCompareCase( bstr, bstrSource ) == 0 )

        piccni->Release();
        piccni = NULL;

        TraceSysFreeString( bstr );
        bstr = NULL;
    } // for:

Cleanup:

    if ( picccniSource != NULL )
    {
        picccniSource->Release();
    } // if:

    if ( piccniSource != NULL )
    {
        piccniSource->Release();
    } // if:

    if ( picccni != NULL )
    {
        picccni->Release();
    } // if:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    VariantClear( &var );

    TraceSysFreeString( bstrAdapterName );
    TraceSysFreeString( bstrConnectionName );
    TraceSysFreeString( bstrMessage );
    TraceSysFreeString( bstrSource );
    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrIsThisNetworkUnique


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks:HrCheckForNLBS
//
//  Description:
//      Are there any soft NLBS adapters? If there is then send a warning status report.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK    - The operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrCheckForNLBS( void )
{
    TraceFunc( "" );

    HRESULT                 hr                  = S_OK;
    IWbemClassObject      * piwcoNetwork        = NULL;
    IEnumWbemClassObject  * piewcoNetworks      = NULL;
    BSTR                    bstrAdapterName     = NULL;
    BSTR                    bstrWQL             = NULL;
    BSTR                    bstrQuery           = NULL;
    ULONG                   cRecordsReturned;

    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    //
    // Load the NLBS Soft adapter name.
    //
    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_NLBS_SOFT_ADAPTER_NAME, &bstrAdapterName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Form the WMI query string.
    //
    hr = HrFormatStringIntoBSTR( L"Select * from Win32_NetworkAdapter where Name='%1!ws!'", &bstrQuery, bstrAdapterName );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Execute this query and see if there are any NLB network adapters.
    //
    hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &piewcoNetworks ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_STRING_REF(
              TASKID_Major_Find_Devices
            , TASKID_Minor_WMI_NetworkAdapter_Qry_Failed
            , IDS_ERROR_WMI_NETWORKADAPTER_QRY_FAILED
            , bstrQuery
            , IDS_ERROR_WMI_NETWORKADAPTER_QRY_FAILED_REF
            , hr
        );
        goto Cleanup;
    } // if:

    //
    // Loop through the adapters returned. Actually we break out of the loop after the first pass.
    // The "for" loop is for future use in case we ever want to loop through every individual record returned.
    //
    for ( ; ; )
    {
        hr = piewcoNetworks->Next( WBEM_INFINITE, 1, &piwcoNetwork, &cRecordsReturned );
        if ( ( hr == S_OK ) && ( cRecordsReturned == 1 ) )
        {
            //
            // NLB network adapter was found.
            // Send a warning status report and break out of the loop.
            //
            STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Warning_NLBS_Detected
                , IDS_WARN_NLBS_DETECTED
                , IDS_WARN_NLBS_DETECTED_REF
                , S_FALSE // Display warning in UI
                );
            break;
        } // if: NLB adapter found
        else if ( ( hr == S_FALSE ) && ( cRecordsReturned == 0 ) )
        {
            //
            // There were no NLB adapters found.
            //
            hr = S_OK;
            break;
        } // else if: no NLB adapters found
        else
        {
            //
            // An error occurred.
            //
            STATUS_REPORT_STRING_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_WQL_Network_Qry_Next_Failed
                , IDS_ERROR_WQL_QRY_NEXT_FAILED
                , bstrQuery
                , IDS_ERROR_WQL_QRY_NEXT_FAILED_REF
                , hr
                );
            goto Cleanup;
        } // else:
    } // for ever

Cleanup:

    TraceSysFreeString( bstrAdapterName );
    TraceSysFreeString( bstrWQL );
    TraceSysFreeString( bstrQuery );

    if ( piwcoNetwork != NULL )
    {
        piwcoNetwork->Release();
    } // if:

    if ( piewcoNetworks != NULL )
    {
        piewcoNetworks->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrCheckForNLBS


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks:HrLoadClusterNetworks
//
//  Description:
//      Load the cluster networks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrLoadClusterNetworks( void )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    HCLUSTER        hCluster = NULL;
    HCLUSENUM       hEnum = NULL;
    DWORD           sc;
    DWORD           idx;
    DWORD           cchNetworkName = 64;
    DWORD           cchNetInterfaceName = 64;
    WCHAR *         pszNetworkName = NULL;
    WCHAR *         pszNetInterfaceName = NULL;
    BSTR            bstrNetInterfaceName = NULL;
    DWORD           dwType;
    HNETWORK        hNetwork = NULL;
    HNETINTERFACE   hNetInterface = NULL;
    BSTR            bstrLocalNetBIOSName = NULL;

    //
    //  Get netbios name for the GetClusterNetInterface clusapi call.
    //

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &bstrLocalNetBIOSName, TRUE ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"[SRV] Failed to get the local computer net bios name.", hr );
        goto Cleanup;
    } // if:
    
    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        sc = TW32( GetLastError() );
        goto MakeHr;
    } // if:

    hEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_NETWORK );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        goto MakeHr;
    } // if:

    pszNetworkName = new WCHAR [ cchNetworkName ];
    if ( pszNetworkName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    pszNetInterfaceName = new WCHAR [ cchNetInterfaceName ];
    if ( pszNetInterfaceName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    //
    // Enumerate all the network connections on this node.
    //

    for ( idx = 0; ; )
    {
        //
        // Get the next network name.
        //

        sc = ClusterEnum( hEnum, idx, &dwType, pszNetworkName, &cchNetworkName );
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            break;
        } // if:

        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszNetworkName;
            pszNetworkName = NULL;

            cchNetworkName++;
            pszNetworkName = new WCHAR [ cchNetworkName ];
            if ( pszNetworkName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            sc = ClusterEnum( hEnum, idx, &dwType, pszNetworkName, &cchNetworkName );
        } // if:

        if ( sc != ERROR_SUCCESS )
        {
            TW32( sc );
            goto MakeHr;
        } // if: ClusterEnum() failed.

        //
        // Get the network handle using the network name.
        //

        hNetwork = OpenClusterNetwork( hCluster, pszNetworkName );
        if ( hNetwork == NULL )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            LOG_STATUS_REPORT_STRING( L"[SRV] Cannot open cluster network \"%1!ws!\".", pszNetworkName, hr );
            goto Cleanup;
        } // if: OpenClusterNetwork() failed.

        //
        // Get the network interface name on this node for the 
        // current network name.
        //

        sc = GetClusterNetInterface(
                      hCluster
                    , bstrLocalNetBIOSName
                    , pszNetworkName
                    , pszNetInterfaceName
                    , &cchNetInterfaceName
                    );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszNetInterfaceName;
            pszNetInterfaceName = NULL;

            cchNetInterfaceName++;
            pszNetInterfaceName = new WCHAR [ cchNetInterfaceName ];
            if ( pszNetInterfaceName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            sc = GetClusterNetInterface(
                          hCluster
                        , bstrLocalNetBIOSName
                        , pszNetworkName
                        , pszNetInterfaceName
                        , &cchNetInterfaceName
                        );
        } // if: ( sc == ERROR_MORE_DATA )

        if ( ( sc != ERROR_SUCCESS ) && ( sc != ERROR_CLUSTER_NETINTERFACE_NOT_FOUND ) )
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
            LOG_STATUS_REPORT_STRING( L"[SRV] Error locating a network interface for cluster network \"%1!ws!\".", pszNetworkName, hr );
            goto Cleanup;
        } // if: GetClusterNetInterface() failed.
 
        if ( sc == ERROR_CLUSTER_NETINTERFACE_NOT_FOUND )
        {
            //
            // If we get ERROR_CLUSTER_NETINTERFACE_NOT_FOUND for
            // any reason then display a warning regarding this network 
            // interface on this node and find a valid (=enabled, working) 
            // network interface on another node.
            //

            hr = S_FALSE;
            STATUS_REPORT_STRING2_REF(
                      TASKID_Major_Find_Devices
                    , TASKID_Minor_Network_Interface_Not_Found
                    , IDS_WARN_NETWORK_INTERFACE_NOT_FOUND
                    , pszNetworkName
                    , bstrLocalNetBIOSName
                    , IDS_WARN_NETWORK_INTERFACE_NOT_FOUND_REF
                    , hr
                    );

           //
           // Find a valid network interface name of another node on this network.
           //

            hr = THR( HrFindNetInterface( hNetwork, &bstrNetInterfaceName ) );
            if ( FAILED( hr ) )
            {
                LOG_STATUS_REPORT_STRING( L"[SRV] Can not find a network interface for cluster network \"%1!ws!\".", pszNetworkName, hr );
                goto Cleanup;
            } // if: HrFindNetInterface failed.
        } // if: sc == ERROR_CLUSTER_NETINTERFACE_NOT_FOUND
        else
        {
            //
            // We have a network interface name on this node
            //
            
            bstrNetInterfaceName = TraceSysAllocString ( pszNetInterfaceName );
            if ( bstrNetInterfaceName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:
        } // else: sc == ERROR_SUCCESS

        Assert( bstrNetInterfaceName != NULL );
        
        //
        // Open the network interface handle using the network interface
        // name.
        //

        hNetInterface = OpenClusterNetInterface( hCluster, bstrNetInterfaceName );
        if ( hNetInterface == NULL )
        {
            //
            //  If we don't have network interface handle by now
            //  we'll log an error and goto cleanup.
            //

            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            LOG_STATUS_REPORT_STRING2( 
                      L"[SRV] Can not open the cluster network interface \"%1!ws!\" for cluster network \"%2!ws!\" on this node."
                    , pszNetInterfaceName
                    , pszNetworkName
                    , hr
                    );
            goto Cleanup;
        } // if: Could not open the network interface.
        else
        {
            hr = THR( HrLoadClusterNetwork( hNetwork, hNetInterface ) );
            if ( FAILED( hr ) )
            {
                LOG_STATUS_REPORT_STRING( L"[SRV] Can not load information for cluster network \"%1!ws!\".", pszNetworkName, hr );
                goto Cleanup;
            } // if:

            CloseClusterNetInterface( hNetInterface );
            hNetInterface = NULL;
        } // else: Could open the network interface.

        CloseClusterNetwork( hNetwork );
        hNetwork = NULL;

        idx++;
    } // for:

    Assert( hr == S_OK );
    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

Cleanup:

    LOG_STATUS_REPORT( L"[SRV] Completed loading the cluster networks.", hr );

    if ( hNetInterface != NULL )
    {
        CloseClusterNetInterface( hNetInterface );
    } // if:

    if ( hNetwork != NULL )
    {
        CloseClusterNetwork( hNetwork );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterCloseEnum( hEnum );
    } // if:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    delete [] pszNetworkName;

    delete [] pszNetInterfaceName;

    TraceSysFreeString( bstrNetInterfaceName );
    TraceSysFreeString( bstrLocalNetBIOSName );

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrLoadClusterNetworks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks:HrLoadClusterNetwork
//
//  Description:
//      Load the cluster network and put it into the array of networks.
//
//  Arguments:
//      hNetworkIn
//      hNetInterfaceIn
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrLoadClusterNetwork(
      HNETWORK      hNetworkIn
    , HNETINTERFACE hNetInterfaceIn
    )
{
    TraceFunc( "" );
    Assert( hNetworkIn != NULL );
    Assert( hNetInterfaceIn != NULL );

    HRESULT     hr;
    IUnknown *  punk = NULL;
    IUnknown *  punkCallback = NULL;

    hr = THR( m_picccCallback->TypeSafeQI( IUnknown, &punkCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Have to pass the Initialize interface arguments since new objects will
    //  be created when this call is made.
    //

    hr = THR( CClusCfgNetworkInfo::S_HrCreateInstance( hNetworkIn, hNetInterfaceIn, punkCallback, m_lcid, m_pIWbemServices, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  This is special -- do not initialize this again.
    //

    //hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    //if ( FAILED( hr ))
    //{
    //    goto Cleanup;
    //} // if:

    //hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    //if ( FAILED( hr ) )
    //{
    //    goto Cleanup;
    //} // if:

    hr = THR( HrAddNetworkToArray( punk ) );

    goto Cleanup;

Cleanup:

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrLoadClusterNetwork

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::HrFindNetInterface
//
//  Description:
//      Finds the first network interface name for the passed in network.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      HRESULT version of error ERROR_CLUSTER_NETINTERFACE_NOT_FOUND
//      or other HRESULTS
//          Failure.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrFindNetInterface(
      HNETWORK          hNetworkIn
    , BSTR *            pbstrNetInterfaceNameOut
    )
{
    TraceFunc( "" );
    Assert( hNetworkIn != NULL );
    Assert( pbstrNetInterfaceNameOut != NULL );

    HRESULT         hr = S_OK;
    DWORD           sc;
    HNETWORKENUM    hEnum = NULL;
    WCHAR *         pszNetInterfaceName = NULL;
    DWORD           cchNetInterfaceName = 64;
    DWORD           idx;
    DWORD           dwType;

    *pbstrNetInterfaceNameOut = NULL;
    
    //
    //  Create a netinterface enum for the passed in network.
    //

    hEnum = ClusterNetworkOpenEnum( hNetworkIn, CLUSTER_NETWORK_ENUM_NETINTERFACES );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LOG_STATUS_REPORT( L"[SRV] Can not open Cluster Network enumeration.", hr );
        goto Cleanup;
    } // if:

    pszNetInterfaceName = new WCHAR [ cchNetInterfaceName ];
    if ( pszNetInterfaceName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; )
    {
        sc = ClusterNetworkEnum( hEnum, idx, &dwType, pszNetInterfaceName, &cchNetInterfaceName );
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            break;
        } // if:

        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszNetInterfaceName;
            pszNetInterfaceName = NULL;

            cchNetInterfaceName++;
            pszNetInterfaceName = new WCHAR [ cchNetInterfaceName ];
            if ( pszNetInterfaceName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            sc = ClusterNetworkEnum( hEnum, idx, &dwType, pszNetInterfaceName, &cchNetInterfaceName );
        } // if:

        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
            LOG_STATUS_REPORT_STRING( L"[SRV] Failed to enumerate Network Interface \"%1!ws!\".", pszNetInterfaceName != NULL ? pszNetInterfaceName : L"<unknown>", hr );
            goto Cleanup;
       } // if: ( sc != ERROR_SUCCESS )
        
        //
        // Get the first enabled network interface for this network  
        // and break out of the for loop.
        //

        *pbstrNetInterfaceNameOut = TraceSysAllocString( pszNetInterfaceName );
        if ( *pbstrNetInterfaceNameOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:

        break;
        
    } // for:

    //
    // This function will either return S_OK or HRESULT version of error 
    // ERROR_CLUSTER_NETINTERFACE_NOT_FOUND at this point.
    //
    
    if (  *pbstrNetInterfaceNameOut == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_CLUSTER_NETINTERFACE_NOT_FOUND ) );
    }  // if:
    else
    {
        hr = S_OK;
    } // else:

    goto Cleanup;

Cleanup:

    LOG_STATUS_REPORT_STRING( L"[SRV] Completed searching for NetInterface \"%1!ws!\".", pszNetInterfaceName != NULL ? pszNetInterfaceName : L"<unknown>", hr );

    if ( hEnum != NULL )
    {
        ClusterNetworkCloseEnum( hEnum );
    } // if:

    delete [] pszNetInterfaceName;

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrFindNetInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumlocalquorum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumLocalQuorum.h
//
//  Description:
//      This file contains the declaration of the CEnumLocalQuorum class.
//
//      The class CEnumLocalQuorum is the enumeration of cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumLocalQuorum.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumLocalQuorum
//
//  Description:
//      The class CEnumLocalQuorum is the enumeration of cluster local
//      quorum devices.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumLocalQuorum
    : public IEnumClusCfgManagedResources
    , public IClusCfgInitialize
    , public CClusterUtils
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    BOOL                m_fEnumLoaded;
    IClusCfgCallback *  m_picccCallback;
    IUnknown *          ((*m_prgQuorums)[]);
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    DWORD               m_cQuorumCount;

    // Private constructors and destructors
    CEnumLocalQuorum( void );
    ~CEnumLocalQuorum( void );

    // Private copy constructor to prevent copying.
    CEnumLocalQuorum( const CEnumLocalQuorum & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumLocalQuorum & operator = ( const CEnumLocalQuorum & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrLoadResources( void );
    HRESULT HrAddResourceToArray( IUnknown * punkIn );
    HRESULT HrCreateDummyObject( void );

public:
    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );
    
    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

    //
    //  CClusterUtils
    //
    virtual HRESULT HrNodeResourceCallback( HCLUSTER hClusterIn, HRESOURCE hResourceIn );

}; //*** Class CEnumLocalQuorum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenummajoritynodeset.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      CEnumMajorityNodeSet.cpp
//
//  Description:
//      This file contains the definition of the CEnumMajorityNodeSet
//       class.
//
//      The class CEnumMajorityNodeSet is the enumeration of cluster
//      majority node set devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include <PropList.h>
#include "CEnumMajorityNodeSet.h"
#include "CMajorityNodeSet.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumMajorityNodeSet" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumMajorityNodeSet class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::S_HrCreateInstance
//
//  Description:
//      Create a CEnumMajorityNodeSet instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CEnumMajorityNodeSet *  pemns = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pemns = new CEnumMajorityNodeSet();
    if ( pemns == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pemns->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pemns->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumMajorityNodeSet::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pemns != NULL )
    {
        pemns->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  IUnknown *
//  CEnumMajorityNodeSet::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      IN  ICatRegister * picrIn
//          Used to register/unregister our CATID support.
//
//      IN  BOOL fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_EnumMajorityNodeSet, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::S_RegisterCatIDSupport


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet:HrNodeResourceCallback
//
//  Description:
//      Called by CClusterUtils::HrEnumNodeResources() when it finds a
//      resource for this node.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::HrNodeResourceCallback(
      HCLUSTER  hClusterIn
    , HRESOURCE hResourceIn
    )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    BOOL                            fIsQuorum;
    IUnknown *                      punk = NULL;
    IClusCfgManagedResourceInfo *   pcccmri = NULL;
    CClusPropList                   cplCommonRO;
    CLUSPROP_BUFFER_HELPER          cpbh;
    DWORD                           sc = ERROR_SUCCESS;
    CClusPropList                   cplPrivate;
    IClusCfgManagedResourceData *   piccmrd = NULL;

    hr = STHR( HrIsResourceOfType( hResourceIn, L"Majority Node Set" ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If this resource is not a majority node set then we simply want to
    //  skip it.
    //
    if ( hr == S_FALSE )
    {
        goto Cleanup;
    } // if:

    hr = STHR( HrIsCoreResource( hResourceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    fIsQuorum = ( hr == S_OK );

    hr = THR( CMajorityNodeSet::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pcccmri ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If a MNS resource is found, ie we get here, then the
    //  MNS resource exists and is managed by default by
    //  the cluster.
    //

    hr = THR( pcccmri->SetManagedByDefault( TRUE ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If a MNS resource is found, ie we get here, then the
    //  MNS resource exists and is in the cluster.
    //

    hr = THR( pcccmri->SetManaged( TRUE ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcccmri->SetQuorumResource( fIsQuorum ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Get the name of this resource.
    //

    sc = TW32( cplCommonRO.ScGetResourceProperties( hResourceIn, CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    sc = TW32( cplCommonRO.ScMoveToPropertyByName( L"Name" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    cpbh = cplCommonRO.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    hr = THR( pcccmri->SetName( cpbh.pStringValue->sz ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
/*
    //
    //  Only gather the private properties when MNS is the quorum resource.  The properties are needed
    //  later to validate that the nodes being added to the cluster can host this resource.
    //

    if ( fIsQuorum )
    {

        //
        //  Get the private properties of this resource and store them as private data.
        //

        sc = TW32( cplPrivate.ScGetResourceProperties( hResourceIn, CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:

        if ( cplPrivate.BIsListEmpty() )
        {
            hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_FOUND ) );
            STATUS_REPORT_REF(
                      TASKID_Major_Find_Devices
                    , TASKID_Minor_MNS_Missing_Private_Properties
                    , IDS_ERROR_MNS_MISSING_PRIVATE_PROPERTIES
                    , IDS_ERROR_MNS_MISSING_PRIVATE_PROPERTIES_REF
                    , hr
                    );

            goto Cleanup;
        } // if:

        hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceData, &piccmrd ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( piccmrd->SetResourcePrivateData( (const BYTE *) cplPrivate.Plist(), (DWORD) cplPrivate.CbPropList() ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:
*/
    hr = THR( HrAddResourceToArray( punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( piccmrd != NULL )
    {
        piccmrd->Release();
    } // if:

    if ( pcccmri != NULL )
    {
        pcccmri->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::HrNodeResourceCallback


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumMajorityNodeSet class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::CEnumMajorityNodeSet
//
//  Description:
//      Constructor of the CEnumMajorityNodeSet class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumMajorityNodeSet::CEnumMajorityNodeSet( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_prgQuorums == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( !m_fEnumLoaded );

    TraceFuncExit();

} //*** CEnumMajorityNodeSet::CEnumMajorityNodeSet


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::~CEnumMajorityNodeSet
//
//  Description:
//      Desstructor of the CEnumMajorityNodeSet class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumMajorityNodeSet::~CEnumMajorityNodeSet( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgQuorums)[ idx ] != NULL )
        {
            ((*m_prgQuorums)[ idx ])->Release();
        } // end if:
    } // for:

    TraceFree( m_prgQuorums );

    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumMajorityNodeSet::~CEnumMajorityNodeSet


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::HrInit( void )
{
    TraceFunc( "" );

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( S_OK );

} //*** CEnumMajorityNodeSet::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::HrLoadResources
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::HrLoadResources( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrLocalNetBIOSName = NULL;

    //
    //  Get netbios name for clusapi calls.
    //

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &bstrLocalNetBIOSName, TRUE ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:


    //
    //  If the cluster service is running then load any majority node set
    //  resources that might exist.
    //
    hr = STHR( HrIsClusterServiceRunning() );
    if ( hr == S_OK )
    {
        hr = THR( HrEnumNodeResources( bstrLocalNetBIOSName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  If this node doesn't own an instance of this resource then we need
        //  to create a dummy resource for MiddleTier analysis.
        //
        if ( m_idxNext == 0 )
        {
            LogMsg( L"[SRV] This node does not own a Majority Node Set resource.  Creating a dummy resource." );
            hr = THR( HrCreateDummyObject() );
        } // if:
    } // if:
    else if ( hr == S_FALSE )
    {
        //
        //  If cluster service isn't running then we need to create a dummy resource
        //  for MiddleTier analysis and for EvictCleanup.
        //
        LogMsg( L"[SRV] The cluster service is not running.  Creating a dummy Majority Node Set resource." );
        hr = THR( HrCreateDummyObject() );
    } // else if:

Cleanup:

    TraceSysFreeString( bstrLocalNetBIOSName );

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::HrLoadResources


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet:HrAddResourceToArray
//
//  Description:
//      Add the passed in majority node set to the array of punks that holds the
//      list of majority node sets.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::HrAddResourceToArray( IUnknown * punkIn )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgQuorums, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrAddResourceToArray, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    m_prgQuorums = prgpunks;

    (*m_prgQuorums)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cQuorumCount += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::HrAddResourceToArray


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::HrCreateDummyObject
//
//  Description:
//      Create a dummy object so the MiddleTier will be happy.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::HrCreateDummyObject( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  punk = NULL;

    hr = THR( CMajorityNodeSet::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddResourceToArray( punk ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::HrCreateDummyObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumMajorityNodeSet -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumMajorityNodeSet::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumMajorityNodeSet::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumMajorityNodeSet::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CEnumMajorityNodeSet::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IEnumClusCfgManagedResources * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgManagedResources ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
    } // else if: IEnumClusCfgManagedResources
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

     QIRETURN_IGNORESTDMARSHALLING1( hr, riidIn, IID_IClusCfgWbemServices );

} //*** CEnumMajorityNodeSet::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumMajorityNodeSet -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    punkCallbackIn
//    lcidIn
//
//  Return Value:
//      S_OK            - Success.
//      E_INVALIDARG    - Required input argument not specified.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Initialize(
      IUnknown *    punkCallbackIn
    , LCID          lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumMajorityNodeSet -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           cFetched = 0;
    IClusCfgManagedResourceInfo *   pccsdi;
    IUnknown *                      punk;
    ULONG                           ulStop;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_MajorityNodeSet, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = THR( HrLoadResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        m_fEnumLoaded = true;
    } // if:

    ulStop = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( hr = S_OK; ( cFetched < ulStop ) && ( m_idxEnumNext < m_idxNext ); m_idxEnumNext++ )
    {
        punk = (*m_prgQuorums)[ m_idxEnumNext ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccsdi ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            rgpManagedResourceInfoOut[ cFetched++ ] = pccsdi;
        } // if:
    } // for:

    if ( FAILED( hr ) )
    {
        m_idxEnumNext -= cFetched;

        while ( cFetched != 0 )
        {
            (rgpManagedResourceInfoOut[ --cFetched ])->Release();
        } // for:

        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    m_idxEnumNext = 0;

    HRETURN( S_OK );

} //*** CEnumMajorityNodeSet::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgStorageDevicesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_MajorityNodeSet, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = THR( HrLoadResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        m_fEnumLoaded = true;
    } // if:

    *pnCountOut = m_cQuorumCount;

Cleanup:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumunknownquorum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      CEnumUnknownQuorum.cpp
//
//  Description:
//      This file contains the definition of the CEnumUnknownQuorum
//       class.
//
//      The class CEnumUnknownQuorum is the enumeration of unknown cluster
//      majority node set devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-MAY-2001
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include <PropList.h>
#include "CEnumUnknownQuorum.h"
#include "CUnknownQuorum.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumUnknownQuorum" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumUnknownQuorum class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CEnumUnknownQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CEnumUnknownQuorum *    peuq = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    peuq = new CEnumUnknownQuorum();
    if ( peuq == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( peuq->HrInit( NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( peuq->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumUnknownQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( peuq != NULL )
    {
        peuq->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CEnumUnknownQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::S_HrCreateInstance(
      BSTR          bstrNameIn
    , BOOL          fMakeQuorumIn
    , IUnknown **   ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CEnumUnknownQuorum *    peuq = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    peuq = new CEnumUnknownQuorum();
    if ( peuq == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( peuq->HrInit( bstrNameIn, fMakeQuorumIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( peuq->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumUnknownQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( peuq != NULL )
    {
        peuq->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::S_HrCreateInstance

/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  IUnknown *
//  CEnumUnknownQuorum::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      IN  ICatRegister * picrIn
//          Used to register/unregister our CATID support.
//
//      IN  BOOL fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_EnumMajorityNodeSet, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::S_RegisterCatIDSupport
*/

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumUnknownQuorum class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::CEnumUnknownQuorum
//
//  Description:
//      Constructor of the CEnumUnknownQuorum class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumUnknownQuorum::CEnumUnknownQuorum( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_prgQuorums == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( !m_fEnumLoaded );
    Assert( !m_fDefaultDeviceToQuorum );
    Assert( m_bstrQuorumResourceName == NULL );

    TraceFuncExit();

} //*** CEnumUnknownQuorum::CEnumUnknownQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::~CEnumUnknownQuorum
//
//  Description:
//      Desstructor of the CEnumUnknownQuorum class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumUnknownQuorum::~CEnumUnknownQuorum( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgQuorums)[ idx ] != NULL )
        {
            ((*m_prgQuorums)[ idx ])->Release();
        } // end if:
    } // for:

    TraceFree( m_prgQuorums );

    TraceSysFreeString( m_bstrNodeName );
    TraceSysFreeString( m_bstrQuorumResourceName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumUnknownQuorum::~CEnumUnknownQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::HrInit( BSTR bstrNameIn, BOOL fMakeQuorumIn /* = FALSE */ )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    m_fDefaultDeviceToQuorum = fMakeQuorumIn;

    //
    //  Were we given a name?
    //
    if ( bstrNameIn != NULL )
    {
        m_bstrQuorumResourceName = TraceSysAllocString( bstrNameIn );
        if ( m_bstrQuorumResourceName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
        } // if:
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::HrInit


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum:HrAddResourceToArray
//
//  Description:
//      Add the passed in majority node set to the array of punks that holds the
//      list of majority node sets.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::HrAddResourceToArray( IUnknown * punkIn )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgQuorums, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrAddResourceToArray, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    m_prgQuorums = prgpunks;

    (*m_prgQuorums)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::HrAddResourceToArray


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::HrCreateDummyObject
//
//  Description:
//      Create a dummy object so the MiddleTier will be happy.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::HrCreateDummyObject( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  punk = NULL;

    hr = THR( CUnknownQuorum::S_HrCreateInstance(
                                      m_bstrQuorumResourceName
                                    , m_fDefaultDeviceToQuorum
                                    , &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddResourceToArray( punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_fEnumLoaded = true;

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::HrCreateDummyObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumUnknownQuorum -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumUnknownQuorum::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumUnknownQuorum::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumUnknownQuorum::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CEnumUnknownQuorum::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IEnumClusCfgManagedResources * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgManagedResources ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
    } // else if: IEnumClusCfgManagedResources
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING1( hr, riidIn, IID_IClusCfgWbemServices );

} //*** CEnumUnknownQuorum::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumUnknownQuorum -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    punkCallbackIn
//    lcidIn
//
//  Return Value:
//      S_OK            - Success.
//      E_INVALIDARG    - Required input argument not specified.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Initialize(
      IUnknown *    punkCallbackIn
    , LCID          lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumUnknownQuorum -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           cFetched = 0;
    IClusCfgManagedResourceInfo *   pccsdi;
    IUnknown *                      punk;
    ULONG                           ulStop;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_MajorityNodeSet, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = THR( HrCreateDummyObject() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    ulStop = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( hr = S_OK; ( cFetched < ulStop ) && ( m_idxEnumNext < m_idxNext ); m_idxEnumNext++ )
    {
        punk = (*m_prgQuorums)[ m_idxEnumNext ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccsdi ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            rgpManagedResourceInfoOut[ cFetched++ ] = pccsdi;
        } // if:
    } // for:

    if ( FAILED( hr ) )
    {
        m_idxEnumNext -= cFetched;

        while ( cFetched != 0 )
        {
            (rgpManagedResourceInfoOut[ --cFetched ])->Release();
        } // for:

        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    m_idxEnumNext = 0;

    HRETURN( S_OK );

} //*** CEnumUnknownQuorum::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgStorageDevicesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_MajorityNodeSet, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = THR( HrCreateDummyObject() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    Assert( m_idxNext == 1 );   // don't expect to ever have more than one.

    *pnCountOut = m_idxNext;

Cleanup:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumphysicaldisks.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CEnumPhysicalDisks.cpp
//
//  Description:
//      This file contains the definition of the CEnumPhysicalDisks
//       class.
//
//      The class CEnumPhysicalDisks is the enumeration of cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
//#include <setupapi.h>
//#include <winioctl.h>
#include "CEnumPhysicalDisks.h"
#include "CPhysicalDisk.h"
#include "CIndexedDisk.h"
#include <PropList.h>
#include <InsertionSort.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumPhysicalDisks" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::S_HrCreateInstance
//
//  Description:
//      Create a CEnumPhysicalDisks instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CEnumPhysicalDisks *    pepd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pepd = new CEnumPhysicalDisks();
    if ( pepd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pepd->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pepd->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumPhysicalDisks::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pepd != NULL )
    {
        pepd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  IUnknown *
//  CEnumPhysicalDisks::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      IN  ICatRegister * picrIn
//          Used to register/unregister our CATID support.
//
//      IN  BOOL fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_EnumPhysicalDisks, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::S_RegisterCatIDSupport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::CEnumPhysicalDisks
//
//  Description:
//      Constructor of the CEnumPhysicalDisks class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumPhysicalDisks::CEnumPhysicalDisks( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
    , m_fLoadedDevices( false )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_prgDisks == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( m_bstrBootDevice == NULL );
    Assert( m_bstrSystemDevice == NULL );
    Assert( m_bstrBootLogicalDisk == NULL );
    Assert( m_bstrSystemLogicalDisk == NULL );
    Assert( m_bstrSystemWMIDeviceID == NULL );
    Assert( m_cDiskCount == 0 );
    Assert( m_bstrCrashDumpLogicalDisk == NULL );

    TraceFuncExit();

} //*** CEnumPhysicalDisks::CEnumPhysicalDisks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::~CEnumPhysicalDisks
//
//  Description:
//      Desstructor of the CEnumPhysicalDisks class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumPhysicalDisks::~CEnumPhysicalDisks( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgDisks)[ idx ] != NULL )
        {
            ((*m_prgDisks)[ idx ])->Release();
        } // end if:
    } // for:

    TraceFree( m_prgDisks );

    TraceSysFreeString( m_bstrNodeName );
    TraceSysFreeString( m_bstrBootDevice );
    TraceSysFreeString( m_bstrSystemDevice );
    TraceSysFreeString( m_bstrBootLogicalDisk );
    TraceSysFreeString( m_bstrSystemLogicalDisk );
    TraceSysFreeString( m_bstrSystemWMIDeviceID );
    TraceSysFreeString( m_bstrCrashDumpLogicalDisk );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumPhysicalDisks::~CEnumPhysicalDisks


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks -- IUnknown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumPhysicalDisks::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    CRETURN( m_cRef );

} //*** CEnumPhysicalDisks::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumPhysicalDisks::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CEnumPhysicalDisks::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IEnumClusCfgManagedResources * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgManagedResources ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
    } // else if: IEnumClusCfgManagedResources
    else if ( IsEqualIID( riidIn, IID_IClusCfgWbemServices ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
    } // else if: IClusCfgWbemServices
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumPhysicalDisks::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Enum_PhysDisk, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

    hr = THR( HrGetSystemDevice( &m_bstrSystemDevice ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrConvertDeviceVolumeToLogicalDisk( m_bstrSystemDevice, &m_bstrSystemLogicalDisk ) );
    if ( HRESULT_CODE( hr ) == ERROR_INVALID_FUNCTION )
    {

        //
        //  system volume is an EFI volume on IA64 and won't have a logical disk.
        //

        hr = THR( HrConvertDeviceVolumeToWMIDeviceID( m_bstrSystemDevice, &m_bstrSystemWMIDeviceID ) );
        Assert( m_bstrSystemLogicalDisk == NULL );
        Assert( m_bstrSystemWMIDeviceID != NULL );
    } // if:

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetBootLogicalDisk( &m_bstrBootLogicalDisk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( HrIsLogicalDiskNTFS( m_bstrBootLogicalDisk ) );
    if ( hr == S_FALSE )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_Boot_Partition_Not_NTFS
                , IDS_WARN_BOOT_PARTITION_NOT_NTFS
                , IDS_WARN_BOOT_PARTITION_NOT_NTFS_REF
                , hr
                );
        hr = S_OK;
    } // if:

    hr = THR( HrGetCrashDumpLogicalDisk( &m_bstrCrashDumpLogicalDisk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    punkCallbackIn
//    lcidIn
//
//  Return Value:
//      S_OK            - Success.
//      E_INVALIDARG    - Required input argument not specified.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Initialize(
      IUnknown *    punkCallbackIn
    , LCID          lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName(
                      ComputerNameDnsHostname
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           cFetched = 0;
    IClusCfgManagedResourceInfo *   pccsdi;
    IUnknown *                      punk;
    ULONG                           ulStop;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_PhysDisk, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedDevices )
    {
        hr = THR( HrLoadEnum() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    ulStop = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( hr = S_OK; ( cFetched < ulStop ) && ( m_idxEnumNext < m_idxNext ); m_idxEnumNext++ )
    {
        punk = (*m_prgDisks)[ m_idxEnumNext ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccsdi ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            rgpManagedResourceInfoOut[ cFetched++ ] = pccsdi;
        } // if:
    } // for:

    if ( FAILED( hr ) )
    {
        m_idxEnumNext -= cFetched;

        while ( cFetched != 0 )
        {
            (rgpManagedResourceInfoOut[ --cFetched ])->Release();
        } // for:

        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    m_idxEnumNext = 0;

    HRETURN( S_OK );

} //*** CEnumPhysicalDisks::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgStorageDevicesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_PhysDisk, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Count
//
//  Description:
//      Return the count of items in the Enum.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedDevices )
    {
        hr = THR( HrLoadEnum() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    *pnCountOut = m_cDiskCount;

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrInit


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrGetDisks
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrGetDisks( void )
{
    TraceFunc( "" );

    HRESULT                 hr = S_FALSE;
    BSTR                    bstrClass;
    IEnumWbemClassObject *  pDisks = NULL;
    ULONG                   ulReturned;
    IWbemClassObject *      pDisk = NULL;

    bstrClass = TraceSysAllocString( L"Win32_DiskDrive" );
    if ( bstrClass == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrGetDisks, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );

        goto Cleanup;
    } // if:

    hr = THR( m_pIWbemServices->CreateInstanceEnum( bstrClass, WBEM_FLAG_SHALLOW, NULL, &pDisks ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_WMI_Phys_Disks_Qry_Failed
                , IDS_ERROR_WMI_PHYS_DISKS_QRY_FAILED
                , IDS_ERROR_WMI_PHYS_DISKS_QRY_FAILED_REF
                , hr
                );
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        hr = pDisks->Next( WBEM_INFINITE, 1, &pDisk, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            hr = STHR( HrLogDiskInfo( pDisk ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = STHR( IsDiskSCSI( pDisk ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                hr = STHR( HrCreateAndAddDiskToArray( pDisk ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:
            } // if:

            pDisk->Release();
            pDisk = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING_REF(
                      TASKID_Major_Find_Devices
                    , TASKID_Minor_WQL_Disk_Qry_Next_Failed
                    , IDS_ERROR_WQL_QRY_NEXT_FAILED
                    , bstrClass
                    , IDS_ERROR_WQL_QRY_NEXT_FAILED_REF
                    , hr
                    );
            goto Cleanup;
        } // else:
    } // for:

    m_idxEnumNext = 0;
    m_fLoadedDevices = TRUE;

    goto Cleanup;

Cleanup:

    if ( pDisk != NULL )
    {
        pDisk->Release();
    } // if:

    if ( pDisks != NULL )
    {
        pDisks->Release();
    } // if:

    TraceSysFreeString( bstrClass );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrGetDisks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrCreateAndAddDiskToArray
//
//  Description:
//      Create a IClusCfgStorageDevice object and add the passed in disk to
//      the array of punks that holds the disks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrCreateAndAddDiskToArray( IWbemClassObject * pDiskIn )
{
    TraceFunc( "" );

    HRESULT                 hr = S_FALSE;
    IUnknown *              punk = NULL;
    IClusCfgSetWbemObject * piccswo = NULL;
    bool                    fRetainObject = true;


    hr = THR( CPhysicalDisk::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if:

    punk = TraceInterface( L"CPhysicalDisk", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgSetWbemObject, &piccswo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( piccswo->SetWbemObject( pDiskIn, &fRetainObject ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( fRetainObject )
    {
        hr = THR( HrAddDiskToArray( punk ) );
    } // if:

Cleanup:

    if ( piccswo != NULL )
    {
        piccswo->Release();
    } // if:

    punk->Release();

Exit:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrCreateAndAddDiskToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrPruneSystemDisks
//
//  Description:
//      Prune all system disks from the list.  System disks are disks that
//      are booted, are running the OS, or have page files.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrPruneSystemDisks( void )
{
    TraceFunc( "" );
    Assert( m_bstrSystemLogicalDisk != NULL );
    Assert( m_bstrBootLogicalDisk != NULL );

    HRESULT                             hr = S_OK;
    ULONG                               idx;
    ULONG                               ulSCSIBus;
    ULONG                               ulSCSIPort;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    IUnknown *                          punk;
    ULONG                               cRemoved = 0;
    ULONG                               cTemp = 0;
    bool                                fSystemAndBootTheSame;
    bool                                fPruneBus = false;

    fSystemAndBootTheSame =   ( m_bstrSystemLogicalDisk != NULL )
                            ? ( m_bstrBootLogicalDisk[ 0 ] == m_bstrSystemLogicalDisk[ 0 ] )
                            : false;

    hr = STHR( HrIsSystemBusManaged() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If the system bus is not managed then we need to prune the disks on those buses
    //  that contain system, boot, and pagefile disks.
    //

    if ( hr == S_FALSE )
    {
        fPruneBus = true;
    } // if:

    //
    //  Prune the disks on the system buses.  If the system disks are IDE they won't
    //  be in the list.
    //

    //
    //  Find the boot disk(s).  Could be a volume with more than one physical disk.
    //

    for ( ; ; )
    {
        hr = STHR( HrFindDiskWithLogicalDisk( m_bstrBootLogicalDisk[ 0 ], &idx ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            //
            //  Should we prune the whole bus, or just the boot disk itself?
            //

            if ( fPruneBus )
            {
                hr = THR( HrGetSCSIInfo( idx, &ulSCSIBus, &ulSCSIPort ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Pruning_Boot_Disk_Bus, IDS_INFO_PRUNING_BOOTDISK_BUS, hr );
                hr = THR( HrPruneDisks(
                                  ulSCSIBus
                                , ulSCSIPort
                                , &TASKID_Minor_Pruning_Boot_Disk_Bus
                                , IDS_INFO_BOOTDISK_PRUNED
                                , IDS_INFO_BOOTDISK_PRUNED_REF
                                , &cTemp
                                ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                cRemoved += cTemp;
            } // if:
            else
            {
                RemoveDiskFromArray( idx );
                cRemoved++;
            } // else:

            continue;
        } // if:

        break;
    } // for:

    //
    //  Prune the system disk bus if it is not the same as the boot disk bus.
    //
    if ( !fSystemAndBootTheSame )
    {
        if ( m_bstrSystemLogicalDisk != NULL )
        {
            Assert( m_bstrSystemWMIDeviceID == NULL );
            hr = STHR( HrFindDiskWithLogicalDisk( m_bstrSystemLogicalDisk[ 0 ], &idx ) );
        } // if:
        else
        {
            Assert( m_bstrSystemLogicalDisk == NULL );
            hr = STHR( HrFindDiskWithWMIDeviceID( m_bstrSystemWMIDeviceID, &idx ) );
        } // else:

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            //
            //  Should we prune the whole bus, or just the system disk itself?
            //

            if ( fPruneBus )
            {
                hr = THR( HrGetSCSIInfo( idx, &ulSCSIBus, &ulSCSIPort ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Pruning_System_Disk_Bus, IDS_INFO_PRUNING_SYSTEMDISK_BUS, hr );
                hr = THR( HrPruneDisks(
                                  ulSCSIBus
                                , ulSCSIPort
                                , &TASKID_Minor_Pruning_System_Disk_Bus
                                , IDS_INFO_SYSTEMDISK_PRUNED
                                , IDS_INFO_SYSTEMDISK_PRUNED_REF
                                , &cTemp
                                ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                cRemoved += cTemp;
            } // if:
            else
            {
                RemoveDiskFromArray( idx );
                cRemoved++;
            } // else:
        } // if:
    } // if:

    //
    //  Now prune the busses that have page file disks on them.
    //

    hr = THR( HrPrunePageFileDiskBussess( fPruneBus, &cTemp ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    cRemoved += cTemp;

    //
    //  Now prune the bus that has a crash dump file disk.
    //

    hr = THR( HrPruneCrashDumpBus( fPruneBus, &cTemp ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    cRemoved += cTemp;

    //
    //  Now prune the off any remaining dynamic disks.
    //

    hr = THR( HrPruneDynamicDisks( &cTemp ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    cRemoved += cTemp;

    //
    //  Now prune the off any remaining GPT disks.
    //

    hr = THR( HrPruneGPTDisks( &cTemp ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    cRemoved += cTemp;

    //
    //  Last ditch effort to properly set the managed state of the remaining disks.
    //

    for ( idx = 0; ( cRemoved < m_idxNext ) && ( idx < m_idxNext ); idx++ )
    {
        punk = (*m_prgDisks)[ idx ];                                                        // don't ref
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
            if ( FAILED( hr ) )
            {
                LOG_STATUS_REPORT( L"Could not query for the IClusCfgPhysicalDiskProperties interface.", hr );
                goto Cleanup;
            } // if:

            //
            //  Give the disk a chance to figure out for itself if it should be managed.
            //

            hr = STHR( piccpdp->CanBeManaged() );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            piccpdp->Release();
            piccpdp = NULL;
        } // if:
    } // for:

    //
    //  Minor optimization.  If we removed all of the elements reset the enum next to 0.
    //

    if ( cRemoved == m_idxNext )
    {
        m_idxNext = 0;
    } // if:

    hr = S_OK;

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrPruneSystemDisks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::IsDiskSCSI
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Disk is SCSI.
//
//      S_FALSE
//          Disk is not SCSI.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::IsDiskSCSI( IWbemClassObject * pDiskIn )
{
    TraceFunc( "" );
    Assert( pDiskIn != NULL );

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"InterfaceType", VT_BSTR, &var ) );
    if ( SUCCEEDED( hr ) )
    {
        if ( ( NStringCchCompareCase( L"SCSI", RTL_NUMBER_OF( L"SCSI" ), var.bstrVal, SysStringLen( var.bstrVal ) + 1 ) == 0 ) )
        {
            hr = S_OK;
        } // if:
        else
        {
            hr = S_FALSE;
        } // else:
    } // if:

    VariantClear( &var );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::IsDiskSCSI


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrAddDiskToArray
//
//  Description:
//      Add the passed in disk to the array of punks that holds the disks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrAddDiskToArray( IUnknown * punkIn )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgDisks, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrAddDiskToArray, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
        goto Cleanup;
    } // if:

    m_prgDisks = prgpunks;

    (*m_prgDisks)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cDiskCount += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrAddDiskToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrFixupDisks
//
//  Description:
//      Tweak the disks to better reflect how they are managed by this node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrFixupDisks( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrLocalNetBIOSName = NULL;

    //
    //  Get netbios name for clusapi calls.
    //

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &bstrLocalNetBIOSName, TRUE ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:


    //
    //  If the cluster service is running then load any physical disk
    //  resources that we own.
    //

    hr = STHR( HrIsClusterServiceRunning() );
    if ( hr == S_OK )
    {
        hr = THR( HrEnumNodeResources( bstrLocalNetBIOSName ) );
    }
    else if ( hr == S_FALSE )
    {
        hr = S_OK;
    } // else:

Cleanup:

    TraceSysFreeString( bstrLocalNetBIOSName );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrFixupDisks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrNodeResourceCallback
//
//  Description:
//      Called by CClusterUtils::HrEnumNodeResources() when it finds a
//      resource for this node.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrNodeResourceCallback(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResourceIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CLUS_SCSI_ADDRESS       csa;
    DWORD                   dwSignature;
    BOOL                    fIsQuorum;
    BSTR                    bstrResourceName = NULL;

    hr = STHR( HrIsResourceOfType( hResourceIn, L"Physical Disk" ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If this resource is not a physical disk then we simply want to
    //  skip it.
    //

    if ( hr == S_FALSE )
    {
        goto Cleanup;
    } // if:

    hr = STHR( HrIsCoreResource( hResourceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    fIsQuorum = ( hr == S_OK );

    hr = THR( HrGetClusterDiskInfo( hClusterIn, hResourceIn, &csa, &dwSignature ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetClusterProperties( hResourceIn, &bstrResourceName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetThisDiskToBeManaged( csa.TargetId, csa.Lun, fIsQuorum, bstrResourceName, dwSignature ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    TraceSysFreeString( bstrResourceName );

    HRETURN( hr );


} //*** CEnumPhysicalDisks::HrNodeResourceCallback


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrGetClusterDiskInfo
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrGetClusterDiskInfo(
    HCLUSTER            hClusterIn,
    HRESOURCE           hResourceIn,
    CLUS_SCSI_ADDRESS * pcsaOut,
    DWORD *             pdwSignatureOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    CClusPropValueList      cpvl;
    CLUSPROP_BUFFER_HELPER  cbhValue = { NULL };

    sc = TW32( cpvl.ScGetResourceValueList( hResourceIn, CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    sc = TW32( cpvl.ScMoveToFirstValue() );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:


    for ( ; ; )
    {
        cbhValue = cpvl;

        switch ( cbhValue.pSyntax->dw )
        {
            case CLUSPROP_SYNTAX_PARTITION_INFO :
            {
                break;
            } // case: CLUSPROP_SYNTAX_PARTITION_INFO

            case CLUSPROP_SYNTAX_DISK_SIGNATURE :
            {
                *pdwSignatureOut = cbhValue.pDiskSignatureValue->dw;
                break;
            } // case: CLUSPROP_SYNTAX_DISK_SIGNATURE

            case CLUSPROP_SYNTAX_SCSI_ADDRESS :
            {
                pcsaOut->dw = cbhValue.pScsiAddressValue->dw;
                break;
            } // case: CLUSPROP_SYNTAXscSI_ADDRESS

            case CLUSPROP_SYNTAX_DISK_NUMBER :
            {
                break;
            } // case: CLUSPROP_SYNTAX_DISK_NUMBER

        } // switch:

        sc = cpvl.ScMoveToNextValue();
        if ( sc == ERROR_SUCCESS )
        {
            continue;
        } // if:

        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            break;
        } // if: error occurred moving to the next value

        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        goto Cleanup;
    } // for:

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrGetClusterDiskInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrSetThisDiskToBeManaged
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrSetThisDiskToBeManaged(
      ULONG ulSCSITidIn
    , ULONG ulSCSILunIn
    , BOOL  fIsQuorumIn
    , BSTR  bstrResourceNameIn
    , DWORD dwSignatureIn
    )
{
    TraceFunc( "" );

    HRESULT                             hr = S_OK;
    ULONG                               idx;
    IUnknown *                          punk = NULL;
    IClusCfgManagedResourceInfo *       piccmri = NULL;
    WCHAR                               sz[ 64 ];
    BSTR                                bstrUID = NULL;
    DWORD                               dwSignature;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;

    hr = THR( StringCchPrintfW( sz, ARRAYSIZE( sz ), L"SCSI Tid %ld, SCSI Lun %ld", ulSCSITidIn, ulSCSILunIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Find the disk that has the passes in TID and Lun and set it
    //  to be managed.
    //

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        punk = (*m_prgDisks)[ idx ];                                                        // don't ref
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &piccmri ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = THR( piccmri->GetUID( &bstrUID ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            TraceMemoryAddBSTR( bstrUID );

            if ( NStringCchCompareNoCase( bstrUID, SysStringLen( bstrUID ) + 1, sz, RTL_NUMBER_OF( sz ) ) == 0 )
            {
                hr = THR( piccmri->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                hr = THR( piccpdp->HrGetSignature( &dwSignature ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                hr = THR( piccpdp->HrSetFriendlyName( bstrResourceNameIn ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                piccpdp->Release();
                piccpdp = NULL;

                //
                //  May want to do more with this later...
                //

                Assert( dwSignatureIn == dwSignature );

                hr = THR( piccmri->SetManaged( TRUE ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                hr = THR( piccmri->SetQuorumResource( fIsQuorumIn ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                break;
            } // if:

            TraceSysFreeString( bstrUID );
            bstrUID = NULL;
            piccmri->Release();
            piccmri = NULL;
        } // if:
    } // for:

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    if ( piccmri != NULL )
    {
        piccmri->Release();
    } // if:

    TraceSysFreeString( bstrUID );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrSetThisDiskToBeManaged


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrFindDiskWithLogicalDisk
//
//  Description:
//      Find the disk with the passed in logical disk ID.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.  Found the disk.
//
//      S_FALSE
//          Success.  Did not find the disk.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrFindDiskWithLogicalDisk(
    WCHAR   cLogicalDiskIn,
    ULONG * pidxDiskOut
    )
{
    TraceFunc( "" );
    Assert( pidxDiskOut != NULL );

    HRESULT                             hr = S_OK;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    ULONG                               idx;
    bool                                fFoundIt = false;
    IUnknown *                          punk;

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        punk = (*m_prgDisks)[ idx ];                                                        // don't ref
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = STHR( piccpdp->IsThisLogicalDisk( cLogicalDiskIn ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                fFoundIt = true;
                break;
            } // if:

            piccpdp->Release();
            piccpdp = NULL;
        } // if:
    } // for:

    if ( !fFoundIt )
    {
        hr = S_FALSE;
    } // if:

    if ( pidxDiskOut != NULL )
    {
        *pidxDiskOut = idx;
    } // if:

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrFindDiskWithLogicalDisk


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrGetSCSIInfo
//
//  Description:
//      Get the SCSI info for the disk at the passed in index.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrGetSCSIInfo(
    ULONG   idxDiskIn,
    ULONG * pulSCSIBusOut,
    ULONG * pulSCSIPortOut
    )
{
    TraceFunc( "" );
    Assert( pulSCSIBusOut != NULL );
    Assert( pulSCSIPortOut != NULL );

    HRESULT                             hr = S_OK;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;

    hr = THR( ((*m_prgDisks)[ idxDiskIn ])->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccpdp->HrGetSCSIBus( pulSCSIBusOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccpdp->HrGetSCSIPort( pulSCSIPortOut ) );

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrGetSCSIInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrPruneDisks
//
//  Description:
//      Get the SCSI info for the disk at the passed in index.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrPruneDisks(
      ULONG         ulSCSIBusIn
    , ULONG         ulSCSIPortIn
    , const GUID *  pcguidMajorIdIn
    , int           nMsgIdIn
    , int           nRefIdIn
    , ULONG *       pulRemovedOut
    )
{
    TraceFunc( "" );
    Assert( pulRemovedOut != NULL );

    HRESULT                             hr = S_OK;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    ULONG                               idx;
    IUnknown *                          punk;
    ULONG                               ulSCSIBus;
    ULONG                               ulSCSIPort;
    ULONG                               cRemoved = 0;

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        punk = (*m_prgDisks)[ idx ];                                                        // don't ref
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = THR( piccpdp->HrGetSCSIBus( &ulSCSIBus ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = THR( piccpdp->HrGetSCSIPort( &ulSCSIPort ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( ( ulSCSIBusIn == ulSCSIBus ) && ( ulSCSIPortIn == ulSCSIPort ) )
            {
                BSTR                            bstr = NULL;
                IClusCfgManagedResourceInfo *   piccmri = NULL;
                HRESULT                         hrTemp;
                CLSID   clsidMinorId;

                hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
                if ( FAILED( hrTemp ) )
                {
                    LogMsg( L"[SRV] Could not create a guid for a pruning disk minor task ID" );
                    clsidMinorId = IID_NULL;
                } // if:

                LogPrunedDisk( punk, ulSCSIBusIn, ulSCSIPortIn );

                THR( ((*m_prgDisks)[ idx ])->TypeSafeQI( IClusCfgManagedResourceInfo, &piccmri ) );
                THR( piccmri->GetName( &bstr ) );
                if ( piccmri != NULL )
                {
                    piccmri->Release();
                } // if:

                TraceMemoryAddBSTR( bstr );

                STATUS_REPORT_STRING_REF( *pcguidMajorIdIn, clsidMinorId, nMsgIdIn, bstr != NULL ? bstr : L"????", nRefIdIn, hr );
                RemoveDiskFromArray( idx );
                cRemoved++;
                TraceSysFreeString( bstr );
            } // if:

            piccpdp->Release();
            piccpdp = NULL;
        } // if:
    } // for:

    if ( pulRemovedOut != NULL )
    {
        *pulRemovedOut = cRemoved;
    } // if:

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrPruneDisks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:LogPrunedDisk
//
//  Description:
//      Get the SCSI info for the disk at the passed in index.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEnumPhysicalDisks::LogPrunedDisk(
    IUnknown *  punkIn,
    ULONG       ulSCSIBusIn,
    ULONG       ulSCSIPortIn
    )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT                             hr = S_OK;
    IClusCfgManagedResourceInfo *       piccmri = NULL;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    BSTR                                bstrName = NULL;
    BSTR                                bstrUID = NULL;
    BSTR                                bstr = NULL;

    hr = THR( punkIn->TypeSafeQI( IClusCfgManagedResourceInfo, &piccmri ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( piccmri->GetUID( &bstrUID ) );
        piccmri->Release();
    } // if:

    if ( FAILED( hr ) )
    {
        bstrUID = TraceSysAllocString( L"<Unknown>" );
    } // if:
    else
    {
        TraceMemoryAddBSTR( bstrUID );
    } // else:

    hr = THR( punkIn->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( piccpdp->HrGetDeviceID( &bstrName ) );
        piccpdp->Release();
    } // if:

    if ( FAILED( hr ) )
    {
        bstrName = TraceSysAllocString( L"<Unknown>" );
    } // if:

    hr = THR( HrFormatStringIntoBSTR(
                  L"Pruning SCSI disk '%1!ws!', on Bus '%2!d!' and Port '%3!d!'; at '%4!ws!'"
                , &bstr
                , bstrName
                , ulSCSIBusIn
                , ulSCSIPortIn
                , bstrUID
                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    LOG_STATUS_REPORT( bstr, hr );

Cleanup:

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrUID );
    TraceSysFreeString( bstr );

    TraceFuncExit();

} //*** CEnumPhysicalDisks::LogPrunedDisk


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrIsLogicalDiskNTFS
//
//  Description:
//      Is the passed in logical disk NTFS?
//
//  Arguments:
//      bstrLogicalDiskIn
//
//  Return Value:
//      S_OK
//          The disk is NTFS.
//
//      S_FALSE
//          The disk is not NTFS.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrIsLogicalDiskNTFS( BSTR bstrLogicalDiskIn )
{
    TraceFunc1( "bstrLogicalDiskIn = '%ls'", bstrLogicalDiskIn == NULL ? L"<null>" : bstrLogicalDiskIn );
    Assert( bstrLogicalDiskIn != NULL );

    HRESULT             hr = S_OK;
    IWbemClassObject *  pLogicalDisk = NULL;
    BSTR                bstrPath = NULL;
    WCHAR               sz[ 64 ];
    VARIANT             var;
    size_t              cch;

    VariantInit( &var );

    cch = wcslen( bstrLogicalDiskIn );
    if ( cch > 3 )
    {
        hr = THR( E_INVALIDARG );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrIsLogicalDiskNTFS_InvalidArg, IDS_ERROR_INVALIDARG, IDS_ERROR_INVALIDARG_REF, hr );
        goto Cleanup;
    } // if:

    //
    //  truncate off any trailing \'s
    //
    if ( bstrLogicalDiskIn[ cch - 1 ] == L'\\' )
    {
        bstrLogicalDiskIn[ cch - 1 ] = '\0';
    } // if:

    //
    //  If we have just the logical disk without the trailing colon...
    //
    if ( wcslen( bstrLogicalDiskIn ) == 1 )
    {
        hr = THR( StringCchPrintfW( sz, ARRAYSIZE( sz ), L"Win32_LogicalDisk.DeviceID=\"%ws:\"", bstrLogicalDiskIn ) );
    } // if:
    else
    {
        hr = THR( StringCchPrintfW( sz, ARRAYSIZE( sz ), L"Win32_LogicalDisk.DeviceID=\"%ws\"", bstrLogicalDiskIn ) );
    } // else:

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    bstrPath = TraceSysAllocString( sz );
    if ( bstrPath == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrIsLogicalDiskNTFS, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

    hr = THR( m_pIWbemServices->GetObject( bstrPath, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pLogicalDisk, NULL ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_STRING_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_WMI_Get_LogicalDisk_Failed
                , IDS_ERROR_WMI_GET_LOGICALDISK_FAILED
                , bstrLogicalDiskIn
                , IDS_ERROR_WMI_GET_LOGICALDISK_FAILED_REF
                , hr
                );
        goto Cleanup;
    } // if:

    hr = THR( HrGetWMIProperty( pLogicalDisk, L"FileSystem", VT_BSTR, &var ) );
    if (FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    CharUpper( var.bstrVal );

    if ( NStringCchCompareCase( var.bstrVal, SysStringLen( var.bstrVal ) + 1, L"NTFS", RTL_NUMBER_OF( L"NTFS" ) ) != 0 )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pLogicalDisk != NULL )
    {
        pLogicalDisk->Release();
    } // if:

    VariantClear( &var );

    TraceSysFreeString( bstrPath );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrIsLogicalDiskNTFS


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrLogDiskInfo
//
//  Description:
//      Write the info about this disk into the log.
//
//  Arguments:
//      pDiskIn
//
//  Return Value:
//      S_OK
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrLogDiskInfo( IWbemClassObject * pDiskIn )
{
    TraceFunc( "" );
    Assert( pDiskIn != NULL );

    HRESULT hr = S_OK;
    VARIANT varDeviceID;
    VARIANT varSCSIBus;
    VARIANT varSCSIPort;
    VARIANT varSCSILun;
    VARIANT varSCSITid;
    BSTR    bstr = NULL;

    VariantInit( &varDeviceID );
    VariantInit( &varSCSIBus );
    VariantInit( &varSCSIPort );
    VariantInit( &varSCSILun );
    VariantInit( &varSCSITid );

    hr = THR( HrGetWMIProperty( pDiskIn, L"DeviceID", VT_BSTR, &varDeviceID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( IsDiskSCSI( pDiskIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Disk is SCSI...
    //
    if ( hr == S_OK )
    {
        hr = THR( HrGetWMIProperty( pDiskIn, L"SCSIBus", VT_I4, &varSCSIBus ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetWMIProperty( pDiskIn, L"SCSITargetId", VT_I4, &varSCSITid ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetWMIProperty( pDiskIn, L"SCSILogicalUnit", VT_I4, &varSCSILun ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetWMIProperty( pDiskIn, L"SCSIPort", VT_I4, &varSCSIPort ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrFormatStringIntoBSTR(
                      L"Found SCSI disk '%1!ws!' on Bus '%2!d!' and Port '%3!d!'; at TID '%4!d!' and LUN '%5!d!'"
                    , &bstr
                    , varDeviceID.bstrVal
                    , varSCSIBus.iVal
                    , varSCSIPort.iVal
                    , varSCSITid.iVal
                    , varSCSILun.iVal
                    ) );

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        LOG_STATUS_REPORT( bstr, hr );
    } // if:
    else
    {
        HRESULT hrTemp;
        CLSID   clsidMinorId;

        hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
        if ( FAILED( hrTemp ) )
        {
            LogMsg( L"[SRV] Could not create a guid for a non-scsi disk minor task ID" );
            clsidMinorId = IID_NULL;
        } // if:

        //
        //  Reset hr to S_OK since we don't want a yellow bang in the UI.  Finding non-scsi disks is expected
        //  and should cause as little concern as possible.
        //
        hr = S_OK;
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Non_SCSI_Disks, IDS_INFO_NON_SCSI_DISKS, IDS_INFO_NON_SCSI_DISKS_REF, hr );
        STATUS_REPORT_STRING_REF( TASKID_Minor_Non_SCSI_Disks, clsidMinorId, IDS_ERROR_FOUND_NON_SCSI_DISK, varDeviceID.bstrVal, IDS_ERROR_FOUND_NON_SCSI_DISK_REF, hr );
    } // else:

Cleanup:

    VariantClear( &varDeviceID );
    VariantClear( &varSCSIBus );
    VariantClear( &varSCSIPort );
    VariantClear( &varSCSILun );
    VariantClear( &varSCSITid );

    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrLogDiskInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrFindDiskWithWMIDeviceID
//
//  Description:
//      Find the disk with the passed in WMI device ID.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.  Found the disk.
//
//      S_FALSE
//          Success.  Did not find the disk.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrFindDiskWithWMIDeviceID(
    BSTR    bstrWMIDeviceIDIn,
    ULONG * pidxDiskOut
    )
{
    TraceFunc( "" );
    Assert( pidxDiskOut != NULL );

    HRESULT                             hr = S_OK;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    ULONG                               idx;
    bool                                fFoundIt = false;
    IUnknown *                          punk;
    BSTR                                bstrDeviceID = NULL;

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        punk = (*m_prgDisks)[ idx ];                                                        // don't ref
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = STHR( piccpdp->HrGetDeviceID( &bstrDeviceID ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( NBSTRCompareCase( bstrWMIDeviceIDIn, bstrDeviceID ) == 0 )
            {
                fFoundIt = true;
                break;
            } // if:

            piccpdp->Release();
            piccpdp = NULL;

            TraceSysFreeString( bstrDeviceID );
            bstrDeviceID = NULL;
        } // if:
    } // for:

    if ( !fFoundIt )
    {
        hr = S_FALSE;
    } // if:

    if ( pidxDiskOut != NULL )
    {
        *pidxDiskOut = idx;
    } // if:

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    TraceSysFreeString( bstrDeviceID );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrFindDiskWithWMIDeviceID


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrIsSystemBusManaged
//
//  Description:
//      Is the system bus managed by the cluster service?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.  The system bus is managed.
//
//      S_FALSE
//          Success.  The system bus is not managed.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrIsSystemBusManaged( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    HKEY    hKey = NULL;
    DWORD   dwData;
    DWORD   cbData = sizeof( dwData );
    DWORD   dwType;

    sc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"SYSTEM\\CURRENTCONTROLSET\\SERVICES\\ClusSvc\\Parameters", 0, KEY_READ, &hKey );
    if ( sc == ERROR_FILE_NOT_FOUND )
    {
        goto Cleanup;       // not yet a cluster node.  Return S_FALSE.
    } // if:

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        LogMsg( L"[SRV] RegOpenKeyEx() failed. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    sc = RegQueryValueEx( hKey, L"ManageDisksOnSystemBuses", NULL, &dwType, (LPBYTE) &dwData, &cbData );
    if ( sc == ERROR_FILE_NOT_FOUND )
    {
        goto Cleanup;       // value not found.  Return S_FALSE.
    } // if:

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        LogMsg( L"[SRV] RegQueryValueEx() failed. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    if (dwType != REG_DWORD) 
    {
        hr = HRESULT_FROM_WIN32( TW32(ERROR_DATATYPE_MISMATCH) );
        LogMsg( L"[SRV] RegQueryValueEx() invalid data type %d.", dwType );
    }
    else if ( dwData > 0)
    {
        hr = S_OK;
    } // if:

Cleanup:

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrIsSystemBusManaged


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrGetClusterProperties
//
//  Description:
//      Return the asked for cluster properties.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrGetClusterProperties(
      HRESOURCE hResourceIn
    , BSTR *    pbstrResourceNameOut
    )
{
    TraceFunc( "" );
    Assert( hResourceIn != NULL );
    Assert( pbstrResourceNameOut != NULL );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    DWORD                   cbBuffer;
    WCHAR *                 pwszBuffer = NULL;

    cbBuffer = 0;
    sc = TW32( ClusterResourceControl(
                        hResourceIn,
                        NULL,
                        CLUSCTL_RESOURCE_GET_NAME,
                        NULL,
                        NULL,
                        NULL,
                        cbBuffer,
                        &cbBuffer
                        ) );

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    }

    // cbBuffer contains the byte count, not the char count.
    pwszBuffer = new WCHAR[(cbBuffer/sizeof(WCHAR))+1];

    if ( pwszBuffer == NULL )
    {
        hr = THR( ERROR_OUTOFMEMORY );
        goto Cleanup;
    }

    sc = ClusterResourceControl(
                        hResourceIn,
                        NULL,
                        CLUSCTL_RESOURCE_GET_NAME,
                        NULL,
                        NULL,
                        pwszBuffer,
                        cbBuffer,
                        &cbBuffer
                        );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        goto Cleanup;
    }

    if ( wcslen( pwszBuffer ) == 0 )
    {
        LOG_STATUS_REPORT( L"The Name of a physical disk resource was empty!", hr );
    }

    *pbstrResourceNameOut = TraceSysAllocString( pwszBuffer );

    hr = S_OK;

Cleanup:

    delete [] pwszBuffer;

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrGetClusterProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::RemoveDiskFromArray
//
//  Description:
//      Release the disk at the specified index in the array and decrease the disk count.
//
//  Arguments:
//      idxDiskIn - the index of the disk to remove; must be less than the array size.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEnumPhysicalDisks::RemoveDiskFromArray( ULONG idxDiskIn )
{
    TraceFunc( "" );

    Assert( idxDiskIn < m_idxNext );

    ((*m_prgDisks)[ idxDiskIn ])->Release();
    (*m_prgDisks)[ idxDiskIn ] = NULL;

    m_cDiskCount -= 1;

    TraceFuncExit();

} //*** CEnumPhysicalDisks::RemoveDiskFromArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrLoadEnum
//
//  Description:
//      Load the enum and filter out any devices that don't belong.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrLoadEnum( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = THR( HrGetDisks() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrPruneSystemDisks() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSortDisksByIndex() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( HrIsNodeClustered() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_OK )
    {
        hr = THR( HrFixupDisks() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    hr = S_OK;  // could have been S_FALSE

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrLoadEnum


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrSortDisksByIndex
//
//  Description:
//      Sort a (possibly sparse) array of pointers to disk objects by their
//      WMI "Index" property.
//
//  Arguments:
//      ppunkDisksIn -- a pointer to an array of (possibly null)
//          IUnknown pointers to objects that implement the
//          IClusCfgPhysicalDiskProperties interface.
//
//      cArraySizeIn -- the total number of pointers in the array,
//          including nulls
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrSortDisksByIndex( void )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    CIndexedDisk *  prgIndexedDisks = NULL;
    size_t          idxCurrentDisk = 0;
    size_t          idxSortedDisk = 0;
    size_t          cDisks = 0;

    // Count the number of non-null pointers in the array
    for ( idxCurrentDisk = 0; idxCurrentDisk < m_idxNext; ++idxCurrentDisk )
    {
        if ( (*m_prgDisks)[ idxCurrentDisk ] != NULL )
        {
            cDisks += 1;
        } // if:
    } // for:

    if ( cDisks < 2 ) // no sorting to do; also avoid calling new[] with zero array size
    {
        goto Cleanup;
    } // if:

    // Make a compact array of indexed disks
    prgIndexedDisks = new CIndexedDisk[ cDisks ];
    if ( prgIndexedDisks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    // Initialize the array of indexed disks
    for ( idxCurrentDisk = 0; idxCurrentDisk < m_idxNext; ++idxCurrentDisk )
    {
        if ( (*m_prgDisks)[ idxCurrentDisk ] != NULL )
        {
            hr = THR( prgIndexedDisks[ idxSortedDisk ].HrInit( (*m_prgDisks)[ idxCurrentDisk ] ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            idxSortedDisk += 1;
        } // if current disk pointer in original array is not null
    } // for each disk pointer in the original array

    InsertionSort( prgIndexedDisks, cDisks, CIndexedDiskLessThan() );

    // Copy the sorted pointers back into the original array, padding extra space with nulls
    for ( idxCurrentDisk = 0; idxCurrentDisk < m_idxNext; ++idxCurrentDisk)
    {
        if ( idxCurrentDisk < cDisks)
        {
            (*m_prgDisks)[ idxCurrentDisk ] = prgIndexedDisks[ idxCurrentDisk ].punkDisk;
        } // if:
        else
        {
            (*m_prgDisks)[ idxCurrentDisk ] = NULL;
        } // else:
    } // for each slot in the original array

Cleanup:

    delete [] prgIndexedDisks;

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrSortDisksByIndex


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrPrunePageFileDiskBussess
//
//  Description:
//      Prune from the list of disks those that have pagefiles on them and
//      the other disks on those same SCSI busses.
//
//  Arguments:
//      fPruneBusIn
//
//      pcPrunedInout
//
//  Return Value:
//      S_OK
//          Success.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrPrunePageFileDiskBussess(
      BOOL    fPruneBusIn
    , ULONG * pcPrunedInout
    )
{
    TraceFunc( "" );
    Assert( pcPrunedInout != NULL );

    HRESULT         hr = S_OK;
    WCHAR           szPageFileDisks[ 26 ];
    int             cPageFileDisks = 0;
    int             idxPageFileDisk;
    ULONG           ulSCSIBus;
    ULONG           ulSCSIPort;
    ULONG           idx;
    ULONG           cPruned = 0;

    //
    //  Prune the bus with disks that have paging files.
    //

    hr = THR( HrGetPageFileLogicalDisks( m_picccCallback, m_pIWbemServices, szPageFileDisks, &cPageFileDisks ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( cPageFileDisks > 0 )
    {
        for ( idxPageFileDisk = 0; idxPageFileDisk < cPageFileDisks; idxPageFileDisk++ )
        {
            hr = STHR( HrFindDiskWithLogicalDisk( szPageFileDisks[ idxPageFileDisk ], &idx ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                //
                //  Should we prune the whole bus, or just the system disk itself?
                //

                if ( fPruneBusIn )
                {
                    hr = THR( HrGetSCSIInfo( idx, &ulSCSIBus, &ulSCSIPort ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:

                    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Pruning_PageFile_Disk_Bus, IDS_INFO_PRUNING_PAGEFILEDISK_BUS, hr );
                    hr = THR( HrPruneDisks(
                                      ulSCSIBus
                                    , ulSCSIPort
                                    , &TASKID_Minor_Pruning_PageFile_Disk_Bus
                                    , IDS_INFO_PAGEFILEDISK_PRUNED
                                    , IDS_INFO_PAGEFILEDISK_PRUNED_REF
                                    , &cPruned
                                    ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:
                } // if:
                else
                {
                    RemoveDiskFromArray( idx );
                    cPruned++;
                } // else:
            } // if:
        } // for:
    } // if:

    *pcPrunedInout = cPruned;
    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrPrunePageFileDiskBussess


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrPruneCrashDumpBus
//
//  Description:
//      Prune from the list of disks those that have pagefiles on them and
//      the other disks on those same SCSI busses.
//
//  Arguments:
//      fPruneBusIn
//
//      pcPrunedInout
//
//  Return Value:
//      S_OK
//          Success.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrPruneCrashDumpBus(
      BOOL    fPruneBusIn
    , ULONG * pcPrunedInout
    )
{
    TraceFunc( "" );
    Assert( pcPrunedInout != NULL );
    Assert( m_bstrCrashDumpLogicalDisk != NULL );

    HRESULT hr = S_OK;
    ULONG   ulSCSIBus;
    ULONG   ulSCSIPort;
    ULONG   idx;
    ULONG   cPruned = 0;

    //
    //  Prune the bus with disks that have paging files.
    //

    hr = STHR( HrFindDiskWithLogicalDisk( m_bstrCrashDumpLogicalDisk[ 0 ], &idx ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_OK )
    {
        //
        //  Should we prune the whole bus, or just the system disk itself?
        //

        if ( fPruneBusIn )
        {
            hr = THR( HrGetSCSIInfo( idx, &ulSCSIBus, &ulSCSIPort ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Pruning_CrashDump_Disk_Bus, IDS_INFO_PRUNING_CRASHDUMP_BUS, hr );
            hr = THR( HrPruneDisks(
                              ulSCSIBus
                            , ulSCSIPort
                            , &TASKID_Minor_Pruning_CrashDump_Disk_Bus
                            , IDS_INFO_CRASHDUMPDISK_PRUNED
                            , IDS_INFO_CRASHDUMPDISK_PRUNED_REF
                            , &cPruned
                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:
        } // if:
        else
        {
            RemoveDiskFromArray( idx );
            cPruned++;
        } // else:
    } // if:

    *pcPrunedInout = cPruned;
    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrPruneCrashDumpBus


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrPruneDynamicDisks
//
//  Description:
//      Prune from the list of disks those that have dynamic partitions
//      on them.
//
//  Arguments:
//      pcPrunedInout
//
//  Return Value:
//      S_OK
//          Success.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrPruneDynamicDisks(
    ULONG * pcPrunedInout
    )
{
    TraceFunc( "" );
    Assert( pcPrunedInout != NULL );

    HRESULT                             hr = S_OK;
    ULONG                               idx;
    ULONG                               cPruned = 0;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    HRESULT                             hrTemp;
    CLSID                               clsidMinorId;
    BSTR                                bstrDiskName = NULL;
    BSTR                                bstrDeviceName = NULL;

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgDisks)[ idx ] != NULL )
        {
            hr = THR( ((*m_prgDisks)[ idx ])->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = piccpdp->HrIsDynamicDisk();
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                ((*m_prgDisks)[ idx ])->Release();
                (*m_prgDisks)[ idx ] = NULL;
                cPruned++;

                hrTemp = THR( piccpdp->HrGetDiskNames( &bstrDiskName, &bstrDeviceName ) );
                if ( FAILED( hrTemp ) )
                {
                    LOG_STATUS_REPORT( L"Could not get the name of the disk", hrTemp );
                    bstrDiskName = NULL;
                    bstrDeviceName = NULL;
                } // if:

                hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
                if ( FAILED( hrTemp ) )
                {
                    LOG_STATUS_REPORT( L"Could not create a guid for a dynamic disk minor task ID", hrTemp );
                    clsidMinorId = IID_NULL;
                } // if:

                STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Non_SCSI_Disks, IDS_INFO_NON_SCSI_DISKS, IDS_INFO_NON_SCSI_DISKS_REF, hr );
                STATUS_REPORT_STRING2_REF(
                          TASKID_Minor_Non_SCSI_Disks
                        , clsidMinorId
                        , IDS_ERROR_LDM_DISK
                        , bstrDeviceName != NULL ? bstrDeviceName : L"<unknown>"
                        , bstrDiskName != NULL ? bstrDiskName : L"<unknown>"
                        , IDS_ERROR_LDM_DISK_REF
                        , hr
                        );
            } // if:

            piccpdp->Release();
            piccpdp = NULL;

            TraceSysFreeString( bstrDiskName );
            bstrDiskName = NULL;

            TraceSysFreeString( bstrDeviceName );
            bstrDeviceName = NULL;
        } // end if:
    } // for:

    *pcPrunedInout = cPruned;
    hr = S_OK;

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    TraceSysFreeString( bstrDiskName );
    TraceSysFreeString( bstrDeviceName );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrPruneDynamicDisks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrPruneGPTDisks
//
//  Description:
//      Prune from the list of disks those that have GPT partitions
//      on them.
//
//  Arguments:
//      pcPrunedInout
//
//  Return Value:
//      S_OK
//          Success.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrPruneGPTDisks(
    ULONG * pcPrunedInout
    )
{
    TraceFunc( "" );
    Assert( pcPrunedInout != NULL );

    HRESULT                             hr = S_OK;
    ULONG                               idx;
    ULONG                               cPruned = 0;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    HRESULT                             hrTemp;
    CLSID                               clsidMinorId;
    BSTR                                bstrDiskName = NULL;
    BSTR                                bstrDeviceName = NULL;

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgDisks)[ idx ] != NULL )
        {
            hr = THR( ((*m_prgDisks)[ idx ])->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = piccpdp->HrIsGPTDisk();
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                ((*m_prgDisks)[ idx ])->Release();
                (*m_prgDisks)[ idx ] = NULL;
                cPruned++;

                hrTemp = THR( piccpdp->HrGetDiskNames( &bstrDiskName, &bstrDeviceName ) );
                if ( FAILED( hrTemp ) )
                {
                    LOG_STATUS_REPORT( L"Could not get the name of the disk", hrTemp );
                    bstrDiskName = NULL;
                    bstrDeviceName = NULL;
                } // if:

                hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
                if ( FAILED( hrTemp ) )
                {
                    LOG_STATUS_REPORT( L"Could not create a guid for a dynamic disk minor task ID", hrTemp );
                    clsidMinorId = IID_NULL;
                } // if:

                STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Non_SCSI_Disks, IDS_INFO_NON_SCSI_DISKS, IDS_INFO_NON_SCSI_DISKS_REF, hr );
                STATUS_REPORT_STRING2_REF(
                          TASKID_Minor_Non_SCSI_Disks
                        , clsidMinorId
                        , IDS_INFO_GPT_DISK
                        , bstrDeviceName != NULL ? bstrDeviceName : L"<unknown>"
                        , bstrDiskName != NULL ? bstrDiskName : L"<unknown>"
                        , IDS_ERROR_LDM_DISK_REF
                        , hr
                        );
            } // if:

            piccpdp->Release();
            piccpdp = NULL;

            TraceSysFreeString( bstrDiskName );
            bstrDiskName = NULL;

            TraceSysFreeString( bstrDeviceName );
            bstrDeviceName = NULL;
        } // end if:
    } // for:

    *pcPrunedInout = cPruned;
    hr = S_OK;

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    TraceSysFreeString( bstrDiskName );
    TraceSysFreeString( bstrDeviceName );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrPruneGPTDisks

/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrGetDisks
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrGetDisks(
    void
    )
{
    TraceFunc( "" );

    HRESULT                             hr = S_OK;
    DWORD                               sc;
    HDEVINFO                            hdiSet = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA                     didData;
    SP_INTERFACE_DEVICE_DATA            iddData;
    GUID                                guidClass = GUID_DEVINTERFACE_DISK;
    DWORD                               idx = 0;
    BOOL                                fRet = TRUE;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    pidddDetailData = NULL;
    DWORD                               cbDetailData = 512L;
    DWORD                               cbRequired = 0L;

    ZeroMemory ( &didData, sizeof( didData ) );
    didData.cbSize = sizeof( didData );

    ZeroMemory ( &iddData, sizeof( iddData ) );
    iddData.cbSize  = sizeof( iddData );

    //
    //  get device list
    //

    hdiSet = SetupDiGetClassDevs( &guidClass, NULL, NULL, DIGCF_INTERFACEDEVICE );
    if ( hdiSet == INVALID_HANDLE_VALUE )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    //
    //  Do initial allocations.
    //

    pidddDetailData = (PSP_INTERFACE_DEVICE_DETAIL_DATA) TraceAlloc( 0, cbDetailData );
    if ( pidddDetailData == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    pidddDetailData->cbSize = sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );

    //
    //  enumerate list
    //

    for ( ; ; )
    {
        fRet = SetupDiEnumDeviceInterfaces( hdiSet, NULL, &guidClass, idx, &iddData );
        if ( fRet == FALSE )
        {
            sc = GetLastError();
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                hr = S_OK;
                break;
            } // if:

            TW32( sc );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:

        for ( ; ; )
        {
            fRet = SetupDiGetDeviceInterfaceDetail( hdiSet, &iddData, pidddDetailData, cbDetailData, &cbRequired, &didData );
            if ( fRet == FALSE )
            {
                sc = GetLastError();
                if ( sc == ERROR_INSUFFICIENT_BUFFER )
                {
                    cbDetailData = cbRequired;

                    TraceFree( pidddDetailData );
                    pidddDetailData = NULL;

                    pidddDetailData = (PSP_INTERFACE_DEVICE_DETAIL_DATA) TraceAlloc( 0, cbDetailData );
                    if ( pidddDetailData == NULL )
                    {
                        hr = THR( E_OUTOFMEMORY );
                        goto Cleanup;
                    } // if:

                    pidddDetailData->cbSize = sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );

                    continue;
                } // if:

                TW32( sc );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            } // if:
            else
            {
                break;
            } // else:
        } // for:

        idx++;
    } // for:

Cleanup:

    TraceFree( pidddDetailData );

    if ( hdiSet != INVALID_HANDLE_VALUE )
    {
        SetupDiDestroyDeviceInfoList( hdiSet );
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrGetDisks
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumunknownquorum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CEnumUnknownQuorum.h
//
//  Description:
//      This file contains the declaration of the CEnumUnknownQuorum class.
//
//      The class CEnumUnknownQuorum is the enumeration of unknown cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//      Unknown quorum resources are "proxy" objects for quorum capable
//      devices that are not known to this setup wizard.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumUnknownQuorum.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-MAY-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumUnknownQuorum
//
//  Description:
//      The class CEnumUnknownQuorum is the enumeration of unknown cluster
//      quorum devices.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumUnknownQuorum
    : public IEnumClusCfgManagedResources
    , public IClusCfgInitialize
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    BOOL                m_fEnumLoaded;
    IClusCfgCallback *  m_picccCallback;
    IUnknown *          ((*m_prgQuorums)[]);
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    BOOL                m_fDefaultDeviceToQuorum;
    BSTR                m_bstrQuorumResourceName;

    // Private constructors and destructors
    CEnumUnknownQuorum( void );
    ~CEnumUnknownQuorum( void );

    // Private copy constructor to prevent copying.
    CEnumUnknownQuorum( const CEnumUnknownQuorum & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumUnknownQuorum & operator = ( const CEnumUnknownQuorum & nodeSrc );

    HRESULT HrInit( BSTR bstrNameIn, BOOL fMakeQuorumIn = FALSE );
    HRESULT HrAddResourceToArray( IUnknown * punkIn );
    HRESULT HrCreateDummyObject( void );

public:
    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrCreateInstance( BSTR bstrNameIn, BOOL fMakeQuorumIn, IUnknown ** ppunkOut );

    //static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

}; //*** Class CEnumUnknownQuorum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenumphysicaldisks.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CEnumPhysicalDisks.h
//
//  Description:
//      This file contains the declaration of the CEnumPhysicalDisks class.
//
//      The class CEnumPhysicalDisks is the enumeration of cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumPhysicalDisks.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumPhysicalDisks
//
//  Description:
//      The class CEnumPhysicalDisks is the enumeration of cluster storage
//      devices.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgWbemServices
//      IClusCfgInitialize
//      CClusterUtils
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumPhysicalDisks
    : public IEnumClusCfgManagedResources
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
    , public CClusterUtils
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    BOOL                m_fLoadedDevices;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    IUnknown *          ((*m_prgDisks)[]);
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    BSTR                m_bstrBootDevice;
    BSTR                m_bstrSystemDevice;
    BSTR                m_bstrBootLogicalDisk;
    BSTR                m_bstrSystemLogicalDisk;
    BSTR                m_bstrSystemWMIDeviceID;
    BSTR                m_bstrCrashDumpLogicalDisk;
    DWORD               m_cDiskCount;

    // Private constructors and destructors
    CEnumPhysicalDisks( void );
    ~CEnumPhysicalDisks( void );

    // Private copy constructor to prevent copying.
    CEnumPhysicalDisks( const CEnumPhysicalDisks & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumPhysicalDisks & operator = ( const CEnumPhysicalDisks & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrGetDisks( void );
    HRESULT HrCreateAndAddDiskToArray( IWbemClassObject * pDiskIn );
    HRESULT HrAddDiskToArray( IUnknown * punkIn );
    HRESULT HrPruneSystemDisks( void );
    HRESULT IsDiskSCSI( IWbemClassObject * pDiskIn );
    HRESULT HrFixupDisks( void );
    HRESULT HrGetClusterDiskInfo( HCLUSTER hClusterIn, HRESOURCE hResourceIn, CLUS_SCSI_ADDRESS * pcsaOut, DWORD * pdwSignatureOut );
    HRESULT HrSetThisDiskToBeManaged( ULONG ulSCSITidIn, ULONG ulSCSILunIn, BOOL fIsQuorumIn, BSTR bstrResourceNameIn, DWORD dwSignatureIn );
    HRESULT HrFindDiskWithLogicalDisk( WCHAR cLogicalDiskIn, ULONG * pidxDiskOut );
    HRESULT HrGetSCSIInfo( ULONG idxDiskIn, ULONG * pulSCSIBusOut, ULONG * pulSCSIPortOut );
    HRESULT HrPruneDisks( ULONG ulSCSIBusIn, ULONG ulSCSIPortIn, const GUID * pcguidMajorIdIn, int nMsgIdIn, int nRefIdIn, ULONG * pulRemovedOut );
    void    LogPrunedDisk( IUnknown * punkIn, ULONG ulSCSIBusIn, ULONG ulSCSIPortIn );
    HRESULT HrIsLogicalDiskNTFS( BSTR bstrLogicalDiskIn );
    HRESULT HrLogDiskInfo( IWbemClassObject * pDiskIn );
    HRESULT HrFindDiskWithWMIDeviceID( BSTR bstrWMIDeviceIDIn, ULONG * pidxDiskOut );
    HRESULT HrIsSystemBusManaged( void );
    HRESULT HrGetClusterProperties( HRESOURCE hResourceIn, BSTR * pbstrResourceNameOut );
    void    RemoveDiskFromArray( ULONG idxDiskIn );
    HRESULT HrLoadEnum( void );
    HRESULT HrSortDisksByIndex( void );
    HRESULT HrPrunePageFileDiskBussess( BOOL fPruneBusIn, ULONG * pcPrunedInout );
    HRESULT HrPruneCrashDumpBus( BOOL fPruneBusIn, ULONG * pcPrunedInout );
    HRESULT HrPruneDynamicDisks( ULONG * pcPrunedInout );
    HRESULT HrPruneGPTDisks( ULONG * pcPrunedInout );

public:
    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

    //
    // CClusterUtils
    //

    HRESULT HrNodeResourceCallback( HCLUSTER hClusterIn, HRESOURCE hResourceIn );

}; //*** Class CEnumPhysicalDisks
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cindexeddisk.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CIndexedDisk.cpp
//
//  Description:
//      This file contains the definition of the CIndexedDisk class.
//
//      The CIndexedDisk structure associates a pointer to a disk object with
//      the disk object's Index property.
//
//  Maintained By:
//      John Franco (jfranco) 1-JUN-2001
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CIndexedDisk.h"
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CIndexedDisk" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CIndexedDisk class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIndexedDisk::HrInit
//
//  Description:
//      Initialize this instance from a disk object; punkDiskIn must
//      support the IClusCfgPhysicalDiskProperties interface.
//
//  Arguments:
//      punkDiskIn - the disk object for initialization.
//
//  Return Values:
//      S_OK - success.
//
//      Error codes from called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////

HRESULT
CIndexedDisk::HrInit( IUnknown * punkDiskIn )
{
    TraceFunc( "" );

    HRESULT                             hr = S_OK;
    IClusCfgPhysicalDiskProperties *    pccpdp = NULL;

    if ( punkDiskIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    // QI for IClusCfgPhysicalDiskProperties

    hr = THR( punkDiskIn->TypeSafeQI( IClusCfgPhysicalDiskProperties, &pccpdp ) );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // get index from IClusCfgPhysicalDiskProperties

    hr = THR( pccpdp->HrGetDeviceIndex( &idxDisk ) );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    punkDisk = punkDiskIn;
    
Cleanup:

    if ( pccpdp != NULL )
    {
        pccpdp->Release();
    }
    
    HRETURN( hr );

} //*** CIndexedDisk::HrInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cenummajoritynodeset.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CEnumMajorityNodeSet.h
//
//  Description:
//      This file contains the declaration of the CEnumMajorityNodeSet class.
//
//      The class CEnumMajorityNodeSet is the enumeration of cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumMajorityNodeSet.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumMajorityNodeSet
//
//  Description:
//      The class CEnumMajorityNodeSet is the enumeration of cluster local
//      quorum devices.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumMajorityNodeSet
    : public IEnumClusCfgManagedResources
    , public IClusCfgInitialize
    , public CClusterUtils
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    BOOL                m_fEnumLoaded;
    IClusCfgCallback *  m_picccCallback;
    IUnknown *          ((*m_prgQuorums)[]);
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    DWORD               m_cQuorumCount;

    // Private constructors and destructors
    CEnumMajorityNodeSet( void );
    ~CEnumMajorityNodeSet( void );

    // Private copy constructor to prevent copying.
    CEnumMajorityNodeSet( const CEnumMajorityNodeSet & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumMajorityNodeSet & operator = ( const CEnumMajorityNodeSet & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrLoadResources( void );
    HRESULT HrAddResourceToArray( IUnknown * punkIn );
    HRESULT HrCreateDummyObject( void );

public:
    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );
    
    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

    //
    //  CClusterUtils
    //
    virtual HRESULT HrNodeResourceCallback( HCLUSTER hClusterIn, HRESOURCE hResourceIn );

}; //*** Class CEnumMajorityNodeSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cindexeddisk.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CIndexedDisk.h
//
//  Implementation Files:
//      CIndexedDisk.cpp
//
//  Description:
//      This file contains the declaration of the CIndexedDisk structure.
//
//      This is a helper for CEnumPhysicalDisks, but has its own file
//      due to the one-class-per-file restriction.      
//
//  Maintained By:
//      John Franco (jfranco) 1-JUN-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  struct CIndexedDisk
//
//  Description:
//      The CIndexedDisk structure associates a pointer to a disk object with
//      the disk object's Index property.
//
//--
//////////////////////////////////////////////////////////////////////////////
struct CIndexedDisk
{
    CIndexedDisk( void );
    // accept default destructor, copy constructor, and assignment operator

    DWORD       idxDisk;
    IUnknown *  punkDisk;

    HRESULT HrInit( IUnknown * punkDiskIn );

}; //*** struct CIndexedDisk


inline CIndexedDisk::CIndexedDisk( void )
    : idxDisk( 0 )
    , punkDisk( NULL )
{
    TraceFunc( "" );
    TraceFuncExit();
    
} //*** CIndexedDisk::CIndexedDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  struct CIndexedDiskLessThan
//
//  Description:
//      The CIndexedDiskLessThan function object provides a comparison
//      operation to arrange CIndexedDisk objects in ascending order when used
//      with generic sort algorithms or sorted containers.
//
//      Although a simple function pointer would work, making it a function
//      object allows the compiler to inline the comparison operation.
//
//--
//////////////////////////////////////////////////////////////////////////////

struct CIndexedDiskLessThan
{
    bool operator()( const CIndexedDisk & rLeftIn, const CIndexedDisk & rRightIn ) const
    {
        return ( rLeftIn.idxDisk < rRightIn.idxDisk );
    }
    
}; //*** struct CIndexedDiskLessThan
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\clocalquorum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CLocalQuorum.cpp
//
//  Description:
//      This file contains the definition of the CLocalQuorum class.
//
//      The class CLocalQuorum represents a cluster manageable
//      device. It implements the IClusCfgManagedResourceInfo interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CLocalQuorum.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CLocalQuorum" );

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CLocalQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CLocalQuorum instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CLocalQuorum::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    CLocalQuorum *  plq = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    plq = new CLocalQuorum();
    if ( plq == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( plq->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( plq->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CLocalQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( plq != NULL )
    {
        plq->Release();
    } // if:

    HRETURN( hr );

} //*** CLocalQuorum::S_HrCreateInstance


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::CLocalQuorum
//
//  Description:
//      Constructor of the CLocalQuorum class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CLocalQuorum::CLocalQuorum( void )
    : m_cRef( 1 )
    , m_fIsQuorumCapable( TRUE )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_lcid == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_fIsQuorum == FALSE );
    Assert( m_fIsMultiNodeCapable == FALSE );
    Assert( m_fIsManaged == FALSE );
    Assert( m_fIsManagedByDefault == FALSE );
    Assert( m_bstrName == NULL );

    TraceFuncExit();

} //*** CLocalQuorum::CLocalQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::~CLocalQuorum
//
//  Description:
//      Desstructor of the CLocalQuorum class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CLocalQuorum::~CLocalQuorum( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_bstrName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CLocalQuorum::~CLocalQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CLocalQuorum::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    //
    //  Do not default to being manageble.  Let our parent enum set this to true
    //  if and only if an instance of LQ exists in the cluster.
    //

    //m_fIsManagedByDefault = TRUE;

    //
    // Load the display name for this resource
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_LOCALQUORUM, &m_bstrName ) );

    HRETURN( hr );

} //*** CLocalQuorum::HrInit


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CLocalQuorum::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CLocalQuorum::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CLocalQuorum::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CLocalQuorum::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgManagedResourceInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
    } // else if: IClusCfgManagedResourceInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceCfg ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceCfg, this, 0 );
    } // else if: IClusCfgManagedResourceCfg
    else if ( IsEqualIID( riidIn, IID_IClusCfgVerifyQuorum ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgVerifyQuorum, this, 0 );
    } // else if: IClusCfgVerifyQuorum
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING2(
          hr
        , riidIn
        , IID_IEnumClusCfgPartitions
        , IID_IClusCfgManagedResourceData
        );

} //*** CLocalQuorum::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CLocalQuorum::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetUID_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( CLUS_RESTYPE_NAME_LKQUORUM );
    if ( *pbstrUIDOut == NULL  )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CLocalQuorum::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetName_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL  )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetName_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CLocalQuorum::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszNameIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrName );
    m_bstrName = bstr;

Cleanup:

    HRETURN( hr );

} //*** CLocalQuorum::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::IsManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManaged )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CLocalQuorum::IsManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::SetManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetManaged(
    BOOL fIsManagedIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsManaged = fIsManagedIn;

    HRETURN( S_OK );

} //*** CLocalQuorum::SetManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::IsQuorumResource
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is the quorum device.
//
//      S_FALSE
//          The device is not the quorum device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::IsQuorumResource( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorum )
    {
        hr = S_OK;
    } // if:

    LOG_STATUS_REPORT_STRING(
                          L"Local quorum '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"is" : L"is not"
                        , hr
                        );

    HRETURN( hr );

} //*** CLocalQuorum::IsQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::SetQuorumResource
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetQuorumResource( BOOL fIsQuorumResourceIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    //
    //  If we are not quorum capable then we should not allow ourself to be
    //  made the quorum resource.
    //

    if ( ( fIsQuorumResourceIn ) && ( m_fIsQuorumCapable == FALSE ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_QUORUM_CAPABLE );
        goto Cleanup;
    } // if:

    m_fIsQuorum = fIsQuorumResourceIn;

Cleanup:

    LOG_STATUS_REPORT_STRING(
                          L"Setting local quorum '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"to be" : L"to not be"
                        , hr
                        );

    HRETURN( hr );

} //*** CLocalQuorum::SetQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::IsQuorumCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is a quorum capable device.
//
//      S_FALSE
//          The device is not a quorum capable device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorumCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CLocalQuorum::IsQuorumCapable


//////////////////////////////////////////////////////////////////////////
//
//  CLocalQuorum::SetQuorumCapable
//
//  Description:
//      Call this to set whether the resource is capable to be the quorum
//      resource or not.
//
//  Parameter:
//      fIsQuorumCapableIn - If TRUE, the resource will be marked as quorum capable.
//
//  Return Values:
//      S_OK
//          Call succeeded.
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetQuorumCapable(
    BOOL fIsQuorumCapableIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsQuorumCapable = fIsQuorumCapableIn;

    HRETURN( hr );

} //*** CLocalQuorum::SetQuorumCapable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_FALSE
//          There are not drive letters on this device.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( S_FALSE );

} //*** CLocalQuorum::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CLocalQuorum::SetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::IsManagedByDefault
//
//  Description:
//      Should this resource be managed by the cluster by default?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The device is managed by default.
//
//      S_FALSE
//          The device is not managed by default.
//
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::IsManagedByDefault( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManagedByDefault )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CLocalQuorum::IsManagedByDefault


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::SetManagedByDefault
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetManagedByDefault(
    BOOL fIsManagedByDefaultIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsManagedByDefault = fIsManagedByDefaultIn;

    HRETURN( S_OK );

} //*** CLocalQuorum::SetManagedByDefault


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum class -- IClusCfgManagedResourceCfg
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::PreCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::PreCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CLocalQuorum::PreCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::Create
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::Create( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CLocalQuorum::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::PostCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::PostCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CLocalQuorum::PostCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::Evict
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::Evict( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CLocalQuorum::Evict


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum class -- IClusCfgVerifyQuorum interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::PrepareToHostQuorumResource
//
//  Description:
//      Do any configuration necessary in preparation for this node hosting
//      the quorum.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::PrepareToHostQuorumResource( void )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRETURN( S_OK );

} //*** CLocalQuorum::PrepareToHostQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::Cleanup
//
//  Description:
//      Do any necessay cleanup from the PrepareToHostQuorumResource()
//      method.
//
//      If the cleanup method is anything other than successful completion
//      then the anything created above in PrepareToHostQuorumResource()
//      needs to be cleaned up.
//
//  Arguments:
//      cccrReasonIn
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::Cleanup(
      EClusCfgCleanupReason cccrReasonIn
    )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRETURN( S_OK );

} //*** CLocalQuorum::Cleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::IsMultiNodeCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device allows join.
//
//      S_FALSE
//          The device does not allow join.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::IsMultiNodeCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsMultiNodeCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CLocalQuorum::IsMultiNodeCapable

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::SetMultiNodeCapable
//
//  Description:
//      Sets the multi node capable flag
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The resource supports multi node clusters.
//
//      S_FALSE
//          The resource does not support multi node clusters.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetMultiNodeCapable(
    BOOL fMultiNodeCapableIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsMultiNodeCapable = fMultiNodeCapableIn;

    HRETURN( S_OK );

} //*** CLocalQuorum::IsMultiNodeCapable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cmajoritynodeset.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      CMajorityNodeSet.h
//
//  Description:
//      This file contains the declaration of the CMajorityNodeSet
//      class.
//
//      The class CMajorityNodeSet represents a cluster storage
//      device. It implements the IClusCfgManagaedResourceInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CMajorityNodeSet.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CMajorityNodeSet
//
//  Description:
//      The class CMajorityNodeSet represents a cluster storage device.
//
//  Interfaces:
//      IClusCfgManagedResourceInfo
//      IClusCfgInitialize
//      IClusCfgManagedResourceCfg
//      IClusCfgManagedResourceData
//      IClusCfgVerifyQuorum
//--
//////////////////////////////////////////////////////////////////////////////
class CMajorityNodeSet
    : public IClusCfgManagedResourceInfo
    , public IClusCfgInitialize
    , public IClusCfgManagedResourceCfg
    , public IClusCfgManagedResourceData
    , public IClusCfgVerifyQuorum
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fIsQuorum;
    BOOL                m_fIsMultiNodeCapable;
    BOOL                m_fIsManaged;
    BOOL                m_fIsManagedByDefault;
    BSTR                m_bstrName;
    BOOL                m_fIsQuorumCapable;     // Is this resource quorum capable
    BOOL                m_fAddedShare;

    CClusPropList       m_cplPrivate;

    // Private constructors and destructors
    CMajorityNodeSet( void );
    ~CMajorityNodeSet( void );

    // Private copy constructor to prevent copying.
    CMajorityNodeSet( const CMajorityNodeSet & nodeSrc );

    // Private assignment operator to prevent copying.
    const CMajorityNodeSet & operator = ( const CMajorityNodeSet & nodeSrc );

    HRESULT HrInit( void );

    // Called from PrepareToHostQuorum.
    HRESULT HrSetupShare( LPCWSTR pcszGUIDIn );

    // Called from Cleanup.
    HRESULT HrDeleteShare( LPCWSTR pcszGUIDIn );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );

    STDMETHOD( IsManaged )( void );

    STDMETHOD( SetManaged )( BOOL fIsManagedIn );

    STDMETHOD( IsQuorumResource )( void );

    STDMETHOD( SetQuorumResource )( BOOL fIsQuorumResourceIn );

    STDMETHOD( IsQuorumCapable )( void );

    STDMETHOD( SetQuorumCapable )( BOOL fIsQuorumCapableIn );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappings );

    STDMETHOD( IsManagedByDefault )( void );

    STDMETHOD( SetManagedByDefault )( BOOL fIsManagedByDefaultIn );

    //
    //  IClusCfgManagedResourceCfg
    //

    STDMETHOD( PreCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Create )( IUnknown * punkServicesIn );

    STDMETHOD( PostCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Evict )( IUnknown * punkServicesIn );

    //
    //  IClusCfgManagedResourceData
    //

    STDMETHOD( GetResourcePrivateData )( BYTE * pbBufferOut, DWORD * pcbBufferInout );

    STDMETHOD( SetResourcePrivateData )( const BYTE * pcbBufferIn, DWORD cbBufferIn );

    //
    //  IClusCfgVerifyQuorum
    //

    STDMETHOD( PrepareToHostQuorumResource )( void );

    STDMETHOD( Cleanup )( EClusCfgCleanupReason cccrReasonIn );

    STDMETHOD( IsMultiNodeCapable )( void );

    STDMETHOD( SetMultiNodeCapable )( BOOL fMultiNodeCapableIn );

}; //*** Class CMajorityNodeSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cphysicaldisk.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CPhysicalDisk.h
//
//  Description:
//      This file contains the declaration of the CPhysicalDisk
//      class.
//
//      The class CPhysicalDisk represents a cluster storage
//      device. It implements the IClusCfgManagaedResourceInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CPhysicalDisk.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CPhysicalDisk
//
//  Description:
//      The class CPhysicalDisk represents a cluster storage
//      device.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CPhysicalDisk
    : public IClusCfgManagedResourceInfo
    , public IClusCfgWbemServices
    , public IClusCfgSetWbemObject
    , public IEnumClusCfgPartitions
    , public IClusCfgPhysicalDiskProperties
    , public IClusCfgManagedResourceCfg
    , public IClusCfgInitialize
    , public IClusCfgVerifyQuorum
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    BSTR                m_bstrName;
    BSTR                m_bstrDeviceID;
    BSTR                m_bstrDescription;
    IUnknown *          ((*m_prgPartitions)[]);
    ULONG               m_idxNextPartition;
    ULONG               m_ulSCSIBus;
    ULONG               m_ulSCSITid;
    ULONG               m_ulSCSIPort;
    ULONG               m_ulSCSILun;
    ULONG               m_idxEnumPartitionNext;
    DWORD               m_dwSignature;
    BOOL                m_fIsManaged;
    BOOL                m_fIsManagedByDefault;
    BOOL                m_fIsQuorumResource;
    BOOL                m_fIsQuorumCapable;                     // Is this resource quorum capable
    BOOL                m_fIsQuorumResourceMultiNodeCapable;
    BSTR                m_bstrFriendlyName;
//    BSTR                m_bstrFirmwareSerialNumber;
    DWORD               m_cPartitions;
    DWORD               m_idxDevice;
    BOOL                m_fIsDynamicDisk;
    BOOL                m_fIsGPTDisk;

    // Private constructors and destructors
    CPhysicalDisk( void );
    ~CPhysicalDisk( void );

    // Private copy constructor to prevent copying.
    CPhysicalDisk( const CPhysicalDisk & nodeSrc );

    // Private assignment operator to prevent copying.
    const CPhysicalDisk & operator = ( const CPhysicalDisk & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrGetPartitionInfo( IWbemClassObject * pDiskIn, bool * pfRetainObjectOut );
    HRESULT HrCreatePartitionInfo( IWbemClassObject * pPartitionIn );
    HRESULT HrAddPartitionToArray( IUnknown * punkIn );
    HRESULT HrCreateFriendlyName( void );
    HRESULT HrCreateFriendlyName( BSTR bstrNameIn );
    HRESULT HrIsPartitionGPT( IWbemClassObject * pPartitionIn );
    HRESULT HrIsPartitionLDM( IWbemClassObject * pPartitionIn );
//    HRESULT HrGetDiskFirmwareSerialNumber( void );
//    HRESULT HrGetDiskFirmwareVitalData( void );
    HRESULT HrIsClusterCapable( void );
//    HRESULT HrProcessMountPoints( void );
//    void    InitDriveLetterMappings( SDriveLetterMapping * pdlmDriveLetterMappingOut );
//    HRESULT HrEnumMountPoints( const WCHAR * pcszRootPathIn );
//    HRESULT HrProcessMountedVolume( const WCHAR * pcszRootPathIn, const WCHAR * pcszMountPointIn );
//    HRESULT HrProcessSpindle( const WCHAR * pcszDeviceIDIn );

public:
    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interface
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgSetWbemObject Interface
    //

    STDMETHOD( SetWbemObject )( IWbemClassObject * pDiskIn, bool * pfRetainObjectOut );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );

    STDMETHOD( IsManaged )( void );

    STDMETHOD( SetManaged )( BOOL fIsManagedIn );

    STDMETHOD( IsQuorumResource )( void );

    STDMETHOD( SetQuorumResource )( BOOL fIsQuorumResourceIn );

    STDMETHOD( IsQuorumCapable )( void );

    STDMETHOD( SetQuorumCapable )( BOOL fIsQuorumCapableIn );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappings );

    STDMETHOD( IsManagedByDefault )( void );

    STDMETHOD( SetManagedByDefault )( BOOL fIsManagedByDefaultIn );

    //
    // IEnumClusCfgPartitions Interface
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgPartitionInfo ** rgpPartitionInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgPartitions ** ppEnumClusCfgPartitionsOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

    //
    // IClusCfgPhysicalDiskProperties Interface
    //

    STDMETHOD( IsThisLogicalDisk )( WCHAR cLogicalDiskIn );

    STDMETHOD( HrGetSCSIBus )( ULONG * pulSCSIBusOut );

    STDMETHOD( HrGetSCSIPort )( ULONG * pulSCSIPortOut );

    STDMETHOD( CanBeManaged )( void );

    STDMETHOD( HrGetDeviceID )( BSTR * pbstrDeviceIDOut );

    STDMETHOD( HrGetSignature )( DWORD * pdwSignatureOut );

    STDMETHOD( HrSetFriendlyName )( LPCWSTR pcszFriendlyNameIn );

    STDMETHOD( HrGetDeviceIndex )( DWORD * pidxDeviceOut );

    STDMETHOD( HrIsDynamicDisk )( void );

    STDMETHOD( HrIsGPTDisk )( void );

    STDMETHOD( HrGetDiskNames )( BSTR * pbstrDiskNameOut, BSTR * pbstrDeviceNameOut );

    //
    //  IClusCfgManagedResourceCfg
    //

    STDMETHOD( PreCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Create )( IUnknown * punkServicesIn );

    STDMETHOD( PostCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Evict )( IUnknown * punkServicesIn );

    //
    //  IClusCfgVerifyQuorum
    //

    STDMETHOD( PrepareToHostQuorumResource )( void );

    STDMETHOD( Cleanup )( EClusCfgCleanupReason cccrReasonIn );

    STDMETHOD( IsMultiNodeCapable )( void );

    STDMETHOD( SetMultiNodeCapable )( BOOL fMultiNodeCapableIn );

}; //*** class CPhysicalDisk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cunknownquorum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      CUnknownQuorum.cpp
//
//  Description:
//      This file contains the definition of the CUnknownQuorum class.
//
//      The class CUnknownQuorum represents a cluster quorum
//      device. It implements the IClusCfgManagedResourceInfo interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CUnknownQuorum.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CUnknownQuorum" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CUnknownQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CUnknownQuorum instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CUnknownQuorum::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CUnknownQuorum *    puq = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    puq = new CUnknownQuorum();
    if ( puq == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( puq->HrInit( NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( puq->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CUnknownQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( puq != NULL )
    {
        puq->Release();
    } // if:

    HRETURN( hr );

} //*** CUnknownQuorum::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CUnknownQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CUnknownQuorum instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CUnknownQuorum::S_HrCreateInstance(
      LPCWSTR       pcszNameIn
    , BOOL          fMakeQuorumIn
    , IUnknown **   ppunkOut
     )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CUnknownQuorum *    puq = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    puq = new CUnknownQuorum();
    if ( puq == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( puq->HrInit( pcszNameIn, fMakeQuorumIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( puq->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CUnknownQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( puq != NULL )
    {
        puq->Release();
    } // if:

    HRETURN( hr );

} //*** CUnknownQuorum::S_HrCreateInstance


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::CUnknownQuorum
//
//  Description:
//      Constructor of the CUnknownQuorum class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CUnknownQuorum::CUnknownQuorum( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_lcid == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_fIsQuorum == FALSE );
    Assert( m_fIsQuorumCapable == FALSE );
    Assert( m_fIsMultiNodeCapable == FALSE );
    Assert( m_fIsManaged  == FALSE );
    Assert( m_fIsManagedByDefault  == FALSE );
    Assert( m_bstrName == NULL );

    TraceFuncExit();

} //*** CUnknownQuorum::CUnknownQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::~CUnknownQuorum
//
//  Description:
//      Desstructor of the CUnknownQuorum class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CUnknownQuorum::~CUnknownQuorum( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_bstrName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CUnknownQuorum::~CUnknownQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CUnknownQuorum::HrInit(
      LPCWSTR pcszNameIn
    , BOOL fMakeQuorumIn    //= FALSE
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    //
    //  If we are proxying for the quorum ( fMakeQuorumIn == TRUE ) then we are:
    //      The quorum.
    //      Manageable.
    //      Managed.
    //  Since we know nothing about the unknown quorum's multi-node capbility
    //  then we will assume it is multi-node capable since most quorum
    //  resources are.
    //
    //  Since this is a quorum resourc we will always be Quorum capable by
    //  default.
    //

    m_fIsQuorum =           fMakeQuorumIn;
    m_fIsManagedByDefault = fMakeQuorumIn;
    m_fIsManaged =          fMakeQuorumIn;
    m_fIsMultiNodeCapable = fMakeQuorumIn;

    m_fIsQuorumCapable = TRUE;

    //
    //  If we were handed a name then use it -- if we are proxying for an
    //  unknown quorum resource.  If we are just a dummy resource then don't
    //  accept the passed in name.
    //

    if ( ( pcszNameIn != NULL ) && ( m_fIsQuorum == TRUE ) )
    {
        m_bstrName = TraceSysAllocString( pcszNameIn );
        if ( m_bstrName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
        } // if:

        LogMsg( L"[SRV] Initializing the name of the UnKnown Quorum to %ws.", m_bstrName );
    } // if:
    else
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_UNKNOWN_QUORUM, &m_bstrName ) );
    } // else:

    HRETURN( hr );


} //*** CUnknownQuorum::HrInit


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CUnknownQuorum::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CUnknownQuorum::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CUnknownQuorum::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CUnknownQuorum::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgManagedResourceInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
    } // else if: IClusCfgManagedResourceInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceCfg ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceCfg, this, 0 );
    } // else if: IClusCfgManagedResourceCfg
    else if ( IsEqualIID( riidIn, IID_IClusCfgVerifyQuorum ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgVerifyQuorum, this, 0 );
    } // else if: IClusCfgVerifyQuorum
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING2(
          hr
        , riidIn
        , IID_IEnumClusCfgPartitions
        , IID_IClusCfgManagedResourceData
        );

} //*** CUnknownQuorum::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_UnknownQuorum_GetUID_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( g_szUnknownQuorumUID );
    if ( *pbstrUIDOut == NULL  )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_UnknownQuorum_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_UnknownQuorum_GetName_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL  )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_UnknownQuorum_GetName_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszNameIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrName );
    m_bstrName = bstr;

    LogMsg( L"[SRV] Setting the name of the UnKnown Quorum to %ws.", m_bstrName );

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::IsManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManaged )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CUnknownQuorum::IsManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::SetManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetManaged(
    BOOL fIsManagedIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsManaged = fIsManagedIn;

    HRETURN( S_OK );

} //*** CUnknownQuorum::SetManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::IsQuorumResource
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is the quorum device.
//
//      S_FALSE
//          The device is not the quorum device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::IsQuorumResource( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorum )
    {
        hr = S_OK;
    } // if:

    LOG_STATUS_REPORT_STRING(
                          L"Unknown quorum '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"is" : L"is not"
                        , hr
                        );

    HRETURN( hr );

} //*** CUnknownQuorum::IsQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::SetQuorumResource
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetQuorumResource( BOOL fIsQuorumResourceIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    //
    //  If we are not quorum capable then we should not allow ourself to be
    //  made the quorum resource.
    //

    if ( ( fIsQuorumResourceIn ) && ( m_fIsQuorumCapable == FALSE ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_QUORUM_CAPABLE );
        goto Cleanup;
    } // if:

    m_fIsQuorum = fIsQuorumResourceIn;

Cleanup:

    LOG_STATUS_REPORT_STRING(
                          L"Setting unknown quorum '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"to be" : L"to not be"
                        , hr
                        );

    HRETURN( hr );

} //*** CUnknownQuorum::SetQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::IsQuorumCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is a quorum capable device.
//
//      S_FALSE
//          The device is not a quorum capable device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorumCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CUnknownQuorum::IsQuorumCapable

//////////////////////////////////////////////////////////////////////////
//
//  CUnknownQuorum::SetQuorumCapable
//
//  Description:
//      Call this to set whether the resource is capable to be the quorum
//      resource or not.
//
//  Parameter:
//      fIsQuorumCapableIn - If TRUE, the resource will be marked as quorum capable.
//
//  Return Values:
//      S_OK
//          Call succeeded.
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetQuorumCapable(
    BOOL fIsQuorumCapableIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsQuorumCapable = fIsQuorumCapableIn;

    HRETURN( hr );

} //*** CUnknownQuorum::SetQuorumCapable

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_FALSE
//          There are not drive letters on this device.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( S_FALSE );

} //*** CUnknownQuorum::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CUnknownQuorum::SetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::IsManagedByDefault
//
//  Description:
//      Should this resource be managed by the cluster by default?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The device is managed by default.
//
//      S_FALSE
//          The device is not managed by default.
//
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::IsManagedByDefault( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManagedByDefault )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CUnknownQuorum::IsManagedByDefault


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::SetManagedByDefault
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetManagedByDefault(
    BOOL fIsManagedByDefaultIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsManagedByDefault = fIsManagedByDefaultIn;

    HRETURN( S_OK );

} //*** CUnknownQuorum::SetManagedByDefault


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum class -- IClusCfgManagedResourceCfg interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::PreCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::PreCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CUnknownQuorum::PreCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::Create
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::Create( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CUnknownQuorum::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::PostCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::PostCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CUnknownQuorum::PostCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::Evict
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::Evict( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CUnknownQuorum::Evict


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum class -- IClusCfgVerifyQuorum interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::PrepareToHostQuorumResource
//
//  Description:
//      Do any configuration necessary in preparation for this node hosting
//      the quorum.
//
//      In this class we need to ensure that we can connect to the proper
//      disk share.  The data about what share to connect to should have
//      already been set using SetResourcePrivateData() above.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::PrepareToHostQuorumResource( void )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRESULT hr = S_OK;

    //
    //  No yet implemented.
    //

    hr = S_FALSE;

    goto Cleanup;

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::PrepareToHostQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::Cleanup
//
//  Description:
//      Do any necessay cleanup from the PrepareToHostQuorumResource()
//      method.
//
//      If the cleanup method is anything other than successful completion
//      then the share needs to be torn down.
//
//  Arguments:
//      cccrReasonIn
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::Cleanup(
      EClusCfgCleanupReason cccrReasonIn
    )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRESULT hr = S_OK;

    //
    //  No yet implemented.
    //

    hr = S_FALSE;

    goto Cleanup;

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::Cleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::IsMultiNodeCapable
//
//  Description:
//      Does this quorum resource support multi node clusters?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The resource allows multi node clusters.
//
//      S_FALSE
//          The resource does not allow multi node clusters.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::IsMultiNodeCapable( void )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsMultiNodeCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CUnknownQuorum::IsMultiNodeCapable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::SetMultiNodeCapable
//
//  Description:
//      Sets the multi node capable flag
//
//  Arguments:
//      fMultiNodeCapableIn
//          The flag telling this instance whether or not it should support
//          Multi node clusters.
//
//  Return Value:
//      S_OK
//          Success.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetMultiNodeCapable( BOOL fMultiNodeCapableIn )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    m_fIsMultiNodeCapable = fMultiNodeCapableIn;

    HRETURN( S_OK );

} //*** CUnknownQuorum::SetMultiNodeCapable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cmajoritynodeset.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      CMajorityNodeSet.cpp
//
//  Description:
//      This file contains the definition of the CMajorityNodeSet class.
//
//      The class CMajorityNodeSet represents a cluster manageable
//      device. It implements the IClusCfgManagedResourceInfo interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CMajorityNodeSet.h"
#include <clusrtl.h>

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CMajorityNodeSet" );

#define SETUP_DIRECTORY_PREFIX  L"\\cluster\\" MAJORITY_NODE_SET_DIRECTORY_PREFIX


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::S_HrCreateInstance
//
//  Description:
//      Create a CMajorityNodeSet instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CMajorityNodeSet instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CMajorityNodeSet::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CMajorityNodeSet *  pmns = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pmns = new CMajorityNodeSet();
    if ( pmns == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pmns->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pmns->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CMajorityNodeSet::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pmns != NULL )
    {
        pmns->Release();
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::S_HrCreateInstance


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::CMajorityNodeSet
//
//  Description:
//      Constructor of the CMajorityNodeSet class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CMajorityNodeSet::CMajorityNodeSet( void )
    : m_cRef( 1 )
    , m_fIsQuorumCapable( TRUE )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_lcid == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_fIsQuorum == FALSE );
    Assert( m_fIsMultiNodeCapable == FALSE );
    Assert( m_fIsManaged == FALSE );
    Assert( m_fIsManagedByDefault == FALSE );
    Assert( m_bstrName == NULL );
    Assert( m_fAddedShare == FALSE );

    TraceFuncExit();

} //*** CMajorityNodeSet::CMajorityNodeSet


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::~CMajorityNodeSet
//
//  Description:
//      Desstructor of the CMajorityNodeSet class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CMajorityNodeSet::~CMajorityNodeSet( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_bstrName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CMajorityNodeSet::~CMajorityNodeSet


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CMajorityNodeSet::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    //
    //  BUGBUG: 16-MAR-2001 GalenB
    //
    //  Make this device joinable by default.  Need to figure how to do this
    //  properly.  Depending upon Majority Node Set this may be the right way to
    //  do it...
    //

    m_fIsMultiNodeCapable = TRUE;

    //
    //  Do not default to being manageable.  Let our parent enum set this to true
    //  if and only if there is an instance of MNS in the cluster.
    //

    //m_fIsManagedByDefault = TRUE;

    //
    // Load the display name for this resource
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_MAJORITY_NODE_SET, &m_bstrName ) );

    HRETURN( hr );

} //*** CMajorityNodeSet::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::HrSetupShare
//
//  Description:
//      Setup the share for the MNS resource.  Called from PrepareToHostQuorum.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT
//          An error occurred.
//
//  Remarks:
//      This duplicates the functionality found in SetupShare in resdll\ndquorum\setup.c.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CMajorityNodeSet::HrSetupShare(
    LPCWSTR pcszGUIDIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    DWORD                   sc;
    DWORD                   cch;
    WCHAR                   szPath[ MAX_PATH ];
    WCHAR                   szGUID[ MAX_PATH ];
    HANDLE                  hDir = NULL;
    SHARE_INFO_502          shareInfo;
    PBYTE                   pbBuffer = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    //
    //  Both the directory and the share need to have '$' appended to them.
    //

    hr = THR( StringCchPrintfW( szGUID, ARRAYSIZE( szGUID ), L"%ws$", pcszGUIDIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Retrieve the windows directory.
    //

    cch = GetWindowsDirectoryW( szPath, MAX_PATH );
    if ( cch == 0 )
    {
        sc = TW32( GetLastError() );
        LogMsg( L"[SRV] CMajorityNodeSet::SetupShare: GetWindowsDirectory failed: %d.", sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: couldn't retrieve the Windows directory

    Assert( cch < MAX_PATH );
    Assert( wcslen( SETUP_DIRECTORY_PREFIX ) + wcslen( szGUID ) < MAX_PATH );

    //  GetWindowsDirectory apparently doesn't null terminate the returned string.
    //szPath[ cch ] = L'\0';

    //
    //  Construct the directory "<%systemroot%>\cluster\MNS.<GUID$>".
    //

    hr = THR( StringCchCatW( szPath, ARRAYSIZE( szPath ), SETUP_DIRECTORY_PREFIX ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( StringCchCatW( szPath, ARRAYSIZE( szPath ), szGUID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If the directory or share exists delete it. Should create it fresh.
    //

    hr = THR( HrDeleteShare( pcszGUIDIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // Test
    LogMsg( L"[SRV] CMajorityNodeSet::SetupShare() share path=%ws share name=%ws.", szPath, szGUID );

    if ( FALSE == CreateDirectory( szPath, NULL ) )
    {
        sc = TW32( GetLastError() );
        if ( sc != ERROR_ALREADY_EXISTS )
        {
            LogMsg( L"[SRV] CMajorityNodeSet::SetupShare: Failed to create directory \'%ws\', %d.", szPath, sc );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if: CreateDirectory failed
    } // if: CreateDirectory failed - either we couldn't create it or it already exists.

    //
    //  Open a handle to the new directory so that we can set permissions on it.
    //

    hDir =  CreateFileW(
                          szPath
                        , GENERIC_READ | WRITE_DAC | READ_CONTROL
                        , FILE_SHARE_READ | FILE_SHARE_WRITE
                        , NULL
                        , OPEN_ALWAYS
                        , FILE_FLAG_BACKUP_SEMANTICS
                        , NULL
                       );
    if ( hDir == INVALID_HANDLE_VALUE )
    {
        sc = TW32( GetLastError() );
        LogMsg( L"[SRV] CMajorityNodeSet::SetupShare: Failed to open a handle to the directory 'w%s', %d.", szPath, sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: we weren't able to open a handle to the new directory

    //
    //  Set the security attributes for the file.
    //

    sc = TW32( ClRtlSetObjSecurityInfo( hDir, SE_FILE_OBJECT, GENERIC_ALL, GENERIC_ALL, 0 ) );
    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( L"[SRV] CMajorityNodeSet::SetupShare: Error setting security on directory '%ws', %d.", szPath, sc );
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        goto Cleanup;
    } // if: failed to set the security on the object

    //
    //  See if the share already exists.
    //

    pbBuffer = (PBYTE) &shareInfo;
    sc = TW32( NetShareGetInfo( NULL, (LPWSTR) szGUID, 502, (PBYTE *) &pbBuffer ) );
    if ( sc == NERR_Success )
    {
        NetApiBufferFree( pbBuffer );
        pbBuffer = NULL;
        hr = S_OK;
        goto Cleanup;
    } // if: NetShareGetInfo succeeded - the share exists already so we're done.

    //
    //  We couldn't find the share, so try to create it.
    //

    sc = ConvertStringSecurityDescriptorToSecurityDescriptor(
                    L"D:P(A;;GA;;;BA)(A;;GA;;;CO)"
                    , SDDL_REVISION_1
                    , &pSD
                    , NULL
                   );
    if ( sc == 0 )  // Zero indicates failure.
    {
        pSD = NULL;
        sc = TW32( GetLastError() );
        LogMsg( L"[SRV] CMajorityNodeSet::SetupShare: Unable to retrieve the security descriptor: %d.", sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: Convert failed

    //
    //  Now try to actually create it.
    //

    ZeroMemory( &shareInfo, sizeof( shareInfo ) );
    shareInfo.shi502_netname =              (LPWSTR) szGUID;
    shareInfo.shi502_type =                 STYPE_DISKTREE;
    shareInfo.shi502_remark =               L"";
    shareInfo.shi502_max_uses =             (DWORD) -1;
    shareInfo.shi502_path =                 szPath;
    shareInfo.shi502_passwd =               NULL;
    shareInfo.shi502_permissions =          ACCESS_ALL;
    shareInfo.shi502_security_descriptor =  pSD;

    sc = NetShareAdd( NULL, 502, (PBYTE) &shareInfo, NULL );
    if ( sc != NERR_Success && sc != NERR_DuplicateShare )
    {
        LogMsg( L"[SRV] CMajorityNodeSet::SetupShare: Unable to add share '%ws' to the local machine, %d.", szPath, sc );
        hr = THR( HRESULT_FROM_WIN32( sc ) );
        goto Cleanup;
    } // if: NetShareAdd failed

    m_fAddedShare = TRUE;

    hr = S_OK;

Cleanup:

    if ( FAILED( hr ) )
    {
        STATUS_REPORT_STRING_REF(
                  TASKID_Major_Check_Cluster_Feasibility
                , TASKID_Minor_MajorityNodeSet_HrSetupShare
                , IDS_ERROR_MNS_HRSETUPSHARE
                , szPath
                , IDS_ERROR_MNS_HRSETUPSHARE_REF
                , hr
                );
    } // if: we had an error

    if ( ( hDir != NULL ) && ( hDir != INVALID_HANDLE_VALUE ) )
    {
        CloseHandle( hDir );
    } // if:

    LocalFree( pSD );

    HRETURN( hr );

} //*** CMajorityNodeSet::HrSetupShare


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::HrDeleteShare
//
//  Description:
//      Delete the share that we setup for the MNS resource.  Called from Cleanup.
//
//  Arguments:
//      pcszGUIDIn - name of the GUID for this resource, used to figure out what
//                   the share name and directory names are.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT
//          An error occurred.
//
//  Remarks:
//      This duplicates the functionality found in SetupDelete in resdll\ndquorum\setup.c.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CMajorityNodeSet::HrDeleteShare(
    LPCWSTR pcszGUIDIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    DWORD   sc;
    DWORD   cch;
    WCHAR   szPath[ MAX_PATH ];
    WCHAR   szGUID[ MAX_PATH ];

    //
    //  Both the directory and the share have '$' appended to them.
    //

    hr = THR( StringCchPrintfW( szGUID, ARRAYSIZE( szGUID ), L"%ws$", pcszGUIDIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    sc = NetShareDel( NULL, szGUID, 0 );
    if ( ( sc != NERR_Success ) && ( sc != NERR_NetNameNotFound ) )
    {
        TW32( sc );
        LogMsg( L"[SRV] CMajorityNodeSet::Cleanup: NetShareDel failed: %d, '%ws'.", sc, szGUID );
        // Don't goto Cleanup yet.  Try to delete the directory first.
    } // if: NetShareDel failed.

    LogMsg( L"CMajorityNodeSet::HrDeleteShare: share '%ws' deleted.", pcszGUIDIn );

    cch = GetWindowsDirectoryW( szPath, MAX_PATH );
    if ( cch == 0 )
    {
        sc = TW32( GetLastError() );
        LogMsg( L"[SRV] CMajorityNodeSet::Cleanup: GetWindowsDirectory failed: %d.", sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: GetWindowsDirectory failed.

    hr = THR( StringCchCatW( szPath, ARRAYSIZE( szPath ), SETUP_DIRECTORY_PREFIX ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( StringCchCatW( szPath, ARRAYSIZE( szPath ), szGUID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    sc = TW32( DwRemoveDirectory( szPath, 32 ) );
    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( L"[SRV] CMajorityNodeSet::Cleanup: DwRemoveDirectory '%ws': %d.", szPath, sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: unable to delete the directory structure

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::HrDeleteShare


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CMajorityNodeSet::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CMajorityNodeSet::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CMajorityNodeSet::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CMajorityNodeSet::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgManagedResourceInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
    } // else if: IClusCfgManagedResourceInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceCfg ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceCfg, this, 0 );
    } // else if: IClusCfgManagedResourceCfg
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceData ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceData, this, 0 );
    } // else if: IClusCfgManagedResourceData
    else if ( IsEqualIID( riidIn, IID_IClusCfgVerifyQuorum ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgVerifyQuorum, this, 0 );
    } // else if: IClusCfgVerifyQuorum
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING1( hr, riidIn, IID_IEnumClusCfgPartitions );

} //*** CMajorityNodeSet::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_MajorityNodeSet_GetUID_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( CLUS_RESTYPE_NAME_MAJORITYNODESET );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_MajorityNodeSet_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_MajorityNodeSet_GetName_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_bstrName == NULL )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if: m_bstrName is NULL

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_MajorityNodeSet_GetName_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszNameIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrName );
    m_bstrName = bstr;

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::IsManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManaged )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::IsManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetManaged(
    BOOL fIsManagedIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsManaged = fIsManagedIn;

    HRETURN( S_OK );

} //*** CMajorityNodeSet::SetManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::IsQuorumResource
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is the quorum device.
//
//      S_FALSE
//          The device is not the quorum device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::IsQuorumResource( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorum )
    {
        hr = S_OK;
    } // if:

    LOG_STATUS_REPORT_STRING(
                          L"Majority Node Set '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"is" : L"is not"
                        , hr
                        );

    HRETURN( hr );

} //*** CMajorityNodeSet::IsQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetQuorumResource
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetQuorumResource( BOOL fIsQuorumResourceIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    //
    //  If we are not quorum capable then we should not allow ourself to be
    //  made the quorum resource.
    //

    if ( ( fIsQuorumResourceIn ) && ( m_fIsQuorumCapable == FALSE ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_QUORUM_CAPABLE );
        goto Cleanup;
    } // if:

    m_fIsQuorum = fIsQuorumResourceIn;

Cleanup:

    LOG_STATUS_REPORT_STRING(
                          L"Setting Majority Node Set '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"to be" : L"to not be"
                        , hr
                        );

    HRETURN( hr );

} //*** CMajorityNodeSet::SetQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::IsQuorumCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is a quorum capable device.
//
//      S_FALSE
//          The device is not a quorum capable device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorumCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::IsQuorumCapable

//////////////////////////////////////////////////////////////////////////
//
//  CMajorityNodeSet::SetQuorumCapable
//
//  Description:
//      Call this to set whether the resource is capable to be the quorum
//      resource or not.
//
//  Parameter:
//      fIsQuorumCapableIn - If TRUE, the resource will be marked as quorum capable.
//
//  Return Values:
//      S_OK
//          Call succeeded.
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetQuorumCapable(
    BOOL fIsQuorumCapableIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsQuorumCapable = fIsQuorumCapableIn;

    HRETURN( hr );

} //*** CMajorityNodeSet::SetQuorumCapable

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_FALSE
//          There are not drive letters on this device.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( S_FALSE );

} //*** CMajorityNodeSet::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CMajorityNodeSet::SetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::IsManagedByDefault
//
//  Description:
//      Should this resource be managed by the cluster by default?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The device is managed by default.
//
//      S_FALSE
//          The device is not managed by default.
//
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::IsManagedByDefault( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManagedByDefault )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::IsManagedByDefault


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetManagedByDefault
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetManagedByDefault(
    BOOL fIsManagedByDefaultIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsManagedByDefault = fIsManagedByDefaultIn;

    HRETURN( S_OK );

} //*** CMajorityNodeSet::SetManagedByDefault


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet class -- IClusCfgManagedResourceCfg
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::PreCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::PreCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRESULT                     hr = S_OK;
    IClusCfgResourcePreCreate * pccrpc = NULL;

    hr = THR( punkServicesIn->TypeSafeQI( IClusCfgResourcePreCreate, &pccrpc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccrpc->SetType( (LPCLSID) &RESTYPE_MajorityNodeSet ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccrpc->SetClassType( (LPCLSID) &RESCLASSTYPE_StorageDevice ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    STATUS_REPORT_STRING( TASKID_Major_Configure_Resources, TASKID_Minor_MNS_PreCreate, IDS_INFO_MNS_PRECREATE, m_bstrName, hr );

    if ( pccrpc != NULL )
    {
        pccrpc->Release();
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::PreCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::Create
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::Create( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRESULT                     hr = S_OK;
    IClusCfgResourceCreate *    pccrc = NULL;

    hr = THR( punkServicesIn->TypeSafeQI( IClusCfgResourceCreate, &pccrc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    STATUS_REPORT_STRING( TASKID_Major_Configure_Resources, TASKID_Minor_MNS_Create, IDS_INFO_MNS_CREATE, m_bstrName, hr );

    if ( pccrc != NULL )
    {
        pccrc->Release();
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::PostCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::PostCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CMajorityNodeSet::PostCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::Evict
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::Evict( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CMajorityNodeSet::Evict


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet class -- IClusCfgManagedResourceData
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::GetResourcePrivateData
//
//  Description:
//      Return the private data for this resource when it is hosted on the
//      cluster.
//
//  Arguments:
//      pbBufferOut
//
//      pcbBufferInout
//
//  Return Value:
//      S_OK
//          Success
//
//      S_FALSE
//          No data available.
//
//      ERROR_INSUFFICIENT_BUFFER as an HRESULT
//          When the passed in buffer is too small to hold the data.
//          pcbBufferOutIn will contain the size required.
//
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::GetResourcePrivateData(
      BYTE *    pbBufferOut
    , DWORD *   pcbBufferInout
    )
{
    TraceFunc( "[IClusCfgManagedResourceData]" );
    Assert( pcbBufferInout != NULL );

    HRESULT     hr = S_OK;
    DWORD       cb;
    DWORD       cbTemp;
    HCLUSTER    hCluster = NULL;
    HRESOURCE   hResource = NULL;
    DWORD       sc;
    WCHAR *     pszResourceId = NULL;

    //
    //  Make sure we have a clean slate to start from.
    //

    m_cplPrivate.DeletePropList();

    //
    //  Attempt to retrieve the resource id from the cluster resource if we're already on a
    //  clustered node.
    //

    hr = HrIsClusterServiceRunning();
    if ( hr != S_OK )
    {
        // We must be on a node that is being added to a cluster.
        // As such we don't have anything to contribute.
        if ( FAILED( hr ) )
        {
            THR( hr );
            LogMsg( L"[SRV] CMajorityNodeSet::GetResourcePrivateData(): HrIsClusterServiceRunning failed: 0x%08x.\n", hr );
        } // if:

        goto Cleanup;
    } // if: cluster service is not running

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        sc = GetLastError();
        if ( sc == RPC_S_SERVER_UNAVAILABLE )
        {
            //
            //  We must be on a node that is being added to a cluster.
            //  As such we don't have anything to contribute.
            //

            hr = S_FALSE;
            LogMsg( L"[SRV] CMajorityNodeSet::GetResourcePrivateData(): This node is not clustered." );
        } // if:
        else
        {
            LogMsg( L"[SRV] CMajorityNodeSet::GetResourcePrivateData(): OpenCluster failed: %d.", sc );
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
        } // else:

        goto Cleanup;
    } // if: hCluster == NULL

    //
    //  Now, open the resource.  If we're on a clustered node and there is no MNS resource by the
    //  name that we've been given then that means we're a dummy resource that exists so that
    //  the middle tier doesn't get confused.  The resource doesn't actually exist, therefore we
    //  can't provide any private data for it.  Note: the dummy resource is created by the enum.
    //

    hResource = OpenClusterResource( hCluster, m_bstrName );
    if ( hResource == NULL )
    {
        sc = GetLastError();
        LogMsg(
                  L"[SRV] CMajorityNodeSet::GetResourcePrivateData(): OpenClusterResource '%ws' failed: %d."
                , ( m_bstrName == NULL ) ? L"<null>" : m_bstrName
                , sc
              );
        if ( sc == ERROR_RESOURCE_NOT_FOUND )
        {
            hr = S_FALSE;
        } // if:
        else
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
        } // else:

        goto Cleanup;
    } // if: OpenClusterResource failed

    //
    //  Get the resource ID from the cluster resource.  First try with a reasonable buffer size and then realloc
    //  and retry if the buffer wasn't big enough.
    //

    cb = 64 * sizeof( WCHAR );
    pszResourceId = new WCHAR[ cb / sizeof( WCHAR ) ];
    if ( pszResourceId == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: couldn't allocate more memory

    sc = ClusterResourceControl( hResource, NULL, CLUSCTL_RESOURCE_GET_ID, NULL, 0, (VOID *) pszResourceId, cb, &cb );
    if ( sc == ERROR_MORE_DATA )
    {
        // Reallocate and try again.
        delete [] pszResourceId;

        pszResourceId = new WCHAR[ cb / sizeof( WCHAR ) ];
        if ( pszResourceId == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if: couldn't allocate more memory

        sc = TW32( ClusterResourceControl( hResource, NULL, CLUSCTL_RESOURCE_GET_ID, NULL, 0, (VOID *) pszResourceId, cb, &cb ) );
    } // if: the buffer wasn't big enough
    else
    {
        TW32( sc );
    } // else:

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( L"[SRV] CMajorityNodeSet::GetResourcePrivateData(): ClusterResourceControl failed: %d.", sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: ClusterResourceControl failed

    //
    //   Now add the property to m_cplPrivate with the name "Resource ID".
    //

    sc = TW32( m_cplPrivate.ScAddProp( L"Resource ID", pszResourceId ) );
    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( L"[SRV] CMajorityNodeSet::GetResourcePrivateData(): ScAddProp failed: %d.", sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: ScAddProp failed

    cb = static_cast< DWORD >( m_cplPrivate.CbPropList() );
    cbTemp = *pcbBufferInout;
    *pcbBufferInout = cb;

    if ( cb > cbTemp )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_MORE_DATA ) );
        goto Cleanup;
    } // if:

    Assert( pbBufferOut != NULL );
    CopyMemory( pbBufferOut, m_cplPrivate.Plist(), cb );

    hr = S_OK;

Cleanup:

    delete [] pszResourceId;

    if ( hResource != NULL )
    {
        CloseClusterResource( hResource );
    } // if:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::GetResourcePrivateData


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetResourcePrivateData
//
//  Description:
//      Accept the private data for this resource from another hosted instance
//      when this node is being added to the cluster.  Note that this is not an
//      additive operation.
//
//  Arguments:
//      pcbBufferIn
//
//      cbBufferIn
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetResourcePrivateData(
      const BYTE *  pcbBufferIn
    , DWORD         cbBufferIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceData]" );

    HRESULT hr = S_OK;
    DWORD   sc;

    //
    //  Make sure we have a clean slate to start from.
    //

    m_cplPrivate.DeletePropList();

    //
    //  If we didn't get passed anything we can't copy anything.
    //

    if ( ( pcbBufferIn == NULL ) || ( cbBufferIn == 0 ) )
    {
        hr = S_OK;
        goto Cleanup;
    } // if: no data to set

    sc = TW32( m_cplPrivate.ScCopy( (PCLUSPROP_LIST) pcbBufferIn, cbBufferIn ) );
    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( L"[SRV] CMajorityNodeSet::SetResourcePrivateData: ScCopy failed: %d.", sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: ScCopy failed

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::SetResourcePrivateData


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet class -- IClusCfgVerifyQuorum
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::PrepareToHostQuorumResource
//
//  Description:
//      Do any configuration necessary in preparation for this node hosting
//      the quorum.
//
//      In this class we need to ensure that we can connect to the proper
//      disk share.  The data about what share to connect to should have
//      already been set using SetResourcePrivateData() above.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::PrepareToHostQuorumResource( void )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRESULT hr = S_OK;
    DWORD   sc;
    WCHAR * pszResId = NULL;
    CLUSPROP_BUFFER_HELPER cpbh;

    if ( m_cplPrivate.BIsListEmpty() )
    {
        hr = S_OK;
        goto Cleanup;
    } // if:

    //
    //  Verify that our resource ID exists.  If it doesn't we can't
    //  do anything, so return an error.
    //

    sc = TW32( m_cplPrivate.ScMoveToPropertyByName( L"Resource ID" ) );
    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( L"[SRV] CMajorityNodeSet::PrepareToHostQuorum: move to property failed: %d.", sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: ScMoveToPropertyByName failed

    cpbh = m_cplPrivate.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    pszResId = (WCHAR *) cpbh.pStringValue->sz;
    Assert( pszResId != NULL );
    Assert( wcslen( pszResId ) < MAX_PATH );

    hr = HrSetupShare( pszResId );

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::PrepareToHostQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::Cleanup
//
//  Description:
//      Do any necessay cleanup from the PrepareToHostQuorumResource()
//      method.
//
//      If the cleanup method is anything other than successful completion
//      then the share needs to be torn down.
//
//  Arguments:
//      cccrReasonIn
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::Cleanup(
      EClusCfgCleanupReason cccrReasonIn
    )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    WCHAR *                 pszResId;
    CLUSPROP_BUFFER_HELPER  cpbh;

    if ( cccrReasonIn != crSUCCESS )
    {
        //
        //  If the list is empty then we did not participate in the quorum selection
        //  process and have nothing to cleanup.
        //

        if ( m_cplPrivate.BIsListEmpty() )
        {
            hr = S_OK;
            goto Cleanup;
        } // if:

        //
        //  Have we actually added a share?
        //

        if ( m_fAddedShare == FALSE )
        {
            hr = S_OK;
            goto Cleanup;
        } // if:

        //
        //  Verify that our resource ID exists.  If it doesn't we can't
        //  do anything, so return an error.
        //

        sc = TW32( m_cplPrivate.ScMoveToPropertyByName( L"Resource ID" ) );
        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( L"[SRV] CMajorityNodeSet::PrepareToHostQuorum: move to property failed: %d.", sc );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        }

        cpbh = m_cplPrivate.CbhCurrentValue();
        Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

        pszResId = (WCHAR *) cpbh.pStringValue->sz;
        if ( pszResId == NULL || wcslen( pszResId ) > MAX_PATH )
        {
            hr = THR( E_POINTER );
            goto Cleanup;
        } // if: pszResId is NULL or too long

        hr = HrDeleteShare( pszResId );
    } // if: !crSUCCESS

Cleanup:

    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_MajorityNodeSet_Cleanup, IDS_ERROR_MNS_CLEANUP, hr );
    } // if: we had an error

    HRETURN( hr );

} //*** CMajorityNodeSet::Cleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::IsMultiNodeCapable
//
//  Description:
//      Does this quorum resource support multi node clusters?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The resource allows multi node clusters.
//
//      S_FALSE
//          The resource does not allow multi node clusters.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::IsMultiNodeCapable( void )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsMultiNodeCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::IsMultiNodeCapable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetMultiNodeCapable
//
//  Description:
//      Sets the multi node capable flag
//
//  Arguments:
//      fMultiNodeCapableIn
//          The flag telling this instance whether or not it should support
//          Multi node clusters.
//
//  Return Value:
//      S_OK
//          Success.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetMultiNodeCapable(
    BOOL fMultiNodeCapableIn
    )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    m_fIsMultiNodeCapable = fMultiNodeCapableIn;

    HRETURN( S_OK );

} //*** CMajorityNodeSet::IsMultiNodeCapable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cphysicaldisk.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CPhysicalDisk.cpp
//
//  Description:
//      This file contains the definition of the CPhysicalDisk
//       class.
//
//      The class CPhysicalDisk represents a cluster manageable
//      device. It implements the IClusCfgManagedResourceInfo interface.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CPhysicalDisk.h"
#include "CClusCfgPartitionInfo.h"
#include <devioctl.h>
#include <ntddvol.h>
#include <ntddstor.h>
#include <ntddscsi.h>

#define _NTSCSI_USER_MODE_
#include <scsi.h>
#undef  _NTSCSI_USER_MODE_

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CPhysicalDisk" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::S_HrCreateInstance
//
//  Description:
//      Create a CPhysicalDisk instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CPhysicalDisk instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    CPhysicalDisk * ppd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    ppd = new CPhysicalDisk();
    if ( ppd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( ppd->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( ppd->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: QI failed

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CPhysicalDisk::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( ppd != NULL )
    {
        ppd->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::CPhysicalDisk
//
//  Description:
//      Constructor of the CPhysicalDisk class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CPhysicalDisk::CPhysicalDisk( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_pIWbemServices == NULL );
    Assert( m_bstrName == NULL );
    Assert( m_bstrDeviceID == NULL );
    Assert( m_bstrDescription == NULL );
    Assert( m_idxNextPartition == 0 );
    Assert( m_ulSCSIBus == 0 );
    Assert( m_ulSCSITid == 0 );
    Assert( m_ulSCSIPort == 0 );
    Assert( m_ulSCSILun == 0 );
    Assert( m_idxEnumPartitionNext == 0 );
    Assert( m_prgPartitions == NULL );
    Assert( m_lcid == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_dwSignature == 0 );
    Assert( m_bstrFriendlyName == NULL );
//    Assert( m_bstrFirmwareSerialNumber == NULL );
    Assert( m_fIsManaged == FALSE );
    Assert( m_fIsManagedByDefault == FALSE );
    Assert( m_cPartitions == 0 );
    Assert( m_idxDevice == 0 );
    Assert( m_fIsDynamicDisk == FALSE );
    Assert( m_fIsGPTDisk == FALSE );

    TraceFuncExit();

} //*** CPhysicalDisk::CPhysicalDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::~CPhysicalDisk
//
//  Description:
//      Desstructor of the CPhysicalDisk class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CPhysicalDisk::~CPhysicalDisk( void )
{
    TraceFunc( "" );

    ULONG   idx;

    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrDeviceID );
    TraceSysFreeString( m_bstrDescription );
    TraceSysFreeString( m_bstrFriendlyName );
//    TraceSysFreeString( m_bstrFirmwareSerialNumber );

    for ( idx = 0; idx < m_idxNextPartition; idx++ )
    {
        ((*m_prgPartitions)[ idx ])->Release();
    } // for:

    TraceFree( m_prgPartitions );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CPhysicalDisk::~CPhysicalDisk


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CPhysicalDisk::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    CRETURN( m_cRef );

} //*** CPhysicalDisk::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CPhysicalDisk::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    CRETURN( cRef );

} //*** CPhysicalDisk::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgManagedResourceInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
    } // else if: IClusCfgManagedResourceInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgWbemServices ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
    } // else if: IClusCfgWbemServices
    else if ( IsEqualIID( riidIn, IID_IClusCfgSetWbemObject ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgSetWbemObject, this, 0 );
    } // else if: IClusCfgSetWbemObject
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgPartitions ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgPartitions, this, 0 );
    } // else if: IEnumClusCfgPartitions
    else if ( IsEqualIID( riidIn, IID_IClusCfgPhysicalDiskProperties ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgPhysicalDiskProperties, this, 0 );
    } // else if: IClusCfgPhysicalDiskProperties
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceCfg ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceCfg, this, 0 );
    } // else if: IClusCfgManagedResourceCfg
    else if ( IsEqualIID( riidIn, IID_IClusCfgVerifyQuorum ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgVerifyQuorum, this, 0 );
    } // else if: IClusCfgVerifyQuorum
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING1(
          hr
        , riidIn
        , IID_IClusCfgManagedResourceData
        );

} //*** CPhysicalDisk::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_PhysDisk, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IEnumClusCfgPartitions interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Next
//
//  Description:
//
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The rgpPartitionInfoOut param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Next(
    ULONG                       cNumberRequestedIn,
    IClusCfgPartitionInfo **    rgpPartitionInfoOut,
    ULONG *                     pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT                 hr = S_FALSE;
    ULONG                   cFetched = 0;
    ULONG                   idx;
    IClusCfgPartitionInfo * piccpi = NULL;

    if ( rgpPartitionInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Next_PhysDisk, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = 0;
    } // if:

    if ( m_prgPartitions == NULL )
    {
        LOG_STATUS_REPORT_MINOR( TASKID_Minor_PhysDisk_No_Partitions, L"A physical disk does not have a partitions enumerator", hr );
        goto Cleanup;
    } // if:

    cFetched = min( cNumberRequestedIn, ( m_idxNextPartition - m_idxEnumPartitionNext ) );

    for ( idx = 0; idx < cFetched; idx++, m_idxEnumPartitionNext++ )
    {
        hr = THR( ((*m_prgPartitions)[ m_idxEnumPartitionNext ])->TypeSafeQI( IClusCfgPartitionInfo, &piccpi ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"CPhysicalDisk::Next() could not query for IClusCfgPartitionInfo.", hr );
            break;
        } // if:

        rgpPartitionInfoOut[ idx ] = piccpi;
    } // for:

    if ( FAILED( hr ) )
    {
        ULONG   idxStop = idx;

        m_idxEnumPartitionNext -= idx;

        for ( idx = 0; idx < idxStop; idx++ )
        {
            (rgpPartitionInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;
        goto Cleanup;
    } // if:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Skip
//
//  Description:
//
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = S_OK;

    m_idxEnumPartitionNext += cNumberToSkipIn;
    if ( m_idxEnumPartitionNext > m_idxNextPartition )
    {
        m_idxEnumPartitionNext = m_idxNextPartition;
        hr = S_FALSE;
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Reset
//
//  Description:
//
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Reset( void )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = S_OK;

    m_idxEnumPartitionNext = 0;

    HRETURN( hr );

} //*** CPhysicalDisk::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Clone
//
//  Description:
//
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The ppEnumClusCfgPartitionsOut param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Clone( IEnumClusCfgPartitions ** ppEnumClusCfgPartitionsOut )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgPartitionsOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_Clone_PhysDisk, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Count
//
//  Description:
//
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pnCountOut param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = THR( S_OK );

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pnCountOut = m_cPartitions;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IClusCfgSetWbemObject interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetWbemObject
//
//  Description:
//      Set the disk information information provider.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetWbemObject(
      IWbemClassObject *    pDiskIn
    , bool *                pfRetainObjectOut
    )
{
    TraceFunc( "[IClusCfgSetWbemObject]" );
    Assert( pDiskIn != NULL );
    Assert( pfRetainObjectOut != NULL );

    HRESULT hr = S_FALSE;
    VARIANT var;
    CLSID   clsidMinorId;

    m_fIsQuorumCapable = TRUE;
    m_fIsQuorumResourceMultiNodeCapable = TRUE;

    VariantInit( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"Name", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( HrCreateFriendlyName( var.bstrVal ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrDeviceID = TraceSysAllocString( var.bstrVal );
    if (m_bstrDeviceID == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"Description", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrDescription = TraceSysAllocString( var.bstrVal );
    if ( m_bstrDescription == NULL  )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"SCSIBus", VT_I4, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_ulSCSIBus = var.lVal;

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"SCSITargetId", VT_I4, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_ulSCSITid = var.lVal;

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"SCSIPort", VT_I4, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_ulSCSIPort = var.lVal;

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"SCSILogicalUnit", VT_I4, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_ulSCSILun = var.lVal;

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"Index", VT_I4, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_idxDevice = var.lVal;

    VariantClear( &var );

    hr = HrGetWMIProperty( pDiskIn, L"Signature", VT_I4, &var );
    if ( hr == WBEM_E_NOT_FOUND )
    {
        //
        //  If the signature is not found then log it and let everything continue.
        //

        LOG_STATUS_REPORT_STRING( L"Physical disk %1!ws! does not have a signature property.", m_bstrName, hr );
        var.lVal = 0L;
        hr = S_OK;
    } // if:

    if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    } // if:

    //
    //  Did we actually get a value?  Could be VT_NULL to indicate that it is empty.
    //  We only want VT_I4 values...
    //

    if ( var.vt == VT_I4 )
    {
        m_dwSignature = (DWORD) var.lVal;
    } // else if:

    LOG_STATUS_REPORT_STRING2( L"Physical disk %1!ws! has signature %2!x!.", m_bstrName, m_dwSignature, hr );

    if ( FAILED( hr ) )
    {
        STATUS_REPORT_REF(
                  TASKID_Major_Find_Devices
                , TASKID_Minor_PhysDisk_Signature
                , IDS_ERROR_PHYSDISK_SIGNATURE
                , IDS_ERROR_PHYSDISK_SIGNATURE_REF
                , hr
                );
        THR( hr );
        goto Cleanup;
    } // if:

    VariantClear( &var );

    hr = STHR( HrGetPartitionInfo( pDiskIn, pfRetainObjectOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  KB: 28-JUL-2000 GalenB
    //
    //  HrGetPartitionInfo() returns S_FALSE when it cannot get the partition info for a disk.
    //  This is usually caused by the disk already being under ClusDisk control.  This is not
    //  and error, it just means we cannot query the partition or logical drive info.
    //
    if ( hr == S_OK )
    {
        hr = STHR( HrCreateFriendlyName() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  Since we have partition info we also have a signature and need to see if this
        //  disk is cluster capable.

        hr = STHR( HrIsClusterCapable() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  If the disk is not cluster capable then we don't want the enumerator
        //  to keep it.
        //
        if ( hr == S_FALSE )
        {
            HRESULT hrTemp;

            STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_PhysDisk_Cluster_Capable, IDS_INFO_PHYSDISK_CLUSTER_CAPABLE, hr );

            hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
            if ( FAILED( hrTemp ) )
            {
                LOG_STATUS_REPORT( L"Could not create a guid for a not cluster capable disk minor task ID", hrTemp );
                clsidMinorId = IID_NULL;
            } // if:

            *pfRetainObjectOut = false;
            STATUS_REPORT_STRING_REF(
                      TASKID_Minor_PhysDisk_Cluster_Capable
                    , clsidMinorId
                    , IDS_INFO_PHYSDISK_NOT_CLUSTER_CAPABLE
                    , m_bstrFriendlyName
                    , IDS_INFO_PHYSDISK_NOT_CLUSTER_CAPABLE_REF
                    , hr
                    );
            LOG_STATUS_REPORT_STRING( L"The '%1!ws!' physical disk is not cluster capable", m_bstrFriendlyName, hr );
        } // if:
/*        else
        {
            hr = THR( HrProcessMountPoints() );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:
        } // else:
*/
    } // if:

    //
    //  TODO:   15-MAR-2001 GalenB
    //
    //  Need to check this error code when this feature is complete!
    //
    //hr = THR( HrGetDiskFirmwareSerialNumber() );

    //THR( HrGetDiskFirmwareVitalData() );

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemObject_PhysDisk, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    VariantClear( &var );

    HRETURN( hr );

} //*** CPhysicalDisk::SetWbemObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::GetUID
//
//  Description:
//
//  Arguments:
//      pbstrUIDOut
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;
    WCHAR   sz[ 256 ];

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_PhysDisk_GetUID_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    hr = THR( StringCchPrintfW( sz, ARRAYSIZE( sz ), L"SCSI Tid %ld, SCSI Lun %ld", m_ulSCSITid, m_ulSCSILun ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( sz );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_PhysDisk_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    //
    //  Prefer the "friendly" name over the WMI name -- if we have it...
    //
    if ( m_bstrFriendlyName != NULL )
    {
        *pbstrNameOut = SysAllocString( m_bstrFriendlyName );
    } // if:
    else
    {
        LOG_STATUS_REPORT_STRING( L"There is not a \"friendly name\" for the physical disk \"%1!ws!\".", m_bstrName, hr );
        *pbstrNameOut = SysAllocString( m_bstrName );
    } // else:

    if (*pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ws'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszNameIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetName_PhysDisk, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrName );
    m_bstrName = bstr;

    //
    // Since we got asked from the outside to set a new name, this should actually be reflected in
    // the friendly name, too, since that, ultimately, gets preference over the real name
    //
    hr = HrSetFriendlyName( pcszNameIn );

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::IsManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManaged )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::IsManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetManaged
//
//  Description:
//
//  Arguments:
//      fIsManagedIn
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetManaged(
    BOOL fIsManagedIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsManaged = fIsManagedIn;

    LOG_STATUS_REPORT_STRING2(
                          L"Physical disk '%1!ws!' '%2!ws!"
                        , ( m_bstrFriendlyName != NULL ) ? m_bstrFriendlyName : m_bstrName
                        , m_fIsManaged ? L"is managed" : L"is not managed"
                        , hr
                        );

    HRETURN( hr );

} //*** CPhysicalDisk::SetManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::IsQuorumResource
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is the quorum device.
//
//      S_FALSE
//          The device is not the quorum device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::IsQuorumResource( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorumResource )
    {
        hr = S_OK;
    } // if:

    LOG_STATUS_REPORT_STRING2(
                          L"Physical disk '%1!ws!' '%2!ws!' the quorum device."
                        , ( m_bstrFriendlyName != NULL ) ? m_bstrFriendlyName : m_bstrDeviceID
                        , m_fIsQuorumResource ? L"is" : L"is not"
                        , hr
                        );

    HRETURN( hr );

} //*** CPhysicalDisk::IsQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetQuorumResource
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetQuorumResource( BOOL fIsQuorumResourceIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    //
    //  Since no accurate determination can be made about a disk's quorum capability
    //  when the node that it's on does not hold the SCSI reservation and have access
    //  to the media we must blindly accept the input given...
    //

/*
    //
    //  If we are not quorum capable then we should not allow ourself to be
    //  made the quorum resource.
    //

    if ( ( fIsQuorumResourceIn ) && ( m_fIsQuorumCapable == FALSE ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_QUORUM_CAPABLE );
        goto Cleanup;
    } // if:
*/

    m_fIsQuorumResource = fIsQuorumResourceIn;

    LOG_STATUS_REPORT_STRING2(
                          L"Setting physical disk '%1!ws!' '%2!ws!' the quorum device."
                        , ( m_bstrFriendlyName != NULL ) ? m_bstrFriendlyName : m_bstrDeviceID
                        , m_fIsQuorumResource ? L"to be" : L"to not be"
                        , hr
                        );

//Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::SetQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::IsQuorumCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is a quorum capable device.
//
//      S_FALSE
//          The device is not a quorum capable device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorumCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::IsQuorumCapable

//////////////////////////////////////////////////////////////////////////
//
//  CPhysicalDisk::SetQuorumCapable
//
//  Description:
//      Call this to set whether the resource is capable to be the quorum
//      resource or not.
//
//  Parameter:
//      fIsQuorumCapableIn - If TRUE, the resource will be marked as quorum capable.
//
//  Return Values:
//      S_OK
//          Call succeeded.
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetQuorumCapable(
    BOOL fIsQuorumCapableIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsQuorumCapable = fIsQuorumCapableIn;

    HRETURN( hr );

} //*** CPhysicalDisk::SetQuorumCapable

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT                 hr = S_FALSE;
    IClusCfgPartitionInfo * piccpi = NULL;
    ULONG                   idx;

    if ( pdlmDriveLetterMappingOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_GetDriveLetterMappings_PhysDisk, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    for ( idx = 0; idx < m_idxNextPartition; idx++ )
    {
        hr = ( ((*m_prgPartitions)[ idx ])->TypeSafeQI( IClusCfgPartitionInfo, &piccpi ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = STHR( piccpi->GetDriveLetterMappings( pdlmDriveLetterMappingOut ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        piccpi->Release();
        piccpi = NULL;
    } // for:

Cleanup:

    if ( piccpi != NULL )
    {
        piccpi->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CPhysicalDisk::SetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::IsManagedByDefault
//
//  Description:
//      Should this resource be managed by the cluster by default?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The device is managed by default.
//
//      S_FALSE
//          The device is not managed by default.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::IsManagedByDefault( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManagedByDefault )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::IsManagedByDefault


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetManagedByDefault
//
//  Description:
//
//  Arguments:
//      fIsManagedByDefaultIn
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetManagedByDefault(
    BOOL fIsManagedByDefaultIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsManagedByDefault = fIsManagedByDefaultIn;

    LOG_STATUS_REPORT_STRING2(
                          L"Physical disk '%1!ws!' '%2!ws!"
                        , ( m_bstrFriendlyName != NULL ) ? m_bstrFriendlyName : m_bstrName
                        , fIsManagedByDefaultIn ? L"is manageable" : L"is not manageable"
                        , hr
                        );

    HRETURN( hr );

} //*** CPhysicalDisk::SetManagedByDefault


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk class -- IClusCfgPhysicalDiskProperties Interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::IsThisLogicalDisk
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::IsThisLogicalDisk( WCHAR cLogicalDiskIn )
{
    TraceFunc( "[IClusCfgPhysicalDiskProperties]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           idx;
    IClusCfgPartitionProperties *   piccpp = NULL;

    for ( idx = 0; idx < m_idxNextPartition; idx++ )
    {
        hr = ( ((*m_prgPartitions)[ idx ])->TypeSafeQI( IClusCfgPartitionProperties, &piccpp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = STHR( piccpp->IsThisLogicalDisk( cLogicalDiskIn ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            break;
        } // if:

        piccpp->Release();
        piccpp = NULL;
    } // for:

Cleanup:

    if ( piccpp != NULL )
    {
        piccpp->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::IsThisLogicalDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetSCSIBus
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrGetSCSIBus( ULONG * pulSCSIBusOut )
{
    TraceFunc( "[IClusCfgPhysicalDiskProperties]" );

    HRESULT hr = S_OK;

    if ( pulSCSIBusOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrGetSCSIBus, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pulSCSIBusOut = m_ulSCSIBus;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetSCSIBus


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetSCSIPort
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrGetSCSIPort( ULONG * pulSCSIPortOut )
{
    TraceFunc( "[IClusCfgPhysicalDiskProperties]" );

    HRESULT hr = S_OK;

    if ( pulSCSIPortOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrGetSCSIPort, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pulSCSIPortOut = m_ulSCSIPort;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetSCSIPort


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetDeviceID
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrGetDeviceID( BSTR * pbstrDeviceIDOut )
{
    TraceFunc( "" );
    Assert( m_bstrDeviceID != NULL );

    HRESULT hr = S_OK;

    if ( pbstrDeviceIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrGetDeviceID_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pbstrDeviceIDOut = TraceSysAllocString( m_bstrDeviceID );
    if ( *pbstrDeviceIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrGetDeviceID_Memory, IDS_ERROR_OUTOFMEMORY, IDS_ERROR_OUTOFMEMORY_REF, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetDeviceID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetSignature
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrGetSignature( DWORD * pdwSignatureOut )
{
    TraceFunc( "" );
    Assert( m_dwSignature != 0 );

    HRESULT hr = S_OK;

    if ( pdwSignatureOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT_REF( TASKID_Major_Find_Devices, TASKID_Minor_HrGetSignature_Pointer, IDS_ERROR_NULL_POINTER, IDS_ERROR_NULL_POINTER_REF, hr );
        goto Cleanup;
    } // if:

    *pdwSignatureOut = m_dwSignature;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetSignature


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrSetFriendlyName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrSetFriendlyName( LPCWSTR pcszFriendlyNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszFriendlyNameIn = '%ws'", pcszFriendlyNameIn == NULL ? L"<null>" : pcszFriendlyNameIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszFriendlyNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszFriendlyNameIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrSetFriendlyName_PhysDisk, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrFriendlyName );
    m_bstrFriendlyName = bstr;

    LOG_STATUS_REPORT_STRING( L"Setting physical disk friendly name to \"%1!ws!\".", m_bstrFriendlyName, hr );

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrSetFriendlyName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetDeviceIndex
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrGetDeviceIndex( DWORD * pidxDeviceOut )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( pidxDeviceOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pidxDeviceOut = m_idxDevice;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetDeviceIndex


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::CanBeManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::CanBeManaged( void )
{
    TraceFunc( "[IClusCfgPhysicalDiskProperties]" );

    HRESULT                         hr = S_OK;
    ULONG                           idx;
    IClusCfgPartitionProperties *   piccpp = NULL;

    //
    //  Turn off the manageable state because this disk may already be managed by
    //  another node, or it may be RAW.
    //

    m_fIsManagedByDefault = FALSE;

    //
    //  A disk must have at least one NTFS partition in order to be a quorum
    //  resource.
    //

    m_fIsQuorumCapable = FALSE;
    m_fIsQuorumResourceMultiNodeCapable = FALSE;

    //
    //  If this disk has no partitions then it may already be managed by
    //  another node, or it may be RAW.
    //

    if ( m_idxNextPartition == 0 )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    //
    //  Enum the partitions and set the quorum capable flag if an NTFS
    //  partition is found.
    //

    for ( idx = 0; idx < m_idxNextPartition; idx++ )
    {
        hr = ( ((*m_prgPartitions)[ idx ])->TypeSafeQI( IClusCfgPartitionProperties, &piccpp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = STHR( piccpp->IsNTFS() );
        if ( hr == S_OK )
        {
            m_fIsQuorumCapable = TRUE;
            m_fIsQuorumResourceMultiNodeCapable = TRUE;
            m_fIsManagedByDefault = TRUE;
            break;
        } // if:

        piccpp->Release();
        piccpp = NULL;
    } // for:

Cleanup:

    LOG_STATUS_REPORT_STRING2(
          L"Physical disk '%1!ws!' %2!ws! quorum capable."
        , ( ( m_bstrFriendlyName != NULL ) ? m_bstrFriendlyName : m_bstrName )
        , ( ( m_fIsQuorumCapable == TRUE ) ? L"is" : L"is NOT" )
        , hr
        );

    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"CPhysicalDisk::CanBeManaged failed.", hr );
    } // if:

    if ( piccpp != NULL )
    {
        piccpp->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::CanBeManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrIsDynamicDisk
//
//  Description:
//      Is this disk a "dynamic" disk?  Dynamic disks are those disks that
//      contain LDM partitions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          This is a dynamic disk.
//
//      S_FALSE
//          This is not a dynamic disk.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrIsDynamicDisk( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( m_fIsDynamicDisk == FALSE )
    {
        hr = S_FALSE;
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::HrIsDynamicDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrIsGPTDisk
//
//  Description:
//      Is this disk a "GPT" disk?  GPT disks are those disks that
//      contain GPT partitions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          This is a GPT disk.
//
//      S_FALSE
//          This is not a GPT disk.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrIsGPTDisk( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( m_fIsGPTDisk == FALSE )
    {
        hr = S_FALSE;
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::HrIsGPTDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetDiskNames
//
//  Description:
//      Get the names of this disk, both its friendly and device names.
//
//  Arguments:
//      pbstrDiskNameOut
//
//      pbstrDeviceNameOut
//
//  Return Value:
//      S_OK
//          Success;
//
//      E_OUTOFMEMORY
//
//      E_POINTER
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrGetDiskNames(
      BSTR * pbstrDiskNameOut
    , BSTR * pbstrDeviceNameOut
    )
{
    TraceFunc( "" );
    Assert( m_bstrName != NULL );
    Assert( m_bstrFriendlyName != NULL );

    Assert( pbstrDiskNameOut != NULL );
    Assert( pbstrDeviceNameOut != NULL );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( ( pbstrDiskNameOut == NULL ) || ( pbstrDeviceNameOut == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( m_bstrFriendlyName );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    *pbstrDiskNameOut = bstr;
    bstr = NULL;

    bstr = TraceSysAllocString( m_bstrName );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    *pbstrDeviceNameOut = bstr;
    bstr = NULL;

Cleanup:

    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetDiskNames


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk class -- IClusCfgManagedResourceCfg
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::PreCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::PreCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRESULT                     hr = S_OK;
    IClusCfgResourcePreCreate * pccrpc = NULL;
    BSTR                        bstr = m_bstrFriendlyName != NULL ? m_bstrFriendlyName : m_bstrName;

    hr = THR( punkServicesIn->TypeSafeQI( IClusCfgResourcePreCreate, &pccrpc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccrpc->SetType( (LPCLSID) &RESTYPE_PhysicalDisk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccrpc->SetClassType( (LPCLSID) &RESCLASSTYPE_StorageDevice ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

#if 0 // test code only
    hr = THR( pccrpc->SetDependency( (LPCLSID) &IID_NULL, dfSHARED ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
#endif // test code only

Cleanup:

    STATUS_REPORT_STRING( TASKID_Major_Configure_Resources, TASKID_Minor_PhysDisk_PreCreate, IDS_INFO_PHYSDISK_PRECREATE, bstr, hr );

    if ( pccrpc != NULL )
    {
        pccrpc->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::PreCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Create
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Create( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRESULT                     hr = S_OK;
    IClusCfgResourceCreate *    pccrc = NULL;
    BSTR *                      pbstr = m_bstrFriendlyName != NULL ? &m_bstrFriendlyName : &m_bstrName;

    hr = THR( punkServicesIn->TypeSafeQI( IClusCfgResourceCreate, &pccrc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( m_dwSignature != 0 )
    {
        LOG_STATUS_REPORT_STRING2( L"Setting signature to \"%1!u!\" on resource \"%2!ws!\".", m_dwSignature, *pbstr, hr );
        hr = THR( pccrc->SetPropertyDWORD( L"Signature", m_dwSignature ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

Cleanup:

    STATUS_REPORT_STRING( TASKID_Major_Configure_Resources, TASKID_Minor_PhysDisk_Create, IDS_INFO_PHYSDISK_CREATE, *pbstr, hr );

    if ( pccrc != NULL )
    {
        pccrc->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::PostCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::PostCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CPhysicalDisk::PostCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Evict
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Evict( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CPhysicalDisk::Evict


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CPhysicalDisk::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetPartitionInfo
//
//  Description:
//      Gather the partition information.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrGetPartitionInfo(
      IWbemClassObject *    pDiskIn
    , bool *                pfRetainObjectOut
    )
{
    TraceFunc( "" );
    Assert( pDiskIn != NULL );
    Assert( pfRetainObjectOut != NULL );

    HRESULT                 hr;
    VARIANT                 var;
    VARIANT                 varDiskName;
    WCHAR                   szBuf[ 256 ];
    IEnumWbemClassObject *  pPartitions = NULL;
    IWbemClassObject *      pPartition = NULL;
    ULONG                   ulReturned;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrWQL = NULL;
    DWORD                   cPartitions;


    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetPartitionInfo, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    VariantInit( &var );
    VariantInit( &varDiskName );

    //
    //  Need to enum the partition(s) of this disk to determine if it is booted
    //  bootable.
    //
    hr = THR( HrGetWMIProperty( pDiskIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( StringCchPrintfW(
                  szBuf
                , ARRAYSIZE( szBuf )
                , L"Associators of {Win32_DiskDrive.DeviceID='%ws'} where AssocClass=Win32_DiskDriveToDiskPartition"
                , var.bstrVal
                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    bstrQuery = TraceSysAllocString( szBuf );
    if ( bstrQuery == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetPartitionInfo, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pPartitions ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_STRING_REF(
                TASKID_Major_Find_Devices
                , TASKID_Minor_WMI_DiskDrivePartitions_Qry_Failed
                , IDS_ERROR_WMI_DISKDRIVEPARTITIONS_QRY_FAILED
                , var.bstrVal
                , IDS_ERROR_WMI_DISKDRIVEPARTITIONS_QRY_FAILED_REF
                , hr
                );
        goto Cleanup;
    } // if:

    for ( cPartitions = 0; ; cPartitions++ )
    {
        hr = STHR( pPartitions->Next( WBEM_INFINITE, 1, &pPartition, &ulReturned ) );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {

            hr = STHR( HrIsPartitionLDM( pPartition ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  If the partition is logical disk manager (LDM)  then we cannot accept this disk therefore cannot manage it.
            //

            if ( hr == S_OK )
            {
                m_fIsDynamicDisk = TRUE;
            } // if:

            hr = STHR( HrIsPartitionGPT( pPartition ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                m_fIsGPTDisk = TRUE;
            } // if:

            hr = THR( HrCreatePartitionInfo( pPartition ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            pPartition->Release();
            pPartition = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING_REF(
                      TASKID_Major_Find_Devices
                    , TASKID_Minor_WQL_Partition_Qry_Next_Failed
                    , IDS_ERROR_WQL_QRY_NEXT_FAILED
                    , bstrQuery
                    , IDS_ERROR_WQL_QRY_NEXT_FAILED_REF
                    , hr
                    );
            goto Cleanup;
        } // else:
    } // for:

    //
    //  The enumerator can be empty because we cannot read the partition info from
    //  clustered disks.  If the enumerator was empty retain the S_FALSE, otherwise
    //  return S_OK if count is greater than 0.
    //

    if ( cPartitions > 0 )
    {
        hr = S_OK;
    } // if:
    else
    {
        LOG_STATUS_REPORT_STRING( L"The physical disk '%1!ws!' does not have any partitions and will not be managed", var.bstrVal, hr );
        m_fIsManagedByDefault = FALSE;
    } // else:

Cleanup:

    VariantClear( &var );
    VariantClear( &varDiskName );

    TraceSysFreeString( bstrQuery );
    TraceSysFreeString( bstrWQL );

    if ( pPartition != NULL )
    {
        pPartition->Release();
    } // if:

    if ( pPartitions != NULL )
    {
        pPartitions->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetPartitionInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrAddPartitionToArray
//
//  Description:
//      Add the passed in partition to the array of punks that holds the
//      partitions.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrAddPartitionToArray( IUnknown * punkIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgPartitions, sizeof( IUnknown * ) * ( m_idxNextPartition + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrAddPartitionToArray, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    m_prgPartitions = prgpunks;

    (*m_prgPartitions)[ m_idxNextPartition++ ] = punkIn;
    punkIn->AddRef();
    m_cPartitions += 1;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrAddPartitionToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrCreatePartitionInfo
//
//  Description:
//      Create a partition info from the passes in WMI partition.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      S_FALSE
//          The file system was not NTFS.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrCreatePartitionInfo( IWbemClassObject * pPartitionIn )
{
    TraceFunc( "" );
    Assert( m_bstrDeviceID != NULL );

    HRESULT                 hr = S_OK;
    IUnknown *              punk = NULL;
    IClusCfgSetWbemObject * piccswo = NULL;
    bool                    fRetainObject = true;

    hr = THR( CClusCfgPartitionInfo::S_HrCreateInstance( &punk, m_bstrDeviceID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CClusCfgPartitionInfo", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgSetWbemObject, &piccswo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccswo->SetWbemObject( pPartitionIn, &fRetainObject ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( fRetainObject )
    {
        hr = THR( HrAddPartitionToArray( punk ) );
    } // if:

Cleanup:

    if ( piccswo != NULL )
    {
        piccswo->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::HrCreatePartitionInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrCreateFriendlyName
//
//  Description:
//      Create a cluster friendly name.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      S_FALSE
//          Success, but a friendly name could not be created.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrCreateFriendlyName( void )
{
    TraceFunc( "" );

    HRESULT                         hr = S_FALSE;
    WCHAR *                         psz = NULL;
    WCHAR *                         pszTmp = NULL;
    DWORD                           cch;
    DWORD                           idx;
    IClusCfgPartitionProperties *   piccpp = NULL;
    BSTR                            bstrName = NULL;
    bool                            fFoundLogicalDisk = false;
    BSTR                            bstr = NULL;
    BSTR                            bstrDisk = NULL;

    if ( m_idxNextPartition == 0 )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_DISK, &bstrDisk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    cch = (UINT) wcslen( bstrDisk ) + 1;

    psz = new WCHAR[ cch ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( StringCchCopyW( psz, cch, bstrDisk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    for ( idx = 0; idx < m_idxNextPartition; idx++ )
    {
        hr = THR( ((*m_prgPartitions)[ idx ])->TypeSafeQI( IClusCfgPartitionProperties, &piccpp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = STHR( piccpp->GetFriendlyName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_FALSE )
        {
            continue;
        } // if:

        fFoundLogicalDisk = true;

        cch += (UINT) wcslen( bstrName ) + 1;

        pszTmp = new WCHAR[ cch ];
        if ( pszTmp == NULL )
        {
            goto OutOfMemory;
        } // if:

        hr = THR( StringCchCopyW( pszTmp, cch, psz ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        delete [] psz;

        psz = pszTmp;
        pszTmp = NULL;

        hr = THR( StringCchCatW( psz, cch, bstrName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        piccpp->Release();
        piccpp = NULL;
    } // for:

    //
    //  KB: 31-JUL-2000
    //
    //  If we didn't find any logical disk IDs then we don't want
    //  to touch m_bstrFriendlyName.
    //

    if ( !fFoundLogicalDisk )
    {
        hr = S_OK;                          // ensure that that the caller doesn't fail since this is not a fatal error...
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( psz );
    if ( bstr == NULL )
    {
        goto OutOfMemory;
    } // if:

    TraceSysFreeString( m_bstrFriendlyName );
    m_bstrFriendlyName = bstr;
    bstr = NULL;

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrCreateFriendlyName_VOID, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    if ( piccpp != NULL )
    {
        piccpp->Release();
    } // if:

    delete [] psz;
    delete [] pszTmp;

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrDisk );
    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CPhysicalDisk::HrCreateFriendlyName


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrCreateFriendlyName
//
//  Description:
//      Convert the WMI disk name into a more freindly version.
//      Create a cluster friendly name.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrCreateFriendlyName( BSTR bstrNameIn )
{
    TraceFunc1( "bstrNameIn = '%ws'", bstrNameIn == NULL ? L"<null>" : bstrNameIn );

    HRESULT hr = S_OK;
    WCHAR * psz = NULL;
    BSTR    bstr = NULL;

    //
    //  KB: 27-JUN-2000 GalenB
    //
    //  Disk names in WMI start with "\\.\".  As a better and easy
    //  friendly name I am just going to trim these leading chars
    //  off.
    //
    psz = bstrNameIn + wcslen( L"\\\\.\\" );

    bstr = TraceSysAllocString( psz );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrCreateFriendlyName_BSTR, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrName );
    m_bstrName = bstr;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrCreateFriendlyName


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrIsPartitionGPT
//
//  Description:
//      Is the passed in partition a GPT partition.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The partition is a GPT partition.
//
//      S_FALSE
//          The partition is not GPT.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      If the type property of a Win32_DiskPartition starts with "GPT"
//      then the whole spindle has GPT partitions.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrIsPartitionGPT( IWbemClassObject * pPartitionIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    VARIANT var;
    WCHAR   szData[ 4 ];
    BSTR    bstrGPT = NULL;

    VariantInit( &var );

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_GPT, &bstrGPT ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetWMIProperty( pPartitionIn, L"Type", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Get the fist three characters.  When the spindle has GPT partitions then
    //  these characters will be "GPT".  I am unsure if this will be localized?
    //

    hr = THR( StringCchCopyNW( szData, ARRAYSIZE( szData ), var.bstrVal, 3 ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    CharUpper( szData );

    if ( NStringCchCompareCase( szData, ARRAYSIZE( szData ), bstrGPT, SysStringLen( bstrGPT ) + 1 ) != 0 )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrGPT );

    HRETURN( hr );

} //*** CPhysicalDisk::HrIsPartitionGPT


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrIsPartitionLDM
//
//  Description:
//      Is the passed in partition an LDM partition.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The partition is an LDM partition.
//
//      S_FALSE
//          The partition is not LDM.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      If the type property of a Win32_DiskPartition is "logical disk
//      manager" then this disk is an LDM disk.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrIsPartitionLDM( IWbemClassObject * pPartitionIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    VARIANT var;
    BSTR    bstrLDM = NULL;

    VariantInit( &var );

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_LDM, &bstrLDM ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetWMIProperty( pPartitionIn, L"Type", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    CharUpper( var.bstrVal );

    if ( NBSTRCompareCase( var.bstrVal, bstrLDM ) != 0 )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrLDM );

    HRETURN( hr );

} //*** CPhysicalDisk::HrIsPartitionLDM

/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrGetDiskFirmwareSerialNumber
//
//  Description:
//      Get the disk firmware serial number.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      S_FALSE
//          There wasn't a firmware serial number.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrGetDiskFirmwareSerialNumber( void )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    HANDLE                      hVolume = NULL;
    DWORD                       dwSize;
    DWORD                       sc;
    STORAGE_PROPERTY_QUERY      spq;
    BOOL                        fRet;
    PSTORAGE_DEVICE_DESCRIPTOR  pddBuffer = NULL;
    DWORD                       cbBuffer;
    PCHAR                       psz = NULL;

    //
    // get handle to disk
    //

    hVolume = CreateFileW(
                          m_bstrDeviceID
                        , GENERIC_READ
                        , FILE_SHARE_READ
                        , NULL
                        , OPEN_EXISTING
                        , FILE_ATTRIBUTE_NORMAL
                        , NULL
                        );
    if ( hVolume == INVALID_HANDLE_VALUE )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    cbBuffer = sizeof( STORAGE_DEVICE_DESCRIPTOR ) + 2048;

    pddBuffer = ( PSTORAGE_DEVICE_DESCRIPTOR ) TraceAlloc( 0, cbBuffer );
    if ( pddBuffer == NULL )
    {
        goto OutOfMemory;
    } // if:

    ZeroMemory( pddBuffer, cbBuffer );
    ZeroMemory( &spq, sizeof( spq ) );

    spq.PropertyId = StorageDeviceProperty;
    spq.QueryType  = PropertyStandardQuery;

    //
    // issue storage class ioctl to get the disk's firmware serial number.
    //

    fRet = DeviceIoControl(
                          hVolume
                        , IOCTL_STORAGE_QUERY_PROPERTY
                        , &spq
                        , sizeof( spq )
                        , pddBuffer
                        , cbBuffer
                        , &dwSize
                        , NULL
                           );
    if ( !fRet )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( dwSize > 0 )
    {
        //
        //  Ensure that there is a serial number offset and that it is within the buffer extents.
        //

        if ( ( pddBuffer->SerialNumberOffset == 0 ) || ( pddBuffer->SerialNumberOffset > pddBuffer->Size ) )
        {
            LOG_STATUS_REPORT_STRING( L"The disk '%1!ws!' does not have a firmware serial number.", m_bstrDeviceID, hr );
            hr = S_FALSE;
            goto Cleanup;
        } // if:

        //
        //  Serial number string is a zero terminated ASCII string.

        //
        //  The header ntddstor.h says the for devices with no serial number,
        //  the offset will be zero.  This doesn't seem to be TRUE.
        //
        //  For devices with no serial number, it looks like a string with a single
        //  null character '\0' is returned.
        //

        psz = (PCHAR) pddBuffer + (DWORD) pddBuffer->SerialNumberOffset;

        hr = THR( HrAnsiStringToBSTR( psz, &m_bstrFirmwareSerialNumber ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        LOG_STATUS_REPORT_STRING3(
              L"Disk '%1!ws!' has firmware serial number '%2!ws!' at offset '%3!#08x!'."
            , m_bstrDeviceID
            , m_bstrFirmwareSerialNumber
            , pddBuffer->SerialNumberOffset
            , hr
            );
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    LOG_STATUS_REPORT( L"HrGetDiskFirmwareSerialNumber() is out of memory.", hr );

Cleanup:

    if ( hVolume != NULL )
    {
        CloseHandle( hVolume );
    } // if:

    TraceFree( pddBuffer );

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetDiskFirmwareSerialNumber


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrGetDiskFirmwareVitalData
//
//  Description:
//      Get the disk firmware vital data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      S_FALSE
//          There wasn't a firmware serial number.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrGetDiskFirmwareVitalData( void )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    HANDLE                          hVolume = NULL;
    DWORD                           dwSize;
    DWORD                           sc;
    STORAGE_PROPERTY_QUERY          spq;
    BOOL                            fRet;
    PSTORAGE_DEVICE_ID_DESCRIPTOR   psdidBuffer = NULL;
    DWORD                           cbBuffer;

    //
    // get handle to disk
    //

    hVolume = CreateFileW(
                          m_bstrDeviceID
                        , GENERIC_READ
                        , FILE_SHARE_READ
                        , NULL
                        , OPEN_EXISTING
                        , FILE_ATTRIBUTE_NORMAL
                        , NULL
                        );
    if ( hVolume == INVALID_HANDLE_VALUE )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    cbBuffer = sizeof( STORAGE_DEVICE_ID_DESCRIPTOR ) + 2048;

    psdidBuffer = (PSTORAGE_DEVICE_ID_DESCRIPTOR) TraceAlloc( 0, cbBuffer );
    if ( psdidBuffer == NULL )
    {
        goto OutOfMemory;
    } // if:

    ZeroMemory( psdidBuffer, cbBuffer );
    ZeroMemory( &spq, sizeof( spq ) );

    spq.PropertyId = StorageDeviceIdProperty;
    spq.QueryType  = PropertyStandardQuery;

    //
    // issue storage class ioctl to get the disk's firmware vital data
    //

    fRet = DeviceIoControl(
                          hVolume
                        , IOCTL_STORAGE_QUERY_PROPERTY
                        , &spq
                        , sizeof( spq )
                        , psdidBuffer
                        , cbBuffer
                        , &dwSize
                        , NULL
                        );
    if ( !fRet )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( dwSize > 0 )
    {
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    LOG_STATUS_REPORT( L"HrGetDiskFirmwareVitalData() is out of memory.", hr );

Cleanup:

    if ( hVolume != NULL )
    {
        CloseHandle( hVolume );
    } // if:

    TraceFree( psdidBuffer );

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetDiskFirmwareVitalData
*/

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrIsClusterCapable
//
//  Description:
//      Is this disk cluster capable?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The disk is cluster capable.
//
//      S_FALSE
//          The disk is not cluster capable.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrIsClusterCapable( void )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    HANDLE          hSCSIPort = INVALID_HANDLE_VALUE;
    DWORD           dwSize;
    DWORD           sc;
    BOOL            fRet;
    WCHAR           szSCSIPort[ 32 ];
    SRB_IO_CONTROL  srb;

    hr = THR( StringCchPrintfW( szSCSIPort, ARRAYSIZE( szSCSIPort ), L"\\\\.\\Scsi%d:", m_ulSCSIPort ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // get handle to disk
    //

    hSCSIPort = CreateFileW(
                          szSCSIPort
                        , GENERIC_READ | GENERIC_WRITE
                        , FILE_SHARE_READ | FILE_SHARE_WRITE
                        , NULL
                        , OPEN_EXISTING
                        , FILE_ATTRIBUTE_NORMAL
                        , NULL
                        );
    if ( hSCSIPort == INVALID_HANDLE_VALUE )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LOG_STATUS_REPORT_STRING( L"Failed to open device %1!ws!.", szSCSIPort, hr );
        goto Cleanup;
    } // if:

#define CLUSDISK_SRB_SIGNATURE "CLUSDISK"

    ZeroMemory( &srb, sizeof( srb ) );

    srb.HeaderLength = sizeof( srb );

    Assert( sizeof( srb.Signature ) <= sizeof( CLUSDISK_SRB_SIGNATURE ) );
    CopyMemory( srb.Signature, CLUSDISK_SRB_SIGNATURE, sizeof( srb.Signature ) );

    srb.ControlCode = IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE;

    //
    // issue mini port ioctl to determine whether the disk is cluster capable
    //

    fRet = DeviceIoControl(
                          hSCSIPort
                        , IOCTL_SCSI_MINIPORT
                        , &srb
                        , sizeof( srb )
                        , NULL
                        , 0
                        , &dwSize
                        , NULL
                        );

    //
    //  If the call succeeds then the disk is "not cluster capable".  If the call
    //  fails then the disk is "not not cluster capable" and that means that it
    //  is cluster capable.
    //

    if ( fRet )
    {
        hr = S_FALSE;
    } // if:
    else
    {
        hr = S_OK;
    } // else:

    LogMsg( L"[SRV] The disks on SCSI port %d are%ws cluster capable.", m_ulSCSIPort, ( hr == S_FALSE ? L" not" : L"" ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        CLSID   clsidMinorId;
        HRESULT hrTemp;

        hrTemp = THR( CoCreateGuid( &clsidMinorId ) );
        if ( FAILED( hrTemp ) )
        {
            LOG_STATUS_REPORT( L"Could not create a guid for a not cluster capable disk minor task ID", hrTemp );
            clsidMinorId = IID_NULL;
        } // if:

        STATUS_REPORT_STRING2_REF(
                  TASKID_Minor_PhysDisk_Cluster_Capable
                , clsidMinorId
                , IDS_ERROR_PHYSDISK_CLUSTER_CAPABLE
                , m_bstrFriendlyName
                , m_ulSCSIPort
                , IDS_ERROR_PHYSDISK_CLUSTER_CAPABLE_REF
                , hr
                );
    } // if:

    if ( hSCSIPort != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hSCSIPort );
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::HrIsClusterCapable

/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrProcessMountPoints
//
//  Description:
//      if any of the partitions on this spindle have reparse points then
//      the mounted volumes are found and enumerated.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      HRESULT errors.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrProcessMountPoints(
    void
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    ULONG                   idxOuter;
    ULONG                   idxInner;
    IClusCfgPartitionInfo * piccpi = NULL;
    SDriveLetterMapping     sdlm;
    DWORD                   dwFlags;
    WCHAR                   szRootPath[] = L"A:\\";
    BSTR                    bstrFileSystem = NULL;

    for ( idxOuter = 0; idxOuter < m_idxNextPartition; idxOuter++ )
    {
        hr = THR( ((*m_prgPartitions)[ idxOuter ])->TypeSafeQI( IClusCfgPartitionInfo, &piccpi ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"CPhysicalDisk::HrHasReparsePoints() could not query for IClusCfgPartitionInfo.", hr );
            goto Cleanup;
        } // if:

        InitDriveLetterMappings( &sdlm );

        hr = THR( piccpi->GetDriveLetterMappings( &sdlm ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            for ( idxInner = 0; idxInner < 26; idxInner++)
            {
                if ( sdlm.dluDrives[ idxInner ] != dluUNUSED )
                {
                    szRootPath[ 0 ] = L'A' + (WCHAR) idxInner;

                    hr = THR( HrGetVolumeInformation( szRootPath, &dwFlags, &bstrFileSystem ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:

                    //
                    //  If this spindle has reparse points then we need to return S_OK.
                    //

                    if ( dwFlags & FILE_SUPPORTS_REPARSE_POINTS )
                    {
                        hr = THR( HrEnumMountPoints( szRootPath ) );
                        if ( FAILED( hr ) )
                        {
                            goto Cleanup;
                        } // if:
                    } // if:

                    TraceSysFreeString( bstrFileSystem );
                    bstrFileSystem = NULL;
                } // if:
            } // for:
        } // if:

        piccpi->Release();
        piccpi = NULL;
    } // for:

Cleanup:

    if ( piccpi != NULL )
    {
        piccpi->Release();
    } // if:

    TraceSysFreeString( bstrFileSystem );

    HRETURN( hr );

} //*** CPhysicalDisk::HrProcessMountPoints


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrEnumMountPoints
//
//  Description:
//      Enumerate the mounted volumes of the passed in root path.
//
//  Arguments:
//      pcszRootPathIn
//
//  Return Value:
//      S_OK
//          Success.
//
//      HRESULT errors.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrEnumMountPoints(
       const WCHAR * pcszRootPathIn
    )
{
    TraceFunc( "" );
    Assert( pcszRootPathIn != NULL );

    HRESULT hr = S_OK;
    HANDLE  hEnum = NULL;
    BOOL    fRet;
    WCHAR * psz = NULL;
    DWORD   cch = 512;
    DWORD   sc;
    int     cTemp;

    psz = new WCHAR[ cch ];
    if ( psz == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( cTemp = 0; cTemp < 3; cTemp++ )
    {
        hEnum = FindFirstVolumeMountPointW( pcszRootPathIn, psz, cch );
        if ( hEnum == INVALID_HANDLE_VALUE )
        {
            sc = GetLastError();
            if ( sc == ERROR_NO_MORE_FILES )
            {
                hr = S_FALSE;
                goto Cleanup;
            } // if:
            else if ( sc == ERROR_BAD_LENGTH )
            {
                //
                //  Grow the buffer and try again.
                //

                cch += 512;

                delete [] psz;

                psz = new WCHAR[ cch ];
                if ( psz == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                } // if:

                continue;
            } // else if:
            else
            {
                hr = HRESULT_FROM_WIN32( TW32( sc ) );
                goto Cleanup;
            } // else:
        } // if:
        else
        {
            sc = ERROR_SUCCESS;
            break;
        } // else:
    } // for:

    if ( hEnum == INVALID_HANDLE_VALUE )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    } // if:

    //
    //  psz has the first mounted volume
    //

    hr = STHR( HrProcessMountedVolume( pcszRootPathIn, psz ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Now find any remaining mount points.
    //

    for ( ; ; )
    {
        fRet = FindNextVolumeMountPointW( hEnum, psz, cch );
        if ( fRet == FALSE )
        {
            sc = GetLastError();
            if ( sc == ERROR_NO_MORE_FILES )
            {
                hr = S_OK;
                break;
            } // if:
            else if ( sc == ERROR_BAD_LENGTH )
            {
                //
                //  Grow the buffer and try again.
                //

                cch += 512;

                delete [] psz;

                psz = new WCHAR[ cch ];
                if ( psz == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                } // if:

                continue;
            } // else if:
            else
            {
                TW32( sc );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            } // else:
        } // if:
        else
        {
            hr = STHR( HrProcessMountedVolume( pcszRootPathIn, psz ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:
        } // else:
    } // for:

Cleanup:

    if ( hEnum != INVALID_HANDLE_VALUE )
    {
        FindVolumeMountPointClose( hEnum );
    } // if:

    delete [] psz;

    HRETURN( hr );

} //*** CPhysicalDisk::HrEnumMountPoints


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:InitDriveLetterMappings
//
//  Description:
//      Initialize the drive letter mappings array.
//
//  Arguments:
//      pdlmDriveLetterMappingOut
//
//  Return Value:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CPhysicalDisk::InitDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "" );
    Assert( pdlmDriveLetterMappingOut != NULL );

    ULONG   idx;

    for ( idx = 0 ; idx < 26 ; idx++ )
    {
        pdlmDriveLetterMappingOut->dluDrives[ idx ] = dluUNUSED;
    } // for:

    TraceFuncExit();

} // *** CPhysicalDisk::InitDriveLetterMappings


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrProcessMountedVolume
//
//  Description:
//      Process the mounted volume by finding each spindle that makes up
//      the mount point volume and convert it into a WMI device ID.
//
//  Arguments:
//      pcszRootPathIn
//
//      pcszMountPointIn
//
//  Return Value:
//      S_OK
//          Success.
//
//      S_FALSE
//          The mounted volume was not a physical disk.
//
//      HRESULT errors.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrProcessMountedVolume(
      const WCHAR * pcszRootPathIn
    , const WCHAR * pcszMountPointIn
    )
{
    TraceFunc( "" );
    Assert( pcszRootPathIn != NULL );
    Assert( pcszMountPointIn != NULL );

    HRESULT                 hr = S_OK;
    BOOL                    fRet;
    WCHAR *                 pszPath = NULL;
    DWORD                   cchPath;
    WCHAR *                 psz = NULL;
    DWORD                   cch = 512;
    int                     cTemp;
    DWORD                   sc = ERROR_SUCCESS;
    BSTR                    bstr = NULL;
    UINT                    uDriveType;
    HANDLE                  hVolume = NULL;
    PVOLUME_DISK_EXTENTS    pvde = NULL;
    DWORD                   cbvde;
    DWORD                   dwSize;
    WCHAR                   sz[ 32 ];
    DWORD                   idx;
    BSTR                    bstrFileSystem = NULL;
    BOOL                    fIsNTFS;

    cchPath = wcslen( pcszRootPathIn ) + wcslen( pcszMountPointIn ) + 1;

    pszPath = new WCHAR[ cchPath ];
    if ( pszPath == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( StringCchCopyW( pszPath, cchPath, pcszRootPathIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( StringCchCopyW( pszPath, cchPath, pcszMountPointIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    psz = new WCHAR[ cch ];
    if ( psz == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( cTemp = 0, fRet = FALSE; cTemp < 3; cTemp++ )
    {
        fRet = GetVolumeNameForVolumeMountPoint( pszPath, psz, cch );
        if ( fRet == FALSE )
        {
            sc = GetLastError();
            if ( sc == ERROR_BAD_LENGTH )
            {
                //
                //  Grow the buffer and try again.
                //

                cch += 512;

                delete [] psz;

                psz = new WCHAR[ cch ];
                if ( psz == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                } // if:

                continue;
            } // if:
            else
            {
                hr = HRESULT_FROM_WIN32( TW32( sc ) );
                goto Cleanup;
            } // else:
        } // if:
        else
        {
            sc = ERROR_SUCCESS;
            break;
        } // else:
    } // for:

    if ( fRet == FALSE )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    } // if:

    //
    //  Now psz has the "guid volume name" for the volume that is mounted.
    //

    //
    //  Now we need to ensure that the mounted volume is a fixed disk.
    //

    uDriveType = GetDriveType( psz );
    if ( uDriveType != DRIVE_FIXED )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    hr = THR( HrGetVolumeInformation( psz, NULL, &bstrFileSystem ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  We don't care about volumes that are not using NTFS.
    //

    fIsNTFS = ( NStringCchCompareCase( bstrFileSystem, SysStringLen( bstrFileSystem ) + 1, L"NTFS", RTL_NUMBER_OF( L"NTFS" ) ) == 0 );
    if ( fIsNTFS == FALSE )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    //
    //  Trim off the trailing \ so we can open the device and poke it with
    //  an IOCTL.
    //

    psz[ wcslen( psz ) - 1 ] = L'\0';

    //
    //  Get and handle to the device.
    //

    hVolume = CreateFileW(
                          psz
                        , GENERIC_READ
                        , FILE_SHARE_READ
                        , NULL
                        , OPEN_EXISTING
                        , FILE_ATTRIBUTE_NORMAL
                        , NULL
                        );
    if ( hVolume == INVALID_HANDLE_VALUE )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    cbvde = sizeof( VOLUME_DISK_EXTENTS );
    pvde = (PVOLUME_DISK_EXTENTS) TraceAlloc( 0, cbvde );
    if ( pvde == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( cTemp = 0; cTemp < 3; cTemp++ )
    {
        fRet = DeviceIoControl(
                              hVolume
                            , IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS
                            , NULL
                            , 0
                            , pvde
                            , cbvde
                            , &dwSize
                            , NULL
                            );
        if ( fRet == FALSE )
        {
            sc = GetLastError();
            if ( sc == ERROR_MORE_DATA )
            {
                PVOLUME_DISK_EXTENTS    pvdeTemp = NULL;

                cbvde = sizeof( VOLUME_DISK_EXTENTS ) + ( sizeof( DISK_EXTENT ) * pvde->NumberOfDiskExtents );

                pvdeTemp = (PVOLUME_DISK_EXTENTS) TraceReAlloc( pvde, cbvde, HEAP_ZERO_MEMORY );
                if ( pvdeTemp == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                } // if:

                pvde = pvdeTemp;
                continue;
            } // if:
            else
            {
                TW32( sc );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            } // else:
        } // if:
        else
        {
            sc = ERROR_SUCCESS;
            break;
        } // else:
    } // for:

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        goto Cleanup;
    } // if:

    //
    //  Now we have the disk number(s) of the mounted disk and we can convert that to
    //  a WMI device ID.
    //

    for ( idx = 0; idx < pvde->NumberOfDiskExtents; idx++ )
    {
        hr = THR( StringCchPrintfW( sz, ARRAYSIZE( sz ), g_szPhysicalDriveFormat, pvde->Extents[ idx ].DiskNumber ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrProcessSpindle( sz ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // for:

Cleanup:

    if ( hVolume != NULL )
    {
        CloseHandle( hVolume );
    } // if:

    TraceFree( pvde );

    TraceSysFreeString( bstr );
    TraceSysFreeString( bstrFileSystem );

    delete [] psz;
    delete [] pszPath;

    HRETURN( hr );

} // *** CPhysicalDisk::HrProcessMountedVolume


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrProcessSpindle
//
//  Description:
//      Process the mounted volume spindle by creating a CPhysicalDisk
//      object and adding it to the physical disks enumerator.
//
//  Arguments:
//      pcszDeviceIDIn
//
//  Return Value:
//      S_OK
//          Success.
//
//      HRESULT errors.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrProcessSpindle(
      const WCHAR * pcszDeviceIDIn
    )
{
    Assert( pcszDeviceIDIn != NULL );

    TraceFunc( "" );

    HRESULT hr = S_OK;

Cleanup:

    HRETURN( hr );

} // *** CPhysicalDisk::HrProcessSpindle
*/

//*************************************************************************//

/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk class -- IClusCfgVerifyQuorum interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::PrepareToHostQuorumResource
//
//  Description:
//      Do any configuration necessary in preparation for this node hosting
//      the quorum.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::PrepareToHostQuorumResource( void )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRETURN( S_OK );

} //*** CPhysicalDisk::PrepareToHostQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Cleanup
//
//  Description:
//      Do any necessay cleanup from the PrepareToHostQuorumResource()
//      method.
//
//      If the cleanup method is anything other than successful completion
//      then the anything created above in PrepareToHostQuorumResource()
//      needs to be cleaned up.
//
//  Arguments:
//      cccrReasonIn
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Cleanup(
      EClusCfgCleanupReason cccrReasonIn
    )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRETURN( S_OK );

} //*** CPhysicalDisk::Cleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::IsMultiNodeCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The quorumable device allows join.
//
//      S_FALSE
//          The device does not allow join.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::IsMultiNodeCapable( void )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorumResourceMultiNodeCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::IsMultiNodeCapable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetMultiNodeCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The quorumable device allows join.
//
//      S_FALSE
//          The device does not allow join.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This function should never be called
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetMultiNodeCapable(
    BOOL fMultiNodeCapableIn
    )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRETURN( S_FALSE );

} //*** CPhysicalDisk::SetMultiNodeCapable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cluscfgserverguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ClusCfgServerGuids.h
//
//  Description:
//      This file contains the guids used in ClusCfgServer.
//
//  Documentation:
//
//  Maintained By:
//      Galen Barbee (GalenB) 17-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <InitGuid.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


// {39371CBA-A47B-4a4f-9042-6BECD321E9E2}
DEFINE_GUID( TASKID_Minor_Server_Initialized,
0x39371cba, 0xa47b, 0x4a4f, 0x90, 0x42, 0x6b, 0xec, 0xd3, 0x21, 0xe9, 0xe2 );

// {77566663-68F1-4b47-9F2C-74D3680F1F4D}
DEFINE_GUID( TASKID_Minor_Get_Cluster_Name,
0x77566663, 0x68f1, 0x4b47, 0x9f, 0x2c, 0x74, 0xd3, 0x68, 0xf, 0x1f, 0x4d );

// {51DE9439-C518-4932-83DD-BEA50A0539E5}
DEFINE_GUID( TASKID_Minor_Get_Cluster_IP_Address,
0x51de9439, 0xc518, 0x4932, 0x83, 0xdd, 0xbe, 0xa5, 0xa, 0x5, 0x39, 0xe5 );

// {44F2EB6A-F6BC-44da-A7A6-5D43E1883861}
DEFINE_GUID( TASKID_Minor_Get_Cluster_IP_Subnet,
0x44f2eb6a, 0xf6bc, 0x44da, 0xa7, 0xa6, 0x5d, 0x43, 0xe1, 0x88, 0x38, 0x61 );

// {08FFC4AA-AA98-40b1-8606-5EB444E5B232}
DEFINE_GUID( TASKID_Minor_Get_Cluster_Networks,
0x8ffc4aa, 0xaa98, 0x40b1, 0x86, 0x6, 0x5e, 0xb4, 0x44, 0xe5, 0xb2, 0x32 );

// {9C751C40-DA64-45ea-9C96-1A50EA03A8E7}
DEFINE_GUID( TASKID_Minor_Non_SCSI_Disks,
0x9c751c40, 0xda64, 0x45ea, 0x9c, 0x96, 0x1a, 0x50, 0xea, 0x3, 0xa8, 0xe7 );

// {9321731F-62D4-4730-9A9D-52D148F34367}
DEFINE_GUID( TASKID_Minor_Primary_IP_Address,
0x9321731f, 0x62d4, 0x4730, 0x9a, 0x9d, 0x52, 0xd1, 0x48, 0xf3, 0x43, 0x67 );

// {DE5F2F90-A0C6-4f88-BB86-A351A1808797}
DEFINE_GUID( TASKID_Minor_WMI_OS_Qry_Failed,
0xde5f2f90, 0xa0c6, 0x4f88, 0xbb, 0x86, 0xa3, 0x51, 0xa1, 0x80, 0x87, 0x97 );

// {D2094BA7-E41E-44be-AE2B-5F8A177FA31C}
DEFINE_GUID( TASKID_Minor_WMI_Logical_Disks_Qry_Failed,
0xd2094ba7, 0xe41e, 0x44be, 0xae, 0x2b, 0x5f, 0x8a, 0x17, 0x7f, 0xa3, 0x1c );

// {5622150D-ADC3-4371-926C-29B2533B50B7}
DEFINE_GUID( TASKID_Minor_WMI_PageFile_Qry_Failed,
0x5622150d, 0xadc3, 0x4371, 0x92, 0x6c, 0x29, 0xb2, 0x53, 0x3b, 0x50, 0xb7 );

// {81EF1C38-1C1C-4e60-A816-D91E0E631FC9}
DEFINE_GUID( TASKID_Minor_WMI_Phys_Disks_Qry_Failed,
0x81ef1c38, 0x1c1c, 0x4e60, 0xa8, 0x16, 0xd9, 0x1e, 0xe, 0x63, 0x1f, 0xc9 );

// {8D4696F2-5855-46d5-9F70-F5E62E5CF9B9}
DEFINE_GUID( TASKID_Minor_Phys_Disk_No_File_System,
0x8d4696f2, 0x5855, 0x46d5, 0x9f, 0x70, 0xf5, 0xe6, 0x2e, 0x5c, 0xf9, 0xb9 );

// {F95D8167-8211-4e81-924F-544582129CAF}
DEFINE_GUID( TASKID_Minor_MNS_PreCreate,
0xf95d8167, 0x8211, 0x4e81, 0x92, 0x4f, 0x54, 0x45, 0x82, 0x12, 0x9c, 0xaf);

// {F95D8167-8211-4e81-924F-544582129CAF}
DEFINE_GUID( TASKID_Minor_MNS_Create,
0xf95d8167, 0x8211, 0x4e81, 0x92, 0x4f, 0x54, 0x45, 0x82, 0x12, 0x9c, 0xaf);

// {74A42186-C180-4260-82B7-18A702115562}
DEFINE_GUID( TASKID_Minor_Phys_Disk_Not_NTFS,
0x74a42186, 0xc180, 0x4260, 0x82, 0xb7, 0x18, 0xa7, 0x2, 0x11, 0x55, 0x62 );

// {C525FFFC-F613-4b6a-88D2-600F30134E56}
DEFINE_GUID( TASKID_Minor_WMI_NetworkAdapterSetting_Qry_Failed,
0xc525fffc, 0xf613, 0x4b6a, 0x88, 0xd2, 0x60, 0xf, 0x30, 0x13, 0x4e, 0x56 );

// {088D6F8B-CCD4-4d0c-9BBD-9C2C730B00FB}
DEFINE_GUID( TASKID_Minor_WMI_NetworkAdapter_Qry_Failed,
0x88d6f8b, 0xccd4, 0x4d0c, 0x9b, 0xbd, 0x9c, 0x2c, 0x73, 0xb, 0x0, 0xfb );

// {9A9DBDB0-56EA-4e04-928E-7720F395ADE2}
DEFINE_GUID( TASKID_Minor_CoCreate_NetConnection_Manager_Failed,
0x9a9dbdb0, 0x56ea, 0x4e04, 0x92, 0x8e, 0x77, 0x20, 0xf3, 0x95, 0xad, 0xe2);

// {5E05D284-F439-4711-A172-F4E1F9C25E75}
DEFINE_GUID( TASKID_Minor_Enumerate_Network_Connections_Failed,
0x5e05d284, 0xf439, 0x4711, 0xa1, 0x72, 0xf4, 0xe1, 0xf9, 0xc2, 0x5e, 0x75);

// {1865D049-E6A0-441f-A887-073729B0F3D3}
DEFINE_GUID( TASKID_Minor_Reset_Network_Connections_Enum_Failed,
0x1865d049, 0xe6a0, 0x441f, 0xa8, 0x87, 0x7, 0x37, 0x29, 0xb0, 0xf3, 0xd3);

// {1782B338-6944-4d45-A169-B1A4861ECEFA}
DEFINE_GUID( TASKID_Minor_Network_Firewall_Enabled,
0x1782b338, 0x6944, 0x4d45, 0xa1, 0x69, 0xb1, 0xa4, 0x86, 0x1e, 0xce, 0xfa);

// {5C339B91-90FD-4876-9757-F544B29A4875}
DEFINE_GUID( TASKID_Minor_Bridged_Network,
0x5c339b91, 0x90fd, 0x4876, 0x97, 0x57, 0xf5, 0x44, 0xb2, 0x9a, 0x48, 0x75);

// {9DE3F291-6C9A-4a88-860B-0FE383EAF871}
DEFINE_GUID( TASKID_Minor_WMI_DiskDrivePartitions_Qry_Failed,
0x9de3f291, 0x6c9a, 0x4a88, 0x86, 0xb, 0xf, 0xe3, 0x83, 0xea, 0xf8, 0x71 );

// {182D2408-3605-4092-9C18-EC3944F75FB7}
DEFINE_GUID( TASKID_Minor_WBEM_Connection_Failure,
0x182d2408, 0x3605, 0x4092, 0x9c, 0x18, 0xec, 0x39, 0x44, 0xf7, 0x5f, 0xb7 );

// {F6B12EAF-E085-49d0-9976-DAC721DC5421}
DEFINE_GUID( TASKID_Minor_Boot_Partition_Not_NTFS,
0xf6b12eaf, 0xe085, 0x49d0, 0x99, 0x76, 0xda, 0xc7, 0x21, 0xdc, 0x54, 0x21 );

// {0A94106C-BA56-48d9-9C46-302F8A05ED68}
DEFINE_GUID( TASKID_Minor_WMI_Get_LogicalDisk_Failed,
0xa94106c, 0xba56, 0x48d9, 0x9c, 0x46, 0x30, 0x2f, 0x8a, 0x5, 0xed, 0x68 );

// {2FAB8C32-5A40-4453-838F-1AF740200F90}
DEFINE_GUID( TASKID_Minor_Server_GetClusterNodeInfo,
0x2fab8c32, 0x5a40, 0x4453, 0x83, 0x8f, 0x1a, 0xf7, 0x40, 0x20, 0xf, 0x90 );

// {B460EA73-6223-44fa-84E0-DE7EC069DDD4}
DEFINE_GUID( TASKID_Minor_Server_GetClusterInfo,
0xb460ea73, 0x6223, 0x44fa, 0x84, 0xe0, 0xde, 0x7e, 0xc0, 0x69, 0xdd, 0xd4 );

// {C9C1154E-067D-45f5-B348-42B9B395C864}
DEFINE_GUID( TASKID_Minor_Server_GetManagedResourcesEnum,
0xc9c1154e, 0x67d, 0x45f5, 0xb3, 0x48, 0x42, 0xb9, 0xb3, 0x95, 0xc8, 0x64 );

// {7D7F8A19-FE6E-4cb2-93C9-213A933BA0FF}
DEFINE_GUID( TASKID_Minor_Server_GetNetworksEnum,
0x7d7f8a19, 0xfe6e, 0x4cb2, 0x93, 0xc9, 0x21, 0x3a, 0x93, 0x3b, 0xa0, 0xff );

// {03D177A6-2AE5-429e-B7FE-1A7D1C98A44B}
DEFINE_GUID( TASKID_Minor_Server_CommitChanges,
0x3d177a6, 0x2ae5, 0x429e, 0xb7, 0xfe, 0x1a, 0x7d, 0x1c, 0x98, 0xa4, 0x4b );

// {8028BF97-2D57-4628-845D-C4BEFFEB531A}
DEFINE_GUID( TASKID_Minor_Node_Down,
0x8028bf97, 0x2d57, 0x4628, 0x84, 0x5d, 0xc4, 0xbe, 0xff, 0xeb, 0x53, 0x1a );

// {2131E2D7-E683-43ba-B220-48ADA80EE0DA}
DEFINE_GUID( TASKID_Minor_MREnum_Negative_Item_Count,
0x2131e2d7, 0xe683, 0x43ba, 0xb2, 0x20, 0x48, 0xad, 0xa8, 0xe, 0xe0, 0xda );

// {2243D619-9869-4f3e-A989-CE476198FC20}
DEFINE_GUID( TASKID_Minor_MREnum_Unknown_State,
0x2243d619, 0x9869, 0x4f3e, 0xa9, 0x89, 0xce, 0x47, 0x61, 0x98, 0xfc, 0x20 );

// {4B3892D7-7459-491e-A92E-376701494B65}
DEFINE_GUID( TASKID_Minor_PhysDisk_No_Partitions,
0x4b3892d7, 0x7459, 0x491e, 0xa9, 0x2e, 0x37, 0x67, 0x1, 0x49, 0x4b, 0x65 );

// {65FFF9F6-3555-4c58-A1FE-917F3A62EBEC}
DEFINE_GUID( TASKID_Minor_PhysDisk_Signature,
0x65fff9f6, 0x3555, 0x4c58, 0xa1, 0xfe, 0x91, 0x7f, 0x3a, 0x62, 0xeb, 0xec );

// {65383B52-FD86-4ca3-96BB-B7E4E09F0C27}
DEFINE_GUID( TASKID_Minor_GetClusterServiceAccountCredentials,
0x65383b52, 0xfd86, 0x4ca3, 0x96, 0xbb, 0xb7, 0xe4, 0xe0, 0x9f, 0xc, 0x27 );

// {BC8E26E5-B499-4aba-AD64-291A286EE5EA}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Cluster,
0xbc8e26e5, 0xb499, 0x4aba, 0xad, 0x64, 0x29, 0x1a, 0x28, 0x6e, 0xe5, 0xea );

// {E7D3F142-D928-4b8d-B6D3-3ABA805DD3E3}
DEFINE_GUID( TASKID_Minor_ClusterInfo_GetName_Pointer,
0xe7d3f142, 0xd928, 0x4b8d, 0xb6, 0xd3, 0x3a, 0xba, 0x80, 0x5d, 0xd3, 0xe3 );

// {45BF7AAA-812F-4a09-83E5-A0B654DB03D7}
DEFINE_GUID( TASKID_Minor_GetName_Memory,
0x45bf7aaa, 0x812f, 0x4a09, 0x83, 0xe5, 0xa0, 0xb6, 0x54, 0xdb, 0x3, 0xd7 );

// {6091A69B-9327-4bb6-AE54-25042BEB124C}
DEFINE_GUID( TASKID_Minor_GetIPAddress,
0x6091a69b, 0x9327, 0x4bb6, 0xae, 0x54, 0x25, 0x4, 0x2b, 0xeb, 0x12, 0x4c );

// {E46F5916-28A6-4aaf-B323-F7194ED4B13C}
DEFINE_GUID( TASKID_Minor_ClusterInfo_GetSubnetMask,
0xe46f5916, 0x28a6, 0x4aaf, 0xb3, 0x23, 0xf7, 0x19, 0x4e, 0xd4, 0xb1, 0x3c );

// {C822E5F8-D703-4726-87A3-C31242DE6DAE}
DEFINE_GUID(TASKID_Minor_GetNetworkInfo,
0xc822e5f8, 0xd703, 0x4726, 0x87, 0xa3, 0xc3, 0x12, 0x42, 0xde, 0x6d, 0xae );

// {CB418AD6-2A16-4b96-88C8-D6F1CAC5D760}
DEFINE_GUID(TASKID_Minor_Initialize,
0xcb418ad6, 0x2a16, 0x4b96, 0x88, 0xc8, 0xd6, 0xf1, 0xca, 0xc5, 0xd7, 0x60 );

// {746D5BBE-1BF2-48f5-9A5F-069C90937435}
DEFINE_GUID( TASKID_Minor_SetName_Cluster,
0x746d5bbe, 0x1bf2, 0x48f5, 0x9a, 0x5f, 0x6, 0x9c, 0x90, 0x93, 0x74, 0x35 );

// {8FFF1861-CC27-4be6-9024-FA90F5559593}
DEFINE_GUID( TASKID_Minor_HrInit,
0x8fff1861, 0xcc27, 0x4be6, 0x90, 0x24, 0xfa, 0x90, 0xf5, 0x55, 0x95, 0x93 );

// {13CF2484-3997-496a-B8AB-E6E135AAC54F}
DEFINE_GUID( TASKID_Minor_Cluster_Network_Not_Found,
0x13cf2484, 0x3997, 0x496a, 0xb8, 0xab, 0xe6, 0xe1, 0x35, 0xaa, 0xc5, 0x4f );

// {A61B00C8-38D7-4097-A14F-19226DC9498F}
DEFINE_GUID( TASKID_Minor_Network_Interface_Not_Found, 
0xa61b00c8, 0x38d7, 0x4097, 0xa1, 0x4f, 0x19, 0x22, 0x6d, 0xc9, 0x49, 0x8f );

// {BC37101F-AF06-4dcc-AFF4-CDA6EA103641}
DEFINE_GUID( TASKID_Minor_HrGetIPAddressInfo,
0xbc37101f, 0xaf06, 0x4dcc, 0xaf, 0xf4, 0xcd, 0xa6, 0xea, 0x10, 0x36, 0x41 );

// {F0BDA809-6250-4e85-A0C1-5A70334AA791}
DEFINE_GUID( TASKID_Minor_HrLoadCredentials,
0xf0bda809, 0x6250, 0x4e85, 0xa0, 0xc1, 0x5a, 0x70, 0x33, 0x4a, 0xa7, 0x91 );

// {147D8FBD-73EA-4d3e-8F0E-ADE480B27691}
DEFINE_GUID( TASKID_Minor_Dotted_Quad_Failed,
0x147d8fbd, 0x73ea, 0x4d3e, 0x8f, 0xe, 0xad, 0xe4, 0x80, 0xb2, 0x76, 0x91 );

// {BDBE3962-E687-466a-99D9-00CF43B71C3F}
DEFINE_GUID( TASKID_Minor_SetWbemServices_IPAddress,
0xbdbe3962, 0xe687, 0x466a, 0x99, 0xd9, 0x0, 0xcf, 0x43, 0xb7, 0x1c, 0x3f );

// {40A8D255-75A9-4034-B821-26AD8F83F1C3}
DEFINE_GUID( TASKID_Minor_IPAddressInfo_GetUID_Pointer,
0x40a8d255, 0x75a9, 0x4034, 0xb8, 0x21, 0x26, 0xad, 0x8f, 0x83, 0xf1, 0xc3 );

// {26125CAB-DCBD-4da1-9D27-EB2433761DB4}
DEFINE_GUID( TASKID_Minor_IPAddressInfo_GetUID_Memory,
0x26125cab, 0xdcbd, 0x4da1, 0x9d, 0x27, 0xeb, 0x24, 0x33, 0x76, 0x1d, 0xb4 );

// {B04D9500-7FC1-40a3-B89E-80E4049E4276}
DEFINE_GUID( TASKID_Minor_GetNetworkGetIPAddress,
0xb04d9500, 0x7fc1, 0x40a3, 0xb8, 0x9e, 0x80, 0xe4, 0x4, 0x9e, 0x42, 0x76 );

// {96C933C5-FBE3-4bdc-B733-55CB692B173D}
DEFINE_GUID( TASKID_Minor_GetSubnetMask,
0x96c933c5, 0xfbe3, 0x4bdc, 0xb7, 0x33, 0x55, 0xcb, 0x69, 0x2b, 0x17, 0x3d );

// {BECE32B7-42BC-4abf-AA1B-4BADFAA1D0FA}
DEFINE_GUID( TASKID_Minor_HrMakeDottedQuad,
0xbece32b7, 0x42bc, 0x4abf, 0xaa, 0x1b, 0x4b, 0xad, 0xfa, 0xa1, 0xd0, 0xfa );

// {C1ABE5C8-CF87-4178-AFF6-15456E242FD0}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Network,
0xc1abe5c8, 0xcf87, 0x4178, 0xaf, 0xf6, 0x15, 0x45, 0x6e, 0x24, 0x2f, 0xd0 );

// {A9D606CD-F87C-4183-939B-54BB9B5B9EB1}
DEFINE_GUID( TASKID_Minor_GetUID,
0xa9d606cd, 0xf87c, 0x4183, 0x93, 0x9b, 0x54, 0xbb, 0x9b, 0x5b, 0x9e, 0xb1 );

// {29A3E6CA-9838-4519-AABD-B16FE063A8BC}
DEFINE_GUID( TASKID_Minor_NetworkInfo_GetName_Pointer,
0x29a3e6ca, 0x9838, 0x4519, 0xaa, 0xbd, 0xb1, 0x6f, 0xe0, 0x63, 0xa8, 0xbc );

// {4A4CC86D-58A9-4b95-8C79-5A4334E536C0}
DEFINE_GUID( TASKID_Minor_NetworkInfo_GetDescription_Pointer,
0x4a4cc86d, 0x58a9, 0x4b95, 0x8c, 0x79, 0x5a, 0x43, 0x34, 0xe5, 0x36, 0xc0 );

// {2D233574-D980-4b0d-B035-CA74938C4D3E}
DEFINE_GUID( TASKID_Minor_NetworkInfo_GetDescription_Memory,
0x2d233574, 0xd980, 0x4b0d, 0xb0, 0x35, 0xca, 0x74, 0x93, 0x8c, 0x4d, 0x3e );

// {10FFDFA2-B540-4116-BD93-BBE77D3657F0}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress,
0x10ffdfa2, 0xb540, 0x4116, 0xbd, 0x93, 0xbb, 0xe7, 0x7d, 0x36, 0x57, 0xf0 );

// {F5704679-2329-4304-A628-66678D9FE154}
DEFINE_GUID( TASKID_Minor_SetWbemObject_Network,
0xf5704679, 0x2329, 0x4304, 0xa6, 0x28, 0x66, 0x67, 0x8d, 0x9f, 0xe1, 0x54 );

// {C1ABE5C8-CF87-4178-AFF6-15456E242FD1}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Node,
0xc1abe5c8, 0xcf87, 0x4178, 0xaf, 0xf6, 0x15, 0x45, 0x6e, 0x24, 0x2f, 0xd1 );

// {29A3E6CA-9838-4519-AABD-B16FE063A8BD}
DEFINE_GUID( TASKID_Minor_NodeInfo_GetName_Pointer,
0x29a3e6ca, 0x9838, 0x4519, 0xaa, 0xbd, 0xb1, 0x6f, 0xe0, 0x63, 0xa8, 0xbd );

// {008D9491-6D33-43f6-B4E5-09AA3E88920A}
DEFINE_GUID( TASKID_Minor_GetClusterConfigInfo,
0x8d9491, 0x6d33, 0x43f6, 0xb4, 0xe5, 0x9, 0xaa, 0x3e, 0x88, 0x92, 0xa );

// {3131B7BA-91BC-424d-BE88-053A0855255F}
DEFINE_GUID( TASKID_Minor_GetClusterVersion,
0x3131b7ba, 0x91bc, 0x424d, 0xbe, 0x88, 0x5, 0x3a, 0x8, 0x55, 0x25, 0x5f );

// {C6AC35F0-E19E-4caf-83FC-148A6D73E8BC}
DEFINE_GUID( TASKID_Minor_GetOSVersion,
0xc6ac35f0, 0xe19e, 0x4caf, 0x83, 0xfc, 0x14, 0x8a, 0x6d, 0x73, 0xe8, 0xbc );

// {36826AEC-2259-4dd5-8142-429A6CA09C6E}
DEFINE_GUID( TASKID_Minor_GetDriveLetterMappings_Node,
0x36826aec, 0x2259, 0x4dd5, 0x81, 0x42, 0x42, 0x9a, 0x6c, 0xa0, 0x9c, 0x6e );

// {C1ABE5C8-CF87-4178-AFF6-15456E242FD2}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Partition,
0xc1abe5c8, 0xcf87, 0x4178, 0xaf, 0xf6, 0x15, 0x45, 0x6e, 0x24, 0x2f, 0xd2 );

// {A9D606CD-F87C-4183-939B-54BB9B5B9EB2}
DEFINE_GUID( TASKID_Minor_PartitionInfo_GetUID_Pointer,
0xa9d606cd, 0xf87c, 0x4183, 0x93, 0x9b, 0x54, 0xbb, 0x9b, 0x5b, 0x9e, 0xb2 );

// {918FAB6C-FD35-4cd3-95AB-01FBFF0089D8}
DEFINE_GUID( TASKID_Minor_PartitionInfo_GetUID_Memory,
0x918fab6c, 0xfd35, 0x4cd3, 0x95, 0xab, 0x1, 0xfb, 0xff, 0x0, 0x89, 0xd8 );

// {656C7BCE-E1B0-4a1f-8F34-6726AAF16A64}
DEFINE_GUID( TASKID_Minor_PartitionInfo_GetName_Pointer,
0x656c7bce, 0xe1b0, 0x4a1f, 0x8f, 0x34, 0x67, 0x26, 0xaa, 0xf1, 0x6a, 0x64 );

// {F45E0464-5DCB-45f0-9937-599AF9B9651A}
DEFINE_GUID( TASKID_Minor_PartitionInfo_GetDescription_Pointer,
0xf45e0464, 0x5dcb, 0x45f0, 0x99, 0x37, 0x59, 0x9a, 0xf9, 0xb9, 0x65, 0x1a );

// {4BC98FAF-C050-4c0f-8FC5-BA91A861DCD2}
DEFINE_GUID( TASKID_Minor_PartitionInfo_GetDescription_Memory,
0x4bc98faf, 0xc050, 0x4c0f, 0x8f, 0xc5, 0xba, 0x91, 0xa8, 0x61, 0xdc, 0xd2 );

// {D00C1BB1-D028-411e-8A0E-05E3B6880BFA}
DEFINE_GUID( TASKID_Minor_GetDriveLetterMappings_Partition,
0xd00c1bb1, 0xd028, 0x411e, 0x8a, 0xe, 0x5, 0xe3, 0xb6, 0x88, 0xb, 0xfa );

// {86C56A21-94D1-4e63-833F-65FA6BAE9A0A}
DEFINE_GUID( TASKID_Minor_GetSize,
0x86c56a21, 0x94d1, 0x4e63, 0x83, 0x3f, 0x65, 0xfa, 0x6b, 0xae, 0x9a, 0xa );

// {CD1F6FD1-6B40-4b28-AE51-A872837FA966}
DEFINE_GUID( TASKID_Minor_GetFriendlyName,
0xcd1f6fd1, 0x6b40, 0x4b28, 0xae, 0x51, 0xa8, 0x72, 0x83, 0x7f, 0xa9, 0x66 );

// {D88AE9D6-FF82-4836-8949-7AAD1D364E2A}
DEFINE_GUID( TASKID_Minor_SetWbemObject_Partition,
0xd88ae9d6, 0xff82, 0x4836, 0x89, 0x49, 0x7a, 0xad, 0x1d, 0x36, 0x4e, 0x2a );

// {123A6334-CB39-4a6d-9250-6F81D5DC91F7}
DEFINE_GUID( TASKID_Minor_HrAddLogicalDiskToArray,
0x123a6334, 0xcb39, 0x4a6d, 0x92, 0x50, 0x6f, 0x81, 0xd5, 0xdc, 0x91, 0xf7 );

// {12BC9977-5682-4e1d-94E8-7EA2FD396C39}
DEFINE_GUID( TASKID_Minor_HrGetLogicalDisks,
0x12bc9977, 0x5682, 0x4e1d, 0x94, 0xe8, 0x7e, 0xa2, 0xfd, 0x39, 0x6c, 0x39 );

// {4EA6D4FA-F3EF-467d-8666-581E0DCFCA5B}
DEFINE_GUID( TASKID_Minor_HrGetLogicalDisks_Next,
0x4ea6d4fa, 0xf3ef, 0x467d, 0x86, 0x66, 0x58, 0x1e, 0xd, 0xcf, 0xca, 0x5b );

// {7BC914C6-2373-48c4-A6C0-44F99B2712E7}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo,
0x7bc914c6, 0x2373, 0x48c4, 0xa6, 0xc0, 0x44, 0xf9, 0x9b, 0x27, 0x12, 0xe7 );

// {5DE6DDA4-5A3B-4fec-8C15-2AB3078DE738}
DEFINE_GUID( TASKID_Minor_GetManagedResourcesEnum,
0x5de6dda4, 0x5a3b, 0x4fec, 0x8c, 0x15, 0x2a, 0xb3, 0x7, 0x8d, 0xe7, 0x38 );

// {A4CDC2C6-ED7E-4cec-AF8C-0E8C079E7152}
DEFINE_GUID( TASKID_Minor_GetNetworksEnum,
0xa4cdc2c6, 0xed7e, 0x4cec, 0xaf, 0x8c, 0xe, 0x8c, 0x7, 0x9e, 0x71, 0x52 );

// {966B1F9E-EB52-493e-870D-2639C4DE8457}
DEFINE_GUID( TASKID_Minor_GetCallback,
0x966b1f9e, 0xeb52, 0x493e, 0x87, 0xd, 0x26, 0x39, 0xc4, 0xde, 0x84, 0x57 );

// {4CB71CC5-16F3-47fb-A1FC-60A4C09BAA58}
DEFINE_GUID( TASKID_Minor_VerifyConnection_OpenCluster,
0x4cb71cc5, 0x16f3, 0x47fb, 0xa1, 0xfc, 0x60, 0xa4, 0xc0, 0x9b, 0xaa, 0x58 );

// {9731FAE0-EAAC-4080-A48E-3EB01ED27DA8}
DEFINE_GUID( TASKID_Minor_VerifyConnection_MachineNotInCluster,
0x9731fae0, 0xeaac, 0x4080, 0xa4, 0x8e, 0x3e, 0xb0, 0x1e, 0xd2, 0x7d, 0xa8);

// {4DF6D62A-3EC4-40a2-9F4E-8C67565AC6F8}
DEFINE_GUID( TASKID_Minor_VerifyConnection_Cluster_Name_Mismatch,
0x4df6d62a, 0x3ec4, 0x40a2, 0x9f, 0x4e, 0x8c, 0x67, 0x56, 0x5a, 0xc6, 0xf8);

// {D60A2A52-44F2-47b7-AD5B-286AF1176A01}
DEFINE_GUID( TASKID_Minor_VerifyConnection_Cluster_Domain_Mismatch,
0xd60a2a52, 0x44f2, 0x47b7, 0xad, 0x5b, 0x28, 0x6a, 0xf1, 0x17, 0x6a, 0x1);

// {27CD60A8-E60D-4bf9-BFD5-708B2A8844D8}
DEFINE_GUID( TASKID_Minor_VerifyConnection_Node_FQDN_Mismatch,
0x27cd60a8, 0xe60d, 0x4bf9, 0xbf, 0xd5, 0x70, 0x8b, 0x2a, 0x88, 0x44, 0xd8);

// {D638377E-138E-46bf-B301-6BA9799D876A}
DEFINE_GUID( TASKID_Minor_VerifyConnection_Node_Domain_Mismatch,
0xd638377e, 0x138e, 0x46bf, 0xb3, 0x1, 0x6b, 0xa9, 0x79, 0x9d, 0x87, 0x6a);

// {A3A57A39-24DD-4ab6-B1AB-2E71BD396C7B}
DEFINE_GUID( TASKID_Minor_VerifyConnection_InvalidArg,
0xa3a57a39, 0x24dd, 0x4ab6, 0xb1, 0xab, 0x2e, 0x71, 0xbd, 0x39, 0x6c, 0x7b );

// {EEEF01F8-3D6B-42f9-8763-1FA881C9959D}
DEFINE_GUID( TASKID_Minor_HrInitializeForLocalServer_Memory,
0xeeef01f8, 0x3d6b, 0x42f9, 0x87, 0x63, 0x1f, 0xa8, 0x81, 0xc9, 0x95, 0x9d );

// {597670A6-D96E-4d95-BB8F-97A88ECFC953}
DEFINE_GUID( TASKID_Minor_HrInitializeForLocalServer_WbemLocator,
0x597670a6, 0xd96e, 0x4d95, 0xbb, 0x8f, 0x97, 0xa8, 0x8e, 0xcf, 0xc9, 0x53 );

// {A6BC72B1-7317-40b0-A612-471F7551B5A1}
DEFINE_GUID( TASKID_Minor_HrInitializeForLocalServer_Blanket,
0xa6bc72b1, 0x7317, 0x40b0, 0xa6, 0x12, 0x47, 0x1f, 0x75, 0x51, 0xb5, 0xa1 );

// {35C1FB29-7D40-476a-9D97-ABB84D3DBF11}
DEFINE_GUID( TASKID_Minor_WQL_Qry_Next_Failed,
0x35c1fb29, 0x7d40, 0x476a, 0x9d, 0x97, 0xab, 0xb8, 0x4d, 0x3d, 0xbf, 0x11 );

// {B69B25B7-081E-470a-BB2A-63C7B7980EA1}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Enum_IPAddresses,
0xb69b25b7, 0x81e, 0x470a, 0xbb, 0x2a, 0x63, 0xc7, 0xb7, 0x98, 0xe, 0xa1 );

// {30909859-D9FC-4dac-8B97-B66551F5587E}
DEFINE_GUID( TASKID_Minor_Next_Enum_IPAddresses,
0x30909859, 0xd9fc, 0x4dac, 0x8b, 0x97, 0xb6, 0x65, 0x51, 0xf5, 0x58, 0x7e );

// {4F4E0DDA-AA44-43bf-9846-DAF244D9AA9C}
DEFINE_GUID( TASKID_Minor_Clone_Enum_IPAddresses,
0x4f4e0dda, 0xaa44, 0x43bf, 0x98, 0x46, 0xda, 0xf2, 0x44, 0xd9, 0xaa, 0x9c );

// {7A1DC74B-3C66-44d8-939E-78FD780B31CF}
DEFINE_GUID( TASKID_Minor_HrGetAdapterConfiguration,
0x7a1dc74b, 0x3c66, 0x44d8, 0x93, 0x9e, 0x78, 0xfd, 0x78, 0xb, 0x31, 0xcf );

// {08CA442E-A437-4c58-8ABD-2FBC09B5B575}
DEFINE_GUID( TASKID_Minor_HrAddIPAddressToArray,
0x8ca442e, 0xa437, 0x4c58, 0x8a, 0xbd, 0x2f, 0xbc, 0x9, 0xb5, 0xb5, 0x75 );

// {34F97A27-F0CE-4525-8298-18BADFEF58ED}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Enum_Resources,
0x34f97a27, 0xf0ce, 0x4525, 0x82, 0x98, 0x18, 0xba, 0xdf, 0xef, 0x58, 0xed );

// {AFAEA77E-FE81-452e-8D01-96323ACF86B8}
DEFINE_GUID( TASKID_Minor_Next_Enum_Resources,
0xafaea77e, 0xfe81, 0x452e, 0x8d, 0x1, 0x96, 0x32, 0x3a, 0xcf, 0x86, 0xb8 );

// {419DCE7E-A369-494d-AD66-93F2318BAE2D}
DEFINE_GUID( TASKID_Minor_Clone_Enum_Resources,
0x419dce7e, 0xa369, 0x494d, 0xad, 0x66, 0x93, 0xf2, 0x31, 0x8b, 0xae, 0x2d );

// {AD0F7066-3193-4956-AB29-FD1A679974C5}
DEFINE_GUID( TASKID_Minor_HrAddToEnumsArray,
0xad0f7066, 0x3193, 0x4956, 0xab, 0x29, 0xfd, 0x1a, 0x67, 0x99, 0x74, 0xc5 );

// {462DBC4C-4FC6-41ef-88CC-2DCE39F51EA2}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Enum_Networks,
0x462dbc4c, 0x4fc6, 0x41ef, 0x88, 0xcc, 0x2d, 0xce, 0x39, 0xf5, 0x1e, 0xa2 );

// {1E5B21BC-386B-4937-9C78-B07311115975}
DEFINE_GUID( TASKID_Minor_Next_Enum_Networks,
0x1e5b21bc, 0x386b, 0x4937, 0x9c, 0x78, 0xb0, 0x73, 0x11, 0x11, 0x59, 0x75 );

// {E707F47D-0C17-4e48-BC6B-41954CB2AD5F}
DEFINE_GUID( TASKID_Minor_Next_Failed,
0xe707f47d, 0xc17, 0x4e48, 0xbc, 0x6b, 0x41, 0x95, 0x4c, 0xb2, 0xad, 0x5f );

// {E8FB8701-E11B-4d6b-915C-AA6419D1B168}
DEFINE_GUID( TASKID_Minor_Clone_Enum_Networks,
0xe8fb8701, 0xe11b, 0x4d6b, 0x91, 0x5c, 0xaa, 0x64, 0x19, 0xd1, 0xb1, 0x68 );

// {46554D86-113D-4ca3-8DC4-91D0071053D5}
DEFINE_GUID( TASKID_Minor_HrAddNetworkToArray,
0x46554d86, 0x113d, 0x4ca3, 0x8d, 0xc4, 0x91, 0xd0, 0x7, 0x10, 0x53, 0xd5 );

// {96C68A63-5029-4f31-8E92-6314C4FD3541}
DEFINE_GUID( TASKID_Minor_HrGetNetworks,
0x96c68a63, 0x5029, 0x4f31, 0x8e, 0x92, 0x63, 0x14, 0xc4, 0xfd, 0x35, 0x41 );

// {50A0FFC1-3036-4398-9C43-314E832A8829}
DEFINE_GUID( TASKID_Minor_HrGetNetworks_DHCP_Enabled,
0x50a0ffc1, 0x3036, 0x4398, 0x9c, 0x43, 0x31, 0x4e, 0x83, 0x2a, 0x88, 0x29 );

// {AC0A480A-16C6-439c-B4F1-7A4D612BF3F5}
DEFINE_GUID( TASKID_Minor_WQL_Network_Qry_Next_Failed,
0xac0a480a, 0x16c6, 0x439c, 0xb4, 0xf1, 0x7a, 0x4d, 0x61, 0x2b, 0xf3, 0xf5 );

// {7E313740-CB90-4f66-B646-23BC9FDD7D72}
DEFINE_GUID( TASKID_Minor_Next_Enum_Cluster_Resources,
0x7e313740, 0xcb90, 0x4f66, 0xb6, 0x46, 0x23, 0xbc, 0x9f, 0xdd, 0x7d, 0x72 );

// {B619CFE1-F5AA-4de3-A22F-8BE1B5D6D302}
DEFINE_GUID( TASKID_Minor_Clone_Enum_Cluster_Resources,
0xb619cfe1, 0xf5aa, 0x4de3, 0xa2, 0x2f, 0x8b, 0xe1, 0xb5, 0xd6, 0xd3, 0x2 );

// {10C04223-A0C6-4baf-82A0-59574E0ED277}
DEFINE_GUID( TASKID_Minor_HrAddResourceToArray,
0x10c04223, 0xa0c6, 0x4baf, 0x82, 0xa0, 0x59, 0x57, 0x4e, 0xe, 0xd2, 0x77 );

// {629582D3-4CB7-4b2d-9D61-3EDD6090A17E}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Enum_PhysDisk,
0x629582d3, 0x4cb7, 0x4b2d, 0x9d, 0x61, 0x3e, 0xdd, 0x60, 0x90, 0xa1, 0x7e );

// {2C10D58F-A354-456d-8B2F-8622893A0284}
DEFINE_GUID( TASKID_Minor_Next_Enum_PhysDisk,
0x2c10d58f, 0xa354, 0x456d, 0x8b, 0x2f, 0x86, 0x22, 0x89, 0x3a, 0x2, 0x84 );

// {A4E0873B-9FA4-4805-BC80-A1982F3FC861}
DEFINE_GUID( TASKID_Minor_Clone_Enum_PhysDisk,
0xa4e0873b, 0x9fa4, 0x4805, 0xbc, 0x80, 0xa1, 0x98, 0x2f, 0x3f, 0xc8, 0x61 );

// {888EDC6F-EDC9-4fde-B6C0-80A951D7816C}
DEFINE_GUID( TASKID_Minor_HrGetDisks,
0x888edc6f, 0xedc9, 0x4fde, 0xb6, 0xc0, 0x80, 0xa9, 0x51, 0xd7, 0x81, 0x6c );

// {482996DE-E635-4e3f-AD48-9BD43F2275DC}
DEFINE_GUID( TASKID_Minor_HrAddDiskToArray,
0x482996de, 0xe635, 0x4e3f, 0xad, 0x48, 0x9b, 0xd4, 0x3f, 0x22, 0x75, 0xdc );

// {4956B4F1-D6E8-496c-8852-E07BEB155DBA}
DEFINE_GUID( TASKID_Minor_HrIsLogicalDiskNTFS,
0x4956b4f1, 0xd6e8, 0x496c, 0x88, 0x52, 0xe0, 0x7b, 0xeb, 0x15, 0x5d, 0xba );

// {AED97D3F-FA6A-4234-86D1-84899EF85371}
DEFINE_GUID( TASKID_Minor_WQL_Disk_Qry_Next_Failed,
0xaed97d3f, 0xfa6a, 0x4234, 0x86, 0xd1, 0x84, 0x89, 0x9e, 0xf8, 0x53, 0x71 );

// {97E9FCEE-78BA-4a52-9F75-2B0D13F1B126}
DEFINE_GUID( TASKID_Minor_HrIsLogicalDiskNTFS_InvalidArg,
0x97e9fcee, 0x78ba, 0x4a52, 0x9f, 0x75, 0x2b, 0xd, 0x13, 0xf1, 0xb1, 0x26 );

// {AD7ED679-B5C9-4c83-9C4C-DA538BFF3FF9}
DEFINE_GUID( TASKID_Minor_SetWbemServices_PhysDisk,
0xad7ed679, 0xb5c9, 0x4c83, 0x9c, 0x4c, 0xda, 0x53, 0x8b, 0xff, 0x3f, 0xf9 );

// {092E4850-AAB4-4e5d-A4CE-F176F789098D}
DEFINE_GUID( TASKID_Minor_Next_PhysDisk,
0x92e4850, 0xaab4, 0x4e5d, 0xa4, 0xce, 0xf1, 0x76, 0xf7, 0x89, 0x9, 0x8d );

// {AD3E8683-571D-4103-9ECC-3DB5489CB9F6}
DEFINE_GUID( TASKID_Minor_Clone_PhysDisk,
0xad3e8683, 0x571d, 0x4103, 0x9e, 0xcc, 0x3d, 0xb5, 0x48, 0x9c, 0xb9, 0xf6 );

// {DD58545C-B3A4-4754-B51D-2C5A2CD5221D}
DEFINE_GUID( TASKID_Minor_GetDriveLetterMappings_PhysDisk,
0xdd58545c, 0xb3a4, 0x4754, 0xb5, 0x1d, 0x2c, 0x5a, 0x2c, 0xd5, 0x22, 0x1d );

// {D81C8511-2C05-4e31-872C-BF0D3B8CCF21}
DEFINE_GUID( TASKID_Minor_HrGetSCSIBus,
0xd81c8511, 0x2c05, 0x4e31, 0x87, 0x2c, 0xbf, 0xd, 0x3b, 0x8c, 0xcf, 0x21 );

// {1427BB1B-D5E5-49e0-B1EC-9ADE2F56E168}
DEFINE_GUID( TASKID_Minor_HrGetSCSIPort,
0x1427bb1b, 0xd5e5, 0x49e0, 0xb1, 0xec, 0x9a, 0xde, 0x2f, 0x56, 0xe1, 0x68 );

// {7FB74F1A-7C37-4f99-9603-6C4FBD5DEA46}
DEFINE_GUID( TASKID_Minor_HrGetDeviceID_Pointer,
0x7fb74f1a, 0x7c37, 0x4f99, 0x96, 0x3, 0x6c, 0x4f, 0xbd, 0x5d, 0xea, 0x46 );

// {BFC4FD0B-C45E-4c57-A547-5D5DABCC15E5}
DEFINE_GUID( TASKID_Minor_HrGetDeviceID_Memory,
0xbfc4fd0b, 0xc45e, 0x4c57, 0xa5, 0x47, 0x5d, 0x5d, 0xab, 0xcc, 0x15, 0xe5 );

// {5CD9E507-7054-4072-A76F-ED5364BF7E54}
DEFINE_GUID( TASKID_Minor_SetWbemObject_PhysDisk,
0x5cd9e507, 0x7054, 0x4072, 0xa7, 0x6f, 0xed, 0x53, 0x64, 0xbf, 0x7e, 0x54 );

// {4631DF4F-B40A-47d5-9087-95FCA29727C6}
DEFINE_GUID( TASKID_Minor_SetName_PhysDisk,
0x4631df4f, 0xb40a, 0x47d5, 0x90, 0x87, 0x95, 0xfc, 0xa2, 0x97, 0x27, 0xc6 );

// {E9FAAE09-22A0-421e-998B-AEC7E62E0AA9}
DEFINE_GUID( TASKID_Minor_HrGetPartitionInfo,
0xe9faae09, 0x22a0, 0x421e, 0x99, 0x8b, 0xae, 0xc7, 0xe6, 0x2e, 0xa, 0xa9);

// {EF5AD4D5-0CC3-4026-B968-DBC244C5AC07}
DEFINE_GUID( TASKID_Minor_HrAddPartitionToArray,
0xef5ad4d5, 0xcc3, 0x4026, 0xb9, 0x68, 0xdb, 0xc2, 0x44, 0xc5, 0xac, 0x7 );

// {BF8CF687-6066-43af-99AD-2B778028B9E3}
DEFINE_GUID( TASKID_Minor_HrCreateFriendlyName_VOID,
0xbf8cf687, 0x6066, 0x43af, 0x99, 0xad, 0x2b, 0x77, 0x80, 0x28, 0xb9, 0xe3 );

// {44749035-31A1-48ab-932C-A393EA28631D}
DEFINE_GUID( TASKID_Minor_HrCreateFriendlyName_BSTR,
0x44749035, 0x31a1, 0x48ab, 0x93, 0x2c, 0xa3, 0x93, 0xea, 0x28, 0x63, 0x1d );

// {E988F59E-7BAF-4364-99D0-E8A78279FF08}
DEFINE_GUID( TASKID_Minor_WQL_Partition_Qry_Next_Failed,
0xe988f59e, 0x7baf, 0x4364, 0x99, 0xd0, 0xe8, 0xa7, 0x82, 0x79, 0xff, 0x8 );

// {96F37AE0-DEB2-4378-8830-090392478188}
DEFINE_GUID( TASKID_Minor_ClusterResource_GetUID_Pointer,
0x96f37ae0, 0xdeb2, 0x4378, 0x88, 0x30, 0x9, 0x3, 0x92, 0x47, 0x81, 0x88 );

// {7950A141-82C4-42d3-9471-21EFFE51B8FE}
DEFINE_GUID( TASKID_Minor_ClusterResource_GetUID_Memory,
0x7950a141, 0x82c4, 0x42d3, 0x94, 0x71, 0x21, 0xef, 0xfe, 0x51, 0xb8, 0xfe );

// {63945EA5-68BF-460e-84BA-F54B4057B4D6}
DEFINE_GUID( TASKID_Minor_GetName_Pointer,
0x63945ea5, 0x68bf, 0x460e, 0x84, 0xba, 0xf5, 0x4b, 0x40, 0x57, 0xb4, 0xd6 );

// {479E7453-F593-41e7-9C58-90190B51F199}
DEFINE_GUID( TASKID_Minor_LoadResource,
0x479e7453, 0xf593, 0x41e7, 0x9c, 0x58, 0x90, 0x19, 0xb, 0x51, 0xf1, 0x99 );

// {7F7FDF6C-7F68-46bc-BA26-D52320342DBB}
DEFINE_GUID( TASKID_Minor_SetName_Cluster_Resource,
0x7f7fdf6c, 0x7f68, 0x46bc, 0xba, 0x26, 0xd5, 0x23, 0x20, 0x34, 0x2d, 0xbb );

// {52436DAE-9837-4fcc-8F66-57646138E71B}
DEFINE_GUID( TASKID_Minor_PhysDisk_GetUID_Pointer,
0x52436dae, 0x9837, 0x4fcc, 0x8f, 0x66, 0x57, 0x64, 0x61, 0x38, 0xe7, 0x1b );

// {70CB0281-0FE7-47d8-B578-7335D17DC3DC}
DEFINE_GUID( TASKID_Minor_PhysDisk_GetUID_Memory,
0x70cb0281, 0xfe7, 0x47d8, 0xb5, 0x78, 0x73, 0x35, 0xd1, 0x7d, 0xc3, 0xdc );

// {47ACE51F-7D82-4807-90FF-0EC19460CDD8}
DEFINE_GUID( TASKID_Minor_WMI_OS_Qry_Next_Failed,
0x47ace51f, 0x7d82, 0x4807, 0x90, 0xff, 0xe, 0xc1, 0x94, 0x60, 0xcd, 0xd8 );

// {7C8D38EB-6478-4ada-8EF3-08A4D1D45BCA}
DEFINE_GUID( TASKID_Minor_WMI_PageFile_Qry_Next_Failed,
0x7c8d38eb, 0x6478, 0x4ada, 0x8e, 0xf3, 0x8, 0xa4, 0xd1, 0xd4, 0x5b, 0xca );

// {A3CD319B-6365-4c0f-A407-63356D9F750A}
DEFINE_GUID( TASKID_Minor_Warning_NLBS_Detected,
0xa3cd319b, 0x6365, 0x4c0f, 0xa4, 0x7, 0x63, 0x35, 0x6d, 0x9f, 0x75, 0xa );

// {AFAE5AED-F023-4f88-8132-E48B5852139F}
DEFINE_GUID( TASKID_Minor_Validating_Node_OS_Version,
0xafae5aed, 0xf023, 0x4f88, 0x81, 0x32, 0xe4, 0x8b, 0x58, 0x52, 0x13, 0x9f );

// {E90771CD-5FB5-42b1-9BEF-AD88482FC70A}
DEFINE_GUID( TASKID_Minor_LocalQuorum_GetUID_Pointer,
0xe90771cd, 0x5fb5, 0x42b1, 0x9b, 0xef, 0xad, 0x88, 0x48, 0x2f, 0xc7, 0xa );

// {FD5ACD31-B3F6-4025-8C36-9F2F2F4632AB}
DEFINE_GUID( TASKID_Minor_LocalQuorum_GetUID_Memory,
0xfd5acd31, 0xb3f6, 0x4025, 0x8c, 0x36, 0x9f, 0x2f, 0x2f, 0x46, 0x32, 0xab );

// {44E18661-5274-4ba9-8499-1CB30846063D}
DEFINE_GUID( TASKID_Minor_LocalQuorum_GetName_Pointer,
0x44e18661, 0x5274, 0x4ba9, 0x84, 0x99, 0x1c, 0xb3, 0x8, 0x46, 0x6, 0x3d );

// {7F35E707-E4B8-48ee-95AB-573A23688C29}
DEFINE_GUID( TASKID_Minor_LocalQuorum_GetName_Memory,
0x7f35e707, 0xe4b8, 0x48ee, 0x95, 0xab, 0x57, 0x3a, 0x23, 0x68, 0x8c, 0x29 );

// {6BBBE956-2789-4ac0-AE42-4DFA97721960}
DEFINE_GUID( TASKID_Minor_Next_Enum_LocalQuorum,
0x6bbbe956, 0x2789, 0x4ac0, 0xae, 0x42, 0x4d, 0xfa, 0x97, 0x72, 0x19, 0x60 );

// {35EFBE5E-1663-47c7-ADCF-6437D18A8FC3}
DEFINE_GUID( TASKID_Minor_Clone_Enum_LocalQuorum,
0x35efbe5e, 0x1663, 0x47c7, 0xad, 0xcf, 0x64, 0x37, 0xd1, 0x8a, 0x8f, 0xc3 );

// {BB6A4DD7-BC8F-4d76-9FAE-CEC30DE03403}
DEFINE_GUID( TASKID_Minor_PhysDisk_PreCreate,
0xbb6a4dd7, 0xbc8f, 0x4d76, 0x9f, 0xae, 0xce, 0xc3, 0xd, 0xe0, 0x34, 0x3 );

// {A4E827B3-67AF-4642-B0C4-7DF1B66CBE3A}
DEFINE_GUID( TASKID_Minor_PhysDisk_Create,
0xa4e827b3, 0x67af, 0x4642, 0xb0, 0xc4, 0x7d, 0xf1, 0xb6, 0x6c, 0xbe, 0x3a );

// {D6B40DC2-4D5A-42e0-8339-FB6716ACA5CB}
DEFINE_GUID( TASKID_Minor_Server_Get_ClusterIPAddress_Info,
0xd6b40dc2, 0x4d5a, 0x42e0, 0x83, 0x39, 0xfb, 0x67, 0x16, 0xac, 0xa5, 0xcb );

// {AD5DD1EA-960B-4bea-9A40-0809238D9BCF}
DEFINE_GUID(TASKID_Minor_Server_LoadNetwork_Info,
0xad5dd1ea, 0x960b, 0x4bea, 0x9a, 0x40, 0x8, 0x9, 0x23, 0x8d, 0x9b, 0xcf );

// {FADB5F0C-6DDA-47c6-91DE-A5E67C687E23}
DEFINE_GUID( TASKID_Minor_Server_Get_ClusterIPAddress_Info_2,
0xfadb5f0c, 0x6dda, 0x47c6, 0x91, 0xde, 0xa5, 0xe6, 0x7c, 0x68, 0x7e, 0x23 );

// {8F1157D7-2F65-4344-B020-D9D7142D083F}
DEFINE_GUID( TASKID_Minor_Server_GetBindingString_Pointer,
0x8f1157d7, 0x2f65, 0x4344, 0xb0, 0x20, 0xd9, 0xd7, 0x14, 0x2d, 0x8, 0x3f );

// {74C364D1-2A05-4127-A3E0-A900F8D28231}
DEFINE_GUID( TASKID_Minor_Server_GetBindingString_Memory,
0x74c364d1, 0x2a05, 0x4127, 0xa3, 0xe0, 0xa9, 0x0, 0xf8, 0xd2, 0x82, 0x31 );

// {44C5E3BD-CE33-4792-8B51-E2A4DE0AD637}
DEFINE_GUID( TASKID_Minor_SetBindingString_Server,
0x44c5e3bd, 0xce33, 0x4792, 0x8b, 0x51, 0xe2, 0xa4, 0xde, 0xa, 0xd6, 0x37 );

// {EE35061D-C8B0-4afe-8E42-D81E60062DAE}
DEFINE_GUID(TASKID_Minor_ClusterInfo_GetBindingString_Pointer,
0xee35061d, 0xc8b0, 0x4afe, 0x8e, 0x42, 0xd8, 0x1e, 0x60, 0x6, 0x2d, 0xae );

// {9990A0E2-A2A4-4c73-A10B-6D2610B564FE}
DEFINE_GUID( TASKID_Minor_GetBindingString_Binding_String_NULL,
0x9990a0e2, 0xa2a4, 0x4c73, 0xa1, 0xb, 0x6d, 0x26, 0x10, 0xb5, 0x64, 0xfe );

// {D776757B-1457-4851-94E4-DC73F4F7E888}
DEFINE_GUID( TASKID_Minor_GetBindingString_Memory,
0xd776757b, 0x1457, 0x4851, 0x94, 0xe4, 0xdc, 0x73, 0xf4, 0xf7, 0xe8, 0x88 );

// {751E68B3-176B-4d7a-95FC-1CA5F501177A}
DEFINE_GUID( TASKID_Minor_SetBindingString_Cluster,
0x751e68b3, 0x176b, 0x4d7a, 0x95, 0xfc, 0x1c, 0xa5, 0xf5, 0x1, 0x17, 0x7a );

// {51414234-AEB5-4713-AE12-2074D3DDD5BF}
DEFINE_GUID( TASKID_Minor_Server_GetBindingString_NULL,
0x51414234, 0xaeb5, 0x4713, 0xae, 0x12, 0x20, 0x74, 0xd3, 0xdd, 0xd5, 0xbf );

// {EEF4611E-86CD-4372-A2FB-01721D1E4994}
DEFINE_GUID( TASKID_Minor_Pruning_PageFile_Disk_Bus,
0xeef4611e, 0x86cd, 0x4372, 0xa2, 0xfb, 0x1, 0x72, 0x1d, 0x1e, 0x49, 0x94 );

// {13E84779-125E-4b76-8C0D-1F5DB92EFE0F}
DEFINE_GUID( TASKID_Minor_Pruning_Boot_Disk_Bus,
0x13e84779, 0x125e, 0x4b76, 0x8c, 0xd, 0x1f, 0x5d, 0xb9, 0x2e, 0xfe, 0xf );

// {56791EE6-CBFC-46b0-B2FB-3DC26958A525}
DEFINE_GUID( TASKID_Minor_Pruning_System_Disk_Bus,
0x56791ee6, 0xcbfc, 0x46b0, 0xb2, 0xfb, 0x3d, 0xc2, 0x69, 0x58, 0xa5, 0x25 );

// {31B1E6B2-A600-48b9-9A28-6D5D52D3AE4C}
DEFINE_GUID( TASKID_Minor_MajorityNodeSet_GetUID_Pointer,
0x31b1e6b2, 0xa600, 0x48b9, 0x9a, 0x28, 0x6d, 0x5d, 0x52, 0xd3, 0xae, 0x4c );

// {F7BD9D91-4E55-46b7-A7E5-E6A97E2ADF47}
DEFINE_GUID( TASKID_Minor_MajorityNodeSet_GetUID_Memory,
0xf7bd9d91, 0x4e55, 0x46b7, 0xa7, 0xe5, 0xe6, 0xa9, 0x7e, 0x2a, 0xdf, 0x47 );

// {2EF03B9F-FBF7-4207-A831-403F888EE8B7}
DEFINE_GUID( TASKID_Minor_MajorityNodeSet_GetName_Pointer,
0x2ef03b9f, 0xfbf7, 0x4207, 0xa8, 0x31, 0x40, 0x3f, 0x88, 0x8e, 0xe8, 0xb7 );

// {1831238B-DA1D-4fad-88F6-244EA1A013E9}
DEFINE_GUID( TASKID_Minor_MajorityNodeSet_GetName_Memory,
0x1831238b, 0xda1d, 0x4fad, 0x88, 0xf6, 0x24, 0x4e, 0xa1, 0xa0, 0x13, 0xe9 );

// {2C98C5A5-AF98-4845-A51D-1B287DBD9D26}
DEFINE_GUID( TASKID_Minor_MajorityNodeSet_HrSetupShare,
0x2c98c5a5, 0xaf98, 0x4845, 0xa5, 0x1d, 0x1b, 0x28, 0x7d, 0xbd, 0x9d, 0x26);

// {82C9E2A0-3AB2-4547-A85C-E79FF48060B1}
DEFINE_GUID( TASKID_Minor_MajorityNodeSet_Cleanup,
0x82c9e2a0, 0x3ab2, 0x4547, 0xa8, 0x5c, 0xe7, 0x9f, 0xf4, 0x80, 0x60, 0xb1);

// {564BFF7B-25E2-4ffe-BD88-01437EE92750}
DEFINE_GUID( TASKID_Minor_ServicesForMac_Installed,
0x564bff7b, 0x25e2, 0x4ffe, 0xbd, 0x88, 0x1, 0x43, 0x7e, 0xe9, 0x27, 0x50 );

// {457DB343-5BD7-4c40-BCFF-83A2355B488B}
DEFINE_GUID(TASKID_Minor_HrInit_Unknown_Network_Role,
0x457db343, 0x5bd7, 0x4c40, 0xbc, 0xff, 0x83, 0xa2, 0x35, 0x5b, 0x48, 0x8b );

// {E729FB8C-FD50-4653-B816-81EC0B752431}
DEFINE_GUID( TASKID_Minor_HrInit_OutOfMemory,
0xe729fb8c, 0xfd50, 0x4653, 0xb8, 0x16, 0x81, 0xec, 0xb, 0x75, 0x24, 0x31 );

// {EF32FFDD-EE89-4e5e-A9D6-EC65C4D2037E}
DEFINE_GUID( TASKID_Minor_HrInit_No_Network_Name,
0xef32ffdd, 0xee89, 0x4e5e, 0xa9, 0xd6, 0xec, 0x65, 0xc4, 0xd2, 0x3, 0x7e );

// {DE52EE4A-7793-4c88-8BF0-32B5BD8F43D6}
DEFINE_GUID( TASKID_Minor_HrInit_Win32Error,
0xde52ee4a, 0x7793, 0x4c88, 0x8b, 0xf0, 0x32, 0xb5, 0xbd, 0x8f, 0x43, 0xd6 );

// {A47DF4EE-2700-41f9-B586-87A9A7B38BCF}
DEFINE_GUID( TASKID_Minor_Next_Enum_MajorityNodeSet,
0xa47df4ee, 0x2700, 0x41f9, 0xb5, 0x86, 0x87, 0xa9, 0xa7, 0xb3, 0x8b, 0xcf );

// {1CC44272-E513-432b-A90A-2F07EF3DF43C}
DEFINE_GUID( TASKID_Minor_Clone_Enum_MajorityNodeSet,
0x1cc44272, 0xe513, 0x432b, 0xa9, 0xa, 0x2f, 0x7, 0xef, 0x3d, 0xf4, 0x3c );

// {567E8360-B1BB-4689-871A-6DC09B34A1DD}
DEFINE_GUID( TASKID_Minor_PhysDisk_Cluster_Capable,
0x567e8360, 0xb1bb, 0x4689, 0x87, 0x1a, 0x6d, 0xc0, 0x9b, 0x34, 0xa1, 0xdd );

// {2778E165-98D2-4ab4-9E05-AE35070E7E3A}
DEFINE_GUID( TASKID_Minor_HrGetSignature_Pointer,
0x2778e165, 0x98d2, 0x4ab4, 0x9e, 0x5, 0xae, 0x35, 0x7, 0xe, 0x7e, 0x3a );

// {E8CBF170-75B0-473a-AED4-31802D79A7D5}
DEFINE_GUID( TASKID_Minor_HrSetFriendlyName_PhysDisk,
0xe8cbf170, 0x75b0, 0x473a, 0xae, 0xd4, 0x31, 0x80, 0x2d, 0x79, 0xa7, 0xd5 );

// {C354015F-2A10-48aa-B6F2-E069C1F6403B}
DEFINE_GUID( TASKID_Minor_Cannot_Create_PostCfg_Mgr,
0xc354015f, 0x2a10, 0x48aa, 0xb6, 0xf2, 0xe0, 0x69, 0xc1, 0xf6, 0x40, 0x3b );

// {BD205A62-9563-4797-BD26-279806EC1793}
DEFINE_GUID( TASKID_Minor_UnknownQuorum_GetUID_Memory,
0xbd205a62, 0x9563, 0x4797, 0xbd, 0x26, 0x27, 0x98, 0x6, 0xec, 0x17, 0x93 );

// {FC0F9636-A3FA-41db-A884-8337A01C7741}
DEFINE_GUID( TASKID_Minor_Pruning_CrashDump_Disk_Bus,
0xfc0f9636, 0xa3fa, 0x41db, 0xa8, 0x84, 0x83, 0x37, 0xa0, 0x1c, 0x77, 0x41 );

// {DB33BE69-CFAE-488a-890E-C032EC4F56C4}
DEFINE_GUID( TASKID_Minor_Invalid_Credentials,
0xdb33be69, 0xcfae, 0x488a, 0x89, 0xe, 0xc0, 0x32, 0xec, 0x4f, 0x56, 0xc4 );

// {2F35BE93-60D3-4690-95CA-234E45E48C8E}
DEFINE_GUID( TASKID_Minor_Invalid_Domain_User,
0x2f35be93, 0x60d3, 0x4690, 0x95, 0xca, 0x23, 0x4e, 0x45, 0xe4, 0x8c, 0x8e );

// {75970768-B53D-4529-B46F-684D8DB07BAA}
DEFINE_GUID( TASKID_Minor_MREnum_Cannot_Create_Component,
0x75970768, 0xb53d, 0x4529, 0xb4, 0x6f, 0x68, 0x4d, 0x8d, 0xb0, 0x7b, 0xaa );

// {4DF46222-A25C-4a23-9F31-C37492C172E2}
DEFINE_GUID( TASKID_Minor_MREnum_Cannot_QI_Component_For_Punk,
0x4df46222, 0xa25c, 0x4a23, 0x9f, 0x31, 0xc3, 0x74, 0x92, 0xc1, 0x72, 0xe2 );

// {4EA53E2B-6D38-43fa-A8BE-2A39531F5E9F}
DEFINE_GUID( TASKID_Minor_UnknownQuorum_GetUID_Pointer,
0x4ea53e2b, 0x6d38, 0x43fa, 0xa8, 0xbe, 0x2a, 0x39, 0x53, 0x1f, 0x5e, 0x9f );

// {1767468F-5260-4647-AD8A-D86A5826791B}
DEFINE_GUID( TASKID_Minor_UnknownQuorum_GetName_Pointer,
0x1767468f, 0x5260, 0x4647, 0xad, 0x8a, 0xd8, 0x6a, 0x58, 0x26, 0x79, 0x1b );

// {1AD309B4-7156-4cd1-9B0C-E04A5BF9762A}
DEFINE_GUID( TASKID_Minor_UnknownQuorum_GetName_Memory,
0x1ad309b4, 0x7156, 0x4cd1, 0x9b, 0xc, 0xe0, 0x4a, 0x5b, 0xf9, 0x76, 0x2a );

// {D0B47381-6016-4d39-915C-76E538BAADB2}
DEFINE_GUID( TASKID_Minor_MREnum_Cannot_Save_Provider,
0xd0b47381, 0x6016, 0x4d39, 0x91, 0x5c, 0x76, 0xe5, 0x38, 0xba, 0xad, 0xb2 );

// {4E8E31E1-03D1-4760-8F28-B128238B3276}
DEFINE_GUID( TASKID_Minor_Enum_Enum_QI_Failed,
0x4e8e31e1, 0x3d1, 0x4760, 0x8f, 0x28, 0xb1, 0x28, 0x23, 0x8b, 0x32, 0x76 );

// {0156C0E5-0725-4cea-B744-6A082DA6D9C9}
DEFINE_GUID( TASKID_Minor_Enum_Enum_Next_Failed,
0x156c0e5, 0x725, 0x4cea, 0xb7, 0x44, 0x6a, 0x8, 0x2d, 0xa6, 0xd9, 0xc9 );

// {92AA2103-B695-4210-B93B-A475A4BE6DFF}
DEFINE_GUID( TASKID_Minor_Enum_Enum_Count_Failed,
0x92aa2103, 0xb695, 0x4210, 0xb9, 0x3b, 0xa4, 0x75, 0xa4, 0xbe, 0x6d, 0xff );

// {11563557-3D52-45cc-8B63-C68C6AB61FAF}
DEFINE_GUID( TASKID_Minor_Server_Find_Network,
0x11563557, 0x3d52, 0x45cc, 0x8b, 0x63, 0xc6, 0x8c, 0x6a, 0xb6, 0x1f, 0xaf );

// {621AD02A-3EF1-449d-9D5D-B1D609AAB1B8}
DEFINE_GUID( TASKID_Minor_Server_Convert_Network_To_String,
0x621ad02a, 0x3ef1, 0x449d, 0x9d, 0x5d, 0xb1, 0xd6, 0x9, 0xaa, 0xb1, 0xb8 );

// {3DC85E97-0E14-407e-8A27-7D39C8DA5326}
DEFINE_GUID( TASKID_Minor_Server_Convert_ClusterIPAddress_To_String,
0x3dc85e97, 0xe14, 0x407e, 0x8a, 0x27, 0x7d, 0x39, 0xc8, 0xda, 0x53, 0x26 );

// {41FA3C62-EB8A-4e1c-8946-287DCF2A32F9}
DEFINE_GUID( TASKID_Minor_Server_Get_IPAddressResource_Info,
0x41fa3c62, 0xeb8a, 0x4e1c, 0x89, 0x46, 0x28, 0x7d, 0xcf, 0x2a, 0x32, 0xf9 );

// {EE397F10-2514-4a8a-BCCA-A09A04006EF3}
//DEFINE_GUID( ,
//0xee397f10, 0x2514, 0x4a8a, 0xbc, 0xca, 0xa0, 0x9a, 0x4, 0x0, 0x6e, 0xf3 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\clocalquorum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CLocalQuorum.h
//
//  Description:
//      This file contains the declaration of the CLocalQuorum
//      class.
//
//      The class CLocalQuorum represents a cluster storage
//      device. It implements the IClusCfgManagaedResourceInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CLocalQuorum.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CLocalQuorum
//
//  Description:
//      The class CLocalQuorum represents a cluster storage
//      device.
//
//  Interfaces:
//      IClusCfgManagedResourceInfo
//      IClusCfgInitialize
//--
//////////////////////////////////////////////////////////////////////////////
class CLocalQuorum
    : public IClusCfgManagedResourceInfo
    , public IClusCfgInitialize
    , public IClusCfgManagedResourceCfg
    , public IClusCfgVerifyQuorum
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fIsQuorum;
    BOOL                m_fIsMultiNodeCapable;
    BOOL                m_fIsManaged;
    BOOL                m_fIsManagedByDefault;
    BSTR                m_bstrName;
    BOOL                m_fIsQuorumCapable;     // Is this resource quorum capable

    // Private constructors and destructors
    CLocalQuorum( void );
    ~CLocalQuorum( void );

    // Private copy constructor to prevent copying.
    CLocalQuorum( const CLocalQuorum & nodeSrc );

    // Private assignment operator to prevent copying.
    const CLocalQuorum & operator = ( const CLocalQuorum & nodeSrc );

    HRESULT HrInit( void );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR bstrNameIn );

    STDMETHOD( IsManaged )( void );

    STDMETHOD( SetManaged )( BOOL fIsManagedIn );

    STDMETHOD( IsQuorumResource )( void );

    STDMETHOD( SetQuorumResource )( BOOL fIsQuorumResourceIn );

    STDMETHOD( IsQuorumCapable )( void );

    STDMETHOD( SetQuorumCapable )( BOOL fIsQuorumCapableIn );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappings );

    STDMETHOD( IsManagedByDefault )( void );

    STDMETHOD( SetManagedByDefault )( BOOL fIsManagedByDefaultIn );

    //
    //  IClusCfgManagedResourceCfg
    //

    STDMETHOD( PreCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Create )( IUnknown * punkServicesIn );

    STDMETHOD( PostCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Evict )( IUnknown * punkServicesIn );

    //
    //  IClusCfgVerifyQuorum
    //

    STDMETHOD( PrepareToHostQuorumResource )( void );

    STDMETHOD( Cleanup )( EClusCfgCleanupReason cccrReasonIn );

    STDMETHOD( IsMultiNodeCapable )( void );

    STDMETHOD( SetMultiNodeCapable )( BOOL fMultiNodeCapableIn );

}; //*** Class CLocalQuorum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
#endif // DBG==1 || _DEBUG

//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <Pragmas.h>
#include <windows.h>
#include <objbase.h>
#include <wchar.h>
#include <ComCat.h>
#include <clusapi.h>
#include <ClusVerp.h>
#include <lm.h>
#include <sddl.h>
#include <ntddscsi.h>

#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <guids.h>
#include <WBemCli.h>
#include <clusudef.h>
#include <proplist.h>

#include <ClusCfgGuids.h>
#include <ClusCfgInternalGuids.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>
#include <LoadString.h>
#include "ServerStrings.h"
#include <CommonStrings.h>
#include "WMIHelpers.h"
#include <StatusReports.h>
#include "ClusCfgServerGuids.h"
#include <ClusCfgDef.h>
#include <ClusterUtils.h>
#include <nameutil.h>
#include <netcon.h>
#include "clstrcmp.h"


//
//  Switching to use the new safe string functions.
//

#include <StrSafe.h>

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

const WCHAR g_szPhysicalDriveFormat [] = { L"\\\\.\\PHYSICALDRIVE%lu\0" };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\privateinterfaces.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      PrivateInterfaces.h
//
//  Description:
//      This file contains the declaration of the private interfaces used in
//      the cluster configuration server.
//
//  Documentation:
//
//  Implementation Files:
//      None.
//
//  Maintained By:
//      Galen Barbee (GalenB) 29-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <ClusApi.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgWbemServices
//
//  Description:
//      The interface IClusCfgWbemServices is the private interface
//      used by the cluster configuration server to set the WBEM provider
//      in its children.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgWbemServices : public IUnknown
{
public:
    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn ) PURE;

}; //*** Class IClusCfgWbemServices


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgDeviceEnums
//
//  Description:
//      The interface IClusCfgDeviceEnums is the private interface
//      used by the cluster configuration server to set the devices and
//      network enums in its children.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgDeviceEnums : public IUnknown
{
public:
    STDMETHOD( SetDevices )( IUnknown * punkEnumStorage, IUnknown * punkEnumNetworks ) PURE;

}; //*** Class IClusCfgDeviceEnums


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgSetWbemObject
//
//  Description:
//      The interface IClusCfgSetWbemObject is the private interface used by the
//      cluster configuration server to set the WBem object.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgSetWbemObject : public IUnknown
{
public:
    STDMETHOD( SetWbemObject )(
              IWbemClassObject *    pObjectIn
            , bool *                pfRetainObjectOut
            ) PURE;

}; //*** Class IClusCfgSetWbemObject


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgSetClusterNodeInfo
//
//  Description:
//      The interface IClusCfgSetClusterNodeInfo is the private
//      interface used by the cluster configuration server to tell the
//      IClusCfgClusterInfo object if this node is part of a cluster.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgSetClusterNodeInfo : public IUnknown
{
public:
    STDMETHOD( SetClusterNodeInfo )( IClusCfgNodeInfo * pNodeInfoIn ) PURE;

}; //*** Class IClusCfgSetClusterNodeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgSetClusterHandles
//
//  Description:
//      The interface IClusCfgSetClusterHandles is the private
//      interface used by the cluster configuration server to tell the
//      IClusCfgClusterServices object what handles to use.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgSetClusterHandles : public IUnknown
{
public:
    STDMETHOD( SetClusterGroupHandle )( HGROUP hGroupIn ) PURE;

    STDMETHOD( SetClusterHandle )( HCLUSTER hClusterIn ) PURE;

}; //*** Class IClusCfgSetClusterHandles

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgPhysicalDiskProperties
//
//  Description:
//      The interface IClusCfgPhysicalDiskProperties is the private
//      interface used by the cluster configuration server to get the
//      SCSI bus number and whether the disk was booted or not.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgPhysicalDiskProperties : public IUnknown
{
public:
    STDMETHOD( IsThisLogicalDisk )( WCHAR cLogicalDiskIn ) PURE;

    STDMETHOD( HrGetSCSIBus )( ULONG * pulSCSIBusOut ) PURE;

    STDMETHOD( HrGetSCSIPort )( ULONG * pulSCSIPortOut ) PURE;

    STDMETHOD( CanBeManaged )( void ) PURE;

    STDMETHOD( HrGetDeviceID )( BSTR * pbstrDeviceIDOut ) PURE;

    STDMETHOD( HrGetSignature )( DWORD * pdwSignatureOut ) PURE;

    STDMETHOD( HrSetFriendlyName )( LPCWSTR pcszFriendlyNameIn ) PURE;

    STDMETHOD( HrGetDeviceIndex )( DWORD * pidxDeviceOut ) PURE;

    STDMETHOD( HrIsDynamicDisk )( void ) PURE;

    STDMETHOD( HrIsGPTDisk )( void ) PURE;

    STDMETHOD( HrGetDiskNames )( BSTR * pbstrDiskNameOut, BSTR * pbstrDeviceNameOut ) PURE;

}; //*** Class IClusCfgPhysicalDiskProperties

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgPartitionProperties
//
//  Description:
//      The interface IClusCfgPartitionProperties is the private
//      interface used by the cluster configuration server to get the
//      properties of a disk partition.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgPartitionProperties : public IUnknown
{
public:
    STDMETHOD( IsThisLogicalDisk )( WCHAR cLogicalDiskIn ) PURE;

    STDMETHOD( IsNTFS )( void ) PURE;

    STDMETHOD( GetFriendlyName )( BSTR * pbstrNameOut ) PURE;

}; //*** Class IClusCfgPartitionProperties

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgLoadResource
//
//  Description:
//      The interface IClusCfgLoadResource is the private interface used
//      by the cluster configuration server to get a resource loaded from
//      a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgLoadResource : public IUnknown
{
public:
    STDMETHOD( LoadResource )( HCLUSTER hClusterIn, HRESOURCE hResourceIn ) PURE;

}; //*** Class IClusCfgLoadResource

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgSetPollingCallback
//
//  Description:
//      The interface IClusCfgSetPollingCallback is the private interface used
//      by the cluster configuration server to tell the callback object that
//      it should do polling.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgSetPollingCallback : public IUnknown
{
public:
    STDMETHOD( SetPollingMode )( BOOL fUsePollingModeIn ) PURE;

}; //*** Class IClusCfgSetPollingCallback

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgClusterNetworkInfo
//
//  Description:
//      The interface IClusCfgClusterNetworkInfo is the private interface used
//      by the cluster configuration server to tell whether or not a network
//      is already a cluster network.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgClusterNetworkInfo : public IUnknown
{
public:
    STDMETHOD( HrIsClusterNetwork )( void ) PURE;
    STDMETHOD( HrGetNetUID )( BSTR * pbstrUIDOut, const CLSID * pclsidMajorIdIn, LPCWSTR pwszNetworkNameIn ) PURE;
    STDMETHOD( HrGetPrimaryNetAddress )( IClusCfgIPAddressInfo ** ppIPAddressOut, const CLSID * pclsidMajorIdIn, LPCWSTR pwszNetworkNameIn ) PURE;


}; //*** Class IClusCfgClusterNetworkInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\wmihelpers.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      WMIHelpers.h
//
//  Description:
//      This file contains the declaration of the WMI helper functions.
//
//  Documentation:
//
//  Implementation Files:
//      WMIHelpers.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 27-Apr-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Function Declarations
//////////////////////////////////////////////////////////////////////////////


HRESULT
HrGetWMIProperty(
    IWbemClassObject *  pWMIObjectIn,
    LPCWSTR             pcszPropertyNameIn,
    ULONG               ulPropertyTypeIn,
    VARIANT *           pVariantOut
    );

HRESULT
HrSetWbemServices(
    IUnknown *      punkIn,
    IWbemServices * pIWbemServicesIn
    );

HRESULT
HrSetInitialize(
    IUnknown *          punkIn,
    IClusCfgCallback *  picccIn,
    LCID                lcidIn
    );

HRESULT
HrCreateNetworksEnum(
    IClusCfgCallback *  picccIn,
    LCID                lcidIn,
    IWbemServices *     pIWbemServicesIn,
    IUnknown **         ppunkOut
    );
/*
HRESULT
HrLoadOperatingSystemInfo(
    IClusCfgCallback *  picccIn,
    IWbemServices *     pIWbemServicesIn,
    BSTR *              pbstrBootDeviceOut,
    BSTR *              pbstrSystemDeviceOut
    );
*/
HRESULT
HrConvertDeviceVolumeToLogicalDisk(
    BSTR    bstrDeviceVolumeIn,
    BSTR *  pbstrLogicalDiskOut
    );

HRESULT
HrConvertDeviceVolumeToWMIDeviceID(
    BSTR    bstrDeviceVolumeIn,
    BSTR *  pbstrWMIDeviceIDOut
    );

HRESULT
HrGetPageFileLogicalDisks(
    IClusCfgCallback *  picccIn,
    IWbemServices *     pIWbemServicesIn,
    WCHAR               szLogicalDisksOut[ 26 ],
    int *               pcLogicalDisksOut
    );

HRESULT
HrGetSystemDevice( BSTR * pbstrSystemDeviceOut );

HRESULT
HrGetBootLogicalDisk( BSTR * pbstrBootDeviceOut );

HRESULT
HrCheckSecurity( void );

HRESULT
HrGetCrashDumpLogicalDisk( BSTR * pbstrCrashDumpLogicalDiskOut );

//HRESULT
//HrGetVolumeInformation( const WCHAR * pcszRootPathIn, DWORD * pdwFlagsOut, BSTR * pbstrFileSystemOut );

#ifdef DEBUG
    void TraceWMIProperties( IWbemClassObject * pDiskIn );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\cunknownquorum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      CUnknownQuorum.h
//
//  Description:
//      This file contains the declaration of the CUnknownQuorum
//      class.
//
//      The class CUnknownQuorum represents a cluster quorum
//      device. It implements the IClusCfgManagaedResourceInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CUnknownQuorum.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CUnknownQuorum
//
//  Description:
//      The class CUnknownQuorum represents a cluster quorum
//      device.
//
//  Interfaces:
//      IClusCfgManagedResourceInfo
//      IClusCfgInitialize
//--
//////////////////////////////////////////////////////////////////////////////
class CUnknownQuorum
    : public IClusCfgManagedResourceInfo
    , public IClusCfgInitialize
    , public IClusCfgManagedResourceCfg
    , public IClusCfgVerifyQuorum
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fIsQuorum;
    BOOL                m_fIsMultiNodeCapable;
    BOOL                m_fIsManaged;
    BOOL                m_fIsManagedByDefault;
    BSTR                m_bstrName;
    BOOL                m_fIsQuorumCapable;     // Is this resource quorum capable

    // Private constructors and destructors
    CUnknownQuorum( void );
    ~CUnknownQuorum( void );

    // Private copy constructor to prevent copying.
    CUnknownQuorum( const CUnknownQuorum & nodeSrc );

    // Private assignment operator to prevent copying.
    const CUnknownQuorum & operator = ( const CUnknownQuorum & nodeSrc );

    HRESULT HrInit( LPCWSTR pcszNameIn, BOOL fMakeQuorumIn = FALSE );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrCreateInstance( LPCWSTR pcszNameIn, BOOL fMakeQuorumIn, IUnknown ** ppunkOut );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );

    STDMETHOD( IsManaged )( void );

    STDMETHOD( SetManaged )( BOOL fIsManagedIn );

    STDMETHOD( IsQuorumResource )( void );

    STDMETHOD( SetQuorumResource )( BOOL fIsQuorumResourceIn );

    STDMETHOD( IsQuorumCapable )( void );

    STDMETHOD( SetQuorumCapable )( BOOL fIsQuorumCapableIn );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappings );

    STDMETHOD( IsManagedByDefault )( void );

    STDMETHOD( SetManagedByDefault )( BOOL fIsManagedByDefaultIn );

    //
    //  IClusCfgManagedResourceCfg
    //

    STDMETHOD( PreCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Create )( IUnknown * punkServicesIn );

    STDMETHOD( PostCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Evict )( IUnknown * punkServicesIn );

    //
    //  IClusCfgVerifyQuorum
    //

    STDMETHOD( PrepareToHostQuorumResource )( void );

    STDMETHOD( Cleanup )( EClusCfgCleanupReason cccrReasonIn );

    STDMETHOD( IsMultiNodeCapable )( void );

    STDMETHOD( SetMultiNodeCapable )( BOOL fMultiNodeCapableIn );

}; //*** Class CUnknownQuorum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\wmihelpers.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      WmiHelpers.cpp
//
//  Description:
//      This file contains the implementation of WMI help functions.
//
//  Documentation:
//
//  Header File:
//      WmiHelpers.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 27-Apr-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "PrivateInterfaces.h"
#include "CEnumClusCfgNetworks.h"
#include <ClusRtl.h>


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetWMIProperty
//
//  Description:
//      Get a named property from a WMI object.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The IWbemClassObject param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetWMIProperty(
    IWbemClassObject *  pWMIObjectIn,
    LPCWSTR             pcszPropertyNameIn,
    ULONG               ulPropertyTypeIn,
    VARIANT *           pVariantOut
    )
{
    TraceFunc1( "pcszPropertyNameIn = '%ws'", pcszPropertyNameIn );

    Assert( pWMIObjectIn != NULL );
    Assert( pcszPropertyNameIn != NULL );
    Assert( pVariantOut != NULL );

    HRESULT hr;
    BSTR    bstrProp = NULL;

    VariantClear( pVariantOut );

    bstrProp = TraceSysAllocString( pcszPropertyNameIn );
    if ( bstrProp == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pWMIObjectIn->Get( bstrProp, 0L, pVariantOut, NULL, NULL ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] Could not get the value for WMI property '%ws'. (hr = %#08x)", bstrProp, hr );
        goto Cleanup;
    } // if:

    //
    //  KB: 28-JUN-2000 GalenB
    //
    //  For reasons only known to WMI boolean properties are of type VT_NULL instead of
    //  VT_BOOL when they are not set or false...
    //
    //  KB: 27-JUL-2000 GalenB
    //
    //  Added the special case check for signature.  We know that signature will be NULL
    //  when the spindle is under ClusDisk control...
    //
    if ( ( ulPropertyTypeIn != VT_BOOL ) && ( NStringCchCompareNoCase( bstrProp, SysStringLen( bstrProp ) + 1, L"Signature", RTL_NUMBER_OF( L"Signature" ) ) != 0 ) )
    {
        if ( pVariantOut->vt != ulPropertyTypeIn )
        {
            LogMsg( L"[SRV] Variant type for WMI Property '%ws' was supposed to be '%d', but was '%d' instead.", pcszPropertyNameIn, ulPropertyTypeIn, pVariantOut->vt );
            hr = THR( E_PROPTYPEMISMATCH );
        } // if:
    } // if:

Cleanup:

    TraceSysFreeString( bstrProp );

    HRETURN( hr );

} //*** HrGetWMIProperty

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSetWbemServices
//
//  Description:
//      Set the WBemServices object into the passed in punk.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The IUnknown param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSetWbemServices( IUnknown * punkIn, IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT                 hr;
    IClusCfgWbemServices *  pWbemProvider;

    if ( punkIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Exit;
    } // if:

    hr = punkIn->TypeSafeQI( IClusCfgWbemServices, &pWbemProvider );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( pWbemProvider->SetWbemServices( pIWbemServicesIn ) );
        pWbemProvider->Release();
    } // if:
    else if ( hr == E_NOINTERFACE )
    {
        hr = S_OK;
    } // else if:
    else
    {
        THR( hr );
    }

Exit:

    HRETURN( hr );

} //*** HrSetWbemServices


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSetInitialize
//
//  Description:
//      Initialize the passed in punk.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The IUnknown param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSetInitialize(
    IUnknown *          punkIn,
    IClusCfgCallback *  picccIn,
    LCID                lcidIn
    )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT                 hr;
    IClusCfgInitialize *    pcci;
    IUnknown *              punkCallback = NULL;

    if ( punkIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->TypeSafeQI( IUnknown, &punkCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    hr = THR( punkIn->TypeSafeQI( IClusCfgInitialize, &pcci ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = STHR( pcci->Initialize( punkCallback, lcidIn ) );
        pcci->Release();
    } // if:
    else if ( hr == E_NOINTERFACE )
    {
        hr = S_OK;
    } // else if:

Cleanup:

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if:

    HRETURN( hr );

} //*** HrSetInitialize


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCreateNetworksEnum
//
//  Description:
//      Create a network enumerator.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The IUnknown param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCreateNetworksEnum(
    IClusCfgCallback *  picccIn,
    LCID                lcidIn,
    IWbemServices *     pIWbemServicesIn,
    IUnknown **         ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        LogMsg( L"[SRV] HrCreateNetworksEnum() was given a NULL pointer argument." );
        goto Exit;
    } // if:

    hr = THR( CEnumClusCfgNetworks::S_HrCreateInstance( ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if:

    *ppunkOut = TraceInterface( L"CEnumClusCfgNetworks", IUnknown, *ppunkOut, 1 );

    hr = THR( HrSetInitialize( *ppunkOut, picccIn, lcidIn ) );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if:

    hr = THR( HrSetWbemServices( *ppunkOut, pIWbemServicesIn ) );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if:

Exit:

    HRETURN( hr );

} //*** HrCreateNetworksEnum

/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLoadOperatingSystemInfo
//
//  Description:
//      Load the Win32_OperatingSystem object and determine which partition
//      were booted and have the OS installed on them.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLoadOperatingSystemInfo(
    IClusCfgCallback *  picccIn,
    IWbemServices *     pIWbemServicesIn,
    BSTR *              pbstrBootDeviceOut,
    BSTR *              pbstrSystemDeviceOut
    )
{
    TraceFunc( "" );
    Assert( picccIn != NULL );
    Assert( pIWbemServicesIn != NULL );
    Assert( pbstrBootDeviceOut != NULL );
    Assert( pbstrSystemDeviceOut != NULL );

    HRESULT     hr = S_OK;

    BSTR                    bstrClass;
    IEnumWbemClassObject *  pOperatingSystems = NULL;
    ULONG                   ulReturned;
    IWbemClassObject *      pOperatingSystem = NULL;
    int                     c;
    VARIANT                 var;
    HRESULT                 hrTemp;

    VariantInit( &var );

    bstrClass = TraceSysAllocString( L"Win32_OperatingSystem" );
    if ( bstrClass == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( pIWbemServicesIn->CreateInstanceEnum( bstrClass, WBEM_FLAG_SHALLOW, NULL, &pOperatingSystems ) );
    if ( FAILED( hr ) )
    {
        hrTemp = THR( HrSendStatusReport(
              picccIn
            , TASKID_Major_Find_Devices
            , TASKID_Minor_WMI_OS_Qry_Failed
            , 0
            , 1
            , 1
            , hr
            , IDS_ERROR_WMI_OS_QRY_FAILED
            , IDS_ERROR_WMI_OS_QRY_FAILED_REF
            ) );
        if ( FAILED( hrTemp ) )
        {
            hr = hrTemp;
        } // if:

        goto Cleanup;
    } // if:

    for ( c = 1; ; c++ )
    {
        hr = pOperatingSystems->Next( WBEM_INFINITE, 1, &pOperatingSystem, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            Assert( c < 2 );        // only expect one of these!

            hr = THR( HrGetWMIProperty( pOperatingSystem, L"BootDevice", VT_BSTR, &var ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            *pbstrBootDeviceOut = TraceSysAllocString( var.bstrVal );
            if ( *pbstrBootDeviceOut == NULL )
            {
                goto OutOfMemory;
            } // if:

            VariantClear( &var );

            hr = THR( HrGetWMIProperty( pOperatingSystem, L"SystemDevice", VT_BSTR, &var ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            *pbstrSystemDeviceOut = TraceSysAllocString( var.bstrVal );
            if ( *pbstrSystemDeviceOut == NULL )
            {
                goto OutOfMemory;
            } // if:

            pOperatingSystem->Release();
            pOperatingSystem = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            hrTemp = THR( HrSendStatusReport(
                              picccIn
                            , TASKID_Major_Find_Devices
                            , TASKID_Minor_WMI_OS_Qry_Next_Failed
                            , 0
                            , 1
                            , 1
                            , hr
                            , IDS_ERROR_WMI_OS_QRY_FAILED
                            , IDS_ERROR_WMI_OS_QRY_FAILED_REF
                            ) );
            if ( FAILED( hrTemp ) )
            {
                hr = hrTemp;
            } // if:

            goto Cleanup;
        } // else:
    } // for:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    VariantClear( &var );

    if ( pOperatingSystem != NULL )
    {
        pOperatingSystem->Release();
    } // if:

    if ( pOperatingSystems != NULL )
    {
        pOperatingSystems->Release();
    } // if:

    TraceSysFreeString( bstrClass );

    HRETURN( hr );

} //*** HrLoadOperatingSystemInfo
*/

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrConvertDeviceVolumeToLogicalDisk
//
//  Description:
//      Convert a device volume to a logical disk.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrConvertDeviceVolumeToLogicalDisk(
    BSTR    bstrDeviceVolumeIn,
    BSTR *  pbstrLogicalDiskOut
    )
{
    TraceFunc( "" );
    Assert( pbstrLogicalDiskOut != NULL );

    HRESULT     hr = S_OK;
    BOOL        fRet;
    size_t      cchMountPoint;
    WCHAR *     pszMountPoint = NULL;
    WCHAR       szVolume[  MAX_PATH ];
    DWORD       sc;
    DWORD       cchPaths = 16;
    WCHAR *     pszPaths = NULL;
    int         c;
    DWORD       cch;
    WCHAR *     pszEOS = NULL;

    cchMountPoint = wcslen( g_szNameSpaceRoot ) + wcslen( bstrDeviceVolumeIn ) + 2;
    pszMountPoint = new WCHAR[ cchMountPoint ];
    if ( pszMountPoint == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( StringCchCopyW( pszMountPoint, cchMountPoint, g_szNameSpaceRoot ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( StringCchCatExW( pszMountPoint, cchMountPoint, bstrDeviceVolumeIn, &pszEOS, NULL, 0 ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Append a trailing \ and re-terminate the string.
    //

    *pszEOS = L'\\';
    *( pszEOS + 1 ) = L'\0';

    fRet = GetVolumeNameForVolumeMountPoint( pszMountPoint, szVolume, ARRAYSIZE( szVolume ) );
    if ( !fRet )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );

        LogMsg( L"[SRV] GetVolumeNameForVolumeMountPoint() failed.  Mount point is '%ws'. (hr = %#08x)", pszMountPoint, hr );

        //
        //  GetVolumeNameForVolumeMountPoint() is no longer supported for IA64 EFI partitions.  If the error is
        //  ERROR_INVALID_FUNCTION then we should try to get the device number using an IOCTL.
        //
        if ( HRESULT_CODE( hr ) == ERROR_INVALID_FUNCTION )
        {
            LogMsg( L"[SRV] Device volume '%ws' must be an IA64 EFI volume.", bstrDeviceVolumeIn );
        } // if:

        goto Cleanup;
    } // if:

    pszPaths = new WCHAR[ cchPaths ];
    if ( pszPaths == NULL )
    {
        goto OutOfMemory;
    } // if:

    //
    //  KB: 16 JAN 2001 GalenB
    //
    //  Since the device name that is passed in is for a volume there will never be more than
    //  one logical disk in the multisz pszPaths.
    //
    for ( c = 0; ; c++ )
    {
        Assert( c < 2 );            // expect to go through here no more than twice.

        fRet = GetVolumePathNamesForVolumeName( szVolume, pszPaths, cchPaths, &cch );
        if ( fRet )
        {
            break;
        } // if:
        else
        {
            sc = GetLastError();
            if ( sc == ERROR_MORE_DATA )
            {
                cchPaths = cch;

                delete [] pszPaths;
                pszPaths = new WCHAR[ cchPaths ];
                if ( pszPaths == NULL )
                {
                    goto OutOfMemory;
                } // if:

                continue;
            } // if:

            hr = THR( HRESULT_FROM_WIN32( sc ) );
            LogMsg( L"[SRV] GetVolumePathNamesForVolumeName() failed. Volume is is '%ws'. (hr = %#08x)", szVolume, hr );
            goto Cleanup;
        } // else:
    } // for:

    *pbstrLogicalDiskOut = TraceSysAllocString( pszPaths );
    if ( *pbstrLogicalDiskOut == NULL )
    {
        goto OutOfMemory;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    delete [] pszPaths;

    delete [] pszMountPoint;

    HRETURN( hr );

} //*** HrConvertDeviceVolumeToLogicalDisk


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrConvertDeviceVolumeToWMIDeviceID
//
//  Description:
//      Since IA64 EFI partitions no longer support the call to
//      GetVolumeNameForVolumeMountPoint() to convert the device name
//      into a logical disk, since there will not longer be logical disks
//      for these partitions.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrConvertDeviceVolumeToWMIDeviceID(
    BSTR    bstrDeviceVolumeIn,
    BSTR *  pbstrWMIDeviceIDOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    HANDLE                  hVolume = NULL;
    DWORD                   dwSize;
    DWORD                   sc;
    STORAGE_DEVICE_NUMBER   sdnDevNumber;
    BOOL                    fRet;
    size_t                  cchDevice;
    WCHAR *                 pszDevice = NULL;
    WCHAR                   sz[ 64 ];

    cchDevice = wcslen( g_szNameSpaceRoot ) + wcslen( bstrDeviceVolumeIn ) + 2;
    pszDevice = new WCHAR[ cchDevice ];
    if ( pszDevice == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( StringCchCopyW( pszDevice, cchDevice, g_szNameSpaceRoot ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( StringCchCatW( pszDevice, cchDevice, bstrDeviceVolumeIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // get handle to partition
    //

    hVolume = CreateFileW(
                        pszDevice
                      , GENERIC_READ
                      , FILE_SHARE_READ
                      , NULL
                      , OPEN_EXISTING
                      , FILE_ATTRIBUTE_NORMAL
                      , NULL
                      );

    if ( hVolume == INVALID_HANDLE_VALUE )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    //
    // issue storage class ioctl to get drive and partition numbers
    // for this device
    //

    fRet = DeviceIoControl(
                          hVolume
                        , IOCTL_STORAGE_GET_DEVICE_NUMBER
                        , NULL
                        , 0
                        , &sdnDevNumber
                        , sizeof( sdnDevNumber )
                        , &dwSize
                        , NULL
                        );
    if ( !fRet )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( StringCchPrintfW( sz, ARRAYSIZE( sz ), g_szPhysicalDriveFormat, sdnDevNumber.DeviceNumber ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    *pbstrWMIDeviceIDOut = SysAllocString( sz );
    if ( *pbstrWMIDeviceIDOut == NULL )
    {
        goto OutOfMemory;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    LogMsg( L"[SRV] HrConvertDeviceVolumeToWMIDeviceID() is out of memory. (hr = %#08x)", hr );

Cleanup:

    if ( hVolume != NULL )
    {
        CloseHandle( hVolume );
    } // if:

    delete [] pszDevice;

    HRETURN( hr );

} //*** HrConvertDeviceVolumeToWMIDeviceID


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetPageFileLogicalDisks
//
//  Description:
//      Mark the drives that have paging files on them.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetPageFileLogicalDisks(
    IClusCfgCallback *  picccIn,
    IWbemServices *     pIWbemServicesIn,
    WCHAR               szLogicalDisksOut[ 26 ],
    int *               pcLogicalDisksOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_FALSE;
    IEnumWbemClassObject *  pPagingFiles = NULL;
    BSTR                    bstrClass;
    ULONG                   ulReturned;
    IWbemClassObject *      pPagingFile = NULL;
    VARIANT                 var;
    int                     idx;
    HRESULT                 hrTemp;

    bstrClass = TraceSysAllocString( L"Win32_PageFile" );
    if ( bstrClass == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pIWbemServicesIn->CreateInstanceEnum( bstrClass, WBEM_FLAG_SHALLOW, NULL, &pPagingFiles ) );
    if ( FAILED( hr ) )
    {
        hrTemp = THR( HrSendStatusReport(
                          picccIn
                        , TASKID_Major_Find_Devices
                        , TASKID_Minor_WMI_PageFile_Qry_Failed
                        , 0
                        , 1
                        , 1
                        , hr
                        , IDS_ERROR_WMI_PAGEFILE_QRY_FAILED
                        , IDS_ERROR_WMI_PAGEFILE_QRY_FAILED_REF
                        ) );
        if ( FAILED( hrTemp ) )
        {
            hr = hrTemp;
        } // if:

        goto Cleanup;
    } // if:

    VariantInit( &var );

    for ( idx = 0; idx < sizeof( szLogicalDisksOut ); idx++ )
    {
        hr = pPagingFiles->Next( WBEM_INFINITE, 1, &pPagingFile, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            VariantClear( &var );

            hr = THR( HrGetWMIProperty( pPagingFile, L"Drive", VT_BSTR, &var ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            CharUpper( var.bstrVal );

            szLogicalDisksOut[ idx ] = var.bstrVal[ 0 ];

            pPagingFile->Release();
            pPagingFile = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            hrTemp = THR( HrSendStatusReport(
                              picccIn
                            , TASKID_Major_Find_Devices
                            , TASKID_Minor_WMI_PageFile_Qry_Next_Failed
                            , 0
                            , 1
                            , 1
                            , hr
                            , IDS_ERROR_WMI_PAGEFILE_QRY_FAILED
                            , IDS_ERROR_WMI_PAGEFILE_QRY_FAILED_REF
                            ) );
            if ( FAILED( hrTemp ) )
            {
                hr = hrTemp;
            } // if:

            goto Cleanup;
        } // else:
    } // for:

    if ( pcLogicalDisksOut != NULL )
    {
        *pcLogicalDisksOut = idx;
    } // if:

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrClass );

    if ( pPagingFile != NULL )
    {
        pPagingFile->Release();
    } // if:

    if ( pPagingFiles != NULL )
    {
        pPagingFiles->Release();
    } // if:

    HRETURN( hr );

} //*** HrGetPageFileLogicalDisks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetSystemDevice
//
//  Description:
//      Returns the system (booted) device.
//
//  Arguments:
//
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetSystemDevice( BSTR * pbstrSystemDeviceOut )
{
    TraceFunc( "" );
    Assert( pbstrSystemDeviceOut != NULL );

    HRESULT hr = S_OK;
    DWORD   sc;
    HKEY    hKey = NULL;
    WCHAR * pszSystemDevice = NULL;
    DWORD   cbSystemDevice = 0; // no need to but prefix complains #318170
    DWORD   dwType;

    sc = TW32( RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"System\\Setup", 0, KEY_READ, &hKey ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] RegOpenKeyEx() failed. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    sc = TW32( RegQueryValueEx( hKey, L"SystemPartition", NULL, NULL, NULL, &cbSystemDevice ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] RegQueryValueEx() failed. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    pszSystemDevice = new WCHAR[ cbSystemDevice / sizeof( WCHAR ) ];
    if ( pszSystemDevice == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = TW32( RegQueryValueEx( hKey, L"SystemPartition", NULL, &dwType, (BYTE *) pszSystemDevice, &cbSystemDevice ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] RegQueryValueEx() failed. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    if (dwType != REG_SZ) 
    {
        hr = ERROR_DATATYPE_MISMATCH;
        LogMsg( L"[SRV] RegQueryValueEx() invalid type %d", dwType);
        goto Cleanup;
    } // if:

    *pbstrSystemDeviceOut = TraceSysAllocString( pszSystemDevice );
    if ( *pbstrSystemDeviceOut == NULL )
    {
        goto OutOfMemory;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    LogMsg( L"[SRV] HrGetSystemDevice() is out of memory. (hr = %#08x)", hr );

Cleanup:

    delete [] pszSystemDevice;

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
    } // if:

    HRETURN( hr );

} //*** HrGetSystemDevice


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetBootLogicalDisk
//
//  Description:
//      Returns the boot (system) logical disk.
//
//  Arguments:
//
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetBootLogicalDisk( BSTR * pbstrBootLogicalDiskOut )
{
    TraceFunc( "" );
    Assert( pbstrBootLogicalDiskOut != NULL );

    HRESULT hr = S_OK;
    DWORD   sc;
    WCHAR   szWindowsDir[ MAX_PATH ];
    WCHAR   szVolume[ MAX_PATH ];
    BOOL    fRet;

    sc = GetWindowsDirectoryW( szWindowsDir, ARRAYSIZE( szWindowsDir ) );
    if ( sc == 0 )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] GetWindowsDirectory() failed. (hr = %#08x)", hr );
        goto Exit;
    } // if:

    fRet = GetVolumePathName( szWindowsDir, szVolume, ARRAYSIZE( szVolume ) );
    if ( !fRet )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] GetVolumePathName() failed. (hr = %#08x)", hr );
        goto Exit;
    } // if:

    *pbstrBootLogicalDiskOut = TraceSysAllocString( szVolume );
    if ( *pbstrBootLogicalDiskOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    } // if:

Exit:

    HRETURN( hr );

} //*** HrGetBootLogicalDisk


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCheckSecurity
//
//  Description:
//      Checks the server security level.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Secutity is high enough.
//
//      E_ACCESSDENIED
//          Security is not high enough.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCheckSecurity( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IServerSecurity *   piss = NULL;
    DWORD               dwAuthnSvc;
    DWORD               dwAuthzSvc;
    BSTR                bstrServerPrincName = NULL;
    DWORD               dwAuthnLevel;
    DWORD               dwImpersonationLevel;
    void *              pvPrivs = NULL;
    DWORD               dwCapabilities;

    hr = THR( CoGetCallContext( IID_IServerSecurity, reinterpret_cast< void ** >( &piss  ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piss->QueryBlanket(
                &dwAuthnSvc,
                &dwAuthzSvc,
                &bstrServerPrincName,
                &dwAuthnLevel,
                &dwImpersonationLevel,
                &pvPrivs,
                &dwCapabilities ) );

Cleanup:

    SysFreeString( bstrServerPrincName );

    if ( piss != NULL )
    {
        piss->Release();
    } // if:

    HRETURN( hr );

} //*** HrCheckSecurity


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetCrashDumpLogicalDisk
//
//  Description:
//      Returns the logical disk of the system crash dump file.
//
//  Arguments:
//      pbstrCrashDumpLogicalDiskOut
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULTs as errors.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetCrashDumpLogicalDisk(
    BSTR * pbstrCrashDumpLogicalDiskOut
    )
{
    TraceFunc( "" );
    Assert( pbstrCrashDumpLogicalDiskOut != NULL );

    HRESULT hr = S_OK;
    DWORD   sc;
    HKEY    hKey = NULL;
    WCHAR * pszDumpFile = NULL;
    WCHAR * pszExpandedDumpFile = NULL;
    DWORD   cbDumpFile = 0; // no need to but prefix complains #318170
    BSTR    bstr = NULL;
    DWORD dwType;

    sc = TW32( RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\CrashControl", 0, KEY_READ, &hKey ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] [HrGetCrashDumpLogicalDisk] RegOpenKeyEx() failed. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    sc = TW32( RegQueryValueEx( hKey, L"DumpFile", NULL, NULL, NULL, &cbDumpFile ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] [HrGetCrashDumpLogicalDisk] RegQueryValueEx() failed. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    pszDumpFile = new WCHAR[ cbDumpFile / sizeof( WCHAR ) ];
    if ( pszDumpFile == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = TW32( RegQueryValueEx( hKey, L"DumpFile", NULL, &dwType, (BYTE *) pszDumpFile, &cbDumpFile ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] [HrGetCrashDumpLogicalDisk] RegQueryValueEx() failed. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
    {
        hr = ERROR_DATATYPE_MISMATCH;
        LogMsg( L"[SRV] RegQueryValueEx() invalid type %d", dwType);
        goto Cleanup;
    } // if:

    pszExpandedDumpFile = ClRtlExpandEnvironmentStrings( pszDumpFile );     // must use LocalFree()
    if ( pszExpandedDumpFile == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pszExpandedDumpFile );
    if ( bstr == NULL )
    {
        goto OutOfMemory;
    } // if:

    *pbstrCrashDumpLogicalDiskOut = bstr;
    bstr = NULL;

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    LogMsg( L"[SRV] [HrGetCrashDumpLogicalDisk] is out of memory. (hr = %#08x)", hr );

Cleanup:

    LocalFree( pszExpandedDumpFile );
    TraceSysFreeString( bstr );

    delete [] pszDumpFile;

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
    } // if:

    HRETURN( hr );

} //*** HrGetCrashDumpLogicalDisk

/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetVolumeInformation
//
//  Description:
//      Wrapper for the Win32 API GetVolumeInformation.
//
//  Arguments:
//      pcszRootPathIn
//          The path to the volume to get the information about.
//
//      pdwFlagsOut
//          The flags returned.
//
//      pbstrFileSystemOut
//          The filesystem on the volume.
//
//  Return Value:
//      S_OK
//          Success.
//
//      HRESULT errors.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetVolumeInformation(
      const WCHAR * pcszRootPathIn
    , DWORD *       pdwFlagsOut
    , BSTR *        pbstrFileSystemOut
    )
{
    TraceFunc( "" );
    Assert( pcszRootPathIn != NULL );

    HRESULT hr = S_OK;
    int     cTemp;
    BOOL    fRet;
    WCHAR * psz = NULL;
    DWORD   cch = 32;
    DWORD   sc = ERROR_SUCCESS;
    DWORD   dwFlags = 0;

    psz = new WCHAR[ cch ];
    if ( psz == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( cTemp = 0 ; cTemp < 3; cTemp++ )
    {
        fRet = GetVolumeInformationW(
                      pcszRootPathIn
                    , NULL
                    , 0
                    , NULL
                    , NULL
                    , &dwFlags
                    , psz
                    , cch
                    );
        if ( fRet == FALSE )
        {
            sc = GetLastError();
            if ( sc == ERROR_BAD_LENGTH )
            {
                //
                //  Grow the buffer and try again.
                //

                cch += 32;

                delete [] psz;

                psz = new WCHAR[ cch ];
                if ( psz == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                } // if:

                continue;
            } // if:
            else
            {
                TW32( sc );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            } // else:
        } // if:
        else
        {
            sc = ERROR_SUCCESS;
            break;
        } // else:
    } // for:

    if ( sc != ERROR_SUCCESS )
    {
        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( pdwFlagsOut != NULL )
    {
        *pdwFlagsOut = dwFlags;
    } // if:

    if ( pbstrFileSystemOut != NULL )
    {
        *pbstrFileSystemOut = TraceSysAllocString( psz );
        if ( *pbstrFileSystemOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if:

Cleanup:

    delete [] psz;

    HRETURN( hr );

} //*** HrGetVolumeInformation
*/

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceWMIProperties
//
//  Description:
//      Trace the properties to the debugger.
//
//  Arguments:
//
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
void
TraceProperties( IWbemClassObject * pDiskIn )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    VARIANT var;
    BSTR    bstrPropName;
    CIMTYPE cimType;
    LONG    lFlags;

    VariantInit( &var );

    hr = THR( pDiskIn->BeginEnumeration( 0 ) );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if:

    for ( ; ; )
    {
        VariantClear( &var );

        hr = pDiskIn->Next( 0, &bstrPropName, &var, &cimType, &lFlags );
        if ( FAILED( hr ) )
        {
            break;
        } // if:
        else if ( hr == S_OK )
        {
            if ( var.vt == VT_BSTR )
            {
                DebugMsg( L"Property %ws = %ws", bstrPropName, var.bstrVal );
            } // if:

            if ( var.vt == VT_I4 )
            {
                DebugMsg( L"Property %ws = %d", bstrPropName, var.iVal );
            } // if:

            if ( var.vt == VT_BOOL )
            {
                if ( var.boolVal == VARIANT_TRUE )
                {
                    DebugMsg( L"Property %ws = True", bstrPropName );
                } // if:
                else
                {
                    DebugMsg( L"Property %ws = False", bstrPropName );
                } // else:
            } // if:

            if ( var.vt == VT_NULL )
            {
                DebugMsg( L"Property %ws = NULL", bstrPropName );
            } // if:

            TraceSysFreeString( bstrPropName );
            VariantClear( &var );
        } // else if:
        else
        {
            break;
        } // else:
    } // for:

Exit:

    VariantClear( &var );

    TraceFuncExit( );

} //*** TraceWMIProperties
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\test\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\test\callback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      Callback.cpp
//
//  Description:
//      This file contains the implementation of the Callback
//      class.
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "Pch.h"
#include "Callback.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  Callback::Callback
//
//  Description:
//      Constructor of the Callback class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
Callback::Callback( void )
    : m_cRef( 1 )
{
} //*** Callback::Callback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  Callback::~Callback
//
//  Description:
//      Destructor of the Callback class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
Callback::~Callback( void )
{
} //*** Callback::~Callback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  Callback::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a Callback instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface to the newly create object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
Callback::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    Callback *  pccb;
    HRESULT hr;

    pccb = new Callback();
    if ( pccb != NULL )
    {
        hr = pccb->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) );
        pccb->Release();

    } // if: error allocating object
    else
    {
        hr = THR( E_OUTOFMEMORY );
    } // else: out of memory

    return hr;

} //*** Callback::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  Callback::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
Callback::AddRef( void )
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;

} //*** Callback::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  Callback::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
Callback::Release( void )
{
    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        delete this;
    } // if: reference count decremented to zero

    return cRef;

} //*** Callback::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  Callback::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
Callback::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
         *ppvOut = static_cast< IClusCfgCallback * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = static_cast< IClusCfgCallback * >( this );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    return hr;

} //*** Callback::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  Callback::SendStatusReport
//
//  Description:
//      Handle a progress notification
//
//  Arguments:
//      bstrNodeNameIn
//          Name of the node that sent the status report.
//
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUID identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//          Values that indicate the percentage of this task that is
//          completed.
//
//      hrStatusIn
//          Error code.
//
//      bstrDescriptionIn
//          String describing the notification.
//
//  Return Value:
//      Always
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
Callback::SendStatusReport(
      BSTR          bstrNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , BSTR          bstrDescriptionIn
    , FILETIME *    pftTimeIn
    , BSTR          bstrReferenceIn
    ) throw()
{
    wprintf( L"Notification ( %d, %d, %d ) =>\n  '%s' ( Error Code %#08x )\n", ulMinIn, ulMaxIn, ulCurrentIn, bstrDescriptionIn, hrStatusIn );

    return S_OK;

} //*** Callback::SendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\test\callback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCallback.h
//
//  Description:
//      Header file for Callback.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


#pragma once


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the IClusCfgCallback interface
#include "ClusCfgServer.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class Callback
//
//  Description:
//      This class implements the IClusCfgBaseCluster interface.
//
//--
//////////////////////////////////////////////////////////////////////////////
class Callback
    : public IClusCfgCallback
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //////////////////////////////////////////////////////////////////////////

    // Constructor
    Callback( void );

    // Destructor
    ~Callback( void );


    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgCallback methods
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD( SendStatusReport )(
            BSTR        bstrNodeNameIn,
            CLSID       clsidTaskMajorIn,
            CLSID       clsidTaskMinorIn,
            ULONG       ulMinIn,
            ULONG       ulMaxIn,
            ULONG       ulCurrentIn,
            HRESULT     hrStatusIn,
            BSTR        bstrDescriptionIn,
            FILETIME *  pftTimeIn,
            BSTR        bstrReferenceIn
            );

    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

private:
    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG                m_cRef;

}; //*** class Callback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\serverstrings.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ServerStrings.h
//
//  Description:
//      Contains the definition of the string ids used by this library.
//      This file will be included in the main resource header of the project.
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

#include <ResourceIdRanges.h>

//////////////////////////////////////////////////////////////////////////////
//  Informational Strings
//////////////////////////////////////////////////////////////////////////////

#define IDS_INFO_PRUNING_PAGEFILEDISK_BUS               ( ID_CCS_START +   0 )
#define IDS_INFO_PAGEFILEDISK_PRUNED                    ( ID_CCS_START +   1 )
#define IDS_INFO_PAGEFILEDISK_PRUNED_REF                ( ID_CCS_START +   2 )

#define IDS_INFO_PRUNING_BOOTDISK_BUS                   ( ID_CCS_START +  10 )
#define IDS_INFO_BOOTDISK_PRUNED                        ( ID_CCS_START +  11 )
#define IDS_INFO_BOOTDISK_PRUNED_REF                    ( ID_CCS_START +  12 )

#define IDS_INFO_PRUNING_SYSTEMDISK_BUS                 ( ID_CCS_START +  20 )
#define IDS_INFO_SYSTEMDISK_PRUNED                      ( ID_CCS_START +  21 )
#define IDS_INFO_SYSTEMDISK_PRUNED_REF                  ( ID_CCS_START +  22 )

#define IDS_INFO_PHYSDISK_CLUSTER_CAPABLE               ( ID_CCS_START +  30 )
#define IDS_INFO_PHYSDISK_NOT_CLUSTER_CAPABLE           ( ID_CCS_START +  31 )
#define IDS_INFO_PHYSDISK_NOT_CLUSTER_CAPABLE_REF       ( ID_CCS_START +  32 )

#define IDS_INFO_NON_SCSI_DISKS                         ( ID_CCS_START +  40 )
#define IDS_INFO_NON_SCSI_DISKS_REF                     ( ID_CCS_START +  41 )

#define IDS_INFO_GPT_DISK                               ( ID_CCS_START +  50 )
#define IDS_INFO_GPT_DISK_REF                           ( ID_CCS_START +  51 )

#define IDS_INFO_PRUNING_CRASHDUMP_BUS                  ( ID_CCS_START +  60 )
#define IDS_INFO_CRASHDUMPDISK_PRUNED                   ( ID_CCS_START +  61 )
#define IDS_INFO_CRASHDUMPDISK_PRUNED_REF               ( ID_CCS_START +  62 )

#define IDS_VALIDATING_NODE_OS_VERSION                  ( ID_CCS_START +  70 )
#define IDS_INFO_PHYSDISK_PRECREATE                     ( ID_CCS_START +  80 )
#define IDS_INFO_PHYSDISK_CREATE                        ( ID_CCS_START +  90 )
#define IDS_INFO_MNS_PRECREATE                          ( ID_CCS_START + 100 )
#define IDS_INFO_MNS_CREATE                             ( ID_CCS_START + 110 )
#define IDS_INFO_NETWORK_CONNECTION_CONCERN             ( ID_CCS_START + 120 )

//////////////////////////////////////////////////////////////////////////////
//  Warning Strings
//////////////////////////////////////////////////////////////////////////////

#define IDS_WARN_PHYSDISK_NOT_NTFS                      ( ID_CCS_START + 200 )
#define IDS_WARN_PHYSDISK_NOT_NTFS_REF                  ( ID_CCS_START + 201 )

#define IDS_WARN_BOOT_PARTITION_NOT_NTFS                ( ID_CCS_START + 210 )
#define IDS_WARN_BOOT_PARTITION_NOT_NTFS_REF            ( ID_CCS_START + 211 )

#define IDS_WARN_NOT_IP_ENABLED                         ( ID_CCS_START + 220 )
#define IDS_WARN_NOT_IP_ENABLED_REF                     ( ID_CCS_START + 221 )

#define IDS_WARN_NO_IP_ADDRESSES                        ( ID_CCS_START + 230 )
#define IDS_WARN_NO_IP_ADDRESSES_REF                    ( ID_CCS_START + 231 )

#define IDS_WARN_NO_VALID_TCP_CONFIGS                   ( ID_CCS_START + 240 )
#define IDS_WARN_NO_VALID_TCP_CONFIGS_REF               ( ID_CCS_START + 241 )

#define IDS_WARN_NETWORK_NOT_CONNECTED                  ( ID_CCS_START + 250 )
#define IDS_WARN_NETWORK_NOT_CONNECTED_REF              ( ID_CCS_START + 251 )

#define IDS_WARN_NETWORK_SKIPPED                        ( ID_CCS_START + 260 )
#define IDS_WARN_NETWORK_SKIPPED_REF                    ( ID_CCS_START + 261 )

#define IDS_WARN_NLBS_DETECTED                          ( ID_CCS_START + 270 )
#define IDS_WARN_NLBS_DETECTED_REF                      ( ID_CCS_START + 271 )

#define IDS_WARN_SERVICES_FOR_MAC_FAILED                ( ID_CCS_START + 280 )
#define IDS_WARN_SERVICES_FOR_MAC_FAILED_REF            ( ID_CCS_START + 281 )

#define IDS_WARN_SERVICES_FOR_MAC_INSTALLED             ( ID_CCS_START + 290 )
#define IDS_WARN_SERVICES_FOR_MAC_INSTALLED_REF         ( ID_CCS_START + 291 )

#define IDS_WARN_DHCP_ENABLED                           ( ID_CCS_START + 300 )
#define IDS_WARN_DHCP_ENABLED_REF                       ( ID_CCS_START + 301 )

#define IDS_WARN_NETWORK_FIREWALL_ENABLED               ( ID_CCS_START + 310 )
#define IDS_WARN_NETWORK_FIREWALL_ENABLED_REF           ( ID_CCS_START + 311 )

#define IDS_WARN_NETWORK_BRIDGE_ENABLED                 ( ID_CCS_START + 320 )
#define IDS_WARN_NETWORK_BRIDGE_ENABLED_REF             ( ID_CCS_START + 321 )

#define IDS_WARN_NETWORK_BRIDGE_ENDPOINT                ( ID_CCS_START + 330 )
#define IDS_WARN_NETWORK_BRIDGE_ENDPOINT_REF            ( ID_CCS_START + 331 )

#define IDS_WARN_MACHINE_NOT_IN_CLUSTER                 ( ID_CCS_START + 340 )
#define IDS_WARN_CLUSTER_NAME_MISMATCH                  ( ID_CCS_START + 341 )
#define IDS_WARN_CLUSTER_DOMAIN_MISMATCH                ( ID_CCS_START + 342 )

#define IDS_WARN_NODE_FQDN_MISMATCH                     ( ID_CCS_START + 350 )
#define IDS_WARN_NODE_DOMAIN_MISMATCH                   ( ID_CCS_START + 351 )

#define IDS_WARN_NETWORK_INTERFACE_NOT_FOUND            ( ID_CCS_START + 360 )
#define IDS_WARN_NETWORK_INTERFACE_NOT_FOUND_REF        ( ID_CCS_START + 361 )


//////////////////////////////////////////////////////////////////////////////
//  Error Strings
//////////////////////////////////////////////////////////////////////////////

#define IDS_ERROR_INVALID_CREDENTIALS                   ( ID_CCS_START + 1000 )
#define IDS_ERROR_INVALID_CREDENTIALS_REF               ( ID_CCS_START + 1001 )

#define IDS_ERROR_INVALID_DOMAIN_USER                   ( ID_CCS_START + 1010 )
#define IDS_ERROR_INVALID_DOMAIN_USER_REF               ( ID_CCS_START + 1011 )

#define IDS_ERROR_MNS_MISSING_PRIVATE_PROPERTIES        ( ID_CCS_START + 1020 )
#define IDS_ERROR_MNS_MISSING_PRIVATE_PROPERTIES_REF    ( ID_CCS_START + 1021 )

// #define ( ID_CCS_START + 1030 )
// #define ( ID_CCS_START + 1031 )

#define IDS_ERROR_NODE_INFO_CREATE                      ( ID_CCS_START + 1040 )
#define IDS_ERROR_NODE_INFO_CREATE_REF                  ( ID_CCS_START + 1041 )

#define IDS_ERROR_MANAGED_RESOURCE_ENUM_CREATE          ( ID_CCS_START + 1050 )
#define IDS_ERROR_MANAGED_RESOURCE_ENUM_CREATE_REF      ( ID_CCS_START + 1051 )

#define IDS_ERROR_NETWORKS_ENUM_CREATE                  ( ID_CCS_START + 1060 )
#define IDS_ERROR_NETWORKS_ENUM_CREATE_REF              ( ID_CCS_START + 1061 )

#define IDS_ERROR_COMMIT_CHANGES                        ( ID_CCS_START + 1070 )
#define IDS_ERROR_COMMIT_CHANGES_REF                    ( ID_CCS_START + 1071 )

#define IDS_ERROR_CANNOT_CREATE_POSTCFG_MGR             ( ID_CCS_START + 1080 )
#define IDS_ERROR_CANNOT_CREATE_POSTCFG_MGR_REF         ( ID_CCS_START + 1081 )

#define IDS_ERROR_CLUSTER_NAME_NOT_FOUND                ( ID_CCS_START + 1090 )
#define IDS_ERROR_CLUSTER_NAME_NOT_FOUND_REF            ( ID_CCS_START + 1091 )

#define IDS_ERROR_CLUSTER_IP_ADDRESS_NOT_FOUND          ( ID_CCS_START + 1100 )
#define IDS_ERROR_CLUSTER_IP_ADDRESS_NOT_FOUND_REF      ( ID_CCS_START + 1110 )

#define IDS_ERROR_CLUSTER_IP_SUBNET_NOT_FOUND           ( ID_CCS_START + 1120 )
#define IDS_ERROR_CLUSTER_IP_SUBNET_NOT_FOUND_REF       ( ID_CCS_START + 1121 )

#define IDS_ERROR_CLUSTER_NETWORKS_NOT_FOUND            ( ID_CCS_START + 1130 )
#define IDS_ERROR_CLUSTER_NETWORKS_NOT_FOUND_REF        ( ID_CCS_START + 1131 )

#define IDS_ERROR_PRIMARY_IP_NOT_FOUND                  ( ID_CCS_START + 1140 )
#define IDS_ERROR_PRIMARY_IP_NOT_FOUND_REF              ( ID_CCS_START + 1141 )

#define IDS_ERROR_CLUSTER_NETWORK_NOT_FOUND             ( ID_CCS_START + 1150 )
#define IDS_ERROR_CLUSTER_NETWORK_NOT_FOUND_REF         ( ID_CCS_START + 1151 )

#define IDS_ERROR_PHYSDISK_SIGNATURE                    ( ID_CCS_START + 1160 )
#define IDS_ERROR_PHYSDISK_SIGNATURE_REF                ( ID_CCS_START + 1161 )

#define IDS_ERROR_PHYSDISK_NO_FILE_SYSTEM               ( ID_CCS_START + 1170 )
#define IDS_ERROR_PHYSDISK_NO_FILE_SYSTEM_REF           ( ID_CCS_START + 1171 )

#define IDS_ERROR_LDM_DISK                              ( ID_CCS_START + 1180 )
#define IDS_ERROR_LDM_DISK_REF                          ( ID_CCS_START + 1181 )

#define IDS_ERROR_FOUND_NON_SCSI_DISK                   ( ID_CCS_START + 1190 )
#define IDS_ERROR_FOUND_NON_SCSI_DISK_REF               ( ID_CCS_START + 1191 )

#define IDS_ERROR_NODE_DOWN                             ( ID_CCS_START + 1200 )
#define IDS_ERROR_NODE_DOWN_REF                         ( ID_CCS_START + 1201 )

#define IDS_ERROR_WBEM_LOCATOR_CREATE_FAILED            ( ID_CCS_START + 1210 )
#define IDS_ERROR_WBEM_LOCATOR_CREATE_FAILED_REF        ( ID_CCS_START + 1211 )

#define IDS_ERROR_WBEM_CONNECTION_FAILURE               ( ID_CCS_START + 1220 )
#define IDS_ERROR_WBEM_CONNECTION_FAILURE_REF           ( ID_CCS_START + 1221 )

#define IDS_ERROR_WQL_QRY_NEXT_FAILED                   ( ID_CCS_START + 1230 )
#define IDS_ERROR_WQL_QRY_NEXT_FAILED_REF               ( ID_CCS_START + 1231 )

#define IDS_ERROR_WMI_OS_QRY_FAILED                     ( ID_CCS_START + 1240 )
#define IDS_ERROR_WMI_OS_QRY_FAILED_REF                 ( ID_CCS_START + 1241 )

#define IDS_ERROR_WMI_NETWORKADAPTER_QRY_FAILED         ( ID_CCS_START + 1250 )
#define IDS_ERROR_WMI_NETWORKADAPTER_QRY_FAILED_REF     ( ID_CCS_START + 1251 )

#define IDS_ERROR_ENUM_NETWORK_CONNECTIONS_FAILED       ( ID_CCS_START + 1255 )
#define IDS_ERROR_ENUM_NETWORK_CONNECTIONS_FAILED_REF   ( ID_CCS_START + 1256 )

#define IDS_ERROR_WMI_NETWORKADAPTER_DUPE_FOUND         ( ID_CCS_START + 1260 )
#define IDS_ERROR_WMI_NETWORKADAPTER_DUPE_FOUND_REF     ( ID_CCS_START + 1261 )

#define IDS_ERROR_WMI_NETWORKADAPTERSETTINGS_QRY_FAILED ( ID_CCS_START + 1270 )
#define IDS_ERROR_WMI_NETWORKADAPTERSETTINGS_QRY_FAILED_REF ( ID_CCS_START + 1271 )

#define IDS_ERROR_WMI_PAGEFILE_QRY_FAILED               ( ID_CCS_START + 1280 )
#define IDS_ERROR_WMI_PAGEFILE_QRY_FAILED_REF           ( ID_CCS_START + 1281 )

#define IDS_ERROR_WMI_PHYS_DISKS_QRY_FAILED             ( ID_CCS_START + 1290 )
#define IDS_ERROR_WMI_PHYS_DISKS_QRY_FAILED_REF         ( ID_CCS_START + 1291 )

#define IDS_ERROR_WMI_DISKDRIVEPARTITIONS_QRY_FAILED      ( ID_CCS_START + 1300 )
#define IDS_ERROR_WMI_DISKDRIVEPARTITIONS_QRY_FAILED_REF ( ID_CCS_START + 1301 )

#define IDS_ERROR_WMI_GET_LOGICALDISK_FAILED            ( ID_CCS_START + 1310 )
#define IDS_ERROR_WMI_GET_LOGICALDISK_FAILED_REF        ( ID_CCS_START + 1311 )

#define IDS_ERROR_CONVERT_TO_DOTTED_QUAD_FAILED         ( ID_CCS_START + 1320 )
#define IDS_ERROR_CONVERT_TO_DOTTED_QUAD_FAILED_REF     ( ID_CCS_START + 1321 )

#define IDS_ERROR_OPEN_CLUSTER_FAILED                   ( ID_CCS_START + 1330 )
#define IDS_ERROR_OPEN_CLUSTER_FAILED_REF               ( ID_CCS_START + 1331 )

#define IDS_ERROR_MNS_HRSETUPSHARE                      ( ID_CCS_START + 1340 )
#define IDS_ERROR_MNS_HRSETUPSHARE_REF                  ( ID_CCS_START + 1341 )

#define IDS_ERROR_MNS_CLEANUP                           ( ID_CCS_START + 1350 )
#define IDS_ERROR_MNS_CLEANUP_REF                       ( ID_CCS_START + 1351 )

#define IDS_ERROR_PHYSDISK_CLUSTER_CAPABLE              ( ID_CCS_START + 1360 )
#define IDS_ERROR_PHYSDISK_CLUSTER_CAPABLE_REF          ( ID_CCS_START + 1361 )

#define IDS_WARNING_SKIPPING_ENUM                       ( ID_CCS_START + 1370 )
#define IDS_WARNING_SKIPPING_ENUM_REF                   ( ID_CCS_START + 1371 )

//////////////////////////////////////////////////////////////////////////////
//  AppID Security Descriptor Strings
//////////////////////////////////////////////////////////////////////////////

#define IDS_GENERIC_LAUNCH_PERMISSIONS                  ( ID_CCS_START + 1700 )
#define IDS_GENERIC_ACCESS_PERMISSIONS                  ( ID_CCS_START + 1701 )

//////////////////////////////////////////////////////////////////////////////
//  Notification strings
//////////////////////////////////////////////////////////////////////////////

#define IDS_NOTIFY_SERVER_INITIALIZED                   ( ID_CCS_START + 1800 )

//////////////////////////////////////////////////////////////////////////////
//  WMI property name strings
//////////////////////////////////////////////////////////////////////////////

#define IDS_NLBS_SOFT_ADAPTER_NAME                      ( ID_CCS_START + 1900 )
#define IDS_LDM                                         ( ID_CCS_START + 1901 )
#define IDS_GPT                                         ( ID_CCS_START + 1902 )

//////////////////////////////////////////////////////////////////////////////
//  Other useful strings
//////////////////////////////////////////////////////////////////////////////

#define IDS_ENUM_UNKNOWN_QUORUM_COMPONENT_NAME          ( ID_CCS_START + 2000 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\test\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <CITrackerSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\test\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <DebugSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\test\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <InterfaceTableSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\uuid\cluscfgguids.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ClusCfgGuids.cpp
//
//  Description:
//      GUIDs from ClusCfgGuids.h
//
//  Maintained By:
//      David Potter (DavidP) 18-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#include <initguid.h>
#include <ClusCfgGuids.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\startup\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the Startup library.
//
//  Maintained By:
//      David Potter    (DavidP)    25-MAR-2002
//      Vij Vasu        (Vvasu)     03-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#define _UNICODE
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

#define USES_SYSALLOCSTRING

////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <Pragmas.h>

// For the windows API and types
#include <windows.h>

// For COM
#include <objbase.h>
#include <ComCat.h>

#include <StrSafe.h>

// Required to be a part of this DLL
#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <Guids.h>
#include <ClusCfgGuids.h>
#include <ClusCfgInternalGuids.h>
#include <ClusCfgServer.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cenumcfgnetworks.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumCfgNetworks.h
//
//  Description:
//      This file contains the declaration of the CEnumCfgNetworks
//      class.
//
//      The class CEnumCfgNetworks is the enumeration of
//      cluster networks. It implements the IEnumClusCfgNetworks interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumCfgNetworks.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumCfgNetworks
//
//  Description:
//      The class CEnumClusCfgNetworks is the enumeration of cluster networks.
//
//  Interfaces:
//      CBaseEnum
//      IEnumClusCfgNetworks
//      IClusCfgSetHandle
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumCfgNetworks
    : public IEnumClusCfgNetworks
{
private:
    LONG                m_cRef;                 //  Reference counter
    IUnknown *          m_punkOuter;            //  Interface to Outer W2K Proxy object
    IClusCfgCallback *  m_pcccb;                //  Callback interface
    HCLUSTER *          m_phCluster;            //  Pointer to cluster handle
    CLSID *             m_pclsidMajor;          //  Pointer to CLSID to use for logging errors to the UI
    DWORD               m_dwIndex;              //  Current enumer index
    HCLUSENUM           m_hClusEnum;            //  Cluster enumer handle

    CEnumCfgNetworks( void );
    ~CEnumCfgNetworks( void );

    // Private copy constructor to prevent copying.
    CEnumCfgNetworks( const CEnumCfgNetworks & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumCfgNetworks & operator = ( const CEnumCfgNetworks & nodeSrc );

    HRESULT HrInit( IUnknown * punkOuterIn, HCLUSTER * phClusterIn, CLSID * pclsidMajorIn );
    HRESULT HrGetItem( DWORD dwItem, IClusCfgNetworkInfo ** ppNetworkInfoOut );

public:
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut,
                                       IUnknown * punkOuterIn,
                                       HCLUSTER * phClusterIn,
                                       CLSID * pclsidMajorIn
                                       );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnum
    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgNetworkInfo ** rgpNetworkInfoOut, ULONG * pcNumberFetchedOut );
    STDMETHOD( Reset )( void );
    STDMETHOD( Skip )( ULONG cNumberToSkipIn );
    STDMETHOD( Clone )( IEnumClusCfgNetworks ** ppNetworkInfoOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )( BSTR bstrNodeNameIn,
                                   CLSID        clsidTaskMajorIn,
                                   CLSID        clsidTaskMinorIn,
                                   ULONG        ulMinIn,
                                   ULONG        ulMaxIn,
                                   ULONG        ulCurrentIn,
                                   HRESULT      hrStatusIn,
                                   BSTR         bstrDescriptionIn,
                                   FILETIME *   pftTimeIn,
                                   BSTR         bstrReferenceIn
                                   );

}; //*** class CEnumCfgNetworks
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE = 1
#define _UNICODE = 1

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
//#define USES_SYSALLOCSTRING
#endif // DBG==1

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>
#include <wchar.h>

#include <common.h>
#include <debug.h>
#include <Log.h>
#include <citracker.h>
#include <guids.h>
#include <ObjectCookie.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cenumcfgnetworks.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumCfgNetworks.cpp
//
//  Description:
//      CEnumCfgNetworks implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CProxyCfgNetworkInfo.h"
#include "CEnumCfgNetworks.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////


DEFINE_THISCLASS("CEnumCfgNetworks")


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgClusterInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCfgNetworks::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown * punkOuterIn,
    HCLUSTER * phClusterIn,
    CLSID * pclsidMajorIn
    )
{
    TraceFunc( "" );

    HRESULT            hr  = S_OK;
    CEnumCfgNetworks * pcecn = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if

    pcecn = new CEnumCfgNetworks;
    if ( pcecn == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pcecn->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcecn->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( pcecn != NULL )
    {
        pcecn->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumCfgNetworks::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::CEnumCfgNetworks
//
//  Description:
//      Constructor of the CEnumCfgNetworks class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumCfgNetworks::CEnumCfgNetworks( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_cRef == 1 );
    Assert( m_pcccb == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );
    Assert( m_dwIndex == 0 );
    Assert( m_hClusEnum == NULL );

    TraceFuncExit();

} //*** CEnumCfgNetworks::CEnumCfgNetworks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::~CEnumCfgNetworks
//
//  Description:
//      Desstructor of the CEnumCfgNetworks class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumCfgNetworks::~CEnumCfgNetworks( void )
{
    TraceFunc( "" );

    // m_cRef - noop

    if ( m_pcccb )
    {
        m_pcccb->Release();
    } //if:

    // m_phCluster - DO NOT CLOSE!

    // m_pclsidMajor - noop
    // m_dwIndex - noop

    if ( m_hClusEnum != NULL )
        ClusterCloseEnum( m_hClusEnum );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumCfgNetworks::~CEnumCfgNetworks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCfgNetworks::HrInit(
    IUnknown * punkOuterIn,
    HCLUSTER * phClusterIn,
    CLSID * pclsidMajorIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    // IUnknown
    Assert( m_cRef == 1 );

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef();
    }

    if ( phClusterIn == NULL )
        goto InvalidArg;

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( punkOuterIn != NULL )
    {
        hr = THR( punkOuterIn->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    //
    //  Open the enumer.
    //

    m_hClusEnum = ClusterOpenEnum( *m_phCluster, CLUSTER_ENUM_NETWORK );
    if ( m_hClusEnum == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ClusterOpenEnum_Failed, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_InvalidArg, hr );
    goto Cleanup;

} //*** CEnumCfgNetworks::HrInit


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCfgNetworks -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IEnumClusCfgNetworks * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgNetworks ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgNetworks, this, 0 );
    } // else if: IEnumClusCfgNetworks
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumCfgNetworks::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumCfgNetworks::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumCfgNetworks::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumCfgNetworks::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CEnumCfgNetworks::Release


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCfgNetworks -- IEnumClusCfgNetworks interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::Next(
    ULONG                   cNumberRequestedIn,
    IClusCfgNetworkInfo **  rgpNetworkInfoOut,
    ULONG *                 pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr;
    ULONG   cFetched = 0;

    if ( rgpNetworkInfoOut == NULL )
        goto InvalidPointer;

    for ( ; cFetched < cNumberRequestedIn; m_dwIndex ++ )
    {
        hr = STHR( HrGetItem( m_dwIndex, &(rgpNetworkInfoOut[ cFetched ]) ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            continue;   // not a network

        if (  hr == MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NO_MORE_ITEMS ) )
            break;  // no more items

        cFetched ++;

    } // for:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:
    else
    {
        hr = S_OK;
    } // else:

Cleanup:
    if ( FAILED( hr ) )
    {
        ULONG idx;

        for ( idx = 0; idx < cFetched; idx++ )
        {
            (rgpNetworkInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;

    } // if:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_Next_InvalidPointer, hr );
    goto Cleanup;

} //*** CEnumCfgNetworks::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::Reset( void )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    m_dwIndex = 0;

    HRETURN( S_OK );

} //*** CEnumCfgNetworks::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT                 hr;
    DWORD                   idx;
    IClusCfgNetworkInfo *   piccni = NULL;

    for ( idx = 0; idx < cNumberToSkipIn; m_dwIndex ++ )
    {
        hr = STHR( HrGetItem( m_dwIndex, &piccni ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            continue;   // not a network

        if (  hr == MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NO_MORE_ITEMS ) )
            break;  // no more items

        piccni->Release();
        piccni = NULL;

        idx ++;

    } // for:

    if ( idx < cNumberToSkipIn )
    {
        hr = S_FALSE;
    } // if:
    else
    {
        hr = S_OK;
    }

Cleanup:
    Assert( piccni == NULL );

    HRETURN( hr );

} //*** CEnumCfgNetworks::Skip

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::Clone( IEnumClusCfgNetworks ** ppNetworkInfoOut )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CEnumCfgNetworks::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    Assert( m_hClusEnum != NULL );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = ClusterGetEnumCount(m_hClusEnum);

Cleanup:

    HRETURN( hr );

} //*** CEnumCfgNetworks::Count



//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::SendStatusReport(
      BSTR          bstrNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , BSTR          bstrDescriptionIn
    , FILETIME *    pftTimeIn
    , BSTR          bstrReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport(
                              bstrNodeNameIn
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , bstrDescriptionIn
                            , pftTimeIn
                            , bstrReferenceIn
                            ) );
    } // if:

    HRETURN( hr );

}  //*** CEnumCfgNetworks::SendStatusReport


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCfgNetworks -- Private methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::HrGetItem
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCfgNetworks::HrGetItem(
      DWORD                     dwItem
    , IClusCfgNetworkInfo **    ppNetworkInfoOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;
    DWORD   dwTypeDummy;
    DWORD   cchName = 64;   // good starting value
    BSTR    bstrName = NULL;

    IUnknown * punk = NULL;

    Assert( ppNetworkInfoOut != NULL );
    Assert( m_hClusEnum != NULL );

    bstrName = TraceSysAllocStringLen( NULL, cchName );
    if ( bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    cchName ++; // SysAllocStringLen allocates cchName + 1.

    // We are wrapping this a cchName should be significantly large enough to handle
    // most of our testing.
    sc = ClusterEnum( m_hClusEnum, m_dwIndex, &dwTypeDummy, bstrName, &cchName );
    if ( sc == ERROR_MORE_DATA )
    {
        //
        //  Our "typical" buffer is too small. Try make it to the size ClusterEnum
        //  returned.
        //

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        bstrName = TraceSysAllocStringLen( NULL, cchName );
        if ( bstrName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }

        cchName ++; // SysAllocStringLen allocates cchName + 1.

        sc = TW32( ClusterEnum( m_hClusEnum, m_dwIndex, &dwTypeDummy, bstrName, &cchName ) );
    }
    else if ( sc == ERROR_NO_MORE_ITEMS )
    {
        hr = MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NO_MORE_ITEMS );
        goto Cleanup;
    }

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrGetItem_ClusterEnum_Failed, hr );
        goto Cleanup;
    }

    Assert( dwTypeDummy == CLUSTER_ENUM_NETWORK );

    //
    // Create the requested object and store it.
    //

    hr = STHR( CProxyCfgNetworkInfo::S_HrCreateInstance( &punk, m_punkOuter, m_phCluster, m_pclsidMajor, bstrName ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrGetItem_Create_CProxyCfgNetworkInfo_Failed, hr );
        goto Cleanup;
    }

    if ( hr == S_FALSE )
    {
        goto Cleanup;   // This means that the object was not a network resource.
    }

    //
    //  QI for the interface to return.
    //

    hr = THR( punk->TypeSafeQI( IClusCfgNetworkInfo, ppNetworkInfoOut ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrGetItem_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:

    TraceSysFreeString( bstrName );

    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

} // *** CEnumCfgNetworks::HrGetItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\server\test\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Description:
//      The entry point for the application that launches unattended
//      installation of the cluster. This application parses input parameters,
//      CoCreates the Configuration Wizard Component, passes the parsed
//      parameters and invokes the Wizard. The Wizard may or may not show any
//      UI depending on swithes and the (in)availability of information.
//
//  Maintained By:
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>
#include <guids.h>
#include <ClusRtl.h>
#include "Callback.h"

DEFINE_MODULE( "CLUSCFGSERVERTEST" )

//
//  Declarations
//
typedef HRESULT (* PDLLREGISTERSERVER)( void );

//
//  Globals
//
HINSTANCE           g_hInstance = NULL;
LONG                g_cObjects  = 0;
IClusCfgServer *    g_pccs      = NULL;


//
//  Register the DLL
//
HRESULT
HrRegisterTheDll( void )
{
    TraceFunc( "" );

    HRESULT hr;

    PDLLREGISTERSERVER  pDllRegisterServer;

    HMODULE hLib    = NULL;

    //
    //  Make sure the DLL is properly registered.
    //

    hLib = LoadLibrary( L"..\\..\\..\\..\\dll\\obj\\i386\\ClusCfgServer.dll" );
    if ( hLib == NULL )
        goto Win32Error;

    pDllRegisterServer = reinterpret_cast< PDLLREGISTERSERVER >( GetProcAddress( hLib, "DllRegisterServer" ) );
    if ( pDllRegisterServer == NULL )
        goto Win32Error;

    hr = THR( pDllRegisterServer() );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:

    if ( hLib != NULL )
    {
        FreeLibrary( hLib );
    }

    HRETURN( hr );

Win32Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
    goto Cleanup;
}

//
//  This tests the Storage device enumeration.
//
HRESULT
HrTestManagedResourceEnum( void )
{
    TraceFunc( "" );

    HRESULT                         hr;
    IEnumClusCfgManagedResources *  pesd    = NULL;
    ULONG                           cReceived = 0;
    IClusCfgManagedResourceInfo *   rgDevices[ 10 ];

    hr = g_pccs->GetManagedResourcesEnum( &pesd );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    while ( hr == S_OK )
    {
        hr = pesd->Next( sizeof( rgDevices ) / sizeof( rgDevices[ 0 ] ), &rgDevices[ 0 ], &cReceived );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        DebugMsg( "cReceived = %u", cReceived );

        for ( ULONG idx = 0; idx < cReceived; idx++ )
        {
            BSTR    bstr;

            THR( rgDevices[ idx ]->GetUID( &bstr ) );
            DebugMsg( "Device %u, UID = %ws", idx, bstr );
            SysFreeString( bstr );
            rgDevices[ idx ]->Release();
        } // for:
    } // while:

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    } // if:

Cleanup:

    if ( pesd != NULL )
    {
        pesd->Release();
    }

    HRETURN( hr );

} //*** HrTestManagedResourceEnum()


//
//  This tests the Storage device enumeration.
//
HRESULT
HrTestNetworksEnum( void )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IEnumClusCfgNetworks *  pens    = NULL;
    ULONG                   cReceived = 0;
    IClusCfgNetworkInfo *   rdNetworks[ 10 ];
    BSTR                    bstrUID;
    LPWSTR                  lpsz = NULL;
    ULONG                   ulDottedQuad;
    IClusCfgIPAddressInfo * piccipai = NULL;

    hr = g_pccs->GetNetworksEnum( &pens );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    while ( hr == S_OK )
    {
        hr = STHR( pens->Next( sizeof( rdNetworks ) / sizeof( rdNetworks[ 0 ] ), &rdNetworks[ 0 ], &cReceived ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        for ( ULONG idx = 0; idx < cReceived; idx++ )
        {
            hr = THR( rdNetworks[ idx ]->GetPrimaryNetworkAddress( &piccipai ) );
            if ( SUCCEEDED( hr ) )
            {
                hr = THR( piccipai->GetIPAddress( &ulDottedQuad ) );
                if ( SUCCEEDED( hr ) )
                {
                    DWORD   sc;

                    sc = ClRtlTcpipAddressToString( ulDottedQuad, &lpsz );
                    if ( sc == ERROR_SUCCESS )
                    {
                        LocalFree( lpsz );
                        lpsz = NULL;
                    } // if:
                } // if:

                piccipai->Release();
            } // if:

            hr = THR( rdNetworks[ idx ]->GetUID( &bstrUID ) );
            if ( SUCCEEDED( hr ) )
            {
                SysFreeString( bstrUID );
            } // if:

            rdNetworks[ idx ]->Release();
        } // for:
    } // while:

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    } // if:

Cleanup:

    if ( pens != NULL )
    {
        pens->Release();
    }

    if ( lpsz != NULL )
    {
        LocalFree( lpsz );
    } // if:

    HRETURN( hr );

} //*** HrTestNetworksEnum()


//
//  This tests the node information
//
HRESULT
HrTestNodeInfo( void )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IClusCfgNodeInfo *      pccni   = NULL;
    DWORD                   dwNodeHighestVersion;
    DWORD                   dwNodeLowestVersion;
    SDriveLetterMapping     dlmDriveLetterUsage;
    IClusCfgClusterInfo *   pccci = NULL;
    DWORD                   dwMajorVersion;
    DWORD                   dwMinorVersion;
    WORD                    wSuiteMask;
    BYTE                    bProductType;
    BSTR                    bstrCSDVersion = NULL;

    hr = g_pccs->GetClusterNodeInfo( &pccni );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pccni->GetClusterVersion( &dwNodeHighestVersion, &dwNodeLowestVersion );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pccni->GetOSVersion( &dwMajorVersion, &dwMinorVersion, &wSuiteMask, &bProductType, &bstrCSDVersion );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pccni->GetDriveLetterMappings( &dlmDriveLetterUsage );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pccni->GetClusterConfigInfo( &pccci );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( pccci != NULL )
    {
        pccci->Release();
    }

    if ( pccni != NULL )
    {
        pccni->Release();
    }

    SysFreeString( bstrCSDVersion );

    HRETURN( hr );

} //*** HrTestNodeInfo()


//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  main( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int _cdecl
main( void )
{
    HRESULT                 hr;
    IClusCfgInitialize *    pgcci = NULL;
    IClusCfgCapabilities *  piccc = NULL;
    IUnknown *              punkCallback = NULL;

    TraceInitializeProcess();

#if 0
    hr = THR( HrRegisterTheDll() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
#endif

    //
    //  Start up the Cluster configuration server
    //

    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( CoInitializeSecurity(
                    NULL,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE,
                    0
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( CoCreateInstance( CLSID_ClusCfgServer, NULL, CLSCTX_SERVER, TypeSafeParams( IClusCfgServer, &g_pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( g_pccs->TypeSafeQI( IClusCfgInitialize, &pgcci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( Callback::S_HrCreateInstance( &punkCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pgcci->Initialize( punkCallback, GetUserDefaultLCID() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( g_pccs->TypeSafeQI( IClusCfgCapabilities, &piccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccc->CanNodeBeClustered() );
    if ( FAILED( hr ) || ( hr == S_FALSE ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrTestNodeInfo() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrTestManagedResourceEnum() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrTestNetworksEnum() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if:

    if ( piccc != NULL )
    {
        piccc->Release();
    } // if:

    if ( pgcci != NULL )
    {
        pgcci->Release();
    } // if:

    if ( g_pccs != NULL )
    {
        g_pccs->Release();
    }

    CoUninitialize();

    TraceTerminateProcess();

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\startup\startupnotify.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      StartupNotify.h
//
//  Description:
//      This file contains the declaration of the CStartupNotify
//      class. This class is used to notify StartupListeners
//      when the cluster service starts.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      StartupNotify.cpp
//
//  Maintained By:
//      Vij Vasu (VVasu) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For IClusCfgStartupNotify
#include <ClusCfgServer.h>

// For ILogger
#include <ClusCfgClient.h>

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CStartupNotify
//
//  Description:
//      This class is used to notify StartupListeners
//      when the cluster service starts.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CStartupNotify
    : public IClusCfgStartupNotify
    , public IClusCfgCallback
{
public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgStartupNotify methods
    //////////////////////////////////////////////////////////////////////////

    // Send out notification of cluster service startup to interested listeners
    STDMETHOD( SendNotifications )( void );

    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgCallback methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( SendStatusReport )(
                      LPCWSTR       pcszNodeNameIn
                    , CLSID         clsidTaskMajorIn
                    , CLSID         clsidTaskMinorIn
                    , ULONG         ulMinIn
                    , ULONG         ulMaxIn
                    , ULONG         ulCurrentIn
                    , HRESULT       hrStatusIn
                    , LPCWSTR       pcszDescriptionIn
                    , FILETIME *    pftTimeIn
                    , LPCWSTR       pcszReference
                    );

    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );


private:
    //////////////////////////////////////////////////////////////////////////
    //  Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Second phase of a two phase constructor.
    HRESULT HrInit( void );

    // Enumerate all components on the local computer registered for cluster 
    // startup notification.
    HRESULT HrNotifyListeners( void );

    // Instantiate a cluster startup listener component and call the 
    // appropriate methods.
    HRESULT HrProcessListener(
        const CLSID &   rclsidListenerCLSIDIn
      , IUnknown *      punkResTypeServicesIn
      );

    //
    // Private constructors, destructor and assignment operator.
    // All of these methods are private for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CStartupNotify( void );

    // Destructor.
    ~CStartupNotify( void );

    // Copy constructor.
    CStartupNotify( const CStartupNotify & );

    // Assignment operator.
    CStartupNotify & operator =( const CStartupNotify & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG                        m_cRef;

    // IClusCfgCallback
    BSTR                m_bstrNodeName;         // Name of the local node.
    ILogger *           m_plLogger;             // ILogger for doing logging.

}; //*** class CStartupNotify
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\startup\startupnotify.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      StartupNotify.cpp
//
//  Description:
//      This file contains the implementation of the CStartupNotify
//      class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (VVasu)     15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "Pch.h"

// The header file for this class
#include "StartupNotify.h"

#include "clusrtl.h"

// For IClusCfgNodeInfo and related interfaces
#include <ClusCfgServer.h>

// For IClusCfgServer and related interfaces
#include <ClusCfgPrivate.h>

// For CClCfgSrvLogger
#include <Logger.h>

// For POSTCONFIG_COMPLETE_EVENT_NAME
#include "EventName.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CStartupNotify" );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStartupNotify::CStartupNotify
//
//  Description:
//      Constructor of the CStartupNotify class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CStartupNotify::CStartupNotify( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    m_bstrNodeName = NULL;
    m_plLogger = NULL;

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CStartupNotify::CStartupNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStartupNotify::~CStartupNotify
//
//  Description:
//      Destructor of the CStartupNotify class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CStartupNotify::~CStartupNotify( void )
{
    TraceFunc( "" );

    if ( m_plLogger != NULL )
    {
        m_plLogger->Release();
    } // if:

    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CStartupNotify::~CStartupNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CStartupNotify::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CStartupNotify instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CStartupNotify::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CStartupNotify *    pStartupNotify = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    // Allocate memory for the new object.
    pStartupNotify = new CStartupNotify();
    if ( pStartupNotify == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: out of memory

    // Initialize the new object.
    hr = THR( pStartupNotify->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: the object could not be initialized.

    hr = THR( pStartupNotify->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pStartupNotify != NULL )
    {
        pStartupNotify->Release();
    } // if: the pointer to the notification object is not NULL

    HRETURN( hr );

} //*** CStartupNotify::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStartupNotify::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CStartupNotify::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CStartupNotify::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStartupNotify::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CStartupNotify::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count decremented to zero

    CRETURN( cRef );

} //*** CStartupNotify::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStartupNotify::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStartupNotify::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgStartupNotify * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgStartupNotify ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgStartupNotify, this, 0 );
    } // else if: IClusCfgStartupNotify
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CStartupNotify::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStartupNotify::HrInit
//
//  Description:
//      Second phase of a two phase constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CStartupNotify::HrInit( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IServiceProvider *  psp = NULL;
    ILogManager *       plm = NULL;

    // IUnknown
    Assert( m_cRef == 1 );

    //
    // Get a ClCfgSrv ILogger instance.
    //
    hr = THR( CoCreateInstance(
                      CLSID_ServiceManager
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IServiceProvider
                    , reinterpret_cast< void ** >( &psp )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
        
    hr = THR( psp->TypeSafeQS( CLSID_LogManager, ILogManager, &plm ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    hr = THR( plm->GetLogger( &m_plLogger ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Save off the local computer name.
    //  If we can't get the fully-qualified name, just get the NetBIOS name.
    //

    hr = THR( HrGetComputerName(
                      ComputerNameDnsFullyQualified
                    , &m_bstrNodeName
                    , TRUE // fBestEffortIn
                    ) );
    if ( FAILED( hr ) )
    {
        THR( hr );
        LogMsg( L"[SN] An error occurred trying to get the fully-qualified Dns name for the local machine during initialization. Status code is= %1!#08x!.", hr );
        goto Cleanup;
    } // if: error occurred getting computer name

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }

    if ( plm != NULL )
    {
        plm->Release();
    }

    HRETURN( hr );

} //*** CStartupNotify::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStartupNotify::SendNotifications
//
//  Description:
//      This method is called by the Cluster Service to inform the implementor
//      of this interface to send out notification of cluster service startup
//      to interested listeners. If this method is being called for the first
//      time, the method waits till the post configuration steps are complete
//      before sending out the notifications.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStartupNotify::SendNotifications( void )
{
    TraceFunc( "[IClusCfgStartupNotify]" );

    HRESULT     hr = S_OK;
    HANDLE      heventPostCfgCompletion = NULL;

    //
    // If the cluster service is being started for the first time, as a part
    // of adding this node to a cluster (forming or joining), then we have
    // to wait till the post-configuration steps are completed before we
    // can send out notifications.
    //

    LogMsg( "[SN] Trying to create an event named '%s'.", POSTCONFIG_COMPLETE_EVENT_NAME );

    // Create an event in the signalled state. If this event already existed
    // we get a handle to that event, and the state of the event is not changed.
    heventPostCfgCompletion = CreateEvent(
          NULL                                  // event security attributes
        , TRUE                                  // manual-reset event
        , TRUE                                  // create in signaled state
        , POSTCONFIG_COMPLETE_EVENT_NAME
        );

    if ( heventPostCfgCompletion == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        LogMsg( "[SN] Error %#08x occurred trying to create an event named '%s'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
        goto Cleanup;
    } // if: we could not get a handle to the event


    TraceFlow( "Waiting for the event to be signaled." );

    //
    // Now, wait for this event to be signaled. If this method was called due to this
    // node being part of a cluster, this event would have been created in the unsignaled state
    // by the cluster configuration server. However, if this was not the first time that
    // the cluster service is starting on this node, the event would have been created in the
    // signaled state above, and so, the wait below will exit immediately.
    //

    do
    {
        DWORD dwStatus;

        // Wait for any message sent or posted to this queue
        // or for our event to be signaled.
        dwStatus = MsgWaitForMultipleObjects(
              1
            , &heventPostCfgCompletion
            , FALSE
            , 900000                    // If no one has signaled this event in 15 minutes, abort.
            , QS_ALLINPUT
            );

        // The result tells us the type of event we have.
        if ( dwStatus == ( WAIT_OBJECT_0 + 1 ) )
        {
            MSG msg;

            // Read all of the messages in this next loop,
            // removing each message as we read it.
            while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
            {
                // If it is a quit message, we are done pumping messages.
                if ( msg.message == WM_QUIT )
                {
                    TraceFlow( "Get a WM_QUIT message. Exit message pump loop." );
                    break;
                } // if: we got a WM_QUIT message

                // Otherwise, dispatch the message.
                DispatchMessage( &msg );
            } // while: there are still messages in the window message queue

        } // if: we have a message in the window message queue
        else
        {
            if ( dwStatus == WAIT_OBJECT_0 )
            {
                TraceFlow( "Our event has been signaled. Exiting wait loop." );
                break;
            } // else if: our event is signaled
            else
            {
                if ( dwStatus == -1 )
                {
                    dwStatus = TW32( GetLastError() );
                    hr = HRESULT_FROM_WIN32( dwStatus );
                    LogMsg( "[SN] Error %#08x occurred trying to wait for an event to be signaled.", dwStatus );
                } // if: MsgWaitForMultipleObjects() returned an error
                else
                {
                    hr = HRESULT_FROM_WIN32( TW32( dwStatus ) );
                    LogMsg( "[SN] Error %#08x occurred trying to wait for an event to be signaled.", dwStatus );
                } // else: an unexpected value was returned by MsgWaitForMultipleObjects()

                break;
            } // else: an unexpected result
        } // else: MsgWaitForMultipleObjects() exited for a reason other than a waiting message
    }
    while( true ); // do-while: loop infinitely

    if ( FAILED( hr ) )
    {
        TraceFlow( "Something went wrong trying to wait for the event to be signaled." );
        goto Cleanup;
    } // if: something has gone wrong

    TraceFlow( "Our event has been signaled. Proceed with the notifications." );

    // Send out the notifications
    hr = THR( HrNotifyListeners() );
    if ( FAILED( hr ) )
    {
        LogMsg( "[SN] Error %#08x occurred trying to notify cluster startup listeners.", hr );
        goto Cleanup;
    } // if: something went wrong while sending out notifications

    LogMsg( "[SN] Sending of cluster startup notifications complete. (hr = %#08x)", hr );

Cleanup:

    //
    // Clean up
    //

    if ( heventPostCfgCompletion != NULL )
    {
        CloseHandle( heventPostCfgCompletion );
    } // if: we had created the event

    HRETURN( hr );

} //*** CStartupNotify::SendNotifications


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CStartupNotify::HrNotifyListeners
//
//  Description:
//      Enumerate all components on the local computer registered for cluster
//      startup notification.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the enumeration.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CStartupNotify::HrNotifyListeners( void )
{
    TraceFunc( "" );

    const UINT          uiCHUNK_SIZE = 16;

    HRESULT             hr = S_OK;
    ICatInformation *   pciCatInfo = NULL;
    IEnumCLSID *        psleStartupListenerClsidEnum = NULL;
    IUnknown *          punkResTypeServices = NULL;

    ULONG               cReturned = 0;
    CATID               rgCatIdsImplemented[ 1 ];

    rgCatIdsImplemented[ 0 ] = CATID_ClusCfgStartupListeners;

    //
    // Enumerate all the enumerators registered in the
    // CATID_ClusCfgStartupListeners category
    //
    hr = THR(
            CoCreateInstance(
                  CLSID_StdComponentCategoriesMgr
                , NULL
                , CLSCTX_SERVER
                , IID_ICatInformation
                , reinterpret_cast< void ** >( &pciCatInfo )
                )
            );

    if ( FAILED( hr ) )
    {
        LogMsg( "[SN] Error %#08x occurred trying to get a pointer to the enumerator of the CATID_ClusCfgStartupListeners category.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the ICatInformation interface

    // Get a pointer to the enumerator of the CLSIDs that belong to the CATID_ClusCfgStartupListeners category.
    hr = THR(
        pciCatInfo->EnumClassesOfCategories(
              1
            , rgCatIdsImplemented
            , 0
            , NULL
            , &psleStartupListenerClsidEnum
            )
        );

    if ( FAILED( hr ) )
    {
        LogMsg( "[SN] Error %#08x occurred trying to get a pointer to the enumerator of the CATID_ClusCfgStartupListeners category.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the IEnumCLSID interface

    //
    // Create an instance of the resource type services component
    //
    hr = THR(
        HrCoCreateInternalInstance(
              CLSID_ClusCfgResTypeServices
            , NULL
            , CLSCTX_INPROC_SERVER
            , __uuidof( punkResTypeServices )
            , reinterpret_cast< void ** >( &punkResTypeServices )
            )
        );

    if ( FAILED( hr ) )
    {
        LogMsg( "[SN] Error %#08x occurred trying to create the resource type services component.", hr );
        goto Cleanup;
    } // if: we could not create the resource type services component


    // Enumerate the CLSIDs of the registered startup listeners
    do
    {
        CLSID   rgStartupListenerClsids[ uiCHUNK_SIZE ];
        ULONG   idxCLSID;

        cReturned = 0;
        hr = STHR(
            psleStartupListenerClsidEnum->Next(
                  uiCHUNK_SIZE
                , rgStartupListenerClsids
                , &cReturned
                )
            );

        if ( FAILED( hr ) )
        {
            LogMsg( "[SN] Error %#08x occurred trying enumerate startup listener components.", hr );
            break;
        } // if: we could not get the next set of CLSIDs

        // hr may be S_FALSE here, so reset it.
        hr = S_OK;

        for ( idxCLSID = 0; idxCLSID < cReturned; ++idxCLSID )
        {
            hr = THR( HrProcessListener( rgStartupListenerClsids[ idxCLSID ], punkResTypeServices ) );

            if ( FAILED( hr ) )
            {
                // The processing of one of the listeners failed.
                // Log the error, but continue processing other listeners.
                TraceMsgGUID( mtfALWAYS, "The CLSID of the failed listener is ", rgStartupListenerClsids[ idxCLSID ] );
                LogMsg( "[SN] Error %#08x occurred trying to process a cluster startup listener. Other listeners will be processed.", hr );
                hr = S_OK;
            } // if: this enumerator failed
        } // for: iterate through the returned CLSIDs
    }
    while( cReturned > 0 ); // while: there are still CLSIDs to be enumerated

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: something went wrong in the loop above

Cleanup:

    //
    // Cleanup code
    //

    if ( pciCatInfo != NULL )
    {
        pciCatInfo->Release();
    } // if: we had obtained a pointer to the ICatInformation interface

    if ( psleStartupListenerClsidEnum != NULL )
    {
        psleStartupListenerClsidEnum->Release();
    } // if: we had obtained a pointer to the enumerator of startup listener CLSIDs

    if ( punkResTypeServices != NULL )
    {
        punkResTypeServices->Release();
    } // if: we had created the resource type services component

    HRETURN( hr );

} //*** CStartupNotify::HrNotifyListeners


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CStartupNotify::HrProcessListener
//
//  Description:
//      This function instantiates a cluster startup listener component
//      and calls the appropriate methods.
//
//  Arguments:
//      rclsidListenerCLSIDIn
//          CLSID of the startup listener component
//
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface on the resource type services
//          component. This interface provides methods that help configure
//          resource types.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the processing of the listener.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CStartupNotify::HrProcessListener(
      const CLSID &   rclsidListenerCLSIDIn
    , IUnknown *      punkResTypeServicesIn
    )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    IClusCfgInitialize *        pciInitialize = NULL;
    IClusCfgStartupListener *   pcslStartupListener = NULL;

    TraceMsgGUID( mtfALWAYS, "The CLSID of this startup listener is ", rclsidListenerCLSIDIn );

    //
    // Create the component represented by the CLSID passed in
    //
    hr = THR(
            CoCreateInstance(
                  rclsidListenerCLSIDIn
                , NULL
                , CLSCTX_INPROC_SERVER
                , __uuidof( pcslStartupListener )
                , reinterpret_cast< void ** >( &pcslStartupListener )
                )
            );

    if ( FAILED( hr ) )
    {
        LogMsg( "[SN] Error %#08x occurred trying to create a cluster startup listener component.", hr );
        goto Cleanup;
    } // if: we could not create the cluster startup listener component

    // Initialize the listener if supported.
    hr = pcslStartupListener->TypeSafeQI( IClusCfgInitialize, &pciInitialize );
    if ( FAILED( hr ) && ( hr != E_NOINTERFACE ) )
    {
        LogMsg( "[SN] Error %#08x occurred trying to query for IClusCfgInitialize on the listener component.", THR( hr ) );
        goto Cleanup;
    } // if: we could not create the cluster startup listener component

    // Initialize the listener if supported.
    if ( pciInitialize != NULL )
    {
        hr = THR( pciInitialize->Initialize( static_cast< IClusCfgCallback * >( this ), GetUserDefaultLCID() ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "[SN] Error %#08x occurred trying to initialize the listener component.", hr );
            goto Cleanup;
        } // if:

        pciInitialize->Release();
        pciInitialize = NULL;
    } // if: pciInitialize != NULL

    // Notify this listener.
    hr = THR( pcslStartupListener->Notify( punkResTypeServicesIn ) );

    if ( FAILED( hr ) )
    {
        LogMsg( "[SN] Error %#08x occurred trying to notify a cluster startup listener.", hr );
        goto Cleanup;
    } // if: this notification

Cleanup:

    //
    // Cleanup code
    //

    if ( pcslStartupListener != NULL )
    {
        pcslStartupListener->Release();
    } // if: we had obtained a pointer to the startup listener interface

    if ( pciInitialize != NULL )
    {
        pciInitialize->Release();
    } // if: we obtained a pointer to the initialize interface

    HRETURN( hr );

} //*** CStartupNotify::HrProcessListener


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStartupNotify::SendStatusReport(
//        LPCWSTR       pcszNodeNameIn
//      , CLSID         clsidTaskMajorIn
//      , CLSID         clsidTaskMinorIn
//      , ULONG         ulMinIn
//      , ULONG         ulMaxIn
//      , ULONG         ulCurrentIn
//      , HRESULT       hrStatusIn
//      , LPCWSTR       pcszDescriptionIn
//      , FILETIME *    pftTimeIn
//      , LPCWSTR       pcszReferenceIn
//      )
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStartupNotify::SendStatusReport(
      LPCWSTR       pcszNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , LPCWSTR       pcszDescriptionIn
    , FILETIME *    pftTimeIn
    , LPCWSTR       pcszReferenceIn
    )
{
    TraceFunc1( "[IClusCfgCallback] pcszDescriptionIn = '%s'", pcszDescriptionIn == NULL ? TEXT("<null>") : pcszDescriptionIn );

    HRESULT hr = S_OK;

    if ( pcszNodeNameIn == NULL )
    {
        pcszNodeNameIn = m_bstrNodeName;
    } // if:

    TraceMsg( mtfFUNC, L"pcszNodeNameIn = %s", pcszNodeNameIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMajorIn ", clsidTaskMajorIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMinorIn ", clsidTaskMinorIn );
    TraceMsg( mtfFUNC, L"ulMinIn = %u", ulMinIn );
    TraceMsg( mtfFUNC, L"ulMaxIn = %u", ulMaxIn );
    TraceMsg( mtfFUNC, L"ulCurrentIn = %u", ulCurrentIn );
    TraceMsg( mtfFUNC, L"hrStatusIn = %#08x", hrStatusIn );
    TraceMsg( mtfFUNC, L"pcszDescriptionIn = '%ws'", ( pcszDescriptionIn ? pcszDescriptionIn : L"<null>" ) );
    //
    //  TODO:   21 NOV 2000 GalenB
    //
    //  How do we log pftTimeIn?
    //
    TraceMsg( mtfFUNC, L"pcszReferenceIn = '%ws'", ( pcszReferenceIn ? pcszReferenceIn : L"<null>" ) );

    hr = THR( CClCfgSrvLogger::S_HrLogStatusReport(
                      m_plLogger
                    , pcszNodeNameIn
                    , clsidTaskMajorIn
                    , clsidTaskMinorIn
                    , ulMinIn
                    , ulMaxIn
                    , ulCurrentIn
                    , hrStatusIn
                    , pcszDescriptionIn
                    , pftTimeIn
                    , pcszReferenceIn
                    ) );

    HRETURN( hr );

} //*** CStartupNotify::SendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\configclusapi.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ConfigClusApi.h
//
//  Description:
//      ConfigClusApi implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CConfigClusApi
//
//  Description:
//
//  Interfaces:
//      IConfigurationConnection
//      IClusCfgServer
//      IClusCfgInitialize
//      IClusCfgCallback
//      IClusCfgCapabilities
//      IClusCfgClusterConnection
//
//--
//////////////////////////////////////////////////////////////////////////////
class
CConfigClusApi
    : public IConfigurationConnection
    , public IClusCfgServer
    , public IClusCfgCallback
    , public IClusCfgCapabilities
    , public IClusCfgVerify
{
private:
    LONG                        m_cRef;
    HCLUSTER                    m_hCluster;                 //  Cluster connection.
    IClusCfgCallback *          m_pcccb;                    //  Callback interface
    CLSID                       m_clsidMajor;               //  What TASKID to log UI errors to.
    CLSID                       m_clsidType;                //  What type of cookie was used to open connection.
    BSTR                        m_bstrName;                 //  Name of node or cluster connected to.
    BSTR                        m_bstrBindingString;        //  Binding string

    CConfigClusApi( void );
    ~CConfigClusApi( void );

    // Private copy constructor to prevent copying.
    CConfigClusApi( const CConfigClusApi & nodeSrc );

    // Private assignment operator to prevent copying.
    const CConfigClusApi & operator = ( const CConfigClusApi & nodeSrc );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IConfigurationConnection
    STDMETHOD( ConnectTo )( OBJECTCOOKIE cookieIn );
    STDMETHOD( ConnectToObject )( OBJECTCOOKIE cookieIn, REFIID riidIn, LPUNKNOWN * ppunkOut );

    // IClusCfgServer
    STDMETHOD( GetClusterNodeInfo )( IClusCfgNodeInfo ** ppClusterNodeInfoOut );
    STDMETHOD( GetManagedResourcesEnum )( IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut );
    STDMETHOD( GetNetworksEnum )( IEnumClusCfgNetworks ** ppEnumNetworksOut );
    STDMETHOD( CommitChanges )( void );
    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );
    STDMETHOD( SetBindingString )( LPCWSTR bstrBindingStringIn );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

    // IClusCfgCapabilities
    STDMETHOD( CanNodeBeClustered )( void );

    // IClusCfgVerify
    STDMETHOD( VerifyCredentials )( LPCWSTR bstrUserIn, LPCWSTR bstrDomainIn, LPCWSTR bstrPasswordIn );
    STDMETHOD( VerifyConnectionToCluster )( LPCWSTR bstrClusterNameIn );
    STDMETHOD( VerifyConnectionToNode )( LPCWSTR bstrNodeNameIn );

}; //*** class CConfigClusApi
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\configclusapi.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ConfigClusApi.cpp
//
//  Description:
//      CConfigClusApi implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ConfigClusApi.h"
#include "CProxyCfgNodeInfo.h"
#include "CEnumCfgResources.h"
#include "CEnumCfgNetworks.h"
#include "StatusReports.h"
#include "nameutil.h"

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CConfigClusApi");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrMakeClusterFQDN
//
//  Description:
//      Construct a cluster's FQDN given a cluster handle and an FQIP (an IP
//      address with a domain appended after a pipe |).
//
//  Arguments:
//      hClusterIn
//      pcwszClusterFQIPIn
//      pbstrFQDNOut
//
//  Return Values:
//      S_OK
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrMakeClusterFQDN(
      HCLUSTER  hClusterIn
    , PCWSTR    pcwszClusterFQIPIn
    , BSTR *    pbstrFQDNOut
    )
{
    TraceFunc( "" );
    
    HRESULT hr = S_OK;
    BSTR    bstrClusterName = NULL;
    size_t  idxClusterDomain = 0;

    //    
    //  Get cluster hostname from handle.
    //    

    hr = THR( HrGetClusterInformation( hClusterIn, &bstrClusterName, NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    //    
    //  Get domain from pcwszClusterFQIPIn.
    //    

    hr = THR( HrFindDomainInFQN( pcwszClusterFQIPIn, &idxClusterDomain ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    //    
    //  Make FQDN from cluster hostname and domain part of pcwszClusterFQIPIn.
    //    

    hr = THR( HrMakeFQN( bstrClusterName, pcwszClusterFQIPIn + idxClusterDomain, true, pbstrFQDNOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
Cleanup:

    TraceSysFreeString( bstrClusterName );
    
    HRETURN( hr );
    
} //*** HrMakeClusterFQDN


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::S_HrCreateInstance
//
//  Description:
//      Create a CConfigClusApi instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigClusApi::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CConfigClusApi *    pcca = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pcca = new CConfigClusApi;
    if ( pcca == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pcca->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pcca != NULL )
    {
        pcca->Release();
    } // if:

    HRETURN( hr );

} //*** CConfigClusApi::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::CConfigClusApi
//
//  Description:
//      Constructor of the CConfigClusApi class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CConfigClusApi::CConfigClusApi( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_cRef == 1 );
    Assert( m_pcccb == NULL );
    Assert( IsEqualIID( m_clsidMajor, IID_NULL ) );
    Assert( m_bstrName == NULL );
    Assert( m_bstrBindingString == NULL );

    TraceFuncExit();

} //*** CConfigClusApi::CConfigClusApi


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::~CConfigClusApi
//
//  Description:
//      Destructor of the CConfigClusApi class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CConfigClusApi::~CConfigClusApi( void )
{
    TraceFunc( "" );

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    } // if:

    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrBindingString );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CConfigClusApi::~CConfigClusApi


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CConfigClusApi -- IUnknown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IConfigurationConnection * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IConfigurationConnection ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IConfigurationConnection, this, 0 );
    } // else if: IConfigClusApi
    else if ( IsEqualIID( riidIn, IID_IClusCfgServer ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgServer, this, 0 );
    } // else if: IClusCfgServer
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else if ( IsEqualIID( riidIn, IID_IClusCfgCapabilities ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCapabilities, this, 0 );
    } // else if: IClusCfgCapabilities
    else if ( IsEqualIID( riidIn, IID_IClusCfgVerify ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgVerify, this, 0 );
    } // else if: IClusCfgVerify
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CConfigClusApi::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConfigClusApi::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CConfigClusApi::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConfigClusApi::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CConfigClusApi::Release


//****************************************************************************
//
// IConfigClusApi
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::ConnectTo
//
//  Description:
//
//
//  Arguments
//    OBJECTCOOKIE cookieIn,  The Object Cookie.
//    REFIID riidIn,          The IID. of the interface
//    LPUNKNOWN * ppunkOut    The return pointer
//
//  Description:
//    Connects to the given object.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::ConnectTo(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[IConfigClusApi]" );

    HRESULT                     hr = S_OK;
    IServiceProvider *          psp   = NULL;
    IObjectManager *            pom   = NULL;
    IStandardInfo *             psi   = NULL;
    IConnectionPoint *          pcp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    BSTR                        bstrClusterFQDN = NULL;

    //
    //  Retrieve the managers needs for the task ahead.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IServiceProvider,
                                reinterpret_cast< void ** >( &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->QueryService( CLSID_ObjectManager,
                                 TypeSafeParams( IObjectManager, &pom )
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->QueryService( CLSID_NotificationManager,
                                 TypeSafeParams( IConnectionPointContainer, &pcpc )
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    psp->Release();        // release promptly
    psp = NULL;

    //
    //  Find the callback interface connection point.
    //

    hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Get the name of the node to contact.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_GetObject_Failed, hr );
        goto Cleanup;
    }

    TraceSysFreeString( m_bstrName );
    m_bstrName = NULL;

    hr = THR( psi->GetName( &m_bstrName ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_GetName_Failed, hr );
        goto Cleanup;
    }

    //
    //  Find out the type of object we are going to connect to (cluster or node).
    //

    hr = THR( psi->GetType( &m_clsidType ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_GetType_Failed, hr );
        goto Cleanup;
    }

    //
    //  Figure out where to logging information in the UI.
    //

    if ( IsEqualIID( m_clsidType, CLSID_NodeType ) )
    {
        CopyMemory( &m_clsidMajor, &TASKID_Major_Establish_Connection, sizeof(m_clsidMajor) );
    }
    else if ( IsEqualIID( m_clsidType, CLSID_ClusterConfigurationType ) )
    {
        CopyMemory( &m_clsidMajor, &TASKID_Major_Checking_For_Existing_Cluster, sizeof(m_clsidMajor) );
    }
    else
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    //  Create a binding string.
    //

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = NULL;

    hr = THR( HrFQNToBindingString( m_pcccb, &m_clsidMajor, m_bstrName, &m_bstrBindingString ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_CreateBinding_Failed, hr );
        goto Cleanup;
    }

    //
    //  Connect to cluster/node.
    //

    m_hCluster = OpenCluster( m_bstrBindingString );
    if ( m_hCluster == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_OpenCluster_Failed, hr );
        goto Cleanup;
    }

    //
    //  Ensure standard info object's name is one that subsequent lookups in the object manager will find.
    //
    hr = STHR( HrFQNIsFQIP( m_bstrName ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_HrFQNIsFQIP_Failed, hr );
        goto Cleanup;
    }
    else if ( hr == S_OK )
    {
        hr = THR( HrMakeClusterFQDN( m_hCluster, m_bstrName, &bstrClusterFQDN ) );
        if ( FAILED( hr ) )
        {
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_HrMakeClusterFQDN_Failed, hr );
            goto Cleanup;
        }

        TraceSysFreeString( m_bstrName );
        m_bstrName = bstrClusterFQDN;
        bstrClusterFQDN = NULL;
        
        hr = THR( psi->SetName( m_bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_SetName_Failed, hr );
            goto Cleanup;
        }
    }
    else
    {
        //
        //  HrFQNIsFQIP returned S_FALSE, but this function should return S_OK.
        //
        hr = S_OK;
    }

Cleanup:
    //  This should be released first... always!
    if ( psp != NULL )
    {
        psp->Release();
    } // if: psp

    if ( pom != NULL )
    {
        pom->Release();
    } // if: pom

    if ( psi != NULL )
    {
        psi->Release();
    } // if: psi

    if ( pcpc != NULL )
    {
        pcpc->Release();
    } // if: pcpc

    if ( pcp != NULL )
    {
        pcp->Release();
    } // if: pcp

    TraceSysFreeString( bstrClusterFQDN );

    HRETURN( hr );

} //*** CConfigClusApi::ConnectTo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::ConnectToObject
//
//  Description:
//
//  Arguments
//    OBJECTCOOKIE cookieIn,  The Object Cookie.
//    REFIID riidIn,          The IID. of the interface
//    LPUNKNOWN * ppunkOut    The return pointer
//
//  Description:
//    Connects to the given object.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::ConnectToObject(
    OBJECTCOOKIE    cookieIn,
    REFIID          riidIn,
    LPUNKNOWN *     ppunkOut
    )
{
    TraceFunc( "[IConfigClusApi]" );

    HRESULT hr;
    CLSID   clsid;

    IServiceProvider *  psp;

    IObjectManager * pom = NULL;
    IStandardInfo *  psi = NULL;

    //
    // Check the parameters.
    //

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  Check my state.
    //

    if ( m_hCluster == NULL )
        goto NotInitialized;

    //
    //  Retrieve the managers needs for the task ahead.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IServiceProvider,
                                reinterpret_cast< void ** >( &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->QueryService( CLSID_ObjectManager,
                                 TypeSafeParams( IObjectManager, &pom )
                                 ) );
    psp->Release();    // release promptly
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Retrieve the type of the object.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectToObject_GetObject_Failed, hr );
        goto Cleanup;
    }

    hr = THR( psi->GetType( &clsid ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectToObject_GetType_Failed, hr );
        goto Cleanup;
    }

    if ( !IsEqualIID( clsid, CLSID_NodeType )
      && !IsEqualIID( clsid, CLSID_ClusterType )
       )
    {
        hr = THR( E_INVALIDARG );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectToObject_InvalidCookie, hr );
        goto Cleanup;
    }

    //
    //  Return the requested interface.
    //

    hr = THR( QueryInterface( riidIn, reinterpret_cast<void**>( ppunkOut ) ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectToObject_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:
    if ( pom != NULL )
    {
        pom->Release();
    } // if: pom

    if ( psi != NULL )
    {
        psi->Release();
    } // if: psi

    HRETURN( hr );

NotInitialized:
    hr = THR( OLE_E_BLANK );    // the error text is better than the message id.
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectToObject_NotInitialized, hr );
    goto Cleanup;

} //*** CConfigClusApi::ConnectToObject


//****************************************************************************
//
// IClusCfgServer
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::GetClusterNodeInfo
//
//  Description:
//
//  Arguments
//    IClusCfgNodeInfo ** ppClusterNodeInfoOut         The Node Info object.
//
//  Description:
//    Returns the Node Info of the Cluster.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::GetClusterNodeInfo(
    IClusCfgNodeInfo ** ppClusterNodeInfoOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;
    size_t  idxDomain = 0;
    BSTR    bstrNodeHostname = NULL;

    IUnknown * punk = NULL;

    //
    // Check for valid parameters.
    //

    if ( ppClusterNodeInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_InvalidPointer, hr );
        goto Cleanup;
    }

    //
    //  Check my state
    //

    if ( m_hCluster == NULL )
    {
        hr = THR( OLE_E_BLANK );    // the error text is better than the message id.
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_NotInitialized, hr );
        goto Cleanup;
    }

    //
    //  Figure out the domain name.
    //

    hr = THR( HrFindDomainInFQN( m_bstrName, &idxDomain ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_HrFindDomainInFQN, hr );
        goto Cleanup;
    }

    //
    //  Use node hostname only if connecting to node; otherwise, leave hostname null.
    //
    if ( IsEqualIID( m_clsidType, CLSID_NodeType ) )
    {
        hr = THR( HrExtractPrefixFromFQN( m_bstrName, &bstrNodeHostname ) );
        if ( FAILED( hr ) )
        {
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_HrExtractPrefixFromFQN, hr );
            goto Cleanup;
        }
    }

    //
    //  Now create the object.
    //
    hr = THR( CProxyCfgNodeInfo::S_HrCreateInstance( &punk,
                                                     static_cast< IConfigurationConnection * >( this ),
                                                     &m_hCluster,
                                                     &m_clsidMajor,
                                                     bstrNodeHostname,
                                                     m_bstrName + idxDomain
                                                     ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_Create_CProxyCfgNodeInfo, hr );
        goto Cleanup;
    }

    //
    // Done.  Return the interface.
    //

    hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, ppClusterNodeInfoOut ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:

    TraceSysFreeString( bstrNodeHostname );

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CConfigClusApi::GetClusterNodeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::GetManagedResourcesEnum
//
//  Description:
//
//  Arguments
//    IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut
//         The Resources enumerator for the clusters.
//
//  Description:
//    Returns the resources enumerator for the cluster.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::GetManagedResourcesEnum(
    IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;

    IUnknown * punk = NULL;

    //
    // Check for valid parameters.
    //

    if ( ppEnumManagedResourcesOut == NULL )
        goto InvalidPointer;

    //
    //  Check my state
    //

    if ( m_hCluster == NULL )
        goto NotInitialized;

    //
    //  Create the resource enumer.
    //

    hr = THR( CEnumCfgResources::S_HrCreateInstance( &punk, static_cast< IConfigurationConnection * >( this ), &m_hCluster, &m_clsidMajor ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetManagedResourcesEnum_Create_CEnumCfgResources_Failed, hr );
        goto Cleanup;
    }

    //
    //  QI for the interface.
    //

    hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, ppEnumManagedResourcesOut ) );
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetManagedResourcesEnum_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

NotInitialized:
    hr = THR( OLE_E_BLANK );    // the error text is better than the message id.
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetManagedResourcesEnum_NotInitialized, hr );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetManagedResourcesEnum_InvalidPointer, hr );
    goto Cleanup;

} //*** CConfigClusApi::GetManagedResourcesEnum

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::GetNetworksEnum
//
//  Description:
//    Returns the network enumerator for the cluster.
//
//  Arguments:
//    IEnumClusCfgNetworks ** ppEnumNetworksOut   The Network Enumerator
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::GetNetworksEnum(
    IEnumClusCfgNetworks ** ppEnumNetworksOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;

    IUnknown * punk = NULL;

    //
    // Check for valid parameters.
    //

    if ( ppEnumNetworksOut == NULL )
        goto InvalidPointer;

    //
    //  Check my state
    //

    if ( m_hCluster == NULL )
        goto NotInitialized;

    //
    // Create an instance of the enumeratore and initialize it.
    //

    hr = THR( CEnumCfgNetworks::S_HrCreateInstance( &punk, static_cast< IConfigurationConnection * >( this ), &m_hCluster, &m_clsidMajor ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetNetworksEnum_Create_CEnumCfgNetworks_Failed, hr );
        goto Cleanup;
    }

    //
    // Return the Enum interface.
    //

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks , ppEnumNetworksOut) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetNetworksEnum_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

NotInitialized:
    hr = THR( OLE_E_BLANK );    // the error text is better than the message id.
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetNetworksEnum_NotInitialized, hr );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetNetworksEnum_InvalidPointer, hr );
    goto Cleanup;

} //*** CConfigClusApi::GetNetworksEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::CommitChanges
//
//  Description:
//      NOT IMPLEMENTED.
//
//  Arguments:
//
//  Return Values:
//      S_FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::CommitChanges( void )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CConfigClusApi::CommitChanges()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::GetBindingString
//
//  Description:
//      Get the binding string.
//
//  Arguments:
//
//  Return Values:
//      S_FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::GetBindingString( BSTR * pbstrBindingStringOut )
{
    TraceFunc1( "[IClusCfgServer] pbstrBindingStringOut = %p", pbstrBindingStringOut );

    HRESULT hr = S_FALSE;

    if ( pbstrBindingStringOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetBindingString_InvalidPointer, hr );
        goto Cleanup;
    }

    //  If local server, then there isn't a binding context.
    if ( m_bstrBindingString == NULL )
    {
        Assert( hr == S_FALSE );
        goto Cleanup;
    }

    *pbstrBindingStringOut = SysAllocString( m_bstrBindingString );
    if ( *pbstrBindingStringOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetBindingString_OutOfMemory, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CConfigClusApi::GetBindingString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::SetBindingString
//
//  Description:
//      Set the binding string.
//
//  Arguments:
//
//  Return Values:
//      S_FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::SetBindingString( LPCWSTR pcszBindingStringIn )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszBindingStringIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = bstr;

Cleanup:

    HRETURN( hr );

} //*** CConfigClusApi::SetBindingString


//****************************************************************************
//
// IClusCfgCapabilities
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::CanNodeBeClustered
//
//  Description:
//      Returns whether the node can be clustered.
//
//  Arguments:
//
//  Return Values:
//      S_OK      True
//      S_FALSE   False
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::CanNodeBeClustered( void )
{
    TraceFunc( "[IClusCfgCapabilities]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CConfigClusApi::CanNodeBeClustered


//****************************************************************************
//
// IClusCfgVerify
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::VerifyCredentials
//
//  Description:
//      Validate the passed in credentials.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The credentials are valid.
//
//      S_FALSE
//          The credentials are not valid.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::VerifyCredentials(
    LPCWSTR pcszNameIn,
    LPCWSTR pcszDomainIn,
    LPCWSTR pcszPasswordIn
    )
{
    TraceFunc( "[IClusCfgVerify]" );

    //
    //  Trying to use the credentials on the client machine adds no value, and
    //  can lead to false errors when the client's domain does not trust the 
    //  the cluster service account's domain.  The Windows Server 2003 nodes being
    //  added to the cluster will perform the proper credential validation.
    //

    UNREFERENCED_PARAMETER( pcszNameIn );
    UNREFERENCED_PARAMETER( pcszDomainIn );
    UNREFERENCED_PARAMETER( pcszPasswordIn );

    HRETURN( S_OK );

} //*** CConfigClusApi::VerifyCredentials


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::VerifyConnectionToCluster
//
//  Description:
//      Verify that that this server is the same as the passed in server.
//
//  Arguments:
//      bstrServerNameIn
//
//  Return Value:
//      S_OK
//          This is the server.
//
//      S_FALSE
//          This is not the server.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::VerifyConnectionToCluster( LPCWSTR pcszClusterNameIn )
{
    TraceFunc1( "pcszClusterNameIn = '%ls'", pcszClusterNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // CConfigClusApi::VerifyConnection

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::VerifyConnectionToNode
//
//  Description:
//      Verify that that this server is the same as the passed in server.
//
//  Arguments:
//      bstrServerNameIn
//
//  Return Value:
//      S_OK
//          This is the server.
//
//      S_FALSE
//          This is not the server.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::VerifyConnectionToNode( LPCWSTR pcszNodeNameIn )
{
    TraceFunc1( "pcszNodeNameIn = '%ls'", pcszNodeNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // CConfigClusApi::VerifyConnection


//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;
    FILETIME    ft;

    if ( pcszNodeNameIn == NULL )
    {
        pcszNodeNameIn = m_bstrName;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             pcszDescriptionIn,
                                             pftTimeIn,
                                             pcszReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

} //*** CConfigClusApi::SendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cenumcfgresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumCfgResources.h
//
//  Description:
//      This file contains the declaration of the CEnumCfgResources
//      class.
//
//      The class CEnumCfgResources is the enumeration of
//      cluster networks. It implements the IEnumClusCfgNetworks interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumCfgResources.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumCfgResources
//
//  Description:
//      The class CEnumCfgResources is the enumeration of cluster resoruces.
//
//  Interfaces:
//      CBaseEnum
//      IEnumClusCfgManagedResources
//      IClusCfgSetHandle
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumCfgResources
    : public IEnumClusCfgManagedResources
{
private:
    LONG                m_cRef;
    IUnknown *          m_punkOuter;                //  Outer control object - It can't be deleted until we get deleted.
    HCLUSTER *          m_phCluster;                //  Pointer to the handle of the cluster/node - DO NOT CLOSE!
    CLSID *             m_pclsidMajor;              //  Pointer to the clsid to log UI information to.
    IClusCfgCallback *  m_pcccb;                    //  Callback interface to log information.
    HCLUSENUM           m_hClusEnum;                //  Cluster enumer handle
    DWORD               m_dwIndex;                  //  Current index

    CEnumCfgResources( void );
    ~CEnumCfgResources( void );

    // Private copy constructor to prevent copying.
    CEnumCfgResources( const CEnumCfgResources & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumCfgResources & operator = ( const CEnumCfgResources & nodeSrc );

    HRESULT HrInit( IUnknown * pOuterIn, HCLUSTER * phClusterIn, CLSID * pclsidMajorIn );
    HRESULT HrGetItem( IClusCfgManagedResourceInfo ** ppManagedResourceInfoOut );

public: // methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut,
                            IUnknown *  pOuterIn,
                            HCLUSTER *  phClusterIn,
                            CLSID *     pclsidMajorIn
                            );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnum
    STDMETHOD( Next )( ULONG cNumberRequestedIn,
                       IClusCfgManagedResourceInfo **   rgpManagedResourceInfoOut,
                       ULONG * pcNumberFetchedOut
                       );
    STDMETHOD( Reset )( void );
    STDMETHOD( Skip )( ULONG cNumberToSkipIn );
    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )( BSTR bstrNodeNameIn,
                                   CLSID        clsidTaskMajorIn,
                                   CLSID        clsidTaskMinorIn,
                                   ULONG        ulMinIn,
                                   ULONG        ulMaxIn,
                                   ULONG        ulCurrentIn,
                                   HRESULT      hrStatusIn,
                                   BSTR         bstrDescriptionIn,
                                   FILETIME *   pftTimeIn,
                                   BSTR         bstrReferenceIn
                                   );

}; //*** class CEnumCfgResources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cenumcfgresources.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumCfgResource.cpp
//
//  Description:
//      CEnumCfgResource implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "CEnumCfgResources.h"
#include "CResourcePhysicalDisk.h"

DEFINE_THISCLASS("CEnumCfgResources")


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCfgResources::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCfgResources::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown * punkOuterIn,
    HCLUSTER * phClusterIn,
    CLSID * pclsidMajorIn
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CEnumCfgResources * pecr = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pecr = new CEnumCfgResources;
    if ( pecr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pecr->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pecr->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pecr != NULL )
    {
        pecr->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumCfgResources::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumCfgResources::CEnumCfgResources
//
//////////////////////////////////////////////////////////////////////////////
CEnumCfgResources::CEnumCfgResources( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_punkOuter == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_hClusEnum == NULL );
    Assert( m_dwIndex == 0 );

    TraceFuncExit();

} //*** CEnumCfgResources::CEnumCfgResources

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumCfgResources::~CEnumCfgResources
//
//////////////////////////////////////////////////////////////////////////////
CEnumCfgResources::~CEnumCfgResources( void )
{
    TraceFunc( "" );

    // m_cRef

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release();
    }

    // m_phCluster - DO NOT CLOSE!

    // m_pclsidMajor

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_hClusEnum != NULL )
    {
        ClusterCloseEnum( m_hClusEnum );
    }

    // m_dwIndex

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumCfgResources::~CEnumCfgResources

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCfgResources::HrInit
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCfgResources::HrInit(
    IUnknown * punkOuterIn,
    HCLUSTER * phClusterIn,
    CLSID *    pclsidMajorIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    // IUnknown
    Assert( m_cRef == 1 );

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef();
    }

    if ( phClusterIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( punkOuterIn != NULL )
    {
        hr = THR( punkOuterIn->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //
    //  Open the enumer.
    //

    m_hClusEnum = ClusterOpenEnum( *m_phCluster, CLUSTER_ENUM_RESOURCE );
    if ( m_hClusEnum == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_Resources_HrInit_ClusterOpenEnum_Failed, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} //*** CEnumCfgResources::HrInit


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgResources::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgResources::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IEnumClusCfgManagedResources * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgManagedResources ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
    } // else if: IEnumClusCfgManagedResources
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEnumCfgResources::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCfgResources::AddRef
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumCfgResources::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CEnumCfgResources::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCfgResources::Release
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumCfgResources::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CEnumCfgResources::Release


//****************************************************************************
//
//  IEnumClusCfgManagedResources
//
//****************************************************************************

//
//
//
STDMETHODIMP
CEnumCfgResources::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr;
    ULONG   cFetched = 0;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr= THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_Resources_Next_InvalidPointer, hr );
        goto Cleanup;
    }

    for( ; cFetched < cNumberRequestedIn; m_dwIndex++ )
    {
        hr = STHR( HrGetItem( &(rgpManagedResourceInfoOut[ cFetched ]) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            continue; // resource was not type physical disk
        }

        if (  hr == MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NO_MORE_ITEMS ) )
        {
            break;  // no more items
        }

        cFetched ++;

    } // for: cFetched

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:
    else
    {
        hr = S_OK;
    }

Cleanup:
    if ( FAILED( hr ) )
    {
        ULONG idx;

        for ( idx = 0; idx < cFetched; idx++ )
        {
            (rgpManagedResourceInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;
    } // if:

    HRETURN( hr );

} //*** CEnumCfgResources::Next

//
//
//
STDMETHODIMP
CEnumCfgResources::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_dwIndex = 0;

    HRETURN( hr );

} //*** CEnumCfgResources::Reset

//
//
//
STDMETHODIMP
CEnumCfgResources::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    //
    //  TODO:   GalenB  27 SEPT 2000
    //
    //  Need to ensure that we don't run off the end of the enumeration.
    //

    m_dwIndex += cNumberToSkipIn;

    HRETURN( hr );

} //*** CEnumCfgResources::Skip

//
//
//
STDMETHODIMP
CEnumCfgResources::Clone( IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CEnumCfgResourcess::Clone

//
//
//
STDMETHODIMP
CEnumCfgResources::Count( DWORD * pnCountOut)
{

    TraceFunc( "[IEnumClusCfgManagedResources]" );

    Assert( m_hClusEnum != NULL );
    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = ClusterGetEnumCount(m_hClusEnum);

Cleanup:

    HRETURN( hr );

} //*** CEnumCfgResourcess::Count

//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgResources::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgResources::SendStatusReport(
    BSTR        bstrNodeNameIn,
    CLSID       clsidTaskMajorIn,
    CLSID       clsidTaskMinorIn,
    ULONG       ulMinIn,
    ULONG       ulMaxIn,
    ULONG       ulCurrentIn,
    HRESULT     hrStatusIn,
    BSTR        bstrDescriptionIn,
    FILETIME *  pftTimeIn,
    BSTR        bstrReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( bstrNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             bstrDescriptionIn,
                                             pftTimeIn,
                                             bstrReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

} //*** CEnumCfgResources::SendStatusReport


//****************************************************************************
//
// Local methods.
//
//****************************************************************************


//
//
//
HRESULT
CEnumCfgResources::HrGetItem(
    IClusCfgManagedResourceInfo **  ppManagedResourceInfoOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;
    DWORD   dwTypeDummy;
    DWORD   cchName = 64;   // good starting value
    BSTR    bstrName = NULL;

    IUnknown * punk = NULL;

    Assert( ppManagedResourceInfoOut != NULL );
    Assert( m_hClusEnum != NULL );

    bstrName = TraceSysAllocStringLen( NULL, cchName );
    if ( bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }
    cchName ++; // SysAllocStringLen allocates cchName + 1.

    // We are wrapping this a cchName should be significantly large enough to handle
    // most of our testing.
    sc = ClusterEnum( m_hClusEnum, m_dwIndex, &dwTypeDummy, bstrName, &cchName );
    if ( sc == ERROR_MORE_DATA )
    {
        //
        //  Our "typical" buffer is too small. Try make it to the size ClusterEnum
        //  returned.
        //

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        bstrName = TraceSysAllocStringLen( NULL, cchName );
        if ( bstrName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
        cchName ++; // SysAllocStringLen allocates cchName + 1.

        sc = TW32( ClusterEnum( m_hClusEnum, m_dwIndex, &dwTypeDummy, bstrName, &cchName ) );
    }
    else if ( sc == ERROR_NO_MORE_ITEMS )
    {
        hr = MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NO_MORE_ITEMS );
        goto Cleanup;
    }

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_Resources_HrGetItem_ClusterEnum_Failed, hr );
        goto Cleanup;
    }

    Assert( dwTypeDummy == CLUSTER_ENUM_RESOURCE );

    //
    // Create the requested object and store it.
    //

    hr = STHR( CResourcePhysicalDisk::S_HrCreateInstance( &punk, m_punkOuter, m_phCluster, m_pclsidMajor, bstrName ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrGetItem_Create_CResourcePhysicalDisk_Failed, hr );
        goto Cleanup;
    }

    if ( hr == S_FALSE )
    {
        goto Cleanup;   // This means that the object was not a physical disk resource.
    }

    //
    //  QI for the interface to return.
    //

    hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, ppManagedResourceInfoOut ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_Resources_HrGetItem_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:

    TraceSysFreeString( bstrName );

    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

} //*** CEnumCfgResources::HrGetItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgipaddressinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgIPAddressInfo.cpp
//
//  Description:
//      CProxyCfgIPAddressInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CProxyCfgIPAddressInfo.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CProxyCfgIPAddressInfo")


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo::S_HrCreateInstance
//
//  Description:
//      Create a CProxyCfgIPAddressInfo instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgIPAddressInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    ULONG       ulIPAddressIn,
    ULONG       ulSubnetMaskIn
    )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    CProxyCfgIPAddressInfo *    ppcipai = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    ppcipai = new CProxyCfgIPAddressInfo;
    if ( ppcipai == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( ppcipai->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn, ulIPAddressIn, ulSubnetMaskIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ppcipai->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ppcipai != NULL )
    {
        ppcipai->Release();
    } // if:

    HRETURN( hr );

} //*** CProxyCfgIPAddressInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo::CProxyCfgIPAddressInfo
//
//  Description:
//      Constructor of the CProxyCfgIPAddressInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgIPAddressInfo::CProxyCfgIPAddressInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_pcccb == NULL );

    TraceFuncExit();

} //*** CProxyCfgIPAddressInfo::CProxyCfgIPAddressInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo::~CProxyCfgIPAddressInfo
//
//  Description:
//      Destructor of the CProxyCfgIPAddressInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgIPAddressInfo::~CProxyCfgIPAddressInfo( void )
{
    TraceFunc( "" );

    //  m_cRef - noop

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release();
    }

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    } // if:

    //  m_phCluster - DO NOT CLOSE!

    //  m_pclsidMajor - noop

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CProxyCfgIPAddressInfo::~CProxyCfgIPAddressInfo

//
//
//
HRESULT
CProxyCfgIPAddressInfo::HrInit(
    IUnknown * punkOuterIn,
    HCLUSTER * phClusterIn,
    CLSID * pclsidMajorIn,
    ULONG  ulIPAddressIn,
    ULONG  ulSubnetMaskIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    // IUnknown
    Assert( m_cRef == 1 );

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef();
    }

    if ( phClusterIn == NULL )
        goto InvalidArg;

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( punkOuterIn != NULL )
    {
        hr = THR( punkOuterIn->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    m_ulIPAddress = ulIPAddressIn;
    m_ulSubnetMask = ulSubnetMaskIn;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_IPAddressInfo_HrInit_InvalidArg, hr );
    goto Cleanup;

} // *** HrInit


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgIPAddressInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgIPAddressInfo::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgIPAddressInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgIPAddressInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgIPAddressInfo, this, 0 );
    } // else if: IClusCfgIPAddressInfo
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CProxyCfgIPAddressInfo::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProxyCfgIPAddressInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CProxyCfgIPAddressInfo::AddRef

    // IClusSetHandleProvider

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProxyCfgIPAddressInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CProxyCfgIPAddressInfo::Release


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgIPAddressInfo -- IClusCfgIPAddressInfo interface.
/////////////////////////////////////////////////////////////////////////////


//
//
//
STDMETHODIMP
CProxyCfgIPAddressInfo::GetUID(
    BSTR * pbstrUIDOut
    )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr;
    DWORD   sc;
    DWORD   ulNetwork = m_ulIPAddress & m_ulSubnetMask;

    LPWSTR  psz = NULL;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_IPAddressInfo_GetName_InvalidPointer, hr );
        goto Cleanup;
    }

    sc = TW32( ClRtlTcpipAddressToString( ulNetwork, &psz ) ); // KB: Allocates to psz using LocalAlloc().
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_IPAddressInfo_GetUID_ClRtlTcpipAddressToString_Failed, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( psz );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_IPAddressInfo_GetUID_OutOfMemory, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    if ( psz != NULL )
    {
        LocalFree( psz ); // KB: Don't use TraceFree() here!
    } // if:

    HRETURN( hr );

} //***CProxyCfgIPAddressInfo::GetUID

//
//
//
STDMETHODIMP
CProxyCfgIPAddressInfo::GetIPAddress(
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut == NULL )
        goto InvalidPointer;

    *pulDottedQuadOut = m_ulIPAddress;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetIPAddress_InvalidPointer, hr );
    goto Cleanup;

} //***CProxyCfgIPAddressInfo::GetIPAddress

//
//
//
STDMETHODIMP
CProxyCfgIPAddressInfo::SetIPAddress(
    ULONG ulDottedQuadIn
    )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //***CProxyCfgIPAddressInfo::SetIPAddress

//
//
//
STDMETHODIMP
CProxyCfgIPAddressInfo::GetSubnetMask(
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut == NULL )
        goto InvalidPointer;

    *pulDottedQuadOut = m_ulSubnetMask;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetSubnetMask_InvalidPointer, hr );
    goto Cleanup;

} //***CProxyCfgIPAddressInfo::GetSubnetMask

//
//
//
STDMETHODIMP
CProxyCfgIPAddressInfo::SetSubnetMask(
    ULONG ulDottedQuadIn
    )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //***CProxyCfgIPAddressInfo::SetSubnetMask



//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgIPAddressInfo::SendStatusReport(
    BSTR        bstrNodeNameIn,
    CLSID       clsidTaskMajorIn,
    CLSID       clsidTaskMinorIn,
    ULONG       ulMinIn,
    ULONG       ulMaxIn,
    ULONG       ulCurrentIn,
    HRESULT     hrStatusIn,
    BSTR        bstrDescriptionIn,
    FILETIME *  pftTimeIn,
    BSTR        bstrReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( bstrNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             bstrDescriptionIn,
                                             pftTimeIn,
                                             bstrReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

} //*** CProxyCfgIPAddressInfo::SendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgclusterinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgClusterInfo.h
//
//  Description:
//      CProxyCfgClusterInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProxyCfgClusterInfo
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProxyCfgClusterInfo
    : public IClusCfgClusterInfo
    , public IClusCfgClusterInfoEx
{
private:

    LONG                    m_cRef;                 //  Reference counter
    IUnknown *              m_punkOuter;            //  Interface to Outer Proxy object
    IClusCfgCallback *      m_pcccb;                //  Callback interface
    HCLUSTER *              m_phCluster;            //  Pointer to the handle of the cluster.
    CLSID *                 m_pclsidMajor;          //  CLSID to use to log errors to the UI.

    BSTR                    m_bstrClusterName;      //  Cluster FQDN name
    ULONG                   m_ulIPAddress;          //  Cluster IP Address
    ULONG                   m_ulSubnetMask;         //  Cluster Network mask
    BSTR                    m_bstrNetworkName;      //  Cluster Network name
    IClusCfgCredentials *   m_pccc;                 //  Cluster Credentials object
    BSTR                    m_bstrBindingString;    //  Cluster binding string.

    CProxyCfgClusterInfo( void );
    ~CProxyCfgClusterInfo( void );

    // Private copy constructor to prevent copying.
    CProxyCfgClusterInfo( const CProxyCfgClusterInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CProxyCfgClusterInfo & operator = ( const CProxyCfgClusterInfo & nodeSrc );

    HRESULT HrInit( IUnknown * punkOuterIn, HCLUSTER * phClusterIn, CLSID * pclsidMajorIn, LPCWSTR pcszDomainIn );
    HRESULT HrLoadCredentials( void );

public:
    static HRESULT S_HrCreateInstance(
                              IUnknown **   ppunkOut
                            , IUnknown *    punkOuterIn
                            , HCLUSTER *    phClusterIn
                            , CLSID *       pclsidMajorIn
                            , LPCWSTR       pcszDomainIn
                            );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgClusterInfo
    STDMETHOD( SetCommitMode )( ECommitMode eccbNewModeIn );
    STDMETHOD( GetCommitMode )( ECommitMode * peccmCurrentModeOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( GetIPAddress )( DWORD * pdwIPAddress );
    STDMETHOD( GetSubnetMask )( DWORD * pdwNetMask  );
    STDMETHOD( GetNetworkInfo )( IClusCfgNetworkInfo ** ppICCNetInfoOut );
    STDMETHOD( GetClusterServiceAccountCredentials )( IClusCfgCredentials ** ppICCCredentials );
    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( SetIPAddress )( DWORD dwIPAddressIn );
    STDMETHOD( SetSubnetMask )( DWORD dwNetMaskIn );
    STDMETHOD( SetNetworkInfo )( IClusCfgNetworkInfo * pICCNetInfoIn );
    STDMETHOD( SetBindingString )( LPCWSTR bstrBindingStringIn );
    STDMETHOD( GetMaxNodeCount )( DWORD * pcMaxNodesOut );

    // IClusCfgClusterInfoEx
    STDMETHOD( CheckJoiningNodeVersion )( DWORD dwNodeHighestVersionIn, DWORD dwNodeLowestVersionIn );
    STDMETHOD( GetNodeNames )( long * pnCountOut, BSTR ** prgbstrNodeNamesOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** Class CProxyCfgClusterInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgclusterinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ConfigClusApi.cpp
//
//  Description:
//      CConfigClusApi implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "CProxyCfgClusterInfo.h"
#include "CProxyCfgNetworkInfo.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CProxyCfgClusterInfo")

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::S_HrCreateInstance
//
//  Description:
//      Create an instance of the CProxyCfgClusterInfo object.
//
//  Arguments:
//      ppunkOut        -
//      punkOuterIn     -
//      pclsidMajorIn   -
//      pcszDomainIn    -
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgClusterInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszDomainIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CProxyCfgClusterInfo *  ppcci = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    ppcci = new CProxyCfgClusterInfo;
    if ( ppcci == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( ppcci->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn, pcszDomainIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ppcci->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ppcci != NULL )
    {
        ppcci->Release();
    } // if:

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::CProxyCfgClusterInfo
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgClusterInfo::CProxyCfgClusterInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_punkOuter == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );

    Assert( m_bstrClusterName == NULL);
    Assert( m_ulIPAddress == 0 );
    Assert( m_ulSubnetMask == 0 );
    Assert( m_bstrNetworkName == NULL);
    Assert( m_pccc == NULL );
    Assert( m_bstrBindingString == NULL );

    TraceFuncExit();

} //*** CProxyCfgClusterInfo::CProxyCfgClusterInfo

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::~CProxyCfgClusterInfo
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgClusterInfo::~CProxyCfgClusterInfo( void )
{
    TraceFunc( "" );

    //  m_cRef - noop

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release();
    }

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    } // if:

    //  m_phCluster - DO NOT CLOSE!

    //  m_pclsidMajor - noop

    TraceSysFreeString( m_bstrClusterName );

    // m_ulIPAddress

    // m_ulSubnetMask

    TraceSysFreeString( m_bstrNetworkName );
    TraceSysFreeString( m_bstrBindingString );

    if ( m_pccc != NULL )
    {
        m_pccc->Release();
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CProxyCfgClusterInfo::~CProxyCfgClusterInfo

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::HrInit
//
//  Description:
//      Secondary initializer.
//
//  Arguments:
//      punkOuterIn     -
//      phClusterIn     -
//      pclsidMajorIn   -
//      pcszDomainIn    -
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgClusterInfo::HrInit(
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszDomainIn
    )
{
    TraceFunc( "" );

    HRESULT             hr;
    DWORD               sc;
    BSTR                bstrClusterName = NULL;
    CLUSTERVERSIONINFO  cvi;
    HRESOURCE           hIPAddressRes = NULL;
    WCHAR *             psz = NULL;
    size_t              cchName = 0;

    // IUnknown
    Assert( m_cRef == 1 );

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef();
    }

    if ( phClusterIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_ClusterInfo_HrInit_InvalidArg, hr );
        goto Cleanup;
    }

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( punkOuterIn != NULL )
    {
        hr = THR( punkOuterIn->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //
    //  Get the cluster's name and version info.
    //

    cvi.dwVersionInfoSize = sizeof( cvi );

    hr = THR( HrGetClusterInformation( *m_phCluster, &bstrClusterName, &cvi ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_GetClusterInformation_Failed, hr );
        goto Cleanup;
    }

    // Give up ownership
    cchName = (size_t) SysStringLen( bstrClusterName ) + 1 + (UINT) wcslen( pcszDomainIn ) + 1;     // include space for the . and the '\0'
    m_bstrClusterName = TraceSysAllocStringLen( NULL, (UINT) cchName );
    if ( m_bstrClusterName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_ClusterInfo_HrInit_OutOfMemory, hr );
        goto Cleanup;
    } // if:

    hr = THR( StringCchPrintfW( m_bstrClusterName, cchName, L"%ws.%ws", bstrClusterName, pcszDomainIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    sc = TW32( ResUtilGetCoreClusterResources( *m_phCluster, NULL, &hIPAddressRes, NULL ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    Assert( m_bstrNetworkName == NULL );
    hr = THR( HrGetIPAddressInfo( hIPAddressRes, &m_ulIPAddress, &m_ulSubnetMask, &m_bstrNetworkName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    sc = TW32( ClRtlTcpipAddressToString( m_ulIPAddress, &psz ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_ClusterInfo_HrInit_InvalidDottedQuad, hr );
        goto Cleanup;
    } // if:

    Assert( m_bstrBindingString == NULL );
    m_bstrBindingString = TraceSysAllocString( psz );
    if ( m_bstrBindingString == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_ClusterInfo_HrInit_OutOfMemory, hr );
        goto Cleanup;
    } // if:

    hr = THR( HrLoadCredentials() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    //
    //  Do not use TraceFree() because ClRtlTcpipAddressToString()
    //  uses LocalAlloc() and does not use our memory tracking code.
    //

    LocalFree( psz );

    if ( hIPAddressRes != NULL )
    {
        CloseClusterResource( hIPAddressRes );
    } // if:

    TraceSysFreeString( bstrClusterName );

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::HrInit

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgClusterInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgClusterInfo::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgClusterInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgClusterInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgClusterInfo, this, 0 );
    } // else if: IClusCfgClusterInfo
    else if ( IsEqualIID( riidIn, IID_IClusCfgClusterInfoEx ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgClusterInfoEx, this, 0 );
    } // else if: IClusCfgClusterInfoEx
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CConfigClusApi::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProxyCfgClusterInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CProxyCfgClusterInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProxyCfgClusterInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CProxyCfgClusterInfo::Release


//****************************************************************************
//
//  IClusCfgClusterInfo
//
//****************************************************************************

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    *pbstrNameOut = SysAllocString( m_bstrClusterName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    }

    CharLower( *pbstrNameOut );

Cleanup:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_ClusterInfo_GetName_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::GetName

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetIPAddress(
    DWORD * pdwIPAddress
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pdwIPAddress == NULL )
        goto InvalidPointer;

    *pdwIPAddress = m_ulIPAddress;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_ClusterInfo_GetIPAddress_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::GetIPAddress

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetSubnetMask(
    DWORD * pdwNetMask
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pdwNetMask == NULL )
        goto InvalidPointer;

    *pdwNetMask = m_ulSubnetMask;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_ClusterInfo_GetSubnetMask_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::GetSubnetMask

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetNetworkInfo(
    IClusCfgNetworkInfo ** ppICCNetInfoOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr;

    IUnknown * punk = NULL;

    if ( ppICCNetInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetNetworkInfo_InvalidPointer, hr );
        goto Cleanup;
    }

    //
    // Create the network info object.
    //

    hr = THR( CProxyCfgNetworkInfo::S_HrCreateInstance( &punk,
                                                        m_punkOuter,
                                                        m_phCluster,
                                                        m_pclsidMajor,
                                                        m_bstrNetworkName
                                                        ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgNetworkInfo, ppICCNetInfoOut ) );

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::GetNetworkInfo


//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetClusterServiceAccountCredentials(
    IClusCfgCredentials ** ppICCCredentialsOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr;

    if ( ppICCCredentialsOut == NULL )
        goto InvalidPointer;

    hr = THR( m_pccc->TypeSafeQI( IClusCfgCredentials, ppICCCredentialsOut ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterServiceAccountCredentials_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::GetClusterServiceAccountCredentials

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetBindingString(
    BSTR * pbstrBindingStringOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrBindingStringOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_ClusterInfo_GetBindingString_InvalidPointer, hr );
        goto Cleanup;
    }

    if ( m_bstrBindingString == NULL )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    *pbstrBindingStringOut = SysAllocString( m_bstrBindingString );
    if ( *pbstrBindingStringOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::GetBindingString

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetCommitMode( ECommitMode ecmNewModeIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );
    Assert( ecmNewModeIn != cmUNKNOWN );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetCommitMode

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetCommitMode( ECommitMode * pecmCurrentModeOut  )
{
    TraceFunc( "[IClusCfgClusterInfo]" );
    Assert( pecmCurrentModeOut != NULL );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::GetCommitMode

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszNameIn = '%ls'", pcszNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetName

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetIPAddress( DWORD dwIPAddressIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( dwIPAddressIn != m_ulIPAddress )
    {
        hr = THR( E_INVALIDARG );
    }

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetIPAddress

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetSubnetMask( DWORD dwNetMaskIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( dwNetMaskIn != m_ulSubnetMask )
    {
        hr = THR( E_INVALIDARG );
    }

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetSubnetMask

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetNetworkInfo( IClusCfgNetworkInfo * pICCNetInfoIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetNetworkInfo

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetBindingString( LPCWSTR pcszBindingStringIn )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszBindingStringIn = '%ls'", pcszBindingStringIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszBindingStringIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = bstr;

Cleanup:

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetBindingString


//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetMaxNodeCount(
    DWORD * pcMaxNodesOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pcMaxNodesOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    //  TODO:   11-OCT-2001 GalenB
    //
    //  Need to figure out the correct max nodes for the Win2K cluster
    //  that we are proxying for.  May be able to use HrGetMaxNodeCount(),
    //  once it is implemented.
    //

    hr = S_FALSE;

Cleanup:

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::GetMaxNodeCount

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::CheckJoiningNodeVersion
//
//  Description:
//      Check a joining node's version information against that of the cluster.
//
//  Arguments:
//      dwNodeHighestVersionIn
//      dwNodeLowestVersionIn
//
//  Return Value:
//      S_OK
//          The joining node is compatible.
//
//      HRESULT_FROM_WIN32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS )
//          The joining node is NOT compatible.
//
//      Other HRESULT errors.
//
//  Remarks:
//
// Get and verify the sponsor version
//
//
// From Whistler onwards, CsRpcGetJoinVersionData() will return a failure code in its last parameter
// if the version of this node is not compatible with the sponsor version. Prior to this, the last
// parameter always contained a success value and the cluster versions had to be compared subsequent to this
// call. This will, however, still have to be done as long as interoperability with Win2K
// is a requirement, since Win2K sponsors do not return an error in the last parameter.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgClusterInfo::CheckJoiningNodeVersion(
      DWORD    dwNodeHighestVersionIn
    , DWORD    dwNodeLowestVersionIn
    )
{
    TraceFunc( "[IClusCfgClusterInfoEx]" );

    HRESULT hr = S_OK;

    hr = THR( HrCheckJoiningNodeVersion(
          m_bstrClusterName
        , dwNodeHighestVersionIn
        , dwNodeLowestVersionIn
        , m_pcccb
        ) );

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::CheckJoiningNodeVersion


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::GetNodeNames
//
//  Description:
//      Retrieve the names of the nodes currently in the cluster.
//
//  Parameters:
//      pnCountOut
//          On success, *pnCountOut returns the number of nodes in the cluster.
//
//      prgbstrNodeNamesOut
//          On success, an array of BSTRs containing the node names.
//          The caller must free each BSTR with SysFreeString, and free
//          the array with CoTaskMemFree.
//
//  Return Values:
//      S_OK
//          The out parameters contain valid information and the caller
//          must free the array and the BSTRs it contains.
//
//      E_OUTOFMEMORY, and other failures are possible.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgClusterInfo::GetNodeNames(
      long *   pnCountOut
    , BSTR **  prgbstrNodeNamesOut
    )
{
    TraceFunc( "[IClusCfgClusterInfoEx]" );

    HRESULT     hr = S_OK;

    hr = THR( HrGetNodeNames(
          *m_phCluster
        , pnCountOut
        , prgbstrNodeNamesOut
        ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::GetNodeNames



//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgClusterInfo::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             pcszDescriptionIn,
                                             pftTimeIn,
                                             pcszReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

}  //*** CProxyCfgClusterInfo::SendStatusReport


//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::HrLoadCredentials
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgClusterInfo::HrLoadCredentials( void )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    SC_HANDLE                   schSCM = NULL;
    SC_HANDLE                   schClusSvc = NULL;
    DWORD                       sc;
    DWORD                       cbpqsc = 128;
    DWORD                       cbRequired;
    QUERY_SERVICE_CONFIG *      pqsc = NULL;
    IUnknown *                  punk = NULL;
    IClusCfgSetCredentials *    piccsc = NULL;

    schSCM = OpenSCManager( m_bstrClusterName, NULL, GENERIC_READ );
    if ( schSCM == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrLoadCredentials_OpenSCManager_Failed, hr );
        goto Cleanup;
    } // if:

    schClusSvc = OpenService( schSCM, L"ClusSvc", GENERIC_READ );
    if ( schClusSvc == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrLoadCredentials_OpenService_Failed, hr );
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        BOOL fRet;

        pqsc = (QUERY_SERVICE_CONFIG *) TraceAlloc( 0, cbpqsc );
        if ( pqsc == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrLoadCredentials_OutOfMemory, hr );
            goto Cleanup;
        }

        fRet = QueryServiceConfig( schClusSvc, pqsc, cbpqsc, &cbRequired );
        if ( !fRet )
        {
            sc = GetLastError();
            if ( sc == ERROR_INSUFFICIENT_BUFFER )
            {
                TraceFree( pqsc );
                pqsc = NULL;
                cbpqsc = cbRequired;
                continue;
            } // if:
            else
            {
                hr = HRESULT_FROM_WIN32( TW32( sc ) );
                SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrLoadCredentials_QueryServiceConfig_Failed, hr );
                goto Cleanup;
            } // else:
        } // if:
        else
        {
            break;
        } // else:
    } // for:

    Assert( m_pccc == NULL );

    hr = THR( HrCoCreateInternalInstance(
                      CLSID_ClusCfgCredentials
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IClusCfgCredentials
                    , reinterpret_cast< void ** >( &m_pccc )
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pccc->TypeSafeQI( IClusCfgSetCredentials, &piccsc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccsc->SetDomainCredentials( pqsc->lpServiceStartName ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( schClusSvc != NULL )
    {
        CloseServiceHandle( schClusSvc );
    } // if:

    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
    } // if:

    if ( pqsc != NULL )
    {
        TraceFree( pqsc );
    } // if:

    if ( piccsc != NULL )
    {
        piccsc->Release();
    } // if:

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::HrLoadCredentials
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgipaddressinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgIPAddressInfo.h
//
//  Description:
//      CProxyCfgIPAddressInfo definition.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProxyCfgIPAddressInfo
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProxyCfgIPAddressInfo
    : public IClusCfgIPAddressInfo
{
private:
    LONG                m_cRef;             //  Reference counter
    IUnknown *          m_punkOuter;        //  Pointer to outer W2K Proxy object
    IClusCfgCallback *  m_pcccb;            //  Callback interface
    HCLUSTER *          m_phCluster;        //  Pointer to handle of cluster
    CLSID *             m_pclsidMajor;      //  Pointer to the CLSID to use to log errors to the UI.
    ULONG               m_ulIPAddress;      //  IP Address
    ULONG               m_ulSubnetMask;     //  Subnet Mask

    CProxyCfgIPAddressInfo( void );
    ~CProxyCfgIPAddressInfo( void );

    // Private copy constructor to prevent copying.
    CProxyCfgIPAddressInfo( const CProxyCfgIPAddressInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CProxyCfgIPAddressInfo & operator = ( const CProxyCfgIPAddressInfo & nodeSrc );

    HRESULT
        HrInit( IUnknown * punkOuterIn,
                HCLUSTER * phClusterIn,
                CLSID *    pclsidMajorIn,
                ULONG      ulIPAddressIn,
                ULONG      ulSubnetMaskIn
                );

public:
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut,
                                       IUnknown *  punkOuterIn,
                                       HCLUSTER *  phClusterIn,
                                       CLSID *     pclsidMajorIn,
                                       ULONG       ulIPAddressIn,
                                       ULONG       ulSubnetMaskIn
                                       );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgIPAddressInfo
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetIPAddress )( ULONG * pulDottedQuadOut );
    STDMETHOD( SetIPAddress )( ULONG ulDottedQuadIn );
    STDMETHOD( GetSubnetMask )( ULONG * pulDottedQuadOut );
    STDMETHOD( SetSubnetMask )( ULONG ulDottedQuadIn );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )( BSTR bstrNodeNameIn,
                                   CLSID        clsidTaskMajorIn,
                                   CLSID        clsidTaskMinorIn,
                                   ULONG        ulMinIn,
                                   ULONG        ulMaxIn,
                                   ULONG        ulCurrentIn,
                                   HRESULT      hrStatusIn,
                                   BSTR         bstrDescriptionIn,
                                   FILETIME *   pftTimeIn,
                                   BSTR         bstrReferenceIn
                                   );

}; //*** Class CProxyCfgIPAddressInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgnetworkinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgNetworkInfo.h
//
//  Description:
//      CProxyCfgNetworkInfo definition.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProxyCfgNetworkInfo
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProxyCfgNetworkInfo
    : public IClusCfgNetworkInfo
    , public IEnumClusCfgIPAddresses
{
private:
    LONG                m_cRef;                 //  Reference counter
    IUnknown *          m_punkOuter;            //  Interface to outer W2K proxy object
    IClusCfgCallback *  m_pcccb;                //  Callback interface
    HCLUSTER  *         m_phCluster;            //  Pointer to cluster handle
    CLSID *             m_pclsidMajor;          //  CLSID to log errors to the UI with.
    CClusPropList       m_cplNetwork;           //  Property list with Network info
    CClusPropList       m_cplNetworkRO;         //  Property list with Network info READ ONLY

    CProxyCfgNetworkInfo( void );
    ~CProxyCfgNetworkInfo( void );

    // Private copy constructor to prevent copying.
    CProxyCfgNetworkInfo( const CProxyCfgNetworkInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CProxyCfgNetworkInfo & operator = ( const CProxyCfgNetworkInfo & nodeSrc );

    HRESULT HrInit( IUnknown * punkOuterIn, HCLUSTER * phClusterIn, CLSID * pclsidMajorIn, LPCWSTR pcszNetworkNameIn );
    HRESULT HrGetNetworkRole( DWORD * pdwRoleOut );

      public:
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut,
                            IUnknown *  punkOuterIn,
                            HCLUSTER *  phClusterIn,
                            CLSID *     pclsidMajorIn,
                            LPCWSTR     pcszNetworkNameIn
                            );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgNetworkInfo
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetName )(  BSTR * pbstrNameOut );
    STDMETHOD( SetName )(  LPCWSTR pcszNameIn );
    STDMETHOD( GetDescription )(  BSTR * pbstrDescriptionOut );
    STDMETHOD( SetDescription )(  LPCWSTR pcszDescriptionIn );
    STDMETHOD( GetPrimaryNetworkAddress )(  IClusCfgIPAddressInfo ** ppIPAddressOut );
    STDMETHOD( SetPrimaryNetworkAddress )(  IClusCfgIPAddressInfo * pIPAddressIn );
    STDMETHOD( IsPublic )( void );
    STDMETHOD( SetPublic )(  BOOL fIsPublicIn );
    STDMETHOD( IsPrivate )( void );
    STDMETHOD( SetPrivate )(  BOOL fIsPrivateIn );

    // IEnumClusCfgIPAddresses
    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgIPAddressInfo ** rgpIPAddressInfoOut, ULONG * pcNumberFetchedOut );
    STDMETHOD( Reset )( void );
    STDMETHOD( Skip )( ULONG cNumberToSkipIn );
    STDMETHOD( Clone )( IEnumClusCfgIPAddresses ** ppiEnumOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** Class CProxyCfgNetworkInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgnetworkinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgNetworkInfo.cpp
//
//  Description:
//      CProxyCfgNetworkInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-SEP-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CProxyCfgNetworkInfo.h"
#include "CProxyCfgIPAddressInfo.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CProxyCfgNetworkInfo")


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo::S_HrCreateInstance
//
//  Description:
//      Create a CProxyCfgNetworkInfo instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgNetworkInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNetworkNameIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr S_OK;
    CProxyCfgNetworkInfo *  ppcni = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    ppcni = new CProxyCfgNetworkInfo;
    if ( ppcni == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( ppcni->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn, pcszNetworkNameIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ppcni->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ppcni != NULL )
    {
        ppcni->Release();
    } // if:

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo::CProxyCfgNetworkInfo
//
//  Description:
//      Constructor of the CProxyCfgNetworkInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgNetworkInfo::CProxyCfgNetworkInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_punkOuter == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );
    //  m_cplNetwork??
    //  m_cplNetworkRO??

    TraceFuncExit();

} //*** CProxyCfgNetworkInfo::CProxyCfgNetworkInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo::~CProxyCfgNetworkInfo
//
//  Description:
//      Destructor of the CProxyCfgNetworkInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgNetworkInfo::~CProxyCfgNetworkInfo( void )
{
    TraceFunc( "" );

    //  m_cRef - noop

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release();
    }

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    } // if:

    //  m_phCluster - DO NOT CLOSE

    //  m_pclsidMajor - noop

    //  m_cplNetwork - has own dtor code

    //  m_cplNetworkRO - has own dtor code

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CProxyCfgNetworkInfo::~CProxyCfgNetworkInfo


//
//
//
HRESULT
CProxyCfgNetworkInfo::HrInit(
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNetworkNameIn
    )
{
    TraceFunc( "" );

    HRESULT  hr;
    DWORD    sc;
    HNETWORK hNetwork = NULL;

    // IUnknown
    Assert( m_cRef == 1 );

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef();
    }

    if ( phClusterIn == NULL )
        goto InvalidArg;

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( punkOuterIn != NULL )
    {
        hr = THR( punkOuterIn->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( pcszNetworkNameIn == NULL )
        goto InvalidArg;

    //
    //  Gather network properties
    //

    hNetwork = OpenClusterNetwork( *m_phCluster, pcszNetworkNameIn );
    if ( hNetwork == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_OpenClusterNetInterface_Failed, hr );
        goto Cleanup;
    }

    //
    // Retrieve the properties.
    //

    sc = TW32( m_cplNetwork.ScGetNetworkProperties( hNetwork, CLUSCTL_NETWORK_GET_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetNetworkProperties_Failed, hr );
        goto Cleanup;
    } // if:

    //
    //  Rettrieve the READ ONLY properties
    //

    sc = TW32( m_cplNetworkRO.ScGetNetworkProperties( hNetwork, CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetNetworkProperties_Failed, hr );
        goto Cleanup;
    } // if:


    hr = S_OK;

Cleanup:
    if ( hNetwork != NULL )
    {
        CloseClusterNetwork( hNetwork );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NetworkInfo_HrInit_InvalidArg, hr );
    goto Cleanup;

} //*** CProxyCfgNetworkInfo::HrInit

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgNetworkInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNetworkInfo::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgNetworkInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgNetworkInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgNetworkInfo, this, 0 );
    } // else if: IClusCfgNetworkInfo
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgIPAddresses ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgIPAddresses, this, 0 );
    } // else if: IEnumClusCfgIPAddresses
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CConfigClusApi::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProxyCfgNetworkInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CProxyCfgNetworkInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProxyCfgNetworkInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CProxyCfgNetworkInfo::Release

//*************************************************************************//

/////////////////////////////////////////////////////////////////////////////
// CProxyCfgNetworkInfo -- IClusCfgNetworkInfo interface.
/////////////////////////////////////////////////////////////////////////////

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr ;
    DWORD   sc;
    LPWSTR  psz = NULL;
    DWORD   ulIPAddress;
    DWORD   ulSubnetMask;
    DWORD   ulNetwork;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NetworkInfo_GetUID_InvalidPointer, hr );
        goto Cleanup;
    }

    sc = TW32( m_cplNetworkRO.ScMoveToPropertyByName( L"Address" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ScMoveToPropetyByName_Address_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplNetworkRO.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( m_cplNetworkRO.CbhCurrentValue().pStringValue->sz, &ulIPAddress ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ClRtlTcpipStringToAddress_Address_Failed, hr );
        goto Cleanup;
    }

    sc = TW32( m_cplNetworkRO.ScMoveToPropertyByName( L"AddressMask" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ScMoveToPropetyByName_AddressMask_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplNetworkRO.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( m_cplNetworkRO.CbhCurrentValue().pStringValue->sz, &ulSubnetMask ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ClRtlTcpipStringToAddress_AddressMask_Failed, hr );
        goto Cleanup;
    }

    ulNetwork = ulIPAddress & ulSubnetMask;

    sc = TW32( ClRtlTcpipAddressToString( ulNetwork, &psz ) ); // KB: Allocates to psz using LocalAlloc().
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ClRtlTcpipAddressToString_Failed, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( psz );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NetworkInfo_GetUID_OutOfMemory, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    if ( psz != NULL )
    {
        LocalFree( psz ); // KB: Don't use TraceFree() here!
    } // if:

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::GetUID

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;
    DWORD   sc;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_INVALIDARG );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_NetworkInfo_GetName_InvalidPointer, hr );
        goto Cleanup;
    }

    //
    //  "Major Version"
    //

    sc = TW32( m_cplNetworkRO.ScMoveToPropertyByName( L"Name" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NetworkInfo_GetName_ScMoveToPropertyByName_MajorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNetworkRO.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    *pbstrNameOut = SysAllocString( m_cplNetworkRO.CbhCurrentValue().pStringValue->sz );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NetworkInfo_GetUID_OutOfMemory, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::GetName

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::GetDescription(
    BSTR * pbstrDescriptionOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;
    DWORD   sc;

    if ( pbstrDescriptionOut == NULL )
    {
        hr = THR( E_INVALIDARG );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetDescription_InvalidPointer, hr );
        goto Cleanup;
    }

    //
    //  "Major Version"
    //

    sc = TW32( m_cplNetwork.ScMoveToPropertyByName( L"Description" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetDescription_ScMoveToPropertyByName_MajorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNetwork.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    *pbstrDescriptionOut = SysAllocString( m_cplNetwork.CbhCurrentValue().pStringValue->sz );
    if ( *pbstrDescriptionOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetDescription_OutOfMemory, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::GetDescription

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::GetPrimaryNetworkAddress(
    IClusCfgIPAddressInfo ** ppIPAddressOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;
    DWORD   sc;
    DWORD   ulIPAddress;
    DWORD   ulSubnetMask;

    IUnknown * punk = NULL;

    if ( ppIPAddressOut == NULL )
        goto InvalidPointer;

    sc = TW32( m_cplNetworkRO.ScMoveToPropertyByName( L"Address" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_ScMoveToPropetyByName_Address_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplNetworkRO.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( m_cplNetworkRO.CbhCurrentValue().pStringValue->sz, &ulIPAddress ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_ClRtlTcpipStringToAddress_Address_Failed, hr );
        goto Cleanup;
    }

    sc = TW32( m_cplNetworkRO.ScMoveToPropertyByName( L"AddressMask" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_ScMoveToPropetyByName_AddressMask_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplNetworkRO.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( m_cplNetworkRO.CbhCurrentValue().pStringValue->sz, &ulSubnetMask ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_ClRtlTcpipStringToAddress_AddressMask_Failed, hr );
        goto Cleanup;
    }

    hr = THR( CProxyCfgIPAddressInfo::S_HrCreateInstance( &punk,
                                                          m_punkOuter,
                                                          m_phCluster,
                                                          m_pclsidMajor,
                                                          ulIPAddress,
                                                          ulSubnetMask
                                                          ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_Create_CProxyCfgIPAddressInfo_Failed, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgIPAddressInfo, ppIPAddressOut ) );

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgNetworkInfo::GetPrimaryNetworkAddress

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::IsPublic( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;
    DWORD   dwRole;

    hr = THR( HrGetNetworkRole( &dwRole ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( dwRole == ClusterNetworkRoleClientAccess
      || dwRole == ClusterNetworkRoleInternalAndClient
       )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::IsPublic

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::IsPrivate( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT                 hr;
    DWORD                   dwRole;

    hr = THR( HrGetNetworkRole( &dwRole ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( dwRole == ClusterNetworkRoleInternalUse
      || dwRole == ClusterNetworkRoleInternalAndClient
       )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::IsPrivate

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::SetPublic(
    BOOL fIsPublicIn
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::SetPublic

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::SetPrivate(
    BOOL fIsPrivateIn
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::SetPrivate

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::SetPrimaryNetworkAddress( IClusCfgIPAddressInfo * pIPAddressIn )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::SetPrimaryNetworkAddress

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::SetDescription(
    LPCWSTR pcszDescriptionIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] bstrDescription = '%ls'", pcszDescriptionIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::SetDescription

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] pcszNameIn = '%ls'", pcszNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::SetName


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgNetworkInfo -- IEnumClusCfgIPAddresses interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// This interface exists and must be supported, but since we only have the
// information about the primary network address available, All we can do is
// return an empty iterator.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNetworkInfo::Next(
        ULONG                       cNumberRequestedIn,
        IClusCfgIPAddressInfo **    rgpIPAddressInfoOut,
        ULONG *                     pcNumberFetchedOut
        )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_FALSE;

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = 0;
    } // if:

    HRETURN( hr );

} // *** CProxyCfgNetworkInfo::Next

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::Reset( void )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // *** CProxyCfgNetworkInfo::Reset

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // *** CProxyCfgNetworkInfo::Skip

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::Clone( IEnumClusCfgIPAddresses ** ppiIPAddressInfoOut )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // *** CProxyCfgNetworkInfo::Clone


//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::Count ( DWORD * pnCountOut  )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = THR( S_OK );

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = 0;

Cleanup:

    HRETURN( hr );

} // *** CProxyCfgNetworkInfo::Count


//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNetworkInfo::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             pcszDescriptionIn,
                                             pftTimeIn,
                                             pcszReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

}  //*** CProxyCfgNetworkInfo::SendStatusReport

//
//
//
HRESULT
CProxyCfgNetworkInfo::HrGetNetworkRole(
    DWORD * pdwRoleOut
    )
{
    TraceFunc( "" );
    Assert( pdwRoleOut != NULL );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    CLUSPROP_BUFFER_HELPER  cpbh;

    sc = TW32( m_cplNetwork.ScMoveToPropertyByName( L"Role" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrGetNetworkRole_ScMoveToPropetyByName_Failed, hr );
        goto Cleanup;
    }

    cpbh = m_cplNetwork.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );

    *pdwRoleOut = cpbh.pDwordValue->dw;

Cleanup:

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::HrGetNetworkRole
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgnodeinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgNodeInfo.cpp
//
//  Description:
//      CProxyCfgNodeInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CProxyCfgNodeInfo.h"
#include "CProxyCfgClusterInfo.h"
#include "nameutil.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CProxyCfgNodeInfo")

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::S_HrCreateInstance
//
//  Description:
//      Create a CProxyCfgNodeInfo instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgNodeInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNodeNameIn,
    LPCWSTR     pcszDomainIn
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CProxyCfgNodeInfo * ppcni = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    ppcni = new CProxyCfgNodeInfo;
    if ( ppcni == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( ppcni->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn, pcszNodeNameIn, pcszDomainIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ppcni->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( ppcni != NULL )
    {
        ppcni->Release();
    } // if:

    HRETURN( hr );

} //*** CProxyCfgNodeInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::CProxyCfgNodeInfo
//
//  Description:
//      Constructor of the CProxyCfgNodeInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgNodeInfo::CProxyCfgNodeInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_punkOuter == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );
    Assert( m_pcccb == NULL );
    // m_cplNode?
    // m_cplNodeRO?
    Assert( m_hNode == NULL );

    TraceFuncExit();

} //*** CProxyCfgNodeInfo::CProxyCfgNodeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::~CProxyCfgNodeInfo
//
//  Description:
//      Destructor of the CProxyCfgNodeInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgNodeInfo::~CProxyCfgNodeInfo( void )
{
    TraceFunc( "" );

    //  m_cRef

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release();
    }

    //  m_phCluster - DO NOT CLOSE!

    //  m_pclsidMajor

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    //  m_cplNode - has its own dotr

    //  m_cplNodeRO - has its own dotr

    if ( m_hNode != NULL )
    {
        BOOL bRet;
        bRet = CloseClusterNode( m_hNode );
        Assert( bRet );
    }

    TraceSysFreeString( m_bstrDomain );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CProxyCfgNodeInfo::~CProxyCfgNodeInfo

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::HrInit
//
//  Description:
//      Initializes the object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Succeeded
//
//      other HRESULTs
//          Failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgNodeInfo::HrInit(
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNodeNameIn,
    LPCWSTR     pcszDomainIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    DWORD   sc;
    BSTR    bstrShortNodeName = NULL;

    // IUnknown
    Assert( m_cRef == 1 );

    //
    //  Gather information from the input parameters.
    //

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef();
    }

    if ( phClusterIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    //
    //  See if we can callback.
    //

    hr = THR( m_punkOuter->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Save away the domain.
    //

    m_bstrDomain = TraceSysAllocString( pcszDomainIn );
    if ( m_bstrDomain == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    //
    //  Open the node.
    //

    if ( pcszNodeNameIn != NULL )
    {
        //
        //  Caller supplied the node name.
        //

        hr = THR( HrGetFQNDisplayName( pcszNodeNameIn, &bstrShortNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_hNode = OpenClusterNode( *m_phCluster, bstrShortNodeName );

        if ( m_hNode == NULL )
        {
            sc = GetLastError();
            if ( sc != ERROR_NOT_FOUND )
            {
                hr = HRESULT_FROM_WIN32( TW32( sc ) );
                SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_OpenClusterNode_Failed, hr );
                goto Cleanup;
            }
        }
    }
    else
    {

        sc = TW32( ResUtilEnumResourcesEx( *m_phCluster,
                                           NULL,
                                           L"Network Name",
                                           &DwEnumResourcesExCallback,
                                           this
                                           ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ResUtilEnumResourcesEx_Failed, hr );
            goto Cleanup;
        }

        Assert( m_hNode != NULL );
    }

    //
    // Retrieve the properties.
    //

    sc = TW32( m_cplNode.ScGetNodeProperties( m_hNode, CLUSCTL_NODE_GET_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetNodeProperties_Failed, hr );
        goto Cleanup;
    } // if:

    sc = TW32( m_cplNodeRO.ScGetNodeProperties( m_hNode, CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetNodeProperties_Failed, hr );
        goto Cleanup;
    } // if:

Cleanup:

    TraceSysFreeString( bstrShortNodeName );
    
    HRETURN( hr );

} //*** CProxyCfgNodeInfo::HrInit



//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgNodeInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNodeInfo::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgNodeInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgNodeInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgNodeInfo, this, 0 );
    } // else if: IClusCfgNodeInfo
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CConfigClusApi::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProxyCfgNodeInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CProxyCfgNodeInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProxyCfgNodeInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CProxyCfgNodeInfo::Release


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgNodeInfo -- IClusCfgNodeInfo interface.
/////////////////////////////////////////////////////////////////////////////

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::GetClusterConfigInfo(
        IClusCfgClusterInfo ** ppClusCfgClusterInfoOut
        )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr;
    IUnknown * punk = NULL;

    //
    //  Check parameters.
    //

    if ( ppClusCfgClusterInfoOut == NULL )
        goto InvalidPointer;

    //
    // Create the cluster object
    //

    hr = THR( CProxyCfgClusterInfo::S_HrCreateInstance( &punk,
                                                        m_punkOuter,
                                                        m_phCluster,
                                                        m_pclsidMajor,
                                                        m_bstrDomain
                                                        ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterConfigInfo_Create_CProxyCfgClusterInfo_Failed, hr );
        goto Cleanup;
    } // if:

    //
    //  QI for the return interface.
    //

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, ppClusCfgClusterInfoOut ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterConfigInfo_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );
InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterConfigInfo_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgNodeInfo::GetClusterConfigInfo


//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::GetOSVersion(
            DWORD * pdwMajorVersionOut,
            DWORD * pdwMinorVersionOut,
            WORD *  pwSuiteMaskOut,
            BYTE *  pbProductTypeOut,
            BSTR *  pbstrCSDVersionOut
            )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr;
    DWORD   sc;

    //
    //  Check parameters.
    //

    if ( pdwMajorVersionOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_InvalidPointer, hr );
        goto Cleanup;
    }

    if ( pdwMinorVersionOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_InvalidPointer, hr );
        goto Cleanup;
    }

    if ( pwSuiteMaskOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_InvalidPointer, hr );
        goto Cleanup;
    }

    if ( pbProductTypeOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_InvalidPointer, hr );
        goto Cleanup;
    }

    if ( pbstrCSDVersionOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_InvalidPointer, hr );
        goto Cleanup;
    }

    //
    //  "Major Version"
    //

    sc = TW32( m_cplNodeRO.ScMoveToPropertyByName( L"MajorVersion" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_MajorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNodeRO.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );
    *pdwMajorVersionOut = *m_cplNodeRO.CbhCurrentValue().pdw;

    //
    //  "Minor Version"
    //

    sc = TW32( m_cplNodeRO.ScMoveToPropertyByName( L"MinorVersion" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_MinorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNodeRO.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );
    *pdwMinorVersionOut = *m_cplNodeRO.CbhCurrentValue().pdw;

    //
    //  "CSD Version"
    //

    sc = TW32( m_cplNodeRO.ScMoveToPropertyByName( L"CSDVersion" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_CSDVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNodeRO.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );
    *pbstrCSDVersionOut  = SysAllocString( m_cplNodeRO.CbhCurrentValue().pStringValue->sz );
    if ( *pbstrCSDVersionOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_OutOfMemory, hr );
        goto Cleanup;
    }

    //
    //  Stuff we can't gather (yet?)
    //

    *pwSuiteMaskOut      = 0;
    *pbProductTypeOut    = 0;

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CProxyCfgNodeInfo::GetOSVersion

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;
    DWORD   sc = ERROR_SUCCESS;
    BSTR    bstrHostName = NULL;
    BSTR    bstrNodeFQDN = NULL;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_NodeInfo_GetName_InvalidPointer, hr );
        goto Cleanup;
    }

    sc = TW32( m_cplNodeRO.ScMoveToPropertyByName( L"NodeName" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_MinorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNodeRO.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );
    bstrHostName = SysAllocString( m_cplNodeRO.CbhCurrentValue().pStringValue->sz );
    if ( bstrHostName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NodeInfo_GetName_OutOfMemory, hr );
        goto Cleanup;
    }

    hr = THR( HrMakeFQN( bstrHostName, m_bstrDomain, true, &bstrNodeFQDN ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NodeInfo_GetName_HrMakeFQN_Failed, hr );
        goto Cleanup;
    }

    *pbstrNameOut = bstrNodeFQDN;
    TraceMemoryDelete( bstrNodeFQDN, false ); // prevent false reports of memory leaks
    bstrNodeFQDN = NULL;

Cleanup:

    TraceSysFreeString( bstrHostName );
    TraceSysFreeString( bstrNodeFQDN );

    HRETURN( hr );

} //*** CProxyCfgNodeInfo::GetName

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::IsMemberOfCluster( void )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CProxyCfgNodeInfo::IsMemberOfCluster

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::GetClusterVersion(
    DWORD * pdwNodeHighestVersionOut,
    DWORD * pdwNodeLowestVersionOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;
    BSTR    bstrClusterName = NULL;
    CLUSTERVERSIONINFO ClusInfo;

    if ( pdwNodeHighestVersionOut == NULL )
        goto InvalidPointer;

    if ( pdwNodeLowestVersionOut == NULL )
        goto InvalidPointer;

    // Initialize variables.
    ClusInfo.dwVersionInfoSize = sizeof(CLUSTERVERSIONINFO);

    hr = THR( HrGetClusterInformation( *m_phCluster, &bstrClusterName, &ClusInfo ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterInformation_Failed, hr );
        goto Cleanup;
    }

    *pdwNodeHighestVersionOut = ClusInfo.dwClusterHighestVersion;
    *pdwNodeLowestVersionOut = ClusInfo.dwClusterLowestVersion;

Cleanup:
    TraceSysFreeString( bstrClusterName );

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterVersion_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgNodeInfo::GetClusterVersion

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterUsageOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pdlmDriveLetterUsageOut == NULL )
        goto InvalidPointer;

    //
    // NOTE:  This really does not do anything (yet). Just clear the array.
    //

    ZeroMemory( pdlmDriveLetterUsageOut, sizeof(*pdlmDriveLetterUsageOut) );

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetDriveLetterMappings_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgNodeInfo::GetDriveLetterMappings

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgNodeInfo] pcszNameIn = '%ls'", pcszNameIn );

    HRESULT hr = S_FALSE;

    AssertMsg( FALSE, "Why is someone calling this?" );

    HRETURN( hr );

} //*** CProxyCfgNodeInfo::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::GetMaxNodeCount
//
//  Description:
//      Returns the maximun number of nodes for this node's product
//      suite type.
//
//  Notes:
//
//  Parameter:
//      pcMaxNodesOut
//          The maximum number of nodes allowed by this node's product
//          suite type.
//
//  Return Value:
//      S_OK
//          Success.
//
//      other HRESULT
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNodeInfo::GetMaxNodeCount(
    DWORD * pcMaxNodesOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pcMaxNodesOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    //  TODO:   11-OCT-2001 GalenB
    //
    //  Need to figure out the correct max nodes for the suite type
    //  of the Win2K node that we are proxying for.  Since we are
    //  not running on the node this could be hard.
    //

    hr = S_FALSE;

Cleanup:

    HRETURN( hr );

} //*** CProxyCfgNodeInfo::GetMaxNodeCount


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::GetProcessorInfo
//
//  Description:
//      Get the processor information for this node.
//
//  Arguments:
//      pwProcessorArchitectureOut
//          The processor architecture.
//
//      pwProcessorLevelOut
//          The processor type.
//
//  Return Value:
//      S_OK
//          Success.
//
//      other HRESULT
//          The call failed.
//
//  Remarks:
//      See SYSTEM_INFO in MSDN and/or the Platform SDK for more
//      information.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNodeInfo::GetProcessorInfo(
      WORD *    pwProcessorArchitectureOut
    , WORD *    pwProcessorLevelOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( ( pwProcessorArchitectureOut == NULL ) && ( pwProcessorLevelOut == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = S_FALSE;

Cleanup:

    HRETURN( hr );

} //*** CProxyCfgNodeInfo::GetProcessorInfo


//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNodeInfo::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             pcszDescriptionIn,
                                             pftTimeIn,
                                             pcszReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

}  //*** CProxyCfgNodeInfo::SendStatusReport


//****************************************************************************
//
// Privates
//
//****************************************************************************


//
//
//
DWORD
CProxyCfgNodeInfo::DwEnumResourcesExCallback(
    HCLUSTER hClusterIn,
    HRESOURCE hResourceSelfIn,
    HRESOURCE hResourceIn,
    PVOID pvIn
    )
{
    TraceFunc( "" );

    DWORD sc;
    DWORD dwFlags;
    DWORD cchName;

    CLUSTER_RESOURCE_STATE state;

    BSTR  bstrName = NULL;
    CProxyCfgNodeInfo * pthis = reinterpret_cast< CProxyCfgNodeInfo * >( pvIn );

    sc = TW32( ClusterResourceControl( hResourceIn,
                                       NULL,
                                       CLUSCTL_RESOURCE_GET_FLAGS,
                                       NULL,
                                       0,
                                       &dwFlags,
                                       sizeof(dwFlags),
                                       NULL
                                       ) );
    if ( sc != ERROR_SUCCESS )
        goto Cleanup;

    if ( ( dwFlags & CLUS_FLAG_CORE ) == 0 )
    {
        Assert( sc == ERROR_SUCCESS );
        goto Cleanup;
    }

    cchName = 64;   // arbitary size

    bstrName = TraceSysAllocStringLen( NULL, cchName );
    if ( bstrName == NULL )
    {
        sc = TW32( ERROR_NOT_ENOUGH_MEMORY );
        goto Cleanup;
    }

    cchName ++; // SysAllocStringLen allocate cchName + 1

    state = GetClusterResourceState( hResourceIn, bstrName, &cchName, NULL, NULL );
    if ( state == ClusterResourceStateUnknown )
    {
        sc = TW32( GetLastError() );
        if ( sc == ERROR_MORE_DATA )
        {
            TraceSysFreeString( bstrName );

            bstrName = TraceSysAllocStringLen( NULL, cchName );
            if ( bstrName == NULL )
            {
                sc = TW32( ERROR_NOT_ENOUGH_MEMORY );
                goto Cleanup;
            }

            cchName ++; // SysAllocStringLen allocate cchName + 1

            state = GetClusterResourceState( hResourceIn, bstrName, &cchName, NULL, NULL );
            if ( state == ClusterResourceStateUnknown )
            {
                sc = TW32( GetLastError() );
                goto Cleanup;
            }
        }
        else
        {
            goto Cleanup;
        }
    } // if: unknown resource state

    pthis->m_hNode = OpenClusterNode( hClusterIn, bstrName );
    if ( pthis->m_hNode == NULL )
    {
        sc = TW32( GetLastError() );
        goto Cleanup;
    }

    sc = ERROR_SUCCESS;

Cleanup:

    TraceSysFreeString( bstrName );

    RETURN( sc );

} //*** CProxyCfgNodeInfo::DwEnumResourcesExCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgnodeinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgNodeInfo.h
//
//  Description:
//      CProxyCfgNodeInfo definition.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProxyCfgNodeInfo
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProxyCfgNodeInfo
    : public IClusCfgNodeInfo
{
private:

    LONG                m_cRef;
    IUnknown *          m_punkOuter;                //  Outer control object - It can't be deleted until we get deleted.
    HCLUSTER *          m_phCluster;                //  Pointer to the handle of the cluster/node - DO NOT CLOSE!
    CLSID *             m_pclsidMajor;              //  Pointer to the clsid to log UI information to.
    IClusCfgCallback *  m_pcccb;                    //  Callback interface to log information.
    CClusPropList       m_cplNode;                  //  Property list with Node info
    CClusPropList       m_cplNodeRO;                //  Property list with Node info READ ONLY
    HNODE               m_hNode;                    //  Handle to node
    BSTR                m_bstrDomain;               //  Domain name for the node.

    CProxyCfgNodeInfo( void );
    ~CProxyCfgNodeInfo( void );

    // Private copy constructor to prevent copying.
    CProxyCfgNodeInfo( const CProxyCfgNodeInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CProxyCfgNodeInfo & operator = ( const CProxyCfgNodeInfo & nodeSrc );

    HRESULT HrInit( IUnknown *   punkOuterIn,
                    HCLUSTER *   phClusterIn,
                    CLSID *      pclsidMajorIn,
                    LPCWSTR      pcszNodeNameIn,
                    LPCWSTR      pcszDomainIn
                    );

    static DWORD
        DwEnumResourcesExCallback( HCLUSTER hClusterIn,
                                   HRESOURCE hResourceSelfIn,
                                   HRESOURCE hResourceIn,
                                   PVOID pvIn
                                   );

public:
    static HRESULT S_HrCreateInstance( IUnknown **  ppunkOut,
                                       IUnknown *   punkOuterIn,
                                       HCLUSTER *   phClusterIn,
                                       CLSID *      pclsidMajorIn,
                                       LPCWSTR      pcszNodeNameIn,
                                       LPCWSTR      pcszDomainIn
                                       );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgNodeInfo
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( IsMemberOfCluster) ( void );
    STDMETHOD( GetClusterConfigInfo )( IClusCfgClusterInfo ** ppClusCfgClusterInfoOut );
    STDMETHOD( GetOSVersion )(
                DWORD * pdwMajorVersionOut,
                DWORD * pdwMinorVersionOut,
                WORD *  pwSuiteMaskOut,
                BYTE *  pbProductTypeOut,
                BSTR *  pbstrCSDVersionOut );

    STDMETHOD( GetClusterVersion )( DWORD * pdwNodeHighestVersion, DWORD * pdwNodeLowestVersion );
    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterUsageOut );
    STDMETHOD( GetMaxNodeCount )( DWORD * pcMaxNodesOut );
    STDMETHOD( GetProcessorInfo )( WORD * pwProcessorArchitectureOut, WORD * pwProcessorLevelOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** Class CProxyCfgNodeInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cresourcephysicaldisk.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CResourcePhysicalDisk.cpp
//
//  Description:
//      CResourcePhysicalDisk implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "Pch.h"
#include "CResourcePhysicalDisk.h"
#include "CResourcePhysicalDiskPartition.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CResourcePhysicalDisk")


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::S_HrCreateInstance
//
//  Description:
//      Create a CResourcePhysicalDisk instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourcePhysicalDisk::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNameIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CResourcePhysicalDisk * prpd = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    prpd = new CResourcePhysicalDisk;
    if ( prpd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = STHR( prpd->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn, pcszNameIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    if ( hr == S_FALSE )
    {
        *ppunkOut = NULL;
        goto Cleanup;
    } // if:

    hr = THR( prpd->TypeSafeQI( IUnknown, ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    if ( prpd != NULL )
    {
        prpd->Release();
    } // if:

    HRETURN( hr );

} //*** CResourcePhysicalDisk::S_HrCreateInitializedInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::CResourcePhysicalDisk
//
//  Description:
//      Constructor of the CResourcePhysicalDisk class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourcePhysicalDisk::CResourcePhysicalDisk( void )
    : m_cRef( 1 )
    , m_fIsQuorumCapable( TRUE )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_punkOuter == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );
    //  Assert( m_cplResource );
    //  Assert( m_cplResourceRO );
    //  Assert( m_cpvlDiskInfo );
    Assert( m_dwFlags == 0 );
    Assert( m_cParitions == 0 );
    Assert( m_ppPartitions == NULL );
    Assert( m_ulCurrent == 0 );

    TraceFuncExit();

} //*** CResourcePhysicalDisk::CResourcePhysicalDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::CResourcePhysicalDisk
//
//  Description:
//      Destructor of the CResourcePhysicalDisk class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourcePhysicalDisk::~CResourcePhysicalDisk( void )
{
    TraceFunc( "" );

    //  m_cRef - noop

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release();
    }

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    } // if:

    // m_phCluster - DO NOT CLOSE!

    // m_pclsidMajor - noop

    // m_cplResource - has its own dtor

    // m_cplResourceRO - has its own dtor

    // m_cpvlDiskInfo - has its own dtor

    // m_dwFlags - noop

    if ( m_ppPartitions != NULL )
    {
        while( m_cParitions != 0 )
        {
            m_cParitions --;

            if ( m_ppPartitions[ m_cParitions ] != NULL )
            {
                m_ppPartitions[ m_cParitions ]->Release();
            }
        }

        TraceFree( m_ppPartitions );
    }

    // m_ulCurrent

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CResourcePhysicalDisk::~CResourcePhysicalDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::HrInit
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourcePhysicalDisk::HrInit(
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNameIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    DWORD   sc;
    DWORD   cb;
    ULONG   cPartition;

    HRESOURCE hResource = NULL;
    IUnknown * punk = NULL;

    // IUnknown
    Assert( m_cRef == 1 );

    //
    //  Gather information from the input parameters.
    //

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef();
    }

    if ( phClusterIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_PhysDisk_HrInit_InvalidArg, hr );
        goto Cleanup;
    }

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_PhysDisk_HrInit_InvalidArg, hr );
        goto Cleanup;
    }

    //
    //  See if we can callback.
    //

    hr = THR( m_punkOuter->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Retrieve the properties.
    //

    hResource = OpenClusterResource( *m_phCluster, pcszNameIn );
    if ( hResource == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_OpenClusterResource_Failed, hr );
        goto Cleanup;
    }

    sc = TW32( m_cplResource.ScGetResourceProperties( hResource, CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetResourceProperties_Failed, hr );
        goto Cleanup;
    }

    //
    //  We only handle Physical Disk resources.
    //

    sc = TW32( m_cplResource.ScMoveToPropertyByName( L"Type" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScMoveToPropertyByName_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplResource.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    if ( ClRtlStrNICmp(
                    m_cplResource.CbhCurrentValue().pStringValue->sz,
                    CLUS_RESTYPE_NAME_PHYS_DISK,                    // L"Physical Disk" - defined in clusudef.h
                    ARRAYSIZE( CLUS_RESTYPE_NAME_PHYS_DISK )
                  ) != 0 )
    {
        //
        //  The resource isn't a physical disk.
        //

        hr = S_FALSE;
        goto Cleanup;
    }

    sc = TW32( m_cplResourceRO.ScGetResourceProperties( hResource, CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetResourceProperties_Failed, hr );
        goto Cleanup;
    }

    sc = TW32( m_cpvlDiskInfo.ScGetResourceValueList( hResource, CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetResourceValueList_Failed, hr );
        goto Cleanup;
    }

    sc = TW32( ClusterResourceControl( hResource, NULL, CLUSCTL_RESOURCE_GET_FLAGS, NULL, NULL, &m_dwFlags, sizeof(m_dwFlags), &cb ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ClusterResourceControl_Failed, hr );
        goto Cleanup;
    }
    Assert( cb == sizeof(m_dwFlags) );

    //
    //  Figure out how many partitions there are.
    //

    m_cParitions = 0;

    sc = TW32( m_cpvlDiskInfo.ScMoveToFirstValue() );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_ScMoveToFirstValue_Failed, hr );
        goto Cleanup;
    } // if:

    do
    {
        if ( m_cpvlDiskInfo.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO )
        {
            m_cParitions ++;
        }

        // Move to the next item.
        sc = m_cpvlDiskInfo.ScCheckIfAtLastValue();
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
           break;
        } // if:

        sc = TW32( m_cpvlDiskInfo.ScMoveToNextValue() );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_ScMoveToNextValue_Failed, hr );
            goto Cleanup;
        }

    } while( sc == ERROR_SUCCESS );

    //
    //  Allocate the array to store pointers to the partition objects.
    //

    m_ppPartitions = (IClusCfgPartitionInfo **) TraceAlloc( 0, m_cParitions * sizeof(IClusCfgPartitionInfo *) );
    if ( m_ppPartitions == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_OutOfMemory, hr );
        goto Cleanup;
    }

    //
    //  Now loop again creating partition objects.
    //

    cPartition = 0;

    sc = TW32( m_cpvlDiskInfo.ScMoveToFirstValue() );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_ScMoveToFirstValue_Failed, hr );
        goto Cleanup;
    } // if:

    do
    {
        if ( m_cpvlDiskInfo.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO )
        {
            // Create the object
            hr = THR( CResourcePhysicalDiskPartition::S_HrCreateInstance( &punk ) );
            if ( FAILED( hr ) )
            {
                SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_Create_CResourcePhysicalDiskPartition_Failed, hr );
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IClusCfgPartitionInfo, &m_ppPartitions[ cPartition ] ) );
            if ( FAILED( hr ) )
            {
                SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_QI_Failed, hr );
                goto Cleanup;
            }

            punk->Release();
            punk = NULL;

            cPartition ++;
        }

        // Move to the next item.
        sc = m_cpvlDiskInfo.ScCheckIfAtLastValue();
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
           break;
        } // if:

        sc = TW32( m_cpvlDiskInfo.ScMoveToNextValue() );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_ScMoveToNextValue2_Failed, hr );
            goto Cleanup;
        }

    } while( sc == ERROR_SUCCESS && cPartition < m_cParitions );

    hr = S_OK;

Cleanup:

    if ( hResource != NULL )
    {
        BOOL bRet;
        bRet = CloseClusterResource( hResource );
        Assert( bRet );
    }
    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

} //*** CResourcePhysicalDisk::HrInit


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourcePhysicalDisk -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgManagedResourceInfo * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
    } // else if: IClusCfgManagedResourceInfo
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgPartitions ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgPartitions, this, 0 );
    } // else if: IEnumClusCfgPartitions
    else if ( IsEqualIID( riidIn, IID_IClusCfgVerifyQuorum ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgVerifyQuorum, this, 0 );
    } // else if: IClusCfgVerifyQuorum
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING1(
          hr
        , riidIn
        , IID_IClusCfgManagedResourceData
        );

} //*** CConfigClusApi::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResourcePhysicalDisk::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CResourcePhysicalDisk::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResourcePhysicalDisk::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CResourcePhysicalDisk::Release


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourcePhysicalDisk -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;
    DWORD   sc;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_INVALIDARG );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetName_InvalidPointer, hr );
        goto Cleanup;
    }

    //
    //  "Major Version"
    //

    sc = TW32( m_cplResourceRO.ScMoveToPropertyByName( L"Name" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetName_ScMoveToPropertyByName_MajorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplResourceRO.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    *pbstrNameOut = SysAllocString( m_cplResourceRO.CbhCurrentValue().pStringValue->sz );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetName_OutOfMemory, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CResourcePhysicalDisk::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::GetUID(
    BSTR * pbstrUIDOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;
    DWORD   sc;
    UCHAR   TargetId;
    UCHAR   Lun;

    WCHAR   sz[ 64 ];

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_InvalidPointer, hr );
        goto Cleanup;
    }

    // loop through all the properties.
    sc = TW32( m_cpvlDiskInfo.ScMoveToFirstValue() );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ScMoveToFirstValue_Failed, hr );
        goto Cleanup;
    } // if:

    do
    {
        if ( m_cpvlDiskInfo.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_SCSI_ADDRESS )
        {
            break;  // found it!
        }

        // Move to the next item.
        sc = m_cpvlDiskInfo.ScCheckIfAtLastValue();
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
           break;
        } // if:

        sc = TW32( m_cpvlDiskInfo.ScMoveToNextValue() );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ScMoveToNextValue_Failed, hr );
            goto Cleanup;
        }

    } while( sc == ERROR_SUCCESS );

    TargetId = m_cpvlDiskInfo.CbhCurrentValue().pScsiAddressValue->TargetId;
    Lun = m_cpvlDiskInfo.CbhCurrentValue().pScsiAddressValue->Lun;

    // Print the UID identical to the others.
    hr = THR( StringCchPrintfW( sz, ARRAYSIZE( sz ), L"SCSI Tid %ld, SCSI Lun %ld", TargetId, Lun ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( sz );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_OutOfMemory, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CResourcePhysicalDisk::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::IsManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Is managed.
//
//      S_FALSE
//          Is not managed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CResourcePhysicalDisk::IsManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::IsQuorumResource
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Is quorum device.
//
//      S_FALSE
//          Is not quorum device.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::IsQuorumResource( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_dwFlags & CLUS_FLAG_CORE )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    } // else:

    HRETURN( hr );

} //*** CResourcePhysicalDisk::IsQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::IsQuorumCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Is quorum capable device.
//
//      S_FALSE
//          Is not quorum capable device.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorumCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CResourcePhysicalDisk::IsQuorumCapable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::IsManagedByDefault
//
//  Description:
//      Should this resource be managed by the cluster by default?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The device is always managed by default.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::IsManagedByDefault( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CResourcePhysicalDisk::IsManagedByDefault


//////////////////////////////////////////////////////////////////////////
//
//  CResourcePhysicalDisk::SetQuorumCapable
//
//  Description:
//      Call this to set whether the resource is capable to be the quorum
//      resource or not.
//
//  Parameter:
//      fIsQuorumCapableIn - If TRUE, the resource will be marked as quorum capable.
//
//  Return Values:
//      S_OK
//          Call succeeded.
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetQuorumCapable(
    BOOL fIsQuorumCapableIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsQuorumCapable = fIsQuorumCapableIn;

    HRETURN( hr );

} //*** CResourcePhysicalDisk::SetQuorumCapable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( pdlmDriveLetterMappingOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    ZeroMemory( pdlmDriveLetterMappingOut, sizeof(*pdlmDriveLetterMappingOut) );

Cleanup:

    HRETURN( hr );

} //*** CResourcePhysicalDisk::GetDriveLetterMappings

//
// KB:  Some of these methods are supported in a limited sense for compatability.
//      Those methods compare the request with the current data and succeed if they
//      match, and fail otherwise.  All other methods assert and fail when called.
//      If they are used, appropriate handling should be done in the upper level,
//      And the THR removed from that section of code.
//

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDisk::SetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CResourcePhysicalDisk::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SetManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetManaged(
    BOOL fIsManagedIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    Assert( fIsManagedIn );

    if ( !fIsManagedIn )
    {
        hr = THR( E_INVALIDARG );
    }

    HRETURN( hr );

} //*** CResourcePhysicalDisk::SetManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SetQuorumResource
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetQuorumResource(
    BOOL fIsQuorumResourceIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_dwFlags & CLUS_FLAG_CORE )
    {
        if ( fIsQuorumResourceIn )
        {
            hr = S_OK;
        }
        else
        {
            hr = THR( E_INVALIDARG );
        }
    } // if: core resource
    else
    {
        if ( ! fIsQuorumResourceIn )
        {
            hr = S_OK;
        }
        else
        {
            hr = THR( E_INVALIDARG );
        }
    }

    HRETURN( hr );

} //*** CResourcePhysicalDisk::SetQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SetManagedByDefault
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetManagedByDefault(
    BOOL fIsManagedByDefaultIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    Assert( fIsManagedByDefaultIn );

    if ( !fIsManagedByDefaultIn )
    {
        hr = THR( E_INVALIDARG );
    } // if:

    HRETURN( hr );

} //*** CResourcePhysicalDisk::SetManagedByDefault


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourcePhysicalDisk -- IEnumClusCfgPartitions interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::Next(
    ULONG                       cNumberRequestedIn,
    IClusCfgPartitionInfo **    rgpPartitionInfoOut,
    ULONG *                     pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr;
    ULONG   cFetched = min(cNumberRequestedIn, m_cParitions - m_ulCurrent);

    if ( rgpPartitionInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_PhysDisk_Next_InvalidPointer, hr );
        goto Cleanup;
    }

    for ( ; cFetched < cNumberRequestedIn; cFetched++, m_ulCurrent++ )
    {
        hr = THR( (m_ppPartitions[ m_ulCurrent ])->TypeSafeQI( IClusCfgPartitionInfo,
                                                               &rgpPartitionInfoOut[ cFetched ]
                                                               ) );
        if ( FAILED( hr ) )
        {
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_Next_QI_Failed, hr );
            goto Cleanup;
        }
    }

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    if ( FAILED( hr ) )
    {
        while ( cFetched != 0 );
        {
            cFetched --;

            rgpPartitionInfoOut[ cFetched ]->Release();
        }
    }

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    }

    HRETURN( hr );

} //*** CResourcePhysicalDisk::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::Reset( void )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = S_OK;

    m_ulCurrent = 0;

    HRETURN( hr );

} //*** CResourcePhysicalDisk::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::Skip(
    ULONG cNumberToSkipIn
    )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = S_OK;

    m_ulCurrent += cNumberToSkipIn;

    if ( m_ulCurrent >= m_cParitions )
    {
        hr = S_FALSE;
        m_ulCurrent = m_cParitions;
    }
    else
    {
        hr = S_OK;
    }

    HRETURN( hr );

} //*** CResourcePhysicalDisk::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::Clone( IEnumClusCfgPartitions ** ppEnumPartitions )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDisk::Clone



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::Count(  DWORD * pnCountOut  )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = THR( S_OK );

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cParitions;

Cleanup:

    HRETURN( hr );

} //*** CResourcePhysicalDisk::Count



//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             pcszDescriptionIn,
                                             pftTimeIn,
                                             pcszReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

} //*** CResourcePhysicalDisk::SendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::PrepareToHostQuorumResource
//
//  Description:
//      Do any configuration necessary in preparation for this node hosting
//      the quorum.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::PrepareToHostQuorumResource( void )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRETURN( S_OK );

} //*** CResourcePhysicalDisk::PrepareToHostQuorumResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Cleanup
//
//  Description:
//      Do any necessay cleanup from the PrepareToHostQuorumResource()
//      method.
//
//      If the cleanup method is anything other than successful completion
//      then the anything created above in PrepareToHostQuorumResource()
//      needs to be cleaned up.
//
//  Arguments:
//      cccrReasonIn
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::Cleanup(
      EClusCfgCleanupReason cccrReasonIn
    )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRETURN( S_OK );

} //*** CResourcePhysicalDisk::Cleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::IsMultiNodeCapable
//      Does this resource supports multi node clusters?
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          This resource supports multi node clusters.
//
//      S_FALSE
//          This resource does not support multi node clusters.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::IsMultiNodeCapable( void )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRETURN( S_OK );

} //*** CResourcePhysicalDisk::IsMultiNodeCapable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SetMultiNodeCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      This function should never be called.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetMultiNodeCapable(
    BOOL fMultiNodeCapableIn
    )
{
    TraceFunc( "[IClusCfgVerifyQuorum]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CResourcePhysicalDisk::SetMultiNodeCapable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <CITrackerSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <DebugSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <InterfaceTableSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\cresourcephysicaldisk.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CResourcePhysicalDisk.h
//
//  Description:
//      CResourcePhysicalDisk definition.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResourcePhysicalDisk
//
//  Description:
//      The class CResourcePhysicalDisk is the cluster storage device.
//
//  Interfaces:
//      CBaseClusterResourceInfo
//      IClusCfgManagedResourceInfo
//      IClusCfgInitialize
//      IEnumClusCfgPartitions
//
//--
//////////////////////////////////////////////////////////////////////////////
class CResourcePhysicalDisk
    : public IClusCfgManagedResourceInfo
    , public IEnumClusCfgPartitions
    , public IClusCfgVerifyQuorum
{
private:

    LONG                        m_cRef;                 //  Reference counter
    IUnknown *                  m_punkOuter;            //  Interface to Outer W2KProxy object
    IClusCfgCallback *          m_pcccb;                //  Callback interface
    HCLUSTER *                  m_phCluster;            //  Pointer to cluster handle.
    CLSID *                     m_pclsidMajor;          //  CLSID to use when log errors to the UI
    CClusPropList               m_cplResource;          //  Property list for the resource
    CClusPropList               m_cplResourceRO;        //  Property list for the resource READ ONLY
    CClusPropValueList          m_cpvlDiskInfo;         //  GetDiskInfo property value list
    DWORD                       m_dwFlags;              //  CLUSCTL_RESOURCE_GET_FLAGS
    ULONG                       m_cParitions;           //  Number of partitions
    IClusCfgPartitionInfo **    m_ppPartitions;         //  Array of partition objects - length is m_cPartitions
    ULONG                       m_ulCurrent;            //  Current index into the array
    BOOL                        m_fIsQuorumCapable;     // Is this resource quorum capable


    CResourcePhysicalDisk( void );
    ~CResourcePhysicalDisk( void );

    // Private copy constructor to prevent copying.
    CResourcePhysicalDisk( const CResourcePhysicalDisk & nodeSrc );

    // Private assignment operator to prevent copying.
    const CResourcePhysicalDisk & operator = ( const CResourcePhysicalDisk & nodeSrc );

    HRESULT
            HrInit( IUnknown *  punkOuterIn,
                    HCLUSTER *  phClusterIn,
                    CLSID *     pclsidMajorIn,
                    LPCWSTR     pcszNameIn
                    );

public:
    static HRESULT
        S_HrCreateInstance( IUnknown ** punkOut,
                            IUnknown *  punkOuterIn,
                            HCLUSTER *  phClusterIn,
                            CLSID *     pclsidMajorIn,
                            LPCWSTR     pcszNameIn
                            );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgManagedResourceInfo
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( IsManaged )( void );
    STDMETHOD( SetManaged )( BOOL fIsManagedIn );
    STDMETHOD( IsQuorumResource )( void );
    STDMETHOD( SetQuorumResource )( BOOL fIsQuorumResourceIn );
    STDMETHOD( IsQuorumCapable )( void );
    STDMETHOD( SetQuorumCapable )( BOOL fIsQuorumCapableIn );
    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );
    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappingIn );
    STDMETHOD( IsManagedByDefault )( void );
    STDMETHOD( SetManagedByDefault )( BOOL fIsManagedByDefaultIn );

    // IEnumClusCfgPartitions
    STDMETHOD( Next  )( ULONG cNumberRequestedIn, IClusCfgPartitionInfo ** rgpPartitionInfoOut, ULONG * pcNumberFetchedOut );
    STDMETHOD( Reset )( void );
    STDMETHOD( Skip  )( ULONG cNumberToSkipIn );
    STDMETHOD( Clone )( IEnumClusCfgPartitions ** ppEnumPartitions );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

    // IClusCfgVerifyQuorum
    STDMETHOD( PrepareToHostQuorumResource )( void );
    STDMETHOD( Cleanup )( EClusCfgCleanupReason cccrReasonIn );
    STDMETHOD( IsMultiNodeCapable )( void );
    STDMETHOD( SetMultiNodeCapable )( BOOL fMultiNodeCapableIn );

}; //*** Class CResourcePhysicalDisk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\w2kproxy\w2kproxyserverguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      W2KProxyServerGuids.h
//
//  Description:
//      This file contains the guids used in ClusCfgServer.
//
//  Documentation:
//
//  Maintained By:
//      Galen Barbee (GalenB) 31-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma