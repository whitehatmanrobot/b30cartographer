itted, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted) {
	return VFW_E_ALREADY_COMMITTED;
    }

    /* Must be no outstanding buffers */

    if (m_lAllocated != m_lFree.GetCount()) {
	return VFW_E_BUFFERS_OUTSTANDING;
    }

    /* There isn't any real need to check the parameters as they
       will just be rejected when the user finally calls Commit */

    pActual->cbBuffer = m_lSize = pRequest->cbBuffer;
    pActual->cBuffers = m_lCount = pRequest->cBuffers;
    pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
    pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

    m_bChanged = TRUE;
    return NOERROR;
}

STDMETHODIMP
CBaseAllocator::GetProperties(
    ALLOCATOR_PROPERTIES * pActual)
{
    CheckPointer(pActual,E_POINTER);
    ValidateReadWritePtr(pActual,sizeof(ALLOCATOR_PROPERTIES));

    CAutoLock cObjectLock(this);
    pActual->cbBuffer = m_lSize;
    pActual->cBuffers = m_lCount;
    pActual->cbAlign = m_lAlignment;
    pActual->cbPrefix = m_lPrefix;
    return NOERROR;
}

// get container for a sample. Blocking, synchronous call to get the
// next free buffer (as represented by an IMediaSample interface).
// on return, the time etc properties will be invalid, but the buffer
// pointer and size will be correct.

HRESULT CBaseAllocator::GetBuffer(IMediaSample **ppBuffer,
                                  REFERENCE_TIME *pStartTime,
                                  REFERENCE_TIME *pEndTime,
                                  DWORD dwFlags
                                  )
{
    UNREFERENCED_PARAMETER(pStartTime);
    UNREFERENCED_PARAMETER(pEndTime);
    UNREFERENCED_PARAMETER(dwFlags);
    CMediaSample *pSample;

    *ppBuffer = NULL;
    for (;;)
    {
        {  // scope for lock
            CAutoLock cObjectLock(this);

            /* Check we are committed */
            if (!m_bCommitted) {
                return VFW_E_NOT_COMMITTED;
            }
            pSample = (CMediaSample *) m_lFree.RemoveHead();
            if (pSample == NULL) {
                SetWaiting();
            }
        }

        /* If we didn't get a sample then wait for the list to signal */

        if (pSample) {
            break;
        }
        if (dwFlags & AM_GBF_NOWAIT) {
            return VFW_E_TIMEOUT;
        }
        ASSERT(m_hSem != NULL);
        WaitForSingleObject(m_hSem, INFINITE);
    }

    /* Addref the buffer up to one. On release
       back to zero instead of being deleted, it will requeue itself by
       calling the ReleaseBuffer member function. NOTE the owner of a
       media sample must always be derived from CBaseAllocator */


    ASSERT(pSample->m_cRef == 0);
    pSample->m_cRef = 1;
    *ppBuffer = pSample;

    return NOERROR;
}


/* Final release of a CMediaSample will call this */

STDMETHODIMP
CBaseAllocator::ReleaseBuffer(IMediaSample * pSample)
{
    CheckPointer(pSample,E_POINTER);
    ValidateReadPtr(pSample,sizeof(IMediaSample));
    BOOL bRelease = FALSE;
    {
        CAutoLock cal(this);

        /* Put back on the free list */

        m_lFree.Add((CMediaSample *)pSample);
        if (m_lWaiting != 0) {
            NotifySample();
        }

        // if there is a pending Decommit, then we need to complete it by
        // calling Free() when the last buffer is placed on the free list

    	LONG l1 = m_lFree.GetCount();
    	if (m_bDecommitInProgress && (l1 == m_lAllocated)) {
    	    Free();
    	    m_bDecommitInProgress = FALSE;
            bRelease = TRUE;
    	}
    }

    /* For each buffer there is one AddRef, made in GetBuffer and released
       here. This may cause the allocator and all samples to be deleted */

    if (bRelease) {
        Release();
    }
    return NOERROR;
}

void
CBaseAllocator::NotifySample()
{
    if (m_lWaiting != 0) {
        ASSERT(m_hSem != NULL);
        ReleaseSemaphore(m_hSem, m_lWaiting, 0);
        m_lWaiting = 0;
    }
}

STDMETHODIMP
CBaseAllocator::Commit()
{
    /* Check we are not decommitted */
    CAutoLock cObjectLock(this);

    // cannot need to alloc or re-alloc if we are committed
    if (m_bCommitted) {
        return NOERROR;
    }

    /* Allow GetBuffer calls */

    m_bCommitted = TRUE;

    // is there a pending decommit ? if so, just cancel it
    if (m_bDecommitInProgress) {
        m_bDecommitInProgress = FALSE;

        // don't call Alloc at this point. He cannot allow SetProperties
        // between Decommit and the last free, so the buffer size cannot have
        // changed. And because some of the buffers are not free yet, he
        // cannot re-alloc anyway.
        return NOERROR;
    }

    DbgLog((LOG_MEMORY, 1, TEXT("Allocating: %ldx%ld"), m_lCount, m_lSize));

    // actually need to allocate the samples
    HRESULT hr = Alloc();
    if (FAILED(hr)) {
        m_bCommitted = FALSE;
        return hr;
    }
    AddRef();
    return NOERROR;
}


STDMETHODIMP
CBaseAllocator::Decommit()
{
    BOOL bRelease = FALSE;
    {
        /* Check we are not already decommitted */
        CAutoLock cObjectLock(this);
        if (m_bCommitted == FALSE) {
            if (m_bDecommitInProgress == FALSE) {
                return NOERROR;
            }
        }

        /* No more GetBuffer calls will succeed */
        m_bCommitted = FALSE;

        // are any buffers outstanding?
        if (m_lFree.GetCount() < m_lAllocated) {
            // please complete the decommit when last buffer is freed
            m_bDecommitInProgress = TRUE;
        } else {
            m_bDecommitInProgress = FALSE;

            // need to complete the decommit here as there are no
            // outstanding buffers

            Free();
            bRelease = TRUE;
        }

        // Tell anyone waiting that they can go now so we can
        // reject their call
        NotifySample();
    }

    if (bRelease) {
        Release();
    }
    return NOERROR;
}


/* Base definition of allocation which checks we are ok to go ahead and do
   the full allocation. We return S_FALSE if the requirements are the same */

HRESULT
CBaseAllocator::Alloc(void)
{
    /* Error if he hasn't set the size yet */
    if (m_lCount <= 0 || m_lSize <= 0 || m_lAlignment <= 0) {
	return VFW_E_SIZENOTSET;
    }

    /* should never get here while buffers outstanding */
    ASSERT(m_lFree.GetCount() == m_lAllocated);

    /* If the requirements haven't changed then don't reallocate */
    if (m_bChanged == FALSE) {
	return S_FALSE;
    }

    return NOERROR;
}

/*  Implement CBaseAllocator::CSampleList::Remove(pSample)
    Removes pSample from the list
*/
void
CBaseAllocator::CSampleList::Remove(CMediaSample * pSample)
{
    CMediaSample **pSearch;
    for (pSearch = &m_List;
         *pSearch != NULL;
         pSearch = &(CBaseAllocator::NextSample(*pSearch))) {
       if (*pSearch == pSample) {
           *pSearch = CBaseAllocator::NextSample(pSample);
           CBaseAllocator::NextSample(pSample) = NULL;
           m_nOnList--;
           return;
       }
    }
    DbgBreak("Couldn't find sample in list");
}

//=====================================================================
//=====================================================================
// Implements CMemAllocator
//=====================================================================
//=====================================================================


/* This goes in the factory template table to create new instances */
CUnknown *CMemAllocator::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CUnknown *pUnkRet = new CMemAllocator(NAME("CMemAllocator"), pUnk, phr);
    return pUnkRet;
}

CMemAllocator::CMemAllocator(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseAllocator(pName, pUnk, phr),
    m_pBuffer(NULL)
{
}

/* This sets the size and count of the required samples. The memory isn't
   actually allocated until Commit() is called, if memory has already been
   allocated then assuming no samples are outstanding the user may call us
   to change the buffering, the memory will be released in Commit() */
STDMETHODIMP
CMemAllocator::SetProperties(
                ALLOCATOR_PROPERTIES* pRequest,
                ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pActual,E_POINTER);
    ValidateReadWritePtr(pActual,sizeof(ALLOCATOR_PROPERTIES));
    CAutoLock cObjectLock(this);

    ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

    ASSERT(pRequest->cbBuffer > 0);

    SYSTEM_INFO SysInfo;
    GetSystemInfo(&SysInfo);

    /*  Check the alignment request is a power of 2 */
    if ((-pRequest->cbAlign & pRequest->cbAlign) != pRequest->cbAlign) {
	DbgLog((LOG_ERROR, 1, TEXT("Alignment requested 0x%x not a power of 2!"),
	       pRequest->cbAlign));
    }
    /*  Check the alignment requested */
    if (pRequest->cbAlign == 0 ||
	(SysInfo.dwAllocationGranularity & (pRequest->cbAlign - 1)) != 0) {
	DbgLog((LOG_ERROR, 1, TEXT("Invalid alignment 0x%x requested - granularity = 0x%x"),
	       pRequest->cbAlign, SysInfo.dwAllocationGranularity));
	return VFW_E_BADALIGN;
    }

    /* Can't do this if already committed, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted == TRUE) {
	return VFW_E_ALREADY_COMMITTED;
    }

    /* Must be no outstanding buffers */

    if (m_lFree.GetCount() < m_lAllocated) {
	return VFW_E_BUFFERS_OUTSTANDING;
    }

    /* There isn't any real need to check the parameters as they
       will just be rejected when the user finally calls Commit */

    // round length up to alignment - remember that prefix is included in
    // the alignment
    LONG lSize = pRequest->cbBuffer + pRequest->cbPrefix;
    LONG lRemainder = lSize % pRequest->cbAlign;
    if (lRemainder != 0) {
	lSize = lSize - lRemainder + pRequest->cbAlign;
    }
    pActual->cbBuffer = m_lSize = (lSize - pRequest->cbPrefix);

    pActual->cBuffers = m_lCount = pRequest->cBuffers;
    pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
    pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

    m_bChanged = TRUE;
    return NOERROR;
}

// override this to allocate our resources when Commit is called.
//
// note that our resources may be already allocated when this is called,
// since we don't free them on Decommit. We will only be called when in
// decommit state with all buffers free.
//
// object locked by caller
HRESULT
CMemAllocator::Alloc(void)
{
    CAutoLock lck(this);

    /* Check he has called SetProperties */
    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
	return hr;
    }

    /* If the requirements haven't changed then don't reallocate */
    if (hr == S_FALSE) {
	ASSERT(m_pBuffer);
	return NOERROR;
    }
    ASSERT(hr == S_OK); // we use this fact in the loop below

    /* Free the old resources */
    if (m_pBuffer) {
	ReallyFree();
    }

    /* Compute the aligned size */
    LONG lAlignedSize = m_lSize + m_lPrefix;
    if (m_lAlignment > 1) {
        LONG lRemainder = lAlignedSize % m_lAlignment;
        if (lRemainder != 0) {
            lAlignedSize += (m_lAlignment - lRemainder);
        }
    }

    /* Create the contiguous memory block for the samples
       making sure it's properly aligned (64K should be enough!)
    */
    ASSERT(lAlignedSize % m_lAlignment == 0);

    m_pBuffer = (PBYTE)VirtualAlloc(NULL,
				    m_lCount * lAlignedSize,
				    MEM_COMMIT,
				    PAGE_READWRITE);

    if (m_pBuffer == NULL) {
	return E_OUTOFMEMORY;
    }

    LPBYTE pNext = m_pBuffer;
    CMediaSample *pSample;

    ASSERT(m_lAllocated == 0);

    // Create the new samples - we have allocated m_lSize bytes for each sample
    // plus m_lPrefix bytes per sample as a prefix. We set the pointer to
    // the memory after the prefix - so that GetPointer() will return a pointer
    // to m_lSize bytes.
    for (; m_lAllocated < m_lCount; m_lAllocated++, pNext += lAlignedSize) {


	pSample = new CMediaSample(
                        NAME("Default memory media sample"),
			this,
                        &hr,
                        pNext + m_lPrefix,      // GetPointer() value
                        m_lSize);               // not including prefix

        ASSERT(SUCCEEDED(hr));
	if (pSample == NULL) {
	    return E_OUTOFMEMORY;
	}

	// This CANNOT fail
	m_lFree.Add(pSample);
    }

    m_bChanged = FALSE;
    return NOERROR;
}


// override this to free up any resources we have allocated.
// called from the base class on Decommit when all buffers have been
// returned to the free list.
//
// caller has already locked the object.

// in our case, we keep the memory until we are deleted, so
// we do nothing here. The memory is deleted in the destructor by
// calling ReallyFree()
void
CMemAllocator::Free(void)
{
    return;
}


// called from the destructor (and from Alloc if changing size/count) to
// actually free up the memory
void
CMemAllocator::ReallyFree(void)
{
    /* Should never be deleting this unless all buffers are freed */

    ASSERT(m_lAllocated == m_lFree.GetCount());

    /* Free up all the CMediaSamples */

    CMediaSample *pSample;
    for (;;) {
        pSample = m_lFree.RemoveHead();
        if (pSample != NULL) {
            delete pSample;
        } else {
            break;
        }
    }

    m_lAllocated = 0;

    // free the block of buffer memory
    if (m_pBuffer) {
	EXECUTE_ASSERT(VirtualFree(m_pBuffer, 0, MEM_RELEASE));
	m_pBuffer = NULL;
    }
}


/* Destructor frees our memory resources */

CMemAllocator::~CMemAllocator()
{
    Decommit();
    ReallyFree();
}

// ------------------------------------------------------------------------
// filter registration through IFilterMapper. used if IFilterMapper is
// not found (Quartz 1.0 install)

STDAPI
AMovieSetupRegisterFilter( const AMOVIESETUP_FILTER * const psetupdata
                         , IFilterMapper *                  pIFM
                         , BOOL                             bRegister  )
{
  DbgLog((LOG_TRACE, 3, TEXT("= AMovieSetupRegisterFilter")));

  // check we've got data
  //
  if( NULL == psetupdata ) return S_FALSE;


  // unregister filter
  // (as pins are subkeys of filter's CLSID key
  // they do not need to be removed separately).
  //
  DbgLog((LOG_TRACE, 3, TEXT("= = unregister filter")));
  HRESULT hr = pIFM->UnregisterFilter( *(psetupdata->clsID) );


  if( bRegister )
  {
    // register filter
    //
    DbgLog((LOG_TRACE, 3, TEXT("= = register filter")));
    hr = pIFM->RegisterFilter( *(psetupdata->clsID)
                             , psetupdata->strName
                             , psetupdata->dwMerit    );
    if( SUCCEEDED(hr) )
    {
      // all its pins
      //
      DbgLog((LOG_TRACE, 3, TEXT("= = register filter pins")));
      for( UINT m1=0; m1 < psetupdata->nPins; m1++ )
      {
        hr = pIFM->RegisterPin( *(psetupdata->clsID)
                              , psetupdata->lpPin[m1].strName
                              , psetupdata->lpPin[m1].bRendered
                              , psetupdata->lpPin[m1].bOutput
                              , psetupdata->lpPin[m1].bZero
                              , psetupdata->lpPin[m1].bMany
                              , *(psetupdata->lpPin[m1].clsConnectsToFilter)
                              , psetupdata->lpPin[m1].strConnectsToPin );

        if( SUCCEEDED(hr) )
        {
          // and each pin's media types
          //
          DbgLog((LOG_TRACE, 3, TEXT("= = register filter pin types")));
          for( UINT m2=0; m2 < psetupdata->lpPin[m1].nMediaTypes; m2++ )
          {
            hr = pIFM->RegisterPinType( *(psetupdata->clsID)
                                      , psetupdata->lpPin[m1].strName
                                      , *(psetupdata->lpPin[m1].lpMediaType[m2].clsMajorType)
                                      , *(psetupdata->lpPin[m1].lpMediaType[m2].clsMinorType) );
            if( FAILED(hr) ) break;
          }
          if( FAILED(hr) ) break;
        }
        if( FAILED(hr) ) break;
      }
    }
  }

  // handle one acceptable "error" - that
  // of filter not being registered!
  // (couldn't find a suitable #define'd
  // name for the error!)
  //
  if( 0x80070002 == hr)
    return NOERROR;
  else
    return hr;
}


//  Remove warnings about unreferenced inline functions
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\combase.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

#include <streams.h>
#pragma warning( disable : 4514 )   // Disable warnings re unused inline functions


/* Define the static member variable */

LONG CBaseObject::m_cObjects = 0;


/* Constructor */

CBaseObject::CBaseObject(const TCHAR *pName)
{
    /* Increment the number of active objects */
    InterlockedIncrement(&m_cObjects);

#ifdef DEBUG
    m_dwCookie = DbgRegisterObjectCreation(pName);
#endif
}


HINSTANCE	hlibOLEAut32;

/* Destructor */

CBaseObject::~CBaseObject()
{
    /* Decrement the number of objects active */
    if (InterlockedDecrement(&m_cObjects) == 0) {
	if (hlibOLEAut32) {
	    FreeLibrary(hlibOLEAut32);

	    hlibOLEAut32 = 0;
	}
    };

    
#ifdef DEBUG
    DbgRegisterObjectDestruction(m_dwCookie);
#endif
}

static const TCHAR szOle32Aut[]   = TEXT("OleAut32.dll");

HINSTANCE LoadOLEAut32()
{
    if (hlibOLEAut32 == 0) {

	hlibOLEAut32 = LoadLibrary(szOle32Aut);
    }

    return hlibOLEAut32;
}


/* Constructor */

// We know we use "this" in the initialization list, we also know we don't modify *phr.
#pragma warning( disable : 4355 4100 )
CUnknown::CUnknown(const TCHAR *pName, LPUNKNOWN pUnk)
: CBaseObject(pName)
/* Start the object with a reference count of zero - when the      */
/* object is queried for it's first interface this may be          */
/* incremented depending on whether or not this object is          */
/* currently being aggregated upon                                 */
, m_cRef(0)
/* Set our pointer to our IUnknown interface.                      */
/* If we have an outer, use its, otherwise use ours.               */
/* This pointer effectivly points to the owner of                  */
/* this object and can be accessed by the GetOwner() method.       */
, m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<LPUNKNOWN>( static_cast<PNDUNKNOWN>(this) ) )
 /* Why the double cast?  Well, the inner cast is a type-safe cast */
 /* to pointer to a type from which we inherit.  The second is     */
 /* type-unsafe but works because INonDelegatingUnknown "behaves   */
 /* like" IUnknown. (Only the names on the methods change.)        */
{
    // Everything we need to do has been done in the initializer list
}

// This does the same as above except it has a useless HRESULT argument
// use the previous constructor, this is just left for compatibility...
CUnknown::CUnknown(TCHAR *pName, LPUNKNOWN pUnk,HRESULT *phr) :
    CBaseObject(pName),
    m_cRef(0),
    m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<LPUNKNOWN>( static_cast<PNDUNKNOWN>(this) ) )
{
}
#pragma warning( default : 4355 4100 )


/* QueryInterface */

STDMETHODIMP CUnknown::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    /* We know only about IUnknown */

    if (riid == IID_IUnknown) {
        GetInterface((LPUNKNOWN) (PNDUNKNOWN) this, ppv);
        return NOERROR;
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

/* We have to ensure that we DON'T use a max macro, since these will typically   */
/* lead to one of the parameters being evaluated twice.  Since we are worried    */
/* about concurrency, we can't afford to access the m_cRef twice since we can't  */
/* afford to run the risk that its value having changed between accesses.        */
#ifdef max
    #undef max
#endif

template<class T> inline static T max( const T & a, const T & b )
{
    return a > b ? a : b;
}

/* AddRef */

STDMETHODIMP_(ULONG) CUnknown::NonDelegatingAddRef()
{
    LONG lRef = InterlockedIncrement( &m_cRef );
    ASSERT(lRef > 0);
    DbgLog((LOG_MEMORY,3,TEXT("    Obj %d ref++ = %d"),
           m_dwCookie, m_cRef));
    return max(ULONG(m_cRef), 1ul);
}


/* Release */

STDMETHODIMP_(ULONG) CUnknown::NonDelegatingRelease()
{
    /* If the reference count drops to zero delete ourselves */

    LONG lRef = InterlockedDecrement( &m_cRef );
    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    Object %d ref-- = %d"),
	    m_dwCookie, m_cRef));
    if (lRef == 0) {

        // COM rules say we must protect against re-entrancy.
        // If we are an aggregator and we hold our own interfaces
        // on the aggregatee, the QI for these interfaces will
        // addref ourselves. So after doing the QI we must release
        // a ref count on ourselves. Then, before releasing the
        // private interface, we must addref ourselves. When we do
        // this from the destructor here it will result in the ref
        // count going to 1 and then back to 0 causing us to
        // re-enter the destructor. Hence we add an extra refcount here
        // once we know we will delete the object.
        // for an example aggregator see filgraph\distrib.cpp.

        m_cRef++;

        delete this;
        return ULONG(0);
    } else {
        return max(ULONG(m_cRef), 1ul);
    }
}


/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(LPUNKNOWN pUnk, void **ppv)
{
    CheckPointer(ppv, E_POINTER);
    *ppv = pUnk;
    pUnk->AddRef();
    return NOERROR;
}


/* Compares two interfaces and returns TRUE if they are on the same object */

BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond)
{
    /*  Different objects can't have the same interface pointer for
        any interface
    */
    if (pFirst == pSecond) {
        return TRUE;
    }
    /*  OK - do it the hard way - check if they have the same
        IUnknown pointers - a single object can only have one of these
    */
    LPUNKNOWN pUnknown1;     // Retrieve the IUnknown interface
    LPUNKNOWN pUnknown2;     // Retrieve the other IUnknown interface
    HRESULT hr;              // General OLE return code

    ASSERT(pFirst);
    ASSERT(pSecond);

    /* See if the IUnknown pointers match */

    hr = pFirst->QueryInterface(IID_IUnknown,(void **) &pUnknown1);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown1);

    hr = pSecond->QueryInterface(IID_IUnknown,(void **) &pUnknown2);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown2);

    /* Release the extra interfaces we hold */

    pUnknown1->Release();
    pUnknown2->Release();
    return (pUnknown1 == pUnknown2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\ctlutil.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base classes implementing IDispatch parsing for the basic control dual
// interfaces. Derive from these and implement just the custom method and
// property methods. We also implement CPosPassThru that can be used by
// renderers and transforms to pass by IMediaPosition and IMediaSeeking


#include <streams.h>
#include <limits.h>
#include "seekpt.h"

// 'bool' non standard reserved word
#pragma warning(disable:4237)


// --- CBaseDispatch implementation ----------
CBaseDispatch::~CBaseDispatch()
{
    if (m_pti) {
	m_pti->Release();
    }
}


// return 1 if we support GetTypeInfo

STDMETHODIMP
CBaseDispatch::GetTypeInfoCount(UINT * pctinfo)
{
    CheckPointer(pctinfo,E_POINTER);
    ValidateReadWritePtr(pctinfo,sizeof(UINT *));
    *pctinfo = 1;
    return S_OK;
}


typedef HRESULT (STDAPICALLTYPE *LPLOADTYPELIB)(
			    const OLECHAR FAR *szFile,
			    ITypeLib FAR* FAR* pptlib);

typedef HRESULT (STDAPICALLTYPE *LPLOADREGTYPELIB)(REFGUID rguid,
			    WORD wVerMajor,
			    WORD wVerMinor,
			    LCID lcid,
			    ITypeLib FAR* FAR* pptlib);

// attempt to find our type library

STDMETHODIMP
CBaseDispatch::GetTypeInfo(
  REFIID riid,
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    CheckPointer(pptinfo,E_POINTER);
    ValidateReadWritePtr(pptinfo,sizeof(ITypeInfo *));
    HRESULT hr;

    *pptinfo = NULL;

    // we only support one type element
    if (0 != itinfo) {
	return TYPE_E_ELEMENTNOTFOUND;
    }

    if (NULL == pptinfo) {
	return E_POINTER;
    }

    // always look for neutral
    if (NULL == m_pti) {

	LPLOADTYPELIB	    lpfnLoadTypeLib;
	LPLOADREGTYPELIB    lpfnLoadRegTypeLib;
	ITypeLib	    *ptlib;
	HINSTANCE	    hInst;

	static const char  szTypeLib[]	  = "LoadTypeLib";
	static const char  szRegTypeLib[] = "LoadRegTypeLib";
	static const WCHAR szControl[]	  = L"control.tlb";

	//
	// Try to get the Ole32Aut.dll module handle.
	//

	hInst = LoadOLEAut32();
	if (hInst == NULL) {
	    DWORD dwError = GetLastError();
	    return HRESULT_FROM_WIN32(dwError);
	}
	lpfnLoadRegTypeLib = (LPLOADREGTYPELIB)GetProcAddress(hInst,
							      szRegTypeLib);
	if (lpfnLoadRegTypeLib == NULL) {
	    DWORD dwError = GetLastError();
	    return HRESULT_FROM_WIN32(dwError);
	}

	hr = (*lpfnLoadRegTypeLib)(LIBID_QuartzTypeLib, 1, 0, // version 1.0
				   lcid, &ptlib);

	if (FAILED(hr)) {

	    // attempt to load directly - this will fill the
	    // registry in if it finds it

	    lpfnLoadTypeLib = (LPLOADTYPELIB)GetProcAddress(hInst, szTypeLib);
	    if (lpfnLoadTypeLib == NULL) {
		DWORD dwError = GetLastError();
		return HRESULT_FROM_WIN32(dwError);
	    }

	    hr = (*lpfnLoadTypeLib)(szControl, &ptlib);
	    if (FAILED(hr)) {
		return hr;
	    }
	}

	hr = ptlib->GetTypeInfoOfGuid(
		    riid,
		    &m_pti);

	ptlib->Release();

	if (FAILED(hr)) {
	    return hr;
	}
    }

    *pptinfo = m_pti;
    m_pti->AddRef();
    return S_OK;
}


STDMETHODIMP
CBaseDispatch::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    // although the IDispatch riid is dead, we use this to pass from
    // the interface implementation class to us the iid we are talking about.

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(riid, 0, lcid, &pti);

    if (SUCCEEDED(hr)) {
	hr = pti->GetIDsOfNames(rgszNames, cNames, rgdispid);

	pti->Release();
    }
    return hr;
}


// --- CMediaControl implementation ---------

CMediaControl::CMediaControl(const TCHAR * name,LPUNKNOWN pUnk) :
    CUnknown(name, pUnk)
{
}

// expose our interfaces IMediaControl and IUnknown

STDMETHODIMP
CMediaControl::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IMediaControl) {
	return GetInterface( (IMediaControl *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// return 1 if we support GetTypeInfo

STDMETHODIMP
CMediaControl::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


// attempt to find our type library

STDMETHODIMP
CMediaControl::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IMediaControl,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CMediaControl::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IMediaControl,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CMediaControl::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IMediaControl *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- CMediaEvent implementation ----------


CMediaEvent::CMediaEvent(const TCHAR * name,LPUNKNOWN pUnk) :
    CUnknown(name, pUnk)
{
}


// expose our interfaces IMediaEvent and IUnknown

STDMETHODIMP
CMediaEvent::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IMediaEvent || riid == IID_IMediaEventEx) {
	return GetInterface( (IMediaEventEx *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// return 1 if we support GetTypeInfo

STDMETHODIMP
CMediaEvent::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


// attempt to find our type library

STDMETHODIMP
CMediaEvent::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IMediaEvent,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CMediaEvent::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IMediaEvent,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CMediaEvent::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IMediaEvent *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- CMediaPosition implementation ----------


CMediaPosition::CMediaPosition(const TCHAR * name,LPUNKNOWN pUnk) :
    CUnknown(name, pUnk)
{
}

CMediaPosition::CMediaPosition(const TCHAR * name,
                               LPUNKNOWN pUnk,
                               HRESULT * phr) :
    CUnknown(name, pUnk)
{
    UNREFERENCED_PARAMETER(phr);
}


// expose our interfaces IMediaPosition and IUnknown

STDMETHODIMP
CMediaPosition::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IMediaPosition) {
	return GetInterface( (IMediaPosition *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// return 1 if we support GetTypeInfo

STDMETHODIMP
CMediaPosition::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


// attempt to find our type library

STDMETHODIMP
CMediaPosition::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IMediaPosition,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CMediaPosition::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IMediaPosition,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CMediaPosition::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IMediaPosition *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- IMediaPosition and IMediaSeeking pass through class ----------


CPosPassThru::CPosPassThru(const TCHAR *pName,
			   LPUNKNOWN pUnk,
			   HRESULT *phr,
			   IPin *pPin) :
    CMediaPosition(pName,pUnk),
    m_pPin(pPin)
{
    if (pPin == NULL) {
	*phr = E_POINTER;
	return;
    }
}


// Expose our IMediaSeeking and IMediaPosition interfaces

STDMETHODIMP
CPosPassThru::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    *ppv = NULL;

    if (riid == IID_IMediaSeeking) {
	return GetInterface( static_cast<IMediaSeeking *>(this), ppv);
    }
    return CMediaPosition::NonDelegatingQueryInterface(riid,ppv);
}


// Return the IMediaPosition interface from our peer

HRESULT
CPosPassThru::GetPeer(IMediaPosition ** ppMP)
{
    *ppMP = NULL;

    IPin *pConnected;
    HRESULT hr = m_pPin->ConnectedTo(&pConnected);
    if (FAILED(hr)) {
	return E_NOTIMPL;
    }
    IMediaPosition * pMP;
    hr = pConnected->QueryInterface(IID_IMediaPosition, (void **) &pMP);
    pConnected->Release();
    if (FAILED(hr)) {
	return E_NOTIMPL;
    }

    *ppMP = pMP;
    return S_OK;
}


// Return the IMediaSeeking interface from our peer

HRESULT
CPosPassThru::GetPeerSeeking(IMediaSeeking ** ppMS)
{
    *ppMS = NULL;

    IPin *pConnected;
    HRESULT hr = m_pPin->ConnectedTo(&pConnected);
    if (FAILED(hr)) {
	return E_NOTIMPL;
    }
    IMediaSeeking * pMS;
    hr = pConnected->QueryInterface(IID_IMediaSeeking, (void **) &pMS);
    pConnected->Release();
    if (FAILED(hr)) {
	return E_NOTIMPL;
    }

    *ppMS = pMS;
    return S_OK;
}


// --- IMediaSeeking methods ----------


STDMETHODIMP
CPosPassThru::GetCapabilities(DWORD * pCaps)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->GetCapabilities(pCaps);
    pMS->Release();
    return hr;
}

STDMETHODIMP
CPosPassThru::CheckCapabilities(DWORD * pCaps)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->CheckCapabilities(pCaps);
    pMS->Release();
    return hr;
}

STDMETHODIMP
CPosPassThru::IsFormatSupported(const GUID * pFormat)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->IsFormatSupported(pFormat);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::QueryPreferredFormat(GUID *pFormat)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->QueryPreferredFormat(pFormat);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::SetTimeFormat(const GUID * pFormat)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->SetTimeFormat(pFormat);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::GetTimeFormat(GUID *pFormat)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->GetTimeFormat(pFormat);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::IsUsingTimeFormat(const GUID * pFormat)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->IsUsingTimeFormat(pFormat);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
				LONGLONG    Source, const GUID * pSourceFormat )
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->ConvertTimeFormat(pTarget, pTargetFormat, Source, pSourceFormat );
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->SetPositions(pCurrent, CurrentFlags, pStop, StopFlags );
    pMS->Release();
    return hr;
}

STDMETHODIMP
CPosPassThru::GetPositions(LONGLONG *pCurrent, LONGLONG * pStop)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->GetPositions(pCurrent,pStop);
    pMS->Release();
    return hr;
}

HRESULT
CPosPassThru::GetSeekingLongLong
( HRESULT (__stdcall IMediaSeeking::*pMethod)( LONGLONG * )
, LONGLONG * pll
)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (SUCCEEDED(hr))
    {
	hr = (pMS->*pMethod)(pll);
	pMS->Release();
    }
    return hr;
}

// If we don't have a current position then ask upstream

STDMETHODIMP
CPosPassThru::GetCurrentPosition(LONGLONG *pCurrent)
{
    // Can we report the current position
    HRESULT hr = GetMediaTime(pCurrent,NULL);
    if (SUCCEEDED(hr)) hr = NOERROR;
    else hr = GetSeekingLongLong( &IMediaSeeking::GetCurrentPosition, pCurrent );
    return hr;
}


STDMETHODIMP
CPosPassThru::GetStopPosition(LONGLONG *pStop)
{
    return GetSeekingLongLong( &IMediaSeeking::GetStopPosition, pStop );;
}

STDMETHODIMP
CPosPassThru::GetDuration(LONGLONG *pDuration)
{
    return GetSeekingLongLong( &IMediaSeeking::GetDuration, pDuration );;
}


STDMETHODIMP
CPosPassThru::GetPreroll(LONGLONG *pllPreroll)
{
    return GetSeekingLongLong( &IMediaSeeking::GetPreroll, pllPreroll );;
}


STDMETHODIMP
CPosPassThru::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->GetAvailable( pEarliest, pLatest );
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::GetRate(double * pdRate)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMS->GetRate(pdRate);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::SetRate(double dRate)
{
    if (0.0 == dRate) {
		return E_INVALIDARG;
    }

    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMS->SetRate(dRate);
    pMS->Release();
    return hr;
}




// --- IMediaPosition methods ----------


STDMETHODIMP
CPosPassThru::get_Duration(REFTIME * plength)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMP->get_Duration(plength);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::get_CurrentPosition(REFTIME * pllTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->get_CurrentPosition(pllTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::put_CurrentPosition(REFTIME llTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->put_CurrentPosition(llTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::get_StopTime(REFTIME * pllTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->get_StopTime(pllTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::put_StopTime(REFTIME llTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->put_StopTime(llTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::get_PrerollTime(REFTIME * pllTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->get_PrerollTime(pllTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::put_PrerollTime(REFTIME llTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->put_PrerollTime(llTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::get_Rate(double * pdRate)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->get_Rate(pdRate);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::put_Rate(double dRate)
{
    if (0.0 == dRate) {
		return E_INVALIDARG;
    }

    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->put_Rate(dRate);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::CanSeekForward(LONG *pCanSeekForward)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->CanSeekForward(pCanSeekForward);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::CanSeekBackward(LONG *pCanSeekBackward)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->CanSeekBackward(pCanSeekBackward);
    pMP->Release();
    return hr;
}


// --- Implements the CRendererPosPassThru class ----------


// Media times (eg current frame, field, sample etc) are passed through the
// filtergraph in media samples. When a renderer gets a sample with media
// times in it, it will call one of the RegisterMediaTime methods we expose
// (one takes an IMediaSample, the other takes the media times direct). We
// store the media times internally and return them in GetCurrentPosition.

CRendererPosPassThru::CRendererPosPassThru(const TCHAR *pName,
					   LPUNKNOWN pUnk,
					   HRESULT *phr,
					   IPin *pPin) :
    CPosPassThru(pName,pUnk,phr,pPin),
    m_StartMedia(0),
    m_EndMedia(0),
    m_bReset(TRUE)
{
}


// Sets the media times the object should report

HRESULT
CRendererPosPassThru::RegisterMediaTime(IMediaSample *pMediaSample)
{
    ASSERT(pMediaSample);
    LONGLONG StartMedia;
    LONGLONG EndMedia;

    CAutoLock cAutoLock(&m_PositionLock);

    // Get the media times from the sample

    HRESULT hr = pMediaSample->GetTime(&StartMedia,&EndMedia);
    if (FAILED(hr))
    {
	ASSERT(hr == VFW_E_SAMPLE_TIME_NOT_SET);
	return hr;
    }

    m_StartMedia = StartMedia;
    m_EndMedia = EndMedia;
    m_bReset = FALSE;
    return NOERROR;
}


// Sets the media times the object should report

HRESULT
CRendererPosPassThru::RegisterMediaTime(LONGLONG StartTime,LONGLONG EndTime)
{
    CAutoLock cAutoLock(&m_PositionLock);
    m_StartMedia = StartTime;
    m_EndMedia = EndTime;
    m_bReset = FALSE;
    return NOERROR;
}


// Return the current media times registered in the object

HRESULT
CRendererPosPassThru::GetMediaTime(LONGLONG *pStartTime,LONGLONG *pEndTime)
{
    ASSERT(pStartTime);

    CAutoLock cAutoLock(&m_PositionLock);
    if (m_bReset == TRUE) {
	return E_FAIL;
    }

    // We don't have to return the end time

    HRESULT hr = ConvertTimeFormat( pStartTime, 0, m_StartMedia, &TIME_FORMAT_MEDIA_TIME );
    if (pEndTime && SUCCEEDED(hr)) {
	hr = ConvertTimeFormat( pEndTime, 0, m_EndMedia, &TIME_FORMAT_MEDIA_TIME );
    }
    return hr;
}


// Resets the media times we hold

HRESULT
CRendererPosPassThru::ResetMediaTime()
{
    CAutoLock cAutoLock(&m_PositionLock);
    m_StartMedia = 0;
    m_EndMedia = 0;
    m_bReset = TRUE;
    return NOERROR;
}

// Intended to be called by the owing filter during EOS processing so
// that the media times can be adjusted to the stop time.  This ensures
// that the GetCurrentPosition will actully get to the stop position.
HRESULT
CRendererPosPassThru::EOS()
{
    HRESULT hr;

    if ( m_bReset == TRUE ) hr = E_FAIL;
    else
    {
	LONGLONG llStop;
	if SUCCEEDED(hr=GetStopPosition(&llStop))
	{
	    CAutoLock cAutoLock(&m_PositionLock);
	    m_StartMedia =
	    m_EndMedia	 = llStop;
	}
    }
    return hr;
}

// -- CSourceSeeking implementation ------------

CSourceSeeking::CSourceSeeking(
    const TCHAR * pName,
    LPUNKNOWN pUnk,
    HRESULT* phr,
    CCritSec * pLock) :
        CUnknown(pName, pUnk),
        m_pLock(pLock),
        m_rtStart((long)0)
{
    m_rtStop = _I64_MAX / 2;
    m_rtDuration = m_rtStop;
    m_dRateSeeking = 1.0;

    m_dwSeekingCaps = AM_SEEKING_CanSeekForwards
        | AM_SEEKING_CanSeekBackwards
        | AM_SEEKING_CanSeekAbsolute
        | AM_SEEKING_CanGetStopPos
        | AM_SEEKING_CanGetDuration;
}

HRESULT CSourceSeeking::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if(riid == IID_IMediaSeeking) {
        CheckPointer(ppv, E_POINTER);
        return GetInterface(static_cast<IMediaSeeking *>(this), ppv);
    }
    else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}
    

HRESULT CSourceSeeking::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    // only seeking in time (REFERENCE_TIME units) is supported
    return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
}

HRESULT CSourceSeeking::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

HRESULT CSourceSeeking::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);

    // nothing to set; just check that it's TIME_FORMAT_TIME
    return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : E_INVALIDARG;
}

HRESULT CSourceSeeking::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
}

HRESULT CSourceSeeking::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

HRESULT CSourceSeeking::GetDuration(LONGLONG *pDuration)
{
    CheckPointer(pDuration, E_POINTER);
    CAutoLock lock(m_pLock);
    *pDuration = m_rtDuration;
    return S_OK;
}

HRESULT CSourceSeeking::GetStopPosition(LONGLONG *pStop)
{
    CheckPointer(pStop, E_POINTER);
    CAutoLock lock(m_pLock);
    *pStop = m_rtStop;
    return S_OK;
}

HRESULT CSourceSeeking::GetCurrentPosition(LONGLONG *pCurrent)
{
    // GetCurrentPosition is typically supported only in renderers and
    // not in source filters.
    return E_NOTIMPL;
}

HRESULT CSourceSeeking::GetCapabilities( DWORD * pCapabilities )
{
    CheckPointer(pCapabilities, E_POINTER);
    *pCapabilities = m_dwSeekingCaps;
    return S_OK;
}

HRESULT CSourceSeeking::CheckCapabilities( DWORD * pCapabilities )
{
    CheckPointer(pCapabilities, E_POINTER);

    // make sure all requested capabilities are in our mask
    return (~m_dwSeekingCaps & *pCapabilities) ? S_FALSE : S_OK;
}

HRESULT CSourceSeeking::ConvertTimeFormat( LONGLONG * pTarget, const GUID * pTargetFormat,
                           LONGLONG    Source, const GUID * pSourceFormat )
{
    CheckPointer(pTarget, E_POINTER);
    // format guids can be null to indicate current format

    // since we only support TIME_FORMAT_MEDIA_TIME, we don't really
    // offer any conversions.
    if(pTargetFormat == 0 || *pTargetFormat == TIME_FORMAT_MEDIA_TIME)
    {
        if(pSourceFormat == 0 || *pSourceFormat == TIME_FORMAT_MEDIA_TIME)
        {
            *pTarget = Source;
            return S_OK;
        }
    }
    
    return E_INVALIDARG;
}


HRESULT CSourceSeeking::SetPositions( LONGLONG * pCurrent,  DWORD CurrentFlags
                      , LONGLONG * pStop,  DWORD StopFlags )
{
    DWORD StopPosBits = StopFlags & AM_SEEKING_PositioningBitsMask;
    DWORD StartPosBits = CurrentFlags & AM_SEEKING_PositioningBitsMask;

    if(StopFlags) {
        CheckPointer(pStop, E_POINTER);

        // accept only relative, incremental, or absolute positioning
        if(StopPosBits != StopFlags) {
            return E_INVALIDARG;
        }
    }

    if(CurrentFlags) {
        CheckPointer(pCurrent, E_POINTER);
        if(StartPosBits != AM_SEEKING_AbsolutePositioning &&
           StartPosBits != AM_SEEKING_RelativePositioning) {
            return E_INVALIDARG;
        }
    }


    // scope for autolock
    {
        CAutoLock lock(m_pLock);

        // set start position
        if(StartPosBits == AM_SEEKING_AbsolutePositioning)
        {
            m_rtStart = *pCurrent;
        }
        else if(StartPosBits == AM_SEEKING_RelativePositioning)
        {
            m_rtStart += *pCurrent;
        }

        // set stop position
        if(StopPosBits == AM_SEEKING_AbsolutePositioning)
        {
            m_rtStop = *pStop;
        }
        else if(StopPosBits == AM_SEEKING_IncrementalPositioning)
        {
            m_rtStop = m_rtStart + *pStop;
        }
        else if(StopPosBits == AM_SEEKING_RelativePositioning)
        {
            m_rtStop = m_rtStop + *pStop;
        }
    }


    HRESULT hr = S_OK;
    if(SUCCEEDED(hr) && StopPosBits) {
        hr = ChangeStop();
    }
    if(StartPosBits) {
        hr = ChangeStart();
    }

    return hr;
}


HRESULT CSourceSeeking::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
    if(pCurrent) {
        *pCurrent = m_rtStart;
    }
    if(pStop) {
        *pStop = m_rtStop;
    }
    
    return S_OK;;
}


HRESULT CSourceSeeking::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
    if(pEarliest) {
        *pEarliest = 0;
    }
    if(pLatest) {
        CAutoLock lock(m_pLock);
        *pLatest = m_rtDuration;
    }
    return S_OK;
}

HRESULT CSourceSeeking::SetRate( double dRate)
{
    {
        CAutoLock lock(m_pLock);
        m_dRateSeeking = dRate;
    }
    return ChangeRate();
}

HRESULT CSourceSeeking::GetRate( double * pdRate)
{
    CheckPointer(pdRate, E_POINTER);
    CAutoLock lock(m_pLock);
    *pdRate = m_dRateSeeking;
    return S_OK;
}

HRESULT CSourceSeeking::GetPreroll(LONGLONG *pPreroll) 
{
    CheckPointer(pPreroll, E_POINTER);
    *pPreroll = 0;
    return S_OK;
}





// --- CSourcePosition implementation ----------


CSourcePosition::CSourcePosition(const TCHAR * pName,
				 LPUNKNOWN pUnk,
				 HRESULT* phr,
				 CCritSec * pLock) :
    CMediaPosition(pName, pUnk),
    m_pLock(pLock),
    m_Start(CRefTime((LONGLONG)0))
{
    m_Stop = _I64_MAX;
    m_Rate = 1.0;
}


STDMETHODIMP
CSourcePosition::get_Duration(REFTIME * plength)
{
    CheckPointer(plength,E_POINTER);
    ValidateReadWritePtr(plength,sizeof(REFTIME));
    CAutoLock lock(m_pLock);

    *plength = m_Duration;
    return S_OK;
}


STDMETHODIMP
CSourcePosition::put_CurrentPosition(REFTIME llTime)
{
    m_pLock->Lock();
    m_Start = llTime;
    m_pLock->Unlock();

    return ChangeStart();
}


STDMETHODIMP
CSourcePosition::get_StopTime(REFTIME * pllTime)
{
    CheckPointer(pllTime,E_POINTER);
    ValidateReadWritePtr(pllTime,sizeof(REFTIME));
    CAutoLock lock(m_pLock);

    *pllTime = m_Stop;
    return S_OK;
}


STDMETHODIMP
CSourcePosition::put_StopTime(REFTIME llTime)
{
    m_pLock->Lock();
    m_Stop = llTime;
    m_pLock->Unlock();

    return ChangeStop();
}


STDMETHODIMP
CSourcePosition::get_PrerollTime(REFTIME * pllTime)
{
    CheckPointer(pllTime,E_POINTER);
    ValidateReadWritePtr(pllTime,sizeof(REFTIME));
    return E_NOTIMPL;
}


STDMETHODIMP
CSourcePosition::put_PrerollTime(REFTIME llTime)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CSourcePosition::get_Rate(double * pdRate)
{
    CheckPointer(pdRate,E_POINTER);
    ValidateReadWritePtr(pdRate,sizeof(double));
    CAutoLock lock(m_pLock);

    *pdRate = m_Rate;
    return S_OK;
}


STDMETHODIMP
CSourcePosition::put_Rate(double dRate)
{
    m_pLock->Lock();
    m_Rate = dRate;
    m_pLock->Unlock();

    return ChangeRate();
}


// By default we can seek forwards

STDMETHODIMP
CSourcePosition::CanSeekForward(LONG *pCanSeekForward)
{
    CheckPointer(pCanSeekForward,E_POINTER);
    *pCanSeekForward = OATRUE;
    return S_OK;
}


// By default we can seek backwards

STDMETHODIMP
CSourcePosition::CanSeekBackward(LONG *pCanSeekBackward)
{
    CheckPointer(pCanSeekBackward,E_POINTER);
    *pCanSeekBackward = OATRUE;
    return S_OK;
}


// --- Implementation of CBasicAudio class ----------


CBasicAudio::CBasicAudio(const TCHAR * pName,LPUNKNOWN punk) :
    CUnknown(pName, punk)
{
}

// overriden to publicise our interfaces

STDMETHODIMP
CBasicAudio::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IBasicAudio) {
	return GetInterface( (IBasicAudio *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


STDMETHODIMP
CBasicAudio::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


STDMETHODIMP
CBasicAudio::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IBasicAudio,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CBasicAudio::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IBasicAudio,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CBasicAudio::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IBasicAudio *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- IVideoWindow implementation ----------

CBaseVideoWindow::CBaseVideoWindow(const TCHAR * pName,LPUNKNOWN punk) :
    CUnknown(pName, punk)
{
}


// overriden to publicise our interfaces

STDMETHODIMP
CBaseVideoWindow::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IVideoWindow) {
	return GetInterface( (IVideoWindow *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


STDMETHODIMP
CBaseVideoWindow::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


STDMETHODIMP
CBaseVideoWindow::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IVideoWindow,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CBaseVideoWindow::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IVideoWindow,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CBaseVideoWindow::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IVideoWindow *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- IBasicVideo implementation ----------


CBaseBasicVideo::CBaseBasicVideo(const TCHAR * pName,LPUNKNOWN punk) :
    CUnknown(pName, punk)
{
}


// overriden to publicise our interfaces

STDMETHODIMP
CBaseBasicVideo::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IBasicVideo || riid == IID_IBasicVideo2) {
	return GetInterface( static_cast<IBasicVideo2 *>(this), ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


STDMETHODIMP
CBaseBasicVideo::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


STDMETHODIMP
CBaseBasicVideo::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IBasicVideo,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CBaseBasicVideo::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IBasicVideo,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CBaseBasicVideo::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IBasicVideo *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- Implementation of Deferred Commands ----------


CDispParams::CDispParams(UINT nArgs, VARIANT* pArgs)
{
   cNamedArgs = 0;
   rgdispidNamedArgs = NULL;
   cArgs = nArgs;

    if (cArgs) {
	rgvarg = new VARIANT[cArgs];

	for (UINT i = 0; i < cArgs; i++) {

	    VARIANT * pDest = &rgvarg[i];
	    VARIANT * pSrc = &pArgs[i];

	    pDest->vt = pSrc->vt;
	    switch(pDest->vt) {

	    case VT_I4:
		pDest->lVal = pSrc->lVal;
		break;

	    case VT_UI1:
		pDest->bVal = pSrc->bVal;
		break;

	    case VT_I2:
		pDest->iVal = pSrc->iVal;
		break;

	    case VT_R4:
		pDest->fltVal = pSrc->fltVal;
		break;

	    case VT_R8:
		pDest->dblVal = pSrc->dblVal;
		break;

	    case VT_BOOL:
		pDest->boolVal = pSrc->boolVal;
		break;

	    case VT_ERROR:
		pDest->scode = pSrc->scode;
		break;

	    case VT_CY:
		pDest->cyVal = pSrc->cyVal;
		break;

	    case VT_DATE:
		pDest->date = pSrc->date;
		break;

	    case VT_BSTR:
		if (pSrc->bstrVal == NULL) {
		    pDest->bstrVal = NULL;
		} else {

		    // a BSTR is a WORD followed by a UNICODE string.
		    // the pointer points just after the WORD

		    WORD len = * (WORD*) (pSrc->bstrVal - (sizeof(WORD) / sizeof(OLECHAR)));
		    OLECHAR* pch = new OLECHAR[len + (sizeof(WORD)/sizeof(OLECHAR))];
		    WORD *pui = (WORD*)pch;
		    *pui = len;
		    pDest->bstrVal = pch + (sizeof(WORD)/sizeof(OLECHAR));
		    CopyMemory(pDest->bstrVal, pSrc->bstrVal, len*sizeof(OLECHAR));
		}
		pDest->bstrVal = pSrc->bstrVal;
		break;

	    case VT_UNKNOWN:
		pDest->punkVal = pSrc->punkVal;
		pDest->punkVal->AddRef();
		break;

	    case VT_DISPATCH:
		pDest->pdispVal = pSrc->pdispVal;
		pDest->pdispVal->AddRef();
		break;

	    default:
		// a type we haven't got round to adding yet!
		ASSERT(0);
		break;
	    }
	}

    } else {
	rgvarg = NULL;
    }

}


CDispParams::~CDispParams()
{
    for (UINT i = 0; i < cArgs; i++) {
	switch(rgvarg[i].vt) {
	case VT_BSTR:
	    if (rgvarg[i].bstrVal != NULL) {
		OLECHAR * pch = rgvarg[i].bstrVal - (sizeof(WORD)/sizeof(OLECHAR));
		delete pch;
	    }
	    break;

	case VT_UNKNOWN:
	    rgvarg[i].punkVal->Release();
	    break;

	case VT_DISPATCH:
	    rgvarg[i].pdispVal->Release();
	    break;
	}
    }
    delete[] rgvarg;
}


// lifetime is controlled by refcounts (see defer.h)

CDeferredCommand::CDeferredCommand(
    CCmdQueue * pQ,
    LPUNKNOWN	pUnk,
    HRESULT *	phr,
    LPUNKNOWN	pUnkExecutor,
    REFTIME	time,
    GUID*	iid,
    long	dispidMethod,
    short	wFlags,
    long	nArgs,
    VARIANT*	pDispParams,
    VARIANT*	pvarResult,
    short*	puArgErr,
    BOOL	bStream
    ) :
	CUnknown(NAME("DeferredCommand"), pUnk),
	m_pQueue(pQ),
	m_pUnk(pUnkExecutor),
	m_iid(iid),
	m_dispidMethod(dispidMethod),
	m_wFlags(wFlags),
	m_DispParams(nArgs, pDispParams),
	m_pvarResult(pvarResult),
	m_bStream(bStream),
	m_hrResult(E_ABORT)

{
    // convert REFTIME to REFERENCE_TIME
    COARefTime convertor(time);
    m_time = convertor;

    // no check of time validity - it's ok to queue a command that's
    // already late

    // check iid is supportable on pUnk by QueryInterface for it
    IUnknown * pInterface;
    HRESULT hr = m_pUnk->QueryInterface(GetIID(), (void**) &pInterface);
    if (FAILED(hr)) {
	*phr = hr;
	return;
    }
    pInterface->Release();


    // !!! check dispidMethod and param/return types using typelib
    ITypeInfo *pti;
    hr = m_Dispatch.GetTypeInfo(*iid, 0, 0, &pti);
    if (FAILED(hr)) {
	*phr = hr;
	return;
    }
    // !!! some sort of ITypeInfo validity check here
    pti->Release();


    // Fix up the dispid for put and get
    if (wFlags == DISPATCH_PROPERTYPUT) {
        m_DispParams.cNamedArgs = 1;
        m_DispId = DISPID_PROPERTYPUT;
        m_DispParams.rgdispidNamedArgs = &m_DispId;
    }

    // all checks ok - add to queue
    hr = pQ->Insert(this);
    if (FAILED(hr)) {
	*phr = hr;
    }
}


// refcounts are held by caller of InvokeAt... and by list. So if
// we get here, we can't be on the list

#if 0
CDeferredCommand::~CDeferredCommand()
{
    // this assert is invalid since if the queue is deleted while we are
    // still on the queue, we will have been removed by the queue and this
    // m_pQueue will not have been modified.
    // ASSERT(m_pQueue == NULL);

    // we don't hold a ref count on pUnk, which is the object that should
    // execute the command.
    // This is because there would otherwise be a circular refcount problem
    // since pUnk probably owns the CmdQueue object that has a refcount
    // on us.
    // The lifetime of pUnk is guaranteed by it being part of, or lifetime
    // controlled by, our parent object. As long as we are on the list, pUnk
    // must be valid. Once we are off the list, we do not use pUnk.

}
#endif


// overriden to publicise our interfaces

STDMETHODIMP
CDeferredCommand::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IDeferredCommand) {
	return GetInterface( (IDeferredCommand *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// remove from q. this will reduce the refcount by one (since the q
// holds a count) but can't make us go away since he must have a
// refcount in order to call this method.

STDMETHODIMP
CDeferredCommand::Cancel()
{
    if (m_pQueue == NULL) {
	return VFW_E_ALREADY_CANCELLED;
    }

    HRESULT hr = m_pQueue->Remove(this);
    if (FAILED(hr)) {
	return hr;
    }

    m_pQueue = NULL;
    return S_OK;
}


STDMETHODIMP
CDeferredCommand::Confidence(LONG* pConfidence)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CDeferredCommand::GetHResult(HRESULT * phrResult)
{
    CheckPointer(phrResult,E_POINTER);
    ValidateReadWritePtr(phrResult,sizeof(HRESULT));

    if (m_pQueue != NULL) {
	return E_ABORT;
    }
    *phrResult = m_hrResult;
    return S_OK;
}


// set the time to be a new time (checking that it is valid) and
// then requeue

STDMETHODIMP
CDeferredCommand::Postpone(REFTIME newtime)
{

    // check that this time is not past
    // convert REFTIME to REFERENCE_TIME
    COARefTime convertor(newtime);

    // check that the time has not passed
    if (m_pQueue->CheckTime(convertor, IsStreamTime())) {
	return VFW_E_TIME_ALREADY_PASSED;
    }

    // extract from list
    HRESULT hr = m_pQueue->Remove(this);
    if (FAILED(hr)) {
	return hr;
    }

    // change time
    m_time = convertor;

    // requeue
    hr = m_pQueue->Insert(this);

    return hr;
}


HRESULT
CDeferredCommand::Invoke()
{
    // check that we are still outstanding
    if (m_pQueue == NULL) {
	return VFW_E_ALREADY_CANCELLED;
    }

    // get the type info
    ITypeInfo* pti;
    HRESULT hr = m_Dispatch.GetTypeInfo(GetIID(), 0, 0, &pti);
    if (FAILED(hr)) {
	return hr;
    }

    // qi for the expected interface and then invoke it. Note that we have to
    // treat the returned interface as IUnknown since we don't know its type.
    IUnknown* pInterface;

    hr = m_pUnk->QueryInterface(GetIID(), (void**) &pInterface);
    if (FAILED(hr)) {
	pti->Release();
	return hr;
    }

    EXCEPINFO expinfo;
    UINT uArgErr;
    m_hrResult = pti->Invoke(
	pInterface,
	GetMethod(),
	GetFlags(),
	GetParams(),
	GetResult(),
	&expinfo,
	&uArgErr);

    // release the interface we QI'd for
    pInterface->Release();
    pti->Release();


    // remove from list whether or not successful
    // or we loop indefinitely
    hr = m_pQueue->Remove(this);
    m_pQueue = NULL;
    return hr;
}



// --- CCmdQueue methods ----------


CCmdQueue::CCmdQueue() :
    m_listPresentation(NAME("Presentation time command list")),
    m_listStream(NAME("Stream time command list")),
    m_evDue(TRUE),    // manual reset
    m_dwAdvise(0),
    m_pClock(NULL),
    m_bRunning(FALSE)
{
}


CCmdQueue::~CCmdQueue()
{
    // empty all our lists

    // we hold a refcount on each, so traverse and Release each
    // entry then RemoveAll to empty the list
    POSITION pos = m_listPresentation.GetHeadPosition();

    while(pos) {
	CDeferredCommand* pCmd = m_listPresentation.GetNext(pos);
	pCmd->Release();
    }
    m_listPresentation.RemoveAll();

    pos = m_listStream.GetHeadPosition();

    while(pos) {
	CDeferredCommand* pCmd = m_listStream.GetNext(pos);
	pCmd->Release();
    }
    m_listStream.RemoveAll();

    if (m_pClock) {
	if (m_dwAdvise) {
	    m_pClock->Unadvise(m_dwAdvise);
	    m_dwAdvise = 0;
	}
	m_pClock->Release();
    }
}


// returns a new CDeferredCommand object that will be initialised with
// the parameters and will be added to the queue during construction.
// returns S_OK if successfully created otherwise an error and
// no object has been queued.

HRESULT
CCmdQueue::New(
    CDeferredCommand **ppCmd,
    LPUNKNOWN	pUnk,		// this object will execute command
    REFTIME	time,
    GUID*	iid,
    long	dispidMethod,
    short	wFlags,
    long	cArgs,
    VARIANT*	pDispParams,
    VARIANT*	pvarResult,
    short*	puArgErr,
    BOOL	bStream
)
{
    CAutoLock lock(&m_Lock);

    HRESULT hr = S_OK;
    *ppCmd = NULL;

    CDeferredCommand* pCmd;
    pCmd = new CDeferredCommand(
		    this,
		    NULL,	    // not aggregated
		    &hr,
		    pUnk,	    // this guy will execute
		    time,
		    iid,
		    dispidMethod,
		    wFlags,
		    cArgs,
		    pDispParams,
		    pvarResult,
		    puArgErr,
		    bStream);

    if (pCmd == NULL) {
	hr = E_OUTOFMEMORY;
    } else {
	*ppCmd = pCmd;
    }
    return hr;
}


HRESULT
CCmdQueue::Insert(CDeferredCommand* pCmd)
{
    CAutoLock lock(&m_Lock);

    // addref the item
    pCmd->AddRef();

    CGenericList<CDeferredCommand> * pList;
    if (pCmd->IsStreamTime()) {
	pList = &m_listStream;
    } else {
	pList = &m_listPresentation;
    }
    POSITION pos = pList->GetHeadPosition();

    // seek past all items that are before us
    while (pos &&
	(pList->Get(pos)->GetTime() <= pCmd->GetTime())) {

	pList->GetNext(pos);
    }

    // now at end of list or in front of items that come later
    if (!pos) {
	pList->AddTail(pCmd);
    } else {
	pList->AddBefore(pos, pCmd);
    }

    SetTimeAdvise();
    return S_OK;
}


HRESULT
CCmdQueue::Remove(CDeferredCommand* pCmd)
{
    CAutoLock lock(&m_Lock);
    HRESULT hr = S_OK;

    CGenericList<CDeferredCommand> * pList;
    if (pCmd->IsStreamTime()) {
	pList = &m_listStream;
    } else {
	pList = &m_listPresentation;
    }
    POSITION pos = pList->GetHeadPosition();

    // traverse the list
    while (pos && (pList->Get(pos) != pCmd)) {
	pList->GetNext(pos);
    }

    // did we drop off the end?
    if (!pos) {
	hr = VFW_E_NOT_FOUND;
    } else {

	// found it - now take off list
	pList->Remove(pos);

	// Insert did an AddRef, so release it
	pCmd->Release();

	// check that timer request is still for earliest time
	SetTimeAdvise();
    }
    return hr;
}


// set the clock used for timing

HRESULT
CCmdQueue::SetSyncSource(IReferenceClock* pClock)
{
    CAutoLock lock(&m_Lock);

    // addref the new clock first in case they are the same
    if (pClock) {
	pClock->AddRef();
    }

    // kill any advise on the old clock
    if (m_pClock) {
	if (m_dwAdvise) {
	    m_pClock->Unadvise(m_dwAdvise);
	    m_dwAdvise = 0;
	}
	m_pClock->Release();
    }
    m_pClock = pClock;

    // set up a new advise
    SetTimeAdvise();
    return S_OK;
}


// set up a timer event with the reference clock

void
CCmdQueue::SetTimeAdvise(void)
{
    // make sure we have a clock to use
    if (!m_pClock) {
	return;
    }

    // reset the event whenever we are requesting a new signal
    m_evDue.Reset();

    // time 0 is earliest
    CRefTime current;

    // find the earliest presentation time
    if (m_listPresentation.GetCount() > 0) {

	POSITION pos = m_listPresentation.GetHeadPosition();
	current = m_listPresentation.Get(pos)->GetTime();
    }

    // if we're running, check the stream times too
    if (m_bRunning) {

	CRefTime t;

	if (m_listStream.GetCount() > 0) {

	    POSITION pos = m_listStream.GetHeadPosition();
	    t = m_listStream.Get(pos)->GetTime();

	    // add on stream time offset to get presentation time
	    t += m_StreamTimeOffset;

	    // is this earlier?
	    if ((current == TimeZero) || (t < current)) {
		current = t;
	    }
	}
    }

    // need to change?
    if ((current > TimeZero) && (current != m_tCurrentAdvise)) {
	if (m_dwAdvise) {
	    m_pClock->Unadvise(m_dwAdvise);
	    // reset the event whenever we are requesting a new signal
	    m_evDue.Reset();
	}

	// ask for time advice - the first two params are either
	// stream time offset and stream time or
	// presentation time and 0. we always use the latter
	HRESULT hr = m_pClock->AdviseTime(
		    (REFERENCE_TIME)current,
		    TimeZero,
		    (HEVENT) HANDLE(m_evDue),
		    &m_dwAdvise);

	ASSERT(SUCCEEDED(hr));
	m_tCurrentAdvise = current;
    }
}


// switch to run mode. Streamtime to Presentation time mapping known.

HRESULT
CCmdQueue::Run(REFERENCE_TIME tStreamTimeOffset)
{
    CAutoLock lock(&m_Lock);

    m_StreamTimeOffset = tStreamTimeOffset;
    m_bRunning = TRUE;

    // ensure advise is accurate
    SetTimeAdvise();
    return S_OK;
}


// switch to Stopped or Paused mode. Time mapping not known.

HRESULT
CCmdQueue::EndRun()
{
    CAutoLock lock(&m_Lock);

    m_bRunning = FALSE;

    // check timer setting - stream times
    SetTimeAdvise();
    return S_OK;
}


// return a pointer to the next due command. Blocks for msTimeout
// milliseconds until there is a due command.
// Stream-time commands will only become due between Run and Endrun calls.
// The command remains queued until invoked or cancelled.
// Returns E_ABORT if timeout occurs, otherwise S_OK (or other error).
//
// returns an AddRef'd object

HRESULT
CCmdQueue::GetDueCommand(CDeferredCommand ** ppCmd, long msTimeout)
{
    // loop until we timeout or find a due command
    for (;;) {

	{
	    CAutoLock lock(&m_Lock);


	    // find the earliest command
	    CDeferredCommand * pCmd = NULL;

	    // check the presentation time and the
	    // stream time list to find the earliest

	    if (m_listPresentation.GetCount() > 0) {
		POSITION pos = m_listPresentation.GetHeadPosition();
		pCmd = m_listPresentation.Get(pos);
	    }

	    if (m_bRunning && (m_listStream.GetCount() > 0)) {
		POSITION pos = m_listStream.GetHeadPosition();
		CDeferredCommand* pStrm = m_listStream.Get(pos);

		CRefTime t = pStrm->GetTime() + m_StreamTimeOffset;
		if (!pCmd || (t < pCmd->GetTime())) {
		    pCmd = pStrm;
		}
	    }

	    //	if we have found one, is it due?
	    if (pCmd) {
		if (CheckTime(pCmd->GetTime(), pCmd->IsStreamTime())) {

		    // yes it's due - addref it
		    pCmd->AddRef();
		    *ppCmd = pCmd;
		    return S_OK;
		}
	    }
	}

	// block until the advise is signalled
	if (WaitForSingleObject(m_evDue, msTimeout) != WAIT_OBJECT_0) {
	    return E_ABORT;
	}
    }
}


// return a pointer to a command that will be due for a given time.
// Pass in a stream time here. The stream time offset will be passed
// in via the Run method.
// Commands remain queued until invoked or cancelled.
// This method will not block. It will report E_ABORT if there are no
// commands due yet.
//
// returns an AddRef'd object

HRESULT
CCmdQueue::GetCommandDueFor(REFERENCE_TIME rtStream, CDeferredCommand**ppCmd)
{
    CAutoLock lock(&m_Lock);

    CRefTime tStream(rtStream);

    // find the earliest stream and presentation time commands
    CDeferredCommand* pStream = NULL;
    if (m_listStream.GetCount() > 0) {
	POSITION pos = m_listStream.GetHeadPosition();
	pStream = m_listStream.Get(pos);
    }
    CDeferredCommand* pPresent = NULL;
    if (m_listPresentation.GetCount() > 0) {
	POSITION pos = m_listPresentation.GetHeadPosition();
	pPresent = m_listPresentation.Get(pos);
    }

    // is there a presentation time that has passed already
    if (pPresent && CheckTime(pPresent->GetTime(), FALSE)) {
	pPresent->AddRef();
	*ppCmd = pPresent;
	return S_OK;
    }

    // is there a stream time command due before this stream time
    if (pStream && (pStream->GetTime() <= tStream)) {
	pPresent->AddRef();
	*ppCmd = pStream;
	return S_OK;
    }

    // if we are running, we can map presentation times to
    // stream time. In this case, is there a presentation time command
    // that will be due before this stream time is presented?
    if (m_bRunning && pPresent) {

	// this stream time will appear at...
	tStream += m_StreamTimeOffset;

	// due before that?
	if (pPresent->GetTime() <= tStream) {
	    *ppCmd = pPresent;
	    return S_OK;
	}
    }

    // no commands due yet
    return VFW_E_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\ctlutil.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base classes implementing IDispatch parsing for the basic control dual
// interfaces. Derive from these and implement just the custom method and
// property methods. We also implement CPosPassThru that can be used by
// renderers and transforms to pass by IMediaPosition and IMediaSeeking

#ifndef __CTLUTIL__
#define __CTLUTIL__

// OLE Automation has different ideas of TRUE and FALSE

#define OATRUE (-1)
#define OAFALSE (0)


// It's possible that we could replace this class with CreateStdDispatch

class CBaseDispatch
{
    ITypeInfo * m_pti;

public:

    CBaseDispatch() : m_pti(NULL) {}
    ~CBaseDispatch();

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      REFIID riid,
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);
};


class AM_NOVTABLE CMediaControl :
    public IMediaControl,
    public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CMediaControl(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


class AM_NOVTABLE CMediaEvent :
    public IMediaEventEx,
    public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CMediaEvent(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


class AM_NOVTABLE CMediaPosition :
    public IMediaPosition,
    public CUnknown
{
    CBaseDispatch m_basedisp;


public:

    CMediaPosition(const TCHAR *, LPUNKNOWN);
    CMediaPosition(const TCHAR *, LPUNKNOWN, HRESULT *phr);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);

};


// OA-compatibility means that we must use double as the RefTime value,
// and REFERENCE_TIME (essentially a LONGLONG) within filters.
// this class converts between the two

class COARefTime : public CRefTime {
public:

    COARefTime() {
    };

    COARefTime(CRefTime t)
        : CRefTime(t)
    {
    };

    COARefTime(REFERENCE_TIME t)
        : CRefTime(t)
    {
    };

    COARefTime(double d) {
        m_time = (LONGLONG) (d * 10000000);
    };

    operator double() {
        return double(m_time) / 10000000;
    };

    operator REFERENCE_TIME() {
        return m_time;
    };

    COARefTime& operator=(const double& rd)  {
        m_time = (LONGLONG) (rd * 10000000);
        return *this;
    }

    COARefTime& operator=(const REFERENCE_TIME& rt)  {
        m_time = rt;
        return *this;
    }

    inline BOOL operator==(const COARefTime& rt)
    {
        return m_time == rt.m_time;
    };

    inline BOOL operator!=(const COARefTime& rt)
    {
        return m_time != rt.m_time;
    };

    inline BOOL operator < (const COARefTime& rt)
    {
        return m_time < rt.m_time;
    };

    inline BOOL operator > (const COARefTime& rt)
    {
        return m_time > rt.m_time;
    };

    inline BOOL operator >= (const COARefTime& rt)
    {
        return m_time >= rt.m_time;
    };

    inline BOOL operator <= (const COARefTime& rt)
    {
        return m_time <= rt.m_time;
    };

    inline COARefTime operator+(const COARefTime& rt)
    {
        return COARefTime(m_time + rt.m_time);
    };

    inline COARefTime operator-(const COARefTime& rt)
    {
        return COARefTime(m_time - rt.m_time);
    };

    inline COARefTime operator*(LONG l)
    {
        return COARefTime(m_time * l);
    };

    inline COARefTime operator/(LONG l)
    {
        return COARefTime(m_time / l);
    };

private:
    //  Prevent bugs from constructing from LONG (which gets
    //  converted to double and then multiplied by 10000000
    COARefTime(LONG);
    operator=(LONG);
};


// A utility class that handles IMediaPosition and IMediaSeeking on behalf
// of single-input pin renderers, or transform filters.
//
// Renderers will expose this from the filter; transform filters will
// expose it from the output pin and not the renderer.
//
// Create one of these, giving it your IPin* for your input pin, and delegate
// all IMediaPosition methods to it. It will query the input pin for
// IMediaPosition and respond appropriately.
//
// Call ForceRefresh if the pin connection changes.
//
// This class no longer caches the upstream IMediaPosition or IMediaSeeking
// it acquires it on each method call. This means ForceRefresh is not needed.
// The method is kept for source compatibility and to minimise the changes
// if we need to put it back later for performance reasons.

class CPosPassThru : public IMediaSeeking, public CMediaPosition
{
    IPin *m_pPin;

    HRESULT GetPeer(IMediaPosition **ppMP);
    HRESULT GetPeerSeeking(IMediaSeeking **ppMS);

public:

    CPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *);
    DECLARE_IUNKNOWN

    HRESULT ForceRefresh() {
        return S_OK;
    };

    // override to return an accurate current position
    virtual HRESULT GetMediaTime(LONGLONG *pStartTime,LONGLONG *pEndTime) {
        return E_FAIL;
    }

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsFormatSupported( const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);
    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                                   LONGLONG    Source, const GUID * pSourceFormat );
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetDuration( LONGLONG *pDuration);
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll );

    // IMediaPosition properties
    STDMETHODIMP get_Duration(REFTIME * plength);
    STDMETHODIMP put_CurrentPosition(REFTIME llTime);
    STDMETHODIMP get_StopTime(REFTIME * pllTime);
    STDMETHODIMP put_StopTime(REFTIME llTime);
    STDMETHODIMP get_PrerollTime(REFTIME * pllTime);
    STDMETHODIMP put_PrerollTime(REFTIME llTime);
    STDMETHODIMP get_Rate(double * pdRate);
    STDMETHODIMP put_Rate(double dRate);
    STDMETHODIMP get_CurrentPosition(REFTIME * pllTime);
    STDMETHODIMP CanSeekForward(LONG *pCanSeekForward);
    STDMETHODIMP CanSeekBackward(LONG *pCanSeekBackward);

private:
    HRESULT GetSeekingLongLong( HRESULT (__stdcall IMediaSeeking::*pMethod)( LONGLONG * ),
                                LONGLONG * pll );
};


// Adds the ability to return a current position

class CRendererPosPassThru : public CPosPassThru
{
    CCritSec m_PositionLock;    // Locks access to our position
    LONGLONG m_StartMedia;      // Start media time last seen
    LONGLONG m_EndMedia;        // And likewise the end media
    BOOL m_bReset;              // Have media times been set

public:

    // Used to help with passing media times through graph

    CRendererPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *);
    HRESULT RegisterMediaTime(IMediaSample *pMediaSample);
    HRESULT RegisterMediaTime(LONGLONG StartTime,LONGLONG EndTime);
    HRESULT GetMediaTime(LONGLONG *pStartTime,LONGLONG *pEndTime);
    HRESULT ResetMediaTime();
    HRESULT EOS();
};

STDAPI CreatePosPassThru(
    LPUNKNOWN pAgg,
    BOOL bRenderer,
    IPin *pPin,
    IUnknown **ppPassThru
);

// A class that handles the IDispatch part of IBasicAudio and leaves the
// properties and methods themselves pure virtual.

class AM_NOVTABLE CBasicAudio : public IBasicAudio, public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CBasicAudio(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


// A class that handles the IDispatch part of IBasicVideo and leaves the
// properties and methods themselves pure virtual.

class AM_NOVTABLE CBaseBasicVideo : public IBasicVideo2, public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CBaseBasicVideo(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);

    STDMETHODIMP GetPreferredAspectRatio(
      long *plAspectX,
      long *plAspectY)
    {
        return E_NOTIMPL;
    }
};


// A class that handles the IDispatch part of IVideoWindow and leaves the
// properties and methods themselves pure virtual.

class AM_NOVTABLE CBaseVideoWindow : public IVideoWindow, public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CBaseVideoWindow(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


// abstract class to help source filters with their implementation
// of IMediaPosition. Derive from this and set the duration (and stop
// position). Also override NotifyChange to do something when the properties
// change.

class AM_NOVTABLE CSourcePosition : public CMediaPosition
{

public:
    CSourcePosition(const TCHAR *, LPUNKNOWN, HRESULT*, CCritSec *);

    // IMediaPosition methods
    STDMETHODIMP get_Duration(REFTIME * plength);
    STDMETHODIMP put_CurrentPosition(REFTIME llTime);
    STDMETHODIMP get_StopTime(REFTIME * pllTime);
    STDMETHODIMP put_StopTime(REFTIME llTime);
    STDMETHODIMP get_PrerollTime(REFTIME * pllTime);
    STDMETHODIMP put_PrerollTime(REFTIME llTime);
    STDMETHODIMP get_Rate(double * pdRate);
    STDMETHODIMP put_Rate(double dRate);
    STDMETHODIMP CanSeekForward(LONG *pCanSeekForward);
    STDMETHODIMP CanSeekBackward(LONG *pCanSeekBackward);

    // override if you can return the data you are actually working on
    STDMETHODIMP get_CurrentPosition(REFTIME * pllTime) {
        return E_NOTIMPL;
    };

protected:

    // we call this to notify changes. Override to handle them
    virtual HRESULT ChangeStart() PURE;
    virtual HRESULT ChangeStop() PURE;
    virtual HRESULT ChangeRate() PURE;

    COARefTime m_Duration;
    COARefTime m_Start;
    COARefTime m_Stop;
    double m_Rate;

    CCritSec * m_pLock;
};

class AM_NOVTABLE CSourceSeeking :
    public IMediaSeeking,
    public CUnknown
{

public:

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    
    // IMediaSeeking methods

    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP ConvertTimeFormat( LONGLONG * pTarget, const GUID * pTargetFormat,
                                    LONGLONG    Source, const GUID * pSourceFormat );

    STDMETHODIMP SetPositions( LONGLONG * pCurrent,  DWORD CurrentFlags
			     , LONGLONG * pStop,  DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );

    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

    
protected:

    // ctor
    CSourceSeeking(const TCHAR *, LPUNKNOWN, HRESULT*, CCritSec *);
    
    // we call this to notify changes. Override to handle them
    virtual HRESULT ChangeStart() PURE;
    virtual HRESULT ChangeStop() PURE;
    virtual HRESULT ChangeRate() PURE;

    CRefTime m_rtDuration;      // length of stream
    CRefTime m_rtStart;         // source will start here
    CRefTime m_rtStop;          // source will stop here
    double m_dRateSeeking;

    // seeking capabilities 
    DWORD m_dwSeekingCaps;

    CCritSec * m_pLock;
};


// Base classes supporting Deferred commands.

// Deferred commands are queued by calls to methods on the IQueueCommand
// interface, exposed by the filtergraph and by some filters. A successful
// call to one of these methods will return an IDeferredCommand interface
// representing the queued command.
//
// A CDeferredCommand object represents a single deferred command, and exposes
// the IDeferredCommand interface as well as other methods permitting time
// checks and actual execution. It contains a reference to the CCommandQueue
// object on which it is queued.
//
// CCommandQueue is a base class providing a queue of CDeferredCommand
// objects, and methods to add, remove, check status and invoke the queued
// commands. A CCommandQueue object would be part of an object that
// implemented IQueueCommand.

class CCmdQueue;

// take a copy of the params and store them. Release any allocated
// memory in destructor

class CDispParams : public DISPPARAMS
{
public:
    CDispParams(UINT nArgs, VARIANT* pArgs);
    ~CDispParams();
};


// CDeferredCommand lifetime is controlled by refcounts. Caller of
// InvokeAt.. gets a refcounted interface pointer, and the CCmdQueue
// object also holds a refcount on us. Calling Cancel or Invoke takes
// us off the CCmdQueue and thus reduces the refcount by 1. Once taken
// off the queue we cannot be put back on the queue.

class CDeferredCommand
    : public CUnknown,
      public IDeferredCommand
{
public:

    CDeferredCommand(
        CCmdQueue * pQ,
        LPUNKNOWN   pUnk,               // aggregation outer unk
        HRESULT *   phr,
        LPUNKNOWN   pUnkExecutor,       // object that will execute this cmd
        REFTIME     time,
        GUID*       iid,
        long        dispidMethod,
        short       wFlags,
        long        cArgs,
        VARIANT*    pDispParams,
        VARIANT*    pvarResult,
        short*      puArgErr,
        BOOL        bStream
        );

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IDeferredCommand methods
    STDMETHODIMP Cancel();
    STDMETHODIMP Confidence(
                    LONG* pConfidence);
    STDMETHODIMP Postpone(
                    REFTIME newtime);
    STDMETHODIMP GetHResult(
                    HRESULT* phrResult);

    // other public methods

    HRESULT Invoke();

    // access methods

    // returns TRUE if streamtime, FALSE if presentation time
    BOOL IsStreamTime() {
       return m_bStream;
    };

    CRefTime GetTime() {
        return m_time;
    };

    REFIID GetIID() {
        return *m_iid;
    };

    long GetMethod() {
        return m_dispidMethod;
    };

    short GetFlags() {
        return m_wFlags;
    };

    DISPPARAMS* GetParams() {
        return &m_DispParams;
    };

    VARIANT* GetResult() {
        return m_pvarResult;
    };

protected:

    CCmdQueue* m_pQueue;

    // pUnk for the interface that we will execute the command on
    LPUNKNOWN   m_pUnk;

    // stored command data
    REFERENCE_TIME     m_time;
    GUID*       m_iid;
    long        m_dispidMethod;
    short       m_wFlags;
    VARIANT*    m_pvarResult;
    BOOL        m_bStream;
    CDispParams m_DispParams;
    DISPID      m_DispId;         //  For get and put

    // we use this for ITypeInfo access
    CBaseDispatch   m_Dispatch;

    // save retval here
    HRESULT     m_hrResult;
};


// a list of CDeferredCommand objects. this is a base class providing
// the basics of access to the list. If you want to use CDeferredCommand
// objects then your queue needs to be derived from this class.

class AM_NOVTABLE CCmdQueue
{
public:
    CCmdQueue();
    virtual ~CCmdQueue();

    // returns a new CDeferredCommand object that will be initialised with
    // the parameters and will be added to the queue during construction.
    // returns S_OK if successfully created otherwise an error and
    // no object has been queued.
    virtual HRESULT  New(
        CDeferredCommand **ppCmd,
        LPUNKNOWN   pUnk,
        REFTIME     time,
        GUID*       iid,
        long        dispidMethod,
        short       wFlags,
        long        cArgs,
        VARIANT*    pDispParams,
        VARIANT*    pvarResult,
        short*      puArgErr,
        BOOL        bStream
    );

    // called by the CDeferredCommand object to add and remove itself
    // from the queue
    virtual HRESULT Insert(CDeferredCommand* pCmd);
    virtual HRESULT Remove(CDeferredCommand* pCmd);

    // Command-Due Checking
    //
    // There are two schemes of synchronisation: coarse and accurate. In
    // coarse mode, you wait till the time arrives and then execute the cmd.
    // In accurate mode, you wait until you are processing the sample that
    // will appear at the time, and then execute the command. It's up to the
    // filter which one it will implement. The filtergraph will always
    // implement coarse mode for commands queued at the filtergraph.
    //
    // If you want coarse sync, you probably want to wait until there is a
    // command due, and then execute it. You can do this by calling
    // GetDueCommand. If you have several things to wait for, get the
    // event handle from GetDueHandle() and when this is signalled then call
    // GetDueCommand. Stream time will only advance between calls to Run and
    // EndRun. Note that to avoid an extra thread there is no guarantee that
    // if the handle is set there will be a command ready. Each time the
    // event is signalled, call GetDueCommand (probably with a 0 timeout);
    // This may return E_ABORT.
    //
    // If you want accurate sync, you must call GetCommandDueFor, passing
    // as a parameter the stream time of the samples you are about to process.
    // This will return:
    //   -- a stream-time command due at or before that stream time
    //   -- a presentation-time command due at or before the
    //      time that stream time will be presented (only between Run
    //      and EndRun calls, since outside of this, the mapping from
    //      stream time to presentation time is not known.
    //   -- any presentation-time command due now.
    // This means that if you want accurate synchronisation on samples that
    // might be processed during Paused mode, you need to use
    // stream-time commands.
    //
    // In all cases, commands remain queued until Invoked or Cancelled. The
    // setting and resetting of the event handle is managed entirely by this
    // queue object.

    // set the clock used for timing
    virtual HRESULT SetSyncSource(IReferenceClock*);

    // switch to run mode. Streamtime to Presentation time mapping known.
    virtual HRESULT Run(REFERENCE_TIME tStreamTimeOffset);

    // switch to Stopped or Paused mode. Time mapping not known.
    virtual HRESULT EndRun();

    // return a pointer to the next due command. Blocks for msTimeout
    // milliseconds until there is a due command.
    // Stream-time commands will only become due between Run and Endrun calls.
    // The command remains queued until invoked or cancelled.
    // Returns E_ABORT if timeout occurs, otherwise S_OK (or other error).
    // Returns an AddRef-ed object
    virtual HRESULT GetDueCommand(CDeferredCommand ** ppCmd, long msTimeout);

    // return the event handle that will be signalled whenever
    // there are deferred commands due for execution (when GetDueCommand
    // will not block).
    HANDLE GetDueHandle() {
        return HANDLE(m_evDue);
    };

    // return a pointer to a command that will be due for a given time.
    // Pass in a stream time here. The stream time offset will be passed
    // in via the Run method.
    // Commands remain queued until invoked or cancelled.
    // This method will not block. It will report VFW_E_NOT_FOUND if there
    // are no commands due yet.
    // Returns an AddRef-ed object
    virtual HRESULT GetCommandDueFor(REFERENCE_TIME tStream, CDeferredCommand**ppCmd);

    // check if a given time is due (TRUE if it is due yet)
    BOOL CheckTime(CRefTime time, BOOL bStream) {

        // if no clock, nothing is due!
        if (!m_pClock) {
            return FALSE;
        }

        // stream time
        if (bStream) {

            // not valid if not running
            if (!m_bRunning) {
                return FALSE;
            }
            // add on known stream time offset to get presentation time
            time += m_StreamTimeOffset;
        }

        CRefTime Now;
        m_pClock->GetTime((REFERENCE_TIME*)&Now);
        return (time <= Now);
    };

protected:

    // protect access to lists etc
    CCritSec m_Lock;

    // commands queued in presentation time are stored here
    CGenericList<CDeferredCommand> m_listPresentation;

    // commands queued in stream time are stored here
    CGenericList<CDeferredCommand> m_listStream;

    // set when any commands are due
    CAMEvent m_evDue;

    // creates an advise for the earliest time required, if any
    void SetTimeAdvise(void);

    // advise id from reference clock (0 if no outstanding advise)
    DWORD_PTR m_dwAdvise;

    // advise time is for this presentation time
    CRefTime m_tCurrentAdvise;

    // the reference clock we are using (addrefed)
    IReferenceClock* m_pClock;

    // true when running
    BOOL m_bRunning;

    // contains stream time offset when m_bRunning is true
    CRefTime m_StreamTimeOffset;
};

#endif // __CTLUTIL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\dllentry.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// classes used to support dll entrypoints for COM objects.
//
#include <streams.h>

#ifdef DEBUG
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif // _UNICODE
#endif // UNICODE

#include <tchar.h>
#endif // DEBUG

extern CFactoryTemplate g_Templates[];
extern int g_cTemplates;

HINSTANCE g_hInst;
DWORD	  g_amPlatform;		// VER_PLATFORM_WIN32_WINDOWS etc... (from GetVersionEx)
OSVERSIONINFO g_osInfo;

//
// an instance of this is created by the DLLGetClassObject entrypoint
// it uses the CFactoryTemplate object it is given to support the
// IClassFactory interface

class CClassFactory : public IClassFactory, public CBaseObject
{

private:
    const CFactoryTemplate *const m_pTemplate;

    ULONG m_cRef;

    static int m_cLocked;
public:
    CClassFactory(const CFactoryTemplate *);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)AddRef();
    STDMETHODIMP_(ULONG)Release();

    // IClassFactory
    STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void **pv);
    STDMETHODIMP LockServer(BOOL fLock);

    // allow DLLGetClassObject to know about global server lock status
    static BOOL IsLocked() {
        return (m_cLocked > 0);
    };
};

// process-wide dll locked state
int CClassFactory::m_cLocked = 0;

CClassFactory::CClassFactory(const CFactoryTemplate *pTemplate)
: CBaseObject(NAME("Class Factory"))
, m_cRef(0)
, m_pTemplate(pTemplate)
{
}


STDMETHODIMP
CClassFactory::QueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER)
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    *ppv = NULL;

    // any interface on this object is the object pointer.
    if ((riid == IID_IUnknown) || (riid == IID_IClassFactory)) {
        *ppv = (LPVOID) this;
	// AddRef returned interface pointer
        ((LPUNKNOWN) *ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG)
CClassFactory::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CClassFactory::Release()
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    } else {
        return m_cRef;
    }
}

STDMETHODIMP
CClassFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    void **pv)
{
    CheckPointer(pv,E_POINTER)
    ValidateReadWritePtr(pv,sizeof(void *));

    /* Enforce the normal OLE rules regarding interfaces and delegation */

    if (pUnkOuter != NULL) {
        if (IsEqualIID(riid,IID_IUnknown) == FALSE) {
            return ResultFromScode(E_NOINTERFACE);
        }
    }

    /* Create the new object through the derived class's create function */

    HRESULT hr = NOERROR;
    CUnknown *pObj = m_pTemplate->CreateInstance(pUnkOuter, &hr);

    if (pObj == NULL) {
	if (SUCCEEDED(hr)) {
	    hr = E_OUTOFMEMORY;
	}
	return hr;
    }

    /* Delete the object if we got a construction error */

    if (FAILED(hr)) {
        delete pObj;
        return hr;
    }

    /* Get a reference counted interface on the object */

    /* We wrap the non-delegating QI with NDAddRef & NDRelease. */
    /* This protects any outer object from being prematurely    */
    /* released by an inner object that may have to be created  */
    /* in order to supply the requested interface.              */
    pObj->NonDelegatingAddRef();
    hr = pObj->NonDelegatingQueryInterface(riid, pv);
    pObj->NonDelegatingRelease();
    /* Note that if NonDelegatingQueryInterface fails, it will  */
    /* not increment the ref count, so the NonDelegatingRelease */
    /* will drop the ref back to zero and the object will "self-*/
    /* destruct".  Hence we don't need additional tidy-up code  */
    /* to cope with NonDelegatingQueryInterface failing.        */

    if (SUCCEEDED(hr)) {
        ASSERT(*pv);
    }

    return hr;
}

STDMETHODIMP
CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        m_cLocked++;
    } else {
        m_cLocked--;
    }
    return NOERROR;
}


// --- COM entrypoints -----------------------------------------

//called by COM to get the class factory object for a given class
STDAPI
DllGetClassObject(
    REFCLSID rClsID,
    REFIID riid,
    void **pv)
{
    if (!(riid == IID_IUnknown) && !(riid == IID_IClassFactory)) {
            return E_NOINTERFACE;
    }

    // traverse the array of templates looking for one with this
    // class id
    for (int i = 0; i < g_cTemplates; i++) {
        const CFactoryTemplate * pT = &g_Templates[i];
        if (pT->IsClassID(rClsID)) {

            // found a template - make a class factory based on this
            // template

            *pv = (LPVOID) (LPUNKNOWN) new CClassFactory(pT);
            if (*pv == NULL) {
                return E_OUTOFMEMORY;
            }
            ((LPUNKNOWN)*pv)->AddRef();
            return NOERROR;
        }
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}

//
//  Call any initialization routines
//
void
DllInitClasses(BOOL bLoading)
{
    int i;

    // traverse the array of templates calling the init routine
    // if they have one
    for (i = 0; i < g_cTemplates; i++) {
        const CFactoryTemplate * pT = &g_Templates[i];
        if (pT->m_lpfnInit != NULL) {
            (*pT->m_lpfnInit)(bLoading, pT->m_ClsID);
        }
    }

}

// called by COM to determine if this dll can be unloaded
// return ok unless there are outstanding objects or a lock requested
// by IClassFactory::LockServer
//
// CClassFactory has a static function that can tell us about the locks,
// and CCOMObject has a static function that can tell us about the active
// object count
STDAPI
DllCanUnloadNow()
{
    DbgLog((LOG_MEMORY,2,TEXT("DLLCanUnloadNow called - IsLocked = %d, Active objects = %d"),
        CClassFactory::IsLocked(),
        CBaseObject::ObjectsActive()));

    if (CClassFactory::IsLocked() || CBaseObject::ObjectsActive()) {
	return S_FALSE;
    } else {
        return S_OK;
    }
}


// --- standard WIN32 entrypoints --------------------------------------


extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);

BOOL WINAPI
DllEntryPoint(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
{
#ifdef DEBUG
    extern bool g_fDbgInDllEntryPoint;
    g_fDbgInDllEntryPoint = true;
#endif

    switch (ulReason)
    {

    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstance);
        DbgInitialise(hInstance);
	{
	    // The platform identifier is used to work out whether
	    // full unicode support is available or not.  Hence the
	    // default will be the lowest common denominator - i.e. N/A
            g_amPlatform = VER_PLATFORM_WIN32_WINDOWS; // win95 assumed in case GetVersionEx fails

            g_osInfo.dwOSVersionInfoSize = sizeof(g_osInfo);
            if (GetVersionEx(&g_osInfo)) {
        	g_amPlatform = g_osInfo.dwPlatformId;
	    } else {
		DbgLog((LOG_ERROR, 1, TEXT("Failed to get the OS platform, assuming Win95")));
	    }
	}
        g_hInst = hInstance;
        DllInitClasses(TRUE);
        break;

    case DLL_PROCESS_DETACH:
        DllInitClasses(FALSE);

#ifdef DEBUG
        if (CBaseObject::ObjectsActive()) {
            DbgSetModuleLevel(LOG_MEMORY, 2);
            TCHAR szInfo[512];
            extern TCHAR m_ModuleName[];     // Cut down module name

            TCHAR FullName[_MAX_PATH];      // Load the full path and module name
            TCHAR *pName;                   // Searches from the end for a backslash

            GetModuleFileName(NULL,FullName,_MAX_PATH);
            pName = _tcsrchr(FullName,'\\');
            if (pName == NULL) {
                pName = FullName;
            } else {
                pName++;
            }

	    DWORD cch = wsprintf(szInfo, TEXT("Executable: %s  Pid %x  Tid %x. "),
			    pName, GetCurrentProcessId(), GetCurrentThreadId());

            wsprintf(szInfo+cch, TEXT("Module %s, %d objects left active!"),
                     m_ModuleName, CBaseObject::ObjectsActive());
            DbgAssert(szInfo, TEXT(__FILE__),__LINE__);

	    // If running remotely wait for the Assert to be acknowledged
	    // before dumping out the object register
            DbgDumpObjectRegister();
        }
        DbgTerminate();
#endif
        break;
    }

#ifdef DEBUG
    g_fDbgInDllEntryPoint = false;
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\combase.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

/*

a. Derive your COM object from CUnknown

b. Make a static CreateInstance function that takes an LPUNKNOWN, an HRESULT *
   and a TCHAR *. The LPUNKNOWN defines the object to delegate IUnknown calls
   to. The HRESULT * allows error codes to be passed around constructors and
   the TCHAR * is a descriptive name that can be printed on the debugger.

   It is important that constructors only change the HRESULT * if they have
   to set an ERROR code, if it was successful then leave it alone or you may
   overwrite an error code from an object previously created.

   When you call a constructor the descriptive name should be in static store
   as we do not copy the string. To stop large amounts of memory being used
   in retail builds by all these static strings use the NAME macro,

   CMyFilter = new CImplFilter(NAME("My filter"),pUnknown,phr);
   if (FAILED(hr)) {
       return hr;
   }

   In retail builds NAME(_x_) compiles to NULL, the base CBaseObject class
   knows not to do anything with objects that don't have a name.

c. Have a constructor for your object that passes the LPUNKNOWN, HRESULT * and
   TCHAR * to the CUnknown constructor. You can set the HRESULT if you have an
   error, or just simply pass it through to the constructor.

   The object creation will fail in the class factory if the HRESULT indicates
   an error (ie FAILED(HRESULT) == TRUE)

d. Create a FactoryTemplate with your object's class id and CreateInstance
   function.

Then (for each interface) either

Multiple inheritance

1. Also derive it from ISomeInterface
2. Include DECLARE_IUNKNOWN in your class definition to declare
   implementations of QueryInterface, AddRef and Release that
   call the outer unknown
3. Override NonDelegatingQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CUnknown::NonDelegatingQueryInterface(riid, ppv);
     }

4. Declare and implement the member functions of ISomeInterface.

or: Nested interfaces

1. Declare a class derived from CUnknown
2. Include DECLARE_IUNKNOWN in your class definition
3. Override NonDelegatingQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CUnknown::NonDelegatingQueryInterface(riid, ppv);
     }

4. Implement the member functions of ISomeInterface. Use GetOwner() to
   access the COM object class.

And in your COM object class:

5. Make the nested class a friend of the COM object class, and declare
   an instance of the nested class as a member of the COM object class.

   NOTE that because you must always pass the outer unknown and an hResult
   to the CUnknown constructor you cannot use a default constructor, in
   other words you will have to make the member variable a pointer to the
   class and make a NEW call in your constructor to actually create it.

6. override the NonDelegatingQueryInterface with code like this:

     if (riid == IID_ISomeInterface) {
         return m_pImplFilter->
            NonDelegatingQueryInterface(IID_ISomeInterface, ppv);
     } else {
         return CUnknown::NonDelegatingQueryInterface(riid, ppv);
     }

You can have mixed classes which support some interfaces via multiple
inheritance and some via nested classes

*/

#ifndef __COMBASE__
#define __COMBASE__

// Filter Setup data structures no defined in axextend.idl

typedef REGPINTYPES
AMOVIESETUP_MEDIATYPE, * PAMOVIESETUP_MEDIATYPE, * FAR LPAMOVIESETUP_MEDIATYPE;

typedef REGFILTERPINS
AMOVIESETUP_PIN, * PAMOVIESETUP_PIN, * FAR LPAMOVIESETUP_PIN;

typedef struct _AMOVIESETUP_FILTER
{
  const CLSID * clsID;
  const WCHAR * strName;
  DWORD      dwMerit;
  UINT       nPins;
  const AMOVIESETUP_PIN * lpPin;
}
AMOVIESETUP_FILTER, * PAMOVIESETUP_FILTER, * FAR LPAMOVIESETUP_FILTER;

/* The DLLENTRY module initialises the module handle on loading */

extern HINSTANCE g_hInst;

/* On DLL load remember which platform we are running on */

extern DWORD g_amPlatform;
extern OSVERSIONINFO g_osInfo;     // Filled in by GetVersionEx

/* Version of IUnknown that is renamed to allow a class to support both
   non delegating and delegating IUnknowns in the same COM object */

#ifndef INONDELEGATINGUNKNOWN_DEFINED
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG, NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG, NonDelegatingRelease)(THIS) PURE;
};
#define INONDELEGATINGUNKNOWN_DEFINED
#endif

typedef INonDelegatingUnknown *PNDUNKNOWN;


/* This is the base object class that supports active object counting. As
   part of the debug facilities we trace every time a C++ object is created
   or destroyed. The name of the object has to be passed up through the class
   derivation list during construction as you cannot call virtual functions
   in the constructor. The downside of all this is that every single object
   constructor has to take an object name parameter that describes it */

class CBaseObject
{

private:

    // Disable the copy constructor and assignment by default so you will get
    //   compiler errors instead of unexpected behaviour if you pass objects
    //   by value or assign objects.
    CBaseObject(const CBaseObject& objectSrc);          // no implementation
    void operator=(const CBaseObject& objectSrc);       // no implementation

private:
    static LONG m_cObjects;     /* Total number of objects active */

protected:
#ifdef DEBUG
    DWORD m_dwCookie;           /* Cookie identifying this object */
#endif


public:

    /* These increment and decrement the number of active objects */

    CBaseObject(const TCHAR *pName);
    ~CBaseObject();

    /* Call this to find if there are any CUnknown derived objects active */

    static LONG ObjectsActive() {
        return m_cObjects;
    };
};


/* An object that supports one or more COM interfaces will be based on
   this class. It supports counting of total objects for DLLCanUnloadNow
   support, and an implementation of the core non delegating IUnknown */

class AM_NOVTABLE CUnknown : public INonDelegatingUnknown,
                 public CBaseObject
{
private:
    const LPUNKNOWN m_pUnknown; /* Owner of this object */

protected:                      /* So we can override NonDelegatingRelease() */
    volatile LONG m_cRef;       /* Number of reference counts */

public:

    CUnknown(const TCHAR *pName, LPUNKNOWN pUnk);
    virtual ~CUnknown() {};

    // This is redundant, just use the other constructor
    //   as we never touch the HRESULT in this anyway
    CUnknown(TCHAR *pName, LPUNKNOWN pUnk,HRESULT *phr);

    /* Return the owner of this object */

    LPUNKNOWN GetOwner() const {
        return m_pUnknown;
    };

    /* Called from the class factory to create a new instance, it is
       pure virtual so it must be overriden in your derived class */

    /* static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *) */

    /* Non delegating unknown implementation */

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
};

/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(LPUNKNOWN pUnk, void **ppv);

/* A function that can create a new COM object */

typedef CUnknown *(CALLBACK *LPFNNewCOMObject)(LPUNKNOWN pUnkOuter, HRESULT *phr);

/*  A function (can be NULL) which is called from the DLL entrypoint
    routine for each factory template:

    bLoading - TRUE on DLL load, FALSE on DLL unload
    rclsid   - the m_ClsID of the entry
*/
typedef void (CALLBACK *LPFNInitRoutine)(BOOL bLoading, const CLSID *rclsid);

/* Create one of these per object class in an array so that
   the default class factory code can create new instances */

class CFactoryTemplate {

public:

    const WCHAR *              m_Name;
    const CLSID *              m_ClsID;
    LPFNNewCOMObject           m_lpfnNew;
    LPFNInitRoutine            m_lpfnInit;
    const AMOVIESETUP_FILTER * m_pAMovieSetup_Filter;

    BOOL IsClassID(REFCLSID rclsid) const {
        return (IsEqualCLSID(*m_ClsID,rclsid));
    };

    CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) const {
        CheckPointer(phr,NULL);
        return m_lpfnNew(pUnk, phr);
    };
};


/* You must override the (pure virtual) NonDelegatingQueryInterface to return
   interface pointers (using GetInterface) to the interfaces your derived
   class supports (the default implementation only supports IUnknown) */

#define DECLARE_IUNKNOWN                                        \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {      \
        return GetOwner()->QueryInterface(riid,ppv);            \
    };                                                          \
    STDMETHODIMP_(ULONG) AddRef() {                             \
        return GetOwner()->AddRef();                            \
    };                                                          \
    STDMETHODIMP_(ULONG) Release() {                            \
        return GetOwner()->Release();                           \
    };



HINSTANCE	LoadOLEAut32();


#endif /* __COMBASE__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\evcode.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// list of standard Quartz event codes and the expected params
//

// Event codes are broken into two groups
//   -- system event codes
//   -- extension event codes
// All system event codes are below EC_USER

#define EC_SYSTEMBASE                       0x00
#define EC_USER                             0x8000


// System-defined event codes
// ==========================
//
// There are three types of system-defined event codes:
//
// 1.  Those which are always passed through to the application
//     (To be collected by calls to GetEvent or within WaitForCompletion.)
//     (e.g. EC_ERRORABORT, EC_USERABORT.)
//
// 2.  Those which are pure internal and will never be passed to
//     the application.  (e.g. EC_SHUTDOWN)
//
// 3.  Those which have default handling.  Default handing implies that
//     the event is not passed to the application.  However, default
//     handling may be canceled by calling
//     IMediaEvent::CancelDefaultHandling.  If the default handling is
//     cancelled in this way, then the message will be delivered to the
//     application and the application must action it appropriately.
//     Default handling can be restored by calling RestoreDefaultHandling.
//
// We will refer to these events as application, internal and defaulted
// events respectively.
//
// System-defined events may have interface pointers, BSTR's, etc passed
// as parameters.  It is therefore essential that, for any message
// retrieved using GetEvent, a matching call to FreeEventParams is made
// to ensure that relevant interfaces are released and storage freed.
// Failure to call FreeEventParams will result in memory leaks, if not
// worse.
//
// Filters sending these messages to the filter graph should not AddRef()
// any interfaces that they may pass as parameters.  The filter graph
// manager will AddRef them if required.  E.g. if the event is to be queued
// for the application or queued to a worker thread.

// Each event listed below is immediately followed by a parameter list
// detailing the types of the parameters associated with the message,
// and an indication of whether the message is an application, internal
// or defaulted message.  This is then followed by a short description.
// The use of "void" in the parameter list implies that the parameter is not
// used.  Such parameters should be zero.



#define EC_COMPLETE                         0x01
// ( HRESULT, void ) : defaulted (special)
// Signals the completed playback of a stream within the graph.  This message
// is sent by renderers when they receive end-of-stream.  The default handling
// of this message results in a _SINGLE_ EC_COMPLETE being sent to the
// application when ALL of the individual renderers have signaled EC_COMPLETE
// to the filter graph.  If the default handing is canceled, the application
// will see all of the individual EC_COMPLETEs.


#define EC_USERABORT                        0x02
// ( void, void ) : application
// In some sense, the user has requested that playback be terminated.
// This message is typically sent by renderers that render into a
// window if the user closes the window into which it was rendering.
// It is up to the application to decide if playback should actually
// be stopped.


#define EC_ERRORABORT                       0x03
// ( HRESULT, void ) : application
// Operation aborted because of error


#define EC_TIME                             0x04
// ( DWORD, DWORD ) : application
// The requested reference time occurred.  (This event is currently not used).
// lParam1 is low dword of ref time, lParam2 is high dword of reftime.


#define EC_REPAINT                          0x05
// ( IPin * (could be NULL), void ) : defaulted
// A repaint is required - lParam1 contains the (IPin *) that needs the data
// to be sent again. Default handling is: if the output pin which the IPin is
// attached  to supports the IMediaEventSink interface then it will be called
// with the EC_REPAINT first.  If that fails then normal repaint processing is
// done by the filter graph.


// Stream error notifications
#define EC_STREAM_ERROR_STOPPED             0x06
#define EC_STREAM_ERROR_STILLPLAYING        0x07
// ( HRESULT, DWORD ) : application
// lParam 1 is major code, lParam2 is minor code, either may be zero.


#define EC_ERROR_STILLPLAYING               0x08
// ( HRESULT, void ) : application
// The filter graph manager may issue Run's to the graph asynchronously.
// If such a Run fails, EC_ERROR_STILLPLAYING is issued to notify the
// application of the failure.  The state of the underlying filters
// at such a time will be indeterminate - they will all have been asked
// to run, but some are almost certainly not.


#define EC_PALETTE_CHANGED                  0x09
// ( void, void ) : application
// notify application that the video palette has changed


#define EC_VIDEO_SIZE_CHANGED               0x0A
// ( DWORD, void ) : application
// Sent by video renderers.
// Notifies the application that the native video size has changed.
// LOWORD of the DWORD is the new width, HIWORD is the new height.


#define EC_QUALITY_CHANGE                   0x0B
// ( void, void ) : application
// Notify application that playback degradation has occurred


#define EC_SHUTTING_DOWN                    0x0C
// ( void, void ) : internal
// This message is sent by the filter graph manager to any plug-in
// distributors which support IMediaEventSink to notify them that
// the filter graph is starting to shutdown.


#define EC_CLOCK_CHANGED                    0x0D
// ( void, void ) : application
// Notify application that the clock has changed.
// (i.e. SetSyncSource has been called on the filter graph and has been
// distributed successfully to the filters in the graph.)


#define EC_OPENING_FILE	                    0x10
#define EC_BUFFERING_DATA                   0x11
// ( BOOL, void ) : application
// lParam1 == 1   --> starting to open file or buffer data
// lParam1 == 0   --> not opening or buffering any more
// (This event does not appear to be used by ActiveMovie.)


#define EC_FULLSCREEN_LOST                  0x12
// ( void, IBaseFilter * ) : application
// Sent by full screen renderers when switched away from full screen.
// IBaseFilter may be NULL.


#define EC_ACTIVATE                         0x13
// ( BOOL, IBaseFilter * ) : internal
// Sent by video renderers when they lose or gain activation.
// lParam1 is set to 1 if gained or 0 if lost
// lParam2 is the IBaseFilter* for the filter that is sending the message
// Used for sound follows focus and full-screen switching


#define EC_NEED_RESTART                     0x14
// ( void, void ) : defaulted
// Sent by renderers when they regain a resource (e.g. audio renderer).
// Causes a restart by Pause/put_Current/Run (if running).


#define EC_WINDOW_DESTROYED                 0x15
// ( IBaseFilter *, void ) : internal
// Sent by video renderers when the window has been destroyed. Handled
// by the filter graph / distributor telling the resource manager.
// lParam1 is the IBaseFilter* of the filter whose window is being destroyed


#define EC_DISPLAY_CHANGED                  0x16
// ( IPin *, void ) : internal
// Sent by renderers when they detect a display change. the filter graph
// will arrange for the graph to be stopped and the pin send in lParam1
// to be reconnected. by being reconnected it allows a renderer to reset
// and connect with a more appropriate format for the new display mode
// lParam1 contains an (IPin *) that should be reconnected by the graph


#define EC_STARVATION                       0x17
// ( void, void ) : defaulted
// Sent by a filter when it detects starvation. Default handling (only when
// running) is for the graph to be paused until all filters enter the
// paused state and then run. Normally this would be sent by a parser or source
// filter when too little data is arriving.


#define EC_OLE_EVENT			    0x18
// ( BSTR, BSTR ) : application
// Sent by a filter to pass a text string to the application.
// Conventionally, the first string is a type, and the second a parameter.


#define EC_NOTIFY_WINDOW                    0x19
// ( HWND, void ) : internal
// Pass the window handle around during pin connection.

#define EC_STREAM_CONTROL_STOPPED	    0x1A
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StopAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Stop.  This
// may not be the pin that the StopAt was sent to.

#define EC_STREAM_CONTROL_STARTED	    0x1B
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StartAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Start.  This
// may not be the pin that the StartAt was sent to.

#define EC_END_OF_SEGMENT                   0x1C
//
// ( const REFERENCE_TIME *pStreamTimeAtEndOfSegment, DWORD dwSegmentNumber )
//
// pStreamTimeAtEndOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous and current segment durations (Stop - Start)
//     and the rate applied to each segment
//     The source add this time to the time within each segment to get
//     a total elapsed time
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a segment end has been reached when the
// AM_SEEKING_Segment flags was set for IMediaSeeking::SetPositions
// Passes in an IMediaSeeking interface to allow the next segment
// to be defined by the application

#define EC_SEGMENT_STARTED                  0x1D
//
// ( const REFERENCE_TIME *pStreamTimeAtStartOfSegment, DWORD dwSegmentNumber)
//
// pStreamTimeAtStartOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous segment durations (Stop - Start)
//     and the rate applied to each segment
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a new segment has been started.
// This is sent synchronously by any entity that will issue
// EC_END_OF_SEGMENT when a new segment is started
// (See IMediaSeeking::SetPositions - AM_SEEKING_Segment flag)
// It is used to compute how many EC_END_OF_SEGMENT notifications
// to expect at the end of a segment and as a consitency check

#define EC_LENGTH_CHANGED                  0x1E
// (void, void)
// sent to indicate that the length of the "file" has changed
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\fourcc.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// FOURCCMap
//
// provides a mapping between old-style multimedia format DWORDs
// and new-style GUIDs.
//
// A range of 4 billion GUIDs has been allocated to ensure that this
// mapping can be done straightforwardly one-to-one in both directions.
//
// January 95


#ifndef __FOURCC__
#define __FOURCC__


// Multimedia format types are marked with DWORDs built from four 8-bit
// chars and known as FOURCCs. New multimedia AM_MEDIA_TYPE definitions include
// a subtype GUID. In order to simplify the mapping, GUIDs in the range:
//    XXXXXXXX-0000-0010-8000-00AA00389B71
// are reserved for FOURCCs.

class FOURCCMap : public GUID
{

public:
    FOURCCMap();
    FOURCCMap(DWORD Fourcc);
    FOURCCMap(const GUID *);


    DWORD GetFOURCC(void);
    void SetFOURCC(DWORD fourcc);
    void SetFOURCC(const GUID *);

private:
    void InitGUID();
};

#define GUID_Data2      0
#define GUID_Data3     0x10
#define GUID_Data4_1   0xaa000080
#define GUID_Data4_2   0x719b3800

inline void
FOURCCMap::InitGUID() {
    Data2 = GUID_Data2;
    Data3 = GUID_Data3;
    ((DWORD *)Data4)[0] = GUID_Data4_1;
    ((DWORD *)Data4)[1] = GUID_Data4_2;
}

inline
FOURCCMap::FOURCCMap() {
    InitGUID();
    SetFOURCC( DWORD(0));
}

inline
FOURCCMap::FOURCCMap(DWORD fourcc)
{
    InitGUID();
    SetFOURCC(fourcc);
}

inline
FOURCCMap::FOURCCMap(const GUID * pGuid)
{
    InitGUID();
    SetFOURCC(pGuid);
}

inline void
FOURCCMap::SetFOURCC(const GUID * pGuid)
{
    FOURCCMap * p = (FOURCCMap*) pGuid;
    SetFOURCC(p->GetFOURCC());
}

inline void
FOURCCMap::SetFOURCC(DWORD fourcc)
{
    Data1 = fourcc;
}

inline DWORD
FOURCCMap::GetFOURCC(void)
{
    return Data1;
}

#endif /* __FOURCC__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\dllsetup.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>

//---------------------------------------------------------------------------
// defines

#define MAX_KEY_LEN  260


//---------------------------------------------------------------------------
// externally defined functions/variable

extern int g_cTemplates;
extern CFactoryTemplate g_Templates[];

//---------------------------------------------------------------------------
//
// EliminateSubKey
//
// Try to enumerate all keys under this one.
// if we find anything, delete it completely.
// Otherwise just delete it.
//
// note - this was pinched/duplicated from
// Filgraph\Mapper.cpp - so should it be in
// a lib somewhere?
//
//---------------------------------------------------------------------------

STDAPI
EliminateSubKey( HKEY hkey, LPTSTR strSubKey )
{
  HKEY hk;
  if (0 == lstrlen(strSubKey) ) {
      // defensive approach
      return E_FAIL;
  }

  LONG lreturn = RegOpenKeyEx( hkey
                             , strSubKey
                             , 0
                             , MAXIMUM_ALLOWED
                             , &hk );

  ASSERT(    lreturn == ERROR_SUCCESS
          || lreturn == ERROR_FILE_NOT_FOUND
          || lreturn == ERROR_INVALID_HANDLE );

  if( ERROR_SUCCESS == lreturn )
  {
    // Keep on enumerating the first (zero-th)
    // key and deleting that

    for( ; ; )
    {
      TCHAR Buffer[MAX_KEY_LEN];
      DWORD dw = MAX_KEY_LEN;
      FILETIME ft;

      lreturn = RegEnumKeyEx( hk
                            , 0
                            , Buffer
                            , &dw
                            , NULL
                            , NULL
                            , NULL
                            , &ft);

      ASSERT(    lreturn == ERROR_SUCCESS
              || lreturn == ERROR_NO_MORE_ITEMS );

      if( ERROR_SUCCESS == lreturn )
      {
        EliminateSubKey(hk, Buffer);
      }
      else
      {
        break;
      }
    }

    RegCloseKey(hk);
    RegDeleteKey(hkey, strSubKey);
  }

  return NOERROR;
}


//---------------------------------------------------------------------------
//
// AMovieSetupRegisterServer()
//
// registers specfied file "szFileName" as server for
// CLSID "clsServer".  A description is also required.
// The ThreadingModel and ServerType are optional, as
// they default to InprocServer32 (i.e. dll) and Both.
//
//---------------------------------------------------------------------------

STDAPI
AMovieSetupRegisterServer( CLSID   clsServer
                         , LPCWSTR szDescription
                         , LPCWSTR szFileName
                         , LPCWSTR szThreadingModel = L"Both"
                         , LPCWSTR szServerType     = L"InprocServer32" )
{
  // temp buffer
  //
  TCHAR achTemp[MAX_PATH];

  // convert CLSID uuid to string and write
  // out subkey as string - CLSID\{}
  //
  OLECHAR szCLSID[CHARS_IN_GUID];
  HRESULT hr = StringFromGUID2( clsServer
                              , szCLSID
                              , CHARS_IN_GUID );
  ASSERT( SUCCEEDED(hr) );

  // create key
  //
  HKEY hkey;
  wsprintf( achTemp, TEXT("CLSID\\%ls"), szCLSID );
  LONG lreturn = RegCreateKey( HKEY_CLASSES_ROOT
                             , (LPCTSTR)achTemp
                             , &hkey              );
  if( ERROR_SUCCESS != lreturn )
  {
    return HRESULT_FROM_WIN32(lreturn);
  }

  // set description string
  //

  wsprintf( achTemp, TEXT("%ls"), szDescription );
  lreturn = RegSetValue( hkey
                       , (LPCTSTR)NULL
                       , REG_SZ
                       , achTemp
                       , sizeof(achTemp) );
  if( ERROR_SUCCESS != lreturn )
  {
    RegCloseKey( hkey );
    return HRESULT_FROM_WIN32(lreturn);
  }

  // create CLSID\\{"CLSID"}\\"ServerType" key,
  // using key to CLSID\\{"CLSID"} passed back by
  // last call to RegCreateKey().
  //
  HKEY hsubkey;

  wsprintf( achTemp, TEXT("%ls"), szServerType );
  lreturn = RegCreateKey( hkey
                        , achTemp
                        , &hsubkey     );
  if( ERROR_SUCCESS != lreturn )
  {
    RegCloseKey( hkey );
    return HRESULT_FROM_WIN32(lreturn);
  }

  // set Server string
  //
  wsprintf( achTemp, TEXT("%ls"), szFileName );
  lreturn = RegSetValue( hsubkey
                       , (LPCTSTR)NULL
                       , REG_SZ
                       , (LPCTSTR)achTemp
                       , sizeof(TCHAR) * (lstrlen(achTemp)+1) );
  if( ERROR_SUCCESS != lreturn )
  {
    RegCloseKey( hkey );
    RegCloseKey( hsubkey );
    return HRESULT_FROM_WIN32(lreturn);
  }

  wsprintf( achTemp, TEXT("%ls"), szThreadingModel );
  lreturn = RegSetValueEx( hsubkey
                         , TEXT("ThreadingModel")
                         , 0L
                         , REG_SZ
                         , (CONST BYTE *)achTemp
                         , sizeof(TCHAR) * (lstrlen(achTemp)+1) );

  // close hkeys
  //
  RegCloseKey( hkey );
  RegCloseKey( hsubkey );

  // and return
  //
  return HRESULT_FROM_WIN32(lreturn);

}


//---------------------------------------------------------------------------
//
// AMovieSetupUnregisterServer()
//
// default ActiveMovie dll setup function
// - to use must be called from an exported
//   function named DllRegisterServer()
//
//---------------------------------------------------------------------------

STDAPI
AMovieSetupUnregisterServer( CLSID clsServer )
{
  // convert CLSID uuid to string and write
  // out subkey CLSID\{}
  //
  OLECHAR szCLSID[CHARS_IN_GUID];
  HRESULT hr = StringFromGUID2( clsServer
                              , szCLSID
                              , CHARS_IN_GUID );
  ASSERT( SUCCEEDED(hr) );

  TCHAR achBuffer[MAX_KEY_LEN];
  wsprintf( achBuffer, TEXT("CLSID\\%ls"), szCLSID );

  // delete subkey
  //

  hr = EliminateSubKey( HKEY_CLASSES_ROOT, achBuffer );
  ASSERT( SUCCEEDED(hr) );

  // return
  //
  return NOERROR;
}


//---------------------------------------------------------------------------
//
// AMovieSetupRegisterFilter through IFilterMapper2
//
//---------------------------------------------------------------------------

STDAPI
AMovieSetupRegisterFilter2( const AMOVIESETUP_FILTER * const psetupdata
                          , IFilterMapper2 *                 pIFM2
                          , BOOL                             bRegister  )
{
  DbgLog((LOG_TRACE, 3, TEXT("= AMovieSetupRegisterFilter")));

  // check we've got data
  //
  if( NULL == psetupdata ) return S_FALSE;


  // unregister filter
  // (as pins are subkeys of filter's CLSID key
  // they do not need to be removed separately).
  //
  DbgLog((LOG_TRACE, 3, TEXT("= = unregister filter")));
  HRESULT hr = pIFM2->UnregisterFilter(
      0,                        // default category
      0,                        // default instance name
      *psetupdata->clsID );


  if( bRegister )
  {
    REGFILTER2 rf2;
    rf2.dwVersion = 1;
    rf2.dwMerit = psetupdata->dwMerit;
    rf2.cPins = psetupdata->nPins;
    rf2.rgPins = psetupdata->lpPin;
    
    // register filter
    //
    DbgLog((LOG_TRACE, 3, TEXT("= = register filter")));
    hr = pIFM2->RegisterFilter(*psetupdata->clsID
                             , psetupdata->strName
                             , 0 // moniker
                             , 0 // category
                             , NULL // instance
                             , &rf2);
  }

  // handle one acceptable "error" - that
  // of filter not being registered!
  // (couldn't find a suitable #define'd
  // name for the error!)
  //
  if( 0x80070002 == hr)
    return NOERROR;
  else
    return hr;
}


//---------------------------------------------------------------------------
//
// RegisterAllServers()
//
//---------------------------------------------------------------------------

STDAPI
RegisterAllServers( LPCWSTR szFileName, BOOL bRegister )
{
  HRESULT hr = NOERROR;

  for( int i = 0; i < g_cTemplates; i++ )
  {
    // get i'th template
    //
    const CFactoryTemplate *pT = &g_Templates[i];

    DbgLog((LOG_TRACE, 2, TEXT("- - register %ls"),
           (LPCWSTR)pT->m_Name ));

    // register CLSID and InprocServer32
    //
    if( bRegister )
    {
      hr = AMovieSetupRegisterServer( *(pT->m_ClsID)
                                    , (LPCWSTR)pT->m_Name
                                    , szFileName );
    }
    else
    {
      hr = AMovieSetupUnregisterServer( *(pT->m_ClsID) );
    }

    // check final error for this pass
    // and break loop if we failed
    //
    if( FAILED(hr) )
      break;
  }

  return hr;
}


//---------------------------------------------------------------------------
//
// AMovieDllRegisterServer2()
//
// default ActiveMovie dll setup function
// - to use must be called from an exported
//   function named DllRegisterServer()
//
// this function is table driven using the
// static members of the CFactoryTemplate
// class defined in the dll.
//
// it registers the Dll as the InprocServer32
// and then calls the IAMovieSetup.Register
// method.
//
//---------------------------------------------------------------------------

STDAPI
AMovieDllRegisterServer2( BOOL bRegister )
{
  HRESULT hr = NOERROR;

  DbgLog((LOG_TRACE, 2, TEXT("AMovieDllRegisterServer2()")));

  // get file name (where g_hInst is the
  // instance handle of the filter dll)
  //
  WCHAR achFileName[MAX_PATH];

  // WIN95 doesn't support GetModuleFileNameW
  //
  {
    char achTemp[MAX_PATH];

    DbgLog((LOG_TRACE, 2, TEXT("- get module file name")));

    // g_hInst handle is set in our dll entry point. Make sure
    // DllEntryPoint in dllentry.cpp is called
    ASSERT(g_hInst != 0);

    if( 0 == GetModuleFileNameA( g_hInst
                              , achTemp
                              , sizeof(achTemp) ) )
    {
      // we've failed!
      DWORD dwerr = GetLastError();
      return HRESULT_FROM_WIN32(dwerr);
    }

    MultiByteToWideChar( CP_ACP
                       , 0L
                       , achTemp
                       , lstrlenA(achTemp) + 1
                       , achFileName
                       , sizeof(achFileName) / sizeof(achFileName[0]));
  }

  //
  // first registering, register all OLE servers
  //
  if( bRegister )
  {
    DbgLog((LOG_TRACE, 2, TEXT("- register OLE Servers")));
    hr = RegisterAllServers( achFileName, TRUE );
  }

  //
  // next, register/unregister all filters
  //

  if( SUCCEEDED(hr) )
  {
    // init is ref counted so call just in case
    // we're being called cold.
    //
    DbgLog((LOG_TRACE, 2, TEXT("- CoInitialize")));
    hr = CoInitialize( (LPVOID)NULL );
    ASSERT( SUCCEEDED(hr) );

    // get hold of IFilterMapper2
    //
    DbgLog((LOG_TRACE, 2, TEXT("- obtain IFilterMapper2")));
    IFilterMapper2 *pIFM2 = 0;
    IFilterMapper *pIFM = 0;
    hr = CoCreateInstance( CLSID_FilterMapper2
                         , NULL
                         , CLSCTX_INPROC_SERVER
                         , IID_IFilterMapper2
                         , (void **)&pIFM2       );
    if(FAILED(hr))
    {
        DbgLog((LOG_TRACE, 2, TEXT("- trying IFilterMapper instead")));

        hr = CoCreateInstance(
            CLSID_FilterMapper,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IFilterMapper,
            (void **)&pIFM);
    }
    if( SUCCEEDED(hr) )
    {
      // scan through array of CFactoryTemplates
      // registering servers and filters.
      //
      DbgLog((LOG_TRACE, 2, TEXT("- register Filters")));
      for( int i = 0; i < g_cTemplates; i++ )
      {
        // get i'th template
        //
        const CFactoryTemplate *pT = &g_Templates[i];

        if( NULL != pT->m_pAMovieSetup_Filter )
        {
          DbgLog((LOG_TRACE, 2, TEXT("- - register %ls"), (LPCWSTR)pT->m_Name ));

          if(pIFM2)
          {
              hr = AMovieSetupRegisterFilter2( pT->m_pAMovieSetup_Filter, pIFM2, bRegister );
          }
          else
          {
              hr = AMovieSetupRegisterFilter( pT->m_pAMovieSetup_Filter, pIFM, bRegister );
          }
        }

        // check final error for this pass
        // and break loop if we failed
        //
        if( FAILED(hr) )
          break;
      }

      // release interface
      //
      if(pIFM2)
          pIFM2->Release();
      else
          pIFM->Release();

    }

    // and clear up
    //
    CoFreeUnusedLibraries();
    CoUninitialize();
  }

  //
  // if unregistering, unregister all OLE servers
  //
  if( SUCCEEDED(hr) && !bRegister )
  {
    DbgLog((LOG_TRACE, 2, TEXT("- register OLE Servers")));
    hr = RegisterAllServers( achFileName, FALSE );
  }

  DbgLog((LOG_TRACE, 2, TEXT("- return %0x"), hr));
  return hr;
}


//---------------------------------------------------------------------------
//
// AMovieDllRegisterServer()
//
// default ActiveMovie dll setup function
// - to use must be called from an exported
//   function named DllRegisterServer()
//
// this function is table driven using the
// static members of the CFactoryTemplate
// class defined in the dll.
//
// it registers the Dll as the InprocServer32
// and then calls the IAMovieSetup.Register
// method.
//
//---------------------------------------------------------------------------


STDAPI
AMovieDllRegisterServer( void )
{
  HRESULT hr = NOERROR;

  // get file name (where g_hInst is the
  // instance handle of the filter dll)
  //
  WCHAR achFileName[MAX_PATH];

  {
    // WIN95 doesn't support GetModuleFileNameW
    //
    char achTemp[MAX_PATH];

    if( 0 == GetModuleFileNameA( g_hInst
                              , achTemp
                              , sizeof(achTemp) ) )
    {
      // we've failed!
      DWORD dwerr = GetLastError();
      return HRESULT_FROM_WIN32(dwerr);
    }

    MultiByteToWideChar( CP_ACP
                       , 0L
                       , achTemp
                       , lstrlenA(achTemp) + 1
                       , achFileName
                       , sizeof(achFileName)/sizeof(achFileName[0]) );
  }

  // scan through array of CFactoryTemplates
  // registering servers and filters.
  //
  for( int i = 0; i < g_cTemplates; i++ )
  {
    // get i'th template
    //
    const CFactoryTemplate *pT = &g_Templates[i];

    // register CLSID and InprocServer32
    //
    hr = AMovieSetupRegisterServer( *(pT->m_ClsID)
                                  , (LPCWSTR)pT->m_Name
                                  , achFileName );

    // instantiate all servers and get hold of
    // IAMovieSetup, if implemented, and call
    // IAMovieSetup.Register() method
    //
    if( SUCCEEDED(hr) && (NULL != pT->m_lpfnNew) )
    {
      // instantiate object
      //
      PAMOVIESETUP psetup;
      hr = CoCreateInstance( *(pT->m_ClsID)
                           , 0
                           , CLSCTX_INPROC_SERVER
                           , IID_IAMovieSetup
                           , reinterpret_cast<void**>(&psetup) );
      if( SUCCEEDED(hr) )
      {
        hr = psetup->Unregister();
        if( SUCCEEDED(hr) )
          hr = psetup->Register();
        psetup->Release();
      }
      else
      {
        if(    (E_NOINTERFACE      == hr )
            || (VFW_E_NEED_OWNER == hr ) )
          hr = NOERROR;
      }
    }

    // check final error for this pass
    // and break loop if we failed
    //
    if( FAILED(hr) )
      break;

  } // end-for

  return hr;
}


//---------------------------------------------------------------------------
//
// AMovieDllUnregisterServer()
//
// default ActiveMovie dll uninstall function
// - to use must be called from an exported
//   function named DllRegisterServer()
//
// this function is table driven using the
// static members of the CFactoryTemplate
// class defined in the dll.
//
// it calls the IAMovieSetup.Unregister
// method and then unregisters the Dll
// as the InprocServer32
//
//---------------------------------------------------------------------------

STDAPI
AMovieDllUnregisterServer()
{
  // initialize return code
  //
  HRESULT hr = NOERROR;

  // scan through CFactory template and unregister
  // all OLE servers and filters.
  //
  for( int i = g_cTemplates; i--; )
  {
    // get i'th template
    //
    const CFactoryTemplate *pT = &g_Templates[i];

    // check method exists
    //
    if( NULL != pT->m_lpfnNew )
    {
      // instantiate object
      //
      PAMOVIESETUP psetup;
      hr = CoCreateInstance( *(pT->m_ClsID)
                           , 0
                           , CLSCTX_INPROC_SERVER
                           , IID_IAMovieSetup
                           , reinterpret_cast<void**>(&psetup) );
      if( SUCCEEDED(hr) )
      {
        hr = psetup->Unregister();
        psetup->Release();
      }
      else
      {
        if(    (E_NOINTERFACE      == hr )
            || (VFW_E_NEED_OWNER == hr ) )
           hr = NOERROR;
      }
    }

    // unregister CLSID and InprocServer32
    //
    if( SUCCEEDED(hr) )
    {
      hr = AMovieSetupUnregisterServer( *(pT->m_ClsID) );
    }

    // check final error for this pass
    // and break loop if we failed
    //
    if( FAILED(hr) )
      break;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\dllsetup.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// To be self registering, OLE servers must
// export functions named DllRegisterServer
// and DllUnregisterServer.  To allow use of
// custom and default implementations the
// defaults are named AMovieDllRegisterServer
// and AMovieDllUnregisterServer.
//
// To the use the default implementation you
// must provide stub functions.
//
// i.e. STDAPI DllRegisterServer()
//      {
//        return AMovieDllRegisterServer();
//      }
//
//      STDAPI DllUnregisterServer()
//      {
//        return AMovieDllUnregisterServer();
//      }
//
//
// AMovieDllRegisterServer   calls IAMovieSetup.Register(), and
// AMovieDllUnregisterServer calls IAMovieSetup.Unregister().

STDAPI AMovieDllRegisterServer2( BOOL );
STDAPI AMovieDllRegisterServer();
STDAPI AMovieDllUnregisterServer();

// helper functions
STDAPI EliminateSubKey( HKEY, LPTSTR );


STDAPI
AMovieSetupRegisterFilter2( const AMOVIESETUP_FILTER * const psetupdata
                          , IFilterMapper2 *                 pIFM2
                          , BOOL                             bRegister  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\measure.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

/*
   The idea is to pepper the source code with interesting measurements and
   have the last few thousand of these recorded in a circular buffer that
   can be post-processed to give interesting numbers.

   WHAT THE LOG LOOKS LIKE:

  Time (sec)   Type        Delta  Incident_Name
    0.055,41  NOTE      -.       Incident Nine  - Another note
    0.055,42  NOTE      0.000,01 Incident Nine  - Another note
    0.055,44  NOTE      0.000,02 Incident Nine  - Another note
    0.055,45  STOP      -.       Incident Eight - Also random
    0.055,47  START     -.       Incident Seven - Random
    0.055,49  NOTE      0.000,05 Incident Nine  - Another note
    ------- <etc.  there is a lot of this> ----------------
    0.125,60  STOP      0.000,03 Msr_Stop
    0.125,62  START     -.       Msr_Start
    0.125,63  START     -.       Incident Two   - Start/Stop
    0.125,65  STOP      0.000,03 Msr_Start
    0.125,66  START     -.       Msr_Stop
    0.125,68  STOP      0.000,05 Incident Two   - Start/Stop
    0.125,70  STOP      0.000,04 Msr_Stop
    0.125,72  START     -.       Msr_Start
    0.125,73  START     -.       Incident Two   - Start/Stop
    0.125,75  STOP      0.000,03 Msr_Start
    0.125,77  START     -.       Msr_Stop
    0.125,78  STOP      0.000,05 Incident Two   - Start/Stop
    0.125,80  STOP      0.000,03 Msr_Stop
    0.125,81  NOTE      -.       Incident Three - single Note
    0.125,83  START     -.       Incident Four  - Start, no stop
    0.125,85  START     -.       Incident Five  - Single Start/Stop
    0.125,87  STOP      0.000,02 Incident Five  - Single Start/Stop

Number      Average       StdDev     Smallest      Largest Incident_Name
    10     0.000,58     0.000,10     0.000,55     0.000,85 Incident One   - Note
    50     0.000,05     0.000,00     0.000,05     0.000,05 Incident Two   - Start/Stop
     1     -.           -.           -.           -.       Incident Three - single Note
     0     -.           -.           -.           -.       Incident Four  - Start, no stop
     1     0.000,02     -.           0.000,02     0.000,02 Incident Five  - Single Start/Stop
     0     -.           -.           -.           -.       Incident Six   - zero occurrences
   100     0.000,25     0.000,12     0.000,02     0.000,62 Incident Seven - Random
   100     0.000,79     0.000,48     0.000,02     0.001,92 Incident Eight - Also random
  5895     0.000,01     0.000,01     0.000,01     0.000,56 Incident Nine  - Another note
    10     0.000,03     0.000,00     0.000,03     0.000,04 Msr_Note
    50     0.000,03     0.000,00     0.000,03     0.000,04 Msr_Start
    50     0.000,04     0.000,03     0.000,03     0.000,31 Msr_Stop

  WHAT IT MEANS:
    The log shows what happened and when.  Each line shows the time at which
    something happened (see WHAT YOU CODE below) what it was that happened
    and (if approporate) the time since the corresponding previous event
    (that's the delta column).

    The statistics show how many times each event occurred, what the average
    delta time was, also the standard deviation, largest and smalles delta.

   WHAT YOU CODE:

   Before anything else executes: - register your ids

    int id1     = Msr_Register("Incident One   - Note");
    int id2     = Msr_Register("Incident Two   - Start/Stop");
    int id3     = Msr_Register("Incident Three - single Note");
    etc.

   At interesting moments:

       // To measure a repetitive event - e.g. end of bitblt to screen
       Msr_Note(Id9);             // e.g. "video frame hiting the screen NOW!"

           or

       // To measure an elapsed time e.g. time taken to decode an MPEG B-frame
       Msr_Start(Id2);            // e.g. "Starting to decode MPEG B-frame"
         . . .
       MsrStop(Id2);              //      "Finished MPEG decode"

   At the end:

       HANDLE hFile;
       hFile = CreateFile("Perf.log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
       Msr_Dump(hFile);           // This writes the log out to the file
       CloseHandle(hFile);

           or

       Msr_Dump(NULL);            // This writes it to DbgLog((LOG_TRACE,0, ... ));
                                  // but if you are writing it out to the debugger
                                  // then the times are probably all garbage because
                                  // the debugger can make things run awfully slow.

    A given id should be used either for start / stop or Note calls.  If Notes
    are mixed in with Starts and Stops their statistics will be gibberish.

    If you code the calls in upper case i.e. MSR_START(idMunge); then you get
    macros which will turn into nothing unless PERF is defined.

    You can reset the statistical counts for a given id by calling Reset(Id).
    They are reset by default at the start.
    It logs Reset as a special incident, so you can see it in the log.

    The log is a circular buffer in storage (to try to minimise disk I/O).
    It overwrites the oldest entries once full.  The statistics include ALL
    incidents since the last Reset, whether still visible in the log or not.
*/

#ifndef __MEASURE__
#define __MEASURE__

#ifdef PERF
#define MSR_INIT() Msr_Init()
#define MSR_TERMINATE() Msr_Terminate()
#define MSR_REGISTER(a) Msr_Register(a)
#define MSR_RESET(a) Msr_Reset(a)
#define MSR_CONTROL(a) Msr_Control(a)
#define MSR_START(a) Msr_Start(a)
#define MSR_STOP(a) Msr_Stop(a)
#define MSR_NOTE(a) Msr_Note(a)
#define MSR_INTEGER(a,b) Msr_Integer(a,b)
#define MSR_DUMP(a) Msr_Dump(a)
#define MSR_DUMPSTATS(a) Msr_DumpStats(a)
#else
#define MSR_INIT() ((void)0)
#define MSR_TERMINATE() ((void)0)
#define MSR_REGISTER(a) 0
#define MSR_RESET(a) ((void)0)
#define MSR_CONTROL(a) ((void)0)
#define MSR_START(a) ((void)0)
#define MSR_STOP(a) ((void)0)
#define MSR_NOTE(a) ((void)0)
#define MSR_INTEGER(a,b) ((void)0)
#define MSR_DUMP(a) ((void)0)
#define MSR_DUMPSTATS(a) ((void)0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

// This must be called first - (called by the DllEntry)

void WINAPI Msr_Init(void);


// Call this last to clean up (or just let it fall off the end - who cares?)

void WINAPI Msr_Terminate(void);


// Call this to get an Id for an "incident" that you can pass to Start, Stop or Note
// everything that's logged is called an "incident".

int  WINAPI Msr_Register(LPTSTR Incident);


// Reset the statistical counts for an incident

void WINAPI Msr_Reset(int Id);


// Reset all the counts for all incidents
#define MSR_RESET_ALL 0
#define MSR_PAUSE 1
#define MSR_RUN 2

void WINAPI Msr_Control(int iAction);


// log the start of an operation

void WINAPI Msr_Start(int Id);


// log the end of an operation

void WINAPI Msr_Stop(int Id);


// log a one-off or repetitive operation

void WINAPI Msr_Note(int Id);


// log an integer (on which we can see statistics later)
void WINAPI Msr_Integer(int Id, int n);


// print out all the vaialable log (it may have wrapped) and then the statistics.
// When the log wraps you lose log but the statistics are still complete.
// hFIle==NULL => use DbgLog
// otherwise hFile must have come from CreateFile or OpenFile.

void WINAPI Msr_Dump(HANDLE hFile);


// just dump the statistics - never mind the log

void WINAPI Msr_DumpStats(HANDLE hFile);

// Type definitions in case you want to declare a pointer to the dump functions
// (makes it a trifle easier to do dynamic linking
// i.e. LoadModule, GetProcAddress and call that)

// Typedefs so can declare MSR_DUMPPROC *MsrDumpStats; or whatever
typedef void WINAPI MSR_DUMPPROC(HANDLE hFile);
typedef void WINAPI MSR_CONTROLPROC(int iAction);


#ifdef __cplusplus
}
#endif

#endif // __MEASURE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\msgthrd.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// support for a worker thread class to which you can asynchronously post
// messages


// Message class - really just a structure.
//
class CMsg {
public:
    UINT uMsg;
    DWORD dwFlags;
    LPVOID lpParam;
    CAMEvent *pEvent;

    CMsg(UINT u, DWORD dw, LPVOID lp, CAMEvent *pEvnt)
        : uMsg(u), dwFlags(dw), lpParam(lp), pEvent(pEvnt) {}

    CMsg()
        : uMsg(0), dwFlags(0L), lpParam(NULL), pEvent(NULL) {}
};

// This is the actual thread class.  It exports all the usual thread control
// functions.  The created thread is different from a normal WIN32 thread in
// that it is prompted to perform particaular tasks by responding to messages
// posted to its message queue.
//
class AM_NOVTABLE CMsgThread {
private:
    static DWORD WINAPI DefaultThreadProc(LPVOID lpParam);
    DWORD               m_ThreadId;
    HANDLE              m_hThread;

protected:

    // if you want to override GetThreadMsg to block on other things
    // as well as this queue, you need access to this
    CGenericList<CMsg>        m_ThreadQueue;
    CCritSec                  m_Lock;
    HANDLE                    m_hSem;
    LONG                      m_lWaiting;

public:
    CMsgThread()
        : m_ThreadId(0),
        m_hThread(NULL),
        m_lWaiting(0),
        m_hSem(NULL),
        // make a list with a cache of 5 items
        m_ThreadQueue(NAME("MsgThread list"), 5)
        {
        }

    ~CMsgThread();
    // override this if you want to block on other things as well
    // as the message loop
    void virtual GetThreadMsg(CMsg *msg);

    // override this if you want to do something on thread startup
    virtual void OnThreadInit() {
    };

    BOOL CreateThread();

    BOOL WaitForThreadExit(LPDWORD lpdwExitCode) {
        if (m_hThread != NULL) {
            WaitForSingleObject(m_hThread, INFINITE);
            return GetExitCodeThread(m_hThread, lpdwExitCode);
        }
        return FALSE;
    }

    DWORD ResumeThread() {
        return ::ResumeThread(m_hThread);
    }

    DWORD SuspendThread() {
        return ::SuspendThread(m_hThread);
    }

    int GetThreadPriority() {
        return ::GetThreadPriority(m_hThread);
    }

    BOOL SetThreadPriority(int nPriority) {
        return ::SetThreadPriority(m_hThread, nPriority);
    }

    HANDLE GetThreadHandle() {
        return m_hThread;
    }

    DWORD GetThreadId() {
        return m_ThreadId;
    }


    void PutThreadMsg(UINT uMsg, DWORD dwMsgFlags,
                      LPVOID lpMsgParam, CAMEvent *pEvent = NULL) {
        CAutoLock lck(&m_Lock);
        CMsg* pMsg = new CMsg(uMsg, dwMsgFlags, lpMsgParam, pEvent);
        m_ThreadQueue.AddTail(pMsg);
        if (m_lWaiting != 0) {
            ReleaseSemaphore(m_hSem, m_lWaiting, 0);
            m_lWaiting = 0;
        }
    }

    // This is the function prototype of the function that the client
    // supplies.  It is always called on the created thread, never on
    // the creator thread.
    //
    virtual LRESULT ThreadMessageProc(
        UINT uMsg, DWORD dwFlags, LPVOID lpParam, CAMEvent *pEvent) = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\ksuuids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// contains the GUIDs for the MediaType type, subtype fields and format types 
// for DVD/MPEG2 media types.


//
// --- MPEG 2 definitions ---
//

// e06d8020-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PES,
0xe06d8020, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)


#if 0
DEFINE_GUID(MEDIATYPE_CONTROL,
0xe06d8021, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#endif // #if 0


// e06d8026-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_VIDEO,
0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// use MPEG2VIDEOINFO (defined below) with FORMAT_MPEG2_VIDEO
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2_VIDEO,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA       (FORMAT_VideoInfo2)
OUR_GUID_ENTRY(FORMAT_VIDEOINFO2,
0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba)

// MPEG2 Other subtypes
// e06d8022-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_PROGRAM,
0xe06d8022, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8023-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT,
0xe06d8023, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802b-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_AUDIO,
0xe06d802b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802c-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3,
0xe06d802c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802d-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_SUBPICTURE,
0xe06d802d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8032-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_LPCM_AUDIO,
0xe06d8032, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// DVD-related mediatypes
// ED0B916A-044D-11d1-AA78-00C04FC31D60
OUR_GUID_ENTRY(MEDIATYPE_DVD_ENCRYPTED_PACK,
0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x04f, 0xc3, 0x1d, 0x60)

// e06d802e-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_DVD_NAVIGATION,
0xe06d802e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802f-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PCI,                             
0xe06d802f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8030-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_DSI,
0xe06d8030, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8031-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER,
0xe06d8031, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

//
// DVD - MPEG2/AC3-related Formats
//
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Video,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e4-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DolbyAC3,
0xe06d80e4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e5-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Audio,
0xe06d80e5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e6-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DVD_LPCMAudio,
0xe06d80e6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)


//
// KS Property Set Id (to communicate with the WDM Proxy filter) -- from
// ksmedia.h of WDM DDK.
//

// BFABE720-6E1F-11D0-BCF2-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_AC3,
0xBFABE720, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00)

// ac390460-43af-11d0-bd6a-003505c103a9
OUR_GUID_ENTRY(AM_KSPROPSETID_DvdSubPic,
0xac390460, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9)

// 0E8A0A40L-6AEF-11D0-9ED0-00A024CA19B3
OUR_GUID_ENTRY(AM_KSPROPSETID_CopyProt,
0x0E8A0A40, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3)

// A503C5C0-1D1D-11d1-AD80-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_TSRateChange, 
0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0)


//
// KS categories from ks.h and ksmedia.h
//
//

// 65E8773D-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_CAPTURE,
0x65E8773DL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 65E8773E-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_RENDER,
0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1E84C900-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_DATACOMPRESSOR,
0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 6994AD04-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_AUDIO,
0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 6994AD05-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_VIDEO,
0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// a799a800-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVTUNER,
0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)

// a799a801-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_CROSSBAR,
0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)               

// a799a802-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVAUDIO,
0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)


//
// guids needed to support IKsPin interface
//

// d3abc7e0l-9a61-11d0-a40d00a0c9223196
OUR_GUID_ENTRY(IID_IKsInterfaceHandler,
0xD3ABC7E0L, 0x9A61, 0x11D0, 0xA4, 0x0D, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 5ffbaa02l-49a3-11d0-9f3600aa00a216a1
OUR_GUID_ENTRY(IID_IKsDataTypeHandler,
0x5FFBAA02L, 0x49A3, 0x11D0, 0x9F, 0x36, 0x00, 0xAA, 0x00, 0xA2, 0x16, 0xA1)

// b61178d1-a2d9-11cf-9e53-00aa00a216a1
OUR_GUID_ENTRY(IID_IKsPin,
0xb61178d1L, 0xa2d9, 0x11cf, 0x9e, 0x53, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1)

// 1A8766A0-62CE-11CF-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_INTERFACESETID_Standard,
0x1A8766A0L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\refclock.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//  REFCLOCK.H
//  Implements IReferenceClock Interface

#ifndef __BASEREFCLOCK__
#define __BASEREFCLOCK__

#include <Schedule.h>

const UINT RESOLUTION = 1;                      /* High resolution timer */
const INT ADVISE_CACHE = 4;                     /* Default cache size */
const LONGLONG MAX_TIME = 0x7FFFFFFFFFFFFFFF;   /* Maximum LONGLONG value */

inline LONGLONG WINAPI ConvertToMilliseconds(const REFERENCE_TIME& RT)
{
    /* This converts an arbitrary value representing a reference time
       into a MILLISECONDS value for use in subsequent system calls */

    return (RT / (UNITS / MILLISECONDS));
}

/* This class hierarchy will support an IReferenceClock interface so
   that an audio card (or other externally driven clock) can update the
   system wide clock that everyone uses.

   The interface will be pretty thin with probably just one update method
   This interface has not yet been defined.
 */

/* This abstract base class implements the IReferenceClock
 * interface.  Classes that actually provide clock signals (from
 * whatever source) have to be derived from this class.
 *
 * The abstract class provides implementations for:
 * 	CUnknown support
 *      locking support (CCritSec)
 *	client advise code (creates a thread)
 *
 * Question: what can we do about quality?  Change the timer
 * resolution to lower the system load?  Up the priority of the
 * timer thread to force more responsive signals?
 *
 * During class construction we create a worker thread that is destroyed during
 * destuction.  This thread executes a series of WaitForSingleObject calls,
 * waking up when a command is given to the thread or the next wake up point
 * is reached.  The wakeup points are determined by clients making Advise
 * calls.
 *
 * Each advise call defines a point in time when they wish to be notified.  A
 * periodic advise is a series of these such events.  We maintain a list of
 * advise links and calculate when the nearest event notification is due for.
 * We then call WaitForSingleObject with a timeout equal to this time.  The
 * handle we wait on is used by the class to signal that something has changed
 * and that we must reschedule the next event.  This typically happens when
 * someone comes in and asks for an advise link while we are waiting for an
 * event to timeout.
 *
 * While we are modifying the list of advise requests we
 * are protected from interference through a critical section.  Clients are NOT
 * advised through callbacks.  One shot clients have an event set, while
 * periodic clients have a semaphore released for each event notification.  A
 * semaphore allows a client to be kept up to date with the number of events
 * actually triggered and be assured that they can't miss multiple events being
 * set.
 *
 * Keeping track of advises is taken care of by the CAMSchedule class.
 */

class CBaseReferenceClock
: public CUnknown, public IReferenceClock, public CCritSec
{
protected:
    virtual ~CBaseReferenceClock();     // Don't let me be created on the stack!
public:
    CBaseReferenceClock(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr, CAMSchedule * pSched = 0 );

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void ** ppv);

    DECLARE_IUNKNOWN

    /* IReferenceClock methods */
    // Derived classes must implement GetPrivateTime().  All our GetTime
    // does is call GetPrivateTime and then check so that time does not
    // go backwards.  A return code of S_FALSE implies that the internal
    // clock has gone backwards and GetTime time has halted until internal
    // time has caught up. (Don't know if this will be much use to folk,
    // but it seems odd not to use the return code for something useful.)
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    // When this is called, it sets m_rtLastGotTime to the time it returns.

    /* Provide standard mechanisms for scheduling events */

    /* Ask for an async notification that a time has elapsed */
    STDMETHODIMP AdviseTime(
        REFERENCE_TIME baseTime,        // base reference time
        REFERENCE_TIME streamTime,      // stream offset time
        HEVENT hEvent,                  // advise via this event
        DWORD_PTR *pdwAdviseCookie          // where your cookie goes
    );

    /* Ask for an asynchronous periodic notification that a time has elapsed */
    STDMETHODIMP AdvisePeriodic(
        REFERENCE_TIME StartTime,       // starting at this time
        REFERENCE_TIME PeriodTime,      // time between notifications
        HSEMAPHORE hSemaphore,          // advise via a semaphore
        DWORD_PTR *pdwAdviseCookie          // where your cookie goes
    );

    /* Cancel a request for notification(s) - if the notification was
     * a one shot timer then this function doesn't need to be called
     * as the advise is automatically cancelled, however it does no
     * harm to explicitly cancel a one-shot advise.  It is REQUIRED that
     * clients call Unadvise to clear a Periodic advise setting.
     */

    STDMETHODIMP Unadvise(DWORD_PTR dwAdviseCookie);

    /* Methods for the benefit of derived classes or outer objects */

    // GetPrivateTime() is the REAL clock.  GetTime is just a cover for
    // it.  Derived classes will probably override this method but not
    // GetTime() itself.
    // The important point about GetPrivateTime() is it's allowed to go
    // backwards.  Our GetTime() will keep returning the LastGotTime
    // until GetPrivateTime() catches up.
    virtual REFERENCE_TIME GetPrivateTime();

    /* Provide a method for correcting drift */
    STDMETHODIMP SetTimeDelta( const REFERENCE_TIME& TimeDelta );

    CAMSchedule * GetSchedule() const { return m_pSchedule; }

private:
    REFERENCE_TIME m_rtPrivateTime;     // Current best estimate of time
    DWORD          m_dwPrevSystemTime;  // Last vaule we got from timeGetTime
    REFERENCE_TIME m_rtLastGotTime;     // Last time returned by GetTime
    REFERENCE_TIME m_rtNextAdvise;      // Time of next advise
    UINT           m_TimerResolution;

#ifdef PERF
    int m_idGetSystemTime;
#endif

// Thread stuff
public:
    void TriggerThread()                	// Wakes thread up.  Need to do this if
    {						// time to next advise needs reevaluating.
	EXECUTE_ASSERT(SetEvent(m_pSchedule->GetEvent()));
    }


private:
    BOOL           m_bAbort;            // Flag used for thread shutdown
    HANDLE         m_hThread;           // Thread handle

    HRESULT AdviseThread();             // Method in which the advise thread runs
    static DWORD __stdcall AdviseThreadFunction(LPVOID); // Function used to get there

protected:
    CAMSchedule * const m_pSchedule;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\reftime.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// CRefTime
//
// Manage reference times.
// Shares same data layout as REFERENCE_TIME, but adds some (nonvirtual)
// functions providing simple comparison, conversion and arithmetic.
//
// A reference time (at the moment) is a unit of seconds represented in
// 100ns units as is used in the Win32 FILETIME structure. BUT the time
// a REFERENCE_TIME represents is NOT the time elapsed since 1/1/1601 it
// will either be stream time or reference time depending upon context
//
// This class provides simple arithmetic operations on reference times
//
// keep non-virtual otherwise the data layout will not be the same as
// REFERENCE_TIME


// -----
// note that you are safe to cast a CRefTime* to a REFERENCE_TIME*, but
// you will need to do so explicitly
// -----


#ifndef __REFTIME__
#define __REFTIME__


const LONGLONG MILLISECONDS = (1000);            // 10 ^ 3
const LONGLONG NANOSECONDS = (1000000000);       // 10 ^ 9
const LONGLONG UNITS = (NANOSECONDS / 100);      // 10 ^ 7

/*  Unfortunately an inline function here generates a call to __allmul
    - even for constants!
*/
#define MILLISECONDS_TO_100NS_UNITS(lMs) \
    Int32x32To64((lMs), (UNITS / MILLISECONDS))

class CRefTime
{
public:

    // *MUST* be the only data member so that this class is exactly
    // equivalent to a REFERENCE_TIME.
    // Also, must be *no virtual functions*

    REFERENCE_TIME m_time;

    inline CRefTime()
    {
        // default to 0 time
        m_time = 0;
    };

    inline CRefTime(LONG msecs)
    {
        m_time = MILLISECONDS_TO_100NS_UNITS(msecs);
    };

    inline CRefTime(REFERENCE_TIME rt)
    {
        m_time = rt;
    };

    inline operator REFERENCE_TIME() const
    {
        return m_time;
    };

    inline CRefTime& operator=(const CRefTime& rt)
    {
        m_time = rt.m_time;
        return *this;
    };

    inline CRefTime& operator=(const LONGLONG ll)
    {
        m_time = ll;
        return *this;
    };

    inline CRefTime& operator+=(const CRefTime& rt)
    {
        return (*this = *this + rt);
    };

    inline CRefTime& operator-=(const CRefTime& rt)
    {
        return (*this = *this - rt);
    };

    inline LONG Millisecs(void)
    {
        return (LONG)(m_time / (UNITS / MILLISECONDS));
    };

    inline LONGLONG GetUnits(void)
    {
        return m_time;
    };
};

const LONGLONG TimeZero = 0;

#endif /* __REFTIME__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\mtype.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Class that holds and manages media type information, December 1994

#ifndef __MTYPE__
#define __MTYPE__

/* Helper class that derived pin objects can use to compare media
   types etc. Has same data members as the struct AM_MEDIA_TYPE defined
   in the streams IDL file, but also has (non-virtual) functions */

class CMediaType : public _AMMediaType {

public:

    ~CMediaType();
    CMediaType();
    CMediaType(const GUID * majortype);
    CMediaType(const AM_MEDIA_TYPE&);
    CMediaType(const CMediaType&);

    CMediaType& operator=(const CMediaType&);
    CMediaType& operator=(const AM_MEDIA_TYPE&);

    BOOL operator == (const CMediaType&) const;
    BOOL operator != (const CMediaType&) const;

    BOOL IsValid() const;

    const GUID *Type() const { return &majortype;} ;
    void SetType(const GUID *);
    const GUID *Subtype() const { return &subtype;} ;
    void SetSubtype(const GUID *);

    BOOL IsFixedSize() const {return bFixedSizeSamples; };
    BOOL IsTemporalCompressed() const {return bTemporalCompression; };
    ULONG GetSampleSize() const;

    void SetSampleSize(ULONG sz);
    void SetVariableSize();
    void SetTemporalCompression(BOOL bCompressed);

    // read/write pointer to format - can't change length without
    // calling SetFormat, AllocFormatBuffer or ReallocFormatBuffer

    BYTE*   Format() const {return pbFormat; };
    ULONG   FormatLength() const { return cbFormat; };

    void SetFormatType(const GUID *);
    const GUID *FormatType() const {return &formattype; };
    BOOL SetFormat(BYTE *pFormat, ULONG length);
    void ResetFormatBuffer();
    BYTE* AllocFormatBuffer(ULONG length);
    BYTE* ReallocFormatBuffer(ULONG length);

    void InitMediaType();

    BOOL MatchesPartial(const CMediaType* ppartial) const;
    BOOL IsPartiallySpecified(void) const;
};


/* General purpose functions to copy and delete a task allocated AM_MEDIA_TYPE
   structure which is useful when using the IEnumMediaFormats interface as
   the implementation allocates the structures which you must later delete */

void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt);
AM_MEDIA_TYPE * WINAPI CreateMediaType(AM_MEDIA_TYPE const *pSrc);
void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource);
void WINAPI FreeMediaType(AM_MEDIA_TYPE& mt);

//  Initialize a media type from a WAVEFORMATEX

STDAPI CreateAudioMediaType(
    const WAVEFORMATEX *pwfx,
    AM_MEDIA_TYPE *pmt,
    BOOL bSetFormat);

#endif /* __MTYPE__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\renbase.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>        // ActiveMovie base class definitions
#include <mmsystem.h>       // Needed for definition of timeGetTime
#include <limits.h>         // Standard data type limit definitions
#include <measure.h>        // Used for time critical log functions

#pragma warning(disable:4355)

//  Helper function for clamping time differences
int inline TimeDiff(REFERENCE_TIME rt)
{
    if (rt < - (50 * UNITS)) {
        return -(50 * UNITS);
    } else
    if (rt > 50 * UNITS) {
        return 50 * UNITS;
    } else return (int)rt;
}

// Implements the CBaseRenderer class

CBaseRenderer::CBaseRenderer(REFCLSID RenderClass, // CLSID for this renderer
			     TCHAR *pName,         // Debug ONLY description
			     LPUNKNOWN pUnk,       // Aggregated owner object
			     HRESULT *phr) :       // General OLE return code

    CBaseFilter(pName,pUnk,&m_InterfaceLock,RenderClass),
    m_evComplete(TRUE),
    m_bAbort(FALSE),
    m_pPosition(NULL),
    m_ThreadSignal(TRUE),
    m_bStreaming(FALSE),
    m_bEOS(FALSE),
    m_bEOSDelivered(FALSE),
    m_pMediaSample(NULL),
    m_dwAdvise(0),
    m_pQSink(NULL),
    m_pInputPin(NULL),
    m_bRepaintStatus(TRUE),
    m_SignalTime(0),
    m_bInReceive(FALSE),
    m_EndOfStreamTimer(0)
{
    Ready();
#ifdef PERF
    m_idBaseStamp = MSR_REGISTER("BaseRenderer: sample time stamp");
    m_idBaseRenderTime = MSR_REGISTER("BaseRenderer: draw time (msec)");
    m_idBaseAccuracy = MSR_REGISTER("BaseRenderer: Accuracy (msec)");
#endif
}


// Delete the dynamically allocated IMediaPosition and IMediaSeeking helper
// object. The object is created when somebody queries us. These are standard
// control interfaces for seeking and setting start/stop positions and rates.
// We will probably also have made an input pin based on CRendererInputPin
// that has to be deleted, it's created when an enumerator calls our GetPin

CBaseRenderer::~CBaseRenderer()
{
    ASSERT(m_bStreaming == FALSE);
    ASSERT(m_EndOfStreamTimer == 0);
    StopStreaming();
    ClearPendingSample();

    // Delete any IMediaPosition implementation

    if (m_pPosition) {
	delete m_pPosition;
	m_pPosition = NULL;
    }

    // Delete any input pin created

    if (m_pInputPin) {
	delete m_pInputPin;
	m_pInputPin = NULL;
    }

    // Release any Quality sink

    ASSERT(m_pQSink == NULL);
}


// This returns the IMediaPosition and IMediaSeeking interfaces

HRESULT CBaseRenderer::GetMediaPositionInterface(REFIID riid,void **ppv)
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    if (m_pPosition) {
	return m_pPosition->NonDelegatingQueryInterface(riid,ppv);
    }

    HRESULT hr = NOERROR;

    // Create implementation of this dynamically since sometimes we may
    // never try and do a seek. The helper object implements a position
    // control interface (IMediaPosition) which in fact simply takes the
    // calls normally from the filter graph and passes them upstream

    m_pPosition = new CRendererPosPassThru(NAME("Renderer CPosPassThru"),
					   CBaseFilter::GetOwner(),
					   (HRESULT *) &hr,
					   GetPin(0));
    if (m_pPosition == NULL) {
	return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
	delete m_pPosition;
	m_pPosition = NULL;
	return E_NOINTERFACE;
    }
    return GetMediaPositionInterface(riid,ppv);
}


// Overriden to say what interfaces we support and where

STDMETHODIMP CBaseRenderer::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    // Do we have this interface

    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
	return GetMediaPositionInterface(riid,ppv);
    } else {
	return CBaseFilter::NonDelegatingQueryInterface(riid,ppv);
    }
}


// This is called whenever we change states, we have a manual reset event that
// is signalled whenever we don't won't the source filter thread to wait in us
// (such as in a stopped state) and likewise is not signalled whenever it can
// wait (during paused and running) this function sets or resets the thread
// event. The event is used to stop source filter threads waiting in Receive

HRESULT CBaseRenderer::SourceThreadCanWait(BOOL bCanWait)
{
    if (bCanWait == TRUE) {
	m_ThreadSignal.Reset();
    } else {
	m_ThreadSignal.Set();
    }
    return NOERROR;
}


#ifdef DEBUG
// Dump the current renderer state to the debug terminal. The hardest part of
// the renderer is the window where we unlock everything to wait for a clock
// to signal it is time to draw or for the application to cancel everything
// by stopping the filter. If we get things wrong we can leave the thread in
// WaitForRenderTime with no way for it to ever get out and we will deadlock

void CBaseRenderer::DisplayRendererState()
{
    DbgLog((LOG_TIMING, 1, TEXT("\nTimed out in WaitForRenderTime")));

    // No way should this be signalled at this point

    BOOL bSignalled = m_ThreadSignal.Check();
    DbgLog((LOG_TIMING, 1, TEXT("Signal sanity check %d"),bSignalled));

    // Now output the current renderer state variables

    DbgLog((LOG_TIMING, 1, TEXT("Filter state %d"),m_State));

    DbgLog((LOG_TIMING, 1, TEXT("Abort flag %d"),m_bAbort));

    DbgLog((LOG_TIMING, 1, TEXT("Streaming flag %d"),m_bStreaming));

    DbgLog((LOG_TIMING, 1, TEXT("Clock advise link %d"),m_dwAdvise));

    DbgLog((LOG_TIMING, 1, TEXT("Current media sample %x"),m_pMediaSample));

    DbgLog((LOG_TIMING, 1, TEXT("EOS signalled %d"),m_bEOS));

    DbgLog((LOG_TIMING, 1, TEXT("EOS delivered %d"),m_bEOSDelivered));

    DbgLog((LOG_TIMING, 1, TEXT("Repaint status %d"),m_bRepaintStatus));


    // Output the delayed end of stream timer information

    DbgLog((LOG_TIMING, 1, TEXT("End of stream timer %x"),m_EndOfStreamTimer));

    DbgLog((LOG_TIMING, 1, TEXT("Deliver time %s"),CDisp((LONGLONG)m_SignalTime)));


    // Should never timeout during a flushing state

    BOOL bFlushing = m_pInputPin->IsFlushing();
    DbgLog((LOG_TIMING, 1, TEXT("Flushing sanity check %d"),bFlushing));

    // Display the time we were told to start at
    DbgLog((LOG_TIMING, 1, TEXT("Last run time %s"),CDisp((LONGLONG)m_tStart.m_time)));

    // Have we got a reference clock
    if (m_pClock == NULL) return;

    // Get the current time from the wall clock

    CRefTime CurrentTime,StartTime,EndTime;
    m_pClock->GetTime((REFERENCE_TIME*) &CurrentTime);
    CRefTime Offset = CurrentTime - m_tStart;

    // Display the current time from the clock

    DbgLog((LOG_TIMING, 1, TEXT("Clock time %s"),CDisp((LONGLONG)CurrentTime.m_time)));

    DbgLog((LOG_TIMING, 1, TEXT("Time difference %dms"),Offset.Millisecs()));


    // Do we have a sample ready to render
    if (m_pMediaSample == NULL) return;

    m_pMediaSample->GetTime((REFERENCE_TIME*)&StartTime, (REFERENCE_TIME*)&EndTime);
    DbgLog((LOG_TIMING, 1, TEXT("Next sample stream times (Start %d End %d ms)"),
	   StartTime.Millisecs(),EndTime.Millisecs()));

    // Calculate how long it is until it is due for rendering
    CRefTime Wait = (m_tStart + StartTime) - CurrentTime;
    DbgLog((LOG_TIMING, 1, TEXT("Wait required %d ms"),Wait.Millisecs()));
}
#endif


// Wait until the clock sets the timer event or we're otherwise signalled. We
// set an arbitrary timeout for this wait and if it fires then we display the
// current renderer state on the debugger. It will often fire if the filter's
// left paused in an application however it may also fire during stress tests
// if the synchronisation with application seeks and state changes is faulty

#define RENDER_TIMEOUT 10000

HRESULT CBaseRenderer::WaitForRenderTime()
{
    HANDLE WaitObjects[] = { m_ThreadSignal, m_RenderEvent };
    DWORD Result = WAIT_TIMEOUT;

    // Wait for either the time to arrive or for us to be stopped

    OnWaitStart();
    while (Result == WAIT_TIMEOUT) {
	Result = WaitForMultipleObjects(2,WaitObjects,FALSE,RENDER_TIMEOUT);

#ifdef DEBUG
	if (Result == WAIT_TIMEOUT) DisplayRendererState();
#endif

    }
    OnWaitEnd();

    // We may have been awoken without the timer firing

    if (Result == WAIT_OBJECT_0) {
	return VFW_E_STATE_CHANGED;
    }

    SignalTimerFired();
    return NOERROR;
}


// Poll waiting for Receive to complete.  This really matters when
// Receive may set the palette and cause window messages
// The problem is that if we don't really wait for a renderer to
// stop processing we can deadlock waiting for a transform which
// is calling the renderer's Receive() method because the transform's
// Stop method doesn't know to process window messages to unblock
// the renderer's Receive processing
void CBaseRenderer::WaitForReceiveToComplete()
{
    for (;;) {
	if (!m_bInReceive) {
	    break;
	}

	MSG msg;
	//  Receive all interthread snedmessages
	PeekMessage(&msg, NULL, WM_NULL, WM_NULL, PM_NOREMOVE);

	Sleep(1);
    }

    // If the wakebit for QS_POSTMESSAGE is set, the PeekMessage call
    // above just cleared the changebit which will cause some messaging
    // calls to block (waitMessage, MsgWaitFor...) now.
    // Post a dummy message to set the QS_POSTMESSAGE bit again
    if (HIWORD(GetQueueStatus(QS_POSTMESSAGE)) & QS_POSTMESSAGE) {
	//  Send dummy message
	PostThreadMessage(GetCurrentThreadId(), WM_NULL, 0, 0);
    }
}

// A filter can have four discrete states, namely Stopped, Running, Paused,
// Intermediate. We are in an intermediate state if we are currently trying
// to pause but haven't yet got the first sample (or if we have been flushed
// in paused state and therefore still have to wait for a sample to arrive)

// This class contains an event called m_evComplete which is signalled when
// the current state is completed and is not signalled when we are waiting to
// complete the last state transition. As mentioned above the only time we
// use this at the moment is when we wait for a media sample in paused state
// If while we are waiting we receive an end of stream notification from the
// source filter then we know no data is imminent so we can reset the event
// This means that when we transition to paused the source filter must call
// end of stream on us or send us an image otherwise we'll hang indefinately


// Simple internal way of getting the real state

FILTER_STATE CBaseRenderer::GetRealState() {
    return m_State;
}


// The renderer doesn't complete the full transition to paused states until
// it has got one media sample to render. If you ask it for its state while
// it's waiting it will return the state along with VFW_S_STATE_INTERMEDIATE

STDMETHODIMP CBaseRenderer::GetState(DWORD dwMSecs,FILTER_STATE *State)
{
    CheckPointer(State,E_POINTER);

    if (WaitDispatchingMessages(m_evComplete, dwMSecs) == WAIT_TIMEOUT) {
	*State = m_State;
	return VFW_S_STATE_INTERMEDIATE;
    }
    *State = m_State;
    return NOERROR;
}


// If we're pausing and we have no samples we don't complete the transition
// to State_Paused and we return S_FALSE. However if the m_bAbort flag has
// been set then all samples are rejected so there is no point waiting for
// one. If we do have a sample then return NOERROR. We will only ever return
// VFW_S_STATE_INTERMEDIATE from GetState after being paused with no sample
// (calling GetState after either being stopped or Run will NOT return this)

HRESULT CBaseRenderer::CompleteStateChange(FILTER_STATE OldState)
{
    // Allow us to be paused when disconnected

    if (m_pInputPin->IsConnected() == FALSE) {
	Ready();
	return S_OK;
    }

    // Have we run off the end of stream

    if (IsEndOfStream() == TRUE) {
	Ready();
	return S_OK;
    }

    // Make sure we get fresh data after being stopped

    if (HaveCurrentSample() == TRUE) {
	if (OldState != State_Stopped) {
	    Ready();
	    return S_OK;
	}
    }
    NotReady();
    return S_FALSE;
}


// When we stop the filter the things we do are:-

//      Decommit the allocator being used in the connection
//      Release the source filter if it's waiting in Receive
//      Cancel any advise link we set up with the clock
//      Any end of stream signalled is now obsolete so reset
//      Allow us to be stopped when we are not connected

STDMETHODIMP CBaseRenderer::Stop()
{
    CAutoLock cRendererLock(&m_InterfaceLock);

    // Make sure there really is a state change

    if (m_State == State_Stopped) {
	return NOERROR;
    }

    // Is our input pin connected

    if (m_pInputPin->IsConnected() == FALSE) {
	NOTE("Input pin is not connected");
	m_State = State_Stopped;
	return NOERROR;
    }

    CBaseFilter::Stop();

    // If we are going into a stopped state then we must decommit whatever
    // allocator we are using it so that any source filter waiting in the
    // GetBuffer can be released and unlock themselves for a state change

    if (m_pInputPin->Allocator()) {
	m_pInputPin->Allocator()->Decommit();
    }

    // Cancel any scheduled rendering

    SetRepaintStatus(TRUE);
    StopStreaming();
    SourceThreadCanWait(FALSE);
    ResetEndOfStream();
    CancelNotification();

    // There should be no outstanding clock advise
    ASSERT(CancelNotification() == S_FALSE);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(m_EndOfStreamTimer == 0);

    Ready();
    WaitForReceiveToComplete();
    m_bAbort = FALSE;
    return NOERROR;
}


// When we pause the filter the things we do are:-

//      Commit the allocator being used in the connection
//      Allow a source filter thread to wait in Receive
//      Cancel any clock advise link (we may be running)
//      Possibly complete the state change if we have data
//      Allow us to be paused when we are not connected

STDMETHODIMP CBaseRenderer::Pause()
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    FILTER_STATE OldState = m_State;
    ASSERT(m_pInputPin->IsFlushing() == FALSE);

    // Make sure there really is a state change

    if (m_State == State_Paused) {
	return CompleteStateChange(State_Paused);
    }

    // Has our input pin been connected

    if (m_pInputPin->IsConnected() == FALSE) {
	NOTE("Input pin is not connected");
	m_State = State_Paused;
	return CompleteStateChange(State_Paused);
    }

    // Pause the base filter class

    HRESULT hr = CBaseFilter::Pause();
    if (FAILED(hr)) {
	NOTE("Pause failed");
	return hr;
    }

    // Enable EC_REPAINT events again

    SetRepaintStatus(TRUE);
    StopStreaming();
    SourceThreadCanWait(TRUE);
    CancelNotification();
    ResetEndOfStreamTimer();

    // If we are going into a paused state then we must commit whatever
    // allocator we are using it so that any source filter can call the
    // GetBuffer and expect to get a buffer without returning an error

    if (m_pInputPin->Allocator()) {
	m_pInputPin->Allocator()->Commit();
    }

    // There should be no outstanding advise
    ASSERT(CancelNotification() == S_FALSE);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(m_EndOfStreamTimer == 0);
    ASSERT(m_pInputPin->IsFlushing() == FALSE);

    // When we come out of a stopped state we must clear any image we were
    // holding onto for frame refreshing. Since renderers see state changes
    // first we can reset ourselves ready to accept the source thread data
    // Paused or running after being stopped causes the current position to
    // be reset so we're not interested in passing end of stream signals

    if (OldState == State_Stopped) {
	m_bAbort = FALSE;
	ClearPendingSample();
    }
    return CompleteStateChange(OldState);
}


// When we run the filter the things we do are:-

//      Commit the allocator being used in the connection
//      Allow a source filter thread to wait in Receive
//      Signal the render event just to get us going
//      Start the base class by calling StartStreaming
//      Allow us to be run when we are not connected
//      Signal EC_COMPLETE if we are not connected

STDMETHODIMP CBaseRenderer::Run(REFERENCE_TIME StartTime)
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    FILTER_STATE OldState = m_State;

    // Make sure there really is a state change

    if (m_State == State_Running) {
	return NOERROR;
    }

    // Send EC_COMPLETE if we're not connected

    if (m_pInputPin->IsConnected() == FALSE) {
	NotifyEvent(EC_COMPLETE,S_OK,(LONG_PTR)(IBaseFilter *)this);
	m_State = State_Running;
	return NOERROR;
    }

    Ready();

    // Pause the base filter class

    HRESULT hr = CBaseFilter::Run(StartTime);
    if (FAILED(hr)) {
	NOTE("Run failed");
	return hr;
    }

    // Allow the source thread to wait
    ASSERT(m_pInputPin->IsFlushing() == FALSE);
    SourceThreadCanWait(TRUE);
    SetRepaintStatus(FALSE);

    // There should be no outstanding advise
    ASSERT(CancelNotification() == S_FALSE);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(m_EndOfStreamTimer == 0);
    ASSERT(m_pInputPin->IsFlushing() == FALSE);

    // If we are going into a running state then we must commit whatever
    // allocator we are using it so that any source filter can call the
    // GetBuffer and expect to get a buffer without returning an error

    if (m_pInputPin->Allocator()) {
	m_pInputPin->Allocator()->Commit();
    }

    // When we come out of a stopped state we must clear any image we were
    // holding onto for frame refreshing. Since renderers see state changes
    // first we can reset ourselves ready to accept the source thread data
    // Paused or running after being stopped causes the current position to
    // be reset so we're not interested in passing end of stream signals

    if (OldState == State_Stopped) {
	m_bAbort = FALSE;
	ClearPendingSample();
    }
    return StartStreaming();
}


// Return the number of input pins we support

int CBaseRenderer::GetPinCount()
{
    return 1;
}


// We only support one input pin and it is numbered zero

CBasePin *CBaseRenderer::GetPin(int n)
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    HRESULT hr = NOERROR;
    ASSERT(n == 0);

    // Should only ever be called with zero

    if (n != 0) {
	return NULL;
    }

    // Create the input pin if not already done so

    if (m_pInputPin == NULL) {
	m_pInputPin = new CRendererInputPin(this,&hr,L"In");
    }
    return m_pInputPin;
}


// If "In" then return the IPin for our input pin, otherwise NULL and error

STDMETHODIMP CBaseRenderer::FindPin(LPCWSTR Id, IPin **ppPin)
{
    CheckPointer(ppPin,E_POINTER);

    if (0==lstrcmpW(Id,L"In")) {
	*ppPin = GetPin(0);
	ASSERT(*ppPin);
	(*ppPin)->AddRef();
    } else {
	*ppPin = NULL;
	return VFW_E_NOT_FOUND;
    }
    return NOERROR;
}


// Called when the input pin receives an EndOfStream notification. If we have
// not got a sample, then notify EC_COMPLETE now. If we have samples, then set
// m_bEOS and check for this on completing samples. If we're waiting to pause
// then complete the transition to paused state by setting the state event

HRESULT CBaseRenderer::EndOfStream()
{
    // Ignore these calls if we are stopped

    if (m_State == State_Stopped) {
	return NOERROR;
    }

    // If we have a sample then wait for it to be rendered

    m_bEOS = TRUE;
    if (m_pMediaSample) {
	return NOERROR;
    }

    // If we are waiting for pause then we are now ready since we cannot now
    // carry on waiting for a sample to arrive since we are being told there
    // won't be any. This sets an event that the GetState function picks up

    Ready();

    // Only signal completion now if we are running otherwise queue it until
    // we do run in StartStreaming. This is used when we seek because a seek
    // causes a pause where early notification of completion is misleading

    if (m_bStreaming) {
	SendEndOfStream();
    }
    return NOERROR;
}


// When we are told to flush we should release the source thread

HRESULT CBaseRenderer::BeginFlush()
{
    // If paused then report state intermediate until we get some data

    if (m_State == State_Paused) {
	NotReady();
    }

    SourceThreadCanWait(FALSE);
    CancelNotification();
    ClearPendingSample();
    //  Wait for Receive to complete
    WaitForReceiveToComplete();
    return NOERROR;
}


// After flushing the source thread can wait in Receive again

HRESULT CBaseRenderer::EndFlush()
{
    // Reset the current sample media time
    if (m_pPosition) m_pPosition->ResetMediaTime();

    // There should be no outstanding advise

    ASSERT(CancelNotification() == S_FALSE);
    SourceThreadCanWait(TRUE);
    return NOERROR;
}


// We can now send EC_REPAINTs if so required

HRESULT CBaseRenderer::CompleteConnect(IPin *pReceivePin)
{
    SetRepaintStatus(TRUE);
    m_bAbort = FALSE;
    return NOERROR;
}


// Called when we go paused or running

HRESULT CBaseRenderer::Active()
{
    return NOERROR;
}


// Called when we go into a stopped state

HRESULT CBaseRenderer::Inactive()
{
    if (m_pPosition) {
	m_pPosition->ResetMediaTime();
    }
    //  People who derive from this may want to override this behaviour
    //  to keep hold of the sample in some circumstances
    ClearPendingSample();
    return NOERROR;
}


// Tell derived classes about the media type agreed

HRESULT CBaseRenderer::SetMediaType(const CMediaType *pmt)
{
    return NOERROR;
}


// When we break the input pin connection we should reset the EOS flags. When
// we are asked for either IMediaPosition or IMediaSeeking we will create a
// CPosPassThru object to handles media time pass through. When we're handed
// samples we store (by calling CPosPassThru::RegisterMediaTime) their media
// times so we can then return a real current position of data being rendered

HRESULT CBaseRenderer::BreakConnect()
{
    // Do we have a quality management sink

    if (m_pQSink) {
	m_pQSink->Release();
	m_pQSink = NULL;
    }

    // Check we have a valid connection

    if (m_pInputPin->IsConnected() == FALSE) {
	return S_FALSE;
    }

    // Check we are stopped before disconnecting

    if (m_State != State_Stopped) {
	return VFW_E_NOT_STOPPED;
    }

    SetRepaintStatus(FALSE);
    ResetEndOfStream();
    ClearPendingSample();
    m_bAbort = FALSE;
    return NOERROR;
}


// Retrieves the sample times for this samples (note the sample times are
// passed in by reference not value). We return S_FALSE to say schedule this
// sample according to the times on the sample. We also return S_OK in
// which case the object should simply render the sample data immediately

HRESULT CBaseRenderer::GetSampleTimes(IMediaSample *pMediaSample,
				      REFERENCE_TIME *pStartTime,
				      REFERENCE_TIME *pEndTime)
{
    ASSERT(m_dwAdvise == 0);
    ASSERT(pMediaSample);

    // If the stop time for this sample is before or the same as start time,
    // then just ignore it (release it) and schedule the next one in line
    // Source filters should always fill in the start and end times properly!

    if (SUCCEEDED(pMediaSample->GetTime(pStartTime, pEndTime))) {
	if (*pEndTime < *pStartTime) {
	    return VFW_E_START_TIME_AFTER_END;
	}
    } else {
	// no time set in the sample... draw it now?
	return S_OK;
    }

    // Can't synchronise without a clock so we return S_OK which tells the
    // caller that the sample should be rendered immediately without going
    // through the overhead of setting a timer advise link with the clock

    if (m_pClock == NULL) {
	return S_OK;
    }
    return ShouldDrawSampleNow(pMediaSample,pStartTime,pEndTime);
}


// By default all samples are drawn according to their time stamps so we
// return S_FALSE. Returning S_OK means draw immediately, this is used
// by the derived video renderer class in its quality management.

HRESULT CBaseRenderer::ShouldDrawSampleNow(IMediaSample *pMediaSample,
					   REFERENCE_TIME *ptrStart,
					   REFERENCE_TIME *ptrEnd)
{
    return S_FALSE;
}


// We must always reset the current advise time to zero after a timer fires
// because there are several possible ways which lead us not to do any more
// scheduling such as the pending image being cleared after state changes

void CBaseRenderer::SignalTimerFired()
{
    m_dwAdvise = 0;
}


// Cancel any notification currently scheduled. This is called by the owning
// window object when it is told to stop streaming. If there is no timer link
// outstanding then calling this is benign otherwise we go ahead and cancel
// We must always reset the render event as the quality management code can
// signal immediate rendering by setting the event without setting an advise
// link. If we're subsequently stopped and run the first attempt to setup an
// advise link with the reference clock will find the event still signalled

HRESULT CBaseRenderer::CancelNotification()
{
    ASSERT(m_dwAdvise == 0 || m_pClock);
    DWORD_PTR dwAdvise = m_dwAdvise;

    // Have we a live advise link

    if (m_dwAdvise) {
	m_pClock->Unadvise(m_dwAdvise);
	SignalTimerFired();
	ASSERT(m_dwAdvise == 0);
    }

    // Clear the event and return our status

    m_RenderEvent.Reset();
    return (dwAdvise ? S_OK : S_FALSE);
}


// Responsible for setting up one shot advise links with the clock
// Return FALSE if the sample is to be dropped (not drawn at all)
// Return TRUE if the sample is to be drawn and in this case also
// arrange for m_RenderEvent to be set at the appropriate time

BOOL CBaseRenderer::ScheduleSample(IMediaSample *pMediaSample)
{
    REFERENCE_TIME StartSample, EndSample;

    // Is someone pulling our leg

    if (pMediaSample == NULL) {
	return FALSE;
    }

    // Get the next sample due up for rendering.  If there aren't any ready
    // then GetNextSampleTimes returns an error.  If there is one to be done
    // then it succeeds and yields the sample times. If it is due now then
    // it returns S_OK other if it's to be done when due it returns S_FALSE

    HRESULT hr = GetSampleTimes(pMediaSample, &StartSample, &EndSample);
    if (FAILED(hr)) {
	return FALSE;
    }

    // If we don't have a reference clock then we cannot set up the advise
    // time so we simply set the event indicating an image to render. This
    // will cause us to run flat out without any timing or synchronisation

    if (hr == S_OK) {
	EXECUTE_ASSERT(SetEvent((HANDLE) m_RenderEvent));
	return TRUE;
    }

    ASSERT(m_dwAdvise == 0);
    ASSERT(m_pClock);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));

    // We do have a valid reference clock interface so we can ask it to
    // set an event when the image comes due for rendering. We pass in
    // the reference time we were told to start at and also the current
    // stream time which is the offset from the start reference time

    hr = m_pClock->AdviseTime(
	    (REFERENCE_TIME) m_tStart,          // Start run time
	    StartSample,                        // Stream time
	    (HEVENT)(HANDLE) m_RenderEvent,     // Render notification
	    &m_dwAdvise);                       // Advise cookie

    if (SUCCEEDED(hr)) {
	return TRUE;
    }

    // We could not schedule the next sample for rendering despite the fact
    // we have a valid sample here. This is a fair indication that either
    // the system clock is wrong or the time stamp for the sample is duff

    ASSERT(m_dwAdvise == 0);
    return FALSE;
}


// This is called when a sample comes due for rendering. We pass the sample
// on to the derived class. After rendering we will initialise the timer for
// the next sample, NOTE signal that the last one fired first, if we don't
// do this it thinks there is still one outstanding that hasn't completed

HRESULT CBaseRenderer::Render(IMediaSample *pMediaSample)
{
    // If the media sample is NULL then we will have been notified by the
    // clock that another sample is ready but in the mean time someone has
    // stopped us streaming which causes the next sample to be released

    if (pMediaSample == NULL) {
	return S_FALSE;
    }

    // If we have stopped streaming then don't render any more samples, the
    // thread that got in and locked us and then reset this flag does not
    // clear the pending sample as we can use it to refresh any output device

    if (m_bStreaming == FALSE) {
	return S_FALSE;
    }

    // Time how long the rendering takes

    OnRenderStart(pMediaSample);
    DoRenderSample(pMediaSample);
    OnRenderEnd(pMediaSample);

    return NOERROR;
}


// Checks if there is a sample waiting at the renderer

BOOL CBaseRenderer::HaveCurrentSample()
{
    CAutoLock cRendererLock(&m_RendererLock);
    return (m_pMediaSample == NULL ? FALSE : TRUE);
}


// Returns the current sample waiting at the video renderer. We AddRef the
// sample before returning so that should it come due for rendering the
// person who called this method will hold the remaining reference count
// that will stop the sample being added back onto the allocator free list

IMediaSample *CBaseRenderer::GetCurrentSample()
{
    CAutoLock cRendererLock(&m_RendererLock);
    if (m_pMediaSample) {
	m_pMediaSample->AddRef();
    }
    return m_pMediaSample;
}


// Called when the source delivers us a sample. We go through a few checks to
// make sure the sample can be rendered. If we are running (streaming) then we
// have the sample scheduled with the reference clock, if we are not streaming
// then we have received an sample in paused mode so we can complete any state
// transition. On leaving this function everything will be unlocked so an app
// thread may get in and change our state to stopped (for example) in which
// case it will also signal the thread event so that our wait call is stopped

HRESULT CBaseRenderer::PrepareReceive(IMediaSample *pMediaSample)
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    m_bInReceive = TRUE;

    // Check our flushing and filter state

    HRESULT hr = m_pInputPin->CBaseInputPin::Receive(pMediaSample);

    if (hr != NOERROR) {
	m_bInReceive = FALSE;
	return E_FAIL;
    }

    // Has the type changed on a media sample. We do all rendering
    // synchronously on the source thread, which has a side effect
    // that only one buffer is ever outstanding. Therefore when we
    // have Receive called we can go ahead and change the format
    // Since the format change can cause a SendMessage we just don't
    // lock
    if (m_pInputPin->SampleProps()->pMediaType) {
	m_pInputPin->SetMediaType(
	    (CMediaType *)m_pInputPin->SampleProps()->pMediaType);
    }


    CAutoLock cSampleLock(&m_RendererLock);

    ASSERT(IsActive() == TRUE);
    ASSERT(m_pInputPin->IsFlushing() == FALSE);
    ASSERT(m_pInputPin->IsConnected() == TRUE);
    ASSERT(m_pMediaSample == NULL);

    // Return an error if we already have a sample waiting for rendering
    // source pins must serialise the Receive calls - we also check that
    // no data is being sent after the source signalled an end of stream

    if (m_pMediaSample || m_bEOS || m_bAbort) {
	Ready();
	m_bInReceive = FALSE;
	return E_UNEXPECTED;
    }

    // Store the media times from this sample
    if (m_pPosition) m_pPosition->RegisterMediaTime(pMediaSample);

    // Schedule the next sample if we are streaming

    if ((m_bStreaming == TRUE) && (ScheduleSample(pMediaSample) == FALSE)) {
	ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
	ASSERT(CancelNotification() == S_FALSE);
	m_bInReceive = FALSE;
	return VFW_E_SAMPLE_REJECTED;
    }

    // Store the sample end time for EC_COMPLETE handling
    m_SignalTime = m_pInputPin->SampleProps()->tStop;

    // BEWARE we sometimes keep the sample even after returning the thread to
    // the source filter such as when we go into a stopped state (we keep it
    // to refresh the device with) so we must AddRef it to keep it safely. If
    // we start flushing the source thread is released and any sample waiting
    // will be released otherwise GetBuffer may never return (see BeginFlush)

    m_pMediaSample = pMediaSample;
    m_pMediaSample->AddRef();

    if (m_bStreaming == FALSE) {
	SetRepaintStatus(TRUE);
    }
    return NOERROR;
}


// Called by the source filter when we have a sample to render. Under normal
// circumstances we set an advise link with the clock, wait for the time to
// arrive and then render the data using the PURE virtual DoRenderSample that
// the derived class will have overriden. After rendering the sample we may
// also signal EOS if it was the last one sent before EndOfStream was called

HRESULT CBaseRenderer::Receive(IMediaSample *pSample)
{
    ASSERT(pSample);

    // It may return VFW_E_SAMPLE_REJECTED code to say don't bother

    HRESULT hr = PrepareReceive(pSample);
    ASSERT(m_bInReceive == SUCCEEDED(hr));
    if (FAILED(hr)) {
	if (hr == VFW_E_SAMPLE_REJECTED) {
	    return NOERROR;
	}
	return hr;
    }

    // We realize the palette in "PrepareRender()" so we have to give away the
    // filter lock here.
    if (m_State == State_Paused) {
	PrepareRender();
	// no need to use InterlockedExchange
	m_bInReceive = FALSE;
	{
	    // We must hold both these locks
	    CAutoLock cRendererLock(&m_InterfaceLock);
	    if (m_State == State_Stopped)
		return NOERROR;
	    m_bInReceive = TRUE;
	    CAutoLock cSampleLock(&m_RendererLock);
	    OnReceiveFirstSample(pSample);
	}
	Ready();
    }
    // Having set an advise link with the clock we sit and wait. We may be
    // awoken by the clock firing or by a state change. The rendering call
    // will lock the critical section and check we can still render the data

    hr = WaitForRenderTime();
    if (FAILED(hr)) {
	m_bInReceive = FALSE;
	return NOERROR;
    }

    PrepareRender();

    //  Set this here and poll it until we work out the locking correctly
    //  It can't be right that the streaming stuff grabs the interface
    //  lock - after all we want to be able to wait for this stuff
    //  to complete
    m_bInReceive = FALSE;

    // We must hold both these locks
    CAutoLock cRendererLock(&m_InterfaceLock);

    // since we gave away the filter wide lock, the sate of the filter could
    // have chnaged to Stopped
    if (m_State == State_Stopped)
	return NOERROR;

    CAutoLock cSampleLock(&m_RendererLock);

    // Deal with this sample

    Render(m_pMediaSample);
    ClearPendingSample();
    SendEndOfStream();
    CancelNotification();
    return NOERROR;
}


// This is called when we stop or are inactivated to clear the pending sample
// We release the media sample interface so that they can be allocated to the
// source filter again, unless of course we are changing state to inactive in
// which case GetBuffer will return an error. We must also reset the current
// media sample to NULL so that we know we do not currently have an image

HRESULT CBaseRenderer::ClearPendingSample()
{
    CAutoLock cRendererLock(&m_RendererLock);
    if (m_pMediaSample) {
	m_pMediaSample->Release();
	m_pMediaSample = NULL;
    }
    return NOERROR;
}


// Used to signal end of stream according to the sample end time

void CALLBACK EndOfStreamTimer(UINT uID,        // Timer identifier
			       UINT uMsg,       // Not currently used
			       DWORD_PTR dwUser,// User information
			       DWORD_PTR dw1,   // Windows reserved
			       DWORD_PTR dw2)   // is also reserved
{
    CBaseRenderer *pRenderer = (CBaseRenderer *) dwUser;
    NOTE1("EndOfStreamTimer called (%d)",uID);
    pRenderer->TimerCallback();
}

//  Do the timer callback work
void CBaseRenderer::TimerCallback()
{
    //  Lock for synchronization (but don't hold this lock when calling
    //  timeKillEvent)
    CAutoLock cRendererLock(&m_RendererLock);

    // See if we should signal end of stream now

    if (m_EndOfStreamTimer) {
	m_EndOfStreamTimer = 0;
	SendEndOfStream();
    }
}


// If we are at the end of the stream signal the filter graph but do not set
// the state flag back to FALSE. Once we drop off the end of the stream we
// leave the flag set (until a subsequent ResetEndOfStream). Each sample we
// get delivered will update m_SignalTime to be the last sample's end time.
// We must wait this long before signalling end of stream to the filtergraph

#define TIMEOUT_DELIVERYWAIT 50
#define TIMEOUT_RESOLUTION 10

HRESULT CBaseRenderer::SendEndOfStream()
{
    ASSERT(CritCheckIn(&m_RendererLock));
    if (m_bEOS == FALSE || m_bEOSDelivered || m_EndOfStreamTimer) {
	return NOERROR;
    }

    // If there is no clock then signal immediately
    if (m_pClock == NULL) {
	return NotifyEndOfStream();
    }

    // How long into the future is the delivery time

    REFERENCE_TIME Signal = m_tStart + m_SignalTime;
    REFERENCE_TIME CurrentTime;
    m_pClock->GetTime(&CurrentTime);
    LONG Delay = LONG((Signal - CurrentTime) / 10000);

    // Dump the timing information to the debugger

    NOTE1("Delay until end of stream delivery %d",Delay);
    NOTE1("Current %s",(LPCTSTR)CDisp((LONGLONG)CurrentTime));
    NOTE1("Signal %s",(LPCTSTR)CDisp((LONGLONG)Signal));

    // Wait for the delivery time to arrive

    if (Delay < TIMEOUT_DELIVERYWAIT) {
	return NotifyEndOfStream();
    }

    // Signal a timer callback on another worker thread

    m_EndOfStreamTimer = timeSetEvent((UINT) Delay,       // Period of timer
				      TIMEOUT_RESOLUTION, // Timer resolution
				      EndOfStreamTimer,   // Callback function
				      DWORD_PTR(this),    // Used information
				      TIME_ONESHOT);      // Type of callback
    if (m_EndOfStreamTimer == 0) {
	return NotifyEndOfStream();
    }
    return NOERROR;
}


// Signals EC_COMPLETE to the filtergraph manager

HRESULT CBaseRenderer::NotifyEndOfStream()
{
    CAutoLock cRendererLock(&m_RendererLock);
    ASSERT(m_bEOS == TRUE);
    ASSERT(m_bEOSDelivered == FALSE);
    ASSERT(m_EndOfStreamTimer == 0);

    // Has the filter changed state

    if (m_bStreaming == FALSE) {
	ASSERT(m_EndOfStreamTimer == 0);
	return NOERROR;
    }

    // Reset the end of stream timer
    m_EndOfStreamTimer = 0;

    // If we've been using the IMediaPosition interface, set it's start
    // and end media "times" to the stop position by hand.  This ensures
    // that we actually get to the end, even if the MPEG guestimate has
    // been bad or if the quality management dropped the last few frames

    if (m_pPosition) m_pPosition->EOS();
    m_bEOSDelivered = TRUE;
    NOTE("Sending EC_COMPLETE...");
    return NotifyEvent(EC_COMPLETE,S_OK,(LONG_PTR)(IBaseFilter *)this);
}


// Reset the end of stream flag, this is typically called when we transfer to
// stopped states since that resets the current position back to the start so
// we will receive more samples or another EndOfStream if there aren't any. We
// keep two separate flags one to say we have run off the end of the stream
// (this is the m_bEOS flag) and another to say we have delivered EC_COMPLETE
// to the filter graph. We need the latter otherwise we can end up sending an
// EC_COMPLETE every time the source changes state and calls our EndOfStream

HRESULT CBaseRenderer::ResetEndOfStream()
{
    ResetEndOfStreamTimer();
    CAutoLock cRendererLock(&m_RendererLock);

    m_bEOS = FALSE;
    m_bEOSDelivered = FALSE;
    m_SignalTime = 0;

    return NOERROR;
}


// Kills any outstanding end of stream timer

void CBaseRenderer::ResetEndOfStreamTimer()
{
    ASSERT(CritCheckOut(&m_RendererLock));
    if (m_EndOfStreamTimer) {
	timeKillEvent(m_EndOfStreamTimer);
	m_EndOfStreamTimer = 0;
    }
}


// This is called when we start running so that we can schedule any pending
// image we have with the clock and display any timing information. If we
// don't have any sample but we have queued an EOS flag then we send it. If
// we do have a sample then we wait until that has been rendered before we
// signal the filter graph otherwise we may change state before it's done

HRESULT CBaseRenderer::StartStreaming()
{
    CAutoLock cRendererLock(&m_RendererLock);
    if (m_bStreaming == TRUE) {
	return NOERROR;
    }

    // Reset the streaming times ready for running

    m_bStreaming = TRUE;
    timeBeginPeriod(1);
    OnStartStreaming();

    // There should be no outstanding advise
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(CancelNotification() == S_FALSE);

    // If we have an EOS and no data then deliver it now

    if (m_pMediaSample == NULL) {
	return SendEndOfStream();
    }

    // Have the data rendered

    ASSERT(m_pMediaSample);
    if (!ScheduleSample(m_pMediaSample))
	m_RenderEvent.Set();
    
    return NOERROR;
}


// This is called when we stop streaming so that we can set our internal flag
// indicating we are not now to schedule any more samples arriving. The state
// change methods in the filter implementation take care of cancelling any
// clock advise link we have set up and clearing any pending sample we have

HRESULT CBaseRenderer::StopStreaming()
{
    CAutoLock cRendererLock(&m_RendererLock);
    m_bEOSDelivered = FALSE;

    if (m_bStreaming == TRUE) {
	m_bStreaming = FALSE;
	OnStopStreaming();
	timeEndPeriod(1);
    }
    return NOERROR;
}


// We have a boolean flag that is reset when we have signalled EC_REPAINT to
// the filter graph. We set this when we receive an image so that should any
// conditions arise again we can send another one. By having a flag we ensure
// we don't flood the filter graph with redundant calls. We do not set the
// event when we receive an EndOfStream call since there is no point in us
// sending further EC_REPAINTs. In particular the AutoShowWindow method and
// the DirectDraw object use this method to control the window repainting

void CBaseRenderer::SetRepaintStatus(BOOL bRepaint)
{
    CAutoLock cSampleLock(&m_RendererLock);
    m_bRepaintStatus = bRepaint;
}


// Pass the window handle to the upstream filter

void CBaseRenderer::SendNotifyWindow(IPin *pPin,HWND hwnd)
{
    IMediaEventSink *pSink;

    // Does the pin support IMediaEventSink
    HRESULT hr = pPin->QueryInterface(IID_IMediaEventSink,(void **)&pSink);
    if (SUCCEEDED(hr)) {
	pSink->Notify(EC_NOTIFY_WINDOW,LONG_PTR(hwnd),0);
	pSink->Release();
    }
    NotifyEvent(EC_NOTIFY_WINDOW,LONG_PTR(hwnd),0);
}


// Signal an EC_REPAINT to the filter graph. This can be used to have data
// sent to us. For example when a video window is first displayed it may
// not have an image to display, at which point it signals EC_REPAINT. The
// filtergraph will either pause the graph if stopped or if already paused
// it will call put_CurrentPosition of the current position. Setting the
// current position to itself has the stream flushed and the image resent

#define RLOG(_x_) DbgLog((LOG_TRACE,1,TEXT(_x_)));

void CBaseRenderer::SendRepaint()
{
    CAutoLock cSampleLock(&m_RendererLock);
    ASSERT(m_pInputPin);

    // We should not send repaint notifications when...
    //    - An end of stream has been notified
    //    - Our input pin is being flushed
    //    - The input pin is not connected
    //    - We have aborted a video playback
    //    - There is a repaint already sent

    if (m_bAbort == FALSE) {
	if (m_pInputPin->IsConnected() == TRUE) {
	    if (m_pInputPin->IsFlushing() == FALSE) {
		if (IsEndOfStream() == FALSE) {
		    if (m_bRepaintStatus == TRUE) {
			IPin *pPin = (IPin *) m_pInputPin;
			NotifyEvent(EC_REPAINT,(LONG_PTR) pPin,0);
			SetRepaintStatus(FALSE);
			RLOG("Sending repaint");
		    }
		}
	    }
	}
    }
}


// When a video window detects a display change (WM_DISPLAYCHANGE message) it
// can send an EC_DISPLAY_CHANGED event code along with the renderer pin. The
// filtergraph will stop everyone and reconnect our input pin. As we're then
// reconnected we can accept the media type that matches the new display mode
// since we may no longer be able to draw the current image type efficiently

BOOL CBaseRenderer::OnDisplayChange()
{
    // Ignore if we are not connected yet

    CAutoLock cSampleLock(&m_RendererLock);
    if (m_pInputPin->IsConnected() == FALSE) {
	return FALSE;
    }

    RLOG("Notification of EC_DISPLAY_CHANGE");

    // Pass our input pin as parameter on the event

    IPin *pPin = (IPin *) m_pInputPin;
    m_pInputPin->AddRef();
    NotifyEvent(EC_DISPLAY_CHANGED,(LONG_PTR) pPin,0);
    SetAbortSignal(TRUE);
    ClearPendingSample();
    m_pInputPin->Release();

    return TRUE;
}


// Called just before we start drawing.
// Store the current time in m_trRenderStart to allow the rendering time to be
// logged.  Log the time stamp of the sample and how late it is (neg is early)

void CBaseRenderer::OnRenderStart(IMediaSample *pMediaSample)
{
#ifdef PERF
    REFERENCE_TIME trStart, trEnd;
    pMediaSample->GetTime(&trStart, &trEnd);

    MSR_INTEGER(m_idBaseStamp, (int)trStart);     // dump low order 32 bits

    m_pClock->GetTime(&m_trRenderStart);
    MSR_INTEGER(0, (int)m_trRenderStart);
    REFERENCE_TIME trStream;
    trStream = m_trRenderStart-m_tStart;     // convert reftime to stream time
    MSR_INTEGER(0,(int)trStream);

    const int trLate = (int)(trStream - trStart);
    MSR_INTEGER(m_idBaseAccuracy, trLate/10000);  // dump in mSec
#endif

} // OnRenderStart


// Called directly after drawing an image.
// calculate the time spent drawing and log it.

void CBaseRenderer::OnRenderEnd(IMediaSample *pMediaSample)
{
#ifdef PERF
    REFERENCE_TIME trNow;
    m_pClock->GetTime(&trNow);
    MSR_INTEGER(0,(int)trNow);
    int t = (int)((trNow - m_trRenderStart)/10000);   // convert UNITS->msec
    MSR_INTEGER(m_idBaseRenderTime, t);
#endif
} // OnRenderEnd




// Constructor must be passed the base renderer object

CRendererInputPin::CRendererInputPin(CBaseRenderer *pRenderer,
				     HRESULT *phr,
				     LPCWSTR pPinName) :
    CBaseInputPin(NAME("Renderer pin"),
		  pRenderer,
		  &pRenderer->m_InterfaceLock,
		  (HRESULT *) phr,
		  pPinName)
{
    m_pRenderer = pRenderer;
    ASSERT(m_pRenderer);
}


// Signals end of data stream on the input pin

STDMETHODIMP CRendererInputPin::EndOfStream()
{
    CAutoLock cRendererLock(&m_pRenderer->m_InterfaceLock);
    CAutoLock cSampleLock(&m_pRenderer->m_RendererLock);

    // Make sure we're streaming ok

    HRESULT hr = CheckStreaming();
    if (hr != NOERROR) {
	return hr;
    }

    // Pass it onto the renderer

    hr = m_pRenderer->EndOfStream();
    if (SUCCEEDED(hr)) {
	hr = CBaseInputPin::EndOfStream();
    }
    return hr;
}


// Signals start of flushing on the input pin - we do the final reset end of
// stream with the renderer lock unlocked but with the interface lock locked
// We must do this because we call timeKillEvent, our timer callback method
// has to take the renderer lock to serialise our state. Therefore holding a
// renderer lock when calling timeKillEvent could cause a deadlock condition

STDMETHODIMP CRendererInputPin::BeginFlush()
{
    CAutoLock cRendererLock(&m_pRenderer->m_InterfaceLock);
    {
	CAutoLock cSampleLock(&m_pRenderer->m_RendererLock);
	CBaseInputPin::BeginFlush();
	m_pRenderer->BeginFlush();
    }
    return m_pRenderer->ResetEndOfStream();
}


// Signals end of flushing on the input pin

STDMETHODIMP CRendererInputPin::EndFlush()
{
    CAutoLock cRendererLock(&m_pRenderer->m_InterfaceLock);
    CAutoLock cSampleLock(&m_pRenderer->m_RendererLock);

    HRESULT hr = m_pRenderer->EndFlush();
    if (SUCCEEDED(hr)) {
	hr = CBaseInputPin::EndFlush();
    }
    return hr;
}


// Pass the sample straight through to the renderer object

STDMETHODIMP CRendererInputPin::Receive(IMediaSample *pSample)
{
    return m_pRenderer->Receive(pSample);
}


// Called when the input pin is disconnected

HRESULT CRendererInputPin::BreakConnect()
{
    HRESULT hr = m_pRenderer->BreakConnect();
    if (FAILED(hr)) {
	return hr;
    }
    return CBaseInputPin::BreakConnect();
}


// Called when the input pin is connected

HRESULT CRendererInputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = m_pRenderer->CompleteConnect(pReceivePin);
    if (FAILED(hr)) {
	return hr;
    }
    return CBaseInputPin::CompleteConnect(pReceivePin);
}


// Give the pin id of our one and only pin

STDMETHODIMP CRendererInputPin::QueryId(LPWSTR *Id)
{
    CheckPointer(Id,E_POINTER);

    *Id = (LPWSTR)CoTaskMemAlloc(8);
    if (*Id == NULL) {
       return E_OUTOFMEMORY;
    }
    lstrcpyW(*Id, L"In");
    return NOERROR;
}


// Will the filter accept this media type

HRESULT CRendererInputPin::CheckMediaType(const CMediaType *pmt)
{
    return m_pRenderer->CheckMediaType(pmt);
}


// Called when we go paused or running

HRESULT CRendererInputPin::Active()
{
    return m_pRenderer->Active();
}


// Called when we go into a stopped state

HRESULT CRendererInputPin::Inactive()
{
    return m_pRenderer->Inactive();
}


// Tell derived classes about the media type agreed

HRESULT CRendererInputPin::SetMediaType(const CMediaType *pmt)
{
    HRESULT hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr)) {
	return hr;
    }
    return m_pRenderer->SetMediaType(pmt);
}


// We do not keep an event object to use when setting up a timer link with
// the clock but are given a pointer to one by the owning object through the
// SetNotificationObject method - this must be initialised before starting
// We can override the default quality management process to have it always
// draw late frames, this is currently done by having the following registry
// key (actually an INI key) called DrawLateFrames set to 1 (default is 0)

const TCHAR AMQUALITY[] = TEXT("ActiveMovie");
const TCHAR DRAWLATEFRAMES[] = TEXT("DrawLateFrames");

CBaseVideoRenderer::CBaseVideoRenderer(
      REFCLSID RenderClass, // CLSID for this renderer
      TCHAR *pName,         // Debug ONLY description
      LPUNKNOWN pUnk,       // Aggregated owner object
      HRESULT *phr) :       // General OLE return code

    CBaseRenderer(RenderClass,pName,pUnk,phr),
    m_cFramesDropped(0),
    m_cFramesDrawn(0),
    m_bSupplierHandlingQuality(FALSE)
{
    ResetStreamingTimes();

#ifdef PERF
    m_idTimeStamp       = MSR_REGISTER("Frame time stamp");
    m_idEarliness       = MSR_REGISTER("Earliness fudge");
    m_idTarget          = MSR_REGISTER("Target (mSec)");
    m_idSchLateTime     = MSR_REGISTER("mSec late when scheduled");
    m_idDecision        = MSR_REGISTER("Scheduler decision code");
    m_idQualityRate     = MSR_REGISTER("Quality rate sent");
    m_idQualityTime     = MSR_REGISTER("Quality time sent");
    m_idWaitReal        = MSR_REGISTER("Render wait");
    // m_idWait            = MSR_REGISTER("wait time recorded (msec)");
    m_idFrameAccuracy   = MSR_REGISTER("Frame accuracy (msecs)");
    m_bDrawLateFrames = GetProfileInt(AMQUALITY, DRAWLATEFRAMES, FALSE);
    //m_idSendQuality      = MSR_REGISTER("Processing Quality message");

    m_idRenderAvg       = MSR_REGISTER("Render draw time Avg");
    m_idFrameAvg        = MSR_REGISTER("FrameAvg");
    m_idWaitAvg         = MSR_REGISTER("WaitAvg");
    m_idDuration        = MSR_REGISTER("Duration");
    m_idThrottle        = MSR_REGISTER("Audio-video throttle wait");
    // m_idDebug           = MSR_REGISTER("Debug stuff");
#endif // PERF
} // Constructor


// Destructor is just a placeholder

CBaseVideoRenderer::~CBaseVideoRenderer()
{
    ASSERT(m_dwAdvise == 0);
}


// The timing functions in this class are called by the window object and by
// the renderer's allocator.
// The windows object calls timing functions as it receives media sample
// images for drawing using GDI.
// The allocator calls timing functions when it starts passing DCI/DirectDraw
// surfaces which are not rendered in the same way; The decompressor writes
// directly to the surface with no separate rendering, so those code paths
// call direct into us.  Since we only ever hand out DCI/DirectDraw surfaces
// when we have allocated one and only one image we know there cannot be any
// conflict between the two.
//
// We use timeGetTime to return the timing counts we use (since it's relative
// performance we are interested in rather than absolute compared to a clock)
// The window object sets the accuracy of the system clock (normally 1ms) by
// calling timeBeginPeriod/timeEndPeriod when it changes streaming states


// Reset all times controlling streaming.
// Set them so that
// 1. Frames will not initially be dropped
// 2. The first frame will definitely be drawn (achieved by saying that there
//    has not ben a frame drawn for a long time).

HRESULT CBaseVideoRenderer::ResetStreamingTimes()
{
    m_trLastDraw = -1000;     // set up as first frame since ages (1 sec) ago
    m_tStreamingStart = timeGetTime();
    m_trRenderAvg = 0;
    m_trFrameAvg = -1;        // -1000 fps == "unset"
    m_trDuration = 0;         // 0 - strange value
    m_trRenderLast = 0;
    m_trWaitAvg = 0;
    m_tRenderStart = 0;
    m_cFramesDrawn = 0;
    m_cFramesDropped = 0;
    m_iTotAcc = 0;
    m_iSumSqAcc = 0;
    m_iSumSqFrameTime = 0;
    m_trFrame = 0;          // hygeine - not really needed
    m_trLate = 0;           // hygeine - not really needed
    m_iSumFrameTime = 0;
    m_nNormal = 0;
    m_trEarliness = 0;
    m_trTarget = -300000;  // 30mSec early
    m_trThrottle = 0;
    m_trRememberStampForPerf = 0;

#ifdef PERF
    m_trRememberFrameForPerf = 0;
#endif

    return NOERROR;
} // ResetStreamingTimes


// Reset all times controlling streaming. Note that we're now streaming. We
// don't need to set the rendering event to have the source filter released
// as it is done during the Run processing. When we are run we immediately
// release the source filter thread and draw any image waiting (that image
// may already have been drawn once as a poster frame while we were paused)

HRESULT CBaseVideoRenderer::OnStartStreaming()
{
    ResetStreamingTimes();
    return NOERROR;
} // OnStartStreaming


// Called at end of streaming.  Fixes times for property page report

HRESULT CBaseVideoRenderer::OnStopStreaming()
{
    m_tStreamingStart = timeGetTime()-m_tStreamingStart;
    return NOERROR;
} // OnStopStreaming


// Called when we start waiting for a rendering event.
// Used to update times spent waiting and not waiting.

void CBaseVideoRenderer::OnWaitStart()
{
    MSR_START(m_idWaitReal);
} // OnWaitStart


// Called when we are awoken from the wait in the window OR by our allocator
// when it is hanging around until the next sample is due for rendering on a
// DCI/DirectDraw surface. We add the wait time into our rolling average.
// We grab the interface lock so that we're serialised with the application
// thread going through the run code - which in due course ends up calling
// ResetStreaming times - possibly as we run through this section of code

void CBaseVideoRenderer::OnWaitEnd()
{
#ifdef PERF
    MSR_STOP(m_idWaitReal);
    // for a perf build we want to know just exactly how late we REALLY are.
    // even if this means that we have to look at the clock again.

    REFERENCE_TIME trRealStream;     // the real time now expressed as stream time.
#if 0
    m_pClock->GetTime(&trRealStream); // Calling clock here causes W95 deadlock!
#else
    // We will be discarding overflows like mad here!
    // This is wrong really because timeGetTime() can wrap but it's
    // only for PERF
    REFERENCE_TIME tr = timeGetTime()*10000;
    trRealStream = tr + m_llTimeOffset;
#endif
    trRealStream -= m_tStart;     // convert to stream time (this is a reftime)

    if (m_trRememberStampForPerf==0) {
	// This is probably the poster frame at the start, and it is not scheduled
	// in the usual way at all.  Just count it.  The rememberstamp gets set
	// in ShouldDrawSampleNow, so this does bogus frame recording until we
	// actually start playing.
	PreparePerformanceData(0, 0);
    } else {
	int trLate = (int)(trRealStream - m_trRememberStampForPerf);
	int trFrame = (int)(tr - m_trRememberFrameForPerf);
	PreparePerformanceData(trLate, trFrame);
    }
    m_trRememberFrameForPerf = tr;
#endif //PERF
} // OnWaitEnd


// Put data on one side that describes the lateness of the current frame.
// We don't yet know whether it will actually be drawn.  In direct draw mode,
// this decision is up to the filter upstream, and it could change its mind.
// The rules say that if it did draw it must call Receive().  One way or
// another we eventually get into either OnRenderStart or OnDirectRender and
// these both call RecordFrameLateness to update the statistics.

void CBaseVideoRenderer::PreparePerformanceData(int trLate, int trFrame)
{
    m_trLate = trLate;
    m_trFrame = trFrame;
} // PreparePerformanceData


// update the statistics:
// m_iTotAcc, m_iSumSqAcc, m_iSumSqFrameTime, m_iSumFrameTime, m_cFramesDrawn
// Note that because the properties page reports using these variables,
// 1. We need to be inside a critical section
// 2. They must all be updated together.  Updating the sums here and the count
// elsewhere can result in imaginary jitter (i.e. attempts to find square roots
// of negative numbers) in the property page code.

void CBaseVideoRenderer::RecordFrameLateness(int trLate, int trFrame)
{
    // Record how timely we are.
    int tLate = trLate/10000;

    // Best estimate of moment of appearing on the screen is average of
    // start and end draw times.  Here we have only the end time.  This may
    // tend to show us as spuriously late by up to 1/2 frame rate achieved.
    // Decoder probably monitors draw time.  We don't bother.
    MSR_INTEGER( m_idFrameAccuracy, tLate );

    // This is a hack - we can get frames that are ridiculously late
    // especially (at start-up) and they sod up the statistics.
    // So ignore things that are more than 1 sec off.
    if (tLate>1000 || tLate<-1000) {
	if (m_cFramesDrawn<=1) {
	    tLate = 0;
	} else if (tLate>0) {
	    tLate = 1000;
	} else {
	    tLate = -1000;
	}
    }
    // The very first frame often has a bogus time, so I'm just
    // not going to count it into the statistics.   ???
    if (m_cFramesDrawn>1) {
	m_iTotAcc += tLate;
	m_iSumSqAcc += (tLate*tLate);
    }

    // calculate inter-frame time.  Doesn't make sense for first frame
    // second frame suffers from bogus first frame stamp.
    if (m_cFramesDrawn>2) {
	int tFrame = trFrame/10000;    // convert to mSec else it overflows
		// This is a hack.  It can overflow anyway (a pause can cause
		// a very long inter-frame time) and it overflows at 2**31/10**7
		// or about 215 seconds i.e. 3min 35sec
	if (tFrame>1000||tFrame<0) tFrame = 1000;
	m_iSumSqFrameTime += tFrame*tFrame;
	ASSERT(m_iSumSqFrameTime>=0);
	m_iSumFrameTime += tFrame;
    }
    ++m_cFramesDrawn;

} // RecordFrameLateness


void CBaseVideoRenderer::ThrottleWait()
{
    if (m_trThrottle>0) {
	int iThrottle = m_trThrottle/10000;    // convert to mSec
	MSR_INTEGER( m_idThrottle, iThrottle);
        DbgLog((LOG_TRACE, 0, TEXT("Throttle %d ms"), iThrottle));
	Sleep(iThrottle);
    } else {
        Sleep(0);
    }
} // ThrottleWait


// Whenever a frame is rendered it goes though either OnRenderStart
// or OnDirectRender.  Data that are generated during ShouldDrawSample
// are added to the statistics by calling RecordFrameLateness from both
// these two places.

// Called in place of OnRenderStart..OnRenderEnd
// When a DirectDraw image is drawn
void CBaseVideoRenderer::OnDirectRender(IMediaSample *pMediaSample)
{
    int time = 0;
    m_trRenderAvg = 0;
    m_trRenderLast = 5000000;  // If we mode switch, we do NOT want this
			       // to inhibit the new average getting going!
			       // so we set it to half a second
    // MSR_INTEGER(m_idRenderAvg, m_trRenderAvg/10000);
    RecordFrameLateness(m_trLate, m_trFrame);
    ThrottleWait();
} // OnDirectRender


// Called just before we start drawing.  All we do is to get the current clock
// time (from the system) and return.  We have to store the start render time
// in a member variable because it isn't used until we complete the drawing
// The rest is just performance logging.

void CBaseVideoRenderer::OnRenderStart(IMediaSample *pMediaSample)
{
    RecordFrameLateness(m_trLate, m_trFrame);
    m_tRenderStart = timeGetTime();
} // OnRenderStart


// Called directly after drawing an image.  We calculate the time spent in the
// drawing code and if this doesn't appear to have any odd looking spikes in
// it then we add it to the current average draw time.  Measurement spikes may
// occur if the drawing thread is interrupted and switched to somewhere else.

void CBaseVideoRenderer::OnRenderEnd(IMediaSample *pMediaSample)
{
    // The renderer time can vary erratically if we are interrupted so we do
    // some smoothing to help get more sensible figures out but even that is
    // not enough as figures can go 9,10,9,9,83,9 and we must disregard 83

    int tr = (timeGetTime() - m_tRenderStart)*10000;   // convert mSec->UNITS
    if (tr < m_trRenderAvg*2 || tr < 2 * m_trRenderLast) {
	// DO_MOVING_AVG(m_trRenderAvg, tr);
	m_trRenderAvg = (tr + (AVGPERIOD-1)*m_trRenderAvg)/AVGPERIOD;
    }
    m_trRenderLast = tr;
    ThrottleWait();
} // OnRenderEnd


STDMETHODIMP CBaseVideoRenderer::SetSink( IQualityControl * piqc)
{

    m_pQSink = piqc;

    return NOERROR;
} // SetSink


STDMETHODIMP CBaseVideoRenderer::Notify( IBaseFilter * pSelf, Quality q)
{
    // NOTE:  We are NOT getting any locks here.  We could be called
    // asynchronously and possibly even on a time critical thread of
    // someone else's - so we do the minumum.  We only set one state
    // variable (an integer) and if that happens to be in the middle
    // of another thread reading it they will just get either the new
    // or the old value.  Locking would achieve no more than this.

    // It might be nice to check that we are being called from m_pGraph, but
    // it turns out to be a millisecond or so per throw!

    // This is heuristics, these numbers are aimed at being "what works"
    // rather than anything based on some theory.
    // We use a hyperbola because it's easy to calculate and it includes
    // a panic button asymptote (which we push off just to the left)
    // The throttling fits the following table (roughly)
    // Proportion   Throttle (msec)
    //     >=1000         0
    //        900         3
    //        800         7
    //        700        11
    //        600        17
    //        500        25
    //        400        35
    //        300        50
    //        200        72
    //        125       100
    //        100       112
    //         50       146
    //          0       200

    // (some evidence that we could go for a sharper kink - e.g. no throttling
    // until below the 750 mark - might give fractionally more frames on a
    // P60-ish machine).  The easy way to get these coefficients is to use
    // Renbase.xls follow the instructions therein using excel solver.

    if (q.Proportion>=1000) { m_trThrottle = 0; }
    else {
	// The DWORD is to make quite sure I get unsigned arithmetic
	// as the constant is between 2**31 and 2**32
	m_trThrottle = -330000 + (388880000/(q.Proportion+167));
    }
    return NOERROR;
} // Notify


// Send a message to indicate what our supplier should do about quality.
// Theory:
// What a supplier wants to know is "is the frame I'm working on NOW
// going to be late?".
// F1 is the frame at the supplier (as above)
// Tf1 is the due time for F1
// T1 is the time at that point (NOW!)
// Tr1 is the time that f1 WILL actually be rendered
// L1 is the latency of the graph for frame F1 = Tr1-T1
// D1 (for delay) is how late F1 will be beyond its due time i.e.
// D1 = (Tr1-Tf1) which is what the supplier really wants to know.
// Unfortunately Tr1 is in the future and is unknown, so is L1
//
// We could estimate L1 by its value for a previous frame,
// L0 = Tr0-T0 and work off
// D1' = ((T1+L0)-Tf1) = (T1 + (Tr0-T0) -Tf1)
// Rearranging terms:
// D1' = (T1-T0) + (Tr0-Tf1)
//       adding (Tf0-Tf0) and rearranging again:
//     = (T1-T0) + (Tr0-Tf0) + (Tf0-Tf1)
//     = (T1-T0) - (Tf1-Tf0) + (Tr0-Tf0)
// But (Tr0-Tf0) is just D0 - how late frame zero was, and this is the
// Late field in the quality message that we send.
// The other two terms just state what correction should be applied before
// using the lateness of F0 to predict the lateness of F1.
// (T1-T0) says how much time has actually passed (we have lost this much)
// (Tf1-Tf0) says how much time should have passed if we were keeping pace
// (we have gained this much).
//
// Suppliers should therefore work off:
//    Quality.Late + (T1-T0)  - (Tf1-Tf0)
// and see if this is "acceptably late" or even early (i.e. negative).
// They get T1 and T0 by polling the clock, they get Tf1 and Tf0 from
// the time stamps in the frames.  They get Quality.Late from us.
//

HRESULT CBaseVideoRenderer::SendQuality(REFERENCE_TIME trLate,
					REFERENCE_TIME trRealStream)
{
    Quality q;
    HRESULT hr;

    // If we are the main user of time, then report this as Flood/Dry.
    // If our suppliers are, then report it as Famine/Glut.
    //
    // We need to take action, but avoid hunting.  Hunting is caused by
    // 1. Taking too much action too soon and overshooting
    // 2. Taking too long to react (so averaging can CAUSE hunting).
    //
    // The reason why we use trLate as well as Wait is to reduce hunting;
    // if the wait time is coming down and about to go into the red, we do
    // NOT want to rely on some average which is only telling is that it used
    // to be OK once.

    q.TimeStamp = (REFERENCE_TIME)trRealStream;

    if (m_trFrameAvg<0) {
	q.Type = Famine;      // guess
    }
    // Is the greater part of the time taken bltting or something else
    else if (m_trFrameAvg > 2*m_trRenderAvg) {
	q.Type = Famine;                        // mainly other
    } else {
	q.Type = Flood;                         // mainly bltting
    }

    q.Proportion = 1000;               // default

    if (m_trFrameAvg<0) {
	// leave it alone - we don't know enough
    }
    else if ( trLate> 0 ) {
	// try to catch up over the next second
	// We could be Really, REALLY late, but rendering all the frames
	// anyway, just because it's so cheap.

	q.Proportion = 1000 - (int)((trLate)/(UNITS/1000));
	if (q.Proportion<500) {
	   q.Proportion = 500;      // don't go daft. (could've been negative!)
	} else {
	}

    } else if (  m_trWaitAvg>20000
	      && trLate<-20000
	      ){
	// Go cautiously faster - aim at 2mSec wait.
	if (m_trWaitAvg>=m_trFrameAvg) {
	    // This can happen because of some fudges.
	    // The waitAvg is how long we originally planned to wait
	    // The frameAvg is more honest.
	    // It means that we are spending a LOT of time waiting
	    q.Proportion = 2000;    // double.
	} else {
	    if (m_trFrameAvg+20000 > m_trWaitAvg) {
		q.Proportion
		    = 1000 * (m_trFrameAvg / (m_trFrameAvg + 20000 - m_trWaitAvg));
	    } else {
		// We're apparently spending more than the whole frame time waiting.
		// Assume that the averages are slightly out of kilter, but that we
		// are indeed doing a lot of waiting.  (This leg probably never
		// happens, but the code avoids any potential divide by zero).
		q.Proportion = 2000;
	    }
	}

	if (q.Proportion>2000) {
	    q.Proportion = 2000;    // don't go crazy.
	}
    }

    // Tell the supplier how late frames are when they get rendered
    // That's how late we are now.
    // If we are in directdraw mode then the guy upstream can see the drawing
    // times and we'll just report on the start time.  He can figure out any
    // offset to apply.  If we are in DIB Section mode then we will apply an
    // extra offset which is half of our drawing time.  This is usually small
    // but can sometimes be the dominant effect.  For this we will use the
    // average drawing time rather than the last frame.  If the last frame took
    // a long time to draw and made us late, that's already in the lateness
    // figure.  We should not add it in again unless we expect the next frame
    // to be the same.  We don't, we expect the average to be a better shot.
    // In direct draw mode the RenderAvg will be zero.

    q.Late = trLate + m_trRenderAvg/2;

    // log what we're doing
    MSR_INTEGER(m_idQualityRate, q.Proportion);
    MSR_INTEGER( m_idQualityTime, (int)q.Late / 10000 );

    // A specific sink interface may be set through IPin

    if (m_pQSink==NULL) {
	// Get our input pin's peer.  We send quality management messages
	// to any nominated receiver of these things (set in the IPin
	// interface), or else to our source filter.

	IQualityControl *pQC = NULL;
	IPin *pOutputPin = m_pInputPin->GetConnected();
	ASSERT(pOutputPin != NULL);

	// And get an AddRef'd quality control interface

	hr = pOutputPin->QueryInterface(IID_IQualityControl,(void**) &pQC);
	if (SUCCEEDED(hr)) {
	    m_pQSink = pQC;
	}
    }
    if (m_pQSink) {
	return m_pQSink->Notify(this,q);
    }

    return S_FALSE;

} // SendQuality


// We are called with a valid IMediaSample image to decide whether this is to
// be drawn or not.  There must be a reference clock in operation.
// Return S_OK if it is to be drawn Now (as soon as possible)
// Return S_FALSE if it is to be drawn when it's due
// Return an error if we want to drop it
// m_nNormal=-1 indicates that we dropped the previous frame and so this
// one should be drawn early.  Respect it and update it.
// Use current stream time plus a number of heuristics (detailed below)
// to make the decision

HRESULT CBaseVideoRenderer::ShouldDrawSampleNow(IMediaSample *pMediaSample,
						REFERENCE_TIME *ptrStart,
						REFERENCE_TIME *ptrEnd)
{

    // Don't call us unless there's a clock interface to synchronise with
    ASSERT(m_pClock);

    MSR_INTEGER(m_idTimeStamp, (int)((*ptrStart)>>32));   // high order 32 bits
    MSR_INTEGER(m_idTimeStamp, (int)(*ptrStart));         // low order 32 bits

    // We lose a bit of time depending on the monitor type waiting for the next
    // screen refresh.  On average this might be about 8mSec - so it will be
    // later than we think when the picture appears.  To compensate a bit
    // we bias the media samples by -8mSec i.e. 80000 UNITs.
    // We don't ever make a stream time negative (call it paranoia)
    if (*ptrStart>=80000) {
	*ptrStart -= 80000;
	*ptrEnd -= 80000;       // bias stop to to retain valid frame duration
    }

    // Cache the time stamp now.  We will want to compare what we did with what
    // we started with (after making the monitor allowance).
    m_trRememberStampForPerf = *ptrStart;

    // Get reference times (current and late)
    REFERENCE_TIME trRealStream;     // the real time now expressed as stream time.
    m_pClock->GetTime(&trRealStream);
#ifdef PERF
    // While the reference clock is expensive:
    // Remember the offset from timeGetTime and use that.
    // This overflows all over the place, but when we subtract to get
    // differences the overflows all cancel out.
    m_llTimeOffset = trRealStream-timeGetTime()*10000;
#endif
    trRealStream -= m_tStart;     // convert to stream time (this is a reftime)

    // We have to wory about two versions of "lateness".  The truth, which we
    // try to work out here and the one measured against m_trTarget which
    // includes long term feedback.  We report statistics against the truth
    // but for operational decisions we work to the target.
    // We use TimeDiff to make sure we get an integer because we
    // may actually be late (or more likely early if there is a big time
    // gap) by a very long time.
    const int trTrueLate = TimeDiff(trRealStream - *ptrStart);
    const int trLate = trTrueLate;

    MSR_INTEGER(m_idSchLateTime, trTrueLate/10000);

    // Send quality control messages upstream, measured against target
    HRESULT hr = SendQuality(trLate, trRealStream);
    // Note: the filter upstream is allowed to this FAIL meaning "you do it".
    m_bSupplierHandlingQuality = (hr==S_OK);

    // Decision time!  Do we drop, draw when ready or draw immediately?

    const int trDuration = (int)(*ptrEnd - *ptrStart);
    {
	// We need to see if the frame rate of the file has just changed.
	// This would make comparing our previous frame rate with the current
	// frame rate odd.  Hang on a moment though.  I've seen files
	// where the frames vary between 33 and 34 mSec so as to average
	// 30fps.  A minor variation like that won't hurt us.
	int t = m_trDuration/32;
	if (  trDuration > m_trDuration+t
	   || trDuration < m_trDuration-t
	   ) {
	    // There's a major variation.  Reset the average frame rate to
	    // exactly the current rate to disable decision 9002 for this frame,
	    // and remember the new rate.
	    m_trFrameAvg = trDuration;
	    m_trDuration = trDuration;
	}
    }

    MSR_INTEGER(m_idEarliness, m_trEarliness/10000);
    MSR_INTEGER(m_idRenderAvg, m_trRenderAvg/10000);
    MSR_INTEGER(m_idFrameAvg, m_trFrameAvg/10000);
    MSR_INTEGER(m_idWaitAvg, m_trWaitAvg/10000);
    MSR_INTEGER(m_idDuration, trDuration/10000);

#ifdef PERF
    if (S_OK==pMediaSample->IsDiscontinuity()) {
	MSR_INTEGER(m_idDecision, 9000);
    }
#endif

    // Control the graceful slide back from slow to fast machine mode.
    // After a frame drop accept an early frame and set the earliness to here
    // If this frame is already later than the earliness then slide it to here
    // otherwise do the standard slide (reduce by about 12% per frame).
    // Note: earliness is normally NEGATIVE
    BOOL bJustDroppedFrame
	= (  m_bSupplierHandlingQuality
	  //  Can't use the pin sample properties because we might
	  //  not be in Receive when we call this
	  && (S_OK == pMediaSample->IsDiscontinuity())          // he just dropped one
	  )
       || (m_nNormal==-1);                          // we just dropped one


    // Set m_trEarliness (slide back from slow to fast machine mode)
    if (trLate>0) {
	m_trEarliness = 0;   // we are no longer in fast machine mode at all!
    } else if (  (trLate>=m_trEarliness) || bJustDroppedFrame) {
	m_trEarliness = trLate;  // Things have slipped of their own accord
    } else {
	m_trEarliness = m_trEarliness - m_trEarliness/8;  // graceful slide
    }

    // prepare the new wait average - but don't pollute the old one until
    // we have finished with it.
    int trWaitAvg;
    {
	// We never mix in a negative wait.  This causes us to believe in fast machines
	// slightly more.
	int trL = trLate<0 ? -trLate : 0;
	trWaitAvg = (trL + m_trWaitAvg*(AVGPERIOD-1))/AVGPERIOD;
    }


    int trFrame;
    {
	REFERENCE_TIME tr = trRealStream - m_trLastDraw; // Cd be large - 4 min pause!
	if (tr>10000000) {
	    tr = 10000000;   // 1 second - arbitrarily.
	}
	trFrame = int(tr);
    }

    // We will DRAW this frame IF...
    if (
	  // ...the time we are spending drawing is a small fraction of the total
	  // observed inter-frame time so that dropping it won't help much.
	  (3*m_trRenderAvg <= m_trFrameAvg)

	 // ...or our supplier is NOT handling things and the next frame would
	 // be less timely than this one or our supplier CLAIMS to be handling
	 // things, and is now less than a full FOUR frames late.
       || ( m_bSupplierHandlingQuality
	  ? (trLate <= trDuration*4)
	  : (trLate+trLate < trDuration)
	  )

	  // ...or we are on average waiting for over eight milliseconds then
	  // this may be just a glitch.  Draw it and we'll hope to catch up.
       || (m_trWaitAvg > 80000)

	  // ...or we haven't drawn an image for over a second.  We will update
	  // the display, which stops the video looking hung.
	  // Do this regardless of how late this media sample is.
       || ((trRealStream - m_trLastDraw) > UNITS)

    ) {
	HRESULT Result;

	// We are going to play this frame.  We may want to play it early.
	// We will play it early if we think we are in slow machine mode.
	// If we think we are NOT in slow machine mode, we will still play
	// it early by m_trEarliness as this controls the graceful slide back.
	// and in addition we aim at being m_trTarget late rather than "on time".

	BOOL bPlayASAP = FALSE;

	// we will play it AT ONCE (slow machine mode) if...

	    // ...we are playing catch-up
	if ( bJustDroppedFrame) {
	    bPlayASAP = TRUE;
	    MSR_INTEGER(m_idDecision, 9001);
	}

	    // ...or if we are running below the true frame rate
	    // exact comparisons are glitchy, for these measurements,
	    // so add an extra 5% or so
	else if (  (m_trFrameAvg > trDuration + trDuration/16)

		   // It's possible to get into a state where we are losing ground, but
		   // are a very long way ahead.  To avoid this or recover from it
		   // we refuse to play early by more than 10 frames.
		&& (trLate > - trDuration*10)
		){
	    bPlayASAP = TRUE;
	    MSR_INTEGER(m_idDecision, 9002);
	}
#if 0
	    // ...or if we have been late and are less than one frame early
	else if (  (trLate + trDuration > 0)
		&& (m_trWaitAvg<=20000)
		) {
	    bPlayASAP = TRUE;
	    MSR_INTEGER(m_idDecision, 9003);
	}
#endif
	// We will NOT play it at once if we are grossly early.  On very slow frame
	// rate movies - e.g. clock.avi - it is not a good idea to leap ahead just
	// because we got starved (for instance by the net) and dropped one frame
	// some time or other.  If we are more than 900mSec early, then wait.
	if (trLate<-9000000) {
	    bPlayASAP = FALSE;
	}

	if (bPlayASAP) {

	    m_nNormal = 0;
	    MSR_INTEGER(m_idDecision, 0);
	    // When we are here, we are in slow-machine mode.  trLate may well
	    // oscillate between negative and positive when the supplier is
	    // dropping frames to keep sync.  We should not let that mislead
	    // us into thinking that we have as much as zero spare time!
	    // We just update with a zero wait.
	    m_trWaitAvg = (m_trWaitAvg*(AVGPERIOD-1))/AVGPERIOD;

	    // Assume that we draw it immediately.  Update inter-frame stats
	    m_trFrameAvg = (trFrame + m_trFrameAvg*(AVGPERIOD-1))/AVGPERIOD;
#ifndef PERF
	    // if this is NOT a perf build, then report what we know so far
	    // without looking at the clock any more.  This assumes that we
	    // actually wait for exactly the time we hope to.  it also reports
	    // how close we get to the hacked up time stamps that we now have
	    // rather than the ones we originally started with.  It will
	    // therefore be a little optimistic.  However it's fast.
	    PreparePerformanceData(trTrueLate, trFrame);
#endif
	    m_trLastDraw = trRealStream;
	    if (m_trEarliness > trLate) {
		m_trEarliness = trLate;  // if we are actually early, this is neg
	    }
	    Result = S_OK;                   // Draw it now

	} else {
	    ++m_nNormal;
	    // Set the average frame rate to EXACTLY the ideal rate.
	    // If we are exiting slow-machine mode then we will have caught up
	    // and be running ahead, so as we slide back to exact timing we will
	    // have a longer than usual gap at this point.  If we record this
	    // real gap then we'll think that we're running slow and go back
	    // into slow-machine mode and vever get it straight.
	    m_trFrameAvg = trDuration;
	    MSR_INTEGER(m_idDecision, 1);

	    // Play it early by m_trEarliness and by m_trTarget

	    {
		int trE = m_trEarliness;
                if (trE < -m_trFrameAvg) {
                    trE = -m_trFrameAvg;
                }
		*ptrStart += trE;           // N.B. earliness is negative
	    }

	    int Delay = -trTrueLate;
	    Result = Delay<=0 ? S_OK : S_FALSE;     // OK = draw now, FALSE = wait

	    m_trWaitAvg = trWaitAvg;

	    // Predict when it will actually be drawn and update frame stats

	    if (Result==S_FALSE) {   // We are going to wait
		trFrame = TimeDiff(*ptrStart-m_trLastDraw);
		m_trLastDraw = *ptrStart;
	    } else {
		// trFrame is already = trRealStream-m_trLastDraw;
		m_trLastDraw = trRealStream;
	    }
#ifndef PERF
	    int iAccuracy;
	    if (Delay>0) {
		// Report lateness based on when we intend to play it
		iAccuracy = TimeDiff(*ptrStart-m_trRememberStampForPerf);
	    } else {
		// Report lateness based on playing it *now*.
		iAccuracy = trTrueLate;     // trRealStream-RememberStampForPerf;
	    }
	    PreparePerformanceData(iAccuracy, trFrame);
#endif
	}
	return Result;
    }

    // We are going to drop this frame!
    // Of course in DirectDraw mode the guy upstream may draw it anyway.

    // This will probably give a large negative wack to the wait avg.
    m_trWaitAvg = trWaitAvg;

#ifdef PERF
    // Respect registry setting - debug only!
    if (m_bDrawLateFrames) {
       return S_OK;                        // draw it when it's ready
    }                                      // even though it's late.
#endif

    // We are going to drop this frame so draw the next one early
    // n.b. if the supplier is doing direct draw then he may draw it anyway
    // but he's doing something funny to arrive here in that case.

    MSR_INTEGER(m_idDecision, 2);
    m_nNormal = -1;
    return E_FAIL;                         // drop it

} // ShouldDrawSampleNow


// NOTE we're called by both the window thread and the source filter thread
// so we have to be protected by a critical section (locked before called)
// Also, when the window thread gets signalled to render an image, it always
// does so regardless of how late it is. All the degradation is done when we
// are scheduling the next sample to be drawn. Hence when we start an advise
// link to draw a sample, that sample's time will always become the last one
// drawn - unless of course we stop streaming in which case we cancel links

BOOL CBaseVideoRenderer::ScheduleSample(IMediaSample *pMediaSample)
{
    // We override ShouldDrawSampleNow to add quality management

    BOOL bDrawImage = CBaseRenderer::ScheduleSample(pMediaSample);
    if (bDrawImage == FALSE) {
	++m_cFramesDropped;
	return FALSE;
    }

    // m_cFramesDrawn must NOT be updated here.  It has to be updated
    // in RecordFrameLateness at the same time as the other statistics.
    return TRUE;
}


// Implementation of IQualProp interface needed to support the property page
// This is how the property page gets the data out of the scheduler. We are
// passed into the constructor the owning object in the COM sense, this will
// either be the video renderer or an external IUnknown if we're aggregated.
// We initialise our CUnknown base class with this interface pointer. Then
// all we have to do is to override NonDelegatingQueryInterface to expose
// our IQualProp interface. The AddRef and Release are handled automatically
// by the base class and will be passed on to the appropriate outer object

STDMETHODIMP CBaseVideoRenderer::get_FramesDroppedInRenderer(int *pcFramesDropped)
{
    CheckPointer(pcFramesDropped,E_POINTER);
    CAutoLock cVideoLock(&m_InterfaceLock);
    *pcFramesDropped = m_cFramesDropped;
    return NOERROR;
} // get_FramesDroppedInRenderer


// Set *pcFramesDrawn to the number of frames drawn since
// streaming started.

STDMETHODIMP CBaseVideoRenderer::get_FramesDrawn( int *pcFramesDrawn)
{
    CheckPointer(pcFramesDrawn,E_POINTER);
    CAutoLock cVideoLock(&m_InterfaceLock);
    *pcFramesDrawn = m_cFramesDrawn;
    return NOERROR;
} // get_FramesDrawn


// Set iAvgFrameRate to the frames per hundred secs since
// streaming started.  0 otherwise.

STDMETHODIMP CBaseVideoRenderer::get_AvgFrameRate( int *piAvgFrameRate)
{
    CheckPointer(piAvgFrameRate,E_POINTER);
    CAutoLock cVideoLock(&m_InterfaceLock);

    int t;
    if (m_bStreaming) {
	t = timeGetTime()-m_tStreamingStart;
    } else {
	t = m_tStreamingStart;
    }

    if (t<=0) {
	*piAvgFrameRate = 0;
	ASSERT(m_cFramesDrawn == 0);
    } else {
	// i is frames per hundred seconds
	*piAvgFrameRate = MulDiv(100000, m_cFramesDrawn, t);
    }
    return NOERROR;
} // get_AvgFrameRate


// Set *piAvg to the average sync offset since streaming started
// in mSec.  The sync offset is the time in mSec between when the frame
// should have been drawn and when the frame was actually drawn.

STDMETHODIMP CBaseVideoRenderer::get_AvgSyncOffset( int *piAvg)
{
    CheckPointer(piAvg,E_POINTER);
    CAutoLock cVideoLock(&m_InterfaceLock);

    if (NULL==m_pClock) {
	*piAvg = 0;
	return NOERROR;
    }

    // Note that we didn't gather the stats on the first frame
    // so we use m_cFramesDrawn-1 here
    if (m_cFramesDrawn<=1) {
	*piAvg = 0;
    } else {
	*piAvg = (int)(m_iTotAcc / (m_cFramesDrawn-1));
    }
    return NOERROR;
} // get_AvgSyncOffset


// To avoid dragging in the maths library - a cheap
// approximate integer square root.
// We do this by getting a starting guess which is between 1
// and 2 times too large, followed by THREE iterations of
// Newton Raphson.  (That will give accuracy to the nearest mSec
// for the range in question - roughly 0..1000)
//
// It would be faster to use a linear interpolation and ONE NR, but
// who cares.  If anyone does - the best linear interpolation is
// to approximates sqrt(x) by
// y = x * (sqrt(2)-1) + 1 - 1/sqrt(2) + 1/(8*(sqrt(2)-1))
// 0r y = x*0.41421 + 0.59467
// This minimises the maximal error in the range in question.
// (error is about +0.008883 and then one NR will give error .0000something
// (Of course these are integers, so you can't just multiply by 0.41421
// you'd have to do some sort of MulDiv).
// Anyone wanna check my maths?  (This is only for a property display!)

int isqrt(int x)
{
    int s = 1;
    // Make s an initial guess for sqrt(x)
    if (x > 0x40000000) {
       s = 0x8000;     // prevent any conceivable closed loop
    } else {
	while (s*s<x) {    // loop cannot possible go more than 31 times
	    s = 2*s;       // normally it goes about 6 times
	}
	// Three NR iterations.
	if (x==0) {
	   s= 0; // Wouldn't it be tragic to divide by zero whenever our
		 // accuracy was perfect!
	} else {
	    s = (s*s+x)/(2*s);
	    if (s>=0) s = (s*s+x)/(2*s);
	    if (s>=0) s = (s*s+x)/(2*s);
	}
    }
    return s;
}

//
//  Do estimates for standard deviations for per-frame
//  statistics
//
HRESULT CBaseVideoRenderer::GetStdDev(
    int nSamples,
    int *piResult,
    LONGLONG llSumSq,
    LONGLONG iTot
)
{
    CheckPointer(piResult,E_POINTER);
    CAutoLock cVideoLock(&m_InterfaceLock);

    if (NULL==m_pClock) {
	*piResult = 0;
	return NOERROR;
    }

    // If S is the Sum of the Squares of observations and
    //    T the Total (i.e. sum) of the observations and there were
    //    N observations, then an estimate of the standard deviation is
    //      sqrt( (S - T**2/N) / (N-1) )

    if (nSamples<=1) {
	*piResult = 0;
    } else {
	LONGLONG x;
	// First frames have bogus stamps, so we get no stats for them
	// So we need 2 frames to get 1 datum, so N is cFramesDrawn-1

	// so we use m_cFramesDrawn-1 here
	x = llSumSq - llMulDiv(iTot, iTot, nSamples, 0);
	x = x / (nSamples-1);
	ASSERT(x>=0);
	*piResult = isqrt((LONG)x);
    }
    return NOERROR;
}

// Set *piDev to the standard deviation in mSec of the sync offset
// of each frame since streaming started.

STDMETHODIMP CBaseVideoRenderer::get_DevSyncOffset( int *piDev)
{
    // First frames have bogus stamps, so we get no stats for them
    // So we need 2 frames to get 1 datum, so N is cFramesDrawn-1
    return GetStdDev(m_cFramesDrawn - 1,
		     piDev,
		     m_iSumSqAcc,
		     m_iTotAcc);
} // get_DevSyncOffset


// Set *piJitter to the standard deviation in mSec of the inter-frame time
// of frames since streaming started.

STDMETHODIMP CBaseVideoRenderer::get_Jitter( int *piJitter)
{
    // First frames have bogus stamps, so we get no stats for them
    // So second frame gives bogus inter-frame time
    // So we need 3 frames to get 1 datum, so N is cFramesDrawn-2
    return GetStdDev(m_cFramesDrawn - 2,
		     piJitter,
		     m_iSumSqFrameTime,
		     m_iSumFrameTime);
} // get_Jitter


// Overidden to return our IQualProp interface

STDMETHODIMP
CBaseVideoRenderer::NonDelegatingQueryInterface(REFIID riid,VOID **ppv)
{
    // We return IQualProp and delegate everything else

    if (riid == IID_IQualProp) {
	return GetInterface( (IQualProp *)this, ppv);
    } else if (riid == IID_IQualityControl) {
	return GetInterface( (IQualityControl *)this, ppv);
    }
    return CBaseRenderer::NonDelegatingQueryInterface(riid,ppv);
}


// Override JoinFilterGraph so that, just before leaving
// the graph we can send an EC_WINDOW_DESTROYED event

STDMETHODIMP
CBaseVideoRenderer::JoinFilterGraph(IFilterGraph *pGraph,LPCWSTR pName)
{
    // Since we send EC_ACTIVATE, we also need to ensure
    // we send EC_WINDOW_DESTROYED or the resource manager may be
    // holding us as a focus object
    if (!pGraph && m_pGraph) {

	// We were in a graph and now we're not
	// Do this properly in case we are aggregated
	IBaseFilter* pFilter;
	QueryInterface(IID_IBaseFilter,(void **) &pFilter);
	NotifyEvent(EC_WINDOW_DESTROYED, (LPARAM) pFilter, 0);
	pFilter->Release();
    }
    return CBaseFilter::JoinFilterGraph(pGraph, pName);
}


// This removes a large number of level 4 warnings from the
// Microsoft compiler which in this case are not very useful
#pragma warning(disable: 4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\mtype.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Class that holds and manages media type information, December 1994

// helper class that derived pin objects can use to compare media
// types etc. Has same data members as the struct AM_MEDIA_TYPE defined
// in the streams IDL file, but also has (non-virtual) functions

#include <streams.h>

CMediaType::~CMediaType(){
    FreeMediaType(*this);
}


CMediaType::CMediaType()
{
    InitMediaType();
}


CMediaType::CMediaType(const GUID * type)
{
    InitMediaType();
    majortype = *type;
}


// copy constructor does a deep copy of the format block

CMediaType::CMediaType(const AM_MEDIA_TYPE& rt)
{
    CopyMediaType(this, &rt);
}

CMediaType::CMediaType(const CMediaType& rt)
{
    CopyMediaType(this, &rt);
}

// this class inherits publicly from AM_MEDIA_TYPE so the compiler could generate
// the following assignment operator itself, however it could introduce some
// memory conflicts and leaks in the process because the structure contains
// a dynamically allocated block (pbFormat) which it will not copy correctly

CMediaType&
CMediaType::operator=(const AM_MEDIA_TYPE& rt)
{
    if (&rt != this) {
        FreeMediaType(*this);
        CopyMediaType(this, &rt);
    }
    return *this;
}


CMediaType&
CMediaType::operator=(const CMediaType& rt)
{
    *this = (AM_MEDIA_TYPE &) rt;
    return *this;
}

BOOL
CMediaType::operator == (const CMediaType& rt) const
{
    // I don't believe we need to check sample size or
    // temporal compression flags, since I think these must
    // be represented in the type, subtype and format somehow. They
    // are pulled out as separate flags so that people who don't understand
    // the particular format representation can still see them, but
    // they should duplicate information in the format block.

    return ((IsEqualGUID(majortype,rt.majortype) == TRUE) &&
        (IsEqualGUID(subtype,rt.subtype) == TRUE) &&
        (IsEqualGUID(formattype,rt.formattype) == TRUE) &&
        (cbFormat == rt.cbFormat) &&
        ( (cbFormat == 0) ||
          (memcmp(pbFormat, rt.pbFormat, cbFormat) == 0)));
}


BOOL
CMediaType::operator != (const CMediaType& rt) const
{
    /* Check to see if they are equal */

    if (*this == rt) {
        return FALSE;
    }
    return TRUE;
}


BOOL
CMediaType::IsValid() const
{
    return (!IsEqualGUID(majortype,GUID_NULL));
}


void
CMediaType::SetType(const GUID* ptype)
{
    majortype = *ptype;
}


void
CMediaType::SetSubtype(const GUID* ptype)
{
    subtype = *ptype;
}


ULONG
CMediaType::GetSampleSize() const {
    if (IsFixedSize()) {
        return lSampleSize;
    } else {
        return 0;
    }
}


void
CMediaType::SetSampleSize(ULONG sz) {
    if (sz == 0) {
        SetVariableSize();
    } else {
        bFixedSizeSamples = TRUE;
        lSampleSize = sz;
    }
}


void
CMediaType::SetVariableSize() {
    bFixedSizeSamples = FALSE;
}


void
CMediaType::SetTemporalCompression(BOOL bCompressed) {
    bTemporalCompression = bCompressed;
}

BOOL
CMediaType::SetFormat(BYTE * pformat, ULONG cb)
{
    if (NULL == AllocFormatBuffer(cb))
	return(FALSE);

    ASSERT(pbFormat);
    memcpy(pbFormat, pformat, cb);
    return(TRUE);
}


// set the type of the media type format block, this type defines what you
// will actually find in the format pointer. For example FORMAT_VideoInfo or
// FORMAT_WaveFormatEx. In the future this may be an interface pointer to a
// property set. Before sending out media types this should be filled in.

void
CMediaType::SetFormatType(const GUID *pformattype)
{
    formattype = *pformattype;
}


// reset the format buffer

void CMediaType::ResetFormatBuffer()
{
    if (cbFormat) {
        CoTaskMemFree((PVOID)pbFormat);
    }
    cbFormat = 0;
    pbFormat = NULL;
}


// allocate length bytes for the format and return a read/write pointer
// If we cannot allocate the new block of memory we return NULL leaving
// the original block of memory untouched (as does ReallocFormatBuffer)

BYTE*
CMediaType::AllocFormatBuffer(ULONG length)
{
    ASSERT(length);

    // do the types have the same buffer size

    if (cbFormat == length) {
        return pbFormat;
    }

    // allocate the new format buffer

    BYTE *pNewFormat = (PBYTE)CoTaskMemAlloc(length);
    if (pNewFormat == NULL) {
        if (length <= cbFormat) return pbFormat; //reuse the old block anyway.
        return NULL;
    }

    // delete the old format

    if (cbFormat != 0) {
        ASSERT(pbFormat);
        CoTaskMemFree((PVOID)pbFormat);
    }

    cbFormat = length;
    pbFormat = pNewFormat;
    return pbFormat;
}


// reallocate length bytes for the format and return a read/write pointer
// to it. We keep as much information as we can given the new buffer size
// if this fails the original format buffer is left untouched. The caller
// is responsible for ensuring the size of memory required is non zero

BYTE*
CMediaType::ReallocFormatBuffer(ULONG length)
{
    ASSERT(length);

    // do the types have the same buffer size

    if (cbFormat == length) {
        return pbFormat;
    }

    // allocate the new format buffer

    BYTE *pNewFormat = (PBYTE)CoTaskMemAlloc(length);
    if (pNewFormat == NULL) {
        if (length <= cbFormat) return pbFormat; //reuse the old block anyway.
        return NULL;
    }

    // copy any previous format (or part of if new is smaller)
    // delete the old format and replace with the new one

    if (cbFormat != 0) {
        ASSERT(pbFormat);
        memcpy(pNewFormat,pbFormat,min(length,cbFormat));
        CoTaskMemFree((PVOID)pbFormat);
    }

    cbFormat = length;
    pbFormat = pNewFormat;
    return pNewFormat;
}

// initialise a media type structure

void CMediaType::InitMediaType()
{
    ZeroMemory((PVOID)this, sizeof(*this));
    lSampleSize = 1;
    bFixedSizeSamples = TRUE;
}


// a partially specified media type can be passed to IPin::Connect
// as a constraint on the media type used in the connection.
// the type, subtype or format type can be null.
BOOL
CMediaType::IsPartiallySpecified(void) const
{
    if ((majortype == GUID_NULL) ||
        (formattype == GUID_NULL)) {
            return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
CMediaType::MatchesPartial(const CMediaType* ppartial) const
{
    if ((ppartial->majortype != GUID_NULL) &&
        (majortype != ppartial->majortype)) {
            return FALSE;
    }
    if ((ppartial->subtype != GUID_NULL) &&
        (subtype != ppartial->subtype)) {
            return FALSE;
    }

    if (ppartial->formattype != GUID_NULL) {
        // if the format block is specified then it must match exactly
        if (formattype != ppartial->formattype) {
            return FALSE;
        }
        if (cbFormat != ppartial->cbFormat) {
            return FALSE;
        }
        if ((cbFormat != 0) &&
            (memcmp(pbFormat, ppartial->pbFormat, cbFormat) != 0)) {
                return FALSE;
        }
    }

    return TRUE;

}



// general purpose function to delete a heap allocated AM_MEDIA_TYPE structure
// which is useful when calling IEnumMediaTypes::Next as the interface
// implementation allocates the structures which you must later delete
// the format block may also be a pointer to an interface to release

void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt)
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    FreeMediaType(*pmt);
    CoTaskMemFree((PVOID)pmt);
}


// this also comes in useful when using the IEnumMediaTypes interface so
// that you can copy a media type, you can do nearly the same by creating
// a CMediaType object but as soon as it goes out of scope the destructor
// will delete the memory it allocated (this takes a copy of the memory)

AM_MEDIA_TYPE * WINAPI CreateMediaType(AM_MEDIA_TYPE const *pSrc)
{
    ASSERT(pSrc);

    // Allocate a block of memory for the media type

    AM_MEDIA_TYPE *pMediaType =
        (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));

    if (pMediaType == NULL) {
        return NULL;
    }
    // Copy the variable length format block

    CopyMediaType(pMediaType,pSrc);

    return pMediaType;
}


//  Copy 1 media type to another

void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource)
{
    //  We'll leak if we copy onto one that already exists - there's one
    //  case we can check like that - copying to itself.
    ASSERT(pmtSource != pmtTarget);
    *pmtTarget = *pmtSource;
    if (pmtSource->cbFormat != 0) {
        ASSERT(pmtSource->pbFormat != NULL);
        pmtTarget->pbFormat = (PBYTE)CoTaskMemAlloc(pmtSource->cbFormat);
        if (pmtTarget->pbFormat == NULL) {
            pmtTarget->cbFormat = 0;
        } else {
            CopyMemory((PVOID)pmtTarget->pbFormat, (PVOID)pmtSource->pbFormat,
                       pmtTarget->cbFormat);
        }
    }
    if (pmtTarget->pUnk != NULL) {
        pmtTarget->pUnk->AddRef();
    }
}

//  Free an existing media type (ie free resources it holds)

void WINAPI FreeMediaType(AM_MEDIA_TYPE& mt)
{
    if (mt.cbFormat != 0) {
        CoTaskMemFree((PVOID)mt.pbFormat);

        // Strictly unnecessary but tidier
        mt.cbFormat = 0;
        mt.pbFormat = NULL;
    }
    if (mt.pUnk != NULL) {
        mt.pUnk->Release();
        mt.pUnk = NULL;
    }
}

//  Initialize a media type from a WAVEFORMATEX

STDAPI CreateAudioMediaType(
    const WAVEFORMATEX *pwfx,
    AM_MEDIA_TYPE *pmt,
    BOOL bSetFormat
)
{
    pmt->majortype            = MEDIATYPE_Audio;
    pmt->subtype              = FOURCCMap(pwfx->wFormatTag);
    pmt->formattype           = FORMAT_WaveFormatEx;
    pmt->bFixedSizeSamples    = TRUE;
    pmt->bTemporalCompression = FALSE;
    pmt->lSampleSize          = pwfx->nBlockAlign;
    pmt->pUnk                 = NULL;
    if (bSetFormat) {
        if (pwfx->wFormatTag == WAVE_FORMAT_PCM) {
            pmt->cbFormat         = sizeof(WAVEFORMATEX);
        } else {
            pmt->cbFormat         = sizeof(WAVEFORMATEX) + pwfx->cbSize;
        }
        pmt->pbFormat             = (PBYTE)CoTaskMemAlloc(pmt->cbFormat);
        if (pmt->pbFormat == NULL) {
            return E_OUTOFMEMORY;
        }
        if (pwfx->wFormatTag == WAVE_FORMAT_PCM) {
            CopyMemory(pmt->pbFormat, pwfx, sizeof(PCMWAVEFORMAT));
            ((WAVEFORMATEX *)pmt->pbFormat)->cbSize = 0;
        } else {
            CopyMemory(pmt->pbFormat, pwfx, pmt->cbFormat);
        }
    }
    return S_OK;
}

// eliminate very many spurious warnings from MS compiler
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\streams.h ===
// a smaller version of streams.h from the quartz tree.

#ifndef _STREAMS_
#define _STREAMS_

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

// #defines from sdk/classes/base/streams.h
#define AM_NOVTABLE __declspec(novtable) 
#define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))

#include <strmif.h>
#include <control.h>
#include <uuids.h>
#include <vfwmsgs.h>

#include "wxdebug.h"
#include "combase.h"
#include "dllsetup.h"
#include "reftime.h"
#include "amvideo.h"
#include "wxutil.h"
#include "wxlist.h"
#include "msgthrd.h"
#include "mtype.h"
#include "schedule.h"
#include "refclock.h"
#include "amfilter.h"
#include "evcode.h"
#include "fourcc.h"
#include "ctlutil.h"
#include "renbase.h"

#endif // _STREAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\seekpt.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#ifndef __seekpt_h__
#define __seekpt_h__


class CSeekingPassThru : public ISeekingPassThru, public CUnknown
{
public:
    static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
    CSeekingPassThru(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr);
    ~CSeekingPassThru();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP Init(BOOL bSupportRendering, IPin *pPin);

private:
    CPosPassThru              *m_pPosPassThru;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\schedule.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//  SCHEDULE.H

#ifndef __CAMSchedule__
#define __CAMSchedule__

class CAMSchedule : private CBaseObject
{
public:
    virtual ~CAMSchedule();
    // ev is the event we should fire if the advise time needs re-evaluating
    CAMSchedule( HANDLE ev );

    DWORD GetAdviseCount();
    REFERENCE_TIME GetNextAdviseTime();

    // We need a method for derived classes to add advise packets, we return the cookie
    DWORD_PTR AddAdvisePacket( const REFERENCE_TIME & time1, const REFERENCE_TIME & time2, HANDLE h, BOOL periodic );
    // And a way to cancel
    HRESULT Unadvise(DWORD_PTR dwAdviseCookie);

    // Tell us the time please, and we'll dispatch the expired events.  We return the time of the next event.
    // NB: The time returned will be "useless" if you start adding extra Advises.  But that's the problem of
    // whoever is using this helper class (typically a clock).
    REFERENCE_TIME Advise( const REFERENCE_TIME & rtTime );

    // Get the event handle which will be set if advise time requires re-evaluation.
    HANDLE GetEvent() const { return m_ev; }

private:
    // We define the nodes that will be used in our singly linked list
    // of advise packets.  The list is ordered by time, with the
    // elements that will expire first at the front.
    class CAdvisePacket
    {
    public:
        CAdvisePacket()
        {}

        CAdvisePacket * m_next;
        DWORD_PTR       m_dwAdviseCookie;
        REFERENCE_TIME  m_rtEventTime;      // Time at which event should be set
        REFERENCE_TIME  m_rtPeriod;         // Periodic time
        HANDLE          m_hNotify;          // Handle to event or semephore
        BOOL            m_bPeriodic;        // TRUE => Periodic event

        CAdvisePacket( CAdvisePacket * next, LONGLONG time ) : m_next(next), m_rtEventTime(time)
        {}

        void InsertAfter( CAdvisePacket * p )
        {
            p->m_next = m_next;
            m_next    = p;
        }

        int IsZ() const // That is, is it the node that represents the end of the list
        { return m_next == 0; }

        CAdvisePacket * RemoveNext()
        {
            CAdvisePacket *const next = m_next;
            CAdvisePacket *const new_next = next->m_next;
            m_next = new_next;
            return next;
        }

        void DeleteNext()
        {
            delete RemoveNext();
        }

        CAdvisePacket * Next() const
        {
            CAdvisePacket * result = m_next;
            if (result->IsZ()) result = 0;
            return result;
        }

        DWORD_PTR Cookie() const
        { return m_dwAdviseCookie; }
    };

    // Structure is:
    // head -> elmt1 -> elmt2 -> z -> null
    // So an empty list is:       head -> z -> null
    // Having head & z as links makes insertaion,
    // deletion and shunting much easier.
    CAdvisePacket   head, z;            // z is both a tail and a sentry

    volatile DWORD_PTR  m_dwNextCookie;     // Strictly increasing
    volatile DWORD  m_dwAdviseCount;    // Number of elements on list

    CCritSec        m_Serialize;

    // AddAdvisePacket: adds the packet, returns the cookie (0 if failed)
    DWORD_PTR AddAdvisePacket( CAdvisePacket * pPacket );
    // Event that we should set if the packed added above will be the next to fire.
    const HANDLE m_ev;

    // A Shunt is where we have changed the first element in the
    // list and want it re-evaluating (i.e. repositioned) in
    // the list.
    void ShuntHead();

    // Rather than delete advise packets, we cache them for future use
    CAdvisePacket * m_pAdviseCache;
    DWORD           m_dwCacheCount;
    enum { dwCacheMax = 5 };             // Don't bother caching more than five

    void Delete( CAdvisePacket * pLink );// This "Delete" will cache the Link

// Attributes and methods for debugging
public:
#ifdef DEBUG
    void DumpLinkedList();
#else
    void DumpLinkedList() {}
#endif

};

#endif // __CAMSchedule__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\renbase.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Generic ActiveX base renderer class, December 1995

#ifndef __RENBASE__
#define __RENBASE__

// Forward class declarations

class CBaseRenderer;
class CBaseVideoRenderer;
class CRendererInputPin;

// This is our input pin class that channels calls to the renderer

class CRendererInputPin : public CBaseInputPin
{
protected:

    CBaseRenderer *m_pRenderer;

public:

    CRendererInputPin(CBaseRenderer *pRenderer,
                      HRESULT *phr,
                      LPCWSTR Name);

    // Overriden from the base pin classes

    HRESULT BreakConnect();
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT Active();
    HRESULT Inactive();

    // Add rendering behaviour to interface functions

    STDMETHODIMP QueryId(LPWSTR *Id);
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP Receive(IMediaSample *pMediaSample);

    // Helper
    IMemAllocator inline *Allocator() const
    {
        return m_pAllocator;
    }
};

// Main renderer class that handles synchronisation and state changes

class CBaseRenderer : public CBaseFilter
{
protected:

    friend class CRendererInputPin;

    friend void CALLBACK EndOfStreamTimer(UINT uID,      // Timer identifier
                                          UINT uMsg,     // Not currently used
                                          DWORD_PTR dwUser,  // User information
                                          DWORD_PTR dw1,     // Windows reserved
                                          DWORD_PTR dw2);    // Is also reserved

    CRendererPosPassThru *m_pPosition;  // Media seeking pass by object
    CAMEvent m_RenderEvent;             // Used to signal timer events
    CAMEvent m_ThreadSignal;            // Signalled to release worker thread
    CAMEvent m_evComplete;              // Signalled when state complete
    BOOL m_bAbort;                      // Stop us from rendering more data
    BOOL m_bStreaming;                  // Are we currently streaming
    DWORD_PTR m_dwAdvise;                   // Timer advise cookie
    IMediaSample *m_pMediaSample;       // Current image media sample
    BOOL m_bEOS;                        // Any more samples in the stream
    BOOL m_bEOSDelivered;               // Have we delivered an EC_COMPLETE
    CRendererInputPin *m_pInputPin;     // Our renderer input pin object
    CCritSec m_InterfaceLock;           // Critical section for interfaces
    CCritSec m_RendererLock;            // Controls access to internals
    IQualityControl * m_pQSink;         // QualityControl sink
    BOOL m_bRepaintStatus;              // Can we signal an EC_REPAINT
    //  Avoid some deadlocks by tracking filter during stop
    volatile BOOL  m_bInReceive;        // Inside Receive between PrepareReceive
                                        // And actually processing the sample
    REFERENCE_TIME m_SignalTime;        // Time when we signal EC_COMPLETE
    UINT m_EndOfStreamTimer;            // Used to signal end of stream

public:

    CBaseRenderer(REFCLSID RenderClass, // CLSID for this renderer
                  TCHAR *pName,         // Debug ONLY description
                  LPUNKNOWN pUnk,       // Aggregated owner object
                  HRESULT *phr);        // General OLE return code

    ~CBaseRenderer();

    // Overriden to say what interfaces we support and where

    virtual HRESULT GetMediaPositionInterface(REFIID riid,void **ppv);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    virtual HRESULT SourceThreadCanWait(BOOL bCanWait);

#ifdef DEBUG
    // Debug only dump of the renderer state
    void DisplayRendererState();
#endif
    virtual HRESULT WaitForRenderTime();
    virtual HRESULT CompleteStateChange(FILTER_STATE OldState);

    // Return internal information about this filter

    BOOL IsEndOfStream() { return m_bEOS; };
    BOOL IsEndOfStreamDelivered() { return m_bEOSDelivered; };
    BOOL IsStreaming() { return m_bStreaming; };
    void SetAbortSignal(BOOL bAbort) { m_bAbort = bAbort; };
    virtual void OnReceiveFirstSample(IMediaSample *pMediaSample) { };
    CAMEvent *GetRenderEvent() { return &m_RenderEvent; };

    // Permit access to the transition state

    void Ready() { m_evComplete.Set(); };
    void NotReady() { m_evComplete.Reset(); };
    BOOL CheckReady() { return m_evComplete.Check(); };

    virtual int GetPinCount();
    virtual CBasePin *GetPin(int n);
    FILTER_STATE GetRealState();
    void SendRepaint();
    void SendNotifyWindow(IPin *pPin,HWND hwnd);
    BOOL OnDisplayChange();
    void SetRepaintStatus(BOOL bRepaint);

    // Override the filter and pin interface functions

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME StartTime);
    STDMETHODIMP GetState(DWORD dwMSecs,FILTER_STATE *State);
    STDMETHODIMP FindPin(LPCWSTR Id, IPin **ppPin);

    // These are available for a quality management implementation

    virtual void OnRenderStart(IMediaSample *pMediaSample);
    virtual void OnRenderEnd(IMediaSample *pMediaSample);
    virtual HRESULT OnStartStreaming() { return NOERROR; };
    virtual HRESULT OnStopStreaming() { return NOERROR; };
    virtual void OnWaitStart() { };
    virtual void OnWaitEnd() { };
    virtual void PrepareRender() { };

#ifdef PERF
    REFERENCE_TIME m_trRenderStart; // Just before we started drawing
                                    // Set in OnRenderStart, Used in OnRenderEnd
    int m_idBaseStamp;              // MSR_id for frame time stamp
    int m_idBaseRenderTime;         // MSR_id for true wait time
    int m_idBaseAccuracy;           // MSR_id for time frame is late (int)
#endif

    // Quality management implementation for scheduling rendering

    virtual BOOL ScheduleSample(IMediaSample *pMediaSample);
    virtual HRESULT GetSampleTimes(IMediaSample *pMediaSample,
                                   REFERENCE_TIME *pStartTime,
                                   REFERENCE_TIME *pEndTime);

    virtual HRESULT ShouldDrawSampleNow(IMediaSample *pMediaSample,
                                        REFERENCE_TIME *ptrStart,
                                        REFERENCE_TIME *ptrEnd);

    // Lots of end of stream complexities

    void TimerCallback();
    void ResetEndOfStreamTimer();
    HRESULT NotifyEndOfStream();
    virtual HRESULT SendEndOfStream();
    virtual HRESULT ResetEndOfStream();
    virtual HRESULT EndOfStream();

    // Rendering is based around the clock

    void SignalTimerFired();
    virtual HRESULT CancelNotification();
    virtual HRESULT ClearPendingSample();

    // Called when the filter changes state

    virtual HRESULT Active();
    virtual HRESULT Inactive();
    virtual HRESULT StartStreaming();
    virtual HRESULT StopStreaming();
    virtual HRESULT BeginFlush();
    virtual HRESULT EndFlush();

    // Deal with connections and type changes

    virtual HRESULT BreakConnect();
    virtual HRESULT SetMediaType(const CMediaType *pmt);
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // These look after the handling of data samples

    virtual HRESULT PrepareReceive(IMediaSample *pMediaSample);
    virtual HRESULT Receive(IMediaSample *pMediaSample);
    virtual BOOL HaveCurrentSample();
    virtual IMediaSample *GetCurrentSample();
    virtual HRESULT Render(IMediaSample *pMediaSample);

    // Derived classes MUST override these
    virtual HRESULT DoRenderSample(IMediaSample *pMediaSample) PURE;
    virtual HRESULT CheckMediaType(const CMediaType *) PURE;

    // Helper
    void WaitForReceiveToComplete();
};


// CBaseVideoRenderer is a renderer class (see its ancestor class) and
// it handles scheduling of media samples so that they are drawn at the
// correct time by the reference clock.  It implements a degradation
// strategy.  Possible degradation modes are:
//    Drop frames here (only useful if the drawing takes significant time)
//    Signal supplier (upstream) to drop some frame(s) - i.e. one-off skip.
//    Signal supplier to change the frame rate - i.e. ongoing skipping.
//    Or any combination of the above.
// In order to determine what's useful to try we need to know what's going
// on.  This is done by timing various operations (including the supplier).
// This timing is done by using timeGetTime as it is accurate enough and
// usually cheaper than calling the reference clock.  It also tells the
// truth if there is an audio break and the reference clock stops.
// We provide a number of public entry points (named OnXxxStart, OnXxxEnd)
// which the rest of the renderer calls at significant moments.  These do
// the timing.

// the number of frames that the sliding averages are averaged over.
// the rule is (1024*NewObservation + (AVGPERIOD-1) * PreviousAverage)/AVGPERIOD
#define AVGPERIOD 4
#define DO_MOVING_AVG(avg,obs) (avg = (1024*obs + (AVGPERIOD-1)*avg)/AVGPERIOD)
// Spot the bug in this macro - I can't. but it doesn't work!

class CBaseVideoRenderer : public CBaseRenderer,    // Base renderer class
                           public IQualProp,        // Property page guff
                           public IQualityControl   // Allow throttling
{
protected:

    // Hungarian:
    //     tFoo is the time Foo in mSec (beware m_tStart from filter.h)
    //     trBar is the time Bar by the reference clock

    //******************************************************************
    // State variables to control synchronisation
    //******************************************************************

    // Control of sending Quality messages.  We need to know whether
    // we are in trouble (e.g. frames being dropped) and where the time
    // is being spent.

    // When we drop a frame we play the next one early.
    // The frame after that is likely to wait before drawing and counting this
    // wait as spare time is unfair, so we count it as a zero wait.
    // We therefore need to know whether we are playing frames early or not.

    int m_nNormal;                  // The number of consecutive frames
                                    // drawn at their normal time (not early)
                                    // -1 means we just dropped a frame.

#ifdef PERF
    BOOL m_bDrawLateFrames;         // Don't drop any frames (debug and I'm
                                    // not keen on people using it!)
#endif

    BOOL m_bSupplierHandlingQuality;// The response to Quality messages says
                                    // our supplier is handling things.
                                    // We will allow things to go extra late
                                    // before dropping frames.  We will play
                                    // very early after he has dropped one.

    // Control of scheduling, frame dropping etc.
    // We need to know where the time is being spent so as to tell whether
    // we should be taking action here, signalling supplier or what.
    // The variables are initialised to a mode of NOT dropping frames.
    // They will tell the truth after a few frames.
    // We typically record a start time for an event, later we get the time
    // again and subtract to get the elapsed time, and we average this over
    // a few frames.  The average is used to tell what mode we are in.

    // Although these are reference times (64 bit) they are all DIFFERENCES
    // between times which are small.  An int will go up to 214 secs before
    // overflow.  Avoiding 64 bit multiplications and divisions seems
    // worth while.



    // Audio-video throttling.  If the user has turned up audio quality
    // very high (in principle it could be any other stream, not just audio)
    // then we can receive cries for help via the graph manager.  In this case
    // we put in a wait for some time after rendering each frame.
    int m_trThrottle;

    // The time taken to render (i.e. BitBlt) frames controls which component
    // needs to degrade.  If the blt is expensive, the renderer degrades.
    // If the blt is cheap it's done anyway and the supplier degrades.
    int m_trRenderAvg;              // Time frames are taking to blt
    int m_trRenderLast;             // Time for last frame blt
    int m_tRenderStart;             // Just before we started drawing (mSec)
                                    // derived from timeGetTime.

    // When frames are dropped we will play the next frame as early as we can.
    // If it was a false alarm and the machine is fast we slide gently back to
    // normal timing.  To do this, we record the offset showing just how early
    // we really are.  This will normally be negative meaning early or zero.
    int m_trEarliness;

    // Target provides slow long-term feedback to try to reduce the
    // average sync offset to zero.  Whenever a frame is actually rendered
    // early we add a msec or two, whenever late we take off a few.
    // We add or take off 1/32 of the error time.
    // Eventually we should be hovering around zero.  For a really bad case
    // where we were (say) 300mSec off, it might take 100 odd frames to
    // settle down.  The rate of change of this is intended to be slower
    // than any other mechanism in Quartz, thereby avoiding hunting.
    int m_trTarget;

    // The proportion of time spent waiting for the right moment to blt
    // controls whether we bother to drop a frame or whether we reckon that
    // we're doing well enough that we can stand a one-frame glitch.
    int m_trWaitAvg;                // Average of last few wait times
                                    // (actually we just average how early
                                    // we were).  Negative here means LATE.

    // The average inter-frame time.
    // This is used to calculate the proportion of the time used by the
    // three operations (supplying us, waiting, rendering)
    int m_trFrameAvg;               // Average inter-frame time
    int m_trDuration;               // duration of last frame.

#ifdef PERF
    // Performance logging identifiers
    int m_idTimeStamp;              // MSR_id for frame time stamp
    int m_idEarliness;              // MSR_id for earliness fudge
    int m_idTarget;                 // MSR_id for Target fudge
    int m_idWaitReal;               // MSR_id for true wait time
    int m_idWait;                   // MSR_id for wait time recorded
    int m_idFrameAccuracy;          // MSR_id for time frame is late (int)
    int m_idRenderAvg;              // MSR_id for Render time recorded (int)
    int m_idSchLateTime;            // MSR_id for lateness at scheduler
    int m_idQualityRate;            // MSR_id for Quality rate requested
    int m_idQualityTime;            // MSR_id for Quality time requested
    int m_idDecision;               // MSR_id for decision code
    int m_idDuration;               // MSR_id for duration of a frame
    int m_idThrottle;               // MSR_id for audio-video throttling
    //int m_idDebug;                  // MSR_id for trace style debugging
    //int m_idSendQuality;          // MSR_id for timing the notifications per se
#endif // PERF
    REFERENCE_TIME m_trRememberStampForPerf;  // original time stamp of frame
                                              // with no earliness fudges etc.
#ifdef PERF
    REFERENCE_TIME m_trRememberFrameForPerf;  // time when previous frame rendered

    // debug...
    int m_idFrameAvg;
    int m_idWaitAvg;
#endif

    // PROPERTY PAGE
    // This has edit fields that show the user what's happening
    // These member variables hold these counts.

    int m_cFramesDropped;           // cumulative frames dropped IN THE RENDERER
    int m_cFramesDrawn;             // Frames since streaming started seen BY THE
                                    // RENDERER (some may be dropped upstream)

    // Next two support average sync offset and standard deviation of sync offset.
    LONGLONG m_iTotAcc;                  // Sum of accuracies in mSec
    LONGLONG m_iSumSqAcc;           // Sum of squares of (accuracies in mSec)

    // Next two allow jitter calculation.  Jitter is std deviation of frame time.
    REFERENCE_TIME m_trLastDraw;    // Time of prev frame (for inter-frame times)
    LONGLONG m_iSumSqFrameTime;     // Sum of squares of (inter-frame time in mSec)
    LONGLONG m_iSumFrameTime;            // Sum of inter-frame times in mSec

    // To get performance statistics on frame rate, jitter etc, we need
    // to record the lateness and inter-frame time.  What we actually need are the
    // data above (sum, sum of squares and number of entries for each) but the data
    // is generated just ahead of time and only later do we discover whether the
    // frame was actually drawn or not.  So we have to hang on to the data
    int m_trLate;                   // hold onto frame lateness
    int m_trFrame;                  // hold onto inter-frame time

    int m_tStreamingStart;          // if streaming then time streaming started
                                    // else time of last streaming session
                                    // used for property page statistics
#ifdef PERF
    LONGLONG m_llTimeOffset;        // timeGetTime()*10000+m_llTimeOffset==ref time
#endif

public:


    CBaseVideoRenderer(REFCLSID RenderClass, // CLSID for this renderer
                       TCHAR *pName,         // Debug ONLY description
                       LPUNKNOWN pUnk,       // Aggregated owner object
                       HRESULT *phr);        // General OLE return code

    ~CBaseVideoRenderer();

    // IQualityControl methods - Notify allows audio-video throttling

    STDMETHODIMP SetSink( IQualityControl * piqc);
    STDMETHODIMP Notify( IBaseFilter * pSelf, Quality q);

    // These provide a full video quality management implementation

    void OnRenderStart(IMediaSample *pMediaSample);
    void OnRenderEnd(IMediaSample *pMediaSample);
    void OnWaitStart();
    void OnWaitEnd();
    HRESULT OnStartStreaming();
    HRESULT OnStopStreaming();
    void ThrottleWait();

    // Handle the statistics gathering for our quality management

    void PreparePerformanceData(int trLate, int trFrame);
    virtual void RecordFrameLateness(int trLate, int trFrame);
    virtual void OnDirectRender(IMediaSample *pMediaSample);
    virtual HRESULT ResetStreamingTimes();
    BOOL ScheduleSample(IMediaSample *pMediaSample);
    HRESULT ShouldDrawSampleNow(IMediaSample *pMediaSample,
                                REFERENCE_TIME *ptrStart,
                                REFERENCE_TIME *ptrEnd);

    virtual HRESULT SendQuality(REFERENCE_TIME trLate, REFERENCE_TIME trRealStream);
    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

    //
    //  Do estimates for standard deviations for per-frame
    //  statistics
    //
    //  *piResult = (llSumSq - iTot * iTot / m_cFramesDrawn - 1) /
    //                            (m_cFramesDrawn - 2)
    //  or 0 if m_cFramesDrawn <= 3
    //
    HRESULT GetStdDev(
        int nSamples,
        int *piResult,
        LONGLONG llSumSq,
        LONGLONG iTot
    );
public:

    // IQualProp property page support

    STDMETHODIMP get_FramesDroppedInRenderer(int *cFramesDropped);
    STDMETHODIMP get_FramesDrawn(int *pcFramesDrawn);
    STDMETHODIMP get_AvgFrameRate(int *piAvgFrameRate);
    STDMETHODIMP get_Jitter(int *piJitter);
    STDMETHODIMP get_AvgSyncOffset(int *piAvg);
    STDMETHODIMP get_DevSyncOffset(int *piDev);

    // Implement an IUnknown interface and expose IQualProp

    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,VOID **ppv);
};

#endif // __RENBASE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\wxdebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Debugging facilities, January 1995

#ifndef __WXDEBUG__
#define __WXDEBUG__

// This library provides fairly straight forward debugging functionality, this
// is split into two main sections. The first is assertion handling, there are
// three types of assertions provided here. The most commonly used one is the
// ASSERT(condition) macro which will pop up a message box including the file
// and line number if the condition evaluates to FALSE. Then there is the
// EXECUTE_ASSERT macro which is the same as ASSERT except the condition will
// still be executed in NON debug builds. The final type of assertion is the
// KASSERT macro which is more suitable for pure (perhaps kernel) filters as
// the condition is printed onto the debugger rather than in a message box.
//
// The other part of the debug module facilties is general purpose logging.
// This is accessed by calling DbgLog(). The function takes a type and level
// field which define the type of informational string you are presenting and
// it's relative importance. The type field can be a combination (one or more)
// of LOG_TIMING, LOG_TRACE, LOG_MEMORY, LOG_LOCKING and LOG_ERROR. The level
// is a DWORD value where zero defines highest important. Use of zero as the
// debug logging level is to be encouraged ONLY for major errors or events as
// they will ALWAYS be displayed on the debugger. Other debug output has it's
// level matched against the current debug output level stored in the registry
// for this module and if less than the current setting it will be displayed.
//
// Each module or executable has it's own debug output level for each of the
// five types. These are read in when the DbgInitialise function is called
// for DLLs linking to STRMBASE.LIB this is done automatically when the DLL
// is loaded, executables must call it explicitely with the module instance
// handle given to them through the WINMAIN entry point. An executable must
// also call DbgTerminate when they have finished to clean up the resources
// the debug library uses, once again this is done automatically for DLLs

// These are the five different categories of logging information

enum {  LOG_TIMING = 0x01,    // Timing and performance measurements
        LOG_TRACE = 0x02,     // General step point call tracing
        LOG_MEMORY =  0x04,   // Memory and object allocation/destruction
        LOG_LOCKING = 0x08,   // Locking/unlocking of critical sections
        LOG_ERROR = 0x10 };   // Debug error notification

enum {  CDISP_HEX = 0x01,
        CDISP_DEC = 0x02};

// For each object created derived from CBaseObject (in debug builds) we
// create a descriptor that holds it's name (statically allocated memory)
// and a cookie we assign it. We keep a list of all the active objects
// we have registered so that we can dump a list of remaining objects

typedef struct tag_ObjectDesc {
    const TCHAR *m_pName;
    DWORD m_dwCookie;
    tag_ObjectDesc *m_pNext;
} ObjectDesc;

#define DLLIMPORT __declspec(dllimport)
#define DLLEXPORT __declspec(dllexport)

#ifdef DEBUG

    #define NAME(x) TEXT(x)

    // These are used internally by the debug library (PRIVATE)

    void WINAPI DbgInitKeyLevels(HKEY hKey);
    void WINAPI DbgInitGlobalSettings();
    void WINAPI DbgInitModuleSettings();
    void WINAPI DbgInitModuleName();
    DWORD WINAPI DbgRegisterObjectCreation(const TCHAR *pObjectName);
    BOOL WINAPI DbgRegisterObjectDestruction(DWORD dwCookie);

    // These are the PUBLIC entry points

    BOOL WINAPI DbgCheckModuleLevel(DWORD Type,DWORD Level);
    void WINAPI DbgSetModuleLevel(DWORD Type,DWORD Level);

    // Initialise the library with the module handle

    void WINAPI DbgInitialise(HINSTANCE hInst);
    void WINAPI DbgTerminate();

    void WINAPI DbgDumpObjectRegister();

    // Display error and logging to the user

    void WINAPI DbgAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgBreakPoint(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgKernelAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgLogInfo(DWORD Type,DWORD Level,const TCHAR *pFormat,...);
    void WINAPI DbgOutString(LPCTSTR psz);

    //  Debug infinite wait stuff
    DWORD WINAPI DbgWaitForSingleObject(HANDLE h);
    DWORD WINAPI DbgWaitForMultipleObjects(DWORD nCount,
                                    CONST HANDLE *lpHandles,
                                    BOOL bWaitAll);
    void WINAPI DbgSetWaitTimeout(DWORD dwTimeout);

#ifdef __strmif_h__
    // Display a media type: Terse at level 2, verbose at level 5
    void WINAPI DisplayType(LPSTR label, const AM_MEDIA_TYPE *pmtIn);

    // Dump lots of information about a filter graph
    void WINAPI DumpGraph(IFilterGraph *pGraph, DWORD dwLevel);
#endif

    #define KASSERT(_x_) if (!(_x_))         \
        DbgKernelAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    //  Break on the debugger without putting up a message box
    //  message goes to debugger instead

    #define KDbgBreak(_x_)                   \
        DbgKernelAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    // We chose a common name for our ASSERT macro, MFC also uses this name
    // So long as the implementation evaluates the condition and handles it
    // then we will be ok. Rather than override the behaviour expected we
    // will leave whatever first defines ASSERT as the handler (i.e. MFC)
    #ifndef ASSERT
        #define ASSERT(_x_) if (!(_x_))         \
            DbgAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)
    #endif

    //  Put up a message box informing the user of a halt
    //  condition in the program

    #define DbgBreak(_x_)                   \
        DbgBreakPoint(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    #define EXECUTE_ASSERT(_x_) ASSERT(_x_)
    #define DbgLog(_x_) DbgLogInfo _x_

    // MFC style trace macros

    #define NOTE(_x_)             DbgLog((LOG_TRACE,5,TEXT(_x_)))
    #define NOTE1(_x_,a)          DbgLog((LOG_TRACE,5,TEXT(_x_),a))
    #define NOTE2(_x_,a,b)        DbgLog((LOG_TRACE,5,TEXT(_x_),a,b))
    #define NOTE3(_x_,a,b,c)      DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c))
    #define NOTE4(_x_,a,b,c,d)    DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c,d))
    #define NOTE5(_x_,a,b,c,d,e)  DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c,d,e))

#else

    // Retail builds make public debug functions inert  - WARNING the source
    // files do not define or build any of the entry points in debug builds
    // (public entry points compile to nothing) so if you go trying to call
    // any of the private entry points in your source they won't compile

    #define NAME(_x_) NULL

    #define DbgInitialise(hInst)
    #define DbgTerminate()
    #define DbgLog(_x_) 0
    #define DbgOutString(psz)

    #define DbgRegisterObjectCreation(pObjectName)
    #define DbgRegisterObjectDestruction(dwCookie)
    #define DbgDumpObjectRegister()

    #define DbgCheckModuleLevel(Type,Level)
    #define DbgSetModuleLevel(Type,Level)

    #define DbgWaitForSingleObject(h)  WaitForSingleObject(h, INFINITE)
    #define DbgWaitForMultipleObjects(nCount, lpHandles, bWaitAll)     \
               WaitForMultipleObjects(nCount, lpHandles, bWaitAll, INFINITE)
    #define DbgSetWaitTimeout(dwTimeout)

    #define KDbgBreak(_x_)
    #define DbgBreak(_x_)

    #define KASSERT(_x_) ((void)0)
    #ifndef ASSERT
	#define ASSERT(_x_) ((void)0)
    #endif
    #define EXECUTE_ASSERT(_x_) ((void)(_x_))

    // MFC style trace macros

    #define NOTE(_x_) ((void)0)
    #define NOTE1(_x_,a) ((void)0)
    #define NOTE2(_x_,a,b) ((void)0)
    #define NOTE3(_x_,a,b,c) ((void)0)
    #define NOTE4(_x_,a,b,c,d) ((void)0)
    #define NOTE5(_x_,a,b,c,d,e) ((void)0)

    #define DisplayType(label, pmtIn) ((void)0)
    #define DumpGraph(pGraph, label) ((void)0)
#endif


// Checks a pointer which should be non NULL - can be used as follows.

#define CheckPointer(p,ret) {if((p)==NULL) return (ret);}

//   HRESULT Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,E_INVALIDARG)
//   }
//
//   Or if the function returns a boolean
//
//   BOOL Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,FALSE)
//   }

// These validate pointers when symbol VFWROBUST is defined
// This will normally be defined in debug not retail builds

#ifdef DEBUG
    #define VFWROBUST
#endif

#ifdef VFWROBUST

    #define ValidateReadPtr(p,cb) \
        {if(IsBadReadPtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid read pointer");}

    #define ValidateWritePtr(p,cb) \
        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid write pointer");}

    #define ValidateReadWritePtr(p,cb) \
        {ValidateReadPtr(p,cb) ValidateWritePtr(p,cb)}

    #define ValidateStringPtr(p) \
        {if(IsBadStringPtr((LPCTSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid string pointer");}

    #define ValidateStringPtrA(p) \
        {if(IsBadStringPtrA((LPCSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid ANSII string pointer");}

    #define ValidateStringPtrW(p) \
        {if(IsBadStringPtrW((LPCWSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid UNICODE string pointer");}

#else
    #define ValidateReadPtr(p,cb) 0
    #define ValidateWritePtr(p,cb) 0
    #define ValidateReadWritePtr(p,cb) 0
    #define ValidateStringPtr(p) 0
    #define ValidateStringPtrA(p) 0
    #define ValidateStringPtrW(p) 0
#endif


#ifdef _OBJBASE_H_

    //  Outputting GUID names.  If you want to include the name
    //  associated with a GUID (eg CLSID_...) then
    //
    //      GuidNames[yourGUID]
    //
    //  Returns the name defined in uuids.h as a string

    typedef struct {
        TCHAR   *szName;
        GUID    guid;
    } GUID_STRING_ENTRY;

    class CGuidNameList {
    public:
        TCHAR *operator [] (const GUID& guid);
    };

    extern CGuidNameList GuidNames;

#endif

#ifndef REMIND
    //  REMIND macro - generates warning as reminder to complete coding
    //  (eg) usage:
    //
    //  #pragma message (REMIND("Add automation support"))


    #define QUOTE(x) #x
    #define QQUOTE(y) QUOTE(y)
    #define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") :  " str
#endif

//  Hack to display objects in a useful format
//
//  eg If you want to display a LONGLONG ll in a debug string do (eg)
//
//  DbgLog((LOG_TRACE, n, TEXT("Value is %s"), (LPCTSTR)CDisp(ll, CDISP_HEX)));


class CDispBasic
{
public:
    CDispBasic() { m_pString = m_String; };
    ~CDispBasic();
protected:
    PTCHAR m_pString;  // normally points to m_String... unless too much data
    TCHAR m_String[50];
};
class CDisp : public CDispBasic
{
public:
    CDisp(LONGLONG ll, int Format = CDISP_HEX); // Display a LONGLONG in CDISP_HEX or CDISP_DEC form
    CDisp(REFCLSID clsid);      // Display a GUID
    CDisp(double d);            // Display a floating point number
#ifdef __strmif_h__
#ifdef __STREAMS__
    CDisp(CRefTime t);          // Display a Reference Time
#endif
    CDisp(IPin *pPin);          // Display a pin as {filter clsid}(pin name)
#endif // __strmif_h__
    ~CDisp();

    //  Implement cast to (LPCTSTR) as parameter to logger
    operator LPCTSTR()
    {
        return (LPCTSTR)m_pString;
    };
};

#endif // __WXDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\uuids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// contains the GUIDs for the MediaType type, subtype fields and format types
// for standard media types, and also class ids for well-known components.


//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
	#define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif


// -- to allow consistent labeling of Media types and subtypes --

#define MEDIATYPE_NULL       GUID_NULL
#define MEDIASUBTYPE_NULL    GUID_NULL

// -- Use this subtype if you don't have a use for a subtype for your type
// e436eb8e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_None
OUR_GUID_ENTRY(MEDIASUBTYPE_None,
0xe436eb8e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


// -- major types ---


// 73646976-0000-0010-8000-00AA00389B71  'vids' == MEDIATYPE_Video
OUR_GUID_ENTRY(MEDIATYPE_Video,
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73647561-0000-0010-8000-00AA00389B71  'auds' == MEDIATYPE_Audio
OUR_GUID_ENTRY(MEDIATYPE_Audio,
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73747874-0000-0010-8000-00AA00389B71  'txts' == MEDIATYPE_Text
OUR_GUID_ENTRY(MEDIATYPE_Text,
0x73747874, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 7364696D-0000-0010-8000-00AA00389B71  'mids' == MEDIATYPE_Midi
OUR_GUID_ENTRY(MEDIATYPE_Midi,
0x7364696D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb83-524f-11ce-9f53-0020af0ba770            MEDIATYPE_Stream
OUR_GUID_ENTRY(MEDIATYPE_Stream,
0xe436eb83, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 73(s)76(v)61(a)69(i)-0000-0010-8000-00AA00389B71  'iavs' == MEDIATYPE_Interleaved
OUR_GUID_ENTRY(MEDIATYPE_Interleaved,
0x73766169, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 656c6966-0000-0010-8000-00AA00389B71  'file' == MEDIATYPE_File
OUR_GUID_ENTRY(MEDIATYPE_File,
0x656c6966, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_ScriptCommand
OUR_GUID_ENTRY(MEDIATYPE_ScriptCommand,
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 670AEA80-3A82-11d0-B79B-00AA003767A7            MEDIATYPE_AUXLine21Data
OUR_GUID_ENTRY(MEDIATYPE_AUXLine21Data,
0x670aea80, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 0482DEE3-7817-11cf-8a03-00aa006ecb65
OUR_GUID_ENTRY(MEDIATYPE_Timecode,
0x482dee3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 74726c6d-0000-0010-8000-00AA00389B71  'lmrt' == MEDIATYPE_LMRT
OUR_GUID_ENTRY(MEDIATYPE_LMRT,
0x74726c6d, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 74726c6d-0000-0010-8000-00AA00389B71  'urls' == MEDIATYPE_URL_STREAM
OUR_GUID_ENTRY(MEDIATYPE_URL_STREAM,
0x736c7275, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// -- sub types ---


// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9
OUR_GUID_ENTRY(MEDIASUBTYPE_YVU9,
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313459-0000-0010-8000-00AA00389B71  'Y411' == MEDIASUBTYPE_Y411
OUR_GUID_ENTRY(MEDIASUBTYPE_Y411,
0x31313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 50313459-0000-0010-8000-00AA00389B71  'Y41P' == MEDIASUBTYPE_Y41P
OUR_GUID_ENTRY(MEDIASUBTYPE_Y41P,
0x50313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2
OUR_GUID_ENTRY(MEDIASUBTYPE_YUY2,
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU
OUR_GUID_ENTRY(MEDIASUBTYPE_YVYU,
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY
OUR_GUID_ENTRY(MEDIASUBTYPE_UYVY,
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'Y211' ==  MEDIASUBTYPE_Y211
OUR_GUID_ENTRY(MEDIASUBTYPE_Y211,
0x31313259, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12
OUR_GUID_ENTRY(MEDIASUBTYPE_YV12,
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 524a4c43-0000-0010-8000-00AA00389B71  'CLJR' ==  MEDIASUBTYPE_CLJR
OUR_GUID_ENTRY(MEDIASUBTYPE_CLJR,
0x524a4c43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39304649-0000-0010-8000-00AA00389B71  'IF09' ==  MEDIASUBTYPE_IF09
OUR_GUID_ENTRY(MEDIASUBTYPE_IF09,
0x39304649, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 414c5043-0000-0010-8000-00AA00389B71  'CPLA' ==  MEDIASUBTYPE_CPLA
OUR_GUID_ENTRY(MEDIASUBTYPE_CPLA,
0x414c5043, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A4D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_MJPG,
0x47504A4D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 4A4D5654-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_TVMJ
OUR_GUID_ENTRY(MEDIASUBTYPE_TVMJ,
0x4A4D5654, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 454B4157-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_WAKE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAKE,
0x454B4157, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 43434643-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_CFCC
OUR_GUID_ENTRY(MEDIASUBTYPE_CFCC,
0x43434643, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A49-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_IJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_IJPG,
0x47504A49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6D756C50-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_Plum
OUR_GUID_ENTRY(MEDIASUBTYPE_Plum,
0x6D756C50, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 53435644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVCS
OUR_GUID_ENTRY(MEDIASUBTYPE_DVCS,
0x53435644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 44535644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVSD
OUR_GUID_ENTRY(MEDIASUBTYPE_DVSD,
0x44535644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// MIROVideo DV
// 4656444D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MDVF
OUR_GUID_ENTRY(MEDIASUBTYPE_MDVF,
0x4656444D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB1,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7f-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Overlay
OUR_GUID_ENTRY(MEDIASUBTYPE_Overlay,
0xe436eb7f, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb80-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEGPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Packet,
0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb81-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Payload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Payload,
0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000050-0000-0010-8000-00AA00389B71		MEDIASUBTYPE_MPEG1AudioPayload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1AudioPayload,
0x00000050, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb82-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1SystemStream
OUR_GUID_ENTRY(MEDIATYPE_MPEG1SystemStream,
0xe436eb82, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// the next consecutive number is assigned to MEDIATYPE_Stream and appears higher up
// e436eb84-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1System
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1System,
0xe436eb84, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb85-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1VideoCD
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1VideoCD,
0xe436eb85, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb86-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Video
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Video,
0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb87-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Audio
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Audio,
0xe436eb87, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb88-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Avi
OUR_GUID_ENTRY(MEDIASUBTYPE_Avi,
0xe436eb88, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {3DB80F90-9412-11d1-ADED-0000F8754B99}          MEDIASUBTYPE_Asf
OUR_GUID_ENTRY(MEDIASUBTYPE_Asf,
0x3db80f90, 0x9412, 0x11d1, 0xad, 0xed, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99)

// e436eb89-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_QTMovie
OUR_GUID_ENTRY(MEDIASUBTYPE_QTMovie,
0xe436eb89, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 617a7072-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Rpza
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRpza,
0x617a7072, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20636d73-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Smc
OUR_GUID_ENTRY(MEDIASUBTYPE_QTSmc,
0x20636d73, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20656c72-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Rle
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRle,
0x20656c72, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6765706a-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Jpeg
OUR_GUID_ENTRY(MEDIASUBTYPE_QTJpeg,
0x6765706a, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb8a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_PCMAudio_Obsolete
OUR_GUID_ENTRY(MEDIASUBTYPE_PCMAudio_Obsolete,
0xe436eb8a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000001-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_PCM
OUR_GUID_ENTRY(MEDIASUBTYPE_PCM,
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb8b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_WAVE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAVE,
0xe436eb8b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AU
OUR_GUID_ENTRY(MEDIASUBTYPE_AU,
0xe436eb8c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AIFF
OUR_GUID_ENTRY(MEDIASUBTYPE_AIFF,
0xe436eb8d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 64(d)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsd' == MEDIASUBTYPE_dvsd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsd,
0x64737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 64(d)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvhd' == MEDIASUBTYPE_dvhd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvhd,
0x64687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6c(l)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsl' == MEDIASUBTYPE_dvsl
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsl,
0x6c737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)
									
// 6E8D4A22-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_BytePair
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_BytePair,
0x6e8d4a22, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A23-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_GOPPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_GOPPacket,
0x6e8d4a23, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A24-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_VBIRawData
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_VBIRawData,
0x6e8d4a24, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// DirectShow DSS definitions

// A0AF4F81-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssVideo,
0xa0af4f81, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// A0AF4F82-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssAudio,
0xa0af4f82, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A40-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVideo,
0x5a9b6a40, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A41-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVBI,
0x5a9b6a41, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// --- class IDs ---


OUR_GUID_ENTRY(IID_IAMCutListElement,
0xCDE29520,0x3418,0x11CF,0xA5,0xB0,0x00,0x20,0xAF,0x05,0x3D,0x8F)

OUR_GUID_ENTRY(IID_IAMFileCutListElement,
0xF0947070,0x276C,0x11d0,0x83,0x16,0x00,0x20,0xAF,0x11,0xC0,0x10)

OUR_GUID_ENTRY(IID_IAMVideoCutListElement,
0xCDE29522,0x3418,0x11CF,0xA5,0xB0,0x00,0x20,0xAF,0x05,0x3D,0x8F)

OUR_GUID_ENTRY(IID_IAMAudioCutListElement,
0xCDE29524,0x3418,0x11CF,0xA5,0xB0,0x00,0x20,0xAF,0x05,0x3D,0x8F)

// the cutlist source filter
OUR_GUID_ENTRY(CLSID_CutListSource, 
0xa5ea8d20, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(IID_IStandardCutList,
0xa5ea8d29, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(IID_IFileClip,
0xa5ea8d2a, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(IID_ICutListGraphBuilder,
0xa5ea8d2c, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_CutListGraphBuilder, 
0xa5ea8d2f, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_SimpleCutList, 
0xa5ea8d30, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_VideoFileClip, 
0xa5ea8d31, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_AudioFileClip, 
0xa5ea8d32, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_CutListCacheMemory, 
0xa5ea8d33, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

// end cut list stuff


// BF87B6E0-8C27-11d0-B3F0-00AA003761C5     Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder,
0xBF87B6E0, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// e436ebb0-524f-11ce-9f53-0020af0ba770            Prototype filtergraph
OUR_GUID_ENTRY(CLSID_ProtoFilterGraph,
0xe436ebb0, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb1-524f-11ce-9f53-0020af0ba770            Reference clock
OUR_GUID_ENTRY(CLSID_SystemClock,
0xe436ebb1, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb2-524f-11ce-9f53-0020af0ba770           Filter Mapper
OUR_GUID_ENTRY(CLSID_FilterMapper,
0xe436ebb2, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb3-524f-11ce-9f53-0020af0ba770           Filter Graph
OUR_GUID_ENTRY(CLSID_FilterGraph,
0xe436ebb3, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb8-524f-11ce-9f53-0020af0ba770           Filter Graph no thread
OUR_GUID_ENTRY(CLSID_FilterGraphNoThread,
0xe436ebb8, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e4bbd160-4269-11ce-838d-00aa0055595a           MPEG System stream
OUR_GUID_ENTRY(CLSID_MPEG1Doc,
0xe4bbd160, 0x4269, 0x11ce, 0x83, 0x8d, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 701722e0-8ae3-11ce-a85c-00aa002feab5           MPEG file reader
OUR_GUID_ENTRY(CLSID_FileSource,
0x701722e0, 0x8ae3, 0x11ce, 0xa8, 0x5c, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// 26C25940-4CA9-11ce-A828-00AA002FEAB5           Takes MPEG1 packets as input
OUR_GUID_ENTRY(CLSID_MPEG1PacketPlayer,
0x26c25940, 0x4ca9, 0x11ce, 0xa8, 0x28, 0x0, 0xaa, 0x0, 0x2f, 0xea, 0xb5)

// 336475d0-942a-11ce-a870-00aa002feab5           MPEG splitter
OUR_GUID_ENTRY(CLSID_MPEG1Splitter,
0x336475d0, 0x942a, 0x11ce, 0xa8, 0x70, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// feb50740-7bef-11ce-9bd9-0000e202599c           MPEG video decoder
OUR_GUID_ENTRY(CLSID_CMpegVideoCodec,
0xfeb50740, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// 4a2286e0-7bef-11ce-9bd9-0000e202599c           MPEG audio decoder
OUR_GUID_ENTRY(CLSID_CMpegAudioCodec,
0x4a2286e0, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// e30629d3-27e5-11ce-875d-00608cb78066           Text renderer
OUR_GUID_ENTRY(CLSID_TextRender,
0xe30629d3, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)



// {F8388A40-D5BB-11d0-BE5A-0080C706568E}
OUR_GUID_ENTRY(CLSID_InfTee,
0xf8388a40, 0xd5bb, 0x11d0, 0xbe, 0x5a, 0x0, 0x80, 0xc7, 0x6, 0x56, 0x8e)

// 1b544c20-fd0b-11ce-8c63-00aa0044b51e           Avi Stream Splitter
OUR_GUID_ENTRY(CLSID_AviSplitter,
0x1b544c20, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c21-fd0b-11ce-8c63-00aa0044b51e           Avi File Reader
OUR_GUID_ENTRY(CLSID_AviReader,
0x1b544c21, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c22-fd0b-11ce-8c63-00aa0044b51e           Vfw 2.0 Capture Driver
OUR_GUID_ENTRY(CLSID_VfwCapture,
0x1b544c22, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

OUR_GUID_ENTRY(CLSID_CaptureProperties,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x1F)

//e436ebb4-524f-11ce-9f53-0020af0ba770            Control Distributor
OUR_GUID_ENTRY(CLSID_FGControl,
0xe436ebb4, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 44584800-F8EE-11ce-B2D4-00DD01101B85           .MOV reader (old)
OUR_GUID_ENTRY(CLSID_MOVReader,
0x44584800, 0xf8ee, 0x11ce, 0xb2, 0xd4, 0x00, 0xdd, 0x1, 0x10, 0x1b, 0x85)

// D51BD5A0-7548-11cf-A520-0080C77EF58A		  QT Splitter
OUR_GUID_ENTRY(CLSID_QuickTimeParser,
0xd51bd5a0, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// FDFE9681-74A3-11d0-AFA7-00AA00B67A42		  QT Decoder
OUR_GUID_ENTRY(CLSID_QTDec, 
0xfdfe9681, 0x74a3, 0x11d0, 0xaf, 0xa7, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// D3588AB0-0781-11ce-B03A-0020AF0BA770           AVIFile-based reader
OUR_GUID_ENTRY(CLSID_AVIDoc,
0xd3588ab0, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// D3588AB1-0781-11ce-B03A-0020AF0BA770           AVIFile-based writer
OUR_GUID_ENTRY(CLSID_AVIDocWriter,
0xd3588ab1, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// 70e102b0-5556-11ce-97c0-00aa0055595a           Video renderer
OUR_GUID_ENTRY(CLSID_VideoRenderer,
0x70e102b0, 0x5556, 0x11ce, 0x97, 0xc0, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1643e180-90f5-11ce-97d5-00aa0055595a           Colour space convertor
OUR_GUID_ENTRY(CLSID_Colour,
0x1643e180, 0x90f5, 0x11ce, 0x97, 0xd5, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1da08500-9edc-11cf-bc10-00aa00ac74f6           VGA 16 color ditherer
OUR_GUID_ENTRY(CLSID_Dither,
0x1da08500, 0x9edc, 0x11cf, 0xbc, 0x10, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// 07167665-5011-11cf-BF33-00AA0055595A           Modex video renderer
OUR_GUID_ENTRY(CLSID_ModexRenderer,
0x7167665, 0x5011, 0x11cf, 0xbf, 0x33, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// e30629d1-27e5-11ce-875d-00608cb78066           Waveout audio renderer
OUR_GUID_ENTRY(CLSID_AudioRender,
0xe30629d1, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// 05589faf-c356-11ce-bf01-00aa0055595a           Audio Renderer Property Page
OUR_GUID_ENTRY(CLSID_AudioProperties,
0x05589faf, 0xc356, 0x11ce, 0xbf, 0x01, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 79376820-07D0-11cf-A24D-0020AFD79767           DSound audio renderer
OUR_GUID_ENTRY(CLSID_DSoundRender,
0x79376820, 0x07D0, 0x11CF, 0xA2, 0x4D, 0x0, 0x20, 0xAF, 0xD7, 0x97, 0x67)

// e30629d2-27e5-11ce-875d-00608cb78066           Wavein audio recorder
OUR_GUID_ENTRY(CLSID_AudioRecord,
0xe30629d2, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// {CF49D4E0-1115-11ce-B03A-0020AF0BA770}         AVI Decoder
OUR_GUID_ENTRY(CLSID_AVIDec,
0xcf49d4e0, 0x1115, 0x11ce, 0xb0, 0x3a, 0x0, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// {A888DF60-1E90-11cf-AC98-00AA004C0FA9}	  AVI ICDraw* wrapper
OUR_GUID_ENTRY(CLSID_AVIDraw,
0xa888df60, 0x1e90, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// 6a08cf80-0e18-11cf-a24d-0020afd79767       ACM Wrapper
OUR_GUID_ENTRY(CLSID_ACMWrapper,
0x6a08cf80, 0x0e18, 0x11cf, 0xa2, 0x4d, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x67)

// {e436ebb5-524f-11ce-9f53-0020af0ba770}    Async File Reader
OUR_GUID_ENTRY(CLSID_AsyncReader,
0xe436ebb5, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb6-524f-11ce-9f53-0020af0ba770}    Async URL Reader
OUR_GUID_ENTRY(CLSID_URLReader,
0xe436ebb6, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb7-524f-11ce-9f53-0020af0ba770}    IPersistMoniker PID
OUR_GUID_ENTRY(CLSID_PersistMonikerPID,
0xe436ebb7, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {5f2759c0-7685-11cf-8b23-00805f6cef60}    IAMovie plug-in distributor
OUR_GUID_ENTRY(CLSID_AMovie,
0x5f2759c0, 0x7685, 0x11cf, 0x8b, 0x23, 0x00, 0x80, 0x5f, 0x6c, 0xef, 0x60)

// {D76E2820-1563-11cf-AC98-00AA004C0FA9}
OUR_GUID_ENTRY(CLSID_AVICo,
0xd76e2820, 0x1563, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// {8596E5F0-0DA5-11d0-BD21-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_FileWriter,
0x8596e5f0, 0xda5, 0x11d0, 0xbd, 0x21, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {E2510970-F137-11CE-8B67-00AA00A3F1A6}     AVI mux filter
OUR_GUID_ENTRY(CLSID_AviDest,
0xe2510970, 0xf137, 0x11ce, 0x8b, 0x67, 0x0, 0xaa, 0x0, 0xa3, 0xf1, 0xa6)

// {F560AE42-6CDD-11d1-ADE2-0000F8754B99}     ASF mux filter
OUR_GUID_ENTRY(CLSID_AsfMux,
0xf560ae42, 0x6cdd, 0x11d1, 0xad, 0xe2, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99)

// {C647B5C0-157C-11d0-BD23-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage,
0xc647b5c0, 0x157c, 0x11d0, 0xbd, 0x23, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {0A9AE910-85C0-11d0-BD42-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage1,
0xa9ae910, 0x85c0, 0x11d0, 0xbd, 0x42, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {07b65360-c445-11ce-afde-00aa006c14f4}
OUR_GUID_ENTRY(CLSID_AVIMIDIRender,
0x07b65360, 0xc445, 0x11ce, 0xaf, 0xde, 0x00, 0xaa, 0x00, 0x6c, 0x14, 0xf4)


// {B1B77C00-C3E4-11cf-AF79-00AA00B67A42}               DV video decoder
OUR_GUID_ENTRY(CLSID_DVVideoCodec,
0xb1b77c00, 0xc3e4, 0x11cf, 0xaf, 0x79, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {13AA3650-BB6F-11d0-AFB9-00AA00B67A42}               DV video encoder
OUR_GUID_ENTRY(CLSID_DVVideoEnc,
0x13aa3650, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4EB31670-9FC6-11cf-AF6E-00AA00B67A42}               DV splitter
OUR_GUID_ENTRY(CLSID_DVSplitter,
0x4eb31670, 0x9fc6, 0x11cf, 0xaf, 0x6e, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {129D7E40-C10D-11d0-AFB9-00AA00B67A42}               DV muxer
OUR_GUID_ENTRY(CLSID_DVMux,
0x129d7e40, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {060AF76C-68DD-11d0-8FC1-00C04FD9189D}
OUR_GUID_ENTRY(CLSID_SeekingPassThru,
0x60af76c, 0x68dd, 0x11d0, 0x8f, 0xc1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d)

// 6E8D4A20-310C-11d0-B79A-00AA003767A7                 Line21 (CC) Decoder
OUR_GUID_ENTRY(CLSID_Line21Decoder,
0x6e8d4a20, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// {CD8743A1-3736-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_OverlayMixer, 
0xcd8743a1, 0x3736, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9800-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VBISurfaces, 
0x814b9800, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// pnp objects and categories
// 62BE5D10-60EB-11d0-BD3B-00A0C911CE86                 ICreateDevEnum
OUR_GUID_ENTRY(CLSID_SystemDeviceEnum,
0x62BE5D10,0x60EB,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 4315D437-5B8C-11d0-BD3B-00A0C911CE86
OUR_GUID_ENTRY(CLSID_CDeviceMoniker,
0x4315D437,0x5B8C,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 860BB310-5D01-11d0-BD3B-00A0C911CE86                 Video capture category
OUR_GUID_ENTRY(CLSID_VideoInputDeviceCategory,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CVidCapClassManager,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 083863F1-70DE-11d0-BD40-00A0C911CE86                 Filter category
OUR_GUID_ENTRY(CLSID_LegacyAmFilterCategory,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CQzFilterClassManager,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 33D9A760-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_VideoCompressorCategory,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CIcmCoClassManager,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A761-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_AudioCompressorCategory,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CAcmCoClassManager,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A762-90C8-11d0-BD43-00A0C911CE86                 Audio source cateogry
OUR_GUID_ENTRY(CLSID_AudioInputDeviceCategory,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveinClassManager,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// E0F158E1-CB04-11d0-BD4E-00A0C911CE86                 Audio renderer category
OUR_GUID_ENTRY(CLSID_AudioRendererCategory,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveOutClassManager,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 4EFE2452-168A-11d1-BC76-00C04FB9453B			Midi renderer category
OUR_GUID_ENTRY(CLSID_MidiRendererCategory,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)
OUR_GUID_ENTRY(CLSID_CMidiOutClassManager,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)

// DA4E3DA0-D07D-11d0-BD50-00A0C911CE86
OUR_GUID_ENTRY(CLSID_ActiveMovieCategories,
0xda4e3da0, 0xd07d, 0x11d0, 0xbd, 0x50, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 2721AE20-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(CLSID_DVDHWDecodersCategory,
0x2721AE20, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// CDA42200-BD88-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_FilterMapper2,
0xcda42200, 0xbd88, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)


// 1e651cc0-b199-11d0-8212-00c04fc32c45
OUR_GUID_ENTRY(CLSID_MemoryAllocator,
0x1e651cc0, 0xb199, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45)

// CDBD8D00-C193-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_MediaPropertyBag,
0xcdbd8d00, 0xc193, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
			
// FCC152B7-F372-11d0-8E00-00C04FD7C08B
OUR_GUID_ENTRY(CLSID_DvdGraphBuilder,
0xFCC152B7, 0xF372, 0x11d0, 0x8E, 0x00, 0x00, 0xC0, 0x4F, 0xD7, 0xC0, 0x8B)

// 9B8C4620-2C1A-11d0-8493-00A02438AD48
OUR_GUID_ENTRY(CLSID_DVDNavigator,
0x9b8c4620, 0x2c1a, 0x11d0, 0x84, 0x93, 0x0, 0xa0, 0x24, 0x38, 0xad, 0x48)

// CC58E280-8AA1-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(CLSID_SmartTee,
0xcc58e280, 0x8aa1, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)


// -- format types ---

// 0F6417D6-C318-11D0-A43F-00A0C9223196	       FORMAT_None
OUR_GUID_ENTRY(FORMAT_None,
0x0F6417D6, 0xc318, 0x11d0, 0xa4, 0x3f, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96)

// 05589f80-c356-11ce-bf01-00aa0055595a        FORMAT_VideoInfo
OUR_GUID_ENTRY(FORMAT_VideoInfo,
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA        FORMAT_VideoInfo2
OUR_GUID_ENTRY(FORMAT_VideoInfo2,
0xf72a76A0, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 05589f81-c356-11ce-bf01-00aa0055595a        FORMAT_WaveFormatEx
OUR_GUID_ENTRY(FORMAT_WaveFormatEx,
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f82-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGVideo
OUR_GUID_ENTRY(FORMAT_MPEGVideo,
0x05589f82, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f83-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGStreams
OUR_GUID_ENTRY(FORMAT_MPEGStreams,
0x05589f83, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f84-c356-11ce-bf01-00aa0055595a        FORMAT_DvInfo, DVINFO
OUR_GUID_ENTRY(FORMAT_DvInfo,
0x05589f84, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)


// -- Video related GUIDs ---


// 944d4c00-dd52-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(CLSID_DirectDrawProperties,
0x944d4c00, 0xdd52, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 59ce6880-acf8-11cf-b56e-0080c7c4b68a
OUR_GUID_ENTRY(CLSID_PerformanceProperties,
0x59ce6880, 0xacf8, 0x11cf, 0xb5, 0x6e, 0x00, 0x80, 0xc7, 0xc4, 0xb6, 0x8a)

// 418afb70-f8b8-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(CLSID_QualityProperties,
0x418afb70, 0xf8b8, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// 61ded640-e912-11ce-a099-00aa00479a58
OUR_GUID_ENTRY(IID_IBaseVideoMixer,
0x61ded640, 0xe912, 0x11ce, 0xa0, 0x99, 0x00, 0xaa, 0x00, 0x47, 0x9a, 0x58)

// 36d39eb0-dd75-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(IID_IDirectDrawVideo,
0x36d39eb0, 0xdd75, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// bd0ecb0-f8e2-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(IID_IQualProp,
0x1bd0ecb0, 0xf8e2, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// {CE292861-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_VPObject, 
0xce292861, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {CE292862-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPObject, 
0xce292862, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {25DF12C1-3DE0-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPControl, 
0x25df12c1, 0x3de0, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9801-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VPVBIObject, 
0x814b9801, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {814B9802-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIObject, 
0x814b9802, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {BC29A660-30E3-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPConfig,
0xbc29a660, 0x30e3, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {C76794A1-D6C5-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify,
0xc76794a1, 0xd6c5, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47183-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify2,
0xebf47183, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// {EC529B00-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIConfig,
0xec529b00, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {EC529B01-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBINotify,
0xec529b01, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {593CDDE1-0759-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig, 
0x593cdde1, 0x759, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47182-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig2,
0xebf47182, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// This is a real pain in the neck. The OLE GUIDs are separated out into a
// different file from the main header files. The header files can then be
// included multiple times and are protected with the following statements,
//
//      #ifndef __SOMETHING_DEFINED__
//      #define __SOMETHING_DEFINED__
//          all the header contents
//      #endif // __SOMETHING_DEFINED__
//
// When the actual GUIDs are to be defined (using initguid) the GUID header
// file can then be included to really define them just once. Unfortunately
// DirectDraw has the GUIDs defined in the main header file. So if the base
// classes bring in ddraw.h to get at the DirectDraw structures and so on
// nobody would then be able to really include ddraw.h to allocate the GUID
// memory structures because of the aforementioned header file protection
// Therefore the DirectDraw GUIDs are defined and allocated for real here

#ifndef __DDRAW_INCLUDED__
OUR_GUID_ENTRY(CLSID_DirectDraw,	    0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35)
OUR_GUID_ENTRY(CLSID_DirectDrawClipper,	    0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDraw,		    0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDraw2,	    0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDrawSurface,	    0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawSurface2,	    0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27)
OUR_GUID_ENTRY(IID_IDirectDrawSurface3,	    0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB)
OUR_GUID_ENTRY(IID_IDirectDrawPalette,	    0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawClipper,	    0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawColorControl, 0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

#ifndef __DVP_INCLUDED__
OUR_GUID_ENTRY(IID_IDDVideoPortContainer,    0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
#endif

#ifndef __DDKM_INCLUDED__
OUR_GUID_ENTRY(IID_IDirectDrawKernel,        0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
OUR_GUID_ENTRY(IID_IDirectDrawSurfaceKernel, 0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

// 0618aa30-6bc4-11cf-bf36-00aa0055595a
OUR_GUID_ENTRY(CLSID_ModexProperties,
0x0618aa30, 0x6bc4, 0x11cf, 0xbf, 0x36, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// dd1d7110-7836-11cf-bf47-00aa0055595a
OUR_GUID_ENTRY(IID_IFullScreenVideo,
0xdd1d7110, 0x7836, 0x11cf, 0xbf, 0x47, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 53479470-f1dd-11cf-bc42-00aa00ac74f6
OUR_GUID_ENTRY(IID_IFullScreenVideoEx,
0x53479470, 0xf1dd, 0x11cf, 0xbc, 0x42, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// {101193C0-0BFE-11d0-AF91-00AA00B67A42}           DV decoder property
OUR_GUID_ENTRY(CLSID_DVDecPropertiesPage,       
0x101193c0, 0xbfe, 0x11d0, 0xaf, 0x91, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4150F050-BB6F-11d0-AFB9-00AA00B67A42}           DV encoder property
OUR_GUID_ENTRY(CLSID_DVEncPropertiesPage,
0x4150f050, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4DB880E0-C10D-11d0-AFB9-00AA00B67A42}           DV Muxer property
OUR_GUID_ENTRY(CLSID_DVMuxPropertyPage,
0x4db880e0, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)


// -- Direct Sound Audio related GUID ---

// 546F4260-D53E-11cf-B3F0-00AA003761C5
OUR_GUID_ENTRY(IID_IAMDirectSound,
0x546f4260, 0xd53e, 0x11cf, 0xb3, 0xf0, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -- MPEG audio decoder properties

// {b45dd570-3c77-11d1-abe1-00a0c905f375}
OUR_GUID_ENTRY(IID_IMpegAudioDecoder,
0xb45dd570, 0x3c77, 0x11d1, 0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// --- Line21 Decoder interface GUID ---

// 6E8D4A21-310C-11d0-B79A-00AA003767A7            IID_IAMLine21Decoder
OUR_GUID_ENTRY(IID_IAMLine21Decoder,
0x6e8d4a21, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// -- Analog video related GUIDs ---


// -- format types ---
// 0482DDE0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(FORMAT_AnalogVideo,
0x482dde0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- major type, Analog Video

// 0482DDE1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIATYPE_AnalogVideo,
0x482dde1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- Analog Video subtypes, NTSC

// 0482DDE2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_NTSC_M,
0x482dde2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, PAL

// 0482DDE5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_B,
0x482dde5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_D,
0x482dde6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE7-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_G,
0x482dde7, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE8-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_H,
0x482dde8, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE9-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_I,
0x482dde9, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEA-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_M,
0x482ddea, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEB-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N,
0x482ddeb, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, SECAM

// 0482DDF0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_B,
0x482ddf0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_D,
0x482ddf1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_G,
0x482ddf2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF3-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_H,
0x482ddf3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF4-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K,
0x482ddf4, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K1,
0x482ddf5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_L,
0x482ddf6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// --  External audio related GUIDs ---

// -- major types, Analog Audio

// 0482DEE1-7817-11cf-8a03-00aa006ecb65
OUR_GUID_ENTRY(MEDIATYPE_AnalogAudio,
0x482dee1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

//
// DirectShow's include file based on ksmedia.h from WDM DDK
//
#include "ksuuids.h"


// -- Well known time format GUIDs ---


// 00000000-0000-0000-0000-000000000000
OUR_GUID_ENTRY(TIME_FORMAT_NONE,
0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

// 7b785570-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FRAME,
0x7b785570, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785571-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_BYTE,
0x7b785571, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785572-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_SAMPLE,
0x7b785572, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785573-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FIELD,
0x7b785573, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// 7b785574-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_MEDIA_TIME,
0x7b785574, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// for IKsPropertySet

// 9B00F101-1567-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(AMPROPSETID_Pin,
0x9b00f101, 0x1567, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// fb6c4281-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CAPTURE,
0xfb6c4281, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4282-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_PREVIEW,
0xfb6c4282, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4283-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_ANALOGVIDEOIN,
0xfb6c4283, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4284-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VBI,
0xfb6c4284, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4285-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT,
0xfb6c4285, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4286-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_NABTS,
0xfb6c4286, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4287-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_EDS,
0xfb6c4287, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4288-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TELETEXT,
0xfb6c4288, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4289-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CC,
0xfb6c4289, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428a-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_STILL,
0xfb6c428a, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428b-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TIMECODE,
0xfb6c428b, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428c-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT_VBI,
0xfb6c428c, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)


// the following special GUIDS are used by ICaptureGraphBuilder::FindInterface

// {AC798BE0-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_UPSTREAM_ONLY,
0xac798be0, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// {AC798BE1-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_DOWNSTREAM_ONLY,
0xac798be1, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -------------------------------------------------------------------------
// KSProxy GUIDS
// -------------------------------------------------------------------------

// {266EEE41-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_TVTunerFilterPropertyPage, 
0x266eee41, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// {71F96461-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,
0x71f96461, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96463-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,
0x71f96463, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96464-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoProcAmpPropertyPage,
0x71f96464, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96465-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CameraControlPropertyPage,
0x71f96465, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)
                                  
// {71F96466-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_AnalogVideoDecoderPropertyPage,
0x71f96466, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)
                                  
// {71F96467-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoStreamConfigPropertyPage,
0x71f96467, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)
                                  
#undef OUR_GUID_ENTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\wxdebug.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// ActiveX system debugging facilities

#define _WINDLL

#include <streams.h>
#include <stdarg.h>
#include <stdio.h>

#ifdef DEBUG
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif // _UNICODE
#endif // UNICODE
#endif // DEBUG

#include <tchar.h>

#ifdef DEBUG

const INT iDEBUGINFO = 512;                 // Used to format strings
const INT iMAXLEVELS = 5;                   // Maximum debug categories

HINSTANCE m_hInst;                          // Module instance handle
TCHAR m_ModuleName[iDEBUGINFO];             // Cut down module name
DWORD m_Levels[iMAXLEVELS];                 // Debug level per category
CRITICAL_SECTION m_CSDebug;                 // Controls access to list
DWORD m_dwNextCookie;                       // Next active object ID
ObjectDesc *pListHead = NULL;               // First active object
DWORD m_dwObjectCount;                      // Active object count
BOOL m_bInit = FALSE;                       // Have we been initialised
HANDLE m_hOutput = INVALID_HANDLE_VALUE;    // Optional output written here
DWORD dwWaitTimeout = INFINITE;             // Default timeout value
DWORD dwTimeOffset;			    // Time of first DbgLog call
bool g_fUseKASSERT = false;                 // don't create messagebox
bool g_fDbgInDllEntryPoint = false;

const TCHAR *pBaseKey = TEXT("SOFTWARE\\Debug");
const TCHAR *pGlobalKey = TEXT("GLOBAL");
static TCHAR *pUnknownName = TEXT("UNKNOWN");

/* For every module and executable we store a debugging level for each of
   the five categories (eg LOG_ERROR and LOG_TIMING). This makes it easy
   to isolate and debug individual modules without seeing everybody elses
   spurious debug output. The keys are stored in the registry under the
   HKEY_LOCAL_MACHINE\SOFTWARE\Debug\<Module Name>\<KeyName> key values
   NOTE these must be in the same order as their enumeration definition */

TCHAR *pKeyNames[] = {
    TEXT("TIMING"),      // Timing and performance measurements
    TEXT("TRACE"),       // General step point call tracing
    TEXT("MEMORY"),      // Memory and object allocation/destruction
    TEXT("LOCKING"),     // Locking/unlocking of critical sections
    TEXT("ERROR")        // Debug error notification
    };

TCHAR *TimeoutName = TEXT("TIMEOUT");

/* This sets the instance handle that the debug library uses to find
   the module's file name from the Win32 GetModuleFileName function */

void WINAPI DbgInitialise(HINSTANCE hInst)
{
    InitializeCriticalSection(&m_CSDebug);
    m_bInit = TRUE;

    m_hInst = hInst;
    DbgInitModuleName();
    if (GetProfileInt(m_ModuleName, TEXT("BreakOnLoad"), 0))
       DebugBreak();
    DbgInitModuleSettings();
    DbgInitGlobalSettings();
    dwTimeOffset = timeGetTime();
}


/* This is called to clear up any resources the debug library uses - at the
   moment we delete our critical section and the object list. The values we
   retrieve from the registry are all done during initialisation but we don't
   go looking for update notifications while we are running, if the values
   are changed then the application has to be restarted to pick them up */

void WINAPI DbgTerminate()
{
    if (m_hOutput != INVALID_HANDLE_VALUE) {
       EXECUTE_ASSERT(CloseHandle(m_hOutput));
       m_hOutput = INVALID_HANDLE_VALUE;
    }
    DeleteCriticalSection(&m_CSDebug);
    m_bInit = FALSE;
}


/* This is called by DbgInitLogLevels to read the debug settings
   for each logging category for this module from the registry */

void WINAPI DbgInitKeyLevels(HKEY hKey)
{
    LONG lReturn;               // Create key return value
    LONG lKeyPos;               // Current key category
    DWORD dwKeySize;            // Size of the key value
    DWORD dwKeyType;            // Receives it's type
    DWORD dwKeyValue;           // This fields value

    /* Try and read a value for each key position in turn */
    for (lKeyPos = 0;lKeyPos < iMAXLEVELS;lKeyPos++) {

        dwKeySize = sizeof(DWORD);
        lReturn = RegQueryValueEx(
            hKey,                       // Handle to an open key
            pKeyNames[lKeyPos],         // Subkey name derivation
            NULL,                       // Reserved field
            &dwKeyType,                 // Returns the field type
            (LPBYTE) &dwKeyValue,       // Returns the field's value
            &dwKeySize );               // Number of bytes transferred

        /* If either the key was not available or it was not a DWORD value
           then we ensure only the high priority debug logging is output
           but we try and update the field to a zero filled DWORD value */

        if (lReturn != ERROR_SUCCESS || dwKeyType != REG_DWORD)  {

            dwKeyValue = 0;
            lReturn = RegSetValueEx(
                hKey,                   // Handle of an open key
                pKeyNames[lKeyPos],     // Address of subkey name
                (DWORD) 0,              // Reserved field
                REG_DWORD,              // Type of the key field
                (PBYTE) &dwKeyValue,    // Value for the field
                sizeof(DWORD));         // Size of the field buffer

            if (lReturn != ERROR_SUCCESS) {
                DbgLog((LOG_ERROR,0,TEXT("Could not create subkey %s"),pKeyNames[lKeyPos]));
                dwKeyValue = 0;
            }
        }
        m_Levels[lKeyPos] = max(dwKeyValue,m_Levels[lKeyPos]);
    }

    /*  Read the timeout value for catching hangs */
    dwKeySize = sizeof(DWORD);
    lReturn = RegQueryValueEx(
        hKey,                       // Handle to an open key
        TimeoutName,                // Subkey name derivation
        NULL,                       // Reserved field
        &dwKeyType,                 // Returns the field type
        (LPBYTE) &dwWaitTimeout,    // Returns the field's value
        &dwKeySize );               // Number of bytes transferred

    /* If either the key was not available or it was not a DWORD value
       then we ensure only the high priority debug logging is output
       but we try and update the field to a zero filled DWORD value */

    if (lReturn != ERROR_SUCCESS || dwKeyType != REG_DWORD)  {

        dwWaitTimeout = INFINITE;
        lReturn = RegSetValueEx(
            hKey,                   // Handle of an open key
            TimeoutName,            // Address of subkey name
            (DWORD) 0,              // Reserved field
            REG_DWORD,              // Type of the key field
            (PBYTE) &dwWaitTimeout, // Value for the field
            sizeof(DWORD));         // Size of the field buffer

        if (lReturn != ERROR_SUCCESS) {
            DbgLog((LOG_ERROR,0,TEXT("Could not create subkey %s"),pKeyNames[lKeyPos]));
            dwWaitTimeout = INFINITE;
        }
    }
}

void WINAPI DbgOutString(LPCTSTR psz)
{
    if (m_hOutput != INVALID_HANDLE_VALUE) {
        UINT  cb = lstrlen(psz);
        DWORD dw;
        WriteFile (m_hOutput, psz, cb, &dw, NULL);
    } else {
        OutputDebugString (psz);
    }
}

/* Called by DbgInitGlobalSettings to setup alternate logging destinations
 */

void WINAPI DbgInitLogTo (
    HKEY hKey)
{
    LONG  lReturn;
    DWORD dwKeyType;
    DWORD dwKeySize;
    TCHAR szFile[MAX_PATH] = {0};
    static const TCHAR cszKey[] = TEXT("LogToFile");

    dwKeySize = MAX_PATH;
    lReturn = RegQueryValueEx(
        hKey,                       // Handle to an open key
        cszKey,                     // Subkey name derivation
        NULL,                       // Reserved field
        &dwKeyType,                 // Returns the field type
        (LPBYTE) szFile,            // Returns the field's value
        &dwKeySize);                // Number of bytes transferred

    // create an empty key if it does not already exist
    //
    if (lReturn != ERROR_SUCCESS || dwKeyType != REG_SZ)
       {
       dwKeySize = 1;
       lReturn = RegSetValueEx(
            hKey,                   // Handle of an open key
            cszKey,                 // Address of subkey name
            (DWORD) 0,              // Reserved field
            REG_SZ,                 // Type of the key field
            (PBYTE)szFile,          // Value for the field
            dwKeySize);            // Size of the field buffer
       }

    // if an output-to was specified.  try to open it.
    //
    if (m_hOutput != INVALID_HANDLE_VALUE) {
       EXECUTE_ASSERT(CloseHandle (m_hOutput));
       m_hOutput = INVALID_HANDLE_VALUE;
    }
    if (szFile[0] != 0)
       {
       if (!lstrcmpi(szFile, TEXT("Console"))) {
          m_hOutput = GetStdHandle (STD_OUTPUT_HANDLE);
          if (m_hOutput == INVALID_HANDLE_VALUE) {
             AllocConsole ();
             m_hOutput = GetStdHandle (STD_OUTPUT_HANDLE);
          }
          SetConsoleTitle (TEXT("ActiveX Debug Output"));
       } else if (szFile[0] &&
                lstrcmpi(szFile, TEXT("Debug")) &&
                lstrcmpi(szFile, TEXT("Debugger")) &&
                lstrcmpi(szFile, TEXT("Deb")))
          {
          m_hOutput = CreateFile(szFile, GENERIC_WRITE,
                                 FILE_SHARE_READ,
                                 NULL, OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);
          if (INVALID_HANDLE_VALUE != m_hOutput)
              {
              static const TCHAR cszBar[] = TEXT("\r\n\r\n=====DbgInitialize()=====\r\n\r\n");
              SetFilePointer (m_hOutput, 0, NULL, FILE_END);
              DbgOutString (cszBar);
              }
          }
       }
}



/* This is called by DbgInitLogLevels to read the global debug settings for
   each logging category for this module from the registry. Normally each
   module has it's own values set for it's different debug categories but
   setting the global SOFTWARE\Debug\Global applies them to ALL modules */

void WINAPI DbgInitGlobalSettings()
{
    LONG lReturn;               // Create key return value
    TCHAR szInfo[iDEBUGINFO];   // Constructs key names
    HKEY hGlobalKey;            // Global override key

    /* Construct the global base key name */
    wsprintf(szInfo,TEXT("%s\\%s"),pBaseKey,pGlobalKey);

    /* Create or open the key for this module */
    lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,   // Handle of an open key
                             szInfo,               // Address of subkey name
                             (DWORD) 0,            // Reserved value
                             NULL,                 // Address of class name
                             (DWORD) 0,            // Special options flags
                             KEY_ALL_ACCESS,       // Desired security access
                             NULL,                 // Key security descriptor
                             &hGlobalKey,          // Opened handle buffer
                             NULL);                // What really happened

    if (lReturn != ERROR_SUCCESS) {
        DbgLog((LOG_ERROR,0,TEXT("Could not access GLOBAL module key")));
        return;
    }

    DbgInitKeyLevels(hGlobalKey);
    RegCloseKey(hGlobalKey);
}


/* This sets the debugging log levels for the different categories. We start
   by opening (or creating if not already available) the SOFTWARE\Debug key
   that all these settings live under. We then look at the global values
   set under SOFTWARE\Debug\Global which apply on top of the individual
   module settings. We then load the individual module registry settings */

void WINAPI DbgInitModuleSettings()
{
    LONG lReturn;               // Create key return value
    TCHAR szInfo[iDEBUGINFO];   // Constructs key names
    HKEY hModuleKey;            // Module key handle

    /* Construct the base key name */
    wsprintf(szInfo,TEXT("%s\\%s"),pBaseKey,m_ModuleName);

    /* Create or open the key for this module */
    lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,   // Handle of an open key
                             szInfo,               // Address of subkey name
                             (DWORD) 0,            // Reserved value
                             NULL,                 // Address of class name
                             (DWORD) 0,            // Special options flags
                             KEY_ALL_ACCESS,       // Desired security access
                             NULL,                 // Key security descriptor
                             &hModuleKey,          // Opened handle buffer
                             NULL);                // What really happened

    if (lReturn != ERROR_SUCCESS) {
        DbgLog((LOG_ERROR,0,TEXT("Could not access module key")));
        return;
    }

    DbgInitLogTo(hModuleKey);
    DbgInitKeyLevels(hModuleKey);
    RegCloseKey(hModuleKey);
}


/* Initialise the module file name */

void WINAPI DbgInitModuleName()
{
    TCHAR FullName[iDEBUGINFO];     // Load the full path and module name
    TCHAR *pName;                   // Searches from the end for a backslash

    GetModuleFileName(m_hInst,FullName,iDEBUGINFO);
    pName = _tcsrchr(FullName,'\\');
    if (pName == NULL) {
        pName = FullName;
    } else {
        pName++;
    }
    lstrcpy(m_ModuleName,pName);
}

struct MsgBoxMsg
{
    HWND hwnd;
    TCHAR *szTitle;
    TCHAR *szMessage;
    DWORD dwFlags;
    INT iResult;
};

//
// create a thread to call MessageBox(). calling MessageBox() on
// random threads at bad times can confuse the host (eg IE).
//
DWORD WINAPI MsgBoxThread(
  LPVOID lpParameter   // thread data
  )
{
    MsgBoxMsg *pmsg = (MsgBoxMsg *)lpParameter;
    pmsg->iResult = MessageBox(
        pmsg->hwnd,
        pmsg->szTitle,
        pmsg->szMessage,
        pmsg->dwFlags);
    
    return 0;
}

INT MessageBoxOtherThread(
    HWND hwnd,
    TCHAR *szTitle,
    TCHAR *szMessage,
    DWORD dwFlags)
{
    if(g_fDbgInDllEntryPoint)
    {
        // can't wait on another thread because we have the loader
        // lock held in the dll entry point.
        return MessageBox(hwnd, szTitle, szMessage, dwFlags);
    }
    else
    {
        MsgBoxMsg msg = {hwnd, szTitle, szMessage, dwFlags, 0};
        DWORD dwid;
        HANDLE hThread = CreateThread(
            0,                      // security
            0,                      // stack size
            MsgBoxThread,
            (void *)&msg,           // arg
            0,                      // flags
            &dwid);
        if(hThread)
        {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
            return msg.iResult;
        }

        // break into debugger on failure.
        return IDCANCEL;
    }
}


/* Displays a message box if the condition evaluated to FALSE */

void WINAPI DbgAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine)
{
    if(g_fUseKASSERT)
    {
        DbgKernelAssert(pCondition, pFileName, iLine);
    }
    else
    {

        TCHAR szInfo[iDEBUGINFO];

        wsprintf(szInfo, TEXT("%s \nAt line %d of %s\nContinue? (Cancel to debug)"),
                 pCondition, iLine, pFileName);

        INT MsgId = MessageBoxOtherThread(NULL,szInfo,TEXT("ASSERT Failed"),
                                          MB_SYSTEMMODAL |
                                          MB_ICONHAND |
                                          MB_YESNOCANCEL |
                                          MB_SETFOREGROUND);
        switch (MsgId)
        {
          case IDNO:              /* Kill the application */

              FatalAppExit(FALSE, TEXT("Application terminated"));
              break;

          case IDCANCEL:          /* Break into the debugger */

              DebugBreak();
              break;

          case IDYES:             /* Ignore assertion continue execution */
              break;
        }
    }
}

/* Displays a message box at a break point */

void WINAPI DbgBreakPoint(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine)
{
    if(g_fUseKASSERT)
    {
        DbgKernelAssert(pCondition, pFileName, iLine);
    }
    else
    {
        TCHAR szInfo[iDEBUGINFO];

        wsprintf(szInfo, TEXT("%s \nAt line %d of %s\nContinue? (Cancel to debug)"),
                 pCondition, iLine, pFileName);

        INT MsgId = MessageBoxOtherThread(NULL,szInfo,TEXT("Hard coded break point"),
                                          MB_SYSTEMMODAL |
                                          MB_ICONHAND |
                                          MB_YESNOCANCEL |
                                          MB_SETFOREGROUND);
        switch (MsgId)
        {
          case IDNO:              /* Kill the application */

              FatalAppExit(FALSE, TEXT("Application terminated"));
              break;

          case IDCANCEL:          /* Break into the debugger */

              DebugBreak();
              break;

          case IDYES:             /* Ignore break point continue execution */
              break;
        }
    }
}


/* When we initialised the library we stored in the m_Levels array the current
   debug output level for this module for each of the five categories. When
   some debug logging is sent to us it can be sent with a combination of the
   categories (if it is applicable to many for example) in which case we map
   the type's categories into their current debug levels and see if any of
   them can be accepted. The function looks at each bit position in turn from
   the input type field and then compares it's debug level with the modules.

   A level of 0 means that output is always sent to the debugger.  This is
   due to producing output if the input level is <= m_Levels.
*/


BOOL WINAPI DbgCheckModuleLevel(DWORD Type,DWORD Level)
{
    DWORD Mask = 0x01;

    // If no valid bits are set return FALSE
    if ((Type & ((1<<iMAXLEVELS)-1))) {

	// speed up unconditional output.
	if (0==Level)
	    return(TRUE);
	
        for (LONG lKeyPos = 0;lKeyPos < iMAXLEVELS;lKeyPos++) {
            if (Type & Mask) {
                if (Level <= m_Levels[lKeyPos]) {
                    return TRUE;
                }
            }
            Mask <<= 1;
        }
    }
    return FALSE;
}


/* Set debug levels to a given value */

void WINAPI DbgSetModuleLevel(DWORD Type, DWORD Level)
{
    DWORD Mask = 0x01;

    for (LONG lKeyPos = 0;lKeyPos < iMAXLEVELS;lKeyPos++) {
        if (Type & Mask) {
            m_Levels[lKeyPos] = Level;
        }
        Mask <<= 1;
    }
}

/* Print a formatted string to the debugger prefixed with this module's name
   Because the COMBASE classes are linked statically every module loaded will
   have their own copy of this code. It therefore helps if the module name is
   included on the output so that the offending code can be easily found */

void WINAPI DbgLogInfo(DWORD Type,DWORD Level,const TCHAR *pFormat,...)
{
    /* Check the current level for this type combination */

    BOOL bAccept = DbgCheckModuleLevel(Type,Level);
    if (bAccept == FALSE) {
        return;
    }

    TCHAR szInfo[2000];

    /* Format the variable length parameter list */

    va_list va;
    va_start(va, pFormat);

    lstrcpy(szInfo,m_ModuleName);
    wsprintf(szInfo + lstrlen(szInfo),
             TEXT("(tid %x) %8d : "),
             GetCurrentThreadId(), timeGetTime() - dwTimeOffset);

    wvsprintf(szInfo + lstrlen(szInfo), pFormat, va);
    lstrcat(szInfo, TEXT("\r\n"));
    DbgOutString(szInfo);

    va_end(va);
}


/* If we are executing as a pure kernel filter we cannot display message
   boxes to the user, this provides an alternative which puts the error
   condition on the debugger output with a suitable eye catching message */

void WINAPI DbgKernelAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine)
{
    DbgLog((LOG_ERROR,0,TEXT("Assertion FAILED (%s) at line %d in file %s"),
           pCondition, iLine, pFileName));
    DebugBreak();
}



/* Each time we create an object derived from CBaseObject the constructor will
   call us to register the creation of the new object. We are passed a string
   description which we store away. We return a cookie that the constructor
   uses to identify the object when it is destroyed later on. We update the
   total number of active objects in the DLL mainly for debugging purposes */

DWORD WINAPI DbgRegisterObjectCreation(const TCHAR *pObjectName)
{
    /* If this fires you have a mixed DEBUG/RETAIL build */

    ASSERT(pObjectName);

    /* Create a place holder for this object description */

    ObjectDesc *pObject = new ObjectDesc;
    ASSERT(pObject);

    /* It is valid to pass a NULL object name */
    if (pObject == NULL) {
        return FALSE;
    }

    /* Check we have been initialised - we may not be initialised when we are
       being pulled in from an executable which has globally defined objects
       as they are created by the C++ run time before WinMain is called */

    if (m_bInit == FALSE) {
        DbgInitialise(GetModuleHandle(NULL));
    }

    /* Grab the list critical section */
    EnterCriticalSection(&m_CSDebug);

    /* If no name then default to UNKNOWN */
    if (pObjectName == NULL) {
        pObjectName = pUnknownName;
    }

    /* Put the new description at the head of the list */

    pObject->m_pName = pObjectName;
    pObject->m_dwCookie = ++m_dwNextCookie;
    pObject->m_pNext = pListHead;

    pListHead = pObject;
    m_dwObjectCount++;

    DWORD ObjectCookie = pObject->m_dwCookie;
    ASSERT(ObjectCookie);

    DbgLog((LOG_MEMORY,2,TEXT("Object created   %d (%s) %d Active"),
            pObject->m_dwCookie, pObjectName, m_dwObjectCount));

    LeaveCriticalSection(&m_CSDebug);
    return ObjectCookie;
}


/* This is called by the CBaseObject destructor when an object is about to be
   destroyed, we are passed the cookie we returned during construction that
   identifies this object. We scan the object list for a matching cookie and
   remove the object if successful. We also update the active object count */

BOOL WINAPI DbgRegisterObjectDestruction(DWORD dwCookie)
{
    /* Grab the list critical section */
    EnterCriticalSection(&m_CSDebug);

    ObjectDesc *pObject = pListHead;
    ObjectDesc *pPrevious = NULL;

    /* Scan the object list looking for a cookie match */

    while (pObject) {
        if (pObject->m_dwCookie == dwCookie) {
            break;
        }
        pPrevious = pObject;
        pObject = pObject->m_pNext;
    }

    if (pObject == NULL) {
        DbgBreak("Apparently destroying a bogus object");
        LeaveCriticalSection(&m_CSDebug);
        return FALSE;
    }

    /* Is the object at the head of the list */

    if (pPrevious == NULL) {
        pListHead = pObject->m_pNext;
    } else {
        pPrevious->m_pNext = pObject->m_pNext;
    }

    /* Delete the object and update the housekeeping information */

    m_dwObjectCount--;
    DbgLog((LOG_MEMORY,2,TEXT("Object destroyed %d (%s) %d Active"),
            pObject->m_dwCookie, pObject->m_pName, m_dwObjectCount));

    delete pObject;
    LeaveCriticalSection(&m_CSDebug);
    return TRUE;
}


/* This runs through the active object list displaying their details */

void WINAPI DbgDumpObjectRegister()
{
    TCHAR szInfo[iDEBUGINFO];

    /* Grab the list critical section */

    EnterCriticalSection(&m_CSDebug);
    ObjectDesc *pObject = pListHead;

    /* Scan the object list displaying the name and cookie */

    DbgLog((LOG_MEMORY,2,TEXT("")));
    DbgLog((LOG_MEMORY,2,TEXT("   ID             Object Description")));
    DbgLog((LOG_MEMORY,2,TEXT("")));

    while (pObject) {
        wsprintf(szInfo,TEXT("%5d (%8x) %30s"),pObject->m_dwCookie, &pObject, pObject->m_pName);
        DbgLog((LOG_MEMORY,2,szInfo));
        pObject = pObject->m_pNext;
    }

    wsprintf(szInfo,TEXT("Total object count %5d"),m_dwObjectCount);
    DbgLog((LOG_MEMORY,2,TEXT("")));
    DbgLog((LOG_MEMORY,1,szInfo));
    LeaveCriticalSection(&m_CSDebug);
}

/*  Debug infinite wait stuff */
DWORD WINAPI DbgWaitForSingleObject(HANDLE h)
{
    DWORD dwWaitResult;
    do {
        dwWaitResult = WaitForSingleObject(h, dwWaitTimeout);
        ASSERT(dwWaitResult == WAIT_OBJECT_0);
    } while (dwWaitResult == WAIT_TIMEOUT);
    return dwWaitResult;
}
DWORD WINAPI DbgWaitForMultipleObjects(DWORD nCount,
                                CONST HANDLE *lpHandles,
                                BOOL bWaitAll)
{
    DWORD dwWaitResult;
    do {
        dwWaitResult = WaitForMultipleObjects(nCount,
                                              lpHandles,
                                              bWaitAll,
                                              dwWaitTimeout);
        ASSERT((DWORD)(dwWaitResult - WAIT_OBJECT_0) < MAXIMUM_WAIT_OBJECTS);
    } while (dwWaitResult == WAIT_TIMEOUT);
    return dwWaitResult;
}

void WINAPI DbgSetWaitTimeout(DWORD dwTimeout)
{
    dwWaitTimeout = dwTimeout;
}

#endif /* DEBUG */

#ifdef _OBJBASE_H_

    /*  Stuff for printing out our GUID names */

    GUID_STRING_ENTRY g_GuidNames[] = {
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    { TEXT(#name), { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } } },
        #include <uuids.h>
    };

    CGuidNameList GuidNames;
    int g_cGuidNames = sizeof(g_GuidNames) / sizeof(g_GuidNames[0]);

    TCHAR *CGuidNameList::operator [] (const GUID &guid)
    {
        for (int i = 0; i < g_cGuidNames; i++) {
            if (g_GuidNames[i].guid == guid) {
                return g_GuidNames[i].szName;
            }
        }
        if (guid == GUID_NULL) {
            return TEXT("GUID_NULL");
        }

	// !!! add something to print FOURCC guids?
	
	// shouldn't this print the hex CLSID?
        return TEXT("Unknown GUID Name");
    }

#endif /* _OBJBASE_H_ */

/*  CDisp class - display our data types */

// clashes with REFERENCE_TIME
CDisp::CDisp(LONGLONG ll, int Format)
{
    // note: this could be combined with CDisp(LONGLONG) by
    // introducing a default format of CDISP_REFTIME
    LARGE_INTEGER li;
    li.QuadPart = ll;
    switch (Format) {
	case CDISP_DEC:
	{
	    TCHAR  temp[20];
	    int pos=20;
	    temp[--pos] = 0;
	    int digit;
	    // always output at least one digit
	    do {
		// Get the rightmost digit - we only need the low word
	        digit = li.LowPart % 10;
		li.QuadPart /= 10;
		temp[--pos] = (TCHAR) digit+L'0';
	    } while (li.QuadPart);
	    wsprintf(m_String, TEXT("%s"), temp+pos);
	    break;
	}
	case CDISP_HEX:
	default:
	    wsprintf(m_String, TEXT("0x%X%8.8X"), li.HighPart, li.LowPart);
    }
};

CDisp::CDisp(REFCLSID clsid)
{
    WCHAR strClass[CHARS_IN_GUID+1];
    StringFromGUID2(clsid, strClass, sizeof(strClass) / sizeof(strClass[0]));
    ASSERT(sizeof(m_String)/sizeof(m_String[0]) >= CHARS_IN_GUID+1);
    wsprintf(m_String, TEXT("%ls"), strClass);
};

#ifdef __STREAMS__
/*  Display stuff */
CDisp::CDisp(CRefTime llTime)
{
    LPTSTR lpsz = m_String;
    LONGLONG llDiv;
    if (llTime < 0) {
        llTime = -llTime;
        lpsz += wsprintf(lpsz, TEXT("-"));
    }
    llDiv = (LONGLONG)24 * 3600 * 10000000;
    if (llTime >= llDiv) {
        lpsz += wsprintf(lpsz, TEXT("%d days "), (LONG)(llTime / llDiv));
        llTime = llTime % llDiv;
    }
    llDiv = (LONGLONG)3600 * 10000000;
    if (llTime >= llDiv) {
        lpsz += wsprintf(lpsz, TEXT("%d hrs "), (LONG)(llTime / llDiv));
        llTime = llTime % llDiv;
    }
    llDiv = (LONGLONG)60 * 10000000;
    if (llTime >= llDiv) {
        lpsz += wsprintf(lpsz, TEXT("%d mins "), (LONG)(llTime / llDiv));
        llTime = llTime % llDiv;
    }
    wsprintf(lpsz, TEXT("%d.%3.3d sec"),
             (LONG)llTime / 10000000,
             (LONG)((llTime % 10000000) / 10000));
};

#endif // __STREAMS__


/*  Display pin */
CDisp::CDisp(IPin *pPin)
{
    PIN_INFO pi;
    TCHAR str[MAX_PIN_NAME];
    if (pPin) {
       pPin->QueryPinInfo(&pi);
       QueryPinInfoReleaseFilter(pi);
      #ifndef UNICODE
       WideCharToMultiByte(GetACP(), 0, pi.achName, lstrlenW(pi.achName) + 1,
                           str, MAX_PIN_NAME, NULL, NULL);
      #else
       lstrcpy(str, pi.achName);
      #endif
    } else {
       lstrcpy(str, TEXT("NULL IPin"));
    }

    m_pString = (PTCHAR) new TCHAR[lstrlen(str)+64];
    if (!m_pString) {
	return;
    }

    CLSID clsid;
    pi.pFilter->GetClassID(&clsid);
    wsprintf(m_pString, TEXT("%s(%s)"), GuidNames[clsid], str);
}

CDisp::~CDisp()
{
}

CDispBasic::~CDispBasic()
{
    if (m_pString != m_String) {
	delete [] m_pString;
    }
}

CDisp::CDisp(double d)
{
#ifdef DEBUG
    _stprintf(m_String, TEXT("%.16g"), d);
#else
    wsprintf(m_String, TEXT("%d.%03d"), (int) d, (int) ((d - (int) d) * 1000));
#endif
}


/* If built for debug this will display the media type details. We convert the
   major and subtypes into strings and also ask the base classes for a string
   description of the subtype, so MEDIASUBTYPE_RGB565 becomes RGB 565 16 bit
   We also display the fields in the BITMAPINFOHEADER structure, this should
   succeed as we do not accept input types unless the format is big enough */

#ifdef DEBUG
void WINAPI DisplayType(LPSTR label, const AM_MEDIA_TYPE *pmtIn)
{

    /* Dump the GUID types and a short description */

    DbgLog((LOG_TRACE,5,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("%hs  M type %s  S type %s"), label,
	    GuidNames[pmtIn->majortype],
	    GuidNames[pmtIn->subtype]));
    DbgLog((LOG_TRACE,5,TEXT("Subtype description %s"),GetSubtypeName(&pmtIn->subtype)));

    /* Dump the generic media types */

    if (pmtIn->bTemporalCompression) {
	DbgLog((LOG_TRACE,5,TEXT("Temporally compressed")));
    } else {
	DbgLog((LOG_TRACE,5,TEXT("Not temporally compressed")));
    }

    if (pmtIn->bFixedSizeSamples) {
	DbgLog((LOG_TRACE,5,TEXT("Sample size %d"),pmtIn->lSampleSize));
    } else {
	DbgLog((LOG_TRACE,5,TEXT("Variable size samples")));
    }

    if (pmtIn->formattype == FORMAT_VideoInfo) {
	/* Dump the contents of the BITMAPINFOHEADER structure */
	BITMAPINFOHEADER *pbmi = HEADER(pmtIn->pbFormat);
	VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *)pmtIn->pbFormat;

	DbgLog((LOG_TRACE,5,TEXT("Source rectangle (Left %d Top %d Right %d Bottom %d)"),
	       pVideoInfo->rcSource.left,
	       pVideoInfo->rcSource.top,
	       pVideoInfo->rcSource.right,
	       pVideoInfo->rcSource.bottom));

	DbgLog((LOG_TRACE,5,TEXT("Target rectangle (Left %d Top %d Right %d Bottom %d)"),
	       pVideoInfo->rcTarget.left,
	       pVideoInfo->rcTarget.top,
	       pVideoInfo->rcTarget.right,
	       pVideoInfo->rcTarget.bottom));

	DbgLog((LOG_TRACE,5,TEXT("Size of BITMAPINFO structure %d"),pbmi->biSize));
	if (pbmi->biCompression < 256) {
	    DbgLog((LOG_TRACE,2,TEXT("%dx%dx%d bit  (%d)"),
		    pbmi->biWidth, pbmi->biHeight,
		    pbmi->biBitCount, pbmi->biCompression));
	} else {
	    DbgLog((LOG_TRACE,2,TEXT("%dx%dx%d bit '%4.4hs'"),
		    pbmi->biWidth, pbmi->biHeight,
		    pbmi->biBitCount, &pbmi->biCompression));
	}

	DbgLog((LOG_TRACE,2,TEXT("Image size %d"),pbmi->biSizeImage));
	DbgLog((LOG_TRACE,5,TEXT("Planes %d"),pbmi->biPlanes));
	DbgLog((LOG_TRACE,5,TEXT("X Pels per metre %d"),pbmi->biXPelsPerMeter));
	DbgLog((LOG_TRACE,5,TEXT("Y Pels per metre %d"),pbmi->biYPelsPerMeter));
	DbgLog((LOG_TRACE,5,TEXT("Colours used %d"),pbmi->biClrUsed));

    } else if (pmtIn->majortype == MEDIATYPE_Audio) {
	DbgLog((LOG_TRACE,2,TEXT("     Format type %s"),
	    GuidNames[pmtIn->formattype]));
	DbgLog((LOG_TRACE,2,TEXT("     Subtype %s"),
	    GuidNames[pmtIn->subtype]));

	if ((pmtIn->subtype != MEDIASUBTYPE_MPEG1Packet)
	  && (pmtIn->cbFormat >= sizeof(PCMWAVEFORMAT)))
	{
	    /* Dump the contents of the WAVEFORMATEX type-specific format structure */

	    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmtIn->pbFormat;
            DbgLog((LOG_TRACE,2,TEXT("wFormatTag %u"), pwfx->wFormatTag));
            DbgLog((LOG_TRACE,2,TEXT("nChannels %u"), pwfx->nChannels));
            DbgLog((LOG_TRACE,2,TEXT("nSamplesPerSec %lu"), pwfx->nSamplesPerSec));
            DbgLog((LOG_TRACE,2,TEXT("nAvgBytesPerSec %lu"), pwfx->nAvgBytesPerSec));
            DbgLog((LOG_TRACE,2,TEXT("nBlockAlign %u"), pwfx->nBlockAlign));
            DbgLog((LOG_TRACE,2,TEXT("wBitsPerSample %u"), pwfx->wBitsPerSample));

            /* PCM uses a WAVEFORMAT and does not have the extra size field */

            if (pmtIn->cbFormat >= sizeof(WAVEFORMATEX)) {
                DbgLog((LOG_TRACE,2,TEXT("cbSize %u"), pwfx->cbSize));
            }
	} else {
	}

    } else {
	DbgLog((LOG_TRACE,2,TEXT("     Format type %s"),
	    GuidNames[pmtIn->formattype]));
	// !!!! should add code to dump wave format, others
    }
}


void WINAPI DumpGraph(IFilterGraph *pGraph, DWORD dwLevel)
{
    IEnumFilters *pFilters;

    DbgLog((LOG_TRACE,dwLevel,TEXT("DumpGraph [%x]"), pGraph));

    if (FAILED(pGraph->EnumFilters(&pFilters))) {
	DbgLog((LOG_TRACE,dwLevel,TEXT("EnumFilters failed!")));
    }

    IBaseFilter *pFilter;
    ULONG	n;
    while (pFilters->Next(1, &pFilter, &n) == S_OK) {
	FILTER_INFO	info;

	if (FAILED(pFilter->QueryFilterInfo(&info))) {
	    DbgLog((LOG_TRACE,dwLevel,TEXT("    Filter [%x]  -- failed QueryFilterInfo"), pFilter));
	} else {
	    QueryFilterInfoReleaseGraph(info);

	    // !!! should QueryVendorInfo here!
	
	    DbgLog((LOG_TRACE,dwLevel,TEXT("    Filter [%x]  '%ls'"), pFilter, info.achName));

	    IEnumPins *pins;

	    if (FAILED(pFilter->EnumPins(&pins))) {
		DbgLog((LOG_TRACE,dwLevel,TEXT("EnumPins failed!")));
	    } else {

		IPin *pPin;
		while (pins->Next(1, &pPin, &n) == S_OK) {
		    PIN_INFO	info;

		    if (FAILED(pPin->QueryPinInfo(&info))) {
			DbgLog((LOG_TRACE,dwLevel,TEXT("          Pin [%x]  -- failed QueryPinInfo"), pPin));
		    } else {
			QueryPinInfoReleaseFilter(info);

			IPin *pPinConnected = NULL;

			HRESULT hr = pPin->ConnectedTo(&pPinConnected);

			if (pPinConnected) {
			    DbgLog((LOG_TRACE,dwLevel,TEXT("          Pin [%x]  '%ls' [%sput]")
							   TEXT("  Connected to pin [%x]"),
				    pPin, info.achName,
				    info.dir == PINDIR_INPUT ? TEXT("In") : TEXT("Out"),
				    pPinConnected));

			    pPinConnected->Release();

			    // perhaps we should really dump the type both ways as a sanity
			    // check?
			    if (info.dir == PINDIR_OUTPUT) {
				AM_MEDIA_TYPE mt;

				hr = pPin->ConnectionMediaType(&mt);

				if (SUCCEEDED(hr)) {
				    DisplayType("Connection type", &mt);

				    FreeMediaType(mt);
				}
			    }
			} else {
			    DbgLog((LOG_TRACE,dwLevel,
				    TEXT("          Pin [%x]  '%ls' [%sput]"),
				    pPin, info.achName,
				    info.dir == PINDIR_INPUT ? TEXT("In") : TEXT("Out")));

			}
		    }

		    pPin->Release();

		}

		pins->Release();
	    }

	}
	
	pFilter->Release();
    }

    pFilters->Release();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\wxlist.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Non MFC based generic list template class, December 1994

/* A generic list of pointers to objects.
   Objectives: avoid using MFC libraries in ndm kernel mode and
   provide a really useful list type.

   The class is thread safe in that separate threads may add and
   delete items in the list concurrently although the application
   must ensure that constructor and destructor access is suitably
   synchronised.

   The list name must not conflict with MFC classes as an
   application may use both

   The nodes form a doubly linked, NULL terminated chain with an anchor
   block (the list object per se) holding pointers to the first and last
   nodes and a count of the nodes.
   There is a node cache to reduce the allocation and freeing overhead.
   It optionally (determined at construction time) has an Event which is
   set whenever the list becomes non-empty and reset whenever it becomes
   empty.
   It optionally (determined at construction time) has a Critical Section
   which is entered during the important part of each operation.  (About
   all you can do outside it is some parameter checking).

   The node cache is a repository of nodes that are NOT in the list to speed
   up storage allocation.  Each list has its own cache to reduce locking and
   serialising.  The list accesses are serialised anyway for a given list - a
   common cache would mean that we would have to separately serialise access
   of all lists within the cache.  Because the cache only stores nodes that are
   not in the list, releasing the cache does not release any list nodes.  This
   means that list nodes can be copied or rechained from one list to another
   without danger of creating a dangling reference if the original cache goes
   away.

   Questionable design decisions:
   1. Retaining the warts for compatibility
   2. Keeping an element count -i.e. counting whenever we do anything
      instead of only when we want the count.
   3. Making the chain pointers NULL terminated.  If the list object
      itself looks just like a node and the list is kept as a ring then
      it reduces the number of special cases.  All inserts look the same.
*/


#include <streams.h>

/* set cursor to the position of each element of list in turn  */
#define INTERNALTRAVERSELIST(list, cursor)               \
for ( cursor = (list).GetHeadPositionI()           \
    ; cursor!=NULL                               \
    ; cursor = (list).Next(cursor)                \
    )


/* set cursor to the position of each element of list in turn
   in reverse order
*/
#define INTERNALREVERSETRAVERSELIST(list, cursor)        \
for ( cursor = (list).GetTailPositionI()           \
    ; cursor!=NULL                               \
    ; cursor = (list).Prev(cursor)                \
    )

/* Constructor calls a separate initialisation function that
   creates a node cache, optionally creates a lock object
   and optionally creates a signaling object.

   By default we create a locking object, a DEFAULTCACHE sized
   cache but no event object so the list cannot be used in calls
   to WaitForSingleObject
*/
CBaseList::CBaseList(TCHAR *pName,    // Descriptive list name
                     INT iItems) :    // Node cache size
#ifdef DEBUG
    CBaseObject(pName),
#endif
    m_pFirst(NULL),
    m_pLast(NULL),
    m_Count(0),
    m_Cache(iItems)
{
} // constructor

CBaseList::CBaseList(TCHAR *pName) :  // Descriptive list name
#ifdef DEBUG
    CBaseObject(pName),
#endif
    m_pFirst(NULL),
    m_pLast(NULL),
    m_Count(0),
    m_Cache(DEFAULTCACHE)
{
} // constructor


/* The destructor enumerates all the node objects in the list and
   in the cache deleting each in turn. We do not do any processing
   on the objects that the list holds (i.e. points to) so if they
   represent interfaces for example the creator of the list should
   ensure that each of them is released before deleting us
*/
CBaseList::~CBaseList()
{
    /* Delete all our list nodes */

    RemoveAll();

} // destructor

/* Remove all the nodes from the list but don't do anything
   with the objects that each node looks after (this is the
   responsibility of the creator).
   Aa a last act we reset the signalling event
   (if available) to indicate to clients that the list
   does not have any entries in it.
*/
void CBaseList::RemoveAll()
{
    /* Free up all the CNode objects NOTE we don't bother putting the
       deleted nodes into the cache as this method is only really called
       in serious times of change such as when we are being deleted at
       which point the cache will be deleted anway */

    CNode *pn = m_pFirst;
    while (pn) {
        CNode *op = pn;
        pn = pn->Next();
        delete op;
    }

    /* Reset the object count and the list pointers */

    m_Count = 0;
    m_pFirst = m_pLast = NULL;

} // RemoveAll



/* Return a position enumerator for the entire list.
   A position enumerator is a pointer to a node object cast to a
   transparent type so all we do is return the head/tail node
   pointer in the list.
   WARNING because the position is a pointer to a node there is
   an implicit assumption for users a the list class that after
   deleting an object from the list that any other position
   enumerators that you have may be invalid (since the node
   may be gone).
*/
POSITION CBaseList::GetHeadPositionI() const
{
    return (POSITION) m_pFirst;
} // GetHeadPosition



POSITION CBaseList::GetTailPositionI() const
{
    return (POSITION) m_pLast;
} // GetTailPosition



/* Get the number of objects in the list,
   Get the lock before accessing the count.
   Locking may not be entirely necessary but it has the side effect
   of making sure that all operations are complete before we get it.
   So for example if a list is being added to this list then that
   will have completed in full before we continue rather than seeing
   an intermediate albeit valid state
*/
int CBaseList::GetCountI() const
{
    return m_Count;
} // GetCount



/* Return the object at rp, update rp to the next object from
   the list or NULL if you have moved over the last object.
   You may still call this function once we return NULL but
   we will continue to return a NULL position value
*/
void *CBaseList::GetNextI(POSITION& rp) const
{
    /* have we reached the end of the list */

    if (rp == NULL) {
        return NULL;
    }

    /* Lock the object before continuing */

    void *pObject;

    /* Copy the original position then step on */

    CNode *pn = (CNode *) rp;
    ASSERT(pn != NULL);
    rp = (POSITION) pn->Next();

    /* Get the object at the original position from the list */

    pObject = pn->GetData();
    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed.
    return pObject;
} //GetNext



/* Return the object at p.
   Asking for the object at NULL ASSERTs then returns NULL
   The object is NOT locked.  The list is not being changed
   in any way.  If another thread is busy deleting the object
   then locking would only result in a change from one bad
   behaviour to another.
*/
void *CBaseList::GetI(POSITION p) const
{
    if (p == NULL) {
        return NULL;
    }

    CNode * pn = (CNode *) p;
    void *pObject = pn->GetData();
    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed.
    return pObject;
} //Get



/* Return the first position in the list which holds the given pointer.
   Return NULL if it's not found.
*/
POSITION CBaseList::FindI( void * pObj) const
{
    POSITION pn;
    INTERNALTRAVERSELIST(*this, pn){
        if (GetI(pn)==pObj) {
            return pn;
        }
    }
    return NULL;
} // Find



/* Remove the first node in the list (deletes the pointer to its object
   from the list, does not free the object itself).
   Return the pointer to its object or NULL if empty
*/
void *CBaseList::RemoveHeadI()
{
    /* All we do is get the head position and ask for that to be deleted.
       We could special case this since some of the code path checking
       in Remove() is redundant as we know there is no previous
       node for example but it seems to gain little over the
       added complexity
    */

    return RemoveI((POSITION)m_pFirst);
} // RemoveHead



/* Remove the last node in the list (deletes the pointer to its object
   from the list, does not free the object itself).
   Return the pointer to its object or NULL if empty
*/
void *CBaseList::RemoveTailI()
{
    /* All we do is get the tail position and ask for that to be deleted.
       We could special case this since some of the code path checking
       in Remove() is redundant as we know there is no previous
       node for example but it seems to gain little over the
       added complexity
    */

    return RemoveI((POSITION)m_pLast);
} // RemoveTail



/* Remove the pointer to the object in this position from the list.
   Deal with all the chain pointers
   Return a pointer to the object removed from the list.
   The node object that is freed as a result
   of this operation is added to the node cache where
   it can be used again.
   Remove(NULL) is a harmless no-op - but probably is a wart.
*/
void *CBaseList::RemoveI(POSITION pos)
{
    /* Lock the critical section before continuing */

    // ASSERT (pos!=NULL);     // Removing NULL is to be harmless!
    if (pos==NULL) return NULL;


    CNode *pCurrent = (CNode *) pos;
    ASSERT(pCurrent != NULL);

    /* Update the previous node */

    CNode *pNode = pCurrent->Prev();
    if (pNode == NULL) {
        m_pFirst = pCurrent->Next();
    } else {
        pNode->SetNext(pCurrent->Next());
    }

    /* Update the following node */

    pNode = pCurrent->Next();
    if (pNode == NULL) {
        m_pLast = pCurrent->Prev();
    } else {
        pNode->SetPrev(pCurrent->Prev());
    }

    /* Get the object this node was looking after */

    void *pObject = pCurrent->GetData();

    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed.

    /* Try and add the node object to the cache -
       a NULL return code from the cache means we ran out of room.
       The cache size is fixed by a constructor argument when the
       list is created and defaults to DEFAULTCACHE.
       This means that the cache will have room for this many
       node objects. So if you have a list of media samples
       and you know there will never be more than five active at
       any given time of them for example then override the default
       constructor
    */

    m_Cache.AddToCache(pCurrent);

    /* If the list is empty then reset the list event */

    --m_Count;
    ASSERT(m_Count >= 0);
    return pObject;
} // Remove



/* Add this object to the tail end of our list
   Return the new tail position.
*/

POSITION CBaseList::AddTailI(void *pObject)
{
    /* Lock the critical section before continuing */

    CNode *pNode;
    // ASSERT(pObject);   // NULL pointers in the list are allowed.

    /* If there is a node objects in the cache then use
       that otherwise we will have to create a new one */

    pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    ASSERT(pNode != NULL);
    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObject);
    pNode->SetNext(NULL);
    pNode->SetPrev(m_pLast);

    if (m_pLast == NULL) {
        m_pFirst = pNode;
    } else {
        m_pLast->SetNext(pNode);
    }

    /* Set the new last node pointer and also increment the number
       of list entries, the critical section is unlocked when we
       exit the function
    */

    m_pLast = pNode;
    ++m_Count;

    return (POSITION) pNode;
} // AddTail(object)



/* Add this object to the head end of our list
   Return the new head position.
*/
POSITION CBaseList::AddHeadI(void *pObject)
{
    CNode *pNode;
    // ASSERT(pObject);  // NULL pointers in the list are allowed.

    /* If there is a node objects in the cache then use
       that otherwise we will have to create a new one */

    pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    ASSERT(pNode != NULL);
    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObject);

    /* chain it in (set four pointers) */
    pNode->SetPrev(NULL);
    pNode->SetNext(m_pFirst);

    if (m_pFirst == NULL) {
        m_pLast = pNode;
    } else {
        m_pFirst->SetPrev(pNode);
    }
    m_pFirst = pNode;

    ++m_Count;

    return (POSITION) pNode;
} // AddHead(object)



/* Add all the elements in *pList to the tail of this list.
   Return TRUE if it all worked, FALSE if it didn't.
   If it fails some elements may have been added.
*/
BOOL CBaseList::AddTail(CBaseList *pList)
{
    /* lock the object before starting then enumerate
       each entry in the source list and add them one by one to
       our list (while still holding the object lock)
       Lock the other list too.
    */
    POSITION pos = pList->GetHeadPositionI();

    while (pos) {
       if (NULL == AddTailI(pList->GetNextI(pos))) {
           return FALSE;
       }
    }
    return TRUE;
} // AddTail(list)



/* Add all the elements in *pList to the head of this list.
   Return TRUE if it all worked, FALSE if it didn't.
   If it fails some elements may have been added.
*/
BOOL CBaseList::AddHead(CBaseList *pList)
{
    /* lock the object before starting then enumerate
       each entry in the source list and add them one by one to
       our list (while still holding the object lock)
       Lock the other list too.

       To avoid reversing the list, traverse it backwards.
    */

    POSITION pos;

    INTERNALREVERSETRAVERSELIST(*pList, pos) {
        if (NULL== AddHeadI(pList->GetI(pos))){
            return FALSE;
        }
    }
    return TRUE;
} // AddHead(list)



/* Add the object after position p
   p is still valid after the operation.
   AddAfter(NULL,x) adds x to the start - same as AddHead
   Return the position of the new object, NULL if it failed
*/
POSITION  CBaseList::AddAfterI(POSITION pos, void * pObj)
{
    if (pos==NULL)
        return AddHeadI(pObj);

    /* As someone else might be furkling with the list -
       Lock the critical section before continuing
    */
    CNode *pAfter = (CNode *) pos;
    ASSERT(pAfter != NULL);
    if (pAfter==m_pLast)
        return AddTailI(pObj);

    /* set pnode to point to a new node, preferably from the cache */

    CNode *pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    ASSERT(pNode != NULL);
    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObj);

    /* It is to be added to the middle of the list - there is a before
       and after node.  Chain it after pAfter, before pBefore.
    */
    CNode * pBefore = pAfter->Next();
    ASSERT(pBefore != NULL);

    /* chain it in (set four pointers) */
    pNode->SetPrev(pAfter);
    pNode->SetNext(pBefore);
    pBefore->SetPrev(pNode);
    pAfter->SetNext(pNode);

    ++m_Count;

    return (POSITION) pNode;

} // AddAfter(object)



BOOL CBaseList::AddAfter(POSITION p, CBaseList *pList)
{
    POSITION pos;
    INTERNALTRAVERSELIST(*pList, pos) {
        /* p follows along the elements being added */
        p = AddAfterI(p, pList->GetI(pos));
        if (p==NULL) return FALSE;
    }
    return TRUE;
} // AddAfter(list)



/* Mirror images:
   Add the element or list after position p.
   p is still valid after the operation.
   AddBefore(NULL,x) adds x to the end - same as AddTail
*/
POSITION CBaseList::AddBeforeI(POSITION pos, void * pObj)
{
    if (pos==NULL)
        return AddTailI(pObj);

    /* set pnode to point to a new node, preferably from the cache */

    CNode *pBefore = (CNode *) pos;
    ASSERT(pBefore != NULL);
    if (pBefore==m_pFirst)
        return AddHeadI(pObj);

    CNode * pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    ASSERT(pNode != NULL);
    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObj);

    /* It is to be added to the middle of the list - there is a before
       and after node.  Chain it after pAfter, before pBefore.
    */

    CNode * pAfter = pBefore->Prev();
    ASSERT(pAfter != NULL);

    /* chain it in (set four pointers) */
    pNode->SetPrev(pAfter);
    pNode->SetNext(pBefore);
    pBefore->SetPrev(pNode);
    pAfter->SetNext(pNode);

    ++m_Count;

    return (POSITION) pNode;

} // Addbefore(object)



BOOL CBaseList::AddBefore(POSITION p, CBaseList *pList)
{
    POSITION pos;
    INTERNALREVERSETRAVERSELIST(*pList, pos) {
        /* p follows along the elements being added */
        p = AddBeforeI(p, pList->GetI(pos));
        if (p==NULL) return FALSE;
    }
    return TRUE;
} // AddBefore(list)



/* Split *this after position p in *this
   Retain as *this the tail portion of the original *this
   Add the head portion to the tail end of *pList
   Return TRUE if it all worked, FALSE if it didn't.

   e.g.
      foo->MoveToTail(foo->GetHeadPosition(), bar);
          moves one element from the head of foo to the tail of bar
      foo->MoveToTail(NULL, bar);
          is a no-op
      foo->MoveToTail(foo->GetTailPosition, bar);
          concatenates foo onto the end of bar and empties foo.

   A better, except excessively long name might be
       MoveElementsFromHeadThroughPositionToOtherTail
*/
BOOL CBaseList::MoveToTail
        (POSITION pos, CBaseList *pList)
{
    /* Algorithm:
       Note that the elements (including their order) in the concatenation
       of *pList to the head of *this is invariant.
       1. Count elements to be moved
       2. Join *pList onto the head of this to make one long chain
       3. Set first/Last pointers in *this and *pList
       4. Break the chain at the new place
       5. Adjust counts
       6. Set/Reset any events
    */

    if (pos==NULL) return TRUE;  // no-op.  Eliminates special cases later.


    /* Make cMove the number of nodes to move */
    CNode * p = (CNode *)pos;
    int cMove = 0;            // number of nodes to move
    while(p!=NULL) {
       p = p->Prev();
       ++cMove;
    }


    /* Join the two chains together */
    if (pList->m_pLast!=NULL)
        pList->m_pLast->SetNext(m_pFirst);
    if (m_pFirst!=NULL)
        m_pFirst->SetPrev(pList->m_pLast);


    /* set first and last pointers */
    p = (CNode *)pos;

    if (pList->m_pFirst==NULL)
        pList->m_pFirst = m_pFirst;
    m_pFirst = p->Next();
    if (m_pFirst==NULL)
        m_pLast = NULL;
    pList->m_pLast = p;


    /* Break the chain after p to create the new pieces */
    if (m_pFirst!=NULL)
        m_pFirst->SetPrev(NULL);
    p->SetNext(NULL);


    /* Adjust the counts */
    m_Count -= cMove;
    pList->m_Count += cMove;

    return TRUE;

} // MoveToTail



/* Mirror image of MoveToTail:
   Split *this before position p in *this.
   Retain in *this the head portion of the original *this
   Add the tail portion to the start (i.e. head) of *pList
   Return TRUE if it all worked, FALSE if it didn't.

   e.g.
      foo->MoveToHead(foo->GetTailPosition(), bar);
          moves one element from the tail of foo to the head of bar
      foo->MoveToHead(NULL, bar);
          is a no-op
      foo->MoveToHead(foo->GetHeadPosition, bar);
          concatenates foo onto the start of bar and empties foo.
*/
BOOL CBaseList::MoveToHead
        (POSITION pos, CBaseList *pList)
{

    /* See the comments on the algorithm in MoveToTail */

    if (pos==NULL) return TRUE;  // no-op.  Eliminates special cases later.

    /* Make cMove the number of nodes to move */
    CNode * p = (CNode *)pos;
    int cMove = 0;            // number of nodes to move
    while(p!=NULL) {
       p = p->Next();
       ++cMove;
    }


    /* Join the two chains together */
    if (pList->m_pFirst!=NULL)
        pList->m_pFirst->SetPrev(m_pLast);
    if (m_pLast!=NULL)
        m_pLast->SetNext(pList->m_pFirst);


    /* set first and last pointers */
    p = (CNode *)pos;


    if (pList->m_pLast==NULL)
        pList->m_pLast = m_pLast;

    m_pLast = p->Prev();
    if (m_pLast==NULL)
        m_pFirst = NULL;
    pList->m_pFirst = p;


    /* Break the chain after p to create the new pieces */
    if (m_pLast!=NULL)
        m_pLast->SetNext(NULL);
    p->SetPrev(NULL);


    /* Adjust the counts */
    m_Count -= cMove;
    pList->m_Count += cMove;

    return TRUE;

} // MoveToHead



/* Reverse the order of the [pointers to] objects in *this
*/
void CBaseList::Reverse()
{
    /* algorithm:
       The obvious booby trap is that you flip pointers around and lose
       addressability to the node that you are going to process next.
       The easy way to avoid this is do do one chain at a time.

       Run along the forward chain,
       For each node, set the reverse pointer to the one ahead of us.
       The reverse chain is now a copy of the old forward chain, including
       the NULL termination.

       Run along the reverse chain (i.e. old forward chain again)
       For each node set the forward pointer of the node ahead to point back
       to the one we're standing on.
       The first node needs special treatment,
       it's new forward pointer is NULL.
       Finally set the First/Last pointers

    */
    CNode * p;

    // Yes we COULD use a traverse, but it would look funny!
    p = m_pFirst;
    while (p!=NULL) {
        CNode * q;
        q = p->Next();
        p->SetNext(p->Prev());
        p->SetPrev(q);
        p = q;
    }

    p = m_pFirst;
    m_pFirst = m_pLast;
    m_pLast = p;


#if 0     // old version

    if (m_pFirst==NULL) return;          // empty list
    if (m_pFirst->Next()==NULL) return;  // single node list


    /* run along forward chain */
    for ( p = m_pFirst
        ; p!=NULL
        ; p = p->Next()
        ){
        p->SetPrev(p->Next());
    }


    /* special case first element */
    m_pFirst->SetNext(NULL);     // fix the old first element


    /* run along new reverse chain i.e. old forward chain again */
    for ( p = m_pFirst           // start at the old first element
        ; p->Prev()!=NULL        // while there's a node still to be set
        ; p = p->Prev()          // work in the same direction as before
        ){
        p->Prev()->SetNext(p);
    }


    /* fix forward and reverse pointers
       - the triple XOR swap would work but all the casts look hideous */
    p = m_pFirst;
    m_pFirst = m_pLast;
    m_pLast = p;
#endif

} // Reverse
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\wxlist.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Non MFC based generic template list class, December 1994

/* A generic list of pointers to objects.
   No storage management or copying is done on the objects pointed to.
   Objectives: avoid using MFC libraries in ndm kernel mode and
   provide a really useful list type.

   The class is thread safe in that separate threads may add and
   delete items in the list concurrently although the application
   must ensure that constructor and destructor access is suitably
   synchronised. An application can cause deadlock with operations
   which use two lists by simultaneously calling
   list1->Operation(list2) and list2->Operation(list1).  So don't!

   The names must not conflict with MFC classes as an application
   may use both.
   */

#ifndef __WXLIST__
#define __WXLIST__

   /* A POSITION represents (in some fashion that's opaque) a cursor
      on the list that can be set to identify any element.  NULL is
      a valid value and several operations regard NULL as the position
      "one step off the end of the list".  (In an n element list there
      are n+1 places to insert and NULL is that "n+1-th" value).
      The POSITION of an element in the list is only invalidated if
      that element is deleted.  Move operations may mean that what
      was a valid POSITION in one list is now a valid POSITION in
      a different list.

      Some operations which at first sight are illegal are allowed as
      harmless no-ops.  For instance RemoveHead is legal on an empty
      list and it returns NULL.  This allows an atomic way to test if
      there is an element there, and if so, get it.  The two operations
      AddTail and RemoveHead thus implement a MONITOR (See Hoare's paper).

      Single element operations return POSITIONs, non-NULL means it worked.
      whole list operations return a BOOL.  TRUE means it all worked.

      This definition is the same as the POSITION type for MFCs, so we must
      avoid defining it twice.
   */
#ifndef __AFX_H__
struct __POSITION { int unused; };
typedef __POSITION* POSITION;
#endif

const int DEFAULTCACHE = 10;    /* Default node object cache size */

/* A class representing one node in a list.
   Each node knows a pointer to it's adjacent nodes and also a pointer
   to the object that it looks after.
   All of these pointers can be retrieved or set through member functions.
*/
class CBaseList 
#ifdef DEBUG
    : public CBaseObject
#endif
{
    /* Making these classes inherit from CBaseObject does nothing
       functionally but it allows us to check there are no memory
       leaks in debug builds. 
    */

public:

#ifdef DEBUG
    class CNode : public CBaseObject {
#else
    class CNode {
#endif

        CNode *m_pPrev;         /* Previous node in the list */
        CNode *m_pNext;         /* Next node in the list */
        void *m_pObject;      /* Pointer to the object */

    public:

        /* Constructor - initialise the object's pointers */
        CNode()
#ifdef DEBUG
            : CBaseObject(NAME("List node"))
#endif
        {
        };


        /* Return the previous node before this one */
        CNode *Prev() const { return m_pPrev; };


        /* Return the next node after this one */
        CNode *Next() const { return m_pNext; };


        /* Set the previous node before this one */
        void SetPrev(CNode *p) { m_pPrev = p; };


        /* Set the next node after this one */
        void SetNext(CNode *p) { m_pNext = p; };


        /* Get the pointer to the object for this node */
        void *GetData() const { return m_pObject; };


        /* Set the pointer to the object for this node */
        void SetData(void *p) { m_pObject = p; };
    };

    class CNodeCache
    {
    public:
        CNodeCache(INT iCacheSize) : m_iCacheSize(iCacheSize),
                                     m_pHead(NULL),
                                     m_iUsed(0)
                                     {};
        ~CNodeCache() {
            CNode *pNode = m_pHead;
            while (pNode) {
                CNode *pCurrent = pNode;
                pNode = pNode->Next();
                delete pCurrent;
            }
        };
        void AddToCache(CNode *pNode)
        {
            if (m_iUsed < m_iCacheSize) {
                pNode->SetNext(m_pHead);
                m_pHead = pNode;
                m_iUsed++;
            } else {
                delete pNode;
            }
        };
        CNode *RemoveFromCache()
        {
            CNode *pNode = m_pHead;
            if (pNode != NULL) {
                m_pHead = pNode->Next();
                m_iUsed--;
                ASSERT(m_iUsed >= 0);
            } else {
                ASSERT(m_iUsed == 0);
            }
            return pNode;
        };
    private:
        INT m_iCacheSize;
        INT m_iUsed;
        CNode *m_pHead;
    };

protected:

    CNode* m_pFirst;    /* Pointer to first node in the list */
    CNode* m_pLast;     /* Pointer to the last node in the list */
    LONG m_Count;       /* Number of nodes currently in the list */

private:

    CNodeCache m_Cache; /* Cache of unused node pointers */

private:

    /* These override the default copy constructor and assignment
       operator for all list classes. They are in the private class
       declaration section so that anybody trying to pass a list
       object by value will generate a compile time error of
       "cannot access the private member function". If these were
       not here then the compiler will create default constructors
       and assignment operators which when executed first take a
       copy of all member variables and then during destruction
       delete them all. This must not be done for any heap
       allocated data.
    */
    CBaseList(const CBaseList &refList);
    CBaseList &operator=(const CBaseList &refList);

public:

    CBaseList(TCHAR *pName,
              INT iItems);

    CBaseList(TCHAR *pName);

    ~CBaseList();

    /* Remove all the nodes from *this i.e. make the list empty */
    void RemoveAll();


    /* Return a cursor which identifies the first element of *this */
    POSITION GetHeadPositionI() const;


    /* Return a cursor which identifies the last element of *this */
    POSITION GetTailPositionI() const;


    /* Return the number of objects in *this */
    int GetCountI() const;

protected:
    /* Return the pointer to the object at rp,
       Update rp to the next node in *this
       but make it NULL if it was at the end of *this.
       This is a wart retained for backwards compatibility.
       GetPrev is not implemented.
       Use Next, Prev and Get separately.
    */
    void *GetNextI(POSITION& rp) const;


    /* Return a pointer to the object at p
       Asking for the object at NULL will return NULL harmlessly.
    */
    void *GetI(POSITION p) const;

public:
    /* return the next / prev position in *this
       return NULL when going past the end/start.
       Next(NULL) is same as GetHeadPosition()
       Prev(NULL) is same as GetTailPosition()
       An n element list therefore behaves like a n+1 element
       cycle with NULL at the start/end.

       !!WARNING!! - This handling of NULL is DIFFERENT from GetNext.

       Some reasons are:
       1. For a list of n items there are n+1 positions to insert
          These are conveniently encoded as the n POSITIONs and NULL.
       2. If you are keeping a list sorted (fairly common) and you
          search forward for an element to insert before and don't
          find it you finish up with NULL as the element before which
          to insert.  You then want that NULL to be a valid POSITION
          so that you can insert before it and you want that insertion
          point to mean the (n+1)-th one that doesn't have a POSITION.
          (symmetrically if you are working backwards through the list).
       3. It simplifies the algebra which the methods generate.
          e.g. AddBefore(p,x) is identical to AddAfter(Prev(p),x)
          in ALL cases.  All the other arguments probably are reflections
          of the algebraic point.
    */
    POSITION Next(POSITION pos) const
    {
        if (pos == NULL) {
            return (POSITION) m_pFirst;
        }
        CNode *pn = (CNode *) pos;
        return (POSITION) pn->Next();
    } //Next

    // See Next
    POSITION Prev(POSITION pos) const
    {
        if (pos == NULL) {
            return (POSITION) m_pLast;
        }
        CNode *pn = (CNode *) pos;
        return (POSITION) pn->Prev();
    } //Prev


    /* Return the first position in *this which holds the given
       pointer.  Return NULL if the pointer was not not found.
    */
protected:
    POSITION FindI( void * pObj) const;

    // ??? Should there be (or even should there be only)
    // ??? POSITION FindNextAfter(void * pObj, POSITION p)
    // ??? And of course FindPrevBefore too.
    // ??? List.Find(&Obj) then becomes List.FindNextAfter(&Obj, NULL)


    /* Remove the first node in *this (deletes the pointer to its
       object from the list, does not free the object itself).
       Return the pointer to its object.
       If *this was already empty it will harmlessly return NULL.
    */
    void *RemoveHeadI();


    /* Remove the last node in *this (deletes the pointer to its
       object from the list, does not free the object itself).
       Return the pointer to its object.
       If *this was already empty it will harmlessly return NULL.
    */
    void *RemoveTailI();


    /* Remove the node identified by p from the list (deletes the pointer
       to its object from the list, does not free the object itself).
       Asking to Remove the object at NULL will harmlessly return NULL.
       Return the pointer to the object removed.
    */
    void *RemoveI(POSITION p);

    /* Add single object *pObj to become a new last element of the list.
       Return the new tail position, NULL if it fails.
       If you are adding a COM objects, you might want AddRef it first.
       Other existing POSITIONs in *this are still valid
    */
    POSITION AddTailI(void * pObj);
public:


    /* Add all the elements in *pList to the tail of *this.
       This duplicates all the nodes in *pList (i.e. duplicates
       all its pointers to objects).  It does not duplicate the objects.
       If you are adding a list of pointers to a COM object into the list
       it's a good idea to AddRef them all  it when you AddTail it.
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails some elements may have been added.
       Existing POSITIONs in *this are still valid

       If you actually want to MOVE the elements, use MoveToTail instead.
    */
    BOOL AddTail(CBaseList *pList);


    /* Mirror images of AddHead: */

    /* Add single object to become a new first element of the list.
       Return the new head position, NULL if it fails.
       Existing POSITIONs in *this are still valid
    */
protected:
    POSITION AddHeadI(void * pObj);
public:

    /* Add all the elements in *pList to the head of *this.
       Same warnings apply as for AddTail.
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails some of the objects may have been added.

       If you actually want to MOVE the elements, use MoveToHead instead.
    */
    BOOL AddHead(CBaseList *pList);


    /* Add the object *pObj to *this after position p in *this.
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return the position of the object added, NULL if it failed.
       Existing POSITIONs in *this are undisturbed, including p.
    */
protected:
    POSITION AddAfterI(POSITION p, void * pObj);
public:

    /* Add the list *pList to *this after position p in *this
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails, some of the objects may be added
       Existing POSITIONs in *this are undisturbed, including p.
    */
    BOOL AddAfter(POSITION p, CBaseList *pList);


    /* Mirror images:
       Add the object *pObj to this-List after position p in *this.
       AddBefore(NULL,x) adds x to the end - equivalent to AddTail
       Return the position of the new object, NULL if it fails
       Existing POSITIONs in *this are undisturbed, including p.
    */
    protected:
    POSITION AddBeforeI(POSITION p, void * pObj);
    public:

    /* Add the list *pList to *this before position p in *this
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails, some of the objects may be added
       Existing POSITIONs in *this are undisturbed, including p.
    */
    BOOL AddBefore(POSITION p, CBaseList *pList);


    /* Note that AddAfter(p,x) is equivalent to AddBefore(Next(p),x)
       even in cases where p is NULL or Next(p) is NULL.
       Similarly for mirror images etc.
       This may make it easier to argue about programs.
    */



    /* The following operations do not copy any elements.
       They move existing blocks of elements around by switching pointers.
       They are fairly efficient for long lists as for short lists.
       (Alas, the Count slows things down).

       They split the list into two parts.
       One part remains as the original list, the other part
       is appended to the second list.  There are eight possible
       variations:
       Split the list {after/before} a given element
       keep the {head/tail} portion in the original list
       append the rest to the {head/tail} of the new list.

       Since After is strictly equivalent to Before Next
       we are not in serious need of the Before/After variants.
       That leaves only four.

       If you are processing a list left to right and dumping
       the bits that you have processed into another list as
       you go, the Tail/Tail variant gives the most natural result.
       If you are processing in reverse order, Head/Head is best.

       By using NULL positions and empty lists judiciously either
       of the other two can be built up in two operations.

       The definition of NULL (see Next/Prev etc) means that
       degenerate cases include
          "move all elements to new list"
          "Split a list into two lists"
          "Concatenate two lists"
          (and quite a few no-ops)

       !!WARNING!! The type checking won't buy you much if you get list
       positions muddled up - e.g. use a POSITION that's in a different
       list and see what a mess you get!
    */

    /* Split *this after position p in *this
       Retain as *this the tail portion of the original *this
       Add the head portion to the tail end of *pList
       Return TRUE if it all worked, FALSE if it didn't.

       e.g.
          foo->MoveToTail(foo->GetHeadPosition(), bar);
              moves one element from the head of foo to the tail of bar
          foo->MoveToTail(NULL, bar);
              is a no-op, returns NULL
          foo->MoveToTail(foo->GetTailPosition, bar);
              concatenates foo onto the end of bar and empties foo.

       A better, except excessively long name might be
           MoveElementsFromHeadThroughPositionToOtherTail
    */
    BOOL MoveToTail(POSITION pos, CBaseList *pList);


    /* Mirror image:
       Split *this before position p in *this.
       Retain in *this the head portion of the original *this
       Add the tail portion to the start (i.e. head) of *pList

       e.g.
          foo->MoveToHead(foo->GetTailPosition(), bar);
              moves one element from the tail of foo to the head of bar
          foo->MoveToHead(NULL, bar);
              is a no-op, returns NULL
          foo->MoveToHead(foo->GetHeadPosition, bar);
              concatenates foo onto the start of bar and empties foo.
    */
    BOOL MoveToHead(POSITION pos, CBaseList *pList);


    /* Reverse the order of the [pointers to] objects in *this
    */
    void Reverse();


    /* set cursor to the position of each element of list in turn  */
    #define TRAVERSELIST(list, cursor)               \
    for ( cursor = (list).GetHeadPosition()           \
        ; cursor!=NULL                               \
        ; cursor = (list).Next(cursor)                \
        )


    /* set cursor to the position of each element of list in turn
       in reverse order
    */
    #define REVERSETRAVERSELIST(list, cursor)        \
    for ( cursor = (list).GetTailPosition()           \
        ; cursor!=NULL                               \
        ; cursor = (list).Prev(cursor)                \
        )

}; // end of class declaration

template<class OBJECT> class CGenericList : public CBaseList
{
public:
    CGenericList(TCHAR *pName,
                 INT iItems,
                 BOOL bLock = TRUE,
                 BOOL bAlert = FALSE) :
                     CBaseList(pName, iItems) {
        UNREFERENCED_PARAMETER(bAlert);
        UNREFERENCED_PARAMETER(bLock);
    };
    CGenericList(TCHAR *pName) :
                     CBaseList(pName) {
    };

    POSITION GetHeadPosition() const { return (POSITION)m_pFirst; }
    POSITION GetTailPosition() const { return (POSITION)m_pLast; }
    int GetCount() const { return m_Count; }

    OBJECT *GetNext(POSITION& rp) const { return (OBJECT *) GetNextI(rp); }

    OBJECT *Get(POSITION p) const { return (OBJECT *) GetI(p); }
    OBJECT *GetHead() const  { return Get(GetHeadPosition()); }

    OBJECT *RemoveHead() { return (OBJECT *) RemoveHeadI(); }

    OBJECT *RemoveTail() { return (OBJECT *) RemoveTailI(); }

    OBJECT *Remove(POSITION p) { return (OBJECT *) RemoveI(p); }
    POSITION AddBefore(POSITION p, OBJECT * pObj) { return AddBeforeI(p, pObj); }
    POSITION AddAfter(POSITION p, OBJECT * pObj)  { return AddAfterI(p, pObj); }
    POSITION AddHead(OBJECT * pObj) { return AddHeadI(pObj); }
    POSITION AddTail(OBJECT * pObj)  { return AddTailI(pObj); }
    BOOL AddTail(CGenericList<OBJECT> *pList)
            { return CBaseList::AddTail((CBaseList *) pList); }
    BOOL AddHead(CGenericList<OBJECT> *pList)
            { return CBaseList::AddHead((CBaseList *) pList); }
    BOOL AddAfter(POSITION p, CGenericList<OBJECT> *pList)
            { return CBaseList::AddAfter(p, (CBaseList *) pList); };
    BOOL AddBefore(POSITION p, CGenericList<OBJECT> *pList)
            { return CBaseList::AddBefore(p, (CBaseList *) pList); };
    POSITION Find( OBJECT * pObj) const { return FindI(pObj); }
}; // end of class declaration



/* These define the standard list types */

typedef CGenericList<CBaseObject> CBaseObjectList;
typedef CGenericList<IUnknown> CBaseInterfaceList;

#endif /* __WXLIST__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\synth\onef\isynth.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// isynth.h
//
// A custom interface to allow the user to adjust the frequency

#ifndef __ISYNTH__
#define __ISYNTH__

#ifdef __cplusplus
extern "C" {
#endif


//
// ISynth's GUID
//
// {FFC08882-CDAC-11ce-8A03-00AA006ECB65}
DEFINE_GUID(IID_ISynth,
0xffc08882, 0xcdac, 0x11ce, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);


//
// ISynth
//
DECLARE_INTERFACE_(ISynth, IUnknown) {

    STDMETHOD(get_Frequency) (THIS_
                int *Frequency          /* [out] */    // the current frequency
             ) PURE;

    STDMETHOD(put_Frequency) (THIS_
                int    Frequency        /* [in] */    // Change to this frequency
             ) PURE;

    STDMETHOD(get_Waveform) (THIS_
                int *Waveform           /* [out] */    // the current Waveform
             ) PURE;

    STDMETHOD(put_Waveform) (THIS_
                int    Waveform         /* [in] */    // Change to this Waveform
             ) PURE;

    STDMETHOD(get_Channels) (THIS_
                int *Channels           /* [out] */    // the current Channels
             ) PURE;

    STDMETHOD(put_Channels) (THIS_
                int    Channels         /* [in] */    // Change to this Channels
             ) PURE;

    STDMETHOD(get_BitsPerSample) (THIS_
                int *BitsPerSample      /* [out] */    // the current BitsPerSample
             ) PURE;

    STDMETHOD(put_BitsPerSample) (THIS_
                int    BitsPerSample    /* [in] */    // Change to this BitsPerSample
             ) PURE;

    STDMETHOD(get_SamplesPerSec) (THIS_
                 int *SamplesPerSec     /* [out] */    // the current SamplesPerSec
             ) PURE;

    STDMETHOD(put_SamplesPerSec) (THIS_
                  int    SamplesPerSec  /* [in] */    // Change to this SamplesPerSec
             ) PURE;

    STDMETHOD(get_Amplitude) (THIS_
                  int *Amplitude        /* [out] */    // the current Amplitude
             ) PURE;

    STDMETHOD(put_Amplitude) (THIS_
                  int    Amplitude      /* [in] */    // Change to this Amplitude
              ) PURE;

    STDMETHOD(get_SweepRange) (THIS_
                  int *SweepStart,      /* [out] */
                  int *SweepEnd         /* [out] */
             ) PURE;

    STDMETHOD(put_SweepRange) (THIS_
                  int    SweepStart,    /* [in] */
                  int    SweepEnd       /* [in] */
             ) PURE;

};


#ifdef __cplusplus
}
#endif

#endif // __ISYNTH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\wxutil.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// helper classes and functions for building multimedia filters
//

#ifndef __WXUTIL__
#define __WXUTIL__

// eliminate spurious "statement has no effect" warnings.
#pragma warning(disable: 4705)

// wrapper for whatever critical section we have
class CCritSec {

    // make copy constructor and assignment operator inaccessible

    CCritSec(const CCritSec &refCritSec);
    CCritSec &operator=(const CCritSec &refCritSec);

    CRITICAL_SECTION m_CritSec;

#ifdef DEBUG
public:
    DWORD   m_currentOwner;
    DWORD   m_lockCount;
    BOOL    m_fTrace;        // Trace this one
public:
    CCritSec();
    ~CCritSec();
    void Lock();
    void Unlock();
#else

public:
    CCritSec() {
	InitializeCriticalSection(&m_CritSec);
    };

    ~CCritSec() {
	DeleteCriticalSection(&m_CritSec);
    };

    void Lock() {
	EnterCriticalSection(&m_CritSec);
    };

    void Unlock() {
	LeaveCriticalSection(&m_CritSec);
    };
#endif
};

//
// To make deadlocks easier to track it is useful to insert in the
// code an assertion that says whether we own a critical section or
// not.  We make the routines that do the checking globals to avoid
// having different numbers of member functions in the debug and
// retail class implementations of CCritSec.  In addition we provide
// a routine that allows usage of specific critical sections to be
// traced.  This is NOT on by default - there are far too many.
//

#ifdef DEBUG
    BOOL WINAPI CritCheckIn(CCritSec * pcCrit);
    BOOL WINAPI CritCheckOut(CCritSec * pcCrit);
    void WINAPI DbgLockTrace(BOOL fTrace);
#else
    #define CritCheckIn(x) TRUE
    #define CritCheckOut(x) TRUE
    #define DbgLockTrace(pc, fT)
#endif


// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoLock {

    // make copy constructor and assignment operator inaccessible

    CAutoLock(const CAutoLock &refAutoLock);
    CAutoLock &operator=(const CAutoLock &refAutoLock);

protected:
    CCritSec * m_pLock;

public:
    CAutoLock(CCritSec * plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ~CAutoLock() {
        m_pLock->Unlock();
    };
};



// wrapper for event objects
class CAMEvent
{

    // make copy constructor and assignment operator inaccessible

    CAMEvent(const CAMEvent &refEvent);
    CAMEvent &operator=(const CAMEvent &refEvent);

protected:
    HANDLE m_hEvent;
public:
    CAMEvent(BOOL fManualReset = FALSE);
    ~CAMEvent();

    // Cast to HANDLE - we don't support this as an lvalue
    operator HANDLE () const { return m_hEvent; };

    void Set() {EXECUTE_ASSERT(SetEvent(m_hEvent));};
    BOOL Wait(DWORD dwTimeout = INFINITE) {
	return (WaitForSingleObject(m_hEvent, dwTimeout) == WAIT_OBJECT_0);
    };
    void Reset() { ResetEvent(m_hEvent); };
    BOOL Check() { return Wait(0); };
};


// wrapper for event objects that do message processing
// This adds ONE method to the CAMEvent object to allow sent
// messages to be processed while waiting

class CAMMsgEvent : public CAMEvent
{

public:

    // Allow SEND messages to be processed while waiting
    BOOL WaitMsg(DWORD dwTimeout = INFINITE);
};

// old name supported for the time being
#define CTimeoutEvent CAMEvent

// support for a worker thread

// simple thread class supports creation of worker thread, synchronization
// and communication. Can be derived to simplify parameter passing
class AM_NOVTABLE CAMThread {

    // make copy constructor and assignment operator inaccessible

    CAMThread(const CAMThread &refThread);
    CAMThread &operator=(const CAMThread &refThread);

    CAMEvent m_EventSend;
    CAMEvent m_EventComplete;

    DWORD m_dwParam;
    DWORD m_dwReturnVal;

protected:
    HANDLE m_hThread;

    // thread will run this function on startup
    // must be supplied by derived class
    virtual DWORD ThreadProc() = 0;

public:
    CAMThread();
    ~CAMThread();

    CCritSec m_AccessLock;	// locks access by client threads
    CCritSec m_WorkerLock;	// locks access to shared objects

    // thread initially runs this. param is actually 'this'. function
    // just gets this and calls ThreadProc
    static DWORD WINAPI InitialThreadProc(LPVOID pv);

    // start thread running  - error if already running
    BOOL Create();

    // signal the thread, and block for a response
    //
    DWORD CallWorker(DWORD);

    // accessor thread calls this when done with thread (having told thread
    // to exit)
    void Close() {
        HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0);
        if (hThread) {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
    };

    // ThreadExists
    // Return TRUE if the thread exists. FALSE otherwise
    BOOL ThreadExists(void) const
    {
        if (m_hThread == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    // wait for the next request
    DWORD GetRequest();

    // is there a request?
    BOOL CheckRequest(DWORD * pParam);

    // reply to the request
    void Reply(DWORD);

    // If you want to do WaitForMultipleObjects you'll need to include
    // this handle in your wait list or you won't be responsive
    HANDLE GetRequestHandle() const { return m_EventSend; };

    // Find out what the request was
    DWORD GetRequestParam() const { return m_dwParam; };

    // call CoInitializeEx (COINIT_DISABLE_OLE1DDE) if
    // available. S_FALSE means it's not available.
    static HRESULT CoInitializeHelper();
};


// CQueue
//
// Implements a simple Queue ADT.  The queue contains a finite number of
// objects, access to which is controlled by a semaphore.  The semaphore
// is created with an initial count (N).  Each time an object is added
// a call to WaitForSingleObject is made on the semaphore's handle.  When
// this function returns a slot has been reserved in the queue for the new
// object.  If no slots are available the function blocks until one becomes
// available.  Each time an object is removed from the queue ReleaseSemaphore
// is called on the semaphore's handle, thus freeing a slot in the queue.
// If no objects are present in the queue the function blocks until an
// object has been added.

#define DEFAULT_QUEUESIZE   2

template <class T> class CQueue {
private:
    HANDLE          hSemPut;        // Semaphore controlling queue "putting"
    HANDLE          hSemGet;        // Semaphore controlling queue "getting"
    CRITICAL_SECTION CritSect;      // Thread seriallization
    int             nMax;           // Max objects allowed in queue
    int             iNextPut;       // Array index of next "PutMsg"
    int             iNextGet;       // Array index of next "GetMsg"
    T              *QueueObjects;   // Array of objects (ptr's to void)

    void Initialize(int n) {
        iNextPut = iNextGet = 0;
        nMax = n;
        InitializeCriticalSection(&CritSect);
        hSemPut = CreateSemaphore(NULL, n, n, NULL);
        hSemGet = CreateSemaphore(NULL, 0, n, NULL);
        QueueObjects = new T[n];
    }


public:
    CQueue(int n) {
        Initialize(n);
    }

    CQueue() {
        Initialize(DEFAULT_QUEUESIZE);
    }

    ~CQueue() {
        delete [] QueueObjects;
        DeleteCriticalSection(&CritSect);
        CloseHandle(hSemPut);
        CloseHandle(hSemGet);
    }

    T GetQueueObject() {
        int iSlot;
        T Object;
        LONG lPrevious;

        // Wait for someone to put something on our queue, returns straight
        // away is there is already an object on the queue.
        //
        WaitForSingleObject(hSemGet, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextGet++ % nMax;
        Object = QueueObjects[iSlot];
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to put an object onto our queue as there
        // is now space available in the queue.
        //
        ReleaseSemaphore(hSemPut, 1L, &lPrevious);
        return Object;
    }

    void PutQueueObject(T Object) {
        int iSlot;
        LONG lPrevious;

        // Wait for someone to get something from our queue, returns straight
        // away is there is already an empty slot on the queue.
        //
        WaitForSingleObject(hSemPut, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextPut++ % nMax;
        QueueObjects[iSlot] = Object;
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to remove an object from our queue as there
        // is now an object available to be removed.
        //
        ReleaseSemaphore(hSemGet, 1L, &lPrevious);
    }
};

// miscellaneous string conversion functions
// NOTE: as we need to use the same binaries on Win95 as on NT this code should
// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up
// these internal routines and the binary will not run on Win95.

#ifndef UNICODE
#define wsprintfW wsprintfWInternal
int WINAPIV wsprintfWInternal(LPWSTR, LPCWSTR, ...);

#define lstrcpyW lstrcpyWInternal
LPWSTR
WINAPI
lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );
#define lstrcpynW lstrcpynWInternal
LPWSTR
WINAPI
lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    );
#define lstrcmpW lstrcmpWInternal
int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
#define lstrcmpiW lstrcmpiWInternal
int
WINAPI
lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
#define lstrlenW lstrlenWInternal
int
WINAPI
lstrlenWInternal(
    LPCWSTR lpString
    );
#endif

extern "C"
void * __stdcall memmoveInternal(void *, const void *, size_t);

inline void * __cdecl memchrInternal(const void *buf, int chr, size_t cnt)
{
#ifdef _X86_
    void *pRet = NULL;

    _asm {
        cld                 // make sure we get the direction right
        mov     ecx, cnt    // num of bytes to scan
        mov     edi, buf    // pointer byte stream
        mov     eax, chr    // byte to scan for
        repne   scasb       // look for the byte in the byte stream
        jnz     exit_memchr // Z flag set if byte found
        dec     edi         // scasb always increments edi even when it
                            // finds the required byte
        mov     pRet, edi
exit_memchr:
    }
    return pRet;

#else
    while ( cnt && (*(unsigned char *)buf != (unsigned char)chr) ) {
        buf = (unsigned char *)buf + 1;
        cnt--;
    }

    return(cnt ? (void *)buf : NULL);
#endif
}

void WINAPI IntToWstr(int i, LPWSTR wstr);

#define WstrToInt(sz) atoiW(sz)

inline int atoiW(const WCHAR *sz)
{
    int i = 0;

    while (*sz && *sz >= L'0' && *sz <= L'9')
    	i = i*10 + *sz++ - L'0';
    	
    return i;    	
}

inline int WINAPI atoiA(const CHAR *sz)
{
    int i = 0;

    while (*sz && *sz >= '0' && *sz <= '9')
    	i = i*10 + *sz++ - '0';
    	
    return i;    	
}

#ifdef UNICODE
#define atoi    atoiW
#else
#define atoi    atoiA
#endif



// These are available to help managing bitmap VIDEOINFOHEADER media structures

extern const DWORD bits555[3];
extern const DWORD bits565[3];
extern const DWORD bits888[3];

// These help convert between VIDEOINFOHEADER and BITMAPINFO structures

STDAPI_(const GUID) GetTrueColorType(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(const GUID) GetBitmapSubtype(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(WORD) GetBitCount(const GUID *pSubtype);
STDAPI_(TCHAR *) GetSubtypeName(const GUID *pSubtype);
STDAPI_(LONG) GetBitmapFormatSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(DWORD) GetBitmapSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(BOOL) ContainsPalette(const VIDEOINFOHEADER *pVideoInfo);
STDAPI_(const RGBQUAD *) GetBitmapPalette(const VIDEOINFOHEADER *pVideoInfo);


// Compares two interfaces and returns TRUE if they are on the same object
BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond);

// This is for comparing pins
#define EqualPins(pPin1, pPin2) IsEqualObject(pPin1, pPin2)


// Arithmetic helper functions

// Compute (a * b + rnd) / c
LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG rnd);
LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG rnd);


// Avoids us dyna-linking to SysAllocString to copy BSTR strings
STDAPI WriteBSTR(BSTR * pstrDest, LPCWSTR szSrc);
STDAPI FreeBSTR(BSTR* pstr);

// Return a wide string - allocating memory for it
// Returns:
//    S_OK          - no error
//    E_POINTER     - ppszReturn == NULL
//    E_OUTOFMEMORY - can't allocate memory for returned string
STDAPI AMGetWideString(LPCWSTR pszString, LPWSTR *ppszReturn);

// Special wait for objects owning windows
DWORD WINAPI WaitDispatchingMessages(HANDLE hObject, DWORD dwWait, HWND hwnd = NULL, UINT uMsg = 0);
#endif /* __WXUTIL__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\synth\onef\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by synth.rc
//
#define VERSION_RES_MINOR_VER           0
#define VERSION_RES_BUILD               0
#define VER_DEBUG                       0
#define VERSION_RES_MAJOR_VER           1
#define IDD_BALLPROP                    101
#define IDD_SYNTHPROP1                  101
#define IDC_FREQUENCYTEXT               1002
#define IDC_FREQUENCY                   1003
#define IDC_AMPLITUDETEXT               1003
#define IDC_FREQTRACKBAR                1004
#define IDC_FREQUENCYGROUP              1005
#define IDC_WAVEFORMGROUP               1006
#define IDC_WAVESINE                    1007
#define IDC_WAVESQUARE                  1008
#define IDC_WAVESAWTOOTH                1009
#define IDC_WAVESWEEP                   1010
#define IDC_AMPLITUDETRACKBAR           1011
#define IDC_CHANNELS1                   1012
#define IDC_CHANNELS2                   1013
#define IDC_BITSPERSAMPLEGROUP          1014
#define IDC_BITSPERSAMPLE8              1015
#define IDC_BITSPERSAMPLE16             1016
#define IDC_SAMPLINGFREQUENCYGROUP      1017
#define IDC_SAMPLINGFREQ11              1018
#define IDC_SAMPLINGFREQ22              1019
#define IDC_SAMPLINGFREQ44              1020
#define IDC_AMPLITUDEGROUP              1021
#define IDC_SWEEP                       1023
#define IDS_SYNTHPROPNAME               1024
#define VERSION_RES_LANGUAGE            0x409
#define VERSION_RES_CHARSET             1252
#define IDS_STATIC                      -1
#define IDC_CHANNELSGROUP               -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1025
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\strmbase\wxutil.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// helper classes for building multimedia filters
//

#include <streams.h>

//
//  Declare function from largeint.h we need so that PPC can build
//

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

#ifndef _X86_

#define LLtoU64(x) (*(unsigned __int64*)(void*)(&(x)))

__inline
ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
        // return remainder if necessary
        if (Remainder != NULL)
                *Remainder = (ULONG)(LLtoU64(Dividend) % Divisor);
        return (ULONG)(LLtoU64(Dividend) / Divisor);
}

#else
__inline
ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
    ULONG ulResult;
    _asm {
        mov eax,Dividend.LowPart
        mov edx,Dividend.HighPart
        mov ecx,Remainder
        div Divisor
        or  ecx,ecx
        jz  short label
        mov [ecx],edx
label:
        mov ulResult,eax
    }
    return ulResult;
}
#endif

// --- CAMEvent -----------------------
CAMEvent::CAMEvent(BOOL fManualReset)
{
    m_hEvent = CreateEvent(NULL, fManualReset, FALSE, NULL);
    ASSERT(m_hEvent);
}

CAMEvent::~CAMEvent()
{
    if (m_hEvent) {
	EXECUTE_ASSERT(CloseHandle(m_hEvent));
    }
}


// --- CAMMsgEvent -----------------------
// One routine.  The rest is handled in CAMEvent

BOOL CAMMsgEvent::WaitMsg(DWORD dwTimeout)
{
    // wait for the event to be signalled, or for the
    // timeout (in MS) to expire.  allow SENT messages
    // to be processed while we wait
    DWORD dwWait;
    DWORD dwStartTime;

    // set the waiting period.
    DWORD dwWaitTime = dwTimeout;

    // the timeout will eventually run down as we iterate
    // processing messages.  grab the start time so that
    // we can calculate elapsed times.
    if (dwWaitTime != INFINITE) {
        dwStartTime = timeGetTime();
    }

    do {
        dwWait = MsgWaitForMultipleObjects(1,&m_hEvent,FALSE, dwWaitTime, QS_SENDMESSAGE);
        if (dwWait == WAIT_OBJECT_0 + 1) {
	    MSG Message;
            PeekMessage(&Message,NULL,0,0,PM_NOREMOVE);

	    // If we have an explicit length of time to wait calculate
	    // the next wake up point - which might be now.
	    // If dwTimeout is INFINITE, it stays INFINITE
	    if (dwWaitTime != INFINITE) {

		DWORD dwElapsed = timeGetTime()-dwStartTime;

		dwWaitTime =
		    (dwElapsed >= dwTimeout)
			? 0  // wake up with WAIT_TIMEOUT
			: dwTimeout-dwElapsed;
	    }
        }
    } while (dwWait == WAIT_OBJECT_0 + 1);

    // return TRUE if we woke on the event handle,
    //        FALSE if we timed out.
    return (dwWait == WAIT_OBJECT_0);
}

// --- CAMThread ----------------------


CAMThread::CAMThread()
    : m_EventSend(TRUE)     // must be manual-reset for CheckRequest()
{
    m_hThread = NULL;
}

CAMThread::~CAMThread() {
    Close();
}


// when the thread starts, it calls this function. We unwrap the 'this'
//pointer and call ThreadProc.
DWORD WINAPI
CAMThread::InitialThreadProc(LPVOID pv)
{
    CAMThread * pThread = (CAMThread *) pv;

    return pThread->ThreadProc();
}

BOOL
CAMThread::Create()
{
    DWORD threadid;

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {
	return FALSE;
    }

    m_hThread = CreateThread(
		    NULL,
		    0,
		    CAMThread::InitialThreadProc,
		    this,
		    0,
		    &threadid);

    if (!m_hThread) {
	return FALSE;
    }

    return TRUE;
}

DWORD
CAMThread::CallWorker(DWORD dwParam)
{
    // lock access to the worker thread for scope of this object
    CAutoLock lock(&m_AccessLock);

    if (!ThreadExists()) {
	return (DWORD) E_FAIL;
    }

    // set the parameter
    m_dwParam = dwParam;

    // signal the worker thread
    m_EventSend.Set();

    // wait for the completion to be signalled
    m_EventComplete.Wait();

    // done - this is the thread's return value
    return m_dwReturnVal;
}

// Wait for a request from the client
DWORD
CAMThread::GetRequest()
{
    m_EventSend.Wait();
    return m_dwParam;
}

// is there a request?
BOOL
CAMThread::CheckRequest(DWORD * pParam)
{
    if (!m_EventSend.Check()) {
	return FALSE;
    } else {
	if (pParam) {
	    *pParam = m_dwParam;
	}
	return TRUE;
    }
}

// reply to the request
void
CAMThread::Reply(DWORD dw)
{
    m_dwReturnVal = dw;

    // The request is now complete so CheckRequest should fail from
    // now on
    //
    // This event should be reset BEFORE we signal the client or
    // the client may Set it before we reset it and we'll then
    // reset it (!)

    m_EventSend.Reset();

    // Tell the client we're finished

    m_EventComplete.Set();
}

HRESULT CAMThread::CoInitializeHelper()
{
    // call CoInitializeEx and tell OLE not to create a window (this
    // thread probably won't dispatch messages and will hang on
    // broadcast msgs o/w).
    //
    // If CoInitEx is not available, threads that don't call CoCreate
    // aren't affected. Threads that do will have to handle the
    // failure. Perhaps we should fall back to CoInitialize and risk
    // hanging?
    //

    // older versions of ole32.dll don't have CoInitializeEx

    HRESULT hr = E_FAIL;
    HINSTANCE hOle = GetModuleHandle(TEXT("ole32.dll"));
    if(hOle)
    {
        typedef HRESULT (STDAPICALLTYPE *PCoInitializeEx)(
            LPVOID pvReserved, DWORD dwCoInit);
        PCoInitializeEx pCoInitializeEx =
            (PCoInitializeEx)(GetProcAddress(hOle, "CoInitializeEx"));
        if(pCoInitializeEx)
        {
            hr = (*pCoInitializeEx)(0, COINIT_DISABLE_OLE1DDE );
        }
    }
    else
    {
        // caller must load ole32.dll
        DbgBreak("couldn't locate ole32.dll");
    }

    return hr;
}


// destructor for CMsgThread  - cleans up any messages left in the
// queue when the thread exited
CMsgThread::~CMsgThread()
{
    if (m_hThread != NULL) {
        WaitForSingleObject(m_hThread, INFINITE);
        EXECUTE_ASSERT(CloseHandle(m_hThread));
    }

    POSITION pos = m_ThreadQueue.GetHeadPosition();
    while (pos) {
        CMsg * pMsg = m_ThreadQueue.GetNext(pos);
        delete pMsg;
    }
    m_ThreadQueue.RemoveAll();

    if (m_hSem != NULL) {
        EXECUTE_ASSERT(CloseHandle(m_hSem));
    }
}

BOOL
CMsgThread::CreateThread(
    )
{
    m_hSem = CreateSemaphore(NULL, 0, 0x7FFFFFFF, NULL);
    if (m_hSem == NULL) {
        return FALSE;
    }

    m_hThread = ::CreateThread(NULL, 0, DefaultThreadProc,
			       (LPVOID)this, 0, &m_ThreadId);
    return m_hThread != NULL;
}


// This is the threads message pump.  Here we get and dispatch messages to
// clients thread proc until the client refuses to process a message.
// The client returns a non-zero value to stop the message pump, this
// value becomes the threads exit code.

DWORD WINAPI
CMsgThread::DefaultThreadProc(
    LPVOID lpParam
    )
{
    CMsgThread *lpThis = (CMsgThread *)lpParam;
    CMsg msg;
    LRESULT lResult;

    // !!!
    CoInitialize(NULL);

    // allow a derived class to handle thread startup
    lpThis->OnThreadInit();

    do {
	lpThis->GetThreadMsg(&msg);
	lResult = lpThis->ThreadMessageProc(msg.uMsg,msg.dwFlags,
					    msg.lpParam, msg.pEvent);
    } while (lResult == 0L);

    // !!!
    CoUninitialize();

    return (DWORD)lResult;
}


// Block until the next message is placed on the list m_ThreadQueue.
// copies the message to the message pointed to by *pmsg
void
CMsgThread::GetThreadMsg(CMsg *msg)
{
    CMsg * pmsg = NULL;

    // keep trying until a message appears
    while (TRUE) {
        {
            CAutoLock lck(&m_Lock);
            pmsg = m_ThreadQueue.RemoveHead();
            if (pmsg == NULL) {
                m_lWaiting++;
            } else {
                break;
            }
        }
        // the semaphore will be signalled when it is non-empty
        WaitForSingleObject(m_hSem, INFINITE);
    }
    // copy fields to caller's CMsg
    *msg = *pmsg;

    // this CMsg was allocated by the 'new' in PutThreadMsg
    delete pmsg;

}


#ifndef UNICODE
// NOTE: as we need to use the same binaries on Win95 as on NT this code should
// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up
// these internal routines and the binary will not run on Win95.

// Windows 95 doesn't implement this, so we provide an implementation.
LPWSTR
WINAPI
lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    LPWSTR  lpReturn = lpString1;
    while (*lpString1++ = *lpString2++);

    return lpReturn;
}

// Windows 95 doesn't implement this, so we provide an implementation.
LPWSTR
WINAPI
lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    )
{
    ASSERT(iMaxLength);
    LPWSTR  lpReturn = lpString1;
    if (iMaxLength) {
        while (--iMaxLength && (*lpString1++ = *lpString2++));

        // If we ran out of room (which will be the case if
        // iMaxLength is now 0) we still need to terminate the
        // string.
        if (!iMaxLength) *lpString1 = L'\0';
    }
    return lpReturn;
}

int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
	WCHAR c1 = *lpString1;
	WCHAR c2 = *lpString2;
	if (c1 != c2)
	    return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);
    return 0;
}


int
WINAPI
lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
	WCHAR c1 = *lpString1;
	WCHAR c2 = *lpString2;
	if (c1 >= L'A' && c1 <= L'Z')
	    c1 -= (WCHAR) (L'A' - L'a');
	if (c2 >= L'A' && c2 <= L'Z')
	    c2 -= (WCHAR) (L'A' - L'a');
	
	if (c1 != c2)
	    return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);

    return 0;
}


int
WINAPI
lstrlenWInternal(
    LPCWSTR lpString
    )
{
    int i = -1;
    while (*(lpString+(++i)))
        ;
    return i;
}

#endif // NOT UNICODE


#ifndef UNICODE
int WINAPIV wsprintfWInternal(LPWSTR wszOut, LPCWSTR pszFmt, ...)
{
    char fmt[256]; // !!!
    char ach[256]; // !!!
    int i;

    va_list va;
    va_start(va, pszFmt);
    WideCharToMultiByte(GetACP(), 0, pszFmt, -1, fmt, 256, NULL, NULL);
    i = wvsprintf(ach, fmt, va);
    va_end(va);

    MultiByteToWideChar(CP_ACP, 0, ach, -1, wszOut, i+1);

    return i;
}
#endif

// Helper function - convert int to WSTR
void WINAPI IntToWstr(int i, LPWSTR wstr)
{
#ifdef UNICODE
    wsprintf(wstr, L"%d", i);
#else
    TCHAR temp[32];
    wsprintf(temp, "%d", i);
    MultiByteToWideChar(CP_ACP, 0, temp, -1, wstr, 32);
#endif
} // IntToWstr


#if 0
void * memchrInternal(const void *pv, int c, size_t sz)
{
    BYTE *pb = (BYTE *) pv;
    while (sz--) {
	if (*pb == c)
	    return (void *) pb;
	pb++;
    }
    return NULL;
}
#endif


#define MEMORY_ALIGNMENT        4
#define MEMORY_ALIGNMENT_LOG2   2
#define MEMORY_ALIGNMENT_MASK   MEMORY_ALIGNMENT - 1

void * __stdcall memmoveInternal(void * dst, const void * src, size_t count)
{
    void * ret = dst;

#ifdef _X86_
    if (dst <= src || (char *)dst >= ((char *)src + count)) {

        /*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
        _asm {
            mov     esi,src
            mov     edi,dst
            mov     ecx,count
            cld
            mov     edx,ecx
            and     edx,MEMORY_ALIGNMENT_MASK
            shr     ecx,MEMORY_ALIGNMENT_LOG2
            rep     movsd
            or      ecx,edx
            jz      memmove_done
            rep     movsb
memmove_done:
        }
    }
    else {

        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        _asm {
            mov     esi,src
            mov     edi,dst
            mov     ecx,count
            std
            add     esi,ecx
            add     edi,ecx
            dec     esi
            dec     edi
            rep     movsb
            cld
        }
    }
#else
    MoveMemory(dst, src, count);
#endif

    return ret;
}

/*  Arithmetic functions to help with time format conversions
*/

/*   Compute (a * b + d) / c */
LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG d)
{
    /*  Compute the absolute values to avoid signed arithmetic problems */
    ULARGE_INTEGER ua, ub;
    DWORDLONG uc;

    ua.QuadPart = (DWORDLONG)(a >= 0 ? a : -a);
    ub.QuadPart = (DWORDLONG)(b >= 0 ? b : -b);
    uc          = (DWORDLONG)(c >= 0 ? c : -c);
    BOOL bSign = (a < 0) ^ (b < 0);

    /*  Do long multiplication */
    ULARGE_INTEGER p[2];
    p[0].QuadPart  = UInt32x32To64(ua.LowPart, ub.LowPart);

    /*  This next computation cannot overflow into p[1].HighPart because
        the max number we can compute here is:

                 (2 ** 32 - 1) * (2 ** 32 - 1) +  // ua.LowPart * ub.LowPart
    (2 ** 32) *  (2 ** 31) * (2 ** 32 - 1) * 2    // x.LowPart * y.HighPart * 2

    == 2 ** 96 - 2 ** 64 + (2 ** 64 - 2 ** 33 + 1)
    == 2 ** 96 - 2 ** 33 + 1
    < 2 ** 96
    */

    ULARGE_INTEGER x;
    x.QuadPart     = UInt32x32To64(ua.LowPart, ub.HighPart) +
                     UInt32x32To64(ua.HighPart, ub.LowPart) +
                     p[0].HighPart;
    p[0].HighPart  = x.LowPart;
    p[1].QuadPart  = UInt32x32To64(ua.HighPart, ub.HighPart) + x.HighPart;

    if (d != 0) {
        ULARGE_INTEGER ud[2];
        if (bSign) {
            ud[0].QuadPart = (DWORDLONG)(-d);
            if (d > 0) {
                /*  -d < 0 */
                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1;
            } else {
                ud[1].QuadPart = (DWORDLONG)0;
            }
        } else {
            ud[0].QuadPart = (DWORDLONG)d;
            if (d < 0) {
                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1;
            } else {
                ud[1].QuadPart = (DWORDLONG)0;
            }
        }
        /*  Now do extended addition */
        ULARGE_INTEGER uliTotal;

        /*  Add ls DWORDs */
        uliTotal.QuadPart  = (DWORDLONG)ud[0].LowPart + p[0].LowPart;
        p[0].LowPart       = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add 2nd most ls DWORDs */
        uliTotal.QuadPart += (DWORDLONG)ud[0].HighPart + p[0].HighPart;
        p[0].HighPart      = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add MS DWORDLONGs - no carry expected */
        p[1].QuadPart     += ud[1].QuadPart + uliTotal.QuadPart;

        /*  Now see if we got a sign change from the addition */
        if ((LONG)p[1].HighPart < 0) {
            bSign = !bSign;

            /*  Negate the current value (ugh!) */
            p[0].QuadPart  = ~p[0].QuadPart;
            p[1].QuadPart  = ~p[1].QuadPart;
            p[0].QuadPart += 1;
            p[1].QuadPart += (p[0].QuadPart == 0);
        }
    }

    /*  Now for the division */
    if (c < 0) {
        bSign = !bSign;
    }


    /*  This will catch c == 0 and overflow */
    if (uc <= p[1].QuadPart) {
        return bSign ? (LONGLONG)0x8000000000000000 :
                       (LONGLONG)0x7FFFFFFFFFFFFFFF;
    }

    DWORDLONG ullResult;

    /*  Do the division */
    /*  If the dividend is a DWORD_LONG use the compiler */
    if (p[1].QuadPart == 0) {
        ullResult = p[0].QuadPart / uc;
        return bSign ? -(LONGLONG)ullResult : (LONGLONG)ullResult;
    }

    /*  If the divisor is a DWORD then its simpler */
    ULARGE_INTEGER ulic;
    ulic.QuadPart = uc;
    if (ulic.HighPart == 0) {
        ULARGE_INTEGER uliDividend;
        ULARGE_INTEGER uliResult;
        DWORD dwDivisor = (DWORD)uc;
        // ASSERT(p[1].HighPart == 0 && p[1].LowPart < dwDivisor);
        uliDividend.HighPart = p[1].LowPart;
        uliDividend.LowPart = p[0].HighPart;
#ifndef USE_LARGEINT
        uliResult.HighPart = (DWORD)(uliDividend.QuadPart / dwDivisor);
        p[0].HighPart = (DWORD)(uliDividend.QuadPart % dwDivisor);
        uliResult.LowPart = 0;
        uliResult.QuadPart = p[0].QuadPart / dwDivisor + uliResult.QuadPart;
#else
        /*  NOTE - this routine will take exceptions if
            the result does not fit in a DWORD
        */
        if (uliDividend.QuadPart >= (DWORDLONG)dwDivisor) {
            uliResult.HighPart = EnlargedUnsignedDivide(
                                     uliDividend,
                                     dwDivisor,
                                     &p[0].HighPart);
        } else {
            uliResult.HighPart = 0;
        }
        uliResult.LowPart = EnlargedUnsignedDivide(
                                 p[0],
                                 dwDivisor,
                                 NULL);
#endif
        return bSign ? -(LONGLONG)uliResult.QuadPart :
                        (LONGLONG)uliResult.QuadPart;
    }


    ullResult = 0;

    /*  OK - do long division */
    for (int i = 0; i < 64; i++) {
        ullResult <<= 1;

        /*  Shift 128 bit p left 1 */
        p[1].QuadPart <<= 1;
        if ((p[0].HighPart & 0x80000000) != 0) {
            p[1].LowPart++;
        }
        p[0].QuadPart <<= 1;

        /*  Compare */
        if (uc <= p[1].QuadPart) {
            p[1].QuadPart -= uc;
            ullResult += 1;
        }
    }

    return bSign ? - (LONGLONG)ullResult : (LONGLONG)ullResult;
}


LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG d)
{
    ULARGE_INTEGER ua;
    DWORD ub;
    DWORD uc;

    /*  Compute the absolute values to avoid signed arithmetic problems */
    ua.QuadPart = (DWORDLONG)(a >= 0 ? a : -a);
    ub = (DWORD)(b >= 0 ? b : -b);
    uc = (DWORD)(c >= 0 ? c : -c);
    BOOL bSign = (a < 0) ^ (b < 0);

    /*  Do long multiplication */
    ULARGE_INTEGER p0;
    DWORD p1;
    p0.QuadPart  = UInt32x32To64(ua.LowPart, ub);

    if (ua.HighPart != 0) {
        ULARGE_INTEGER x;
        x.QuadPart     = UInt32x32To64(ua.HighPart, ub) + p0.HighPart;
        p0.HighPart  = x.LowPart;
        p1   = x.HighPart;
    } else {
        p1 = 0;
    }

    if (d != 0) {
        ULARGE_INTEGER ud0;
        DWORD ud1;

        if (bSign) {
            //
            //  Cast d to LONGLONG first otherwise -0x80000000 sign extends
            //  incorrectly
            //
            ud0.QuadPart = (DWORDLONG)(-(LONGLONG)d);
            if (d > 0) {
                /*  -d < 0 */
                ud1 = (DWORD)-1;
            } else {
                ud1 = (DWORD)0;
            }
        } else {
            ud0.QuadPart = (DWORDLONG)d;
            if (d < 0) {
                ud1 = (DWORD)-1;
            } else {
                ud1 = (DWORD)0;
            }
        }
        /*  Now do extended addition */
        ULARGE_INTEGER uliTotal;

        /*  Add ls DWORDs */
        uliTotal.QuadPart  = (DWORDLONG)ud0.LowPart + p0.LowPart;
        p0.LowPart       = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add 2nd most ls DWORDs */
        uliTotal.QuadPart += (DWORDLONG)ud0.HighPart + p0.HighPart;
        p0.HighPart      = uliTotal.LowPart;

        /*  Add MS DWORDLONGs - no carry expected */
        p1 += ud1 + uliTotal.HighPart;

        /*  Now see if we got a sign change from the addition */
        if ((LONG)p1 < 0) {
            bSign = !bSign;

            /*  Negate the current value (ugh!) */
            p0.QuadPart  = ~p0.QuadPart;
            p1 = ~p1;
            p0.QuadPart += 1;
            p1 += (p0.QuadPart == 0);
        }
    }

    /*  Now for the division */
    if (c < 0) {
        bSign = !bSign;
    }


    /*  This will catch c == 0 and overflow */
    if (uc <= p1) {
        return bSign ? (LONGLONG)0x8000000000000000 :
                       (LONGLONG)0x7FFFFFFFFFFFFFFF;
    }

    /*  Do the division */

    /*  If the divisor is a DWORD then its simpler */
    ULARGE_INTEGER uliDividend;
    ULARGE_INTEGER uliResult;
    DWORD dwDivisor = uc;
    uliDividend.HighPart = p1;
    uliDividend.LowPart = p0.HighPart;
    /*  NOTE - this routine will take exceptions if
        the result does not fit in a DWORD
    */
    if (uliDividend.QuadPart >= (DWORDLONG)dwDivisor) {
        uliResult.HighPart = EnlargedUnsignedDivide(
                                 uliDividend,
                                 dwDivisor,
                                 &p0.HighPart);
    } else {
        uliResult.HighPart = 0;
    }
    uliResult.LowPart = EnlargedUnsignedDivide(
                             p0,
                             dwDivisor,
                             NULL);
    return bSign ? -(LONGLONG)uliResult.QuadPart :
                    (LONGLONG)uliResult.QuadPart;
}

#ifdef DEBUG
/******************************Public*Routine******************************\
* Debug CCritSec helpers
*
* We provide debug versions of the Constructor, destructor, Lock and Unlock
* routines.  The debug code tracks who owns each critical section by
* maintaining a depth count.
*
* History:
*
\**************************************************************************/

CCritSec::CCritSec()
{
    InitializeCriticalSection(&m_CritSec);
    m_currentOwner = m_lockCount = 0;
    m_fTrace = FALSE;
}

CCritSec::~CCritSec()
{
    DeleteCriticalSection(&m_CritSec);
}

void CCritSec::Lock()
{
    UINT tracelevel=3;
    DWORD us = GetCurrentThreadId();
    DWORD currentOwner = m_currentOwner;
    if (currentOwner && (currentOwner != us)) {
        // already owned, but not by us
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, 2, TEXT("Thread %d about to wait for lock %x owned by %d"),
                GetCurrentThreadId(), &m_CritSec, currentOwner));
            tracelevel=2;
	    // if we saw the message about waiting for the critical
	    // section we ensure we see the message when we get the
	    // critical section
        }
    }
    EnterCriticalSection(&m_CritSec);
    if (0 == m_lockCount++) {
        // we now own it for the first time.  Set owner information
        m_currentOwner = us;
	//ASSERT(((PRTL_CRITICAL_SECTION)&m_CritSec)->OwningThread == (HANDLE)m_currentOwner);
	// only valid on NT
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, tracelevel, TEXT("Thread %d now owns lock %x"), m_currentOwner, &m_CritSec));
        }
    }
}

void CCritSec::Unlock() {
    if (0 == --m_lockCount) {
        // about to be unowned
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, 3, TEXT("Thread %d releasing lock %x"), m_currentOwner, &m_CritSec));
	    //ASSERT(((PRTL_CRITICAL_SECTION)&m_CritSec)->OwningThread == (HANDLE)m_currentOwner);
	    // only valid on NT
        }
        m_currentOwner = 0;
    }
    LeaveCriticalSection(&m_CritSec);
}

void WINAPI DbgLockTrace(CCritSec * pcCrit, BOOL fTrace)
{
    pcCrit->m_fTrace = fTrace;
}

BOOL WINAPI CritCheckIn(CCritSec * pcCrit)
{
    return (GetCurrentThreadId() == pcCrit->m_currentOwner);
}

BOOL WINAPI CritCheckOut(CCritSec * pcCrit)
{
    return (GetCurrentThreadId() != pcCrit->m_currentOwner);
}
#endif


typedef BSTR (STDAPICALLTYPE *LPSYSALLOCSTRING)(const OLECHAR FAR *);

// Dyna-link to SysAllocString to copy BSTR strings

STDAPI WriteBSTR(BSTR *pstrDest, LPCWSTR szSrc)
{
    LPSYSALLOCSTRING	lpfnSysAllocString;
    HINSTANCE		hInst;
    static const char	szSysAllocString[]	  = "SysAllocString";

    //
    // Try to get the Ole32Aut.dll module handle.
    //

    hInst = LoadOLEAut32();
    if (hInst == NULL) {
	DWORD dwError = GetLastError();
	return HRESULT_FROM_WIN32(dwError);
    }
    lpfnSysAllocString = (LPSYSALLOCSTRING)GetProcAddress(hInst,
							  szSysAllocString);
    if (lpfnSysAllocString == NULL) {
	DWORD dwError = GetLastError();
	return HRESULT_FROM_WIN32(dwError);
    }

    *pstrDest = (*lpfnSysAllocString)(szSrc);

    return S_OK;
}


// Free an OLE BSTR through the task allocator

STDAPI FreeBSTR(BSTR* pstr)
{
    if (*pstr != NULL) {
        // get pointer to string
        DWORD* p = (DWORD*) (*pstr);

        // back up to point at DWORD length
        p--;

        // set pointer to null
        *pstr = NULL;

        // and free this
        CoTaskMemFree(p);

        return S_OK;
    } else {
        return S_FALSE;
    }
}


// Return a wide string - allocating memory for it
// Returns:
//    S_OK          - no error
//    E_POINTER     - ppszReturn == NULL
//    E_OUTOFMEMORY - can't allocate memory for returned string
STDAPI AMGetWideString(LPCWSTR psz, LPWSTR *ppszReturn)
{
    CheckPointer(ppszReturn, E_POINTER);
    ValidateReadWritePtr(ppszReturn, sizeof(LPWSTR));
    DWORD nameLen = sizeof(WCHAR) * (lstrlenW(psz)+1);
    *ppszReturn = (LPWSTR)CoTaskMemAlloc(nameLen);
    if (*ppszReturn == NULL) {
       return E_OUTOFMEMORY;
    }
    CopyMemory(*ppszReturn, psz, nameLen);
    return NOERROR;
}

// Waits for the HANDLE hObject.  While waiting messages sent
// to windows on our thread by SendMessage will be processed.
// Using this function to do waits and mutual exclusion
// avoids some deadlocks in objects with windows.
// Return codes are the same as for WaitForSingleObject
DWORD WINAPI WaitDispatchingMessages(HANDLE hObject, DWORD dwWait, HWND hwnd, UINT uMsg)
{
    BOOL bPeeked = FALSE;
    DWORD dwResult;
    DWORD dwStart;
    DWORD dwThreadPriority;
    if (dwWait != INFINITE && dwWait != 0) {
        dwStart = GetTickCount();
    }
    for (; ; ) {
        DWORD dwTimeOut = dwWait;
        if (dwTimeOut > 10) {
            dwTimeOut = 10;
        }
        dwResult = MsgWaitForMultipleObjects(
                             1,
                             &hObject,
                             FALSE,
                             dwTimeOut,
                             hwnd == NULL ? QS_SENDMESSAGE :
                                            QS_SENDMESSAGE + QS_POSTMESSAGE);
        if (dwResult == WAIT_OBJECT_0 + 1 ||
            dwResult == WAIT_TIMEOUT && dwTimeOut != dwWait) {
            MSG msg;
            if (hwnd != NULL) {
                while (PeekMessage(&msg, hwnd, uMsg, uMsg, PM_REMOVE)) {
                    DispatchMessage(&msg);
                }
            }
            // Do this anyway - the previous peek doesn't flush out the
            // messages
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

            if (dwWait != INFINITE && dwWait != 0) {
                DWORD dwNow = GetTickCount();

                // Working with differences handles wrap-around
                DWORD dwDiff = dwNow - dwStart;
                if (dwDiff > dwWait) {
                    dwWait = 0;
                } else {
                    dwWait -= dwDiff;
                }
                dwStart = dwNow;
            }
            if (!bPeeked) {
                //  Raise our priority to prevent our message queue
                //  building up
                dwThreadPriority = GetThreadPriority(GetCurrentThread());
                if (dwThreadPriority < THREAD_PRIORITY_HIGHEST) {
                    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
                }
                bPeeked = TRUE;
            }
        } else {
            break;
        }
    }
    if (bPeeked) {
        SetThreadPriority(GetCurrentThread(), dwThreadPriority);
        if (HIWORD(GetQueueStatus(QS_POSTMESSAGE)) & QS_POSTMESSAGE) {
            //  Send dummy message
            PostThreadMessage(GetCurrentThreadId(), WM_NULL, 0, 0);
        }
    }
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\synth\onef\synth.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// synth.cpp
//
// Audio Signal Generator Source Filter


#include <windows.h>
#include <streams.h>
#include <math.h>

#include <initguid.h>
#if (1100 > _MSC_VER)
#include <olectlid.h>
#else
#include <olectl.h>
#endif

#define RMAX 0x7fff  // 2^15-1 (based on rand's max value)
#define _AUDIOSYNTH_IMPLEMENTATION_

#include "isynth.h"
#include "synth.h"
#include "synthprp.h"

// setup data

const AMOVIESETUP_MEDIATYPE sudOpPinTypes =
{ &MEDIATYPE_Audio      // clsMajorType
, &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN sudOpPin =
{ L"Output"          // strName
, FALSE              // bRendered
, TRUE               // bOutput
, FALSE              // bZero
, FALSE              // bMany
, &CLSID_NULL        // clsConnectsToFilter
, L"Input"           // strConnectsToPin
, 1                  // nTypes
, &sudOpPinTypes };  // lpTypes

const AMOVIESETUP_FILTER sudSynth =
{ &CLSID_SynthFilter     // clsID
, L"1/f Audio Synthesizer" // strName
, MERIT_UNLIKELY       // dwMerit
, 1                    // nPins
, &sudOpPin };         // lpPin

// -------------------------------------------------------------------------
// g_Templates
// -------------------------------------------------------------------------
// COM global table of objects in this dll

CFactoryTemplate g_Templates[] = {

    { L"1/f Audio Synthesizer"
    , &CLSID_SynthFilter
    , CSynthFilter::CreateInstance
    , NULL
    , &sudSynth }
  ,
    { L"1/f Audio Synthesizer Property Page"
    , &CLSID_SynthPropertyPage
    , CSynthProperties::CreateInstance }

};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// -------------------------------------------------------------------------
// CSynthFilter, the main filter object
// -------------------------------------------------------------------------
//
// CreateInstance
//
// The only allowed way to create Synthesizers

CUnknown * WINAPI CSynthFilter::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CSynthFilter(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}

//
// CSynthFilter::Constructor
//
// initialise a CSynthStream object so that we have a pin.

CSynthFilter::CSynthFilter(LPUNKNOWN lpunk, HRESULT *phr)
    : CSource(NAME("Audio Synthesizer Filter"),lpunk, CLSID_SynthFilter)
    , CPersistStream(lpunk, phr)
{
    CAutoLock l(&m_cStateLock);

    m_paStreams    = (CSourceStream **) new CSynthStream*[1];
    if (m_paStreams == NULL) {
        *phr = E_OUTOFMEMORY;
        return;
    }

    m_paStreams[0] = new CSynthStream(phr, this, L"Audio Synth Stream");
    if (m_paStreams[0] == NULL) {
        *phr = E_OUTOFMEMORY;
        return;
    }

    if (SUCCEEDED(*phr)) {
	ASSERT(m_Synth);
	m_Channels = 1;
	m_SamplesPerSec = 11025;
	m_BitsPerSample = 8;
	m_Synth->put_SynthFormat(m_Channels, m_BitsPerSample, m_SamplesPerSec);
    }
}

//
// CSynthFilter::Destructor
//
CSynthFilter::~CSynthFilter(void) {

    //
    //  Base class will free our pins
    //
}

//
// NonDelegatingQueryInterface
//
// Reveal our property page, persistance, and control interfaces

STDMETHODIMP CSynthFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CAutoLock l(&m_cStateLock);

    if (riid == IID_ISynth) {
        return GetInterface((ISynth *) this, ppv);
    }
    else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else {
        return CSource::NonDelegatingQueryInterface(riid, ppv);
    }
}


//
// GetPages
//
STDMETHODIMP CSynthFilter::GetPages(CAUUID * pPages) {

    CAutoLock l(&m_cStateLock);

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_SynthPropertyPage;

    return NOERROR;

}

// -------------------------------------------------------------------------
// --- IPersistStream ---
// -------------------------------------------------------------------------

#define WRITEOUT(var)   hr = pStream->Write(&var, sizeof(var), NULL); \
                        if (FAILED(hr)) return hr;

#define READIN(var)     hr = pStream->Read(&var, sizeof(var), NULL); \
                        if (FAILED(hr)) return hr;

STDMETHODIMP CSynthFilter::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);
}

int CSynthFilter::SizeMax ()
{
    return sizeof (int) * 8;
}

HRESULT CSynthFilter::WriteToStream(IStream *pStream)
{
    HRESULT hr;
    int i, k;

    get_Frequency (&i);  // don't we wish we'd used a structure, now?
    WRITEOUT(i);
    get_Waveform (&i);
    WRITEOUT(i);
    get_Channels (&i);
    WRITEOUT(i);
    get_BitsPerSample (&i);
    WRITEOUT(i);
    get_SamplesPerSec (&i);
    WRITEOUT(i);
    get_Amplitude (&i);
    WRITEOUT(i);
    get_SweepRange (&i, &k);
    WRITEOUT(i);
    WRITEOUT(k);

    return hr;
}


HRESULT CSynthFilter::ReadFromStream(IStream *pStream)
{
    HRESULT hr;
    int i, k;

    READIN(i);
    put_Frequency(i);
    READIN(i);
    put_Waveform (i);
    READIN(i);
    put_Channels (i);
    READIN(i);
    put_BitsPerSample (i);
    READIN(i);
    put_SamplesPerSec (i);
    READIN(i);
    put_Amplitude (i);
    READIN(i);
    READIN(k);
    put_SweepRange (i, k);

    return hr;
}

// -------------------------------------------------------------------------
// ISynth, the control interface for the synthesizer
// -------------------------------------------------------------------------

//
// get_Frequency
//
STDMETHODIMP CSynthFilter::get_Frequency(int *Frequency) {

    m_Synth->get_Frequency(Frequency);

    DbgLog((LOG_TRACE, 3, TEXT("get_Frequency: %d"), *Frequency));

    return NOERROR;
}


//
// put_Frequency
//
STDMETHODIMP CSynthFilter::put_Frequency(int Frequency) {

    m_Synth->put_Frequency (Frequency);

    DbgLog((LOG_TRACE, 3, TEXT("put_Frequency: %d"), Frequency));

    return NOERROR;
}

//
// get_Waveform
//
STDMETHODIMP CSynthFilter::get_Waveform(int *Waveform) {

    m_Synth->get_Waveform (Waveform);

    DbgLog((LOG_TRACE, 3, TEXT("get_Waveform: %d"), *Waveform));

    return NOERROR;
}


//
// put_Waveform
//
STDMETHODIMP CSynthFilter::put_Waveform(int Waveform) {

    m_Synth->put_Waveform (Waveform);

    DbgLog((LOG_TRACE, 3, TEXT("put_Waveform: %d"), Waveform));

    return NOERROR;
}

//
// get_Channels
//
STDMETHODIMP CSynthFilter::get_Channels(int *Channels) {

    *Channels = m_Channels;

    DbgLog((LOG_TRACE, 3, TEXT("get_Channels: %d"), *Channels));

    return NOERROR;
}

//
// If the format changes, we need to reconnect
//
void CSynthFilter::ReconnectWithNewFormat(void) {

//    CAutoLock l(&m_SynthLock);

    HRESULT hr;
    FILTER_STATE  State;

    CBasePin *pPin = GetPin(0);

    // Get the state and confirm that the graph is stopped
    GetState (0, &State);
    if (State != State_Stopped && pPin->GetConnected()) {
	// let's attempt a dynamic connection
	CMediaType mtNew;

	// !!! better way to get back to a CSynthStream???
	CSynthStream * pStream = (CSynthStream *) pPin;
	pStream->GetMediaType(&mtNew);

	// !!! does this really mean they'll accept a dynamic format change?
	hr = pPin->GetConnected()->QueryAccept(&mtNew);

	DbgLog((LOG_TRACE,2,TEXT("Attempting format change: queryAccept returned %x"), hr));

	if (hr == S_OK) {
	    // actually change what's being pushed
	    m_Synth->put_SynthFormat(m_Channels, m_BitsPerSample, m_SamplesPerSec);
	} else {
	    // !!! couldn't change right now, we should really schedule a reconnect
	    // for the next time the graph is stopped.
	}
	
        return;
    }

    if (!m_pGraph)
        return;

    hr = GetFilterGraph()->Reconnect (pPin);       // Renegotiate the format
    if (FAILED(hr)) {
        DbgLog((LOG_TRACE, 1, TEXT("Reconnect failed, err=%x"), hr));
        return;
    }
}


//
// put_Channels
//
STDMETHODIMP CSynthFilter::put_Channels(int Channels) {

    m_Channels = Channels;

    ReconnectWithNewFormat ();

    DbgLog((LOG_TRACE, 3, TEXT("put_Channels: %d"), Channels));

    return NOERROR;
}

//
// get_BitsPerSample
//
STDMETHODIMP CSynthFilter::get_BitsPerSample(int *BitsPerSample) {

    *BitsPerSample = m_BitsPerSample;

    DbgLog((LOG_TRACE, 3, TEXT("get_BitsPerSample: %d"), *BitsPerSample));

    return NOERROR;
}


//
// put_BitsPerSample
//
STDMETHODIMP CSynthFilter::put_BitsPerSample(int BitsPerSample) {

    m_BitsPerSample = BitsPerSample;

    ReconnectWithNewFormat ();

    DbgLog((LOG_TRACE, 3, TEXT("put_BitsPerSample: %d"), BitsPerSample));

    return NOERROR;
}

//
// get_SamplesPerSec
//
STDMETHODIMP CSynthFilter::get_SamplesPerSec(int *SamplesPerSec) {

    *SamplesPerSec = m_SamplesPerSec;

    DbgLog((LOG_TRACE, 3, TEXT("get_SamplesPerSec: %d"), *SamplesPerSec));

    return NOERROR;
}


//
// put_SamplesPerSec
//
STDMETHODIMP CSynthFilter::put_SamplesPerSec(int SamplesPerSec) {

    m_SamplesPerSec = SamplesPerSec;

    ReconnectWithNewFormat ();

    DbgLog((LOG_TRACE, 3, TEXT("put_SamplesPerSec: %d"), SamplesPerSec));

    return NOERROR;
}

//
// get_Amplitude
//
STDMETHODIMP CSynthFilter::get_Amplitude(int *Amplitude) {

    m_Synth->get_Amplitude (Amplitude);

    DbgLog((LOG_TRACE, 3, TEXT("get_Amplitude: %d"), *Amplitude));

    return NOERROR;
}


//
// put_Amplitude
//
STDMETHODIMP CSynthFilter::put_Amplitude(int Amplitude) {

    m_Synth->put_Amplitude (Amplitude);

    DbgLog((LOG_TRACE, 3, TEXT("put_Amplitude: %d"), Amplitude));

    return NOERROR;
}


//
// get_SweepRange
//
STDMETHODIMP CSynthFilter::get_SweepRange(int *SweepStart, int *SweepEnd) {

    m_Synth->get_SweepRange (SweepStart, SweepEnd);

    DbgLog((LOG_TRACE, 3, TEXT("get_SweepStart: %d %d"), *SweepStart, *SweepEnd));

    return NOERROR;
}


//
// put_SweepRange
//
STDMETHODIMP CSynthFilter::put_SweepRange(int SweepStart, int SweepEnd) {

    m_Synth->put_SweepRange (SweepStart, SweepEnd);

    DbgLog((LOG_TRACE, 3, TEXT("put_SweepRange: %d %d"), SweepStart, SweepEnd));

    return NOERROR;
}


// -------------------------------------------------------------------------
// CSynthStream, the output pin
// -------------------------------------------------------------------------

//
// CSynthStream::Constructor
//

CSynthStream::CSynthStream(HRESULT *phr, CSynthFilter *pParent, LPCWSTR pName)
    : CSourceStream(NAME("Audio Synth output pin"),phr, pParent, pName) {

    CAutoLock l(m_pFilter->pStateLock());

    {
        CAutoLock l(&m_cSharedState);

        m_Synth = new CAudioSynth( );
        pParent->m_Synth = m_Synth;
        if (m_Synth == NULL) {
            *phr = E_OUTOFMEMORY;
            return;
        }
	m_pParent = pParent;
    }
}


//
// CSynthStream::Destructor
//
CSynthStream::~CSynthStream(void) {

    CAutoLock l(&m_cSharedState);

    delete m_Synth;
}


//
// FillBuffer
//
// Stuffs the buffer with data
HRESULT CSynthStream::FillBuffer(IMediaSample *pms) {

    BYTE *pData;
    long lDataLen;
    int nSamplesPerSec;
    int nBitsPerSample;
    int nChannels;
    BOOL fNewFormat = FALSE;

    pms->GetPointer(&pData);
    lDataLen = pms->GetSize();

    CAutoLock lShared(&m_cSharedState);
   // m_Synth->FillAudioBuffer (pData, lDataLen, &fNewFormat);
	m_Synth->CalcOneF (pData, lDataLen);

    if (fNewFormat) {
	CMediaType mtNew;
	GetMediaType(&mtNew);

	pms->SetMediaType(&mtNew);

	DbgLog((LOG_TRACE,2,TEXT("Sending buffer with new media type")));
    }

    CRefTime rtStart  = m_rtSampleTime;  // the current time is the sample's start

    m_Synth->get_SamplesPerSec (&nSamplesPerSec);
    m_Synth->get_BitsPerSample (&nBitsPerSample);
    m_Synth->get_Channels (&nChannels);

    m_rtSampleTime += (UNITS * lDataLen /
            (nSamplesPerSec * nChannels * nBitsPerSample / 8));

    pms->SetTime((REFERENCE_TIME*)&rtStart,
                 (REFERENCE_TIME*)&m_rtSampleTime);

    return NOERROR;
}


//
// Format Support
//

//
// GetMediaType
//
HRESULT CSynthStream::GetMediaType(CMediaType *pmt) {

    CAutoLock l(m_pFilter->pStateLock());

    WAVEFORMATEX *pwf = (WAVEFORMATEX *) pmt->AllocFormatBuffer(sizeof(WAVEFORMATEX));

    pwf->wFormatTag = WAVE_FORMAT_PCM;
    pwf->nChannels = (WORD) m_pParent->m_Channels;
    pwf->nSamplesPerSec = (DWORD) m_pParent->m_SamplesPerSec;
    pwf->wBitsPerSample = (WORD) m_pParent->m_BitsPerSample;
    pwf->nBlockAlign = pwf->wBitsPerSample * pwf->nChannels / 8;
    pwf->nAvgBytesPerSec = (int) ((DWORD) pwf->nBlockAlign *
                           pwf->nSamplesPerSec);
    pwf->cbSize = 0;

    return CreateAudioMediaType(pwf, pmt, FALSE);
}


//
// CheckMediaType
//
// Returns E_INVALIDARG if the mediatype is not acceptable, S_OK if it is
HRESULT CSynthStream::CheckMediaType(const CMediaType *pMediaType) {

    CAutoLock l(m_pFilter->pStateLock());

    //  Check that's Audio and that the format block
    //  has the WAVEFORMATEX structure (indicated by a format type
    //  GUID of FORMAT_WaveFormatEx)

    if ((*pMediaType->Type() != MEDIATYPE_Audio) ||
        (*pMediaType->FormatType() != FORMAT_WaveFormatEx))
        return E_INVALIDARG;

    WAVEFORMATEX * pwfx  = (WAVEFORMATEX *)pMediaType->Format();

    if (pwfx->wFormatTag != WAVE_FORMAT_PCM)
	return E_INVALIDARG;

    // !!! check 8/16, 1/2 channel

    // Check for the subtypes we support

    // Get the format area of the media type

    // !!! if we're going to allow arbitrary media types here, we have to actually
    // look at SetMediaType to see what we've agreed on!

    return S_OK;  // This format is acceptable.
}

//
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. So we have a look at m_mt to see what format we agreed to.
// Then we can ask for buffers of the correct size to contain them.
HRESULT CSynthStream::DecideBufferSize(IMemAllocator *pAlloc,
                                       ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock l(m_pFilter->pStateLock());
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    pProperties->cbBuffer = WaveBufferSize;

    int nBitsPerSample;
    int nSamplesPerSec;
    int nChannels;

    m_Synth->get_SamplesPerSec (&nSamplesPerSec);
    m_Synth->get_BitsPerSample (&nBitsPerSample);
    m_Synth->get_Channels (&nChannels);

    pProperties->cBuffers = nChannels * (nSamplesPerSec / pProperties->cbBuffer) * (nBitsPerSample / 8);
    // Get 1/2 second worth of buffers
    pProperties->cBuffers /= 2;
    if (pProperties->cBuffers < 1)
        pProperties->cBuffers = 1 ;

    // Ask the allocator to reserve us the memory

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }
    return NOERROR;
}


//
// SetMediaType
//
// Overriden from CBasePin.
HRESULT CSynthStream::SetMediaType(const CMediaType *pMediaType) {

    CAutoLock l(m_pFilter->pStateLock());

    HRESULT hr;         // return code from base class calls

    // Pass the call up to my base class
    hr = CSourceStream::SetMediaType(pMediaType);
    if (SUCCEEDED(hr))
        return NOERROR;
    else
        return hr;

}


//
// OnThreadCreate
//
// as we go active reset the stream time to zero
HRESULT CSynthStream::OnThreadCreate(void) {

    CAutoLock lShared(&m_cSharedState);

    m_rtSampleTime = 0;

    return NOERROR;
}

//
// Active
//
// Send a message to the property page telling it to disable
// buttons which change the format when the graph starts running
HRESULT CSynthStream::Active  (void) {
    m_Synth->AllocWaveCache();

    return CSourceStream::Active();
}


//
// Inactive
//
// Send a message to the property page telling it to enable
// buttons which change the format when the graph stops running
HRESULT CSynthStream::Inactive  (void) {
    return CSourceStream::Inactive();
}

// -------------------------------------------------------------------------
// CAudioSynth
// -------------------------------------------------------------------------
// Object that knows nothing about ActiveMovie, but just synthesizes
// waveforms

CAudioSynth::CAudioSynth(
                int Frequency,
                int Waveform,
                int iBitsPerSample,
                int iChannels,
                int iSamplesPerSec,
                int iAmplitude
                )
    : m_bWaveCache(NULL),
      m_wWaveCache(NULL)
{

    ASSERT(Waveform >= WAVE_SINE);
    ASSERT(Waveform <  WAVE_LAST);

    m_iFrequency = Frequency;
    m_iWaveform = Waveform;
    m_iAmplitude = iAmplitude;
    m_iSweepStart = DefaultSweepStart;
    m_iSweepEnd = DefaultSweepEnd;

    // init our WAVEFORMATEX structure
    wfex.wFormatTag = WAVE_FORMAT_PCM;
    wfex.wBitsPerSample = iBitsPerSample;
    wfex.nChannels = iChannels;
    wfex.nSamplesPerSec = iSamplesPerSec;
    wfex.nBlockAlign = wfex.wBitsPerSample * wfex.nChannels / 8;
    wfex.nAvgBytesPerSec = ((DWORD) wfex.nBlockAlign *
                           wfex.nSamplesPerSec);
    wfex.cbSize = 0;
}

CAudioSynth::~CAudioSynth()
{
    if (m_bWaveCache) {
        delete[] m_bWaveCache;
    }

    if (m_wWaveCache) {
        delete[] m_wWaveCache;
    }
}

//
// AllocWaveCache
//
//
void CAudioSynth::AllocWaveCache (void) {
    wfexLast = wfex;

    m_iWaveCacheCycles = m_iFrequency;
    m_iWaveCacheSize = (int) wfex.nSamplesPerSec;

    m_iFrequencyLast = 0;	// force cache contents invalid

    if (m_bWaveCache) {
        delete[] m_bWaveCache;
        m_bWaveCache = NULL;
    }
    if (m_wWaveCache) {
        delete[] m_wWaveCache;
        m_wWaveCache = NULL;
    }

    if (wfex.wBitsPerSample == 8)
        m_bWaveCache = new BYTE [m_iWaveCacheSize];
    else
        m_wWaveCache = new WORD [m_iWaveCacheSize];
}

//
// FillAudioBuffer
//
//
//
//
//
/**********************************************************************
fran: return a random float between min and max (ECM pg 417)
/**********************************************************************/
double 
CAudioSynth::fran(double min, double max)
{
    return((max - min) * ((double)rand()/RMAX) + min);
}

/**********************************************************************
iran: return a random int value between min and max (ECM pg 417)
**********************************************************************/
int 
CAudioSynth::iran(int min, int max)
{
    return((int)fran((double)min, max + 0.9999));
}


void CAudioSynth::CalcOneF (BYTE pBuf[], int len) {

	//define buffer related to wfex.nSamplesPerSec

  int i, n, lastn, length, numSamples, N;
  length = len;
   
  short *buffer;  
  float  halfrange;
  float *r;
  float  R;
	numSamples = 0;
	N = 4;  //default value.  make changeable later.
    r = (float *) malloc (N*sizeof(float));
	numSamples = (int)pow(2.0, (double)N);
    buffer  = (short *)malloc(numSamples*sizeof(short));
    
	// compute length of output sequence
    //for(length= 1, i= 0; i < N; i++)
	//length <<= 1;

	   // normalize halfrange so that sum of all generators always lies in (-1,1)
    halfrange = 1.0/N;

    lastn = length -1; // initialize previous index value

    // generate the sequence
    for(n= 0; n < length; n++) 
       {
       // at each step, check for changing bits and update corresponding random
       //numbers--thier sum is the output

       for(R= i= 0; i<N; i++)
		  {
			if(((1<<i)&n) != ((1<<i)&lastn))
			r[i]= fran(-halfrange, halfrange);
			R+=r[i];
			}
			//printf("%d %f\n", index, R);
		
	   *pBuf++ = (short)(R * 0x7FFF);
       lastn = n;
     }//end for(n)

}

//
// get_Frequency
//
STDMETHODIMP CAudioSynth::get_Frequency(int *Frequency) {

    *Frequency = m_iFrequency;

    DbgLog((LOG_TRACE, 3, TEXT("get_Frequency: %d"), *Frequency));

    return NOERROR;
}


//
// put_Frequency
//
STDMETHODIMP CAudioSynth::put_Frequency(int Frequency) {

    CAutoLock l(&m_SynthLock);

    m_iFrequency = Frequency;

    DbgLog((LOG_TRACE, 3, TEXT("put_Frequency: %d"), Frequency));

    return NOERROR;
}

//
// get_Waveform
//
STDMETHODIMP CAudioSynth::get_Waveform(int *Waveform) {

    *Waveform = m_iWaveform;

    DbgLog((LOG_TRACE, 3, TEXT("get_Waveform: %d"), *Waveform));

    return NOERROR;
}


//
// put_Waveform
//
STDMETHODIMP CAudioSynth::put_Waveform(int Waveform) {

    CAutoLock l(&m_SynthLock);

    m_iWaveform = Waveform;

    DbgLog((LOG_TRACE, 3, TEXT("put_Waveform: %d"), Waveform));

    return NOERROR;
}

//
// get_Channels
//
STDMETHODIMP CAudioSynth::get_Channels(int *Channels) {

    *Channels = wfex.nChannels;

    DbgLog((LOG_TRACE, 3, TEXT("get_Channels: %d"), *Channels));

    return NOERROR;
}


//
// get_BitsPerSample
//
STDMETHODIMP CAudioSynth::get_BitsPerSample(int *BitsPerSample) {

    *BitsPerSample = wfex.wBitsPerSample;

    DbgLog((LOG_TRACE, 3, TEXT("get_BitsPerSample: %d"), *BitsPerSample));

    return NOERROR;
}


//
// get_SamplesPerSec
//
STDMETHODIMP CAudioSynth::get_SamplesPerSec(int *SamplesPerSec) {

    *SamplesPerSec = wfex.nSamplesPerSec;

    DbgLog((LOG_TRACE, 3, TEXT("get_SamplesPerSec: %d"), *SamplesPerSec));

    return NOERROR;
}

//
// put_SynthFormat
//
STDMETHODIMP CAudioSynth::put_SynthFormat(int Channels, int BitsPerSample,
					  int SamplesPerSec) {

    CAutoLock l(&m_SynthLock);

    wfex.nChannels = Channels;

    wfex.wBitsPerSample = BitsPerSample;

    wfex.nSamplesPerSec = SamplesPerSec;

    DbgLog((LOG_TRACE, 1, TEXT("put_SynthFormat: %d-bit %d-channel %dHz"),
	    BitsPerSample, Channels, SamplesPerSec));

    return NOERROR;
}


//
// get_Amplitude
//
STDMETHODIMP CAudioSynth::get_Amplitude(int *Amplitude) {

    *Amplitude =  m_iAmplitude;

    DbgLog((LOG_TRACE, 3, TEXT("get_Amplitude: %d"), *Amplitude));

    return NOERROR;
}


//
// put_Amplitude
//
STDMETHODIMP CAudioSynth::put_Amplitude(int Amplitude) {

    CAutoLock l(&m_SynthLock);

    if (Amplitude > MaxAmplitude || Amplitude < MinAmplitude)
        return E_INVALIDARG;

    m_iAmplitude = Amplitude;

    DbgLog((LOG_TRACE, 3, TEXT("put_Amplitude: %d"), Amplitude));

    return NOERROR;
}


//
// get_SweepRange
//
STDMETHODIMP CAudioSynth::get_SweepRange(int *SweepStart, int *SweepEnd) {

    *SweepStart = m_iSweepStart;
    *SweepEnd = m_iSweepEnd;

    DbgLog((LOG_TRACE, 3, TEXT("get_SweepStart: %d %d"), *SweepStart, *SweepEnd));

    return NOERROR;
}


//
// put_SweepRange
//
STDMETHODIMP CAudioSynth::put_SweepRange(int SweepStart, int SweepEnd) {

    CAutoLock l(&m_SynthLock);

    m_iSweepStart = SweepStart;
    m_iSweepEnd = SweepEnd;

    DbgLog((LOG_TRACE, 3, TEXT("put_SweepRange: %d %d"), SweepStart, SweepEnd));

    return NOERROR;
}

/******************************Public*Routine******************************\
* exported entry points for registration and
* unregistration (in this case they only call
* through to default implmentations).
*
*
*
* History:
*
\**************************************************************************/
STDAPI
DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI
DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}


// call the quartz dll entry point (since filters need initialization)
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);
BOOL WINAPI DllMain(HINSTANCE hinstDLL,  // handle to DLL module
    DWORD fdwReason,     // reason for calling function
    LPVOID lpvReserved   // reserved
    )
{
    return DllEntryPoint( hinstDLL, fdwReason, lpvReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\synth\onef\synth.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  synth.h
//
//  Audio Signal Generator

#ifndef __AUDIOSYNTH__
#define __AUDIOSYNTH__

// This was generated by Ken on 9/9/98
//CLSID_SynthFilter 
// {3D76319F-482D-11d2-AA53-00C04FC2F60F}
DEFINE_GUID(CLSID_SynthFilter, 
0x3d76319f, 0x482d, 0x11d2, 0xaa, 0x53, 0x0, 0xc0, 0x4f, 0xc2, 0xf6, 0xf);


// This was generated by Ken on 9/9/98
// {5A6D82AF-482E-11d2-AA53-00C04FC2F60F}
DEFINE_GUID(CLSID_SynthPropertyPage,
0x5a6d82af, 0x482e, 0x11d2, 0xaa, 0x53, 0x0, 0xc0, 0x4f, 0xc2, 0xf6, 0xf);


const double TWOPI = 6.283185308;
const int MaxFrequency = 20000;
const int MinFrequency = 0;
const int DefaultFrequency = 440;       // A-440
const int MaxAmplitude = 100;
const int MinAmplitude = 0;
const int DefaultSweepStart = DefaultFrequency;
const int DefaultSweepEnd = 5000;
const int WaveBufferSize = 16*1024;     // Size of each allocated buffer
                                        // Originally used to be 2K, but at
                                        // 44khz/16bit/stereo you would get
                                        // audio breaks with a transform in the
                                        // middle.

enum Waveforms {
    WAVE_SINE = 0,
    WAVE_SQUARE,
    WAVE_SAWTOOTH,
    WAVE_SINESWEEP,
    WAVE_LAST           // Always keep this guy last
};

#define WM_PROPERTYPAGE_ENABLE  (WM_USER + 100)

// below stuff is implementation-only....
#ifdef _AUDIOSYNTH_IMPLEMENTATION_

class CSynthStream;

// -------------------------------------------------------------------------
// CAudioSynth
// -------------------------------------------------------------------------

class CAudioSynth {

public:

    CAudioSynth(
                int Frequency = DefaultFrequency,
                int Waveform = WAVE_SINE,
                int iBitsPerSample = 8,
                int iChannels = 1,
                int iSamplesPerSec = 11025,
                int iAmplitude = 100
                );

    ~CAudioSynth();

    // Load the buffer with the current waveform
    void FillAudioBuffer (BYTE pBuf[], int iSize, BOOL * fNewFormat);
	// My version of loading buffer with current waveform!!
	void CalcOneF          (BYTE pBuf[], int iSize) ;  
    // Set the "current" format and allocate temporary memory
    void AllocWaveCache    (void) ;

    STDMETHODIMP get_Frequency(int *Frequency);
    STDMETHODIMP put_Frequency(int  Frequency);
    STDMETHODIMP get_Waveform(int *Waveform);
    STDMETHODIMP put_Waveform(int  Waveform);
    STDMETHODIMP get_Channels(int *Channels);
    STDMETHODIMP get_BitsPerSample(int *BitsPerSample);
    STDMETHODIMP get_SamplesPerSec(int *SamplesPerSec);
    STDMETHODIMP put_SynthFormat(int Channels, int BitsPerSample, int SamplesPerSec);
    STDMETHODIMP get_Amplitude(int *Amplitude);
    STDMETHODIMP put_Amplitude(int  Amplitude);
    STDMETHODIMP get_SweepRange(int *SweepStart, int *SweepEnd);
    STDMETHODIMP put_SweepRange(int  SweepStart, int  SweepEnd);

private:
    CCritSec m_SynthLock;

    WAVEFORMATEX wfex;          // the current format
    WAVEFORMATEX wfexLast;      // last known waveformat

    int m_iWaveform;            // WAVE_SINE ...
    int m_iFrequency;           // if not using sweep, this is the frequency
    int m_iAmplitude;           // 0 to 100

    int m_iWaveformLast;        // keep track of the last known format
    int m_iFrequencyLast;       // so we can flush the cache if necessary
    int m_iAmplitudeLast;

    int m_iCurrentSample;       // 0 to iSamplesPerSec-1
    BYTE * m_bWaveCache;        // Wave Cache as BYTEs
    WORD * m_wWaveCache;        // Wave Cache as WORDs
    int m_iWaveCacheSize;       // how big is the cache?
    int m_iWaveCacheCycles;     // how many cycles are in the cache
    int m_iWaveCacheIndex;

    int m_iSweepStart;           // start of sweep
    int m_iSweepEnd;             // end of sweep
//    double m_SweepDuration;     // how long the sweep lasts

    void CalcCacheSine     (void) ;
    void CalcCacheSquare   (void) ;
    void CalcCacheSawtooth (void) ;
    void CalcCacheSweep    (void) ;
	//void CalcOneF          (BYTE pBuf[]) ;
	int iran(int min, int max);
	double fran(double min, double max);

};



// -------------------------------------------------------------------------
// CSynthFilter
// -------------------------------------------------------------------------
// CSynthFilter manages filter level stuff

class CSynthFilter :    public ISynth,
                        public CPersistStream,
                        public ISpecifyPropertyPages,
                        public CSource {

public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    ~CSynthFilter();

    DECLARE_IUNKNOWN;

    // override this to reveal our property interface
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // --- ISpecifyPropertyPages ---

    // return our property pages
    STDMETHODIMP GetPages(CAUUID * pPages);

    // --- IPersistStream Interface

    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);

    //
    // --- ISynth ---
    //

    STDMETHODIMP get_Frequency(int *Frequency);
    STDMETHODIMP put_Frequency(int Frequency);
    STDMETHODIMP get_Waveform(int *Waveform);
    STDMETHODIMP put_Waveform(int Waveform);
    STDMETHODIMP get_Channels(int *Channels);
    STDMETHODIMP get_BitsPerSample(int *BitsPerSample);
    STDMETHODIMP get_SamplesPerSec(int *SamplesPerSec);
    STDMETHODIMP put_Channels(int Channels);
    STDMETHODIMP put_BitsPerSample(int BitsPersample);
    STDMETHODIMP put_SamplesPerSec(int SamplesPerSec);
    STDMETHODIMP get_Amplitude(int *Amplitude);
    STDMETHODIMP put_Amplitude(int Amplitude);
    STDMETHODIMP get_SweepRange(int *SweepStart, int *SweepEnd);
    STDMETHODIMP put_SweepRange(int  SweepStart, int  SweepEnd);

    CAudioSynth *m_Synth;           // the current synthesizer
    int		m_Channels;
    int		m_BitsPerSample;
    int		m_SamplesPerSec;

private:

    // it is only allowed to to create these objects with CreateInstance
    CSynthFilter(LPUNKNOWN lpunk, HRESULT *phr);

    // When the format changes, reconnect...
    void CSynthFilter::ReconnectWithNewFormat(void);

};


// -------------------------------------------------------------------------
// CSynthStream
// -------------------------------------------------------------------------
// CSynthStream manages the data flow from the output pin.

class CSynthStream : public CSourceStream {

public:

    CSynthStream(HRESULT *phr, CSynthFilter *pParent, LPCWSTR pPinName);
    ~CSynthStream();

    BOOL ReadyToStop(void) {return FALSE;}

    // stuff an audio buffer with the current format
    HRESULT FillBuffer(IMediaSample *pms);

    // ask for buffers of the size appropriate to the agreed media type.
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    // verify we can handle this format
    HRESULT CheckMediaType(const CMediaType *pMediaType);

    // set the agreed media type
    HRESULT SetMediaType(const CMediaType *pMediaType);

    HRESULT GetMediaType(CMediaType *pmt);

    // resets the stream time to zero.
    HRESULT OnThreadCreate(void);

    HRESULT Active   (void);
    HRESULT Inactive (void);

private:

    // Access to this state information should be serialized with the filters
    // critical section (m_pFilter->pStateLock())

    CCritSec    m_cSharedState;     // use this to lock access to m_rtSampleTime and m_Synth
                                    // which are shared with the worker thread.

    CRefTime     m_rtSampleTime;    // The time to be stamped on each sample
    CAudioSynth *m_Synth;           // the current synthesizer

    CSynthFilter *m_pParent;
};



#endif // _AUDIOSYNTH_IMPLEMENTATION_ implementation only....

#endif /* __AUDIOSYNTH__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\synth\onef\synthprp.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// synthprop.cpp - Synthesizer Property Page
//

#include <windows.h>
#include <streams.h>
#include <commctrl.h>
#include <memory.h>
#include <olectl.h>

#include "isynth.h"
#include "synth.h"
#include "synthprp.h"
#include "resource.h"


// -------------------------------------------------------------------------
// CSynthProperties
// -------------------------------------------------------------------------

//
// CreateInstance
//

CUnknown * WINAPI CSynthProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CSynthProperties(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// Constructor
//
// Creaete a Property page object for the synthesizer

CSynthProperties::CSynthProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("Synth Property Page"), lpunk,
        IDD_SYNTHPROP1,IDS_SYNTHPROPNAME)
    , m_pSynth(NULL)
    , m_iSweepStart(DefaultSweepStart)
    , m_iSweepEnd(DefaultSweepEnd)
	, m_fWindowInActive(TRUE)
{
    ASSERT(phr);

    InitCommonControls();
}

//
// OnConnect
//
// Give us the filter to communicate with

HRESULT CSynthProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pSynth == NULL);

    // Ask the filter for it's control interface

    HRESULT hr = pUnknown->QueryInterface(IID_ISynth,(void **)&m_pSynth);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    ASSERT(m_pSynth);

    // Get current filter state
    m_pSynth->get_BitsPerSample(&m_iBitsPerSampleOriginal);
    m_pSynth->get_Waveform(&m_iWaveformOriginal);
    m_pSynth->get_Frequency(&m_iFrequencyOriginal);
    m_pSynth->get_Channels(&m_iChannelsOriginal);
    m_pSynth->get_SamplesPerSec(&m_iSamplesPerSecOriginal);
    m_pSynth->get_Amplitude(&m_iAmplitudeOriginal);

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CSynthProperties::OnDisconnect()
{
    // Release the interface

    if (m_pSynth == NULL) {
        return E_UNEXPECTED;
    }

    m_pSynth->put_Waveform(m_iWaveformOriginal);
    m_pSynth->put_Frequency(m_iFrequencyOriginal);
    m_pSynth->put_Amplitude(m_iAmplitudeOriginal);

    m_pSynth->put_Channels(m_iChannelsOriginal);
    m_pSynth->put_BitsPerSample(m_iBitsPerSampleOriginal);
    m_pSynth->put_SamplesPerSec(m_iSamplesPerSecOriginal);

    m_pSynth->Release();
    m_pSynth = NULL;
    return NOERROR;
}


//
// OnActivate
//
// Called on dialog creation

HRESULT CSynthProperties::OnActivate(void)
{
    InitPropertiesDialog(m_hwnd);

   // ASSERT(m_hwndFreqSlider);

	m_fWindowInActive = FALSE;
    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CSynthProperties::OnDeactivate(void)
{
	m_fWindowInActive = TRUE;
    return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT CSynthProperties::OnApplyChanges(void)
{
    m_pSynth->get_BitsPerSample(&m_iBitsPerSampleOriginal);
    m_pSynth->get_Waveform(&m_iWaveformOriginal);
    m_pSynth->get_Frequency(&m_iFrequencyOriginal);
    m_pSynth->get_Channels(&m_iChannelsOriginal);
    m_pSynth->get_SamplesPerSec(&m_iSamplesPerSecOriginal);
    m_pSynth->get_Amplitude(&m_iAmplitudeOriginal);

    return NOERROR;
}


//
// OnReceiveMessages
//
// Handles the messages for our property window

BOOL CSynthProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam)
{

	if(m_fWindowInActive)
		return FALSE;

    switch (uMsg) {

    case WM_PROPERTYPAGE_ENABLE:
        // Our private message that our owning filter sends us when changing to a Run / Stop / Pause
        // state.  if lParam, then enable the controls which affect the format; if not lParam, then
        // disable the controls that affect the format.

        EnableWindow (GetDlgItem (hwnd, IDC_SAMPLINGFREQ11), (BOOL) lParam);
        EnableWindow (GetDlgItem (hwnd, IDC_SAMPLINGFREQ22), (BOOL) lParam);
        EnableWindow (GetDlgItem (hwnd, IDC_SAMPLINGFREQ44), (BOOL) lParam);

        EnableWindow (GetDlgItem (hwnd, IDC_BITSPERSAMPLE8),  (BOOL) lParam);
        EnableWindow (GetDlgItem (hwnd, IDC_BITSPERSAMPLE16), (BOOL) lParam);

        EnableWindow (GetDlgItem (hwnd, IDC_CHANNELS1), (BOOL) lParam);
        EnableWindow (GetDlgItem (hwnd, IDC_CHANNELS2), (BOOL) lParam);
        break;

    case WM_VSCROLL:
        if ((HWND) lParam == m_hwndFreqSlider)
            OnFreqSliderNotification(LOWORD (wParam), HIWORD (wParam));
        else if ((HWND) lParam == m_hwndAmplitudeSlider)
            OnAmpSliderNotification(LOWORD (wParam), HIWORD (wParam));
        SetDirty();
        return TRUE;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDC_FREQUENCYTEXT:
        {
            int iNotify = HIWORD (wParam);

            if (iNotify == EN_KILLFOCUS) {
                BOOL fOK;

                int iPos = GetDlgItemInt (hwnd, IDC_FREQUENCYTEXT, &fOK, FALSE);
                int iMaxFreq;

                m_pSynth->get_SamplesPerSec(&iMaxFreq);
                iMaxFreq /= 2;

                if (!fOK || (iPos > iMaxFreq || iPos < 0)) {
                    int iCurrentFreq;
                    m_pSynth->get_Frequency(&iCurrentFreq);
                    SetDlgItemInt (hwnd, IDC_FREQUENCYTEXT, iCurrentFreq, FALSE);
                    break;
                }

		   		SendMessage(m_hwndFreqSlider, TBM_SETPOS, TRUE, (LPARAM) iMaxFreq - iPos);
                m_pSynth->put_Frequency(iPos);
                SetDirty();
            }
        }
        break;

        case IDC_AMPLITUDETEXT:
        {
            int iNotify = HIWORD (wParam);

            if (iNotify == EN_KILLFOCUS) {
                BOOL fOK;

                int iPos = GetDlgItemInt (hwnd, IDC_AMPLITUDETEXT, &fOK, FALSE);

                if (!fOK || (iPos > MaxAmplitude || iPos < 0)) {
                    int iCurrentAmplitude;

                    m_pSynth->get_Amplitude(&iCurrentAmplitude);
                    SetDlgItemInt (hwnd, IDC_AMPLITUDETEXT, iCurrentAmplitude, FALSE);
                    break;
                }

			    SendMessage(m_hwndAmplitudeSlider, TBM_SETPOS, TRUE, (LPARAM) MaxAmplitude - iPos);
                m_pSynth->put_Amplitude(iPos);
                SetDirty();
            }
        }
        break;

        case IDC_SAMPLINGFREQ11:
            m_pSynth->put_SamplesPerSec(11025);
            RecalcFreqSlider();
            SetDirty();
            break;
        case IDC_SAMPLINGFREQ22:
            m_pSynth->put_SamplesPerSec(22050);
            RecalcFreqSlider();
            SetDirty();
            break;
        case IDC_SAMPLINGFREQ44:
            m_pSynth->put_SamplesPerSec(44100);
            RecalcFreqSlider();
            SetDirty();
            break;


        case IDC_BITSPERSAMPLE8:
            m_pSynth->put_BitsPerSample(8);
            SetDirty();
            break;
        case IDC_BITSPERSAMPLE16:
            m_pSynth->put_BitsPerSample(16);
            SetDirty();
            break;


        case IDC_CHANNELS1:
            m_pSynth->put_Channels(1);
            SetDirty();
            break;
        case IDC_CHANNELS2:
            m_pSynth->put_Channels(2);
            SetDirty();
            break;
	    

        case IDC_WAVESINE:
            m_pSynth->put_Waveform(WAVE_SINE);
            SetDirty();
            break;
        case IDC_WAVESQUARE:
            m_pSynth->put_Waveform(WAVE_SQUARE);
            SetDirty();
            break;
        case IDC_WAVESAWTOOTH:
            m_pSynth->put_Waveform(WAVE_SAWTOOTH);
            SetDirty();
            break;
        case IDC_WAVESWEEP:
            m_pSynth->put_Waveform(WAVE_SINESWEEP);
            SetDirty();
            break;

        default:
            break;

        }
        return TRUE;

    case WM_DESTROY:
        return TRUE;

    default:
        return FALSE;

    }
    return TRUE;
}


//
// InitPropertiesDialog
//

void
CSynthProperties::InitPropertiesDialog(HWND hwndParent)
{
    m_hwndFreqSlider = GetDlgItem (hwndParent, IDC_FREQTRACKBAR);
    m_hwndFreqText  = GetDlgItem (hwndParent, IDC_FREQUENCYTEXT);
    m_hwndAmplitudeSlider = GetDlgItem (hwndParent, IDC_AMPLITUDETRACKBAR);
    m_hwndAmplitudeText  = GetDlgItem (hwndParent, IDC_AMPLITUDETEXT);

    // Sampling Frequency
    int i;
    switch (m_iSamplesPerSecOriginal) {
    case 11025: i = IDC_SAMPLINGFREQ11; break;
    case 22050: i = IDC_SAMPLINGFREQ22; break;
    case 44100: i = IDC_SAMPLINGFREQ44; break;
    default:
        ASSERT(0);
    }
    CheckRadioButton(hwndParent,
        IDC_SAMPLINGFREQ11,
        IDC_SAMPLINGFREQ44,
        i);

    // BitsPerSample
    CheckRadioButton(hwndParent,
                IDC_BITSPERSAMPLE8,
                IDC_BITSPERSAMPLE16,
                IDC_BITSPERSAMPLE8 + m_iBitsPerSampleOriginal / 8 - 1);

    // Waveform 0 == sine, 1 == square, ...
    CheckRadioButton(hwndParent,
                IDC_WAVESINE,
                IDC_WAVESWEEP,
                IDC_WAVESINE + m_iWaveformOriginal);

    // Channels
    CheckRadioButton(hwndParent,
                IDC_CHANNELS1,
                IDC_CHANNELS2,
                IDC_CHANNELS1 + m_iChannelsOriginal - 1);

    //
    // Frequency trackbar
    //

    RecalcFreqSlider();

    //
    //  Amplitude trackbar
    //

    SendMessage(m_hwndAmplitudeSlider, TBM_SETRANGE, TRUE,
        MAKELONG(MinAmplitude, MaxAmplitude) );

    SendMessage(m_hwndAmplitudeSlider, TBM_SETTIC, 0,
        ((MinAmplitude + MaxAmplitude) / 2));

    SendMessage(m_hwndAmplitudeSlider, TBM_SETPOS, TRUE,
        (LPARAM) (MaxAmplitude - m_iAmplitudeOriginal));

    SetDlgItemInt (hwndParent, IDC_AMPLITUDETEXT,
        m_iAmplitudeOriginal, TRUE);
}


//
// RecalcFreqSlider
//
// Set the range, current settings for the Freq scrollbar

void
CSynthProperties::RecalcFreqSlider(void)
{
    int iPos, iMaxFreq;

    // Limit the frequency to one half the sampling frequency

    m_pSynth->get_SamplesPerSec(&iMaxFreq);
    iMaxFreq /= 2;
    m_pSynth->get_Frequency(&iPos);
    if (iPos > iMaxFreq)
        iPos = iMaxFreq;

    SendMessage(m_hwndFreqSlider, TBM_SETRANGE, TRUE,
        MAKELONG(0, iMaxFreq));

    SendMessage(m_hwndFreqSlider, TBM_SETTIC, 0,
        iMaxFreq / 2);

    SendMessage(m_hwndFreqSlider, TBM_SETPOS, TRUE,
        (LPARAM) (iMaxFreq - iPos));

    SendMessage(m_hwndFreqSlider, TBM_SETPAGESIZE, 0, 10);

    SendMessage(m_hwndFreqSlider, TBM_SETSEL, TRUE,
        MAKELONG (iMaxFreq - m_iSweepEnd, iMaxFreq - m_iSweepStart));

    SetDlgItemInt (m_hwnd, IDC_FREQUENCYTEXT,
        iPos, TRUE);

}

//
// OnFreqSliderNotification
//
// Handle the notification meesages from the slider control

void
CSynthProperties::OnFreqSliderNotification(WPARAM wParam, WORD wPosition)
{
    int MaxFreq;
    int Freq;
    int SliderPos;

    switch (wParam) {

    case TB_ENDTRACK:
    case TB_THUMBTRACK:
    case TB_LINEDOWN:
    case TB_LINEUP: {
        // max frequency of slider is half the sampling frequency
        m_pSynth->get_SamplesPerSec (&MaxFreq);
        MaxFreq /= 2;
        SliderPos = (int) SendMessage(m_hwndFreqSlider, TBM_GETPOS, 0, 0L);
        Freq = MaxFreq - SliderPos;
        m_pSynth->put_Frequency (Freq);

        // Set the end of sweep to the current slider pos
        if (!(GetKeyState (VK_SHIFT) & 0x8000)) {
            m_iSweepEnd = Freq;
        }

        // Set the start of the sweep range if SHIFT key is pressed
        if (GetKeyState (VK_SHIFT) & 0x8000) {
            m_iSweepStart = Freq;
        }
        m_pSynth->put_SweepRange (m_iSweepStart, m_iSweepEnd);

        if (m_iSweepEnd > m_iSweepStart)
            SendMessage(m_hwndFreqSlider, TBM_SETSEL, TRUE,
                MAKELONG (MaxFreq - m_iSweepEnd, MaxFreq - m_iSweepStart));
        else
            SendMessage(m_hwndFreqSlider, TBM_SETSEL, TRUE,
                MAKELONG (MaxFreq - m_iSweepStart, MaxFreq - m_iSweepEnd));

        SetDlgItemInt (m_hwnd, IDC_FREQUENCYTEXT, Freq, TRUE);

    }
    break;

    }
}

//
// OnAmpSliderNotification
//
// Handle the notification meesages from the slider control

void
CSynthProperties::OnAmpSliderNotification(WPARAM wParam, WORD wPosition)
{
    switch (wParam) {

    case TB_ENDTRACK:
    case TB_THUMBTRACK:
    case TB_LINEDOWN:
    case TB_LINEUP: {
        int Level = (int) SendMessage(m_hwndAmplitudeSlider, TBM_GETPOS, 0, 0L);
        m_pSynth->put_Amplitude (MaxAmplitude - Level);
        SetDlgItemInt (m_hwnd, IDC_AMPLITUDETEXT, MaxAmplitude - Level, TRUE);
    }
    break;

    }
}

//
// SetDirty
//
// notifies the property page site of changes

void
CSynthProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\synth\onef\synthprp.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  synthprp.h
//
//  CSynthProperties

class CSynthProperties : public CBasePropertyPage {

public:

    CSynthProperties(LPUNKNOWN lpUnk, HRESULT *phr);
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    BOOL OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

private:

    static BOOL CALLBACK DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void    InitPropertiesDialog(HWND hwndParent);
    void    OnFreqSliderNotification(WPARAM wParam, WORD wPosition);
    void    OnAmpSliderNotification(WPARAM wParam, WORD wPosition);
    void    RecalcFreqSlider(void );
    void    SetDirty(void );

    HWND    m_hwndFreqSlider;           // handle of slider
    HWND    m_hwndFreqText;             // Handle of frequency text window
    HWND    m_hwndAmplitudeSlider;      // handle of slider
    HWND    m_hwndAmplitudeText;        // Handle of amplitude text window

    int     m_iWaveformOriginal;        // WAVE_SINE ...
    int     m_iFrequencyOriginal;       // if not using sweep, this is the frequency
    int     m_iBitsPerSampleOriginal;   // 8 or 16
    int     m_iChannelsOriginal;        // 1 or 2
    int     m_iSamplesPerSecOriginal;   // 8000, 11025, ...
    int     m_iAmplitudeOriginal;       // 0 to 100
    int     m_iSweepStart;              // Sweep range on freq slider
    int     m_iSweepEnd;

	BOOL	m_fWindowInActive;		// TRUE ==> dialog is in the process of being destroyed

    ISynth  *m_pSynth;                  // Interface to the synthsizer
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\urlcache\reftime.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// CRefTime
//
// Manage reference times.
// Shares same data layout as REFERENCE_TIME, but adds some (nonvirtual)
// functions providing simple comparison, conversion and arithmetic.
//
// A reference time (at the moment) is a unit of seconds represented in
// 100ns units as is used in the Win32 FILETIME structure. BUT the time
// a REFERENCE_TIME represents is NOT the time elapsed since 1/1/1601 it
// will either be stream time or reference time depending upon context
//
// This class provides simple arithmetic operations on reference times
//
// keep non-virtual otherwise the data layout will not be the same as
// REFERENCE_TIME


// -----
// note that you are safe to cast a CRefTime* to a REFERENCE_TIME*, but
// you will need to do so explicitly
// -----


#ifndef __REFTIME__
#define __REFTIME__


const LONGLONG MILLISECONDS = (1000);            // 10 ^ 3
const LONGLONG NANOSECONDS = (1000000000);       // 10 ^ 9
const LONGLONG UNITS = (NANOSECONDS / 100);      // 10 ^ 7

/*  Unfortunately an inline function here generates a call to __allmul
    - even for constants!
*/
#define MILLISECONDS_TO_100NS_UNITS(lMs) \
    Int32x32To64((lMs), (UNITS / MILLISECONDS))

class CRefTime
{
public:

    // *MUST* be the only data member so that this class is exactly
    // equivalent to a REFERENCE_TIME.
    // Also, must be *no virtual functions*

    REFERENCE_TIME m_time;

    inline CRefTime()
    {
        // default to 0 time
        m_time = 0;
    };

    inline CRefTime(LONG msecs)
    {
        m_time = MILLISECONDS_TO_100NS_UNITS(msecs);
    };

    inline CRefTime(REFERENCE_TIME rt)
    {
        m_time = rt;
    };

    inline operator REFERENCE_TIME() const
    {
        return m_time;
    };

    inline CRefTime& operator=(const CRefTime& rt)
    {
        m_time = rt.m_time;
        return *this;
    };

    inline CRefTime& operator=(const LONGLONG ll)
    {
        m_time = ll;
        return *this;
    };

    inline CRefTime& operator+=(const CRefTime& rt)
    {
        return (*this = *this + rt);
    };

    inline CRefTime& operator-=(const CRefTime& rt)
    {
        return (*this = *this - rt);
    };

    inline LONG Millisecs(void)
    {
        return (LONG)(m_time / (UNITS / MILLISECONDS));
    };

    inline LONGLONG GetUnits(void)
    {
        return m_time;
    };
};

const LONGLONG TimeZero = 0;

#endif /* __REFTIME__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\urlcache\url.cpp ===
#include <windows.h>
#include "url.h"
#include <atlbase.h>

#undef _ATL_STATIC_REGISTRY

#include <atlimpl.cpp>
#include <winineti.h>

#define max(a,b)            (((a) > (b)) ? (a) : (b))
#define ASSERT _ASSERTE

///////////////////////////////////////////////////////////////////////////////
HRESULT
AddFileToCache(
    IN  PWSZ        pwszFilePath,
    IN  PWSZ        pwszUrl,
    IN  PWSZ        pwszOriginalUrl,
    IN  DWORD       dwFileSize,
    IN  LPFILETIME  pLastModifiedTime,
    IN  DWORD       dwCacheEntryType )
{
    HRESULT     hr                  = S_OK;
    FLAG        fCreateCacheEntry;
    char        *szOriginalUrl;
    char        szHeader[]          = "HTTP/1.0 200 OK\r\n\r\n";
    char        szExtension         [ INTERNET_MAX_URL_LENGTH + 1 ];
    char        szCacheFilePath     [ MAX_PATH + 1 ];
    char        *szFilePath;
    FILETIME    ZeroFileTime;
    DWORD       dwReserved;

    ASSERT( NULL != pwszFilePath );
    ASSERT( NULL != pwszUrl );

    USES_CONVERSION;
    char *szUrl = W2A(pwszUrl);

    if( NULL != pwszOriginalUrl )
    {
        szOriginalUrl = W2A(pwszOriginalUrl);
    }

    //
    // Check if the URL is already in the cache.
    //

    hr = QueryCreateCacheEntry( szUrl, pLastModifiedTime, &fCreateCacheEntry );
    
    if( hr == S_OK && fCreateCacheEntry )
    {
        //
        // We need to create the cache entry.
        //

        //
        // First, get the filename extension of the URL. We do this so
        // that the URL will show up in the IE cache window with the right icon.
        //

        hr = GetUrlExtension(
                szUrl,
                szExtension );

        if( hr == S_OK )
        {
            //
            // Now, create the cache entry.
            //

            if( !CreateUrlCacheEntryA( 
                    szUrl,
                    dwFileSize,
                    szExtension,
                    szCacheFilePath,
                    0 ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }
            else
            {
                //
                // Copy the file to the cache file path.
                //

                szFilePath = W2A(pwszFilePath);

                if( !CopyFileA(
                        szFilePath,
                        szCacheFilePath,
                        FALSE ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                }
            }
        }

        if( hr == S_OK )
        {
            //
            // Commit the cache entry.
            //

            if( NULL != pwszOriginalUrl )
            {
                //
                // The URL was redirected. Pass the original URL in via the
                // dwReserved parameter.
                //
                dwReserved = (DWORD)szOriginalUrl;
            }
            else
            {
                //
                // The URL was not redirected.
                //
                dwReserved = 0;
            }

            ZeroMemory( &ZeroFileTime, sizeof( FILETIME ) );

            if( !CommitUrlCacheEntryA(
                    szUrl,
                    szCacheFilePath,
                    ZeroFileTime,
                    *pLastModifiedTime,
                    dwCacheEntryType,
                    (LPBYTE)szHeader,
                    strlen( szHeader ),
                    NULL,
                    (DWORD_ALPHA_CAST)dwReserved ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }
        }

        if( hr != S_OK )
        {
            //
            // An error occured. Delete the cache entry.
            //
            DeleteUrlCacheEntry( szUrl );
        }
    }

    return( hr );
}

///////////////////////////////////////////////////////////////////////////////
HRESULT
QueryCreateCacheEntry(
    IN  PSZ         pszUrl,
    IN  LPFILETIME  pLastModifiedTime,
    OUT FLAG        *pfCreateCacheEntry )
{
    HRESULT                         hr                      = S_OK;
    FLAG                            fCreateCacheEntry       = FALSE;
    BYTE                            CacheEntryBuffer        [MAX_CACHE_ENTRY_INFO_SIZE];
    LPINTERNET_CACHE_ENTRY_INFOA    pCacheEntryInfo;
    DWORD                           dwCacheEntryInfoSize    = MAX_CACHE_ENTRY_INFO_SIZE;

    ASSERT( NULL != pszUrl );
    ASSERT( NULL != pLastModifiedTime );
    ASSERT( NULL != pfCreateCacheEntry );

    dwCacheEntryInfoSize    = MAX_CACHE_ENTRY_INFO_SIZE;
    pCacheEntryInfo         = (LPINTERNET_CACHE_ENTRY_INFOA)CacheEntryBuffer;
    
    ZeroMemory(pCacheEntryInfo, dwCacheEntryInfoSize);
    pCacheEntryInfo->dwStructSize = dwCacheEntryInfoSize;

    if (!GetUrlCacheEntryInfoA(
            pszUrl,
            pCacheEntryInfo,
            &dwCacheEntryInfoSize ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    if( hr == S_OK )
    {
        //
        // The URL already exists in the cache. Check if it is older than the source file.
        // Only replace it if it is.
        //

        if( CompareFileTime(
                &pCacheEntryInfo->LastModifiedTime, 
                pLastModifiedTime ) < 0 ) 
        {
            //
            // The last modified time of the currently cached URL is older
            // than the file being received. Delete the entry and re-create it.
            //

            DeleteUrlCacheEntry( pszUrl );

            fCreateCacheEntry = TRUE;
        }
    }
    else if( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
    {
        //
        // The URL does not exist in the cache. We have to create it.
        //

        fCreateCacheEntry = TRUE;

        hr = S_OK;
    }

    *pfCreateCacheEntry = fCreateCacheEntry;

    return( hr );
}

///////////////////////////////////////////////////////////////////////////////
HRESULT
GetUrlExtension(
    IN  PSZ     pszUrl,
    OUT PSZ     pszExtension )
{
    HRESULT         hr                  = S_OK;
    char            szCanonicalUrl      [INTERNET_MAX_URL_LENGTH + 1];
    char            szUrlPath           [INTERNET_MAX_URL_LENGTH + 1];
    DWORD           dwUrlBufferLength   = (INTERNET_MAX_URL_LENGTH + 1);
    PSZ             pszT;
    PSZ             pszT1;
    PSZ             pszT2;
    URL_COMPONENTSA UrlComponents;
    DWORD           dwLen;
    char            ch;

    ASSERT( NULL != pszUrl );
    ASSERT( NULL != pszExtension );

    if( !InternetCanonicalizeUrlA(
            pszUrl,
            szCanonicalUrl,
            &dwUrlBufferLength,
            ICU_NO_ENCODE | ICU_BROWSER_MODE ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }
    else
    {
        ZeroMemory( &UrlComponents, sizeof( URL_COMPONENTSA ) );

        UrlComponents.dwStructSize      = sizeof( URL_COMPONENTSA );
        UrlComponents.dwSchemeLength    = 1;
        
        UrlComponents.lpszUrlPath       = szUrlPath;
        UrlComponents.dwUrlPathLength   = INTERNET_MAX_URL_LENGTH + 1;

        if( !InternetCrackUrlA( szCanonicalUrl, 0, 0, &UrlComponents ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
        else
        {
            ASSERT( NULL != UrlComponents.lpszUrlPath );

            //
            // Now, look for the extension of the file path. 
            // If the URL has a query, then the extension is that of the URL before 
            // the query delimiter (?) -- e.g., the extension of http://foo.asp?default.gif 
            // is "asp," not "gif." If the URL does not have a query, then the extension is
            // that of the URL itself. If the URL itself doesnt have an extension, we pass out
            // "htm" so that the default IE icon will be used. A special case exists for "asp" --
            // "htm" will also be passed out in this case because that is what IE does.
            // 
            //

            pszT1 = strrchr( UrlComponents.lpszUrlPath, '/' );
            pszT2 = strrchr( UrlComponents.lpszUrlPath, '\\' );

            pszT = max( pszT1, pszT2 );

            if( NULL == pszT )
            {
                pszT = UrlComponents.lpszUrlPath;
            }
            else
            {
                pszT++;
            }

            pszT2 = strchr( pszT, '?' );

            if( NULL != pszT2 )
            {
                ch = *pszT2;

                *pszT2 = '\0';
            }

            pszT = strrchr( pszT, '.' );

            if( NULL != pszT2 )
            {
                *pszT2 = ch;
            }

            if( NULL != pszT )
            {
                pszT++;

                dwLen = strlen( pszT );

                ch = *( pszT + dwLen - 1 );

                if( '/' == ch || '\\' == ch )
                {
                    *( pszT + dwLen - 1 ) = '\0';
                }

                //
                // Dont include non-alphanumeric characters.
                //

                pszT1 = pszT;

                while( '\0' != *pszT1 && isalnum( *pszT1 ) )
                {
                    pszT1++;
                }

                if( pszT1 == pszT )
                {
                    strcpy( pszExtension, "htm" );
                }
                else
                {
                    *pszT1 = '\0';

                    if( !_stricmp( pszT, "asp" ) )
                    {
                        strcpy( pszExtension, "htm" );
                    }
                    else
                    {
                        strcpy( pszExtension, pszT );
                    }
                }
            }
            else
            {
                strcpy( pszExtension, "htm" );
            }
        }
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\apelutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Utilities for clients of the AxA engine.

*******************************************************************************/


#ifndef _APELUTIL_H
#define _APELUTIL_H

#include "ocidl.h"

class AXAMsgFilter
{
  public:
    AXAMsgFilter();
    AXAMsgFilter(IDA3View * v, HWND hwnd);
    AXAMsgFilter(IDA3View * v, IOleInPlaceSiteWindowless * site);
    ~AXAMsgFilter();

    bool Filter(double when,
                UINT msg,
                WPARAM wParam,
                LPARAM lParam);

    bool Filter(DWORD dwMsgtime,
                UINT msg,
                WPARAM wParam,
                LPARAM lParam);

    double GetCurTime();
    double ConvertMsgTime(DWORD dwMsgtime);
    
    // Set the AxA view origin relative to its container.  Do this
    // because the AxA engine always interprets mouse position as
    // relative to the AxA view's upper-left-hand corner (which it
    // interprets as (0,0)). The problem is that the window system
    // gives us mouse positions relative to the container.  Setting
    // the view origin here allows our message filter to compensate
    // for this and pass down positions relative to the view to the
    // AxA engine.  If this is not called, this defaults to (0,0).
    void SetViewOrigin(unsigned short left, unsigned short top);

    IDA3View * GetView() { return _view; }
    void SetView(IDA3View * v) { _view = v; }

    HWND GetWindow() { return _hwnd; }
    void SetWindow(HWND hwnd) { _hwnd = hwnd; }

    IOleInPlaceSiteWindowless * GetSite() { return _site; }
    void SetSite(IOleInPlaceSiteWindowless * s) {
        if (_site) _site->Release();
        _site = s;
        if (_site) _site->AddRef();
    }
  protected:
    IDA3View * _view;
    HWND _hwnd;
    IOleInPlaceSiteWindowless * _site;
    BYTE _lastKeyMod;
    DWORD _lastKey;
    double _curtime;
    DWORD _lasttick;
    unsigned short _left;
    unsigned short _top;

    void ReportKeyup(double when, BOOL bReset = TRUE);
};


#endif /* _APELUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\urlcache\url.h ===
#ifndef __URL_H__
#define __URL_H__

#include "wininet.h"
#include "urlmon.h"

typedef WCHAR *PWSZ;
typedef DWORD FLAG;

typedef DWORD       DWORD_ALPHA_CAST;   

HRESULT
AddFileToCache(
    IN  PWSZ        pwszFilePath,
    IN  PWSZ        pwszUrl,
    IN  PWSZ        pwszOriginalUrl,
    IN  DWORD       dwFileSize,
    IN  LPFILETIME  pLastModifiedTime,
    IN  DWORD       dwCacheEntryType );

HRESULT
QueryCreateCacheEntry(
    IN  PSZ         pszUrl,
    IN  LPFILETIME  pLastModifiedTime,
    OUT FLAG        *pfCreateCacheEntry );

HRESULT
GetUrlExtension(
    IN  PSZ     pszUrl,
    OUT PSZ     pszExtension );

#endif // __URL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\axadefs.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _AXADEFS_H
#define _AXADEFS_H

#define AXA_MOUSE_BUTTON_LEFT    0
#define AXA_MOUSE_BUTTON_RIGHT   1
#define AXA_MOUSE_BUTTON_MIDDLE  2

#define AXA_STATE_DOWN       TRUE
#define AXA_STATE_UP         FALSE

#define AXAEMOD_SHIFT_MASK   0x01
#define AXAEMOD_CTRL_MASK    0x02
#define AXAEMOD_ALT_MASK     0x04
#define AXAEMOD_MENU_MASK    0x04
#define AXAEMOD_META_MASK    0x08

#define AXAEMOD_NONE         0x00
#define AXAEMOD_ALL          0xff

//
// Define the special keys
//

// For now these will be greater than any 16 bit value so that
// all chars can be stored in a single DWORD

// Base the numbers off of win32 vk's since it makes it simpler for
// win32 clients to convert the keys

#define VK_TO_AXAKEY(vk)     ((vk) + 0x00010000)
#define AXAKEY_TO_VK(k)      ((k)  - 0x00010000)

#define AXAKEY_PGUP          VK_TO_AXAKEY(VK_PRIOR)
#define AXAKEY_PGDN          VK_TO_AXAKEY(VK_NEXT)
#define AXAKEY_END           VK_TO_AXAKEY(VK_END)
#define AXAKEY_HOME          VK_TO_AXAKEY(VK_HOME)
#define AXAKEY_LEFT          VK_TO_AXAKEY(VK_LEFT)
#define AXAKEY_UP            VK_TO_AXAKEY(VK_UP)
#define AXAKEY_RIGHT         VK_TO_AXAKEY(VK_RIGHT)
#define AXAKEY_DOWN          VK_TO_AXAKEY(VK_DOWN)

#define AXAKEY_INSERT        VK_TO_AXAKEY(VK_INSERT)
#define AXAKEY_DELETE        VK_TO_AXAKEY(VK_DELETE)

#define AXAKEY_NUMPAD0       VK_TO_AXAKEY(VK_NUMPAD0)
#define AXAKEY_NUMPAD1       VK_TO_AXAKEY(VK_NUMPAD1)
#define AXAKEY_NUMPAD2       VK_TO_AXAKEY(VK_NUMPAD2)
#define AXAKEY_NUMPAD3       VK_TO_AXAKEY(VK_NUMPAD3)
#define AXAKEY_NUMPAD4       VK_TO_AXAKEY(VK_NUMPAD4)
#define AXAKEY_NUMPAD5       VK_TO_AXAKEY(VK_NUMPAD5)
#define AXAKEY_NUMPAD6       VK_TO_AXAKEY(VK_NUMPAD6)
#define AXAKEY_NUMPAD7       VK_TO_AXAKEY(VK_NUMPAD7)
#define AXAKEY_NUMPAD8       VK_TO_AXAKEY(VK_NUMPAD8)
#define AXAKEY_NUMPAD9       VK_TO_AXAKEY(VK_NUMPAD9)
#define AXAKEY_MULTIPLY      VK_TO_AXAKEY(VK_MULTIPLY)
#define AXAKEY_ADD           VK_TO_AXAKEY(VK_ADD)
#define AXAKEY_SEPARATOR     VK_TO_AXAKEY(VK_SEPARATOR)
#define AXAKEY_SUBTRACT      VK_TO_AXAKEY(VK_SUBTRACT)
#define AXAKEY_DECIMAL       VK_TO_AXAKEY(VK_DECIMAL)
#define AXAKEY_DIVIDE        VK_TO_AXAKEY(VK_DIVIDE)

#define AXAKEY_F1            VK_TO_AXAKEY(VK_F1)
#define AXAKEY_F2            VK_TO_AXAKEY(VK_F2)
#define AXAKEY_F3            VK_TO_AXAKEY(VK_F3)
#define AXAKEY_F4            VK_TO_AXAKEY(VK_F4)
#define AXAKEY_F5            VK_TO_AXAKEY(VK_F5)
#define AXAKEY_F6            VK_TO_AXAKEY(VK_F6)
#define AXAKEY_F7            VK_TO_AXAKEY(VK_F7)
#define AXAKEY_F8            VK_TO_AXAKEY(VK_F8)
#define AXAKEY_F9            VK_TO_AXAKEY(VK_F9)
#define AXAKEY_F10           VK_TO_AXAKEY(VK_F10)
#define AXAKEY_F11           VK_TO_AXAKEY(VK_F11)
#define AXAKEY_F12           VK_TO_AXAKEY(VK_F12)
#define AXAKEY_F13           VK_TO_AXAKEY(VK_F13)
#define AXAKEY_F14           VK_TO_AXAKEY(VK_F14)
#define AXAKEY_F15           VK_TO_AXAKEY(VK_F15)
#define AXAKEY_F16           VK_TO_AXAKEY(VK_F16)
#define AXAKEY_F17           VK_TO_AXAKEY(VK_F17)
#define AXAKEY_F18           VK_TO_AXAKEY(VK_F18)
#define AXAKEY_F19           VK_TO_AXAKEY(VK_F19)
#define AXAKEY_F20           VK_TO_AXAKEY(VK_F20)
#define AXAKEY_F21           VK_TO_AXAKEY(VK_F21)
#define AXAKEY_F22           VK_TO_AXAKEY(VK_F22)
#define AXAKEY_F23           VK_TO_AXAKEY(VK_F23)
#define AXAKEY_F24           VK_TO_AXAKEY(VK_F24)

inline BOOL AXAIsSpecialVK(UINT_PTR vk) {
    return ((vk >= VK_PRIOR && vk <= VK_DOWN) ||
            (vk >= VK_INSERT && vk <= VK_DELETE) ||
            (vk >= VK_NUMPAD0 && vk <= VK_DIVIDE) ||
            (vk >= VK_F1 && vk <= VK_F24)) ;
}

#endif /* _AXADEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\avengine.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _RBML_H
#define _RBML_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

#include <windows.h>

#define WM_AXA_REDRAW  (WM_USER+0x200)

extern BOOL StartEngine (int argc, char **argv, char **env) ;

#endif /* _RBML_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\filters\urlcache\urlcache.cpp ===
#include <streams.h>
#include "url.h"

static const GUID CLSID_UrlStreamRenderer = { /* bf0b4b00-8c6c-11d1-ade9-0000f8754b99 */
    0xbf0b4b00,
    0x8c6c,
    0x11d1,
    {0xad, 0xe9, 0x00, 0x00, 0xf8, 0x75, 0x4b, 0x99}
  };



AMOVIESETUP_MEDIATYPE sudURLSPinTypes[] =   {
  &MEDIATYPE_URL_STREAM,        // clsMajorType
  &MEDIATYPE_URL_STREAM };      // clsMinorType

AMOVIESETUP_PIN sudURLSPins[] =
{
  { L"Input"                    // strName
    , TRUE                      // bRendered
    , FALSE                     // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , 0                         // strConnectsToPin
    , NUMELMS(sudURLSPinTypes)  // nTypes
    , sudURLSPinTypes           // lpTypes
  }
};


const AMOVIESETUP_FILTER sudURLS =
{
  &CLSID_UrlStreamRenderer      // clsID
  , L"URL StreamRenderer"       // strName
  , MERIT_NORMAL                // dwMerit
  , NUMELMS(sudURLSPins)        // nPins
  , sudURLSPins                 // lpPin
};

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}


class CUrlInPin : public CBaseInputPin
{
public:
    CUrlInPin(
        CBaseFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr
        );

    STDMETHODIMP Receive(IMediaSample *pSample);
    HRESULT CheckMediaType(const CMediaType *) ;
};

CUrlInPin::CUrlInPin(CBaseFilter *pFilter, CCritSec *pLock, HRESULT *phr) :
        CBaseInputPin(NAME("url in pin"), pFilter, pLock, phr, L"In")
{
    if(SUCCEEDED(*phr))
    {
    }
}

HRESULT CUrlInPin::CheckMediaType(const CMediaType *pmt)
{
    if(pmt->majortype == MEDIATYPE_URL_STREAM)
    {
        return S_OK;
    }
    return S_FALSE;
}

HRESULT CUrlInPin::Receive(IMediaSample *ps)
{
    HRESULT hrSignal = S_OK;
    
    HRESULT hr = CBaseInputPin::Receive(ps);
    if(hr == S_OK)
    {
        // determine length of url
        for(LONG ib = 0; ib < m_SampleProps.lActual; ib++)
        {
            if(m_SampleProps.pbBuffer[ib] == 0)
                break;
        }
        if(ib < m_SampleProps.lActual)
        {
            ULONG cbSz = ib + 1; // incl null
            BYTE *pbImage = m_SampleProps.pbBuffer + ib + 1;
            ULONG ibImage = ib + 1; // image starts here
            ULONG cbImage = m_SampleProps.lActual - cbSz;
            
            // don't know the time stamp of the actual ASF/AVI
            // file. so the authoring tool will have to generate a new
            // url each time (hopefully just use a guid).
            FILETIME zft;
            ZeroMemory(&zft, sizeof(&zft));

            FLAG fCreateCacheEntry;
            char *szUrl = (char *)m_SampleProps.pbBuffer;

            hr = QueryCreateCacheEntry(
                szUrl,
                &zft,
                &fCreateCacheEntry);

            if( hr == S_OK && fCreateCacheEntry )
            {
                char szExtension[ INTERNET_MAX_URL_LENGTH + 1 ];
                
                //
                // First, get the filename extension of the URL. We do
                // this so that the URL will show up in the IE cache
                // window with the right icon.
                //
                hr = GetUrlExtension(
                    szUrl,
                    szExtension );
                if(hr == S_OK)
                {
                    char szCacheFilePath [ MAX_PATH + 1 ];

                    BOOL b =  CreateUrlCacheEntryA( 
                        szUrl,
                        cbImage,
                        szExtension,
                        szCacheFilePath,
                        0 );
                    if(b)
                    {
                        HANDLE hFile = CreateFile(
                            szCacheFilePath,
                            GENERIC_WRITE,
                            0,  // share
                            0,  // lpSecurityAttribytes
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            0);
                        if(hFile != INVALID_HANDLE_VALUE)
                        {
                            DWORD cbWritten;
                            
                            b = WriteFile(
                                hFile,
                                pbImage,
                                cbImage,
                                &cbWritten,
                                0); // overlapped

                            EXECUTE_ASSERT(CloseHandle(hFile));
                            
                            if(b)
                            {
                                hFile = INVALID_HANDLE_VALUE;
                                
                                DWORD dwReserved = 0;
                                DWORD dwCacheEntryType = 0; // ???

                                static const char szHeader[] = "HTTP/1.0 200 OK\r\n\r\n";                                
                                b = CommitUrlCacheEntryA(
                                    szUrl, // unique src name
                                    szCacheFilePath, // local copy
                                    zft, // expire time
                                    zft, // last mod time
                                    dwCacheEntryType,
                                    (LPBYTE)szHeader,
                                    strlen( szHeader ),
                                    NULL, // lpszFileExtension, not used
                                    (DWORD_ALPHA_CAST)dwReserved );
                                if(b)
                                {
                                    // success! !!! should we lock the
                                    // file in the cache until the
                                    // graph stops?

                                    
                                }

                                ASSERT(cbWritten == cbImage);
                            } // WriteFile
                        } // CreateFile
                        else
                        {
                            b = FALSE;
                        }

                        if(!b)
                        {
                            // delete on error
                            DeleteUrlCacheEntry( szUrl );
                        }
                        
                    } // CreateUrlCacheEntryA

                    if(!b)
                    {
                        DWORD dw = GetLastError();
                        hr = HRESULT_FROM_WIN32( dw);
                    }                    
                }
            }

            if(FAILED(hr))
            {
                hrSignal = hr;
                hr = S_FALSE;   // stop pushing
            }

        }
        else
        {
            // no null terminator on string
            hrSignal = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            hr = S_FALSE;
        }
        
    } // base class receive

    if(SUCCEEDED(hrSignal))
    {
        return hr;
    }
    else
    {
        m_pFilter->NotifyEvent(EC_STREAM_ERROR_STOPPED, hrSignal, 0);
        return S_FALSE;
    }
}

class CUrlStreamRenderer : public CBaseFilter
{
    CCritSec m_cs;
    CUrlInPin m_inPin;

    int GetPinCount() { return 1; }
    CBasePin *GetPin(int n) { ASSERT(n == 0); return &m_inPin; }
    
    
public:
    CUrlStreamRenderer(LPUNKNOWN punk, HRESULT *phr);
    ~CUrlStreamRenderer() {; }

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

};

CFactoryTemplate g_Templates[]= {
  {L"URL StreamRenderer", &CLSID_UrlStreamRenderer, CUrlStreamRenderer::CreateInstance, NULL, &sudURLS},
};
int g_cTemplates = NUMELMS(g_Templates);

CUnknown *CUrlStreamRenderer::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    if(SUCCEEDED(*phr))
        return new CUrlStreamRenderer(lpunk, phr);
    else
        return 0;
}

#pragma warning(disable:4355)

CUrlStreamRenderer::CUrlStreamRenderer(LPUNKNOWN punk, HRESULT *phr) :
        CBaseFilter(NAME("URL Stream Filter"), punk, &m_cs, CLSID_UrlStreamRenderer),
        m_inPin(this, &m_cs, phr)
{
}

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);


BOOL WINAPI DllMain(  HINSTANCE hinstDLL,  // handle to DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{
    return DllEntryPoint( hinstDLL, fdwReason, lpvReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\daatl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DAATL_H
#define _DAATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_NO_DEBUG_CRT 1

#ifdef _DEBUG
#undef _ASSERTE
#endif

#define _ASSERTE(expr) ((void)0)

#define _ATL_STATIC_REGISTRY 1

#ifdef _DEBUG
inline void _cdecl AtlTrace2(LPCTSTR , ...){}
#define ATLTRACE            1 ? (void)0 : AtlTrace2
#endif

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#include <atlbase.h>

// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DAComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DEVELOPER_DEBUG
    void AddComPtr(void *ptr, const _TCHAR * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DAComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

#if _DEBUG
#include <typeinfo.h>
#endif

// COPIED FROM ATLCOM.H

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
class ModuleReleaser
{
  public:
    ModuleReleaser() {
        _Module.Lock();
    }

    ~ModuleReleaser() {
        _Module.Unlock();
    }
};

template <class Base>
class DAComObject 
    : public ModuleReleaser,
      public Base
{
  public:
    typedef Base _BaseClass;
    DAComObject(void* = NULL)
    {
#if DEVELOPER_DEBUG
#if _DEBUG
        _Module.AddComPtr(this, GetName());
#else
        _Module.AddComPtr(this, NULL);
#endif
#endif
    }
    // Set refcount to 1 to protect destruction
    ~DAComObject()
    {
#if DEVELOPER_DEBUG
        _Module.RemoveComPtr(this);
#endif
        m_dwRef = 1L;
        FinalRelease();
    }
    //If InternalAddRef or InteralRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()
    {
        ULONG l = InternalRelease();
        if (l == 0)
            delete this;
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
    {return _InternalQueryInterface(iid, ppvObject);}
    static HRESULT WINAPI CreateInstance(DAComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI DAComObject<Base>::CreateInstance(DAComObject<Base>** pp)
{
    _ASSERTE(pp != NULL);
    HRESULT hRes = E_OUTOFMEMORY;
    DAComObject<Base>* p = NULL;
    ATLTRY((p = new DAComObject<Base>()));
    if (p != NULL) {
        p->SetVoid(NULL);
        p->InternalFinalConstructAddRef();
        hRes = p->FinalConstruct();
        p->InternalFinalConstructRelease();
        if (hRes != S_OK) {
            delete p;
            p = NULL;
        }
    }
    *pp = p;
    return hRes;
}

#define DA_DECLARE_NOT_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DA_DECLARE_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;

// END OF COPIED CODE
// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

extern bool bFailedLoad;

#endif /* _DAATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\daerror.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 *
 * Contains all the DirectAnimation error codes
 *
 *******************************************************************************/


#ifndef _DAERROR_H
#define _DAERROR_H

#include <winerror.h>

#define FACILITY_DIRECTANIMATION    FACILITY_ITF
#define DAERR_CODE_BEGIN            0x1000

#define DA_MAKE_HRESULT(i)          MAKE_HRESULT(SEVERITY_ERROR,            \
                                                 FACILITY_DIRECTANIMATION,  \
                                                 (DAERR_CODE_BEGIN + i))


// BEGIN - View specific error codes.
#define DAERR_VIEW_LOCKED               DA_MAKE_HRESULT(10)
#define DAERR_VIEW_TARGET_NOT_SET       DA_MAKE_HRESULT(11)
#define DAERR_VIEW_SURFACE_BUSY         DA_MAKE_HRESULT(12)
// End   - View specific error codes.

    
// BEGIN - DXTransform specific error codes.
#define DAERR_DXTRANSFORM_UNSUPPORTED_OPERATION               DA_MAKE_HRESULT(20)
// End   - DXTransform specific error codes.

    
#endif /* _DAERROR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\dacomutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DACOMUTIL_H
#define _DACOMUTIL_H

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}

template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

#endif /* _DACOMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\guids.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Appelles guids

--*/

#ifndef __GUIDS_H
#define __GUIDS_H

#endif  // __GUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\dartapi.h ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/


#ifndef _DARTAPI_H
#define _DARTAPI_H

class CRBvr;
typedef CRBvr * CRBvrPtr;
class CRBoolean;
typedef CRBoolean * CRBooleanPtr;
class CRCamera;
typedef CRCamera * CRCameraPtr;
class CRColor;
typedef CRColor * CRColorPtr;
class CRGeometry;
typedef CRGeometry * CRGeometryPtr;
class CRImage;
typedef CRImage * CRImagePtr;
class CRMatte;
typedef CRMatte * CRMattePtr;
class CRMicrophone;
typedef CRMicrophone * CRMicrophonePtr;
class CRMontage;
typedef CRMontage * CRMontagePtr;
class CRNumber;
typedef CRNumber * CRNumberPtr;
class CRPath2;
typedef CRPath2 * CRPath2Ptr;
class CRPoint2;
typedef CRPoint2 * CRPoint2Ptr;
class CRPoint3;
typedef CRPoint3 * CRPoint3Ptr;
class CRSound;
typedef CRSound * CRSoundPtr;
class CRString;
typedef CRString * CRStringPtr;
class CRTransform2;
typedef CRTransform2 * CRTransform2Ptr;
class CRTransform3;
typedef CRTransform3 * CRTransform3Ptr;
class CRVector2;
typedef CRVector2 * CRVector2Ptr;
class CRVector3;
typedef CRVector3 * CRVector3Ptr;
class CRFontStyle;
typedef CRFontStyle * CRFontStylePtr;
class CRLineStyle;
typedef CRLineStyle * CRLineStylePtr;
class CREndStyle;
typedef CREndStyle * CREndStylePtr;
class CRJoinStyle;
typedef CRJoinStyle * CRJoinStylePtr;
class CRDashStyle;
typedef CRDashStyle * CRDashStylePtr;
class CRBbox2;
typedef CRBbox2 * CRBbox2Ptr;
class CRBbox3;
typedef CRBbox3 * CRBbox3Ptr;
class CRPair;
typedef CRPair * CRPairPtr;
class CREvent;
typedef CREvent * CREventPtr;
class CRArray;
typedef CRArray * CRArrayPtr;
class CRTuple;
typedef CRTuple * CRTuplePtr;
class CRUserData;
typedef CRUserData * CRUserDataPtr;


enum CR_BVR_TYPEID {
    CRINVALID_TYPEID = -1,
    CRUNKNOWN_TYPEID = 0,
    CRBOOLEAN_TYPEID = 1,
    CRCAMERA_TYPEID = 2,
    CRCOLOR_TYPEID = 3,
    CRGEOMETRY_TYPEID = 4,
    CRIMAGE_TYPEID = 5,
    CRMATTE_TYPEID = 6,
    CRMICROPHONE_TYPEID = 7,
    CRMONTAGE_TYPEID = 8,
    CRNUMBER_TYPEID = 9,
    CRPATH2_TYPEID = 10,
    CRPOINT2_TYPEID = 11,
    CRPOINT3_TYPEID = 12,
    CRSOUND_TYPEID = 13,
    CRSTRING_TYPEID = 14,
    CRTRANSFORM2_TYPEID = 15,
    CRTRANSFORM3_TYPEID = 16,
    CRVECTOR2_TYPEID = 17,
    CRVECTOR3_TYPEID = 18,
    CRFONTSTYLE_TYPEID = 19,
    CRLINESTYLE_TYPEID = 20,
    CRENDSTYLE_TYPEID = 21,
    CRJOINSTYLE_TYPEID = 22,
    CRDASHSTYLE_TYPEID = 23,
    CRBBOX2_TYPEID = 24,
    CRBBOX3_TYPEID = 25,
    CRPAIR_TYPEID = 26,
    CREVENT_TYPEID = 27,
    CRARRAY_TYPEID = 28,
    CRTUPLE_TYPEID = 29,
    CRUSERDATA_TYPEID = 30,
};


#ifndef CRSTDAPI

#ifndef _DART_

#define CRSTDAPI            __declspec( dllimport ) HRESULT STDAPICALLTYPE
#define CRSTDAPI_(type)     __declspec( dllimport ) type STDAPICALLTYPE

#define CRSTDAPICB          HRESULT STDAPICALLTYPE
#define CRSTDAPICB_(type)   type STDAPICALLTYPE

#else // _DART_

#define CRSTDAPI            __declspec( dllexport ) HRESULT STDAPICALLTYPE
#define CRSTDAPI_(type)     __declspec( dllexport ) type STDAPICALLTYPE

#define CRSTDAPICB          HRESULT STDAPICALLTYPE
#define CRSTDAPICB_(type)   type STDAPICALLTYPE

#endif // _DART_

#endif

// Base types

class CRBaseCB
{
  public:
    virtual CRSTDAPICB_(ULONG) AddRef() = 0;
    virtual CRSTDAPICB_(ULONG) Release() = 0;
};

typedef CRBaseCB * CRBaseCBPtr;

class CRView;
typedef CRView * CRViewPtr;

class CRViewSite : public CRBaseCB
{
  public:
    virtual CRSTDAPICB_(void) SetStatusText(LPCWSTR StatusText) = 0;
};

typedef CRViewSite * CRViewSitePtr;

// Callbacks

class CRUntilNotifier : public CRBaseCB
{
  public:
    virtual CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                         CRBvrPtr curRunningBvr,
                                         CRViewPtr curView) = 0;
};

typedef CRUntilNotifier * CRUntilNotifierPtr;

class CRBvrHook : public CRBaseCB
{
  public:
    virtual CRSTDAPICB_(CRBvrPtr) Notify(long id,
                                         bool startingPerformance,
                                         double startTime,
                                         double gTime,
                                         double lTime,
                                         CRBvrPtr sampleVal,
                                         CRBvrPtr curRunningBvr) = 0;
};

typedef CRBvrHook * CRBvrHookPtr;

class CRSite : public CRBaseCB
{
  public:
    virtual CRSTDAPICB_(void) SetStatusText(LPCWSTR StatusText) = 0;
    virtual CRSTDAPICB_(void) ReportError(HRESULT hr, LPCWSTR ErrorText) = 0;
    virtual CRSTDAPICB_(void) ReportGC(bool bStarting) = 0;
};

typedef CRSite * CRSitePtr;

class CRImportSite : public CRBaseCB
{
  public:
    virtual CRSTDAPICB_(void) SetStatusText(DWORD importId, LPCWSTR StatusText) = 0;
    virtual CRSTDAPICB_(void) ReportError(DWORD importId, HRESULT hr, LPCWSTR ErrorText) = 0;

    virtual CRSTDAPICB_(void) OnImportStart(DWORD importId) = 0;
    virtual CRSTDAPICB_(void) OnImportStop(DWORD importId) = 0;
    virtual CRSTDAPICB_(void) OnImportCreate(DWORD importId, bool async) = 0;
};

typedef CRImportSite * CRImportSitePtr;

// Results

class CRPickableResult;
typedef CRPickableResult * CRPickableResultPtr;

class CRImportationResult;
typedef CRImportationResult * CRImportationResultPtr;

class CRDXTransformResult;
typedef CRDXTransformResult * CRDXTransformResultPtr;

class TriMeshData;

CRSTDAPI_(CRNumber *) CRPow(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRAbs(CRNumber * a);
CRSTDAPI_(CRNumber *) CRSqrt(CRNumber * a);
CRSTDAPI_(CRNumber *) CRFloor(CRNumber * a);
CRSTDAPI_(CRNumber *) CRRound(CRNumber * a);
CRSTDAPI_(CRNumber *) CRCeiling(CRNumber * a);
CRSTDAPI_(CRNumber *) CRAsin(CRNumber * a);
CRSTDAPI_(CRNumber *) CRAcos(CRNumber * a);
CRSTDAPI_(CRNumber *) CRAtan(CRNumber * a);
CRSTDAPI_(CRNumber *) CRSin(CRNumber * a);
CRSTDAPI_(CRNumber *) CRCos(CRNumber * a);
CRSTDAPI_(CRNumber *) CRTan(CRNumber * a);
CRSTDAPI_(CRNumber *) CRExp(CRNumber * a);
CRSTDAPI_(CRNumber *) CRLn(CRNumber * a);
CRSTDAPI_(CRNumber *) CRLog10(CRNumber * a);
CRSTDAPI_(CRNumber *) CRToDegrees(CRNumber * a);
CRSTDAPI_(CRNumber *) CRToRadians(CRNumber * a);
CRSTDAPI_(CRNumber *) CRMod(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRAtan2(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBvr *) CRFirst(CRPair * p);
CRSTDAPI_(CRBvr *) CRSecond(CRPair * p);
CRSTDAPI_(CRNumber *) CRAdd(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRSub(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRMul(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRDiv(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CRLT(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CRLTE(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CRGT(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CRGTE(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CREQ(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CRNE(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRNeg(CRNumber * a);
CRSTDAPI_(CRNumber *) CRInterpolate(CRNumber * from, CRNumber * to, CRNumber * duration);
CRSTDAPI_(CRNumber *) CRInterpolate(double from, double to, double duration);
CRSTDAPI_(CRNumber *) CRSlowInSlowOut(CRNumber * from, CRNumber * to, CRNumber * duration, CRNumber * sharpness);
CRSTDAPI_(CRNumber *) CRSlowInSlowOut(double from, double to, double duration, double sharpness);
CRSTDAPI_(CRSound *) CRRenderSound(CRGeometry * geom, CRMicrophone * mic);
CRSTDAPI_(CRGeometry *) CRSoundSource(CRSound * snd);
CRSTDAPI_(CRSound *) CRMix(CRSound * left, CRSound * right);
CRSTDAPI_(CRBoolean *) CRAnd(CRBoolean * a, CRBoolean * b);
CRSTDAPI_(CRBoolean *) CROr(CRBoolean * a, CRBoolean * b);
CRSTDAPI_(CRBoolean *) CRNot(CRBoolean * a);
CRSTDAPI_(CRNumber *) CRIntegral(CRNumber * b);
CRSTDAPI_(CRNumber *) CRDerivative(CRNumber * b);
CRSTDAPI_(CRVector2 *) CRIntegral(CRVector2 * v);
CRSTDAPI_(CRVector3 *) CRIntegral(CRVector3 * v);
CRSTDAPI_(CRVector2 *) CRDerivative(CRVector2 * v);
CRSTDAPI_(CRVector3 *) CRDerivative(CRVector3 * v);
CRSTDAPI_(CRVector2 *) CRDerivative(CRPoint2 * v);
CRSTDAPI_(CRVector3 *) CRDerivative(CRPoint3 * v);
CRSTDAPI_(CRBoolean *) CRKeyState(CRNumber * n);
CRSTDAPI_(CREvent *) CRKeyUp(LONG arg0);
CRSTDAPI_(CREvent *) CRKeyDown(LONG arg0);
CRSTDAPI_(CRNumber *) CRCreateNumber(double num);
CRSTDAPI_(CRString *) CRCreateString(LPWSTR str);
CRSTDAPI_(CRBoolean *) CRCreateBoolean(bool num);
CRSTDAPI_(double) CRExtract(CRNumber * num);
CRSTDAPI_(CRNumber *) CRSeededRandom(double arg0);
CRSTDAPI_(LPWSTR) CRExtract(CRString * str);
CRSTDAPI_(bool) CRExtract(CRBoolean * b);
CRSTDAPI_(CRBvr *) CRNth(CRArray * arr, CRNumber * index);
CRSTDAPI_(CRNumber *) CRLength(CRArray * arr);
CRSTDAPI_(CRBvr *) CRNth(CRTuple * t, long index);
CRSTDAPI_(long) CRLength(CRTuple * t);
CRSTDAPI_(CRPoint2 *) CRMousePosition();
CRSTDAPI_(CRBoolean *) CRLeftButtonState();
CRSTDAPI_(CRBoolean *) CRRightButtonState();
CRSTDAPI_(CRBoolean *) CRTrue();
CRSTDAPI_(CRBoolean *) CRFalse();
CRSTDAPI_(CRNumber *) CRLocalTime();
CRSTDAPI_(CRNumber *) CRGlobalTime();
CRSTDAPI_(CRNumber *) CRPixel();
CRSTDAPI_(CRUserData *) CRCreateUserData(IUnknown * data);
CRSTDAPI_(IUnknown *) CRGetData(CRUserData * data);
CRSTDAPI_(CRBvr *) CRUntilNotify(CRBvr * b0, CREvent * event, CRUntilNotifier * notifier);
CRSTDAPI_(CRBvr *) CRUntil(CRBvr * b0, CREvent * event, CRBvr * b1);
CRSTDAPI_(CRBvr *) CRUntilEx(CRBvr * b0, CREvent * event);
CRSTDAPI_(CRBvr *) CRSequence(CRBvr * s1, CRBvr * s2);
CRSTDAPI_(CRBvr *) CRSequenceArray(long s, CRBvrPtr pBvrs[]);
CRSTDAPI_(CRPickableResult *) CRPickable(CRImage * img);
CRSTDAPI_(CRPickableResult *) CRPickable(CRGeometry * geom);
CRSTDAPI_(CRPickableResult *) CRPickableOccluded(CRImage * img);
CRSTDAPI_(CRPickableResult *) CRPickableOccluded(CRGeometry * geom);
CRSTDAPI_(CRTransform2 *) CRFollowPath(CRPath2 * path, double duration);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngle(CRPath2 * path, double duration);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUpright(CRPath2 * path, double duration);
CRSTDAPI_(CRTransform2 *) CRFollowPathEval(CRPath2 * path, CRNumber * eval);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleEval(CRPath2 * path, CRNumber * eval);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUprightEval(CRPath2 * path, CRNumber * eval);
CRSTDAPI_(CRTransform2 *) CRFollowPath(CRPath2 * obsoleted1, CRNumber * obsoleted2);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngle(CRPath2 * obsoleted1, CRNumber * obsoleted2);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUpright(CRPath2 * obsoleted1, CRNumber * obsoleted2);
CRSTDAPI_(CRImage *) CRAddPickData(CRImage * img, IUnknown * id, bool ignoresOcclusion);
CRSTDAPI_(CRGeometry *) CRAddPickData(CRGeometry * geo, IUnknown * id, bool ignoresOcclusion);
CRSTDAPI_(long) CRAddElement(CRArray * arr, CRBvr * b, DWORD flag);
CRSTDAPI_(bool) CRRemoveElement(CRArray * arr, long i);
CRSTDAPI_(bool) CRSetElement(CRArray * arr, long i, CRBvr * b, long flag);
CRSTDAPI_(CRBvr *) CRGetElement(CRArray * arr, long i);
CRSTDAPI_(CRString *) CRConcatString(CRString * s1, CRString * s2);
CRSTDAPI_(CRPoint2 *) CRMin(CRBbox2 * box);
CRSTDAPI_(CRPoint2 *) CRMax(CRBbox2 * box);
CRSTDAPI_(CRPoint3 *) CRMin(CRBbox3 * box);
CRSTDAPI_(CRPoint3 *) CRMax(CRBbox3 * box);
CRSTDAPI_(CRCamera *) CRPerspectiveCamera(double focalDist, double nearClip);
CRSTDAPI_(CRCamera *) CRPerspectiveCameraAnim(CRNumber * focalDist, CRNumber * nearClip);
CRSTDAPI_(CRCamera *) CRParallelCamera(double nearClip);
CRSTDAPI_(CRCamera *) CRParallelCameraAnim(CRNumber * nearClip);
CRSTDAPI_(CRCamera *) CRTransform(CRCamera * cam, CRTransform3 * xf);
CRSTDAPI_(CRCamera *) CRDepth(CRCamera * cam, double depth);
CRSTDAPI_(CRCamera *) CRDepth(CRCamera * cam, CRNumber * depth);
CRSTDAPI_(CRCamera *) CRDepthResolution(CRCamera * cam, double resolution);
CRSTDAPI_(CRCamera *) CRDepthResolution(CRCamera * cam, CRNumber * resolution);
CRSTDAPI_(CRPoint2 *) CRProject(CRPoint3 * pt, CRCamera * cam);
CRSTDAPI_(CRColor *) CRColorRgb(CRNumber * red, CRNumber * green, CRNumber * blue);
CRSTDAPI_(CRColor *) CRColorRgb(double red, double green, double blue);
CRSTDAPI_(CRColor *) CRColorRgb255(short red, short green, short blue);
CRSTDAPI_(CRColor *) CRColorHsl(double hue, double saturation, double lum);
CRSTDAPI_(CRColor *) CRColorHsl(CRNumber * hue, CRNumber * saturation, CRNumber * lum);
CRSTDAPI_(CRNumber *) CRGetRed(CRColor * color);
CRSTDAPI_(CRNumber *) CRGetGreen(CRColor * color);
CRSTDAPI_(CRNumber *) CRGetBlue(CRColor * color);
CRSTDAPI_(CRNumber *) CRGetHue(CRColor * color);
CRSTDAPI_(CRNumber *) CRGetSaturation(CRColor * color);
CRSTDAPI_(CRNumber *) CRGetLightness(CRColor * color);
CRSTDAPI_(CRColor *) CRRed();
CRSTDAPI_(CRColor *) CRGreen();
CRSTDAPI_(CRColor *) CRBlue();
CRSTDAPI_(CRColor *) CRCyan();
CRSTDAPI_(CRColor *) CRMagenta();
CRSTDAPI_(CRColor *) CRYellow();
CRSTDAPI_(CRColor *) CRBlack();
CRSTDAPI_(CRColor *) CRWhite();
CRSTDAPI_(CRColor *) CRAqua();
CRSTDAPI_(CRColor *) CRFuchsia();
CRSTDAPI_(CRColor *) CRGray();
CRSTDAPI_(CRColor *) CRLime();
CRSTDAPI_(CRColor *) CRMaroon();
CRSTDAPI_(CRColor *) CRNavy();
CRSTDAPI_(CRColor *) CROlive();
CRSTDAPI_(CRColor *) CRPurple();
CRSTDAPI_(CRColor *) CRSilver();
CRSTDAPI_(CRColor *) CRTeal();
CRSTDAPI_(CREvent *) CRPredicate(CRBoolean * b);
CRSTDAPI_(CREvent *) CRNotEvent(CREvent * event);
CRSTDAPI_(CREvent *) CRAndEvent(CREvent * e1, CREvent * e2);
CRSTDAPI_(CREvent *) CROrEvent(CREvent * e1, CREvent * e2);
CRSTDAPI_(CREvent *) CRThenEvent(CREvent * e1, CREvent * e2);
CRSTDAPI_(CREvent *) CRLeftButtonDown();
CRSTDAPI_(CREvent *) CRLeftButtonUp();
CRSTDAPI_(CREvent *) CRRightButtonDown();
CRSTDAPI_(CREvent *) CRRightButtonUp();
CRSTDAPI_(CREvent *) CRAlways();
CRSTDAPI_(CREvent *) CRNever();
CRSTDAPI_(CREvent *) CRTimer(CRNumber * n);
CRSTDAPI_(CREvent *) CRTimer(double n);
CRSTDAPI_(CREvent *) CRNotify(CREvent * event, CRUntilNotifier * notifier);
CRSTDAPI_(CREvent *) CRSnapshot(CREvent * event, CRBvr * b);
CRSTDAPI_(CREvent *) CRAppTriggeredEvent();
CRSTDAPI_(CREvent *) CRAttachData(CREvent * event, CRBvr * data);
CRSTDAPI_(CRGeometry *) CRUndetectable(CRGeometry * geo);
CRSTDAPI_(CRGeometry *) CREmissiveColor(CRGeometry * geo, CRColor * col);
CRSTDAPI_(CRGeometry *) CRDiffuseColor(CRGeometry * geo, CRColor * col);
CRSTDAPI_(CRGeometry *) CRSpecularColor(CRGeometry * geo, CRColor * col);
CRSTDAPI_(CRGeometry *) CRSpecularExponent(CRGeometry * geo, double power);
CRSTDAPI_(CRGeometry *) CRSpecularExponentAnim(CRGeometry * geo, CRNumber * power);
CRSTDAPI_(CRGeometry *) CRTexture(CRGeometry * geo, CRImage * texture);
CRSTDAPI_(CRGeometry *) CROpacity(CRGeometry * geom, double level);
CRSTDAPI_(CRGeometry *) CROpacity(CRGeometry * geom, CRNumber * level);
CRSTDAPI_(CRGeometry *) CRTransform(CRGeometry * geo, CRTransform3 * xf);
CRSTDAPI_(CRGeometry *) CRShadow(CRGeometry * geoToShadow, CRGeometry * geoContainingLights, CRPoint3 * planePoint, CRVector3 * planeNormal);
CRSTDAPI_(CRGeometry *) CREmptyGeometry();
CRSTDAPI_(CRGeometry *) CRUnionGeometry(CRGeometry * g1, CRGeometry * g2);
CRSTDAPI_(CRGeometry *) CRUnionGeometry(CRArrayPtr imgs);
CRSTDAPI_(CRBbox3 *) CRBoundingBox(CRGeometry * geo);
CRSTDAPI_(CRImage *) CREmptyImage();
CRSTDAPI_(CRImage *) CRDetectableEmptyImage();
CRSTDAPI_(CRImage *) CRRender(CRGeometry * geo, CRCamera * cam);
CRSTDAPI_(CRImage *) CRSolidColorImage(CRColor * col);
CRSTDAPI_(CRImage *) CRGradientPolygon(CRArrayPtr points, CRArrayPtr colors);
CRSTDAPI_(CRImage *) CRRadialGradientPolygon(CRColor * inner, CRColor * outer, CRArrayPtr points, double fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientPolygon(CRColor * inner, CRColor * outer, CRArrayPtr points, CRNumber * fallOff);
CRSTDAPI_(CRImage *) CRGradientSquare(CRColor * lowerLeft, CRColor * upperLeft, CRColor * upperRight, CRColor * lowerRight);
CRSTDAPI_(CRImage *) CRRadialGradientSquare(CRColor * inner, CRColor * outer, double fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientSquare(CRColor * inner, CRColor * outer, CRNumber * fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientRegularPoly(CRColor * inner, CRColor * outer, double numEdges, double fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientRegularPoly(CRColor * inner, CRColor * outer, CRNumber * numEdges, CRNumber * fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientMulticolor(CRArrayPtr offsets, CRArrayPtr colors);
CRSTDAPI_(CRImage *) CRLinearGradientMulticolor(CRArrayPtr offsets, CRArrayPtr colors);
CRSTDAPI_(CRImage *) CRGradientHorizontal(CRColor * start, CRColor * stop, double fallOff);
CRSTDAPI_(CRImage *) CRGradientHorizontal(CRColor * start, CRColor * stop, CRNumber * fallOff);
CRSTDAPI_(CRImage *) CRHatchHorizontal(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchHorizontal(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CRHatchVertical(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchVertical(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CRHatchForwardDiagonal(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchForwardDiagonal(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CRHatchBackwardDiagonal(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchBackwardDiagonal(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CRHatchCross(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchCross(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CRHatchDiagonalCross(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchDiagonalCross(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CROverlay(CRImage * top, CRImage * bottom);
CRSTDAPI_(CRImage *) CROverlay(CRArrayPtr imgs);
CRSTDAPI_(CRBbox2 *) CRBoundingBox(CRImage * image);
CRSTDAPI_(CRImage *) CRCrop(CRImage * image, CRPoint2 * min, CRPoint2 * max);
CRSTDAPI_(CRImage *) CRTransform(CRImage * image, CRTransform2 * xf);
CRSTDAPI_(CRImage *) CROpacity(CRImage * image, CRNumber * opacity);
CRSTDAPI_(CRImage *) CROpacity(CRImage * image, double opacity);
CRSTDAPI_(CRImage *) CRUndetectable(CRImage * image);
CRSTDAPI_(CRImage *) CRTile(CRImage * image);
CRSTDAPI_(CRImage *) CRClip(CRImage * image, CRMatte * m);
CRSTDAPI_(CRImage *) CRMapToUnitSquare(CRImage * image);
CRSTDAPI_(CRImage *) CRClipPolygonImage(CRImage * image, CRArrayPtr points);
CRSTDAPI_(CRImage *) CRRenderResolution(CRImage * img, long width, long height);
CRSTDAPI_(CRImage *) CRImageQuality(CRImage * img, DWORD dwQualityFlags);
CRSTDAPI_(CRImage *) CRColorKey(CRImage * image, CRColor * colorKey);
CRSTDAPI_(CRImage *) CRTransformColorRGB(CRImage * arg0, CRTransform3 * arg1);
CRSTDAPI_(CRGeometry*) CRAmbientLight();
CRSTDAPI_(CRGeometry*) CRDirectionalLight();
CRSTDAPI_(CRGeometry*) CRPointLight();
CRSTDAPI_(CRGeometry*) CRSpotLight(CRNumber * fullcone, CRNumber * cutoff);
CRSTDAPI_(CRGeometry*) CRSpotLight(CRNumber * fullcone, double cutoff);
CRSTDAPI_(CRGeometry*) CRLightColor(CRGeometry * geom, CRColor * color);
CRSTDAPI_(CRGeometry*) CRLightRange(CRGeometry * geom, CRNumber * range);
CRSTDAPI_(CRGeometry*) CRLightRange(CRGeometry * geom, double range);
CRSTDAPI_(CRGeometry*) CRLightAttenuation(CRGeometry * geom, CRNumber * constant, CRNumber * linear, CRNumber * quadratic);
CRSTDAPI_(CRGeometry*) CRLightAttenuation(CRGeometry * geom, double constant, double linear, double quadratic);
CRSTDAPI_(CRGeometry*) CRBlendTextureDiffuse(CRGeometry * geometry, CRBoolean * blended);
CRSTDAPI_(CRGeometry*) CRAmbientColor(CRGeometry * geo, CRColor * color);
CRSTDAPI_(CRGeometry*) CRD3DRMTexture(CRGeometry * geo, IUnknown * rmTex);
CRSTDAPI_(CRGeometry*) CRModelClip(CRGeometry * geo, CRPoint3 * planePt, CRVector3 * planeVec);
CRSTDAPI_(CRGeometry*) CRLighting(CRGeometry * geo, CRBoolean * lighting);
CRSTDAPI_(CRGeometry*) CRTextureImage(CRGeometry * geo, CRImage * texture);
CRSTDAPI_(CRGeometry*) CRBillboard (CRGeometry*, CRVector3*);
CRSTDAPI_(CRGeometry*) CRTriMesh (TriMeshData &tm);
CRSTDAPI_(CRLineStyle *) CRDefaultLineStyle();
CRSTDAPI_(CRLineStyle *) CREmptyLineStyle();
CRSTDAPI_(CRLineStyle *) CREnd(CRLineStyle * lsty, CREndStyle * sty);
CRSTDAPI_(CRLineStyle *) CRJoin(CRLineStyle * lsty, CRJoinStyle * sty);
CRSTDAPI_(CRLineStyle *) CRDash(CRLineStyle * lsty, CRDashStyle * sty);
CRSTDAPI_(CRLineStyle *) CRWidth(CRLineStyle * lsty, CRNumber * sty);
CRSTDAPI_(CRLineStyle *) CRWidth(CRLineStyle * lsty, double sty);
CRSTDAPI_(CRLineStyle *) CRAntiAliasing(CRLineStyle * lsty, double aaStyle);
CRSTDAPI_(CRLineStyle *) CRDetail(CRLineStyle * lsty);
CRSTDAPI_(CRLineStyle *) CRLineColor(CRLineStyle * lsty, CRColor * clr);
CRSTDAPI_(CRJoinStyle *) CRJoinStyleBevel();
CRSTDAPI_(CRJoinStyle *) CRJoinStyleRound();
CRSTDAPI_(CRJoinStyle *) CRJoinStyleMiter();
CRSTDAPI_(CREndStyle *) CREndStyleFlat();
CRSTDAPI_(CREndStyle *) CREndStyleSquare();
CRSTDAPI_(CREndStyle *) CREndStyleRound();
CRSTDAPI_(CRDashStyle *) CRDashStyleSolid();
CRSTDAPI_(CRDashStyle *) CRDashStyleDashed();
CRSTDAPI_(CRLineStyle *) CRDashEx(CRLineStyle * ls, DWORD ds_enum);
CRSTDAPI_(CRLineStyle *) CRMiterLimit(CRLineStyle * ls, double mtrlim);
CRSTDAPI_(CRLineStyle *) CRMiterLimit(CRLineStyle * ls, CRNumber * mtrlim);
CRSTDAPI_(CRLineStyle *) CRJoinEx(CRLineStyle * ls, DWORD js_enum);
CRSTDAPI_(CRLineStyle *) CREndEx(CRLineStyle * ls, DWORD es_enum);
CRSTDAPI_(CRMicrophone *) CRDefaultMicrophone();
CRSTDAPI_(CRMicrophone *) CRTransform(CRMicrophone * mic, CRTransform3 * xf);
CRSTDAPI_(CRMatte *) CROpaqueMatte();
CRSTDAPI_(CRMatte *) CRClearMatte();
CRSTDAPI_(CRMatte *) CRUnionMatte(CRMatte * m1, CRMatte * m2);
CRSTDAPI_(CRMatte *) CRIntersectMatte(CRMatte * m1, CRMatte * m2);
CRSTDAPI_(CRMatte *) CRDifferenceMatte(CRMatte * m1, CRMatte * m2);
CRSTDAPI_(CRMatte *) CRTransform(CRMatte * m, CRTransform2 * xf);
CRSTDAPI_(CRMatte *) CRFillMatte(CRPath2 * p);
CRSTDAPI_(CRMatte *) CRTextMatte(CRString * str, CRFontStyle * fs);
CRSTDAPI_(CRMontage *) CREmptyMontage();
CRSTDAPI_(CRMontage *) CRImageMontage(CRImage * im, double depth);
CRSTDAPI_(CRMontage *) CRImageMontageAnim(CRImage * im, CRNumber * depth);
CRSTDAPI_(CRMontage *) CRUnionMontage(CRMontage * m1, CRMontage * m2);
CRSTDAPI_(CRImage *) CRRender(CRMontage * m);
CRSTDAPI_(CRPath2 *) CRConcat(CRPath2 * p1, CRPath2 * p2);
CRSTDAPI_(CRPath2 *) CRConcat(CRArrayPtr paths);
CRSTDAPI_(CRPath2 *) CRTransform(CRPath2 * p, CRTransform2 * xf);
CRSTDAPI_(CRBbox2 *) CRBoundingBox(CRPath2 * p, CRLineStyle * style);
CRSTDAPI_(CRImage *) CRFill(CRPath2 * p, CRLineStyle * border, CRImage * fill);
CRSTDAPI_(CRImage *) CRDraw(CRPath2 * p, CRLineStyle * border);
CRSTDAPI_(CRPath2 *) CRClose(CRPath2 * p);
CRSTDAPI_(CRPath2 *) CRLine(CRPoint2 * p1, CRPoint2 * p2);
CRSTDAPI_(CRPath2 *) CRRay(CRPoint2 * pt);
CRSTDAPI_(CRPath2 *) CRStringPath(CRString * str, CRFontStyle * fs);
CRSTDAPI_(CRPath2 *) CRStringPath(LPWSTR str, CRFontStyle * fs);
CRSTDAPI_(CRPath2 *) CRPolyline(CRArrayPtr points);
CRSTDAPI_(CRPath2 *) CRPolydrawPath(CRArrayPtr points, CRArrayPtr codes);
CRSTDAPI_(CRPath2 *) CRPolydrawPath(double*, unsigned int, double*, unsigned int);
CRSTDAPI_(CRPath2 *) CRArcRadians(double startAngle, double endAngle, double arcWidth, double arcHeight);
CRSTDAPI_(CRPath2 *) CRArcRadians(CRNumber * startAngle, CRNumber * endAngle, CRNumber * arcWidth, CRNumber * arcHeight);
CRSTDAPI_(CRPath2 *) CRArc(double startAngle, double endAngle, double arcWidth, double arcHeight);
CRSTDAPI_(CRPath2 *) CRPieRadians(double startAngle, double endAngle, double arcWidth, double arcHeight);
CRSTDAPI_(CRPath2 *) CRPieRadians(CRNumber * startAngle, CRNumber * endAngle, CRNumber * arcWidth, CRNumber * arcHeight);
CRSTDAPI_(CRPath2 *) CRPie(double startAngle, double endAngle, double arcWidth, double arcHeight);
CRSTDAPI_(CRPath2 *) CROval(double width, double height);
CRSTDAPI_(CRPath2 *) CROval(CRNumber * width, CRNumber * height);
CRSTDAPI_(CRPath2 *) CRRect(double width, double height);
CRSTDAPI_(CRPath2 *) CRRect(CRNumber * width, CRNumber * height);
CRSTDAPI_(CRPath2 *) CRRoundRect(double width, double height, double cornerArcWidth, double cornerArcHeight);
CRSTDAPI_(CRPath2 *) CRRoundRect(CRNumber * width, CRNumber * height, CRNumber * cornerArcWidth, CRNumber * cornerArcHeight);
CRSTDAPI_(CRPath2 *) CRCubicBSplinePath(CRArrayPtr points, CRArrayPtr knots);
CRSTDAPI_(CRPath2 *) CRTextPath(CRString * obsolete1, CRFontStyle * obsolete2);
CRSTDAPI_(CRSound *) CRSilence();
CRSTDAPI_(CRSound *) CRMix(CRArrayPtr snds);
CRSTDAPI_(CRSound *) CRPhase(CRSound * snd, CRNumber * phaseAmt);
CRSTDAPI_(CRSound *) CRPhase(CRSound * snd, double phaseAmt);
CRSTDAPI_(CRSound *) CRRate(CRSound * snd, CRNumber * pitchShift);
CRSTDAPI_(CRSound *) CRRate(CRSound * snd, double pitchShift);
CRSTDAPI_(CRSound *) CRPan(CRSound * snd, CRNumber * panAmt);
CRSTDAPI_(CRSound *) CRPan(CRSound * snd, double panAmt);
CRSTDAPI_(CRSound *) CRGain(CRSound * snd, CRNumber * gainAmt);
CRSTDAPI_(CRSound *) CRGain(CRSound * snd, double gainAmt);
CRSTDAPI_(CRSound *) CRLoop(CRSound * snd);
CRSTDAPI_(CRSound *) CRSinSynth();
CRSTDAPI_(CRString *) CRToString(CRNumber * num, CRNumber * precision);
CRSTDAPI_(CRString *) CRToString(CRNumber * num, double precision);
CRSTDAPI_(CRFontStyle *) CRDefaultFont();
CRSTDAPI_(CRFontStyle *) CRFont(CRString * str, CRNumber * size, CRColor * col);
CRSTDAPI_(CRFontStyle *) CRFont(LPWSTR str, double size, CRColor * col);
CRSTDAPI_(CRImage *) CRStringImage(CRString * str, CRFontStyle * fs);
CRSTDAPI_(CRImage *) CRStringImage(LPWSTR str, CRFontStyle * fs);
CRSTDAPI_(CRFontStyle *) CRBold(CRFontStyle * fs);
CRSTDAPI_(CRFontStyle *) CRItalic(CRFontStyle * fs);
CRSTDAPI_(CRFontStyle *) CRUnderline(CRFontStyle * fs);
CRSTDAPI_(CRFontStyle *) CRStrikethrough(CRFontStyle * fs);
CRSTDAPI_(CRFontStyle *) CRAntiAliasing(CRFontStyle * fs, double aaStyle);
CRSTDAPI_(CRFontStyle *) CRTextColor(CRFontStyle * fs, CRColor * col);
CRSTDAPI_(CRFontStyle *) CRFamily(CRFontStyle * fs, CRString * face);
CRSTDAPI_(CRFontStyle *) CRFamily(CRFontStyle * fs, LPWSTR face);
CRSTDAPI_(CRFontStyle *) CRSize(CRFontStyle * fs, CRNumber * size);
CRSTDAPI_(CRFontStyle *) CRSize(CRFontStyle * fs, double size);
CRSTDAPI_(CRFontStyle *) CRWeight(CRFontStyle * fs, double weight);
CRSTDAPI_(CRFontStyle *) CRWeight(CRFontStyle * fs, CRNumber * weight);
CRSTDAPI_(CRImage *) CRTextImage(CRString * obsoleted1, CRFontStyle * obsoleted2);
CRSTDAPI_(CRImage *) CRTextImage(LPWSTR obsoleted1, CRFontStyle * obsoleted2);
CRSTDAPI_(CRFontStyle *) CRTransformCharacters(CRFontStyle * style, CRTransform2 * transform);
CRSTDAPI_(CRVector2 *) CRXVector2();
CRSTDAPI_(CRVector2 *) CRYVector2();
CRSTDAPI_(CRVector2 *) CRZeroVector2();
CRSTDAPI_(CRPoint2 *) CROrigin2();
CRSTDAPI_(CRVector2 *) CRCreateVector2(CRNumber * x, CRNumber * y);
CRSTDAPI_(CRVector2 *) CRCreateVector2(double x, double y);
CRSTDAPI_(CRPoint2 *) CRCreatePoint2(CRNumber * x, CRNumber * y);
CRSTDAPI_(CRPoint2 *) CRCreatePoint2(double x, double y);
CRSTDAPI_(CRVector2 *) CRVector2Polar(CRNumber * theta, CRNumber * radius);
CRSTDAPI_(CRVector2 *) CRVector2Polar(double theta, double radius);
CRSTDAPI_(CRPoint2 *) CRPoint2Polar(CRNumber * theta, CRNumber * radius);
CRSTDAPI_(CRPoint2 *) CRPoint2Polar(double theta, double radius);
CRSTDAPI_(CRNumber *) CRLength(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRLengthSquared(CRVector2 * v);
CRSTDAPI_(CRVector2 *) CRNormalize(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRDot(CRVector2 * v, CRVector2 * u);
CRSTDAPI_(CRVector2 *) CRNeg(CRVector2 * v);
CRSTDAPI_(CRVector2 *) CRMul(CRVector2 * v, CRNumber * scalar);
CRSTDAPI_(CRVector2 *) CRMul(CRVector2 * v, double scalar);
CRSTDAPI_(CRVector2 *) CRDiv(CRVector2 * v, CRNumber * scalar);
CRSTDAPI_(CRVector2 *) CRDiv(CRVector2 * v, double scalar);
CRSTDAPI_(CRVector2 *) CRSub(CRVector2 * v1, CRVector2 * v2);
CRSTDAPI_(CRVector2 *) CRAdd(CRVector2 * v1, CRVector2 * v2);
CRSTDAPI_(CRPoint2 *) CRAdd(CRPoint2 * p, CRVector2 * v);
CRSTDAPI_(CRPoint2 *) CRSub(CRPoint2 * p, CRVector2 * v);
CRSTDAPI_(CRVector2 *) CRSub(CRPoint2 * p1, CRPoint2 * p2);
CRSTDAPI_(CRNumber *) CRDistance(CRPoint2 * p, CRPoint2 * q);
CRSTDAPI_(CRNumber *) CRDistanceSquared(CRPoint2 * p, CRPoint2 * q);
CRSTDAPI_(CRNumber *) CRGetX(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRGetY(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRPolarCoordAngle(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRPolarCoordLength(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRGetX(CRPoint2 * v);
CRSTDAPI_(CRNumber *) CRGetY(CRPoint2 * v);
CRSTDAPI_(CRNumber *) CRPolarCoordAngle(CRPoint2 * v);
CRSTDAPI_(CRNumber *) CRPolarCoordLength(CRPoint2 * v);
CRSTDAPI_(CRVector3 *) CRXVector3();
CRSTDAPI_(CRVector3 *) CRYVector3();
CRSTDAPI_(CRVector3 *) CRZVector3();
CRSTDAPI_(CRVector3 *) CRZeroVector3();
CRSTDAPI_(CRPoint3 *) CROrigin3();
CRSTDAPI_(CRVector3 *) CRCreateVector3(CRNumber * x, CRNumber * y, CRNumber * z);
CRSTDAPI_(CRVector3 *) CRCreateVector3(double x, double y, double z);
CRSTDAPI_(CRPoint3 *) CRCreatePoint3(CRNumber * x, CRNumber * y, CRNumber * z);
CRSTDAPI_(CRPoint3 *) CRCreatePoint3(double x, double y, double z);
CRSTDAPI_(CRVector3 *) CRVector3Spherical(CRNumber * xyAngle, CRNumber * yzAngle, CRNumber * radius);
CRSTDAPI_(CRVector3 *) CRVector3Spherical(double xyAngle, double yzAngle, double radius);
CRSTDAPI_(CRPoint3 *) CRPoint3Spherical(CRNumber * zxAngle, CRNumber * xyAngle, CRNumber * radius);
CRSTDAPI_(CRPoint3 *) CRPoint3Spherical(double zxAngle, double xyAngle, double radius);
CRSTDAPI_(CRNumber *) CRLength(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRLengthSquared(CRVector3 * v);
CRSTDAPI_(CRVector3 *) CRNormalize(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRDot(CRVector3 * v, CRVector3 * u);
CRSTDAPI_(CRVector3 *) CRCross(CRVector3 * v, CRVector3 * u);
CRSTDAPI_(CRVector3 *) CRNeg(CRVector3 * v);
CRSTDAPI_(CRVector3 *) CRMul(CRVector3 * v, CRNumber * scalar);
CRSTDAPI_(CRVector3 *) CRMul(CRVector3 * v, double scalar);
CRSTDAPI_(CRVector3 *) CRDiv(CRVector3 * v, CRNumber * scalar);
CRSTDAPI_(CRVector3 *) CRDiv(CRVector3 * v, double scalar);
CRSTDAPI_(CRVector3 *) CRSub(CRVector3 * v1, CRVector3 * v2);
CRSTDAPI_(CRVector3 *) CRAdd(CRVector3 * v1, CRVector3 * v2);
CRSTDAPI_(CRPoint3 *) CRAdd(CRPoint3 * p, CRVector3 * v);
CRSTDAPI_(CRPoint3 *) CRSub(CRPoint3 * p, CRVector3 * v);
CRSTDAPI_(CRVector3 *) CRSub(CRPoint3 * p1, CRPoint3 * p2);
CRSTDAPI_(CRNumber *) CRDistance(CRPoint3 * p, CRPoint3 * q);
CRSTDAPI_(CRNumber *) CRDistanceSquared(CRPoint3 * p, CRPoint3 * q);
CRSTDAPI_(CRNumber *) CRGetX(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRGetY(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRGetZ(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordXYAngle(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordYZAngle(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordLength(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRGetX(CRPoint3 * v);
CRSTDAPI_(CRNumber *) CRGetY(CRPoint3 * v);
CRSTDAPI_(CRNumber *) CRGetZ(CRPoint3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordXYAngle(CRPoint3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordYZAngle(CRPoint3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordLength(CRPoint3 * v);
CRSTDAPI_(CRTransform3 *) CRIdentityTransform3();
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRNumber * tx, CRNumber * ty, CRNumber * tz);
CRSTDAPI_(CRTransform3 *) CRTranslate3(double tx, double ty, double tz);
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRNumber tx, CRNumber ty, CRNumber tz);
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRVector3 * delta);
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRPoint3 * new_origin);
CRSTDAPI_(CRTransform3 *) CRScale3(CRNumber * x, CRNumber * y, CRNumber * z);
CRSTDAPI_(CRTransform3 *) CRScale3(double x, double y, double z);
CRSTDAPI_(CRTransform3 *) CRScale3(CRNumber x, CRNumber y, CRNumber z);
CRSTDAPI_(CRTransform3 *) CRScale3(CRVector3 * scale_vec);
CRSTDAPI_(CRTransform3 *) CRScale3Uniform(CRNumber * uniform_scale);
CRSTDAPI_(CRTransform3 *) CRScale3Uniform(double uniform_scale);
CRSTDAPI_(CRTransform3 *) CRScale3Uniform(CRNumber uniform_scale);
CRSTDAPI_(CRTransform3 *) CRRotate3(CRVector3 * axis, CRNumber * angle);
CRSTDAPI_(CRTransform3 *) CRRotate3(CRVector3 * axis, double angle);
CRSTDAPI_(CRTransform3 *) CRRotate3(CRVector3 * axis, CRNumber angle);
CRSTDAPI_(CRVector3 *) CRTransform(CRVector3 * vec, CRTransform3 * xf);
CRSTDAPI_(CRPoint3 *) CRTransform(CRPoint3 * pt, CRTransform3 * xf);
CRSTDAPI_(CRTransform3 *) CRXShear3(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRTransform3 *) CRXShear3(double a, double b);
CRSTDAPI_(CRTransform3 *) CRXShear3(CRNumber a, CRNumber b);
CRSTDAPI_(CRTransform3 *) CRYShear3(CRNumber * c, CRNumber * d);
CRSTDAPI_(CRTransform3 *) CRYShear3(double c, double d);
CRSTDAPI_(CRTransform3 *) CRYShear3(CRNumber c, CRNumber d);
CRSTDAPI_(CRTransform3 *) CRZShear3(CRNumber * e, CRNumber * f);
CRSTDAPI_(CRTransform3 *) CRZShear3(double e, double f);
CRSTDAPI_(CRTransform3 *) CRZShear3(CRNumber e, CRNumber f);
CRSTDAPI_(CRTransform3 *) CRTransform4x4(CRArrayPtr m);
CRSTDAPI_(CRTransform3 *) CRCompose3(CRTransform3 * a, CRTransform3 * b);
CRSTDAPI_(CRTransform3 *) CRCompose3(CRArrayPtr xfs);
CRSTDAPI_(CRTransform3 *) CRInverse(CRTransform3 * xform);
CRSTDAPI_(CRBoolean *) CRIsSingular(CRTransform3 * xform);
CRSTDAPI_(CRTransform3 *) CRLookAtFrom(CRPoint3 * to, CRPoint3 * from, CRVector3 * up);
CRSTDAPI_(CRTransform2 *) CRIdentityTransform2();
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRNumber * Tx, CRNumber * Ty);
CRSTDAPI_(CRTransform2 *) CRTranslate2(double Tx, double Ty);
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRNumber Tx, CRNumber Ty);
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRVector2 * delta);
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRPoint2 * pos);
CRSTDAPI_(CRTransform2 *) CRScale2(CRNumber * x, CRNumber * y);
CRSTDAPI_(CRTransform2 *) CRScale2(double x, double y);
CRSTDAPI_(CRTransform2 *) CRScale2(CRNumber x, CRNumber y);
CRSTDAPI_(CRTransform2 *) CRScale2(CRVector2 * obsoleteMethod);
CRSTDAPI_(CRTransform2 *) CRScale2(CRVector2 * scale_vec);
CRSTDAPI_(CRTransform2 *) CRScale2Uniform(CRNumber * uniform_scale);
CRSTDAPI_(CRTransform2 *) CRScale2Uniform(double uniform_scale);
CRSTDAPI_(CRTransform2 *) CRScale2Uniform(CRNumber uniform_scale);
CRSTDAPI_(CRTransform2 *) CRRotate2(CRNumber * angle);
CRSTDAPI_(CRTransform2 *) CRRotate2(double angle);
CRSTDAPI_(CRTransform2 *) CRRotate2(CRNumber angle);
CRSTDAPI_(CRTransform2 *) CRRotate2Degrees(double angle);
CRSTDAPI_(CRTransform2 *) CRXShear2(CRNumber * arg0);
CRSTDAPI_(CRTransform2 *) CRXShear2(double arg0);
CRSTDAPI_(CRTransform2 *) CRXShear2(CRNumber arg0);
CRSTDAPI_(CRTransform2 *) CRYShear2(CRNumber * arg0);
CRSTDAPI_(CRTransform2 *) CRYShear2(double arg0);
CRSTDAPI_(CRTransform2 *) CRYShear2(CRNumber arg0);
CRSTDAPI_(CRTransform2 *) CRTransform3x2(CRArrayPtr m);
CRSTDAPI_(CRTransform2 *) CRTransform3x2(double *m, unsigned int n);
CRSTDAPI_(CRTransform2 *) CRCompose2(CRTransform2 * a, CRTransform2 * b);
CRSTDAPI_(CRTransform2 *) CRCompose2(CRArrayPtr xfs);
CRSTDAPI_(CRPoint2 *) CRTransform(CRPoint2 * pt, CRTransform2 * xf);
CRSTDAPI_(CRVector2 *) CRTransform(CRVector2 * vec, CRTransform2 * xf);
CRSTDAPI_(CRTransform2 *) CRInverse(CRTransform2 * theXf);
CRSTDAPI_(CRBoolean *) CRIsSingular(CRTransform2 * theXf);
CRSTDAPI_(CRTransform2 *) CRParallelTransform2(CRTransform3 * xf);
CRSTDAPI_(CRNumber *) CRViewFrameRate();
CRSTDAPI_(CRNumber *) CRViewTimeDelta();
CRSTDAPI_(CRMontage *) CRUnionMontageArray(CRArrayPtr mtgs);
CRSTDAPI_(CRColor *) CREmptyColor();
// Basic functions
CRSTDAPI_(bool)        CRConnect(HINSTANCE hinst);
CRSTDAPI_(bool)        CRDisconnect(HINSTANCE hinst);
CRSTDAPI_(bool)        CRIsConnected(HINSTANCE hinst);

CRSTDAPI_(bool)        CRAddSite(CRSitePtr s);
CRSTDAPI_(bool)        CRRemoveSite(CRSitePtr s);

CRSTDAPI_(HRESULT)     CRGetLastError();
CRSTDAPI_(LPCWSTR)     CRGetLastErrorString();
CRSTDAPI_(void)        CRClearLastError();
CRSTDAPI_(void)        CRSetLastError(HRESULT reason, LPCWSTR msg);

CRSTDAPI_(bool)        CRAcquireGCLock();
CRSTDAPI_(bool)        CRReleaseGCLock();
CRSTDAPI_(bool)        CRDoGC();
CRSTDAPI_(bool)        CRAddRefGC(void *);
CRSTDAPI_(bool)        CRReleaseGC(void *);

CRSTDAPI_(bool)        CRBvrToCOM(CRBvrPtr bvr,
                                  REFIID riid,
                                  void ** ppv);
CRSTDAPI_(CRBvrPtr)    COMToCRBvr(IUnknown * pbvr);

// Behavior functions

#define CRContinueTimeline   0x00000001
#define CRSwitchFinal        0x00000002
#define CRSwitchNextTick     0x00000004
#define CRSwitchAtTime       0x00000008
#define CRSwitchCurrentTick  0x00000010

CRSTDAPI_(CR_BVR_TYPEID) CRGetTypeId(CRBvrPtr);
CRSTDAPI_(CR_BVR_TYPEID) CRGetArrayTypeId(CRBvrPtr);
CRSTDAPI_(bool)          CRInit(CRBvrPtr, CRBvrPtr toBvr);
CRSTDAPI_(CRBvrPtr)      CRImportance(CRBvrPtr, double relativeImportance);
CRSTDAPI_(CRBvrPtr)      CRRunOnce(CRBvrPtr);
CRSTDAPI_(CRBvrPtr)      CRSubstituteTime(CRBvrPtr, CRNumberPtr xform);
CRSTDAPI_(CRBvrPtr)      CRHook(CRBvrPtr, CRBvrHookPtr notifier);
CRSTDAPI_(CRBvrPtr)      CRDuration(CRBvrPtr, double duration);
CRSTDAPI_(CRBvrPtr)      CRDuration(CRBvrPtr, CRNumberPtr duration);
CRSTDAPI_(CRBvrPtr)      CRRepeat(CRBvrPtr, long count);
CRSTDAPI_(CRBvrPtr)      CRRepeatForever(CRBvrPtr);
CRSTDAPI_(CRBvrPtr)      CRBvrApplyPreference(CRBvrPtr bv, BSTR pref, VARIANT val);
CRSTDAPI_(bool)          CRIsReady(CRBvrPtr, bool bBlock);
CRSTDAPI_(CRBvrPtr)      CREndEvent(CRBvrPtr);

CRSTDAPI_(bool)          CRIsImport(CRBvrPtr);
CRSTDAPI                 CRImportStatus(CRBvrPtr);
CRSTDAPI_(bool)          CRImportCancel(CRBvrPtr);
CRSTDAPI_(bool)          CRSetImportPriority(CRBvrPtr, float prio);
CRSTDAPI_(float)         CRGetImportPriority(CRBvrPtr);

CRSTDAPI_(bool)          CRIsModifiableBvr(CRBvrPtr);
CRSTDAPI_(bool)          CRSwitchTo(CRBvrPtr,
                                    CRBvrPtr switchTo,
                                    bool bOverrideFlags,
                                    DWORD dwFlags,
                                    double gTime);
CRSTDAPI_(bool)          CRSwitchToNumber(CRNumberPtr, double numToSwitchTo);
CRSTDAPI_(bool)          CRSwitchToString(CRStringPtr, LPWSTR strToSwitchTo);
CRSTDAPI_(bool)          CRSwitchToBool(CRBooleanPtr, bool b);
CRSTDAPI_(CRBvrPtr)      CRGetModifiableBvr(CRBvrPtr);

// View functions
#define CRAsyncFlag 0x00000001
#define CRINVRECT_MERGE_BOXES (1L << 0)

CRSTDAPI_(CRViewPtr)             CRCreateView();
CRSTDAPI_(void)                  CRDestroyView(CRViewPtr v);

CRSTDAPI_(double)                CRGetSimulationTime(CRViewPtr);
CRSTDAPI_(bool)                  CRTick(CRViewPtr, double simTime, bool * needToRender);
CRSTDAPI_(bool)                  CRRender(CRViewPtr);
CRSTDAPI_(bool)                  CRAddBvrToRun(CRViewPtr, 
                                               CRBvrPtr bvr, 
                                               bool continueTimeline,
                                               long * pId);
CRSTDAPI_(bool)                  CRRemoveRunningBvr(CRViewPtr, long id);
CRSTDAPI_(bool)                  CRStartModel(CRViewPtr,
                                              CRImagePtr pImage,
                                              CRSoundPtr pSound,
                                              double startTime,
                                              DWORD dwFlags,
                                              bool * pbPending);
CRSTDAPI_(bool)                  CRStopModel(CRViewPtr);
CRSTDAPI_(bool)                  CRPauseModel(CRViewPtr);
CRSTDAPI_(bool)                  CRResumeModel(CRViewPtr);
CRSTDAPI_(HWND)                  CRGetWindow(CRViewPtr);
CRSTDAPI_(bool)                  CRSetWindow(CRViewPtr, HWND hwnd);
CRSTDAPI_(IUnknown *)            CRGetDirectDrawSurface(CRViewPtr);
CRSTDAPI_(bool)                  CRSetDirectDrawSurface(CRViewPtr, IUnknown *ddsurf);
CRSTDAPI_(HDC)                   CRGetDC(CRViewPtr);
CRSTDAPI_(bool)                  CRSetDC(CRViewPtr, HDC dc);
CRSTDAPI_(bool)                  CRGetCompositeDirectlyToTarget(CRViewPtr);
CRSTDAPI_(bool)                  CRSetCompositeDirectlyToTarget(CRViewPtr, bool b);
CRSTDAPI_(bool)                  CRSetViewport(CRViewPtr,
                                               long xPos,
                                               long yPos,
                                               long w,
                                               long h);
CRSTDAPI_(bool)                  CRSetClipRect(CRViewPtr,
                                               long xPos,
                                               long yPos,
                                               long w,
                                               long h);
CRSTDAPI_(bool)                  CRRepaint(CRViewPtr,
                                           long xPos,
                                           long yPos,
                                           long w,
                                           long h);
CRSTDAPI_(CRViewSitePtr)         CRGetSite(CRViewPtr);
CRSTDAPI_(bool)                  CRSetSite(CRViewPtr, CRViewSitePtr s);
CRSTDAPI_(IServiceProvider *)    CRGetServiceProvider(CRViewPtr);
CRSTDAPI_(bool)                  CRSetServiceProvider(CRViewPtr,
                                                      IServiceProvider * s);
CRSTDAPI_(bool)                  CROnMouseMove(CRViewPtr,
                                               double when,
                                               long xPos, long yPos,
                                               byte modifiers);
CRSTDAPI_(bool)                  CROnMouseLeave(CRViewPtr,
                                                double when);
CRSTDAPI_(bool)                  CROnMouseButton(CRViewPtr,
                                                 double when,
                                                 long xPos, long yPos,
                                                 byte button,
                                                 bool bPressed,
                                                 byte modifiers);
CRSTDAPI_(bool)                  CROnKey(CRViewPtr,
                                         double when,
                                         long key,
                                         bool bPressed,
                                         byte modifiers);
CRSTDAPI_(bool)                  CROnFocus(CRViewPtr,
                                           bool bHasFocus);
CRSTDAPI_(DWORD)                 CRQueryHitPoint(CRViewPtr,
                                                 DWORD dwAspect,
                                                 LPCRECT prcBounds,
                                                 POINT   ptLoc,
                                                 long lCloseHint);
CRSTDAPI_(long)                  CRQueryHitPointEx(CRViewPtr,
                                                   long s,
                                                   DWORD_PTR *cookies,
                                                   double *points,
                                                   LPCRECT prcBounds,
                                                   POINT   ptLoc);
CRSTDAPI_(long)                  CRGetInvalidatedRects(CRViewPtr,
                                                       DWORD flags,
                                                       long  size,
                                                       RECT *pRects);
CRSTDAPI_(bool)                  CRGetDDD3DRM(CRViewPtr,
                                              IUnknown **directDraw,
                                              IUnknown **d3drm);
CRSTDAPI_(bool)                  CRGetRMDevice(CRViewPtr,
                                               IUnknown **d3drmDevice,
                                               DWORD     *sequenceNumber);
CRSTDAPI_(bool)                  CRPutPreference(CRViewPtr,
                                                 LPWSTR preferenceName,
                                                 VARIANT value);
CRSTDAPI_(bool)                  CRGetPreference(CRViewPtr,
                                                 LPWSTR preferenceName,
                                                 VARIANT * value);
CRSTDAPI_(bool)                  CRPropagate(CRViewPtr);

// Pickable result functions

CRSTDAPI_(CRImagePtr)    CRGetImage(CRPickableResultPtr);
CRSTDAPI_(CRGeometryPtr) CRGetGeometry(CRPickableResultPtr);
CRSTDAPI_(CREventPtr)    CRGetEvent(CRPickableResultPtr);

// Importation result functions

CRSTDAPI_(CRImagePtr)    CRGetImage(CRImportationResultPtr);
CRSTDAPI_(CRSoundPtr)    CRGetSound(CRImportationResultPtr);
CRSTDAPI_(CRGeometryPtr) CRGetGeometry(CRImportationResultPtr);
CRSTDAPI_(CRNumberPtr)   CRGetDuration(CRImportationResultPtr);
CRSTDAPI_(CREventPtr)    CRGetCompletionEvent(CRImportationResultPtr);
CRSTDAPI_(CRNumberPtr)   CRGetProgress(CRImportationResultPtr);
CRSTDAPI_(CRNumberPtr)   CRGetSize(CRImportationResultPtr);

// Transform result functions

CRSTDAPI_(CRBvrPtr)    CRGetOutputBvr(CRDXTransformResultPtr);
CRSTDAPI_(IUnknown *)  CRGetTransform(CRDXTransformResultPtr);
CRSTDAPI_(bool)        CRSetBvrAsProperty(CRDXTransformResultPtr,
                                          LPCWSTR property,
                                          CRBvrPtr bvr);

CRSTDAPI_(CRDXTransformResultPtr) CRApplyDXTransform(IUnknown *theXf,
                                                     long numInputs,
                                                     CRBvrPtr *inputs,
                                                     CRBvrPtr evaluator);

// Import
enum CR_MEDIA_SOURCE {
    CR_SRC_URL = 0,
    CR_SRC_IStream = 1
};

#define CR_IMPORT_ASYNC        0x00000001
#define CR_IMPORT_STREAMED     0x00000002

CRSTDAPI_(CRImportationResultPtr)   CRImportMedia(LPWSTR baseUrl,
                                                  void * mediaSource,
                                                  CR_MEDIA_SOURCE srcType,
                                                  void * params[],
                                                  DWORD flags,
                                                  CRImportSitePtr s);
CRSTDAPI_(DWORD)                     CRImportImage(LPCWSTR baseUrl,
                                                   LPCWSTR relUrl,
                                                   CRImportSitePtr s,
                                                   IBindHost * bh,
                                                   bool useColorKey,
                                                   BYTE ckRed,
                                                   BYTE ckGreen,
                                                   BYTE ckBlue,
                                                   CRImage   *pImageStandIn,
                                                   CRImage  **ppImage,
                                                   CREvent  **ppEvent,
                                                   CRNumber **ppProgress,
                                                   CRNumber **size);
CRSTDAPI_(DWORD)                     CRImportMovie(LPCWSTR baseUrl,
                                                   LPCWSTR relUrl,
                                                   CRImportSitePtr s,
                                                   IBindHost * bh,
                                                   bool        stream,
                                                   CRImage   *pImageStandIn,
                                                   CRSound   *pSoundStandIn,
                                                   CRImage  **ppImage,
                                                   CRSound  **ppSound,
                                                   CRNumber **length,
                                                   CREvent  **ppEvent,
                                                   CRNumber **ppProgress,
                                                   CRNumber **size);
CRSTDAPI_(DWORD)                     CRImportSound(LPCWSTR baseUrl,
                                                   LPCWSTR relUrl,
                                                   CRImportSitePtr s,
                                                   IBindHost * bh,
                                                   bool        stream,
                                                   CRSound   *pSoundStandIn,
                                                   CRSound  **ppSound,
                                                   CRNumber **length,
                                                   CREvent  **ppEvent,
                                                   CRNumber **ppProgress,
                                                   CRNumber **size);

CRSTDAPI_(DWORD)                     CRImportGeometry(LPCWSTR baseUrl,
                                                      LPCWSTR relUrl,
                                                      CRImportSitePtr s,
                                                      IBindHost * bh,
                                                      CRGeometry   *pGeoStandIn,
                                                      CRGeometry  **ppGeometry,
                                                      CREvent  **ppEvent,
                                                      CRNumber **ppProgress,
                                                      CRNumber **size);

CRSTDAPI_(DWORD)                     CRImportGeometryWrapped(LPCWSTR baseUrl,
                                                             LPCWSTR relUrl,
                                                             CRImportSitePtr s,
                                                             IBindHost * bh,
                                                             CRGeometry   *pGeoStandIn,
                                                             CRGeometry  **ppGeometry,
                                                             CREvent  **ppEvent,
                                                             CRNumber **ppProgress,
                                                             CRNumber **size,
                                                             LONG wrapType,
                                                             double originX,
                                                             double originY,
                                                             double originZ,
                                                             double zAxisX,
                                                             double zAxisY,
                                                             double zAxisZ,
                                                             double yAxisX,
                                                             double yAxisY,
                                                             double yAxisZ,
                                                             double texOriginX,
                                                             double texOriginY,
                                                             double texScaleX,
                                                             double texScaleY,
                                                             DWORD flags);

CRSTDAPI_(CRImagePtr)    CRImportDirectDrawSurface (IUnknown *dds,
                                                    CREvent *updateEvent);

CRSTDAPI_(CRGeometryPtr) CRImportDirect3DRMVisual (IUnknown *visual);

CRSTDAPI_(CRGeometryPtr) CRImportDirect3DRMVisualWrapped(IUnknown *visual,
                                                         LONG wrapType,
                                                         double originX,
                                                         double originY,
                                                         double originZ,
                                                         double zAxisX,
                                                         double zAxisY,
                                                         double zAxisZ,
                                                         double yAxisX,
                                                         double yAxisY,
                                                         double yAxisZ,
                                                         double texOriginX,
                                                         double texOriginY,
                                                         double texScaleX,
                                                         double texScaleY,
                                                         DWORD flags);

// Misc
#define CR_ARRAY_CHANGEABLE_FLAG  0x00000001

CRSTDAPI_(LPCWSTR)         CRVersionString();
CRSTDAPI_(bool)            CRTriggerEvent(CREventPtr event, CRBvrPtr t);
CRSTDAPI_(CRBvrPtr)        CRCond(CRBooleanPtr c,
                                  CRBvrPtr i,
                                  CRBvrPtr e);
CRSTDAPI_(CRArrayPtr)      CRCreateArray(long s,
                                         CRBvrPtr pBvrs[],
                                         DWORD dwFlags);
CRSTDAPI_(CRArrayPtr)      CRCreateArray(long s,
                                         double dArr[],
                                         CR_BVR_TYPEID tid);
CRSTDAPI_(CRTuplePtr)      CRCreateTuple(long s, CRBvrPtr pBvrs[]);
CRSTDAPI_(CRArrayPtr)      CRUninitializedArray(CRArrayPtr typeTmp);
CRSTDAPI_(CRTuplePtr)      CRUninitializedTuple(CRTuplePtr typeTmp);
CRSTDAPI_(CRBvrPtr)        CRUninitializedBvr(CR_BVR_TYPEID t);
CRSTDAPI_(CRBvrPtr)        CRSampleAtLocalTime(CRBvrPtr b, double localTime);
CRSTDAPI_(bool)            CRIsConstantBvr(CRBvrPtr b);

// Modifiables
CRSTDAPI_(CRBvrPtr)        CRModifiableBvr(CRBvrPtr orig, DWORD dwFlags);
CRSTDAPI_(CRNumberPtr)     CRModifiableNumber(double initVal);
CRSTDAPI_(CRStringPtr)     CRModifiableString(LPWSTR initVal);
CRSTDAPI_(CRColorPtr)      CRModifiableColor255(BYTE initRed,
                                                BYTE initGreen,
                                                BYTE initBlue);
CRSTDAPI_(CRPoint2Ptr)     CRModifiablePoint2(double x,
                                              double y,
                                              bool bPixelMode);
CRSTDAPI_(CRVector2Ptr)    CRModifiableVector2(double x,
                                               double y,
                                               bool bPixelMode);
CRSTDAPI_(CRPoint3Ptr)     CRModifiablePoint3(double x,
                                              double y,
                                              double z,
                                              bool bPixelMode);
CRSTDAPI_(CRVector3Ptr)    CRModifiableVector3(double x,
                                               double y,
                                               double z,
                                               bool bPixelMode);
CRSTDAPI_(CRTransform2Ptr) CRModifiableTranslate2(double x,
                                                  double y,
                                                  bool bPixelMode);
CRSTDAPI_(CRTransform2Ptr) CRModifiableScale2(double x,
                                              double y);
CRSTDAPI_(CRTransform2Ptr) CRModifiableRotate2(double angle);
CRSTDAPI_(CRTransform3Ptr) CRModifiableTranslate3(double x,
                                                  double y,
                                                  double z,
                                                  bool bPixelMode);
CRSTDAPI_(CRTransform3Ptr) CRModifiableScale3(double x,
                                              double y,
                                              double z);
CRSTDAPI_(CRTransform3Ptr) CRModifiableRotate3(double axisX,
                                               double axisY,
                                               double axisZ,
                                               double angle);
// Splines
CRSTDAPI_(CRBvrPtr)      CRBSpline(int degree,
                                   long numKnots,
                                   CRNumberPtr knots[],
                                   long numPts,
                                   CRBvrPtr ctrlPts[],
                                   long numWts,
                                   CRNumberPtr weights[],
                                   CRNumberPtr evaluator,
                                   CR_BVR_TYPEID tid);

CRSTDAPI_(CRBvrPtr)      CRExtendedAttrib(CRBvr *arg0,
                                          LPWSTR arg1,
                                          VARIANT arg2);

#define CRQUAL_AA_TEXT_ON     (1L << 0)
#define CRQUAL_AA_TEXT_OFF    (1L << 1)
#define CRQUAL_AA_LINES_ON    (1L << 2)
#define CRQUAL_AA_LINES_OFF   (1L << 3)
#define CRQUAL_AA_SOLIDS_ON   (1L << 4)
#define CRQUAL_AA_SOLIDS_OFF  (1L << 5)
#define CRQUAL_AA_CLIP_ON     (1L << 6)
#define CRQUAL_AA_CLIP_OFF    (1L << 7)
#define CRQUAL_MSHTML_COLORS_ON  (1L << 8)
#define CRQUAL_MSHTML_COLORS_OFF  (1L << 9)
#define CRQUAL_QUALITY_TRANSFORMS_ON  (1L << 10)
#define CRQUAL_QUALITY_TRANSFORMS_OFF (1L << 11)

// SAME VALUES AS DANIM.IDL <if you update this: update danim.idl>

typedef enum  {
    ds_Solid      = 0,
    ds_Dashed     = 1,
    ds_Dot        = 2,
    ds_Dashdot    = 3,
    ds_Dashdotdot = 4,
    ds_Null       = 5
} DashStyleEnum;

typedef enum  {
    es_Round  = 0,
    es_Square = 1,
    es_Flat   = 2
} EndStyleEnum;

typedef enum  {
    js_Round = 0,
    js_Bevel = 1,
    js_Miter = 2
} JoinStyleEnum;


#endif /* _DARTAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\dispids.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Global dispid file

--*/

#ifndef _DISPIDS_H_
#define _DISPIDS_H_

#define DISPID_AXAVIEWCONTROL_DATAPATH     100
#define DISPID_AXAVIEWCONTROL_EXPRESSION   102
#define DISPID_AXAVIEWCONTROL_BORDER       103
#define DISPID_AXAVIEWCONTROL_FROZEN       105
#define DISPID_AXAVIEWCONTROL_DATA         106
#define DISPID_AXAVIEWCONTROL_VIEWERMENUS  107
#define DISPID_AXAVIEWCONTROL_SHOWSOURCE   108

#define DISPID_ENGINE_SETENGINESITE            200
#define DISPID_ENGINE_SETCONTAINER             201
#define DISPID_ENGINE_SHOWCONTEXTMENU          202
#define DISPID_ENGINE_MAKEBEHAVIORINTERFACE    203
#define DISPID_ENGINE_CREATEMODULE             204
#define DISPID_ENGINE_CREATEVIEW               205

#define DISPID_MODULE_LOADURL          300
#define DISPID_MODULE_LOADSTRING       301
#define DISPID_MODULE_GETTYPESTRING    302
#define DISPID_MODULE_GETCODESTRING    303
#define DISPID_MODULE_ENUMPRIMITIVES   304
#define DISPID_MODULE_ENUMENVIRONMENT  305
#define DISPID_MODULE_DOCUMENTBASE     306
#define DISPID_MODULE_SETMODULESITE    307
#define DISPID_MODULE_STATUSHWND       308
#define DISPID_MODULE_MAKEBEHAVIOR     309

#define DISPID_VIEW_TICK                 401
#define DISPID_VIEW_TICK_USE_SYS_TIME    402
#define DISPID_VIEW_START_MODEL          403
#define DISPID_VIEW_WINDOW               404
#define DISPID_VIEW_NAME                 405
#define DISPID_VIEW_PAINT                406
#define DISPID_VIEW_SETSIZE              407
#define DISPID_VIEW_PALETTECHANGED       408
#define DISPID_VIEW_CONTEXTMENU          409
#define DISPID_VIEW_SETVIEWSITE          410
#define DISPID_VIEW_SETSYSSTARTTIME      411
#define DISPID_VIEW_GETSYSSTARTTIME      412
#define DISPID_VIEW_APPTRIGGER           413
#define DISPID_VIEW_ONMOUSEMOVE          414
#define DISPID_VIEW_ONMOUSEBUTTON        415
#define DISPID_VIEW_ONKEY                416
#define DISPID_VIEW_ONFOCUS              417
#define DISPID_VIEW_START_SCRIPT_MODEL   418
#define DISPID_VIEW_QUERYACTUALGC        419

#define DISPID_BEHAVIOR_GETTYPESTRING   600
#define DISPID_BEHAVIOR_GETCLASSNAME    601
#define DISPID_BEHAVIOR_RUN             602
#define DISPID_BEHAVIOR_SNAPSHOT        603

#define DISPID_UNTILNOTIFIER_NOTIFY     700

#endif  // _DISPIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\dalibc.h ===
#pragma once
#ifndef _DALIBC_H
#define _DALIBC_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

/*
const double pi    = 3.1415926535897932384626434;

// Point conversions
// 72 pts/ inch * 1/2.54 inch/cm * 100 cm/m
#define POINTS_PER_METER (72.0 * 100.0 / 2.54)
#define METERS_PER_POINT (1.0/POINTS_PER_METER)
*/

extern "C" {
        
    #define StrCmpNA  DAStrCmpNA
    #define StrCmpNIA DAStrCmpNIA
    #define StrRChrA  DAStrRChrA

    LPWSTR StrCpyW(LPWSTR psz1, LPCWSTR psz2);
    LPWSTR StrCpyNW(LPWSTR psz1, LPCWSTR psz2, int cchMax);
    LPWSTR StrCatW(LPWSTR psz1, LPCWSTR psz2);

    BOOL ChrCmpIA(WORD w1, WORD wMatch);
    BOOL ChrCmpIW(WORD w1, WORD wMatch);

    int StrCmpW(LPCWSTR pwsz1, LPCWSTR pwsz2);
    int StrCmpIW(LPCWSTR pwsz1, LPCWSTR pwsz2);
    int StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
    int StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
    int StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
    int StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);

    LPSTR StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);

    bool DALibStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);
};



/*****************************************************************************
This object maintains information about the current platform.
*****************************************************************************/

class SysInfo {

  public:

    void Init (void);

    bool IsNT (void);
    bool IsWin9x (void);    // Windows 95 or Windows 98

    // These return the MAJOR / MINOR versions of the OS.

    DWORD OSVersionMajor (void);
    DWORD OSVersionMinor (void);

    // This method queries the version of D3D on the system.

    int VersionD3D (void);

    // This method queries the version of DDraw on the system.  It returns
    // 3 for DDraw 3 or earlier, or N for DDraw N (where N is version 5 or
    // later.

    int VersionDDraw (void);

  private:

    OSVERSIONINFO _osVersion;     // OS Version Information
    int           _versionD3D;    // D3D Version Level
    int           _versionDDraw;  // DDraw Version Level
};

extern SysInfo sysInfo;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\dartapipriv.h ===
#ifndef _DARTAPIPRIV_H
#define _DARTAPIPRIV_H


class CRBvr : public BvrImpl{};
class CRBoolean : public CRBvr{};
class CRCamera : public CRBvr{};
class CRColor : public CRBvr{};
class CRGeometry : public CRBvr{};
class CRImage : public CRBvr{};
class CRMatte : public CRBvr{};
class CRMicrophone : public CRBvr{};
class CRMontage : public CRBvr{};
class CRNumber : public CRBvr{};
class CRPath2 : public CRBvr{};
class CRPoint2 : public CRBvr{};
class CRPoint3 : public CRBvr{};
class CRSound : public CRBvr{};
class CRString : public CRBvr{};
class CRTransform2 : public CRBvr{};
class CRTransform3 : public CRBvr{};
class CRVector2 : public CRBvr{};
class CRVector3 : public CRBvr{};
class CRFontStyle : public CRBvr{};
class CRLineStyle : public CRBvr{};
class CREndStyle : public CRBvr{};
class CRJoinStyle : public CRBvr{};
class CRDashStyle : public CRBvr{};
class CRBbox2 : public CRBvr{};
class CRBbox3 : public CRBvr{};
class CRPair : public CRBvr{};
class CREvent : public CRBvr{};
class CRArray : public CRBvr{};
class CRTuple : public CRBvr{};
class CRUserData : public CRBvr{};


#endif /* _DARTAPIPRIV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\verhead.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\vertail.h ===
#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\include\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

/* 8/11/00 tuanle - change from 6,01,09,0727 to 6,03,01,0146    */
/* for DX8 Beta2                                                */

#define VERSION                     "6.03.01.0146" 
#define VER_FILEVERSION_STR         "6.03.01.0146\0" 
#define VER_FILEVERSION             6,03,01,0146 
#define VER_PRODUCTVERSION_STR      "6.03.01.0146\0" 
#define VER_PRODUCTVERSION          6,03,01,0146 

#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#if DEVELOPER_DEBUG /*OFFICIAL */
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\jaxa\makecomm.inc ===
!include ../../root.inc
MODULE=jaxa
PCHPATH=$(BLDROOT)\jaxa
PCHFILE=headers

INCLUDEDIRS=$(SRCDIR) $(TOOLSINCLUDE) $(SRCROOT)\include $(SDKDIR) $(BLDDIR)

!include $(ROOT)\src\make\make1.inc

JAVAPRIM=javaprim.bat
PRIMFILE=$(SDKDIR)\cprims.h
MAKE_CLASS_INC=$(BLDDIR)\mkclass.inc
STATICSNAME=Statics
PACKAGEROOT=com.ms.dxmedia
PACKAGEPATHROOT=$(PACKAGEROOT:.=\)
PACKAGEPATH=$(BLDDIR)\$(PACKAGEPATHROOT)
BINPACKAGEPATH=$(BINDIR)\$(PACKAGEPATHROOT)
FILELIST=$(BLDDIR)\files.lst
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\javacab\cabcopy.cpp ===
#include <windows.h>

  DWORD dwReturn;
  TCHAR destDir[MAX_PATH];
  TCHAR zCmd[MAX_PATH];
  TCHAR currentDir[MAX_PATH];

  // this is the file to copy
  TCHAR cabFile[] = "dajava.cab";
  #define CAB_FILENAME_LENGTH	10

  int WINAPI WinMain(
		HINSTANCE	hInstance,
		HINSTANCE	hPrevInstance,
		LPSTR		lpCmdLine,
		int			nCmdShow ) 
  { // WinMain //

    DWORD	currDirLength;
	UINT	character,
			destDirLength;
	int		returnValue = -1;

    destDirLength = GetWindowsDirectory(destDir, MAX_PATH);
	
	if( destDirLength == 0 || destDirLength > MAX_PATH) {
		return returnValue;
	}

	currDirLength = GetCurrentDirectory(MAX_PATH, currentDir);

	if( currDirLength == 0 || currDirLength > MAX_PATH) {
		return returnValue;
	}

	//Let's append the filename to the current directory
	// check space for the directory separator and null termination
	if( currDirLength > MAX_PATH + CAB_FILENAME_LENGTH + 2) {
		return returnValue;
	}

	//Add a directory separator
	currentDir[currDirLength] = '\\';
	currDirLength++;

	for( character = 0; character < CAB_FILENAME_LENGTH; character++) {
		currentDir[currDirLength + character] = cabFile[character];
	}

	// NULL terminate the string
	currentDir[currDirLength + CAB_FILENAME_LENGTH] = 0;

	//Now, let's append the filename to the destination directory
	// check space for the directory separator and null termination
	if( destDirLength > MAX_PATH + CAB_FILENAME_LENGTH + 2) {
		return returnValue;
	}

	//Add a directory separator
	destDir[destDirLength] = '\\';
	destDirLength++;

	// Note that we start at one because we already add the backslash
	for( character = 0; character < CAB_FILENAME_LENGTH; character++) {
		destDir[destDirLength + character] = cabFile[character];
	}

	// NULL terminate the string
	destDir[destDirLength + CAB_FILENAME_LENGTH] = 0;

	if( MoveFile(currentDir, destDir) == 0 ) {
		DWORD error = GetLastError();
	} else {
		returnValue = 0;
	}

	return returnValue;

  } // WinMain //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\jaxa\makefile.inc ===
BINDIR=$(BLDROOT)\bin
BLDDIR=$(TARGETPATH)\$(TARGET_DIRECTORY)
JAVA15DIR=$(TOOLSDIR)\java15
JCOMGEN  = $(JAVA15DIR)\bin\JCOMGEN
JAVADIR=$(TOOLSDIR)\java20
PACKAGEROOT=com.ms.dxmedia
PACKAGEROOT=com.ms.dxmedia
PACKAGEPATHROOT=com\ms\dxmedia
PACKAGEPATH=$(BLDDIR)\$(PACKAGEPATHROOT)
BINPACKAGEPATH=$(BINDIR)\$(PACKAGEPATHROOT)
_USER_JCOMGENFLAGS=/p $(PACKAGEROOT).rawcom /p:b- /d $(BLDDIR) /xi /e /X:m-
JCOMGENFLAGS= /nologo $(_USER_JCOMGENFLAGS)
JCCLASSPATH= $(JAVADIR)\classes\afc.zip;$(JAVADIR)\classes\classes.zip;$(SRCDIR);$(BLDDIR);$(SDKDIR);$(BINDIR)
ATTRJC   = $(JAVA15DIR)\bin\ATTRJVC
ATTRJCFLAGS= /cp:p $(JCCLASSPATH) $(_USER_ATTRJCFLAGS)

!ifndef NOLINK

JavaStuff: $(BINPACKAGEPATH)\rawcom\IDAView.class jaxasrc

$(BINPACKAGEPATH)\rawcom\IDAView.class: $(BLDDIR)\danim.tlb
    $(JCOMGEN) $(JCOMGENFLAGS) $(BLDDIR)\danim.tlb
    DEL 2>nul: $(PACKAGEPATH)\rawcom\*Default.java
    $(ATTRJC) $(ATTRJCFLAGS) /d $(BLDDIR) $(PACKAGEPATH)\rawcom\*.java
    @-md $(BINPACKAGEPATH)\rawcom
    xcopy >NUL $(PACKAGEPATH)\rawcom\*.class $(BINPACKAGEPATH)\rawcom

jaxasrc:
    set _BLDROOT=$(_BLDROOT)
    set NTMAKEENV_TMP=$(NTMAKEENV)
    set NTMAKEENV=
!if $(FREEBUILD)
    nmake D=0 fresh
!else
    nmake fresh
!endif
    set NTMAKEENV=$(NTMAKEENV_TMP)
    copy $(BINDIR)\dxmedia.zip $(TARGETPATH)\$(TARGET_DIRECTORY)
    copy $(BINDIR)\dajava.cab $(TARGETPATH)\$(TARGET_DIRECTORY)
!else
JavaStuff:
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\autoeffect.h ===
#ifndef __AUTOEFFECT_H_
#define __AUTOEFFECT_H_

//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    AutoEffect.h
//
// Author:	markhal
//
// Created:	11/10/98
//
// Abstract:    Definition of the LM Auto Effect Behavior.
//
//*****************************************************************************

#include <resource.h>
#include <vector>

#include "lmrt.h"
#include "..\chrome\include\basebvr.h"
#include "..\chrome\include\sampler.h"
#include "sparkmaker.h"

using namespace std;

class CSpark
{
public:
	CSpark(	IDABehavior * pBvr = NULL, 
			bool fAlive = true, 
			double dAge = 0.0 );

	CSpark( const CSpark& );

	virtual ~CSpark();

public:
	bool		IsAlive();
	double		Age( double dDeltaTime );
	HRESULT		Kill( IDABehavior * );
	HRESULT		Reincarnate( IDABehavior *, double in_dAge = 0.0 );

protected:
	bool							m_fAlive;
	double							m_dAge;
	CComPtr<IDABehavior>			m_pModifiableBvr;
};

typedef vector<CSpark> VecSparks;

#define NUM_AUTOEFFECT_PROPS 10

//*****************************************************************************

class ATL_NO_VTABLE CAutoEffectBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAutoEffectBvr, &CLSID_LMAutoEffectBvr>,
    public IConnectionPointContainerImpl<CAutoEffectBvr>,
    public IPropertyNotifySinkCP<CAutoEffectBvr>,
    public IDispatchImpl<ILMAutoEffectBvr, &IID_ILMAutoEffectBvr, &LIBID_LiquidMotion>,
    public IPersistPropertyBag2,
    public IElementBehavior,
	public ILMSample,
    public CBaseBehavior
	
{
public:
DECLARE_REGISTRY_RESOURCEID(IDR_AUTOEFFECTBVR)

BEGIN_COM_MAP(CAutoEffectBvr)
	COM_INTERFACE_ENTRY(ILMAutoEffectBvr)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY(IElementBehavior)
    COM_INTERFACE_ENTRY(ILMSample)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CAutoEffectBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

	CAutoEffectBvr();
    ~CAutoEffectBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // ILMSample
    STDMETHOD(Sample) (double dStart, double dGlobalNow, double dLocalNow );

    //
    //ILMAutoEffectBvr
    //
    STDMETHOD(put_animates)( VARIANT newVal );
    STDMETHOD(get_animates)( VARIANT *pVal );
    STDMETHOD(put_type)( VARIANT newVal );
    STDMETHOD(get_type)( VARIANT *pVal );
    STDMETHOD(put_cause)( VARIANT newVal );
    STDMETHOD(get_cause)( VARIANT *pVal );
    STDMETHOD(put_span)( VARIANT newVal );
    STDMETHOD(get_span)( VARIANT *pVal );
    STDMETHOD(put_size)( VARIANT newVal );
    STDMETHOD(get_size)( VARIANT *pVal );
    STDMETHOD(put_rate)( VARIANT newVal );
    STDMETHOD(get_rate)( VARIANT *pVal );
    STDMETHOD(put_gravity)( VARIANT newVal );
    STDMETHOD(get_gravity)( VARIANT *pVal );
    STDMETHOD(put_wind)( VARIANT newVal );
    STDMETHOD(get_wind)( VARIANT *pVal );
    STDMETHOD(put_fillColor)( VARIANT newVal );
    STDMETHOD(get_fillColor)( VARIANT *pVal );
    STDMETHOD(put_strokeColor)( VARIANT newVal );
    STDMETHOD(get_strokeColor)( VARIANT *pVal );
    STDMETHOD(put_opacity)( VARIANT newVal );
    STDMETHOD(get_opacity)( VARIANT *pVal );
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

	STDMETHOD(mouseEvent) (long x,
						   long y,
                           VARIANT_BOOL bMove,
                           VARIANT_BOOL bUp,
                           VARIANT_BOOL bShift, 
                           VARIANT_BOOL bAlt,
                           VARIANT_BOOL bCtrl,
                           long button);
    //IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ILMAutoEffectBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

protected:
	enum Cause
	{
		CAUSE_TIME,
		CAUSE_MOUSEMOVE,
		CAUSE_DRAGOVER,
		CAUSE_MOUSEDOWN,
		NUM_CAUSES
	};

	static const WCHAR * const RGSZ_CAUSES[ NUM_CAUSES ];
	
	static const WCHAR * const RGSZ_TYPES[ CSparkMaker::NUM_TYPES ];
	
protected:
    virtual HRESULT BuildAnimationAsDABehavior() { return S_OK; }

    virtual VARIANT *VariantFromIndex(ULONG iIndex);

    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

	HRESULT InitInternalProperties();
	HRESULT InitSparks();

	HRESULT AddSpark();
	HRESULT AddSparkAround( long x, long y );
	HRESULT	AddSparkAt( long x, long y );

	HRESULT	CreateSparkBvr( IDAImage ** ppImageBvr, float fX, float fY, float fSize );


private:
	HRESULT AddMouseEventListener( bool bAdd );
	
	HRESULT	AgeSparks( double dDeltaTime );

	HRESULT PossiblyAddSparks( double dLocalTime );
	HRESULT PossiblyAddSpark( double dLocalTime, long x, long y );
	HRESULT	ResetSparks( double dLocalTime );
	bool	ThrottleBirth( double dLocalTime );
	void	ResetThrottle( double dLocalTime );
	
	HRESULT AddBvrToSparkArray( IDAImage * pImageBvr );
		
private:
	CComPtr<IDispatch>	m_pdispActor;

	CSampler			* m_pSampler;
	CSparkMaker			* m_pSparkMaker;
	CComPtr<IDA2Array>	m_pDAArraySparks;
	VecSparks			m_vecSparks;
	SparkOptions		m_sparkOptions;

    static WCHAR                *m_rgPropNames[NUM_AUTOEFFECT_PROPS]; 

    VARIANT m_type;
    VARIANT m_cause;
    VARIANT m_span;
    VARIANT m_size;
    VARIANT m_rate;
    VARIANT m_gravity;
    VARIANT m_wind;
    VARIANT m_fillColor;
    VARIANT m_strokeColor;
	VARIANT m_opacity;

	CSparkMaker::Type	m_eType;
	Cause				m_eCause;
	double				m_dMaxAge;               
	float				m_fScaledSize;           
	double				m_dBirthDelta;           
	float				m_fXVelocity;            
	float				m_fYVelocity;            
	float				m_fOpacity;              
						                         
	double				m_dLocalTime;            
	double				m_dLastBirth; 

	long				m_lCookie;

	HRESULT				RemoveFragment();
	
}; // CAutoEffectBvr

inline CSpark::CSpark( IDABehavior * in_pBvr, bool in_fAlive, double in_dAge )
{
	m_fAlive 			= in_fAlive;
	m_dAge				= in_dAge;
	m_pModifiableBvr	= in_pBvr;
}

inline CSpark::CSpark( const CSpark& in_spark )
{
	m_fAlive			= in_spark.m_fAlive;
	m_dAge				= in_spark.m_dAge;
	m_pModifiableBvr	= in_spark.m_pModifiableBvr;
}

inline CSpark::~CSpark()
{
}

inline bool
CSpark::IsAlive()
{
	return m_fAlive;
}

#endif //__AUTOEFFECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\avoidfollow.cpp ===
//*****************************************************************************
//
// File:            avoidFollow.cpp
// Author:          kurtj
// Date Created:    11/6/98
//
// Abstract: Implementation of the Liquid Motion avoid follow behavior as
//           a DHTML behavior.
//
//
//Change Log:
//11-06-98  kurtj   Created
//11-11-98  kurtj   Fleshed out.
//*****************************************************************************

#include "headers.h" 

#include "avoidfollow.h"
#include "lmattrib.h"
#include "..\chrome\include\utils.h"

#undef THIS
#define THIS CAvoidFollowBvr
#define SUPER CBaseBehavior

#include "..\chrome\src\pbagimp.cpp"


#define DEFAULT_RADIUS 400.0

#define VAR_RADIUS 0
#define VAR_TARGET 1
#define VAR_VELOCITY 2

WCHAR * CAvoidFollowBvr::m_rgPropNames[] = {
                                             BEHAVIOR_PROPERTY_RADIUS,
                                             BEHAVIOR_PROPERTY_TARGET,
                                             BEHAVIOR_PROPERTY_VELOCITY
                                           };


//*****************************************************************************
//CAvoidFollowBvr
//*****************************************************************************



CAvoidFollowBvr::CAvoidFollowBvr(): m_sampler( NULL ),
									m_targetType(targetInvalid),
									m_timeDelta(0.0),
									m_pElement( NULL ),
									m_pAnimatedElement( NULL ),
									m_pAnimatedElement2( NULL ),
									m_pTargetElement2( NULL ),
									m_pWindow3(NULL),
									m_currentX( 0.0 ),
									m_currentY( 0.0 ),
									m_lastSampleTime( 0.0 ),
									m_dRadius( 0.0 ),
									m_dVelocity( 0.0 ),
									m_screenLeft( 0 ),
									m_screenTop( 0 ),
									m_sourceLeft( 0 ),
									m_sourceTop( 0 ),
									m_targetLeft( 0 ),
									m_targetTop( 0 ),
									m_topBvr( NULL ),
									m_leftBvr( NULL ),
									m_pBody2( NULL ),
                                    m_originalX( 0 ),
                                    m_originalY( 0 ),
                                    m_originalLeft( 0 ),
                                    m_originalTop( 0 ),
									m_targetClientLeft( 0 ),
									m_targetClientTop( 0 )
{
    VariantInit( &m_radius );
    VariantInit( &m_target );
    VariantInit( &m_velocity );
    
    m_sampler = new CSampler( SampleOnBvr, reinterpret_cast<void*>(this) );
} // CAvoidFollowBvr

//*****************************************************************************

CAvoidFollowBvr::~CAvoidFollowBvr()
{
    VariantClear( &m_radius );
    VariantClear( &m_target );
    VariantClear( &m_velocity );

	ReleaseInterface( m_leftBvr );
	ReleaseInterface( m_topBvr );

    if( m_sampler != NULL )
	{
        m_sampler->Invalidate();
		m_sampler = NULL;
	}
} // ~CAvoidFollowBvr

//*****************************************************************************

HRESULT 
CAvoidFollowBvr::FinalConstruct()
{

    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in move behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

STDMETHODIMP 
CAvoidFollowBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	HRESULT hr = SUPER::Init(pBehaviorSite);

	hr = pBehaviorSite->GetElement( &m_pElement );

	return hr;
} // Init

//*****************************************************************************

VARIANT *
CAvoidFollowBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_AVOIDFOLLOW_PROPS);
    switch (iIndex)
    {
    case VAR_RADIUS:
        return &m_radius;
        break;
    case VAR_TARGET:
        return &m_target;
        break;
    case VAR_VELOCITY:
        return &m_velocity;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CAvoidFollowBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_AVOIDFOLLOW_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CAvoidFollowBvr::Notify(LONG event, VARIANT *pVar)
{
	return SUPER::Notify(event, pVar);
} // Notify

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::Detach()
{
    if( m_sampler != NULL )
	{
        m_sampler->Invalidate();
		m_sampler = NULL;
	}

	ReleaseDAInterfaces();
	ReleaseTridentInterfaces();

	return SUPER::Detach();
} // Detach 

//*****************************************************************************

void
CAvoidFollowBvr::ReleaseTridentInterfaces()
{
	ReleaseInterface( m_pElement );
	ReleaseInterface( m_pAnimatedElement );
	ReleaseInterface( m_pAnimatedElement2 );
	ReleaseInterface( m_pTargetElement2);
	ReleaseInterface( m_pWindow3 );
	ReleaseInterface( m_pBody2 );
}

//*****************************************************************************

void
CAvoidFollowBvr::ReleaseDAInterfaces()
{
	ReleaseInterface( m_leftBvr );
	ReleaseInterface( m_topBvr );
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::FindTargetElement()
{
	if( m_pElement == NULL )
		return E_FAIL;
	HRESULT hr = E_FAIL;

	//make sure that the target variant is a bstr and valid.
	hr = CUtils::InsurePropertyVariantAsBSTR( &m_velocity );

	if( FAILED( hr ) )
	{
		DPF_ERR("Could not ensure that the target property was a bstr");
		goto cleanup;
	}

	//get the IDispatch of the document from our element
	IDispatch *pdispDocument;
	hr = m_pElement->get_document( &pdispDocument );

	CheckHR( hr, "Failed to get the IDispatch of the document from the element", cleanup );

	//query the IDispatch returned for IHTMLDocument2
	IHTMLDocument2 *pdoc2Document;
	hr = pdispDocument->QueryInterface( IID_TO_PPV( IHTMLDocument2, &pdoc2Document ) );
	ReleaseInterface( pdispDocument );
	CheckHR( hr, "failed to qi dispatch from get_document for IHTMLDocument2", cleanup );

	//call get_all on the pointer to IHTMLDocument2 getting an IHTMLElementCollection
	IHTMLElementCollection *pelmcolAll;
	hr = pdoc2Document->get_all( &pelmcolAll );
	ReleaseInterface( pdoc2Document );
	CheckHR( hr, "failed to get the all collection from the document", cleanup );
	
	//create a variant which is the index we want if more than one element has the same name (0)
	VARIANT varIndex;
	VariantInit( &varIndex );
	V_VT(&varIndex) = VT_I4;
	V_I4(&varIndex) = 0;

	IDispatch *pdispTarget;

	//call item on the IHTMLElementCollection using our target variant as the name to get
	//  getting back the IDispatch of the element
	hr = pelmcolAll->item( m_target, varIndex, &pdispTarget );
	ReleaseInterface( pelmcolAll );
	VariantClear( &varIndex );
	CheckHR( hr, "failed to get the target from the all collection", cleanup );

	if( pdispTarget == NULL )
	{
		hr = E_FAIL;
		goto cleanup;
	}

	//Query the Element returned for IHTMLElement2 setting m_pTargetElement2
	hr = pdispTarget->QueryInterface( IID_TO_PPV( IHTMLElement2, &m_pTargetElement2 ) );
	ReleaseInterface(pdispTarget);
	CheckHR( hr, "failed to get IHTMLElement2 from the dispatch returned by item", cleanup );

cleanup:

	return hr;
}

//*****************************************************************************

bool
CAvoidFollowBvr::IsTargetPosLegal()
{
	if( m_targetType != targetMouse )
		return true;

	if( m_pBody2 == NULL )
		CacheBody2();

	if( m_pBody2 != NULL )
	{
		HRESULT hr;

		long width = 0;
		long height = 0;

		hr = GetElementClientDimension( m_pBody2, &width, &height );
		CheckHR( hr, "Failed to get the dimension of the body", done );

		return  ( ( m_targetClientLeft >= 0 && m_targetClientLeft <= width ) && 
				  ( m_targetClientTop >=0 && m_targetClientTop <= height ) );

	}
done:
	return false;
}

//*****************************************************************************

bool
CAvoidFollowBvr::IsElementAbsolute( IHTMLElement2 *pElement2 )
{
	HRESULT hr = E_FAIL;

	BSTR position = NULL;

	IHTMLCurrentStyle *pCurrentStyle;
	hr = pElement2->get_currentStyle( &pCurrentStyle );
	CheckHR( hr, "Failed to get the current style from pElement2", cleanup );
	CheckPtr( pCurrentStyle, hr, E_FAIL, "Pointer returned from get_currentStyle was null", cleanup );

	hr = pCurrentStyle->get_position( &position );
	ReleaseInterface( pCurrentStyle );
	CheckHR( hr, "Failed to get the position from the currentStyle", cleanup );

	if( position != NULL && _wcsicmp( position, L"absolute" ) == 0 )
		return true;

	SysFreeString( position );

cleanup:
		return false;
}


//*****************************************************************************


HRESULT
CAvoidFollowBvr::MapToLocal( long *pX, long *pY )
{
    if( pX == NULL || pY == NULL )
        return E_INVALIDARG;

    if( m_pAnimatedElement == NULL )
        return E_FAIL;

    HRESULT hr = E_FAIL;
    
    IHTMLElement *pelemNext = NULL;
    IHTMLElement *pelemCur = NULL;

	long curX = 0;
	long curY = 0;

    hr = m_pAnimatedElement->get_offsetParent( &pelemCur );
    CheckHR( hr, "Failed to get the offset Parent of the animated element", cleanup );

    while( pelemCur != NULL )
    {

		hr = pelemCur->get_offsetLeft( &curX );
		CheckHR( hr, "Could not get the offset left from the current element", cleanup );

		hr = pelemCur->get_offsetTop( &curY );
		CheckHR( hr, "Could not get offsetTop from the current element", cleanup );

		(*pX) -= curX;
		(*pY) -= curY;

        hr = pelemCur->get_offsetParent( &pelemNext );
        CheckHR( hr, "Failed to get the offset parent of the current element", cleanup );

        ReleaseInterface( pelemCur );

        pelemCur = pelemNext;
        pelemNext = NULL;

    }

	//in some cases trident forgets that the body has a position of 2, 2
	(*pX) -=2;
	(*pY) -=2;

cleanup:

    ReleaseInterface( pelemCur );

    return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::UpdateSourcePos()
{
	if( m_pAnimatedElement == NULL || m_pAnimatedElement2 == NULL )
		return E_FAIL;

    HRESULT hr = E_FAIL;

    hr = m_pAnimatedElement->get_offsetLeft( &m_sourceLeft );
	CheckHR( hr, "failed to get the offset Left of the target element", cleanup );

    hr = m_pAnimatedElement->get_offsetTop( &m_sourceTop );
	CheckHR( hr, "failed to get the offset Top of the target element", cleanup );

	long width;
	long height;

	//offset for the center of the element;
	hr = GetElementClientDimension( m_pAnimatedElement2, &width, &height );
	CheckHR( hr, "failed to get the element's client dimension", cleanup );

	m_sourceLeft += width/2;
	m_sourceTop +=height/2;


cleanup:
    return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::UpdateTargetPos( )
{

	HRESULT hr = E_FAIL;

	//if the target is an element ( not the mouse )
	if( m_targetType == targetElement )
	{
		//get the target element
		if( m_pTargetElement2 == NULL )
		{
			hr = FindTargetElement();
			CheckHR( hr, "failed to find the target element", cleanup );
		}
		//get the position of the target element
		hr = GetElementClientPosition( m_pTargetElement2, &m_targetLeft, &m_targetTop );
		CheckHR( hr, "failed to get the client position of the target element", cleanup );
	} 
	else if( m_targetType == targetMouse ) //else the target is the mouse pointer
	{
		//get the top left offset of the trident window
		hr = UpdateWindowTopLeft();  
		//if we got the top left of the window
		if( SUCCEEDED( hr ) )
		{
			
			//get the mouse position
			POINT mousePos;
			mousePos.x = mousePos.y = 0;
			GetCursorPos( &mousePos ); 
			//translate the mouse position into trident window space
			m_targetLeft = mousePos.x - m_screenLeft;
			m_targetTop = mousePos.y - m_screenTop;
			m_targetClientLeft = m_targetLeft;
			m_targetClientTop = m_targetTop;

		}
	}else //else target is unknown return an error
	{
		hr = E_FAIL;
	}

	hr = MapToLocal( &m_targetLeft, &m_targetTop );
	CheckHR( hr, "failed to map the target Position into local space", cleanup );

cleanup:

	return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::CacheWindow3()
{
	HRESULT hr = E_FAIL;

	if( m_pWindow3 != NULL )
		ReleaseInterface( m_pWindow3 );

	if( m_pElement == NULL )
	{
		return E_FAIL;
	}

	IDispatch *pDocumentDispatch;
	hr = m_pElement->get_document( &pDocumentDispatch );
	if( SUCCEEDED( hr ) )
	{
		IHTMLDocument2 *pDocument2;
		hr = pDocumentDispatch->QueryInterface( IID_TO_PPV( IHTMLDocument2, &pDocument2 ) );
		ReleaseInterface( pDocumentDispatch );
		if( SUCCEEDED( hr ) )
		{
			IHTMLWindow2 *pWindow2;
			hr = pDocument2->get_parentWindow( &pWindow2 );
			ReleaseInterface( pDocument2 );
			if( SUCCEEDED( hr ) )
			{
				IHTMLWindow3 *pWindow3;
				hr = pWindow2->QueryInterface( IID_TO_PPV( IHTMLWindow3, &pWindow3 ) );
				ReleaseInterface( pWindow2 );
				if( SUCCEEDED( hr ) )
				{
					m_pWindow3 = pWindow3;
					hr = S_OK;
				}
				else  //QI failed for IHTMLWindow3 on IHTMLWindow2
				{
					DPF_ERR( "AvoidFollow: QI for IHTMLWindow3 on IHTMLWindow2 failed" );
				}
			}
			else //getParentWindow on IHTMLDocument2 failed
			{
				DPF_ERR( "AvoidFollow: getParentWindow on IHTMLDocument2 failed" );
			}
		}
		else  //QI for IHTMLDocument2 on IHTMLDocument failed
		{
			DPF_ERR( "AvoidFollow: QI for IHTMLDocument2 on IHTMLDocument failed" );
		}
	}
	else  //failed to get the document from the animated element
	{
		DPF_ERR( "AvoidFollow: failed to get the document from the animated element" );
	}

	return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::CacheBody2()
{
	if( m_pElement == NULL )
		return E_FAIL;

	if( m_pBody2 != NULL )
		ReleaseInterface( m_pBody2 );

	HRESULT hr = E_FAIL;


	IDispatch *pdispDocument;
	hr = m_pElement->get_document( &pdispDocument );
	CheckHR( hr, "failed to get the document from element", cleanup );

	CheckPtr( pdispDocument, hr, E_FAIL, "pointer returned from get_document was null", cleanup );

	IHTMLDocument2 *pdoc2Document;
	hr = pdispDocument->QueryInterface( IID_TO_PPV( IHTMLDocument2, &pdoc2Document ) );
	ReleaseInterface( pdispDocument );
	CheckHR( hr, "Failed to get IHTMLDocument 2 from the document dispatch", cleanup );

	IHTMLElement *pelemBody;
	hr = pdoc2Document->get_body( &pelemBody );
	ReleaseInterface( pdoc2Document );
	CheckHR( hr, "Failed to get the body from the document", cleanup );
	CheckPtr( pelemBody, hr, E_FAIL, "Body returned from get_body was null", cleanup );

	hr = pelemBody->QueryInterface( IID_TO_PPV( IHTMLElement2, &m_pBody2 ) );
	ReleaseInterface( pelemBody );
	CheckHR( hr, "Failed to get IHTMLElement2 from the body element", cleanup );


cleanup:
	return hr;

}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::UpdateWindowTopLeft( )
{
	HRESULT hr = E_FAIL;

	if( m_pWindow3 == NULL )
		CacheWindow3();
	
	if( m_pWindow3 != NULL )
	{
		hr = m_pWindow3->get_screenLeft( &m_screenLeft );
		if( SUCCEEDED( hr ) )
		{
			hr = m_pWindow3->get_screenTop( &m_screenTop );
			if( FAILED( hr ) )//failed to get screen top from IHTMLWindow3
			{
				DPF_ERR( "AvoidFollow: could not get screen top from IHTMLWindow3" );
			}
		}
		else //failed to get left from window3 
		{
			DPF_ERR( "AvoidFollow: could not get screen left from IHTMLWindow3" );
		}
	}
	else  //Could not Cache IHTMLWindow3
	{
		DPF_ERR( "AvoidFollow: Could not Cache IHTMLWindow3" );
		hr = E_FAIL;
	}

	return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::GetElementClientPosition( IHTMLElement2 *pElement2, long *pLeft, long* pTop )
{
	if( pElement2 == NULL || pLeft == NULL || pTop == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;

	IHTMLRect *prectBBox = NULL;

	hr = pElement2->getBoundingClientRect( &prectBBox );
	CheckHR( hr, "failed to get the bounding client rect of the element", cleanup );
	CheckPtr( prectBBox, hr, E_FAIL, "pointer returned from getBounding ClientRect was NULL", cleanup );

	//get the top and left from the IHTMLRect
	hr = prectBBox->get_left( pLeft );
	CheckHR( hr, "failed to get the left coordiante of the bbox", cleanup );

	hr = prectBBox->get_top( pTop );
	CheckHR( hr, "failed to get the top coordiante of the bbox", cleanup );

cleanup:

	if( FAILED( hr ) )
	{
		(*pLeft) = 0;
		(*pTop) = 0;
	}

	ReleaseInterface( prectBBox );

	return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::GetElementClientDimension( IHTMLElement2 *pElement2, long *pWidth, long* pHeight )
{
	if( pElement2 == NULL || pWidth == NULL || pHeight == NULL )
		return E_INVALIDARG;


    HRESULT hr = E_FAIL;


    long left = 0;
    long top = 0;
    long right =0;
    long bottom = 0;

    IHTMLRect *prectBBox = NULL;
	hr = pElement2->getBoundingClientRect( &prectBBox );
	CheckHR( hr, "failed to get the bounding client rect of the element", cleanup );
	CheckPtr( prectBBox, hr, E_FAIL, "pointer returned from getBounding ClientRect was NULL", cleanup );

	//get the top and left from the IHTMLRect

	hr = prectBBox->get_left( &left );
	CheckHR( hr, "failed to get the left of the bbox", cleanup );

	hr = prectBBox->get_top( &top );
	CheckHR( hr, "failed to get the top of the bbox", cleanup );

    hr = prectBBox->get_right( &right );
	CheckHR( hr, "failed to get the right of the bbox", cleanup );

	hr = prectBBox->get_bottom( &bottom );
	CheckHR( hr, "failed to get the bottom of the bbox", cleanup );

    (*pWidth) = right - left;
    (*pHeight) = bottom - top;


cleanup:

	if( FAILED( hr ) )
	{
		(*pWidth) = 0;
		(*pHeight) = 0;
	}

    ReleaseInterface( prectBBox );

	return hr;
}
//*****************************************************************************


HRESULT
CAvoidFollowBvr::SetTargetType()
{
	HRESULT hr = E_FAIL;

	hr = CUtils::InsurePropertyVariantAsBSTR( &m_target );
	if( SUCCEEDED( hr ) )
	{
		if( V_BSTR(&m_target) == NULL  || 
			_wcsicmp( TARGET_MOUSE, V_BSTR(&m_target) ) == 0 )
		{
			m_targetType = targetMouse;
		}
		else
		{
			m_targetType = targetElement;
		}

	}
	else //failed to insure that the target property was a bstr
	{
		m_targetType = targetMouse;
		hr = S_OK;
	}

	return hr;

}

//*****************************************************************************

HRESULT 
CAvoidFollowBvr::BuildAnimationAsDABehavior()
{
	return S_OK;
} // BuildAnimationAsDABehavior


//*****************************************************************************


HRESULT
CAvoidFollowBvr::SampleOnBvr(void *thisPtr,
							 double startTime,
							 double globalNow,
							 double localNow,
							 IDABehavior * sampleVal)
{
	return reinterpret_cast<CAvoidFollowBvr*>(thisPtr)->Sample( startTime, 
															   globalNow, 
															   localNow, 
															   sampleVal );
}


//*****************************************************************************

HRESULT
CAvoidFollowBvr::Sample( double startTime, double globalNow, double localNow, IDABehavior *sampleVal )
{
	HRESULT hr = E_FAIL;

	VARIANT_BOOL on = VARIANT_FALSE;

	IDABoolean *pdaboolSample;
	hr = sampleVal->QueryInterface( IID_TO_PPV( IDABoolean, &pdaboolSample) );
	if( FAILED( hr ) )
		return S_OK;

	hr = pdaboolSample->Extract( &on );
	ReleaseInterface( pdaboolSample );
	if( FAILED ( hr ) )
		return S_OK;

	//if we are not on, there is nothing to do.
	if( on == VARIANT_FALSE)
		return S_OK;

	//if we just turned on set the last sample time.
	if( on != m_lastOn )
		m_lastSampleTime = globalNow;

	m_lastOn = on;

	m_timeDelta = globalNow - m_lastSampleTime;
	m_lastSampleTime = globalNow;

	if( m_timeDelta == 0.0 )
		return S_OK;
	
	if( m_timeDelta < 0 )
		m_timeDelta = -m_timeDelta;

	hr = UpdateTargetPos();
	if( FAILED( hr ) )
		return S_OK;

	if( !IsTargetPosLegal() )
		return S_OK;

	hr = UpdateSourcePos();

	if( FAILED( hr ) )
		return S_OK;
    


    //ensure that the translation that we applied has taken effect
    //TODO: this does not account for transforms applied by other behaviors.
	//  currently this is okay since this is an absolute behavior.
    if( m_originalX + m_currentX != m_sourceLeft ||
        m_originalY + m_currentY != m_sourceTop )
        return S_OK;

	double xToTarget = m_targetLeft-m_sourceLeft;
	double yToTarget = m_targetTop-m_sourceTop;//y is inverted

	double distanceToTarget = sqrt( (xToTarget*xToTarget) + (yToTarget*yToTarget) );
	
	if( distanceToTarget > m_dRadius || distanceToTarget == 0)
		//bail, the target is beyond our sensitive radius
		return S_OK;

	double xMove = xToTarget;
	double yMove = yToTarget;

	double totalMove = m_timeDelta * m_dVelocity;

	//if we are following and we have reached the target in this step
	if( distanceToTarget > totalMove )
	{
		xMove *= totalMove/distanceToTarget;
        yMove *= totalMove/distanceToTarget;
	}


	m_currentX += static_cast<long>( xMove );
	m_currentY += static_cast<long>( yMove );

	hr = m_leftBvr->SwitchToNumber(  m_originalLeft + m_currentX );
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to switch in the left bvr" );
	}
	hr = m_topBvr->SwitchToNumber(  m_originalTop + m_currentY );
	if( FAILED( hr ) )
	{
		DPF_ERR( "failed to switch in the top bvr" );
	}

    return S_OK;
}

//*****************************************************************************
//ILMAvoidFollowBvr
//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::put_animates( VARIANT varAnimates )
{
    return SUPER::SetAnimatesProperty( varAnimates );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::get_animates( VARIANT *varAnimates )
{
    return SUPER::GetAnimatesProperty( varAnimates );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::put_radius( VARIANT varRadius )
{
    return VariantCopy( &m_radius, &varRadius );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::get_radius( VARIANT *varRadius )
{
    return VariantCopy( varRadius, &m_radius );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::put_target( VARIANT varTarget )
{
    return VariantCopy( &m_target, &varTarget );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::get_target( VARIANT *varTarget )
{
    return VariantCopy( varTarget, &m_target );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::put_velocity( VARIANT varVelocity )
{
    return VariantCopy( &m_velocity, &varVelocity );
}

//*****************************************************************************

STDMETHODIMP 
CAvoidFollowBvr::get_velocity( VARIANT *varVelocity )
{
    return VariantCopy( varVelocity, &m_velocity );
}

//*****************************************************************************
STDMETHODIMP
CAvoidFollowBvr::buildBehaviorFragments( IDispatch *pActorDisp )
{
	if( pActorDisp == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	m_lastOn = VARIANT_FALSE;		

	IDA2Statics *statics = GetDAStatics();
	IDATransform2 *transform = NULL;

	hr = GetElementToAnimate( &m_pAnimatedElement );
	CheckHR( hr, "Failed to get the animated element", cleanup );

	hr = m_pAnimatedElement->QueryInterface( IID_TO_PPV( IHTMLElement2, &m_pAnimatedElement2 ) );
	CheckHR( hr, "Failed to query the animatedElement for IHTMLElement2", cleanup );

	hr = SetTargetType();
	CheckHR( hr, "Failed to set the target type", cleanup );


	hr = UpdateTargetPos();
	CheckHR( hr, "Failed to update the target Position", cleanup );

    hr = UpdateSourcePos();
    CheckHR( hr, "Failed to update the source position", cleanup );

    m_originalX = m_sourceLeft;
    m_originalY = m_sourceTop;

    if( IsElementAbsolute( m_pAnimatedElement2 ) )
	{
		hr= m_pAnimatedElement->get_offsetLeft( &m_originalLeft );
		CheckHR( hr, "Failed to get the original Left", cleanup );

		hr = m_pAnimatedElement->get_offsetTop( &m_originalTop );
		CheckHR( hr, "Failed to get the original Top", cleanup );
	}
	else
	{
		m_originalLeft = 0;
		m_originalTop = 0;
	}

	hr = CUtils::InsurePropertyVariantAsFloat( &m_radius );
	if( SUCCEEDED( hr ) )
	{
		m_dRadius = static_cast<double>(V_R4(&m_radius));
	}
	else
	{
		m_dRadius = DEFAULT_RADIUS;
	}

	hr = CUtils::InsurePropertyVariantAsFloat( &m_velocity );
	if( SUCCEEDED( hr ) )
	{
		m_dVelocity = - (static_cast<double>(V_R4(&m_velocity)));
	}
	else
	{
		m_dVelocity = 10.0;
	}

	hr = statics->ModifiableNumber( m_originalLeft, &m_leftBvr );
	CheckHR( hr, "Failed to create a modifiable number for the left bvr", cleanup );

	hr = statics->ModifiableNumber( m_originalTop, &m_topBvr );
	CheckHR( hr, "Failed to create a modifiable number for the top bvr", cleanup );

	hr = statics->Translate2Anim( m_leftBvr, m_topBvr, &transform );
	CheckHR( hr, "Failed to create a translate2 behavior for the total translation", cleanup );

	hr = AttachBehaviorToActor( pActorDisp,
							transform, 
							L"Translation",
							e_Absolute,
							e_Translation );

	IDABoolean *onBvr;
	hr = GetTIMEBooleanBehavior( &onBvr );
	CheckHR( hr, "Failed to get the boolean behavior from time", cleanup );

	IDABehavior *hookedBehavior;
	hr = m_sampler->Attach( onBvr, &hookedBehavior );
	ReleaseInterface( onBvr );
	CheckHR( hr, "Failed to attach the sampler to the on behavior", cleanup );

	hr = AddBehaviorToTIME( hookedBehavior );
	ReleaseInterface( hookedBehavior );
	CheckHR( hr, "Failed to add the on behavior to TIME", cleanup );


cleanup:
	ReleaseInterface( transform );

    if( FAILED( hr ) )
    {
        ReleaseDAInterfaces();
        ReleaseTridentInterfaces();
    }

    return hr;
}

//*****************************************************************************
//End ILMAvoidFollowBvr
//*****************************************************************************

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\autoeffect.cpp ===
//*****************************************************************************
//
// File:            autoeffect.cpp
// Author:          markhal, elainela
// Date Created:    11/10/98
//
// Abstract: Implementation of the Liquid Motion auto effect behavior as
//           a DHTML behavior.
//
//*****************************************************************************

#include "headers.h"

#include "autoeffect.h"
#include "lmattrib.h"
#include "lmdefaults.h"
#include "..\idl\lmbvrdispid.h"
#include "..\chrome\src\dautil.h"
#include "..\chrome\include\utils.h"

#undef THIS
#define THIS CAutoEffectBvr
#define SUPER CBaseBehavior

#include "..\chrome\src\pbagimp.cpp"

static const	int		RAND_PRECISION		= 1000;

static const	long	MAX_SPARKS			= 40;
static const	double	MIN_MAXAGE			= 0.04;
static const	double	MIN_DELTABIRTH		= 0.005;
static const	double	SPARK_BASESIZE		= 4.0;
static const	long	SPARK_OFFSET		= 10;

const WCHAR * const CAutoEffectBvr::RGSZ_CAUSES[ NUM_CAUSES ] =
{
	L"time",
	L"onmousemove",
	L"ondragover",
	L"onmousedown"
};

const WCHAR * const CAutoEffectBvr::RGSZ_TYPES[ CSparkMaker::NUM_TYPES ] =
{
	L"sparkles",
	L"twirlers",
	L"bubbles",
	L"filledbubbles",
	L"clouds",
	L"smoke"
};

#define VAR_TYPE		0
#define VAR_CAUSE		1
#define VAR_SPAN		2 
#define VAR_SIZE		3 
#define VAR_RATE		4 
#define VAR_GRAVITY		5
#define VAR_WIND		6 
#define VAR_FILLCOLOR	7
#define VAR_STROKECOLOR 8
#define VAR_OPACITY		9

WCHAR * CAutoEffectBvr::m_rgPropNames[] = {
									 BEHAVIOR_PROPERTY_TYPE,
									 BEHAVIOR_PROPERTY_CAUSE,
									 BEHAVIOR_PROPERTY_SPAN,
									 BEHAVIOR_PROPERTY_SIZE,
									 BEHAVIOR_PROPERTY_RATE,
									 BEHAVIOR_PROPERTY_GRAVITY,
									 BEHAVIOR_PROPERTY_WIND,
									 BEHAVIOR_PROPERTY_FILLCOLOR,
									 BEHAVIOR_PROPERTY_STROKECOLOR,
									 BEHAVIOR_PROPERTY_OPACITY
									};

//*****************************************************************************

CAutoEffectBvr::CAutoEffectBvr()
{
	m_pdispActor	= NULL;

	m_lCookie 		= 0;

	m_pSampler		= NULL;
	
	m_pSparkMaker	= NULL;
	m_eType			= CSparkMaker::SPARKLES;
	m_eCause		= CAUSE_TIME;
	
	// REVIEW: These numbers should never actually be used.
	m_dBirthDelta	= 1.0/3.0;
	m_dMaxAge		= 3.0;
	m_fScaledSize	= 5.0f;
	m_fXVelocity	= 0.0f;
	m_fYVelocity	= 0.0f;
	
	m_dLastBirth	= 0;

	VariantInit( &m_type );
	VariantInit( &m_cause );
	VariantInit( &m_span );
	VariantInit( &m_size );
	VariantInit( &m_rate );
	VariantInit( &m_gravity );
	VariantInit( &m_wind );
	VariantInit( &m_fillColor );
	VariantInit( &m_strokeColor );
	VariantInit( &m_opacity );
}

//*****************************************************************************

CAutoEffectBvr::~CAutoEffectBvr()
{
	if( m_pSampler != NULL )
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}

	delete m_pSparkMaker;
	
	VariantClear( &m_type );
	VariantClear( &m_cause );
	VariantClear( &m_span );
	VariantClear( &m_size );
	VariantClear( &m_rate );
	VariantClear( &m_gravity );
	VariantClear( &m_wind );
	VariantClear( &m_fillColor );
	VariantClear( &m_strokeColor );
	VariantClear( &m_opacity );
}

//*****************************************************************************

HRESULT 
CAutoEffectBvr::FinalConstruct()
{

	HRESULT hr = SUPER::FinalConstruct();
	if (FAILED(hr))
	{
		DPF_ERR("Error in auto effect behavior FinalConstruct initializing base classes");
		return hr;
	}
	return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CAutoEffectBvr::VariantFromIndex(ULONG iIndex)
{
	DASSERT(iIndex < NUM_AUTOEFFECT_PROPS);
	switch (iIndex)
	{
	case VAR_TYPE:
		return &m_type;
		break;
	case VAR_CAUSE:
		return &m_cause;
		break;
	case VAR_SPAN:
		return &m_span;
		break;
	case VAR_SIZE:
		return &m_size;
		break;
	case VAR_RATE:
		return &m_rate;
		break;
	case VAR_GRAVITY:
		return &m_gravity;
		break;
	case VAR_WIND:
		return &m_wind;
		break;
	case VAR_FILLCOLOR:
		return &m_fillColor;
		break;
	case VAR_STROKECOLOR:
		return &m_strokeColor;
		break;
	case VAR_OPACITY:
		return &m_opacity;
		break;
	default:
		// We should never get here
		DASSERT(false);
		return NULL;
	}
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CAutoEffectBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
	*pulProperties = NUM_AUTOEFFECT_PROPS;
	*pppPropNames = m_rgPropNames;
	return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;

} // Notify

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::Detach()
{
	if ( m_pdispActor )
	{
		AddMouseEventListener( false );
	}

	HRESULT hr = S_OK;

	if( m_pSampler != NULL )
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}

	hr = RemoveFragment();

	m_pdispActor.Release();
	
	hr = SUPER::Detach();

	CheckHR( hr, "Failed to remove the behavior fragment from this behavior", end );

end:
	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::Sample( double dStart, double dGlobalNow, double dLocalNow )
{
	if ( m_pSparkMaker == NULL ) return S_OK;
	
	HRESULT		hr = S_OK;

	// Never run before, or starting over again?  Reset sparks
	if ( ( m_dLocalTime < 0.0 ) || ( dLocalNow < m_dLocalTime ) )
		ResetSparks( 0.0 );
	else
		AgeSparks( dLocalNow - m_dLocalTime );

	m_dLocalTime = dLocalNow;
	
	if ( m_eCause == CAUSE_TIME )
	{
		PossiblyAddSparks( dLocalNow );
	}
	
	return	hr;

} // Sample

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
	HRESULT hr = S_OK;

	hr = RemoveFragment();
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to remove the behavior fragment" );
		return hr;
	}

	if( m_pSampler != NULL )
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}

	m_pSampler = new CSampler( this );


	// HACK: This is just so we can test the progress number
	if (V_VT(&m_type) == VT_BSTR && wcsicmp(V_BSTR(&m_type), L"progress") == 0)
	{
		CComPtr<IDANumber> pProgress;
		
		hr = GetTIMEProgressNumber(&pProgress);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAString> pProgressString;

		hr = pProgress->ToString(5, &pProgressString);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAFontStyle> pDefaultFont;

		hr = GetDAStatics()->get_DefaultFont(&pDefaultFont);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAImage> pProgressImage;

		hr = GetDAStatics()->StringImageAnim(pProgressString, pDefaultFont, &pProgressImage);
		LMRETURNIFFAILED(hr);

		IDispatch* pdispThis = NULL;

		hr = GetHTMLElementDispatch( &pdispThis );
		if( FAILED( hr ) )
		{
			DPF_ERR( "failed to get IDispatch from the element" );
			return hr;
		}
		
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pProgressImage, 
									  L"image", 
									  e_Relative, 
									  e_Image,
									  pdispThis,
									  &m_lCookie);
		ReleaseInterface( pdispThis );
		LMRETURNIFFAILED(hr);

		m_pdispActor = pActorDisp;
		
		return S_OK;
	}

	// HACK: This is just so we can test the timeline number
	if (V_VT(&m_type) == VT_BSTR && wcsicmp(V_BSTR(&m_type), L"timeline") == 0)
	{
		CComPtr<IDANumber> pProgress;
		
		hr = GetTIMETimelineBehavior(&pProgress);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAString> pProgressString;

		hr = pProgress->ToString(5, &pProgressString);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAFontStyle> pDefaultFont;

		hr = GetDAStatics()->get_DefaultFont(&pDefaultFont);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAImage> pProgressImage;

		hr = GetDAStatics()->StringImageAnim(pProgressString, pDefaultFont, &pProgressImage);
		LMRETURNIFFAILED(hr);

		IDispatch* pdispThis = NULL;

		hr = GetHTMLElementDispatch( &pdispThis );
		if( FAILED( hr ) )
		{
			DPF_ERR( "failed to get IDispatch from the element" );
			return hr;
		}
		
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pProgressImage, 
									  L"image", 
									  e_Relative, 
									  e_Image,
									  pdispThis,
									  &m_lCookie);
		ReleaseInterface( pdispThis );
		LMRETURNIFFAILED(hr);

		m_pdispActor = pActorDisp;
		
		return S_OK;
	}

	// HACK: This is just so we can display the framerate number
	if (V_VT(&m_type) == VT_BSTR && wcsicmp(V_BSTR(&m_type), L"framerate") == 0)
	{
		CComQIPtr<IDA2Statics, &IID_IDA2Statics> pStatics2(GetDAStatics());

		if (pStatics2 == NULL)
			return E_FAIL;

		CComPtr<IDANumber> pFrameRate;

		hr = pStatics2->get_ViewFrameRate(&pFrameRate);
		LMRETURNIFFAILED(hr);
		
		CComPtr<IDAString> pString;

		hr = pFrameRate->ToString(5, &pString);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAFontStyle> pDefaultFont;

		hr = GetDAStatics()->get_DefaultFont(&pDefaultFont);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAImage> pImage;

		hr = GetDAStatics()->StringImageAnim(pString, pDefaultFont, &pImage);
		LMRETURNIFFAILED(hr);

		IDispatch* pdispThis = NULL;

		hr = GetHTMLElementDispatch( &pdispThis );
		if( FAILED( hr ) )
		{
			DPF_ERR( "failed to get IDispatch from the element" );
			return hr;
		}
		
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pImage, 
									  L"image", 
									  e_Relative, 
									  e_Image,
									  pdispThis,
									  &m_lCookie);
		ReleaseInterface( pdispThis );
		LMRETURNIFFAILED(hr);

		m_pdispActor = pActorDisp;
		
		return S_OK;
	}

	// HACK: This is also a hack to return a solid red image
	if (V_VT(&m_type) == VT_BSTR && wcsicmp(V_BSTR(&m_type), L"red") == 0)
	{
		CComPtr<IDAColor> pColor;
		hr = GetDAStatics()->get_Red(&pColor);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAImage> pImage;
		hr = GetDAStatics()->SolidColorImage(pColor, &pImage);
		LMRETURNIFFAILED(hr);

		IDispatch* pdispThis = NULL;

		hr = GetHTMLElementDispatch( &pdispThis );
		if( FAILED( hr ) )
		{
			DPF_ERR( "failed to get IDispatch from the element" );
			return hr;
		}
		
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pImage, 
									  L"image", 
									  e_Relative, 
									  e_Image,
									  pdispThis,
									  &m_lCookie);
		ReleaseInterface( pdispThis );
		LMRETURNIFFAILED(hr);

		m_pdispActor = pActorDisp;
		
		return S_OK;
	}

	m_pdispActor = pActorDisp;

	hr = AddMouseEventListener( true );
	LMRETURNIFFAILED(hr);

	
	IDAStatics * pStatics = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;

	// Initialize internal representation of properties
	//----------------------------------------------------------------------
	hr = InitInternalProperties();
	LMRETURNIFFAILED(hr);

	// Initialize sparks
	//----------------------------------------------------------------------
	hr = InitSparks();
	LMRETURNIFFAILED(hr);

	CComPtr<IUnknown> pUnkDAArray( m_pDAArraySparks );
	CComPtr<IDAImage> pImageBvr;
	CComVariant		  varDAArray( pUnkDAArray );

	hr = pStatics->OverlayArray( varDAArray, &pImageBvr );
	LMRETURNIFFAILED(hr);
/*
  if (m_fOpacity != 1.0f)
  {
  // We have to add in some opacity
  CComPtr<IDAImage> pOpacityImage;
  hr = pImageBvr->Opacity(m_fOpacity, &pOpacityImage);
  LMRETURNIFFAILED(hr);
		
  pImageBvr = pOpacityImage;
  }
*/
	// We have the resultant behavior; we want to sample it in order
	// to update it
	//----------------------------------------------------------------------
	CComQIPtr<IDABehavior, &IID_IDABehavior> pBvrOrig( pImageBvr );
	CComPtr<IDABehavior> pBvrSampled;

	hr = m_pSampler->Attach( pBvrOrig, &pBvrSampled );
	LMRETURNIFFAILED(hr);

	// Substitute timeline behavior so that Sample() calls us with our local time
	//----------------------------------------------------------------------
	CComPtr<IDANumber> 		pnumTimeline;
	CComPtr<IDABehavior> 	pBvrLocal;
	
	hr = GetTIMETimelineBehavior( &pnumTimeline );
	LMRETURNIFFAILED(hr);

	hr = pBvrSampled->SubstituteTime( pnumTimeline, &pBvrLocal );
	LMRETURNIFFAILED(hr);
	
	CComQIPtr<IDAImage, &IID_IDAImage> pImgBvrLocal( pBvrLocal );
	if ( pImgBvrLocal == NULL )
		return E_FAIL;

	// Attach behavior to the actor
	//----------------------------------------------------------------------

	IDispatch* pdispThis = NULL;

	hr = GetHTMLElementDispatch( &pdispThis );
	if( FAILED( hr ) )
	{
		DPF_ERR( "failed to get IDispatch from the element" );
		return hr;
	}
	
	hr = AttachBehaviorToActorEx( pActorDisp, 
								  pImgBvrLocal, 
								  L"image", 
								  e_ScaledImage, 
								  e_Image,
								  pdispThis,
								  &m_lCookie );

	ReleaseInterface( pdispThis );
	if (FAILED(hr))
	{
		DPF_ERR("Error building animation");
		return SetErrorInfo(hr);
	}

	return S_OK;

} // buildBehaviorFragments

HRESULT
CAutoEffectBvr::InitInternalProperties()
{
	HRESULT	hr;

	// Type -- initialize SparkMaker
	//----------------------------------------------------------------------
	delete m_pSparkMaker, m_pSparkMaker = NULL;

	CComBSTR bstrType = RGSZ_TYPES[ CSparkMaker::SPARKLES ];
	HRESULT hrTmp = CUtils::InsurePropertyVariantAsBSTR( &m_type );
	if ( SUCCEEDED(hrTmp) )
		bstrType = V_BSTR( &m_type );

	for ( int i = 0; i < CSparkMaker::NUM_TYPES; i++ )
	{
		if ( _wcsicmp( bstrType, RGSZ_TYPES[ i] ) == 0 )
		{
			m_eType = (CSparkMaker::Type) i;
			hr = CSparkMaker::CreateSparkMaker( GetDAStatics(),
												m_eType,
												&m_pSparkMaker );
			LMRETURNIFFAILED(hr);
			break;
		}
	}

	if ( m_pSparkMaker == NULL )
		return E_FAIL;
		
	// Cause
	//----------------------------------------------------------------------
	CComBSTR bstrCause = RGSZ_CAUSES[ CAUSE_TIME ];
	hrTmp = CUtils::InsurePropertyVariantAsBSTR( &m_cause );
	if ( SUCCEEDED(hrTmp) )
		bstrCause = V_BSTR( &m_cause );

	for ( i = 0; i < NUM_CAUSES; i++ )
	{
		if ( _wcsicmp( bstrCause, RGSZ_CAUSES[ i] ) == 0 )
		{
			m_eCause = (Cause) i;
			break;
		}
	}
	
	// Lifespan --> Maximum age
	//----------------------------------------------------------------------
	float fSpan = DEFAULT_AUTOEFFECT_SPAN;
	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_span );
	if ( SUCCEEDED(hrTmp) )
		fSpan = V_R4( &m_span );
	
	fSpan = __max( 0.0, __min( 1.0, fSpan ) );

	// Parabolic scale; make max 15 secs
	m_dMaxAge = fSpan*fSpan*15.0;
	m_dMaxAge = __max( MIN_MAXAGE, m_dMaxAge );
	
	// Size --> m_fScaledSize
	//----------------------------------------------------------------------
	float fSize = DEFAULT_AUTOEFFECT_SIZE;
	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_size );
	if ( SUCCEEDED(hrTmp) )
		fSize = V_R4( &m_size );

	fSize = __max( 0.0, __min( 1.0, fSize ) );
	
	fSize *= 2;
	m_fScaledSize = (fSize*fSize) * 10.0f;

	// Birthrate --> Birth Delta
	//----------------------------------------------------------------------
	float fRate = DEFAULT_AUTOEFFECT_RATE;
	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_rate );
	if ( SUCCEEDED(hrTmp) )
		fRate = V_R4( &m_rate );
	
	fRate = __max( 0.0, __min( 1.0, fRate ) );
		
	// 0 becomes high; 1 becomes low
	m_dBirthDelta = 1.0 - fRate;
	//	4*(v^4) -- high curve; max is 4 secs.
	m_dBirthDelta = 4*pow( m_dBirthDelta, 4 ) + MIN_DELTABIRTH;

	// Velocity
	//----------------------------------------------------------------------
	float	fXV = DEFAULT_AUTOEFFECT_WIND;
	float	fYV = DEFAULT_AUTOEFFECT_GRAVITY;

	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_wind );
	if ( SUCCEEDED(hrTmp) )
		fXV = V_R4( &m_wind );

	fXV = __max( -1.0, __min( 1.0, fXV ) );

	m_fXVelocity = fXV * 20.0;
	
	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_gravity );
	if ( SUCCEEDED(hrTmp) )
		fYV = V_R4( &m_gravity );

	fYV = __max( -1.0, __min( 1.0, fYV ) );
	
	m_fYVelocity = fYV * -40.0;

	// Opacity
	//----------------------------------------------------------------------
	float fOpacity = DEFAULT_AUTOEFFECT_OPACITY;
	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_opacity );
	if ( SUCCEEDED(hrTmp) )
		fOpacity = V_R4( &m_opacity );

	fOpacity = __max( 0.0, __min( 1.0, fOpacity ) );

	m_fOpacity = fOpacity;
	
	return hr;
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::InitSparks()
{
	HRESULT	hr = S_OK;
	
	// Cleanup from previous runs
	//----------------------------------------------------------------------
	if ( m_pDAArraySparks != NULL )
	{
		m_pDAArraySparks.Release();
	}

	// Initialize parameters for a run --
	// REVIEW: using same functions as LM 1.0
	//----------------------------------------------------------------------
	m_dLocalTime = -1.0;
	m_dLastBirth = -1.0;
	
	// Color behaviors
	//----------------------------------------------------------------------
	IDAStatics * pStatics = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;
	CComQIPtr<IDA2Statics, &IID_IDA2Statics> pStatics2( pStatics );
	
	HRESULT		hrTmp;
	DWORD		color1 = DEFAULT_AUTOEFFECT_FILLCOLOR;
	DWORD		color2 = DEFAULT_AUTOEFFECT_STROKECOLOR;
	float		h1, s1, l1;
	float		h2, s2, l2;
	
	hrTmp = CUtils::InsurePropertyVariantAsBSTR( &m_fillColor );
	if ( SUCCEEDED(hrTmp) )
		color1 = CUtils::GetColorFromVariant( &m_fillColor );
		
	hrTmp = CUtils::InsurePropertyVariantAsBSTR( &m_strokeColor );
	if ( SUCCEEDED(hrTmp) )
		color2 = CUtils::GetColorFromVariant( &m_strokeColor );

	HSL hsl;
	
	CUtils::GetHSLValue( color1, &hsl.hue, &hsl.sat, &hsl.lum );
	m_sparkOptions.hslPrimary = hsl;
	CUtils::GetHSLValue( color2, &hsl.hue, &hsl.sat, &hsl.lum );
	m_sparkOptions.hslSecondary = hsl;

	// Add an image behavior now; otherwise we don't get calls to Sample()
	// later
	//----------------------------------------------------------------------
	CComPtr<IDAImage> pImageEmpty;
	hr = pStatics->get_EmptyImage( &pImageEmpty );
	LMRETURNIFFAILED(hr);
		
	AddBvrToSparkArray( pImageEmpty );					

	return hr;
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::AddSpark()
{
	// Determine position & dimensions of our "canvas"
	CComPtr<IHTMLElement>	pElement;
	long					lWidth, lHeight;
	HRESULT					hr;
	
	hr = GetElementToAnimate( &pElement );
	LMRETURNIFFAILED(hr);

	hr = pElement->get_offsetWidth( &lWidth );
	LMRETURNIFFAILED(hr);
	hr = pElement->get_offsetHeight( &lHeight );
	LMRETURNIFFAILED(hr);

	// Origin is in the middle
	long x = lWidth == 0 ? 0 : ( 2 * (rand() % lWidth) - lWidth ) / 2;
	long y = lHeight == 0 ? 0 : ( 2 * (rand() % lHeight) - lHeight ) / 2;

	return AddSparkAt( x, y );
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::AddSparkAround( long x, long y)
{
	long xOff = (long) ((rand() % (2*SPARK_OFFSET)) - SPARK_OFFSET);
	long yOff = (long) ((rand() % (2*SPARK_OFFSET)) - SPARK_OFFSET);

	return AddSparkAt( x+xOff, y+yOff );
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::AddSparkAt( long x, long y)
{
	HRESULT				hr			= S_OK;

	// See if we can add element to existing array:	 try to reincarnate 
	// dead sparks if they exist.
	//----------------------------------------------------------------------
	bool				bReuseDeadSpark	= false;
	VecSparks::iterator itSpark				= m_vecSparks.begin();

	for ( itSpark = m_vecSparks.begin();
		  itSpark != m_vecSparks.end();
		  itSpark++ )
	
	{
		if ( !itSpark->IsAlive() )
		{
			bReuseDeadSpark = true;
			break;
		}
	}

	// We allow at most MAX_SPARKS in our array
	//----------------------------------------------------------------------
	if ( !bReuseDeadSpark && m_vecSparks.size() == MAX_SPARKS )
		return S_FALSE;
		 
	// Create spark
	//----------------------------------------------------------------------
	CComPtr<IDAImage>	pImageBvr;

	float fSize = SPARK_BASESIZE +
		m_fScaledSize * ( (rand()%RAND_PRECISION)/((float) RAND_PRECISION) );
	
	hr = CreateSparkBvr( &pImageBvr, (float) x, (float) y, fSize );
	LMRETURNIFFAILED(hr);

	// Reuse a dead spark if we have one.  If we have to create a new spark,
	// we need to add a new modifiable behavior to the DAArray.
	//----------------------------------------------------------------------
	if ( bReuseDeadSpark )
		itSpark->Reincarnate( pImageBvr, 0.0 );
	else
		AddBvrToSparkArray( pImageBvr );

	return hr;
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::CreateSparkBvr( IDAImage ** ppImageBvr, float fX, float fY, float fSize )
{
	DASSERT( ppImageBvr != NULL );

	if ( m_pSparkMaker == NULL ) return E_FAIL;
	
	HRESULT					hr	= S_OK;
	VecDATransforms			vecTransforms;
	int						cTransforms = 0;
	
	IDA2Statics * pStatics	= GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;

	// Get age behavior == local time, which will start at zero when we are
	// born.
	//----------------------------------------------------------------------
	CComPtr<IDANumber>		pnumAge;
	CComPtr<IDANumber>		pnumCurTime;
	CComPtr<IDANumber>		pnumLocalTime;
	CComPtr<IDANumber>		pnumMaxAge;
	CComPtr<IDANumber>		pnumAgeRatio;
	CComPtr<IDANumber>		pnumOne;
	CComPtr<IDABoolean>		pboolGTOne;
	CComPtr<IDABehavior>	pClampedAgeRatio;
	
	hr = pStatics->get_LocalTime( &pnumLocalTime );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, m_dMaxAge, &pnumMaxAge );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, m_dLocalTime, &pnumCurTime );
	LMRETURNIFFAILED(hr);

	hr = pStatics->Sub( pnumLocalTime, pnumCurTime, &pnumAge );
	LMRETURNIFFAILED(hr);
	
	hr = pStatics->Div( pnumAge, pnumMaxAge, &pnumAgeRatio);
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, 1.0f, &pnumOne );
	LMRETURNIFFAILED(hr);

	hr = pStatics->GT( pnumAgeRatio, pnumOne, &pboolGTOne );
	LMRETURNIFFAILED(hr);

	//hr = pStatics->Cond( pboolGTOne, pnumOne, pnumAgeRatio, &pClampedAgeRatio );
	hr = SafeCond( pStatics, pboolGTOne, pnumOne, pnumAgeRatio, &pClampedAgeRatio );
	LMRETURNIFFAILED(hr);

	pnumAgeRatio.Release();
	hr = pClampedAgeRatio->QueryInterface( IID_IDANumber, (LPVOID *) &pnumAgeRatio );
	LMRETURNIFFAILED(hr);
	
	// Create basic image
	//----------------------------------------------------------------------
	CComPtr<IDAImage>		pBaseImage;
	
	hr = m_pSparkMaker->GetSparkImageBvr( &m_sparkOptions, pnumAgeRatio, &pBaseImage );
	LMRETURNIFFAILED(hr);
	
	// OPACITY:
	//----------------------------------------------------------------------
	if (m_fOpacity != 1.0f)
	{
		CComPtr<IDAImage> pOpacityImage;
		hr = pBaseImage->Opacity(m_fOpacity, &pOpacityImage);
		LMRETURNIFFAILED(hr);
		
		pBaseImage = pOpacityImage;
	}

	// SCALE: Initial size
	//----------------------------------------------------------------------
	CComPtr<IDATransform2>	pTransScale;

	hr = pStatics->Scale2Uniform( fSize, &pTransScale );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransScale );

	// SCALE: Size animation
	//----------------------------------------------------------------------
	hr = m_pSparkMaker->AddScaleTransforms( pnumAgeRatio, vecTransforms );
	LMRETURNIFFAILED(hr);
	
	// ROTATION: Rotation animation
	//----------------------------------------------------------------------
	hr = m_pSparkMaker->AddRotateTransforms( pnumAgeRatio, vecTransforms );
	LMRETURNIFFAILED(hr);

	// TRANSLATION: Translation animation
	//----------------------------------------------------------------------
	hr = m_pSparkMaker->AddTranslateTransforms( pnumAgeRatio, vecTransforms );
	LMRETURNIFFAILED(hr);
	
	// TRANSLATION: Velocity
	//----------------------------------------------------------------------
	CComPtr<IDANumber>		pnumVelX;
	CComPtr<IDANumber>		pnumVelY;
	CComPtr<IDANumber>		pnumVelXMulAge;
	CComPtr<IDANumber>		pnumVelYMulAge;
	CComPtr<IDATransform2>	pTransVelocity;

	hr = CDAUtils::GetDANumber( pStatics, m_fXVelocity, &pnumVelX );
	LMRETURNIFFAILED(hr);

	hr = pStatics->Mul( pnumVelX, pnumAge, &pnumVelXMulAge );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, m_fYVelocity, &pnumVelY );
	LMRETURNIFFAILED(hr);
	
	hr = pStatics->Mul( pnumVelY, pnumAge, &pnumVelYMulAge );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::BuildMoveTransform2( pStatics, 
										pnumVelXMulAge, 
										pnumVelYMulAge, 
										&pTransVelocity );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransVelocity );

	// TRANSLATION: Position the image according to coordinates
	//----------------------------------------------------------------------
	CComPtr<IDANumber>		pnumX;
	CComPtr<IDANumber>		pnumY;
	CComPtr<IDATransform2>	pTranslate;
	
	hr = CDAUtils::GetDANumber( pStatics, fX, &pnumX );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, fY, &pnumY );
	LMRETURNIFFAILED(hr);

	hr = pStatics->Translate2Anim( pnumX, pnumY, &pTranslate );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTranslate );

	// GLOBAL SCALE: scale by meter/pixel conversion factor
	//----------------------------------------------------------------------
	CComPtr<IDANumber>		pnumMetersPerPixel;
	CComPtr<IDATransform2>	pTransScaleGlobal;

	hr = pStatics->get_Pixel( &pnumMetersPerPixel );
	LMRETURNIFFAILED(hr);

	hr = pStatics->Scale2UniformAnim( pnumMetersPerPixel, &pTransScaleGlobal );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransScaleGlobal );

	// Now apply all the transforms
	//----------------------------------------------------------------------
	CComPtr<IDATransform2>		pTransFinal;
	VecDATransforms::iterator	itTransform = vecTransforms.begin();

	pTransFinal = *itTransform;
	++itTransform;
	
	while ( itTransform != vecTransforms.end() )
	{
		CComPtr<IDATransform2> pTransTmp;
		
		hr = pStatics->Compose2( *itTransform, pTransFinal, &pTransTmp );
		LMRETURNIFFAILED(hr);

		pTransFinal = pTransTmp;

		++itTransform;
	}

	hr = pBaseImage->Transform( pTransFinal, ppImageBvr );
	LMRETURNIFFAILED(hr);

	return		hr;
}

//**********************************************************************

HRESULT
CAutoEffectBvr::AddMouseEventListener( bool bAdd )
{
	if ( m_pdispActor == NULL ) return E_FAIL;
	
	HRESULT		hr			= S_OK;
	OLECHAR	*	szName;
	DISPID		dispidAddML;
	DISPPARAMS	params;
	VARIANTARG	rgvargs[1];
	int			cArgs = 1;
	VARIANT		varResult;
	EXCEPINFO	excepInfo;
	UINT		iArgErr;

	szName = bAdd ? L"addMouseEventListener" : L"removeMouseEventListener";
	
	rgvargs[0] = CComVariant( GetUnknown() );
	
	params.rgvarg				= rgvargs;
	params.cArgs				= cArgs;
	params.rgdispidNamedArgs	= NULL;
	params.cNamedArgs			= 0;
	
	hr = m_pdispActor->GetIDsOfNames( IID_NULL,
									  &szName,
									  1,
									  LOCALE_SYSTEM_DEFAULT,
									  &dispidAddML );
	LMRETURNIFFAILED(hr);

	hr = m_pdispActor->Invoke( dispidAddML,
							   IID_NULL,
							   LOCALE_SYSTEM_DEFAULT,
							   DISPATCH_METHOD,
							   &params,
							   &varResult,
							   &excepInfo,
							   &iArgErr );
	return hr;
}

//**********************************************************************

HRESULT
CAutoEffectBvr::AgeSparks( double dDeltaTime )
{
	HRESULT hr	= S_OK;

	IDAStatics * pStatics = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;

	CComPtr<IDAImage> pImageEmpty;
	hr = pStatics->get_EmptyImage( &pImageEmpty );
	LMRETURNIFFAILED(hr);

	VecSparks::iterator itSpark;

	for ( itSpark = m_vecSparks.begin(); 
		  itSpark != m_vecSparks.end();
		  itSpark++ )
	{
		if ( itSpark->IsAlive() && ( itSpark->Age( dDeltaTime ) > m_dMaxAge ) )
		{
			itSpark->Kill( pImageEmpty );
		}
	}

	return hr;
}

//**********************************************************************

HRESULT
CAutoEffectBvr::PossiblyAddSpark( double dLocalTime, long x, long y )
{
	bool bAdded = false;

	while ( ThrottleBirth( dLocalTime ) && ( AddSparkAround( x, y ) == S_OK ) )
	{
		ResetThrottle( dLocalTime );
		bAdded = true;
	}
	
	return bAdded ? S_OK : S_FALSE;
}		

//**********************************************************************

HRESULT
CAutoEffectBvr::PossiblyAddSparks( double dLocalTime )
{
	bool bAdded = false;

	while ( ThrottleBirth( dLocalTime ) && ( AddSpark() == S_OK ) )
		bAdded = true;

	return bAdded ? S_OK : S_FALSE;
}		

//**********************************************************************

HRESULT
CAutoEffectBvr::ResetSparks( double dLocalTime )
{
	HRESULT hr	= S_OK;

	IDAStatics * pStatics = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;

	CComPtr<IDAImage> pImageEmpty;
	hr = pStatics->get_EmptyImage( &pImageEmpty );
	LMRETURNIFFAILED(hr);

	VecSparks::iterator itSpark;

	for ( itSpark = m_vecSparks.begin(); 
		  itSpark != m_vecSparks.end();
		  itSpark++ )
	{
		if ( itSpark->IsAlive() )
		{
			itSpark->Kill( pImageEmpty );
		}
	}

	ResetThrottle( dLocalTime );
	
	return hr;
}

//**********************************************************************

// See if we could have given birth to a spark in the past.
bool
CAutoEffectBvr::ThrottleBirth( double dLocalTime )
{
	double	dDeltaTime = dLocalTime - m_dLastBirth;

	if ( dDeltaTime < 0 )
	{
		m_dLastBirth = dLocalTime;
		return false;
	}

	if ( dDeltaTime > m_dBirthDelta )
	{
		m_dLastBirth += m_dBirthDelta;
		return true;
	}

	return false;
}

//*****************************************************************************

void
CAutoEffectBvr::ResetThrottle( double dLocalTime )
{
	m_dLastBirth = dLocalTime;
}

HRESULT
CAutoEffectBvr::AddBvrToSparkArray( IDAImage * pImageBvr )
{
	HRESULT				hr			= S_OK;

	IDAStatics * pStatics = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;
	
	CComQIPtr<IDABehavior, &IID_IDABehavior> pBvrImageBvr( pImageBvr );
	CComPtr<IDABehavior> pBvrModifiable;
	hr = pStatics->ModifiableBehavior( pBvrImageBvr, &pBvrModifiable );
	LMRETURNIFFAILED(hr);

	// DAArray doesn't exist; we must create it.
	//------------------------------------------------------------------
	if ( m_pDAArraySparks == NULL )
	{
		CComQIPtr<IDA2Statics, &IID_IDA2Statics> pStatics2( pStatics );
		CComPtr<IDAArray> pDAArray;

		hr = pStatics2->DAArrayEx2( 1, &pBvrModifiable, DAARRAY_CHANGEABLE, &pDAArray );
		LMRETURNIFFAILED(hr);

		hr = pDAArray->QueryInterface( IID_IDA2Array, (LPVOID *) &m_pDAArraySparks );
		LMRETURNIFFAILED(hr);
	}
	// DAArray already exists; just add new element.
	//------------------------------------------------------------------
	else
	{
		long lIndex;

		hr = m_pDAArraySparks->AddElement( pBvrModifiable, 0, &lIndex );
		LMRETURNIFFAILED(hr);
	}

	m_vecSparks.push_back( CSpark( pBvrModifiable ) );
		
	return hr;
}

//*****************************************************************************
//ILMAutoEffectBvr
//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_animates( VARIANT newVal )
{
	return SUPER::SetAnimatesProperty( newVal );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::get_animates( VARIANT *pVal )
{
	return SUPER::GetAnimatesProperty( pVal );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_type( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_type, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_TYPE);
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::get_type( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_type );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_cause( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_cause, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_CAUSE);
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::get_cause( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_cause );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_span( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_span, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_SPAN);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_span( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_span );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_size( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_size, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_SIZE);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_size( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_size );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_rate( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_rate, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_RATE);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_rate( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_rate );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_gravity( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_gravity, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_GRAVITY);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_gravity( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_gravity );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_wind( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_wind, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_WIND);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_wind( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_wind );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_fillColor( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_fillColor, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_FILLCOLOR);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_fillColor( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_fillColor );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_strokeColor( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_strokeColor, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_STROKECOLOR);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_strokeColor( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_strokeColor );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_opacity( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_opacity, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_OPACITY);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_opacity( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_opacity );
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::mouseEvent(long x, 
						   long y, 
						   VARIANT_BOOL bMove,
						   VARIANT_BOOL bUp,
						   VARIANT_BOOL bShift, 
						   VARIANT_BOOL bAlt,
						   VARIANT_BOOL bCtrl,
						   long lButton)
{
	// Determine position & dimensions of our "canvas"
	CComPtr<IHTMLElement>	pElement;
	long					lWidth, lHeight;
	HRESULT					hr;
	
	hr = GetElementToAnimate( &pElement );
	LMRETURNIFFAILED(hr);

	hr = pElement->get_offsetWidth( &lWidth );
	LMRETURNIFFAILED(hr);
	hr = pElement->get_offsetHeight( &lHeight );
	LMRETURNIFFAILED(hr);

	// DA origin is at the center of the element, and Y goes up
	x -= lWidth/2;
	y = (lHeight/2) - y;
	
	// Mouse down
	if ( !bMove && !bUp && ( lButton == MK_LBUTTON ) )
	{
		if ( m_eCause == CAUSE_MOUSEDOWN )
		{
			PossiblyAddSpark( m_dLocalTime, x, y );
		}
	}
	// Mouse is moving
	else if ( bMove && !bUp )
	{
		// Mouse being dragged?
		if ( ( m_eCause == CAUSE_DRAGOVER ) && ( lButton == MK_LBUTTON ) )
		{
			PossiblyAddSpark( m_dLocalTime, x, y );
		}
		// Mouse being moved only?
		else if ( ( m_eCause == CAUSE_MOUSEMOVE ) && ( lButton == 0 ) )
		{
			PossiblyAddSpark( m_dLocalTime, x, y );
		}
	}
	
	return S_OK;
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::RemoveFragment()
{
	HRESULT hr = S_OK;
	
	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		hr  = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		m_lCookie = 0;
		CheckHR( hr, "Failed to remove a fragment from the actor", end );
	}

end:

	return hr;
}

//**********************************************************************

double CSpark::Age( double dDeltaTime )
{
	m_dAge += dDeltaTime;
	return m_dAge;
}

//**********************************************************************

HRESULT CSpark::Kill( IDABehavior * in_pDeadBvr )
{
	if ( !IsAlive() ) return S_FALSE;

	m_fAlive = false;

	return m_pModifiableBvr->SwitchTo( in_pDeadBvr );
}

//**********************************************************************

HRESULT CSpark::Reincarnate( IDABehavior * in_pNewBvr, double in_dAge )
{
	m_fAlive	= true;
	m_dAge		= in_dAge;

	return m_pModifiableBvr->SwitchTo( in_pNewBvr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\headers.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Precompiled headers for appel.dll
*******************************************************************************/

#ifndef LM_HEADERS_HXX
#define LM_HEADERS_HXX

/*********** Headers from external dependencies *********/

//#ifdef DEBUG
//#define DEBUGMEM
//#endif

/* Standard */
#include <math.h>
//#ifdef DEBUGMEM
//#include "crtdbg.h"
//#endif
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#ifndef _NO_CRT
#include <ios.h>
#include <fstream.h>
#include <iostream.h>
#include <ostream.h>
#include <strstrea.h>
#include <istream.h>
#include <ctype.h>
#include <sys/types.h>
#endif
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
// ATL - needs to be before windows.h
#include "lmatl.h"

/* Windows */
#include <windows.h>
#include <windowsx.h>

/*DA*/
#include <danim.h>

/*mshtml*/
#include <mshtml.h>

/*
#ifdef DEBUGMEM
#ifndef DEBUG_NEW
#define DEBUG_NEW                   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif
#define new                         DEBUG_NEW
#define malloc(size)                _malloc_dbg(size, _NORMAL_BLOCK, __FILE__, __LINE__)
#define free(p)                     _free_dbg(p, _NORMAL_BLOCK)
#define calloc(c, s)                _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define realloc(p, s)               _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _expand(p, s)               _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _msize(p)                   _msize_dbg(p, _NORMAL_BLOCK)
#endif
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\jump.cpp ===
//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    jump.cpp
//
// Author:	elainela
//
// Created:	11/11/98
//
// Abstract:    Implementation of the LM Jump Behavior.
//
//*****************************************************************************

#include "headers.h" 

#include "..\chrome\src\dautil.h"
#include "..\chrome\include\utils.h"
#include "jump.h"
#include "lmattrib.h"
#include "lmdefaults.h"

#undef THIS
#define THIS CJumpBvr
#define SUPER CBaseBehavior

#include "..\chrome\src\pbagimp.cpp"

static const WCHAR * const	SZ_RANGE_WINDOW		= L"window";
static const WCHAR * const	SZ_RANGE_PAGE		= L"page";

#define VAR_INTERVAL    0
#define VAR_RANGE       1

WCHAR * CJumpBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_INTERVAL,
                                     BEHAVIOR_PROPERTY_RANGE
                                    };


//*****************************************************************************

CJumpBvr::CJumpBvr() :
	m_fOrigX( 0.0f ),
	m_fOrigY( 0.0f ),
	m_eTargetType( TARGET_NONE )
{
	m_pSampler		= new CSampler( this );
	
    VariantInit( &m_varInterval );
    VariantInit( &m_varRange );

	m_fFrequency 		= 0.0f;
	m_dLastUpdateCycle	= -1.0;
	
} // CJumpBvr

//*****************************************************************************

CJumpBvr::~CJumpBvr()
{
    VariantClear( &m_varInterval );
    VariantClear( &m_varRange );

	m_pSampler->Release();

} // ~CJumpBvr

//*****************************************************************************

HRESULT 
CJumpBvr::FinalConstruct()
{

    return SUPER::FinalConstruct();
} // FinalConstruct

//*****************************************************************************

VARIANT *
CJumpBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_JUMP_PROPS);
    switch (iIndex)
    {
    case VAR_INTERVAL:
        return &m_varInterval;
        break;
    case VAR_RANGE:
        return &m_varRange;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CJumpBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_JUMP_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CJumpBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
    return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CJumpBvr::Notify(LONG event, VARIANT *pVar)
{
    return SUPER::Notify(event, pVar);
} // Notify

//*****************************************************************************

STDMETHODIMP
CJumpBvr::Detach()
{
    return SUPER::Detach();
} // Detach 

//*****************************************************************************

STDMETHODIMP
CJumpBvr::Sample( double dStart, double dGlobalNow, double dLocalNow )
{
	double	dCurrentCycle = ::floor( dLocalNow * m_fFrequency );
		
	if ( dCurrentCycle == m_dLastUpdateCycle )
		return S_OK;

	HRESULT	hr = S_OK;
	
	{
		m_dLastUpdateCycle = dCurrentCycle;

		float fMinX, fMaxX, fMinY, fMaxY;
		hr = GetJumpRanges( fMinX, fMaxX, fMinY, fMaxY );
		LMCLEANUPIFFAILED(hr);

		if ( fMinX != m_fBaseX )
		{
			m_fBaseX = fMinX;
			
			hr = m_pBvrModifBaseX->SwitchToNumber( m_fBaseX );
			LMCLEANUPIFFAILED(hr);
		}
		
		if ( fMaxX - fMinX != m_fRangeX )
		{
			m_fRangeX = fMaxX-fMinX;
			
			hr = m_pBvrModifRangeX->SwitchToNumber( m_fRangeX );
			LMCLEANUPIFFAILED(hr);
		}
		
		if ( fMinY != m_fBaseY )
		{
			m_fBaseY = fMinY;
			
			hr = m_pBvrModifBaseY->SwitchToNumber( m_fBaseY );
			LMCLEANUPIFFAILED(hr);
		}
		
		if ( fMaxY - fMinY != m_fRangeY )
		{
			m_fRangeY = fMaxY-fMinY;
			
			hr = m_pBvrModifRangeY->SwitchToNumber( m_fRangeY );
			LMCLEANUPIFFAILED(hr);
		}
	}
	
  cleanup:
	return hr;
}

//*****************************************************************************

HRESULT 
CJumpBvr::buildBehaviorFragments( IDispatch * pActorDisp )
{
    HRESULT hr = S_OK;

	{
		m_dLastUpdateCycle = -1.0;
		
		hr = GetInitialPosition( m_fOrigX, m_fOrigY );
		LMCLEANUPIFFAILED(hr);

		CComPtr<IDATransform2> pbvrTransform;
		hr = Build2DTransform(&pbvrTransform);
		LMCLEANUPIFFAILED(hr);

		// Sample it
		CComPtr<IDABehavior> pBvrSampled;

		hr = m_pSampler->Attach( pbvrTransform, &pBvrSampled );
		LMCLEANUPIFFAILED(hr);
	
		// REVIEW: Supporting only absolute
		hr = AttachBehaviorToActor( pActorDisp, pBvrSampled,
									CComBSTR( L"translation" ),
									e_Absolute,
									e_Translation );
		LMCLEANUPIFFAILED(hr);
	}
	
  cleanup:
    return S_OK;

} // BuildAnimationAsDABehavior

HRESULT
CJumpBvr::GetNumberModifiableBvr( float fNumber, IDAModifiableBehavior ** out_ppModifiable, IDANumber ** out_ppNumberModifiable )
{
	HRESULT		hr = S_OK;
	
	IDA2Statics * pStatics  = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;

	{
		CComPtr<IDANumber>	pnum;

		hr = pStatics->ModifiableNumber( fNumber, out_ppNumberModifiable );
		LMCLEANUPIFFAILED(hr);

		hr = (*out_ppNumberModifiable)->QueryInterface( IID_IDAModifiableBehavior,
														(LPVOID *) out_ppModifiable );
		LMCLEANUPIFFAILED(hr);
	}
	
  cleanup:
	return hr;
}

//*****************************************************************************

HRESULT
CJumpBvr::GetRandomNumber( IDA2Statics 	*pStatics,
						   IDANumber   	*pnumBase,
						   IDANumber   	*pnumRange,
						   IDANumber **ppnumReturn )
{
    DASSERT( pDAStatics != NULL );
    DASSERT( ppnumReturn != NULL );
    *ppnumReturn = NULL;

    DASSERT( fMin != fMax );

    HRESULT hr = S_OK;

	{
		CComPtr<IDANumber> pnumRand;
		CComPtr<IDANumber> pnumMod;
		CComPtr<IDANumber> pnumRandMulRange;

		hr = pStatics->SeededRandom( rand(), &pnumRand );
		LMCLEANUPIFFAILED(hr);

		hr = pStatics->Mul( pnumRand, pnumRange, &pnumRandMulRange );
		LMCLEANUPIFFAILED(hr);

		hr = pStatics->Add( pnumRandMulRange, pnumBase, ppnumReturn );
		LMCLEANUPIFFAILED(hr);
	}

  cleanup:
    return hr;

} // GetRandomNumber

//*****************************************************************************

HRESULT 
CJumpBvr::GetJumpRanges( float& fMinX, float& fMaxX, float& fMinY, float& fMaxY )
{
	HRESULT	hr	= S_OK;

	{
		// First determine position & dimensions of element
		//----------------------------------------------------------------------
		CComPtr<IHTMLElement>   pElement;
		hr = GetElementToAnimate( &pElement );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElement2( pElement );
		LMRETURNIFNULL( pElement2 );

		CComPtr<IHTMLRect>	pRect;
		long				lBoundLeft, lBoundTop, lBoundRight, lBoundBottom;

		hr = pElement2->getBoundingClientRect( &pRect );
		LMCLEANUPIFFAILED(hr);

		pRect->get_left( &lBoundLeft );
		LMCLEANUPIFFAILED(hr);
		pRect->get_top( &lBoundTop );
		LMCLEANUPIFFAILED(hr);
		pRect->get_right( &lBoundRight );
		LMCLEANUPIFFAILED(hr);
		pRect->get_bottom( &lBoundBottom );
		LMCLEANUPIFFAILED(hr);

		CComPtr<IDispatch>		pDispDoc;
		hr = pElement->get_document( &pDispDoc );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2> pDoc2( pDispDoc );
		LMRETURNIFNULL( pDoc2 );

		// Determine the range
		//----------------------------------------------------------------------
		long lRefLeft, lRefTop, lRefWidth, lRefHeight;

		CComPtr<IHTMLElement> pEltBody;
		hr = pDoc2->get_body( &pEltBody );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElt2Body( pEltBody );
		LMRETURNIFNULL( pElt2Body );

		// Range: Page
		//----------------------------------------------------------------------
		if ( m_eTargetType == TARGET_PAGE )
		{
			lRefLeft	= 0;
			lRefTop		= 0;

			hr = pElt2Body->get_scrollWidth( &lRefWidth );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Body->get_scrollHeight( &lRefHeight );
			LMCLEANUPIFFAILED(hr);
		}
		// Range: Window
		//----------------------------------------------------------------------
		else if ( m_eTargetType == TARGET_WINDOW )
		{
			hr = pElt2Body->get_clientLeft( &lRefLeft );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Body->get_clientTop( &lRefTop );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Body->get_clientWidth( &lRefWidth );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Body->get_clientHeight( &lRefHeight );
			LMCLEANUPIFFAILED(hr);
		}
		// Range: some element on the page
		//----------------------------------------------------------------------
		else if ( m_eTargetType == TARGET_ELEMENT )
		{
			CComPtr<IHTMLElementCollection> pEltColl;
			CComPtr<IDispatch> pDispReference;

			hr = pDoc2->get_all( &pEltColl );
			LMCLEANUPIFFAILED(hr);

			hr = pEltColl->item( m_varRange, CComVariant( 0L ), &pDispReference );
			LMCLEANUPIFFAILED(hr);
			LMRETURNIFNULL( pDispReference );

			if ( pDispReference == NULL ) return E_FAIL;
			CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElt2Ref(pDispReference);
			LMRETURNIFNULL( pElt2Ref );

			hr = pElt2Ref->get_clientLeft( &lRefLeft );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Ref->get_clientTop( &lRefTop );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Ref->get_clientWidth( &lRefWidth );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Ref->get_clientHeight( &lRefHeight );
			LMCLEANUPIFFAILED(hr);

			// The area must be offset by position in the body
			CComPtr<IHTMLRect>	pRectRef;
			long				lBoundLeft, lBoundTop;

			hr = pElt2Ref->getBoundingClientRect( &pRectRef );
			LMCLEANUPIFFAILED(hr);
			hr = pRectRef->get_left( &lBoundLeft );
			LMCLEANUPIFFAILED(hr);
			hr = pRectRef->get_top( &lBoundTop );
			LMCLEANUPIFFAILED(hr);

			lRefLeft	+= lBoundLeft;
			lRefTop		+= lBoundTop;
		}
		else
		{
			return E_FAIL;
		}
		
		// Now compute the range behaviors
		//----------------------------------------------------------------------
		fMinX = (float) (lRefLeft - m_lOrigBoundingLeft);
		fMaxX = (float) (lRefLeft + lRefWidth -
						 (m_lOrigBoundingLeft+lBoundRight-lBoundLeft));
		
		fMinY = (float) (lRefTop - m_lOrigBoundingTop);
		fMaxY = (float) (lRefTop + lRefHeight -
						 (m_lOrigBoundingTop+lBoundBottom-lBoundTop));

		// REVIEW: do this only if offset is absolute
		fMinX += m_fOrigX;
		fMaxX += m_fOrigX;

		fMinY += m_fOrigY;
		fMaxY += m_fOrigY;
	}
	
  cleanup:
	return hr;
}

//*****************************************************************************

HRESULT 
CJumpBvr::BuildJumpRangeBehaviors( IDANumber ** ppnumJumpX, 
								   IDANumber ** ppnumJumpY )
{
	DASSERT( ppnumJumpX != NULL );
	DASSERT( ppnumJumpY != NULL );

	HRESULT	hr	= S_OK;

	{
		hr = CUtils::InsurePropertyVariantAsBSTR( &m_varRange );

		CComBSTR	bstrRange( DEFAULT_JUMPBVR_RANGE );
		if ( SUCCEEDED(hr) && ( V_VT( &m_varRange ) == VT_BSTR ) )
			bstrRange = V_BSTR( &m_varRange );

		if ( _wcsicmp( bstrRange, SZ_RANGE_PAGE ) == 0 )
		{
			m_eTargetType = TARGET_PAGE;
		}
		else if ( _wcsicmp( bstrRange, SZ_RANGE_WINDOW ) == 0 )
		{
			m_eTargetType = TARGET_WINDOW;
		}
		else
		{
			m_eTargetType = TARGET_ELEMENT;
		}

		// Get original bounding left & top
		//----------------------------------------------------------------------
		CComPtr<IHTMLElement>   pElement;
		hr = GetElementToAnimate( &pElement );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElement2( pElement );
		LMRETURNIFNULL( pElement2 );

		CComPtr<IHTMLRect>	pRect;
		long				lBoundRight, lBoundBottom;

		hr = pElement2->getBoundingClientRect( &pRect );
		LMCLEANUPIFFAILED(hr);

		pRect->get_left( &m_lOrigBoundingLeft );
		LMCLEANUPIFFAILED(hr);
		pRect->get_top( &m_lOrigBoundingTop );
		LMCLEANUPIFFAILED(hr);
		LMCLEANUPIFFAILED(hr);
		
		// Now build the range behaviors
		//----------------------------------------------------------------------
		float fMaxX, fMaxY;
		
		hr = GetJumpRanges( m_fBaseX, fMaxX, m_fBaseY, fMaxY );
		LMCLEANUPIFFAILED(hr);

		m_fRangeX = fMaxX - m_fBaseX;
		m_fRangeY = fMaxY - m_fBaseY;
		
		// Now get random numbers
		IDA2Statics * pStatics  = GetDAStatics();

		CComPtr<IDANumber> pBaseX;
		CComPtr<IDANumber> pRangeX;
		CComPtr<IDANumber> pBaseY;
		CComPtr<IDANumber> pRangeY;
		
		hr = GetNumberModifiableBvr( m_fBaseX, &m_pBvrModifBaseX, &pBaseX );
		LMCLEANUPIFFAILED(hr);
		hr = GetNumberModifiableBvr( m_fRangeX, &m_pBvrModifRangeX, &pRangeX );
		LMCLEANUPIFFAILED(hr);
		hr = GetNumberModifiableBvr( m_fBaseY, &m_pBvrModifBaseY, &pBaseY );
		LMCLEANUPIFFAILED(hr);
		hr = GetNumberModifiableBvr( m_fRangeY, &m_pBvrModifRangeY, &pRangeY );
		LMCLEANUPIFFAILED(hr);
		
		hr = GetRandomNumber( pStatics, pBaseX, pRangeX, ppnumJumpX );
		LMCLEANUPIFFAILED(hr);
		hr = GetRandomNumber( pStatics, pBaseY, pRangeY, ppnumJumpY );
		LMCLEANUPIFFAILED(hr);
	}
	
  cleanup:
	return hr;

} // BuildJumpRangeBehaviors

//*****************************************************************************

HRESULT 
CJumpBvr::Build2DTransform(IDATransform2 **ppbvrTransform)
{
    HRESULT hr  = S_OK;

	{
		// Check our parameters.
		//----------------------------------------------------------------------
		IDA2Statics * pStatics  = GetDAStatics();
		if ( pStatics == NULL ) return E_FAIL;

		DASSERT(ppbvrTransform != NULL);
		*ppbvrTransform = NULL;

		m_fFrequency = 1.0f/DEFAULT_JUMPBVR_INTERVAL;

		if ( ( V_VT( &m_varInterval ) != VT_EMPTY ) &&
			 ( V_VT( &m_varInterval ) != VT_NULL ) )
		{
			hr = CUtils::InsurePropertyVariantAsFloat( &m_varInterval );
			LMRETURNIFFAILED(hr);

			if ( V_R4( &m_varInterval ) <= 0.0f )
				return E_FAIL;
			
			m_fFrequency = 1/V_R4( &m_varInterval );
		}
		
		// Compute jump range
		//----------------------------------------------------------------------
		CComPtr<IDANumber> pnumJumpX;
		CComPtr<IDANumber> pnumJumpY;

		hr = BuildJumpRangeBehaviors( &pnumJumpX, &pnumJumpY );
		LMCLEANUPIFFAILED(hr);
	
		// Jump according to jump interval
		//----------------------------------------------------------------------
		CComPtr<IDANumber> pnumProgress;
		CComPtr<IDANumber> pnumFrequency;
		CComPtr<IDANumber> pnumProgressMulFrequency;
		CComPtr<IDANumber> pnumStepTime;

		hr = pStatics->get_LocalTime( &pnumProgress );
		LMCLEANUPIFFAILED(hr);
		hr = CDAUtils::GetDANumber( pStatics, m_fFrequency, &pnumFrequency );
		LMCLEANUPIFFAILED(hr);
		hr = pStatics->Mul( pnumProgress, pnumFrequency, &pnumProgressMulFrequency );
		LMCLEANUPIFFAILED(hr);
		hr = pStatics->Floor( pnumProgressMulFrequency, &pnumStepTime );
		LMCLEANUPIFFAILED(hr);

		CComPtr<IDABehavior> pbvrJumpXStep;
		CComPtr<IDABehavior> pbvrJumpYStep;
		hr = pnumJumpX->SubstituteTime( pnumStepTime, &pbvrJumpXStep );
		LMCLEANUPIFFAILED(hr);
		hr = pnumJumpY->SubstituteTime( pnumStepTime, &pbvrJumpYStep );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IDANumber, &IID_IDANumber> pnumJumpXStep( pbvrJumpXStep );
		CComQIPtr<IDANumber, &IID_IDANumber> pnumJumpYStep( pbvrJumpYStep );

		hr = CDAUtils::BuildMoveTransform2( pStatics, pnumJumpXStep, pnumJumpYStep,
											ppbvrTransform );
	}
	
  cleanup:
    return hr;

} // Build2DTransform

//*****************************************************************************

HRESULT 
CJumpBvr::Apply2DTransformToAnimationElement(IDATransform2 *pbvrMove)
{
    HRESULT hr  = S_OK;
	
	{
		float	fOrigX, fOrigY;

		hr = GetInitialPosition( fOrigX, fOrigY );
		LMCLEANUPIFFAILED(hr);

		// REVIEW: Supporting only absolute
		hr = ApplyAbsolute2DMoveBehavior( pbvrMove, fOrigX, fOrigY );
    }
	
  cleanup:
    return hr;

} // Apply2DTransformToAnimationElement

//*****************************************************************************

HRESULT
CJumpBvr::GetInitialPosition( float &fOrigX, float &fOrigY )
{
	HRESULT					hr = S_OK;

	{
		CComPtr<IHTMLElement>		   pElement;
		CComPtr<IHTMLCurrentStyle>     pStyle;
		float                   fLeft, fTop;

		hr = GetElementToAnimate( &pElement );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElement2( pElement );
		
		pElement2->get_currentStyle( &pStyle );
		LMCLEANUPIFFAILED(hr);

		long left, top;
		hr = pElement->get_offsetLeft( &left );
		LMCLEANUPIFFAILED(hr);
		hr = pElement->get_offsetTop( &top );
		LMCLEANUPIFFAILED(hr);

		fOrigX = (float) left;
		fOrigY = (float) top;
	}
	
  cleanup:
	return hr;

} // GetInitialPosition

//*****************************************************************************
//ILMJumpBvr
//*****************************************************************************

//*****************************************************************************

STDMETHODIMP
CJumpBvr::put_interval( VARIANT varInterval )
{
    return VariantCopy( &m_varInterval, &varInterval );
}

//*****************************************************************************

STDMETHODIMP
CJumpBvr::get_interval( VARIANT *varInterval )
{
    return VariantCopy( varInterval, &m_varInterval );
}

//*****************************************************************************

STDMETHODIMP
CJumpBvr::put_range( VARIANT varRange )
{
    return VariantCopy( &m_varRange, &varRange );
}

//*****************************************************************************

STDMETHODIMP
CJumpBvr::get_range( VARIANT *varRange )
{
    return VariantCopy( varRange, &m_varRange );
}

//*****************************************************************************
//End ILMJumpBvr
//*****************************************************************************

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\avoidfollow.h ===
#ifndef __AVOIDFOLLOW_H_
#define __AVOIDFOLLOW_H_
//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    AvoidFollowBvr.h
//
// Author:	kurtj
//
// Created:	11/06/98
//
// Abstract:    Definition of the LM Avoid Follow Behavior.
//
//*****************************************************************************

#include <resource.h>
#include "lmrt.h"
#include "..\chrome\include\basebvr.h"
#include "..\chrome\include\sampler.h"

//*****************************************************************************

typedef enum AF_TargetType
{
	targetInvalid,
	targetMouse,
	targetElement
} AF_TargetType;

#define NUM_AVOIDFOLLOW_PROPS 3


class ATL_NO_VTABLE CAvoidFollowBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAvoidFollowBvr, &CLSID_LMAvoidFollowBvr>,
    public IConnectionPointContainerImpl<CAvoidFollowBvr>,
    public IPropertyNotifySinkCP<CAvoidFollowBvr>,
	public IDispatchImpl<ILMAvoidFollowBvr, &IID_ILMAvoidFollowBvr, &LIBID_LiquidMotion>,
    public IPersistPropertyBag2,
	public IElementBehavior,
    public CBaseBehavior
{
public:
DECLARE_REGISTRY_RESOURCEID(IDR_AVOIDFOLLOWBVR)

BEGIN_COM_MAP(CAvoidFollowBvr)
	COM_INTERFACE_ENTRY(ILMAvoidFollowBvr)
    COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CAvoidFollowBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
	CAvoidFollowBvr();
    virtual ~CAvoidFollowBvr();
    HRESULT                 FinalConstruct              ();

    // IElementBehavior
    //
	STDMETHOD			    (Init)						(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD			    (Notify)					(LONG event, VARIANT *pVar);
	STDMETHOD			    (Detach)					();

    //
    //ILMAvoidFollowBvr
    //
    //animates
    STDMETHOD			    (put_animates)				( VARIANT varAnimates );
    STDMETHOD			    (get_animates)				( VARIANT *varAnimates );
    //radius
    STDMETHOD			    (put_radius)				( VARIANT varRadius );
    STDMETHOD			    (get_radius)				( VARIANT *varRadius );
    //target
    STDMETHOD			    (put_target)				( VARIANT varTarget );
    STDMETHOD			    (get_target)				( VARIANT *varTarget );
    //velocity
    STDMETHOD			    (put_velocity)				( VARIANT varVelocity );
    STDMETHOD			    (get_velocity)				( VARIANT *varVelocity );
	//methods
	STDMETHOD			    (buildBehaviorFragments)	( IDispatch *pActorDisp );

    //IPersistPropertyBag2 methods
    STDMETHOD               (GetClassID)                (CLSID* pclsid);
	STDMETHOD               (InitNew)                   (void);
    STDMETHOD               (IsDirty)                   (void){return S_OK;};
    STDMETHOD               (Load)                      (IPropertyBag2 *pPropBag,
                                                         IErrorLog *pErrorLog);
    STDMETHOD               (Save)                      (IPropertyBag2 *pPropBag, 
                                                         BOOL fClearDirty, 
                                                         BOOL fSaveAllProperties);

    // Needed by CBaseBehavior
    void * 				    GetInstance					();
	
    HRESULT				    GetTypeInfo					(ITypeInfo ** ppInfo);

	static HRESULT			SampleOnBvr					(void *thisPtr,
														 double startTime,
														 double globalNow,
														 double localNow,
														 IDABehavior * sampleVal);

protected:

	HRESULT					(Sample)					( double startTime, 
                                                          double globalNow, 
                                                          double localNow,
														  IDABehavior *sampleVal);

    virtual HRESULT		    BuildAnimationAsDABehavior	();

	HRESULT				    MapToLocal					( long* pX, long* pY );
    HRESULT				    UpdateSourcePos				();
	HRESULT				    UpdateTargetPos				();
	HRESULT				    UpdateWindowTopLeft			();

	HRESULT				    GetElementClientPosition	(IHTMLElement2 *pElement2, 
                                                         long *pLeft, 
                                                         long *pTop);
	HRESULT					GetElementClientDimension	( IHTMLElement2 *pElement2, 
														  long *pWidth, 
														  long* pHeight );

    virtual HRESULT		    GetPropertyBagInfo			(ULONG *pulProperties, 
                                                         WCHAR ***pppPropName);
    virtual HRESULT		    GetConnectionPoint			(REFIID riid, 
                                                         IConnectionPoint **ppICP);

    virtual VARIANT *	    VariantFromIndex			(ULONG iIndex);

	void				    ReleaseTridentInterfaces	();
	void				    ReleaseDAInterfaces			();
	HRESULT				    CacheWindow3				();
	HRESULT					CacheBody2					();
	HRESULT				    FindTargetElement			();

	bool					IsTargetPosLegal			();
	bool					IsElementAbsolute			(IHTMLElement2 *pElement2 );

private:

    HRESULT				    InitializeProperties		();
	HRESULT				    SetTargetType				();

    //properties
    VARIANT				    m_radius;
    VARIANT				    m_target;
    VARIANT				    m_velocity;

    //cached values
    //the coords of the object that we are avoid/following
    long				    m_targetLeft;
    long				    m_targetTop;
	long					m_targetClientTop;  //only defined for target == mouse
	long					m_targetClientLeft;
    //the coordinates of the object that we are moving
    long				    m_sourceLeft;
    long				    m_sourceTop;
    //the coordinates of the trident window top left for translating mouse events
    long				    m_screenLeft;
    long				    m_screenTop;

	double				    m_dVelocity;
	double				    m_dRadius;
	double				    m_currentX;
	double				    m_currentY;
    long                    m_originalX;
    long                    m_originalY;
    long                    m_originalLeft;
    long                    m_originalTop;

	//These should be released in ReleaseTridentInterfaces
	IHTMLElement*		    m_pElement;
	IHTMLElement*		    m_pAnimatedElement;
	IHTMLElement2*          m_pAnimatedElement2;
	IHTMLElement2*		    m_pTargetElement2;
	IHTMLWindow3*		    m_pWindow3;
	IHTMLElement2*			m_pBody2;

    IDANumber*			    m_leftBvr;
    IDANumber*			    m_topBvr;

	VARIANT_BOOL			m_lastOn;

    //the sampler.  used to hook us up to whomever is going to tell us to sample
    CSampler*			    m_sampler;

	AF_TargetType		    m_targetType;
	
	double				    m_lastSampleTime;
	double				    m_timeDelta;

    static WCHAR            *m_rgPropNames[NUM_AVOIDFOLLOW_PROPS]; 

}; // CAvoidFollowBvr

//*****************************************************************************
//inlines
//*****************************************************************************

inline void*
CAvoidFollowBvr::GetInstance()
{
	return (ILMAvoidFollowBvr *) this ;
}

inline HRESULT 
CAvoidFollowBvr::GetTypeInfo(ITypeInfo ** ppInfo)
{
	return GetTI(GetUserDefaultLCID(), ppInfo);
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__AVOIDFOLLOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\jump.h ===
#ifndef __JUMP_H_
#define __JUMP_H_

//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    jump.h
//
// Author:	elainela
//
// Created:	11/11/98
//
// Abstract:    Definition of the LM Jump Behavior.
//
//*****************************************************************************

#include <resource.h>
#include "lmrt.h"
#include "..\chrome\include\basebvr.h"
#include "..\chrome\include\sampler.h"

//*****************************************************************************

#define NUM_JUMP_PROPS 2

class ATL_NO_VTABLE CJumpBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CJumpBvr, &CLSID_LMJumpBvr>,
    public IConnectionPointContainerImpl<CJumpBvr>,
    public IPropertyNotifySinkCP<CJumpBvr>,
	public IDispatchImpl<ILMJumpBvr, &IID_ILMJumpBvr, &LIBID_LiquidMotion>,
    public IPersistPropertyBag2,
	public IElementBehavior,
	public ILMSample,
    public CBaseBehavior
	
{
public:
DECLARE_REGISTRY_RESOURCEID(IDR_JUMPBVR)

BEGIN_COM_MAP(CJumpBvr)
	COM_INTERFACE_ENTRY(ILMJumpBvr)
    COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
    COM_INTERFACE_ENTRY(ILMSample)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CJumpBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

	CJumpBvr();
    ~CJumpBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // ILMSample
    STDMETHOD(Sample) (double dStart, double dGlobalNow, double dLocalNow );

    //
    //ILMJumpBvr
    //
    STDMETHOD(put_interval)( VARIANT varInterval );
    STDMETHOD(get_interval)( VARIANT *varInterval );
    STDMETHOD(put_range)( VARIANT varRange );
    STDMETHOD(get_range)( VARIANT *varRange );
	STDMETHOD(buildBehaviorFragments)(IDispatch *pActorDisp);
    
    //IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ILMJumpBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }


protected:
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT BuildAnimationAsDABehavior() { return S_OK; }

protected:
	enum TargetType
	{
		TARGET_NONE     = -1,
		TARGET_PAGE     = 0,
		TARGET_WINDOW   = 1,
		TARGET_ELEMENT  = 2,
		NUM_TARGETTYPES = 3
	};
	
protected:
	HRESULT GetNumberModifiableBvr( float fNumber, IDAModifiableBehavior ** out_ppModifiable, IDANumber ** out_ppNumberModifiable );
	HRESULT GetRandomNumber( IDA2Statics *pDAStatics, IDANumber * pnumBase, IDANumber * pnumRange, IDANumber **ppnumReturn );
	HRESULT GetJumpRanges( float& fMinX, float& fMaxX, float& fMinY, float& fMaxY );
	HRESULT BuildJumpRangeBehaviors( IDANumber ** ppnumJumpX, IDANumber ** ppnumJumpY );
    HRESULT Build2DTransform(IDATransform2 **ppbvrTransform);
    HRESULT Apply2DTransformToAnimationElement(IDATransform2 *pbvrTransform);
	HRESULT	GetInitialPosition( float& fX, float& fY );

    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:
	VARIANT	m_varInterval;
	VARIANT	m_varRange;
    float	m_fFrequency;
	
    static WCHAR                *m_rgPropNames[NUM_JUMP_PROPS];
	float						m_fOrigX;
	float						m_fOrigY;
	long						m_lOrigBoundingLeft;
	long						m_lOrigBoundingTop;
	CSampler					* m_pSampler;
	TargetType					m_eTargetType;
	double						m_dLastUpdateCycle;

	float						m_fBaseX;
	float						m_fRangeX;
	float						m_fBaseY;
	float						m_fRangeY;

	
	CComPtr<IDAModifiableBehavior>		m_pBvrModifRangeX;
	CComPtr<IDAModifiableBehavior>		m_pBvrModifBaseX;
	CComPtr<IDAModifiableBehavior>		m_pBvrModifRangeY;
	CComPtr<IDAModifiableBehavior>		m_pBvrModifBaseY;

}; // CJumpBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__JUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\lmfactory.h ===
// LMBehaviorFactory.h : Declaration of the CLMBehaviorFactory

#ifndef __LMBEHAVIORFACTORY_H_
#define __LMBEHAVIORFACTORY_H_

#include "resource.h"       // main symbols

#include "..\chrome\include\autobase.h"

#include "lmrt.h"

/////////////////////////////////////////////////////////////////////////////
// CLMBehaviorFactory
class ATL_NO_VTABLE CLMBehaviorFactory : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CLMBehaviorFactory, &CLSID_LMBehaviorFactory>,
    public IDispatchImpl<ILMBehaviorFactory, &IID_ILMBehaviorFactory, &LIBID_LiquidMotion>,
    public IObjectSafetyImpl<CLMBehaviorFactory>,
    public IElementBehaviorFactory,
    public CAutoBase
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_LMBVRFACTORY)

    CLMBehaviorFactory();
    ~CLMBehaviorFactory();

    // IObjectSafetyImpl
    STDMETHOD(SetInterfaceSafetyOptions)(
                            /* [in] */ REFIID riid,
                            /* [in] */ DWORD dwOptionSetMask,
                            /* [in] */ DWORD dwEnabledOptions);
    STDMETHOD(GetInterfaceSafetyOptions)(
                            /* [in] */ REFIID riid, 
                            /* [out] */DWORD *pdwSupportedOptions, 
                            /* [out] */DWORD *pdwEnabledOptions);
    //
    // IElementBehaviorFactory
    //

    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace, 
                            LPOLESTR pchTagName, 
                            IElementBehaviorSite *pUnkArg, 
                            IElementBehavior **ppBehavior)
    {
        return FindBehavior(pchNameSpace, pchTagName, static_cast<IUnknown*>(pUnkArg), ppBehavior);
    }

    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace, 
                            LPOLESTR pchTagName, 
                            IUnknown *pUnkArg, 
                            IElementBehavior **ppBehavior);

    STDMETHODIMP UIDeactivate() { return S_OK; }

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLMBehaviorFactory)
    COM_INTERFACE_ENTRY(ILMBehaviorFactory)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehaviorFactory)
END_COM_MAP()


private:
    DWORD m_dwSafety;

    IElementBehaviorFactory *m_chromeFactory;

// ILMBehaviorFactory
public:
};

#endif //__LMBEHAVIORFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\pathmaker.h ===
//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    PathMaker.h
//
// Author:	elainela
//
// Created:	11/20/98
//
// Abstract:    Definition of the PathMaker for the AutoEffect.
//
//*****************************************************************************

#ifndef __PATHMAKER_H__
#define __PATHMAKER_H__

#include "lmrt.h"

#include <vector>

using namespace std;

//**********************************************************************

struct PathNode
{
	float	fIncomingBCPX;
	float	fIncomingBCPY;
	float	fAnchorX;
	float	fAnchorY;
	float	fOutgoingBCPX;
	float	fOutgoingBCPY;
	int		nAnchorType;
};

typedef vector<PathNode>	VecPathNodes;

class CPathMaker
{
public:
	static HRESULT CreatePathBvr( IDA2Statics * pStatics, VecPathNodes& vecNodes, bool fClosed, IDAPath2 ** ppPath );
	
	static HRESULT CreateStarPath(int cArms, double dInnerRadius,
								  double dOuterRadius,
								  VecPathNodes& vecNodes );
};

#endif // __PATHMAKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\sparkmaker.cpp ===
#include "headers.h" 

#include "sparkmaker.h"

#include "..\chrome\src\dautil.h"
#include "..\chrome\include\utils.h"

static	const float PI		= 3.14159265359f;
const	int CSparkleMaker::NUM_STARARMS		= 8;

HRESULT CSparkMaker::CreateSparkMaker( IDA2Statics * pStatics, Type iType, CSparkMaker ** ppMaker )
{
	HRESULT	hr = S_OK;
	
	switch ( iType )
	{
		default:
		case SPARKLES:
			*ppMaker = new CSparkleMaker( pStatics );
			break;

		case TWIRLERS:
			*ppMaker = new CTwirlerMaker( pStatics );
			break;

		case BUBBLES:
			*ppMaker = new CBubbleMaker( pStatics );
			break;
			
		case FILLEDBUBBLES:
			*ppMaker = new CFilledBubbleMaker( pStatics );
			break;

		case CLOUDS:
			*ppMaker = new CCloudMaker( pStatics );
			break;

		case SMOKE:
			*ppMaker = new CSmokeMaker( pStatics );
			break;
	}

	return hr;
}

HRESULT
CSparkMaker::GetSparkImageBvr( SparkOptions * pSparkOptions, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr )
{
	HRESULT	hr;
	
	if ( !m_fInitialized )
	{
		hr = Init( pSparkOptions );
		LMRETURNIFFAILED(hr);
	}

	return CreateBasicSparkImageBvr( pSparkOptions, pnumAgeRatio, ppImageBvr );
}

HRESULT
CSparkMaker::CreateLineStyleBvr( IDALineStyle ** ppLineStyle )
{
	HRESULT hr = S_OK;

	CComPtr<IDALineStyle> 	pLineStyleDefault;
	
	hr = m_pStatics->get_DefaultLineStyle( &pLineStyleDefault );
	LMRETURNIFFAILED(hr);

	hr = pLineStyleDefault->AntiAliasing( 1.0, ppLineStyle );
	LMRETURNIFFAILED(hr);

	return hr;
}

//**********************************************************************
// Star Maker
//**********************************************************************

CStarMaker::CStarMaker( IDA2Statics * pStatics ) :
	CSparkMaker( pStatics )
{
}

HRESULT
CStarMaker::Init( SparkOptions * pOptions )
{
	HRESULT hr = CSparkMaker::Init( pOptions );
	LMRETURNIFFAILED(hr);

	// Colors
	//----------------------------------------------------------------------
	CComPtr<IDAColor> pColorPrimary;
	CComPtr<IDAColor> pColorSecondary;
	
	HSL hsl = pOptions->hslPrimary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorPrimary );
	LMRETURNIFFAILED(hr);

	hsl = pOptions->hslSecondary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorSecondary );
	LMRETURNIFFAILED(hr);

	// Create outer star path
	//----------------------------------------------------------------------
	CComPtr<IDAPath2> pOuterPathBvr;
	VecPathNodes vecNodes;
	
	hr = CPathMaker::CreateStarPath( NUM_STARARMS, 0, 1.0, vecNodes );
	LMRETURNIFFAILED(hr);

	hr = CPathMaker::CreatePathBvr( m_pStatics, vecNodes, true, &pOuterPathBvr );
	LMRETURNIFFAILED(hr);

    // Create inner star path
	//----------------------------------------------------------------------
	CComPtr<IDAPath2> pInnerPathBvr;
	
	vecNodes.clear();

	hr = CPathMaker::CreateStarPath( NUM_STARARMS, 0, 0.5f, vecNodes );
	LMRETURNIFFAILED(hr);

	hr = CPathMaker::CreatePathBvr( m_pStatics, vecNodes, true, &pInnerPathBvr );
	LMRETURNIFFAILED(hr);

	// Basic image
	//----------------------------------------------------------------------
	CComPtr<IDALineStyle> 	pLineStyleDefault;
	CComPtr<IDALineStyle>	pLineStyleOuter;
	CComPtr<IDALineStyle>	pLineStyleInner;
	CComPtr<IDAImage>		pImageOuter;
	CComPtr<IDAImage>		pImageInner;

	hr = CreateLineStyleBvr( &pLineStyleDefault );
	LMRETURNIFFAILED(hr);

	hr = pLineStyleDefault->Color( pColorPrimary, &pLineStyleInner );
	LMRETURNIFFAILED(hr);

	hr = pLineStyleDefault->Color( pColorSecondary, &pLineStyleOuter );
	LMRETURNIFFAILED(hr);

  	hr = pInnerPathBvr->Draw( pLineStyleInner, &pImageInner );
  	LMRETURNIFFAILED(hr);

  	hr = pOuterPathBvr->Draw( pLineStyleOuter, &pImageOuter );
  	LMRETURNIFFAILED(hr);

	hr = m_pStatics->Overlay( pImageInner, pImageOuter, &m_pBaseImage );
  	LMRETURNIFFAILED(hr);
	
	return		hr;
}

HRESULT
CStarMaker::CreateBasicSparkImageBvr( SparkOptions * pSparkOptions, IDANumber *, IDAImage ** ppBaseImage )
{
	HRESULT 	hr = S_OK;

	if ( m_pBaseImage == NULL )	return E_FAIL;

	*ppBaseImage = m_pBaseImage;
	(*ppBaseImage)->AddRef();
	
	return hr;
}

//**********************************************************************
// Sparkle Maker
//**********************************************************************

CSparkleMaker::CSparkleMaker( IDA2Statics * pStatics ) : CStarMaker( pStatics )
{
}

HRESULT
CSparkleMaker::AddScaleTransforms( IDANumber * pnumAgeRatio, VecDATransforms& vecTransforms )
{
	HRESULT	hr	= S_OK;

	CComPtr<IDANumber>		pnumOne;
	CComPtr<IDANumber>		pnumScaleAnim;
	CComPtr<IDATransform2>	pTransScaleAnim;

	hr = CDAUtils::GetDANumber( m_pStatics, 1.0f, &pnumOne );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->Sub( pnumOne, pnumAgeRatio, &pnumScaleAnim );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->Scale2UniformAnim( pnumScaleAnim, &pTransScaleAnim );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransScaleAnim );
	
	return S_OK;
}

//**********************************************************************
// Twirler Maker
//**********************************************************************

CTwirlerMaker::CTwirlerMaker( IDA2Statics * pStatics ) : CStarMaker( pStatics )
{
}

HRESULT
CTwirlerMaker::AddRotateTransforms( IDANumber * pnumAgeRatio, VecDATransforms& vecTransforms )
{
	HRESULT	hr	= S_OK;

	CComPtr<IDANumber>		pnumRotateAnim;
	CComPtr<IDATransform2>	pTransRotateAnim;

	hr = m_pStatics->Rotate2Rate( 7.0, &pTransRotateAnim );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransRotateAnim );
	
	return S_OK;
}

//**********************************************************************
// Filled Bubble Maker
//**********************************************************************

CFilledBubbleMaker::CFilledBubbleMaker( IDA2Statics * pStatics ) :
	CSparkMaker( pStatics )
{
}

HRESULT
CFilledBubbleMaker::Init( SparkOptions * pOptions )
{
	HRESULT hr = CSparkMaker::Init( pOptions );
	LMRETURNIFFAILED(hr);
	
	// Colors
	//----------------------------------------------------------------------
	CComPtr<IDAColor> pColorPrimary;
	CComPtr<IDAColor> pColorSecondary;
	
	HSL hsl = pOptions->hslPrimary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorPrimary );
	LMRETURNIFFAILED(hr);

	hsl = pOptions->hslSecondary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorSecondary );
	LMRETURNIFFAILED(hr);

	// Path
	//----------------------------------------------------------------------
	CComPtr<IDAPath2> pPathBvr;
	
	hr = m_pStatics->Oval( 2.0f, 2.0f, &pPathBvr );

	// Base image
	//----------------------------------------------------------------------
	CComPtr<IDAImage>		pFillImage;
	CComPtr<IDALineStyle> 	pLineStyleDefault;
	CComPtr<IDALineStyle>	pLineStyle;
	
	hr = m_pStatics->SolidColorImage( pColorPrimary, &pFillImage );
	LMRETURNIFFAILED(hr);

	hr = CreateLineStyleBvr( &pLineStyleDefault );
	LMRETURNIFFAILED(hr);

	hr = pLineStyleDefault->Color( pColorSecondary, &pLineStyle );
	LMRETURNIFFAILED(hr);

  	hr = pPathBvr->Fill( pLineStyle, pFillImage, &m_pBaseImage );
  	LMRETURNIFFAILED(hr);

	return		hr;
}

HRESULT
CFilledBubbleMaker::CreateBasicSparkImageBvr( SparkOptions * pSparkOptions, IDANumber *, IDAImage ** ppBaseImage )
{
	HRESULT 	hr = S_OK;

	if ( m_pBaseImage == NULL )	return E_FAIL;

	*ppBaseImage = m_pBaseImage;
	(*ppBaseImage)->AddRef();
	
	return hr;
}

//**********************************************************************
// Bubble Maker
//**********************************************************************

CBubbleMaker::CBubbleMaker( IDA2Statics * pStatics ) :
	CSparkMaker( pStatics )
{
}

HRESULT
CBubbleMaker::Init( SparkOptions * pOptions )
{
	HRESULT hr = CSparkMaker::Init( pOptions );
	LMRETURNIFFAILED(hr);

	// Colors
	//----------------------------------------------------------------------
	CComPtr<IDAColor> pColorPrimary;
	CComPtr<IDAColor> pColorSecondary;
	
	HSL hsl = pOptions->hslPrimary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorPrimary );
	LMRETURNIFFAILED(hr);

	hsl = pOptions->hslSecondary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorSecondary );
	LMRETURNIFFAILED(hr);
	
	// Bubble and glint paths
	//----------------------------------------------------------------------
	CComPtr<IDAPath2> pBubblePathBvr;
	CComPtr<IDAPath2> pGlintPathBvr;
	
	hr = m_pStatics->Oval( 2.0f, 2.0f, &pBubblePathBvr );
	LMRETURNIFFAILED(hr);

	VecPathNodes vecNodes;
	hr = MakeGlintPath( 1.0f, vecNodes );
	LMRETURNIFFAILED(hr);

	hr = CPathMaker::CreatePathBvr( m_pStatics, vecNodes, true, &pGlintPathBvr );
	
	CComPtr<IDALineStyle>	pLineStyleDefault;
	CComPtr<IDALineStyle>	pLineStyleOuter;
	CComPtr<IDALineStyle>	pLineStyleInner;
	CComPtr<IDAImage>		pImageOuter;
	CComPtr<IDAImage>		pImageInner;

	hr = CreateLineStyleBvr( &pLineStyleDefault );
	LMRETURNIFFAILED(hr);
	
	hr = pLineStyleDefault->Color( pColorPrimary, &pLineStyleInner );
	LMRETURNIFFAILED(hr);

	hr = pLineStyleDefault->Color( pColorSecondary, &pLineStyleOuter );
	LMRETURNIFFAILED(hr);

  	hr = pGlintPathBvr->Draw( pLineStyleInner, &pImageInner );
  	LMRETURNIFFAILED(hr);

  	hr = pBubblePathBvr->Draw( pLineStyleOuter, &pImageOuter );
  	LMRETURNIFFAILED(hr);

	hr = m_pStatics->Overlay( pImageInner, pImageOuter, &m_pBaseImage );
  	LMRETURNIFFAILED(hr);
	
	return		hr;
}

HRESULT
CBubbleMaker::CreateBasicSparkImageBvr( SparkOptions * pSparkOptions, IDANumber *, IDAImage ** ppBaseImage )
{
	HRESULT 	hr = S_OK;

	if ( m_pBaseImage == NULL )	return E_FAIL;

	*ppBaseImage = m_pBaseImage;
	(*ppBaseImage)->AddRef();
	
	return hr;
}

HRESULT
CBubbleMaker::MakeGlintPath( float fRadius, VecPathNodes& vecNodes )
{
	HRESULT	hr	= S_OK;
	
	fRadius *= 0.7f;

	static const float HANDLE_RATIO = 0.5522919f;
	float fHR = fRadius * HANDLE_RATIO;

	PathNode pn1, pn2, pn3, pn4;

	pn1.nAnchorType = 0;
	pn2.nAnchorType = 0;
	pn3.nAnchorType = 0;
	pn4.nAnchorType = 0;

	pn1.fAnchorX = -fRadius * 1.0f;		pn1.fAnchorY = 0.0f;
	pn2.fAnchorX = 0.0f;	            pn2.fAnchorY = fRadius * 1.0f;
	pn3.fAnchorX = 0.0f;            	pn3.fAnchorY = fRadius;
	pn4.fAnchorX = -fRadius;        	pn4.fAnchorY = 0.0f;

	pn1.fIncomingBCPX = pn1.fAnchorX;
	pn1.fIncomingBCPY = pn1.fAnchorY;
	pn1.fOutgoingBCPX = pn1.fAnchorX;
	pn1.fOutgoingBCPY = pn1.fAnchorY+fHR; 

	pn2.fIncomingBCPX = pn2.fAnchorX-fHR;
	pn2.fIncomingBCPY = pn2.fAnchorY; 
	pn2.fOutgoingBCPX = pn2.fAnchorX;
	pn2.fOutgoingBCPY = pn2.fAnchorY;

	pn3.fIncomingBCPX = pn3.fAnchorX;
	pn3.fIncomingBCPY = pn3.fAnchorY;
	pn3.fOutgoingBCPX = pn3.fAnchorX-fHR;
	pn3.fOutgoingBCPY = pn3.fAnchorY; 

	pn4.fIncomingBCPX = pn4.fAnchorX;
	pn4.fIncomingBCPY = pn4.fAnchorY+fHR; 
	pn4.fOutgoingBCPX = pn4.fAnchorX;
	pn4.fOutgoingBCPY = pn4.fAnchorY;

	vecNodes.push_back( pn1 );
	vecNodes.push_back( pn2 );
	vecNodes.push_back( pn3 );
	vecNodes.push_back( pn4 );
	
	return hr;
}

//**********************************************************************
// Cloud Maker
//**********************************************************************

CCloudMaker::CCloudMaker( IDA2Statics * pStatics ) :
	CSparkMaker( pStatics )
{
}

HRESULT
CCloudMaker::Init( SparkOptions * pOptions )
{
	HRESULT hr = CSparkMaker::Init( pOptions );
	LMRETURNIFFAILED(hr);

	// Smoke path
	//----------------------------------------------------------------------
	PathNode rgPathNodes[] = 
	{
		{-37.25f, 13.0f, -17.808838f, 9.077637f, -7.0f, 28.75f, 0},
		{24.5f, 16.5f, 19.0f, 5.5f, 25.0f, 7.5f, 0},
		{35.0f, 7.0f, 37.0f, 0.75f, 41.5f, 2.75f, 0},
		{47.75f, -2.25f, 46.75f, -6.25f, 74.5f, -9.5f, 0},
		{63.5f, -26.5f, 31.011475f, -21.54663f, 20.5f, -28.75f, 0},
		{-7.75f, -25.25f, -10.008911f, -21.6875f, -20.5f, -25.5f, 0},
		{-48.0f, -26.0f, -50.770508f, -19.394653f, -73.75f, -19.75f, 0},
		{-61.0f, -0.25f, -49.557495f, -4.092285f, -50.75f, 5.25f, 0}
	};

	CComPtr<IDAPath2>	pPathBvr;
	VecPathNodes		vecNodes;
	long	cNodes = sizeof( rgPathNodes ) / sizeof( rgPathNodes[0] );

	for ( int i = 0; i < cNodes; i++ )
	{
		vecNodes.push_back( rgPathNodes[i] );
	}
	
	hr = CPathMaker::CreatePathBvr( m_pStatics, vecNodes, true,
									&pPathBvr );
	LMRETURNIFFAILED(hr);

	// REVIEW: Scale the points here.
	CComPtr<IDATransform2>	pTransScale;
	hr = m_pStatics->Scale2Uniform( 0.25, &pTransScale );
	LMRETURNIFFAILED(hr);

	hr = pPathBvr->Transform( pTransScale, &m_pPathBvr );
	
	return		hr;
}

HRESULT
CCloudMaker::CreateBasicSparkImageBvr( SparkOptions * pOptions, IDANumber * pnumAgeRatio, IDAImage ** ppBaseImage )
{
	HRESULT 	hr = S_OK;

	CComPtr<IDANumber>		pnumHue;
	CComPtr<IDANumber>		pnumLum;
	CComPtr<IDANumber>		pnumSat;
	CComPtr<IDAColor>		pColorAnim;
	CComPtr<IDAImage>		pFillImage;
	HSL						hsl1 = pOptions->hslPrimary;
	HSL						hsl2 = pOptions->hslSecondary;

	// Interpolate between the 2 colors
	//----------------------------------------------------------------------
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.hue, hsl2.hue, pnumAgeRatio, &pnumHue );
	LMRETURNIFFAILED(hr);
	
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.sat, hsl2.sat, pnumAgeRatio, &pnumSat );
	LMRETURNIFFAILED(hr);
	
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.lum, hsl2.lum, pnumAgeRatio, &pnumLum );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->ColorHslAnim( pnumHue, pnumSat, pnumLum, &pColorAnim );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->SolidColorImage( pColorAnim, &pFillImage );
	LMRETURNIFFAILED(hr);

	CComPtr<IDALineStyle> 	pLineStyleEmpty;
	hr = m_pStatics->get_EmptyLineStyle( &pLineStyleEmpty );
	LMRETURNIFFAILED(hr);

  	hr = m_pPathBvr->Fill( pLineStyleEmpty, pFillImage, ppBaseImage );
  	LMRETURNIFFAILED(hr);

	return hr;
}


//**********************************************************************
// Smoke Maker
//**********************************************************************

CSmokeMaker::CSmokeMaker( IDA2Statics * pStatics ) :
	CSparkMaker( pStatics )
{
}

HRESULT
CSmokeMaker::Init( SparkOptions * pOptions )
{
	HRESULT hr = CSparkMaker::Init( pOptions );
	LMRETURNIFFAILED(hr);

	// Smoke path
	//----------------------------------------------------------------------
	PathNode rgPathNodes[] = 
	{
		{-16.918701f, 11.05835f, -12.742432f, 11.241455f, -15.564819f, 17.944336f, 0},
		{-1.7054443f, 20.058594f, 0.23352051f, 15.299072f, 5.901123f, 20.333252f, 0},
		{17.907715f, 14.597412f, 13.137573f, 8.6188965f, 19.995728f, 12.034668f, 0},
		{24.321045f, 0.92907715f, 18.355103f, -0.04724121f, 24.171875f, -1.1456299f, 0},
		{24.917725f, -14.447876f, 11.643433f, -12.12915f, 13.582275f, -16.278564f, 0},
		{4.633423f, -19.939697f, -0.7359619f, -15.058105f, -5.0612793f, -20.305786f, 0},
		{-20.423706f, -16.522583f, -17.589844f, -7.6136475f, -21.616821f, -7.9798584f, 0},
		{-23.555786f, -3.4643555f, -19.976196f, -1.5117188f, -25.35852f, -0.043701172f, 0},
		{-23.321411f, 8.708008f, -15.725464f, 7.946289f, -15.725464f, 7.946289f, 0}
	};

	CComPtr<IDAPath2>	pPathBvr;
	VecPathNodes		vecNodes;
	long	cNodes = sizeof( rgPathNodes ) / sizeof( rgPathNodes[0] );

	for ( int i = 0; i < cNodes; i++ )
	{
		vecNodes.push_back( rgPathNodes[i] );
	}
	
	hr = CPathMaker::CreatePathBvr( m_pStatics, vecNodes, true,
									&pPathBvr );
	LMRETURNIFFAILED(hr);

	// REVIEW: Scale the points here.
	CComPtr<IDATransform2>	pTransScale;
	hr = m_pStatics->Scale2Uniform( 0.25, &pTransScale );
	LMRETURNIFFAILED(hr);

	hr = pPathBvr->Transform( pTransScale, &m_pPathBvr );
	
	return		hr;
}

HRESULT
CSmokeMaker::AddScaleTransforms( IDANumber * pnumAgeRatio, VecDATransforms& vecTransforms )
{
	HRESULT	hr	= S_OK;

	CComPtr<IDATransform2>	pTransScaleAnim;

	hr = m_pStatics->Scale2UniformAnim( pnumAgeRatio, &pTransScaleAnim );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransScaleAnim );
	
	return S_OK;
}

HRESULT
CSmokeMaker::CreateBasicSparkImageBvr( SparkOptions * pOptions, IDANumber * pnumAgeRatio, IDAImage ** ppBaseImage )
{
	HRESULT 	hr = S_OK;

	CComPtr<IDANumber>		pnumHue;
	CComPtr<IDANumber>		pnumLum;
	CComPtr<IDANumber>		pnumSat;
	CComPtr<IDAColor>		pColorAnim;
	CComPtr<IDAImage>		pFillImage;
	HSL						hsl1 = pOptions->hslPrimary;
	HSL						hsl2 = pOptions->hslSecondary;

	// Interpolate between the 2 colors
	//----------------------------------------------------------------------
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.hue, hsl2.hue, pnumAgeRatio, &pnumHue );
	LMRETURNIFFAILED(hr);
	
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.sat, hsl2.sat, pnumAgeRatio, &pnumSat );
	LMRETURNIFFAILED(hr);
	
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.lum, hsl2.lum, pnumAgeRatio, &pnumLum );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->ColorHslAnim( pnumHue, pnumSat, pnumLum, &pColorAnim );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->SolidColorImage( pColorAnim, &pFillImage );
	LMRETURNIFFAILED(hr);

	CComPtr<IDALineStyle> 	pLineStyleEmpty;
	hr = m_pStatics->get_EmptyLineStyle( &pLineStyleEmpty );
	LMRETURNIFFAILED(hr);

  	hr = m_pPathBvr->Fill( pLineStyleEmpty, pFillImage, ppBaseImage );
  	LMRETURNIFFAILED(hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\sparkmaker.h ===
//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    SparkMaker.h
//
// Author:	elainela
//
// Created:	11/19/98
//
// Abstract:    Definition of the SparkMaker for the AutoEffect.
//
//*****************************************************************************

#ifndef __SPARKMAKER_H__
#define __SPARKMAKER_H__

#include <vector>

#include "lmrt.h"
#include "pathmaker.h"

using namespace std;

typedef CComPtr<IDATransform2>	DATransform2Ptr;
typedef vector<DATransform2Ptr> VecDATransforms;

#define	SPARK_SCALE		(1 << 0)
#define SPARK_ROTATE	(1 << 1)
#define SPARK_TRANSLATE	(1 << 2)

//**********************************************************************

struct HSL
{
	float hue;
	float sat;
	float lum;
};

struct SparkOptions
{
	HSL	hslPrimary;
	HSL hslSecondary;
};

//**********************************************************************

class CSparkMaker
{
public:
	enum Type
	{
		SPARKLES,
		TWIRLERS,
		BUBBLES,
		FILLEDBUBBLES,
		CLOUDS,
		SMOKE,
		NUM_TYPES
	};

	static HRESULT CreateSparkMaker( IDA2Statics * pStatics, Type iType, CSparkMaker ** ppMaker );
	
public:
	CSparkMaker( IDA2Statics * pStatics );
	virtual ~CSparkMaker();
	
public:
	virtual HRESULT	Init( SparkOptions * );
	
	virtual HRESULT	GetSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr );

	virtual long	GetTransformFlags() { return 0L; }
	
	virtual HRESULT AddScaleTransforms( IDANumber * pnumAge, VecDATransforms& ) { return S_OK; }
	virtual HRESULT AddRotateTransforms( IDANumber * pnumAge, VecDATransforms& ) { return S_OK; }
	virtual HRESULT AddTranslateTransforms( IDANumber * pnumAge, VecDATransforms& ) { return S_OK; }
	
protected:
	virtual HRESULT CreateLineStyleBvr( IDALineStyle ** ppLineStyle );
	virtual HRESULT CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) = 0;

protected:
	IDA2Statics 	* m_pStatics;
	bool			m_fInitialized;
};

//**********************************************************************

class CStarMaker : public CSparkMaker
{
public:
	CStarMaker( IDA2Statics * );

	HRESULT	Init( SparkOptions *);

protected:
	static const int	NUM_STARARMS;
	
protected:
	HRESULT	CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) ;

protected:
	CComPtr<IDAImage> m_pBaseImage;
};

//**********************************************************************

class CSparkleMaker : public CStarMaker
{
public:
	CSparkleMaker( IDA2Statics * );

	long	GetTransformFlags()	{ return SPARK_SCALE; }
	
	HRESULT AddScaleTransforms( IDANumber * pnumAgeRatio, VecDATransforms& );
};

//**********************************************************************

class CTwirlerMaker : public CStarMaker
{
public:
	CTwirlerMaker( IDA2Statics * );

	long	GetTransformFlags()	{ return SPARK_ROTATE; }
	
	HRESULT AddRotateTransforms( IDANumber * pnumAgeRatio, VecDATransforms& );
};

//**********************************************************************

class CFilledBubbleMaker : public CSparkMaker
{
public:
	CFilledBubbleMaker( IDA2Statics * );

	HRESULT	Init( SparkOptions * );

protected:
	HRESULT	CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) ;

protected:
	CComPtr<IDAImage> m_pBaseImage;
};

//**********************************************************************

class CBubbleMaker : public CSparkMaker
{
public:
	CBubbleMaker( IDA2Statics * );

	HRESULT	Init( SparkOptions * );

protected:
	HRESULT	CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) ;
	HRESULT	MakeGlintPath( float fRadius, VecPathNodes& vecNodes );

protected:
	CComPtr<IDAImage> m_pBaseImage;
};

//**********************************************************************

class CCloudMaker : public CSparkMaker
{
public:
	CCloudMaker( IDA2Statics * );

	HRESULT	Init( SparkOptions * );

protected:
	HRESULT	CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) ;

protected:
	CComPtr<IDAPath2> m_pPathBvr;
};

//**********************************************************************

class CSmokeMaker : public CSparkMaker
{
public:
	CSmokeMaker( IDA2Statics * );

	HRESULT	Init( SparkOptions * );

	long	GetTransformFlags()	{ return SPARK_SCALE; }
	
	HRESULT AddScaleTransforms( IDANumber * pnumAgeRatio, VecDATransforms& );
	
protected:
	HRESULT	CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) ;

protected:
	CComPtr<IDAPath2> m_pPathBvr;
};

//**********************************************************************
// Inlines
//**********************************************************************

inline CSparkMaker::CSparkMaker( IDA2Statics * pStatics )
{
	m_fInitialized	= false;
	m_pStatics		= pStatics;		// weak ref
}

inline CSparkMaker::~CSparkMaker()
{
}

inline HRESULT CSparkMaker::Init( SparkOptions * )
{
	m_fInitialized = true;
	return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\dll\main.cpp ===
//*****************************************************************************
//
// Microsoft Chrome
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    main.cpp
//
// Author:	    jeffort
//
// Created:	    10/07/98
//
// Abstract:    main dll file
// Modifications:
// 10/07/98 jeffort created file
//
//*****************************************************************************
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#include "headers.h"
#include "crbvr.h"
#include "factory.h"
#include "colorbvr.h"
#include "rotate.h"
#include "scale.h"
#include "move.h"
#include "path.h"
#include "number.h"
#include "set.h"
#include "actorbvr.h"
#include "effect.h"

//*****************************************************************************

CComModule _Module;

//*****************************************************************************

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CrBehaviorFactory, CCrBehaviorFactory)
    OBJECT_ENTRY(CLSID_CrColorBvr, CColorBvr)
    OBJECT_ENTRY(CLSID_CrRotateBvr, CRotateBvr)
    OBJECT_ENTRY(CLSID_CrScaleBvr, CScaleBvr)
    OBJECT_ENTRY(CLSID_CrMoveBvr, CMoveBvr)
    OBJECT_ENTRY(CLSID_CrPathBvr, CPathBvr)
    OBJECT_ENTRY(CLSID_CrNumberBvr, CNumberBvr)
    OBJECT_ENTRY(CLSID_CrSetBvr, CSetBvr)
    OBJECT_ENTRY(CLSID_CrActorBvr, CActorBvr)
    OBJECT_ENTRY(CLSID_CrEffectBvr, CEffectBvr)
END_OBJECT_MAP()

//*****************************************************************************

HINSTANCE  hInst;

//*****************************************************************************

extern "C"
BOOL WINAPI 
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        hInst = hInstance;
        DisableThreadLibraryCalls(hInstance);
        _Module.Init(ObjectMap, hInstance);
    }        
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
//#ifdef DEBUGMEM
//		_CrtDumpMemoryLeaks();
//#endif
	
    }
    
    return TRUE;    // ok
} //DllMain

//*****************************************************************************

STDAPI 
DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow

//*****************************************************************************

STDAPI 
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
} // DllGetClassObject

//*****************************************************************************

STDAPI 
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
} // DllRegisterServer

//*****************************************************************************

STDAPI 
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
} // DllUnregisterServer

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\lmfactory.cpp ===
// LMBehaviorFactory.cpp : Implementation of CLMBehaviorFactory

#include "headers.h"

#include "lmattrib.h"
#include "lmfactory.h"

//chrome includes
#include "..\chrome\include\utils.h"
#include "..\chrome\include\defaults.h"
#include "..\chrome\include\factory.h"

// Behaviors
//#include "jump.h" //punted for v1
//#include "avoidfollow.h" //punted for v1
#include "autoeffect.h"

/////////////////////////////////////////////////////////////////////////////
// CLMBehaviorFactory

CLMBehaviorFactory::CLMBehaviorFactory():m_chromeFactory(NULL)
{
}

CLMBehaviorFactory::~CLMBehaviorFactory()
{
    if( m_chromeFactory != NULL )
    {
        ReleaseInterface( m_chromeFactory );
    }
}

STDMETHODIMP CLMBehaviorFactory::FindBehavior( LPOLESTR pchBehaviorName,
											   LPOLESTR	pchBehaviorURL,
											   IUnknown * pUnkArg,
											   IElementBehavior ** ppBehavior)
{
    HRESULT hr = E_FAIL;

    // (TIME bails if we are in 16 or less color mode. Need to the same
    // here because LM crashes if time is not around.)
    // If we are in 16 or less color mode on the Primary Device, bail.
    // Note: Multi-monitor API are currently unavailable in this build
    HWND hwndDesktop = NULL;
    hwndDesktop = GetDesktopWindow();
    if (NULL != hwndDesktop)
    {
        HDC hdcPrimaryDevice = NULL;
        hdcPrimaryDevice = GetDC(NULL);
        if (NULL != hdcPrimaryDevice)
        {
            int bpp = 32;
            bpp = GetDeviceCaps(hdcPrimaryDevice, BITSPIXEL);
            ReleaseDC(hwndDesktop, hdcPrimaryDevice);
            if (bpp <= 4)
            {
                // This prevents LM bvrs from being created
                return E_FAIL;
            }
        }
    }

    // check the paramters passed in to ensure they are valid
	if (pUnkArg == NULL ||
		ppBehavior == NULL) 
	{
		DPF_ERR("Invalid Parameter passed into FindBehavior is NULL");
		return SetErrorInfo(E_INVALIDARG);
	}

    BSTR bstrTagName;
    if (pchBehaviorName == NULL || _wcsicmp(DEFAULT_BEHAVIOR_AS_TAG_URL, pchBehaviorName) == 0)
    {
        // we need to get the tag name from the HTMLElement that we are being
        // created from.  To do this we use the IUnknown to get a IElementBehaviorSite,
        // from this we get the HTMLElement, and get the tagname from this.
        IElementBehaviorSite *pBehaviorSite;
        hr = pUnkArg->QueryInterface(IID_TO_PPV(IElementBehaviorSite, &pBehaviorSite));
        if (FAILED(hr))
        {
            DPF_ERR("Unable to get an ElementBehaviorSite from IUnknown in FindBehavior");
            return SetErrorInfo(hr);
        }
        DASSERT(pBehaviorSite != NULL);
        IHTMLElement *pElement;
        hr = pBehaviorSite->GetElement(&pElement);
        ReleaseInterface(pBehaviorSite);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving HTMLElement from BehaviorSite in FindBehavior");
            return SetErrorInfo(hr);
        }
        DASSERT(pElement != NULL);
        hr = pElement->get_tagName(&bstrTagName);
        ReleaseInterface(pElement);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving tagname from HTML element in FindBehavior");
            return SetErrorInfo(hr);
        }
    }
    else
    {
        bstrTagName = pchBehaviorName;
    }
    if (_wcsicmp(BEHAVIOR_TYPE_AUTOEFFECT, bstrTagName) == 0)
	{
        CComObject<CAutoEffectBvr> *pAutoEffect;
        hr = CComObject<CAutoEffectBvr>::CreateInstance(&pAutoEffect);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating auto effect behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pAutoEffect->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
	}
    else if (_wcsicmp(BEHAVIOR_TYPE_AVOIDFOLLOW, bstrTagName) == 0)
	{
        //AvoidFollow punted for version 1
        /*
        CComObject<CAvoidFollowBvr> *pAvoidFollow;
        hr = CComObject<CAvoidFollowBvr>::CreateInstance(&pAvoidFollow);
        if( SUCCEEDED( hr ) )
        {
            // this will do the necessary AddRef to the object
            hr = pAvoidFollow->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		    DASSERT(SUCCEEDED(hr));
        }
        else //failed to create the avoid follow behavior
		{
			DPF_ERR("Error creating AvoidFollow behavior in FindBehavior");
			return SetErrorInfo(hr);
        }
        */
        hr = E_INVALIDARG;
	}
    else if ( _wcsicmp(BEHAVIOR_TYPE_JUMP, bstrTagName) == 0 )
	{
        //Jump punted for version 1
        /*
        CComObject<CJumpBvr> *pJump;
        hr = CComObject<CJumpBvr>::CreateInstance(&pJump);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating Jump behavior in FIndBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pJump->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        */
        hr = E_INVALIDARG;
	}
    else
    {
        //this may be a request for a chrome behavior.
        //request the behavior from the chrome factory.
        if( m_chromeFactory == NULL )
        {
            //cache a chrome factory
            CComObject<CCrBehaviorFactory> *pFactory;
            hr = CComObject<CCrBehaviorFactory>::CreateInstance(&pFactory);
            if( SUCCEEDED( hr ) )
            {
                hr = pFactory->QueryInterface( IID_TO_PPV(IElementBehaviorFactory, &m_chromeFactory) );
                if( FAILED( hr ) )
                {
                    DPF_ERR( "Error Querying the chrome behavior factory for IElementBehaviorFactory" );
                    return SetErrorInfo( hr );
                }
                //otherwise we succeeded and all is well.
            }
            else
            {
                DPF_ERR( "Error creating the chrome behavior factory" );
                return SetErrorInfo( hr );
            }
        }

        // QI pUnkArg for pBehaviorSite and pass to FindBehavior(...)
        // TODO: (dilipk) this QI goes away with the old FindBehavior Signature (#38656).
        IElementBehaviorSite *pBehaviorSite = NULL;
        hr = pUnkArg->QueryInterface(IID_TO_PPV(IElementBehaviorSite, &pBehaviorSite)); 
        if (FAILED(hr))
        {
            DPF_ERR("Error Querying for IElementBehaviorSite in FindBehavior");
            return hr;
        }
        hr = m_chromeFactory->FindBehavior( pchBehaviorName, 
                                            pchBehaviorURL, 
                                            pBehaviorSite, 
                                            ppBehavior );
        ReleaseInterface(pBehaviorSite);
    }
    if (bstrTagName != pchBehaviorName)
        SysFreeString(bstrTagName);
	
    return hr;

}

STDMETHODIMP CLMBehaviorFactory::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag2 )
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}

STDMETHODIMP CLMBehaviorFactory::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2 )
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"
#include "resource.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\behaviors\pathmaker.cpp ===
#include "headers.h" 

#include "pathmaker.h"

#include "..\chrome\src\dautil.h"
#include "..\chrome\include\utils.h"

typedef CComPtr<IDAPoint2> DAPoint2Ptr;
typedef CComPtr<IDANumber> DANumberPtr;

static const float PI		= 3.14159265359f;
static const float LINETO	= 2.0f;
static const float BEZIERTO = 4.0f;
static const float MOVETO	= 6.0f;
	
HRESULT
CPathMaker::CreatePathBvr( IDA2Statics * pStatics, VecPathNodes& vecNodes, bool fClosed, IDAPath2 ** ppPath )
{
	HRESULT	hr = S_OK;

	long cNodes = vecNodes.size();
	
	// don't loop around to beginning if path isn't closed.
	if ( !fClosed ) cNodes--;
	
	vector<DAPoint2Ptr> vecPoints;
	vector<DANumberPtr> vecCodes;
	
	// Move to 1st point
	//----------------------------------------------------------------------
	long				cPoints				= 0;
	CComPtr<IDANumber>	pnumCodeLineTo;
	CComPtr<IDANumber>	pnumCodeMoveTo;
	CComPtr<IDANumber>	pnumCodeBezierTo;
	CComPtr<IDAPoint2>	pPointFirst;
	
	hr = CDAUtils::GetDANumber( pStatics, LINETO, &pnumCodeLineTo );
	LMRETURNIFFAILED(hr);
	
	hr = CDAUtils::GetDANumber( pStatics, MOVETO, &pnumCodeMoveTo );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, BEZIERTO, &pnumCodeBezierTo );
	LMRETURNIFFAILED(hr);

	hr = pStatics->Point2( vecNodes[0].fAnchorX, vecNodes[0].fAnchorY, &pPointFirst );
	LMRETURNIFFAILED(hr);

	vecPoints.push_back( pPointFirst );
	vecCodes.push_back( pnumCodeMoveTo );
	cPoints++;

	// Add curves
	//----------------------------------------------------------------------
	for ( long liNode = 0; liNode < cNodes; liNode++ )
	{
		PathNode& nodePrev = vecNodes[ liNode ];
		PathNode& nodeNext = vecNodes[ (liNode+1) % cNodes ];

		CComPtr<IDAPoint2>	pPointAnchor;
		
		// Special case of linear bezier segment?
		//----------------------------------------------------------------------
		if ( ( nodePrev.fAnchorX == nodePrev.fOutgoingBCPX ) &&
			 ( nodePrev.fAnchorY == nodePrev.fOutgoingBCPY ) &&
			 ( nodeNext.fAnchorX == nodeNext.fIncomingBCPX ) &&
			 ( nodeNext.fAnchorY == nodeNext.fIncomingBCPY ) )
		{
			// Anchor point
			hr = pStatics->Point2( nodeNext.fAnchorX, nodeNext.fAnchorY,
								   &pPointAnchor );
			LMRETURNIFFAILED(hr);
		
			vecPoints.push_back( pPointAnchor );
			vecCodes.push_back( pnumCodeLineTo );
			cPoints++;
		}
		// Bezier curve segment
		//----------------------------------------------------------------------
		else
		{
			CComPtr<IDAPoint2>	pPointOutgoing; 
			CComPtr<IDAPoint2>	pPointIncoming; 

			// Outgoing point
			hr = pStatics->Point2( nodePrev.fOutgoingBCPX, nodePrev.fOutgoingBCPY,
								   &pPointOutgoing );
			LMRETURNIFFAILED(hr);
		
			vecPoints.push_back( pPointOutgoing );
			vecCodes.push_back( pnumCodeBezierTo );
			cPoints++;

			// Incoming point
			hr = pStatics->Point2( nodeNext.fIncomingBCPX, nodeNext.fIncomingBCPY,
								   &pPointIncoming );
			LMRETURNIFFAILED(hr);
		
			vecPoints.push_back( pPointIncoming );
			vecCodes.push_back( pnumCodeBezierTo );
			cPoints++;
		
			// Anchor point
			hr = pStatics->Point2( nodeNext.fAnchorX, nodeNext.fAnchorY,
								   &pPointAnchor );
			LMRETURNIFFAILED(hr);
		
			vecPoints.push_back( pPointAnchor );
			vecCodes.push_back( pnumCodeBezierTo );
			cPoints++;
		}
	}

	// Now tell DA to create the path bvr for us.
	//----------------------------------------------------------------------
	IDAPoint2 ** rgPoints = new IDAPoint2 * [ cPoints ];
	IDANumber ** rgCodes  = new IDANumber * [ cPoints ];

	if ( ( rgPoints == NULL ) || ( rgCodes == NULL ) )
	{
		delete [] rgPoints;
		delete [] rgCodes;
		return E_OUTOFMEMORY;
	}
	
	for ( long liPoint = 0; liPoint < cPoints; liPoint++ )
	{
		rgPoints[liPoint]	= vecPoints[liPoint];
		rgCodes[liPoint]	= vecCodes[liPoint];
	}
	
	hr = pStatics->PolydrawPathEx( cPoints, rgPoints, cPoints, rgCodes, ppPath );
	
	delete [] rgPoints;
	delete [] rgCodes;
	
	return hr;
}

//**********************************************************************

// Following the version in PathUtils.java
HRESULT
CPathMaker::CreateStarPath( int cArms,
							double dInnerRadius,
							double dOuterRadius,
							VecPathNodes& vecNodes )
{
	HRESULT	hr	= S_OK;

	if ( ( cArms < 3 ) ||
		 ( dInnerRadius < 0.0 ) ||
		 ( dOuterRadius < dInnerRadius ) )
	{
		return E_FAIL;
	}

	// Step angle: 360 degrees divided by number of arms.
	//----------------------------------------------------------------------
	double	dHalfStepAngle		= PI / cArms;
	double	dStepAngle			= 2.0 * dHalfStepAngle;
	double	dOffsetAngle		= PI / 2.0;

	// Move to first vertex
	//----------------------------------------------------------------------
	double	dOuterVertexX = dOuterRadius * cos( dOffsetAngle );
	double	dOuterVertexY = dOuterRadius * sin( dOffsetAngle );

	PathNode	node;

	node.fAnchorX = node.fOutgoingBCPX = node.fIncomingBCPX = dOuterVertexX;
	node.fAnchorY = node.fOutgoingBCPY = node.fIncomingBCPY = dOuterVertexY;
	node.nAnchorType = 0;
	vecNodes.push_back( node );

	double	dOuterVertexAngle;
	double	dInnerVertexAngle;
	double 	dInnerVertexX, dInnerVertexY;
		
	for ( int iArm = 0; iArm < cArms; iArm++ )
	{
		//	Compute angle for the (i + 1)th outer vertex
		//	and the angle for the i'th inner vertex.
		dOuterVertexAngle	= (iArm+1) * dStepAngle + dOffsetAngle;
		dInnerVertexAngle	= dOuterVertexAngle - dHalfStepAngle;

		//	Extend a line from the outer vertex of the current arm
		//	to the inner vertex between this arm and the next.
		dInnerVertexX = dInnerRadius * cos( dInnerVertexAngle );
		dInnerVertexY = dInnerRadius * sin( dInnerVertexAngle );
		
		node.fAnchorX = node.fOutgoingBCPX = node.fIncomingBCPX = dInnerVertexX;
		node.fAnchorY = node.fOutgoingBCPY = node.fIncomingBCPY = dInnerVertexY;
		node.nAnchorType = 0;
		vecNodes.push_back( node );

		//	Extend a line from the inner vertex between this arm and
		//	the next to the outer vertex of the next arm.  For the
		//	last arm this will extend a line back to the outer vertex
		//	of the very first arm.
		dOuterVertexX = dOuterRadius * cos( dOuterVertexAngle );
		dOuterVertexY = dOuterRadius * sin( dOuterVertexAngle );

		node.fAnchorX = node.fOutgoingBCPX = node.fIncomingBCPX = dOuterVertexX;
		node.fAnchorY = node.fOutgoingBCPY = node.fIncomingBCPY = dOuterVertexY;
		node.nAnchorType = 0;
		vecNodes.push_back( node );
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\idl\makefile.inc ===
$(SDKDIR)\crbvr.h : $(O)\crbvr.h
    copy /v $** $@

$(SDKDIR)\crbvr.tlb : $(O)\crbvr.tlb
    copy /v $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\action.h ===
#pragma once
#ifndef __ACTION_H_
#define __ACTION_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    action.h
//
// Author:	kurtj
//
// Created:	11/23//98
//
// Abstract:    set behavior class definition
// Modifications:
// 11/23/98 kurtj created file
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#define NUM_ACTION_PROPS 0

//*****************************************************************************

class ATL_NO_VTABLE CActionBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CActionBvr, &CLSID_CrActionBvr>,
    public IConnectionPointContainerImpl<CActionBvr>,
    public IPropertyNotifySinkCP<CActionBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrActionBvr, &IID_ICrActionBvr, &LIBID_ChromeBehavior>,
    error me here
#else
	public IDispatchImpl<ICrActionBvr, &IID_ICrActionBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CActionBvr)
	COM_INTERFACE_ENTRY(ICrActionBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CActionBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_ACTIONBVR)

	CActionBvr();
    virtual ~CActionBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrActionBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    //ICrActionBvr
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

	HRESULT BuildChildren( IDispatch *pdispActor );
	HRESULT CallBuildBehaviors( IDispatch *pDisp, DISPPARAMS *pParams, VARIANT *pResult );

private:
	static WCHAR                *m_rgPropNames[NUM_ACTION_PROPS]; 


}; // CActionBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__ACTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\idl\crbvrdispid.h ===
#ifndef __CRBEHAVIORDISPID_H_
#define __CRBEHAVIORDISPID_H_
//*********************************************************************************
//
// File: crbvrdispid.h
// Author: jeff ort
// Date Created: Sept 26, 1998
//
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
//
//*********************************************************************************


// Since these are DHTML behaviors, we need to keep the
// dispid's low due to a MSHTML bug.  We will make each
// group have a base of 1, and increment from here

#define DISPID_COLORBVR_BASE						1
#define DISPID_ICRCOLORBVR_FROM						(DISPID_COLORBVR_BASE + 0)
#define DISPID_ICRCOLORBVR_TO						(DISPID_COLORBVR_BASE + 1)
#define DISPID_ICRCOLORBVR_PROPERTY					(DISPID_COLORBVR_BASE + 2)
#define DISPID_ICRCOLORBVR_DIRECTION				(DISPID_COLORBVR_BASE + 3)
#define DISPID_ICRCOLORBVR_ANIMATES					(DISPID_COLORBVR_BASE + 4)
#define DISPID_ICRCOLORBVR_BUILDBVRFRAGS			(DISPID_COLORBVR_BASE + 5)

#define DISPID_ROTATEBVR_BASE						1
#define DISPID_ICRROTATEBVR_FROM					(DISPID_ROTATEBVR_BASE + 0)
#define DISPID_ICRROTATEBVR_TO						(DISPID_ROTATEBVR_BASE + 1)
#define DISPID_ICRROTATEBVR_BY						(DISPID_ROTATEBVR_BASE + 2)
#define DISPID_ICRROTATEBVR_TYPE					(DISPID_ROTATEBVR_BASE + 3)
#define DISPID_ICRROTATEBVR_MODE					(DISPID_ROTATEBVR_BASE + 4)
#define DISPID_ICRROTATEBVR_ANIMATES				(DISPID_ROTATEBVR_BASE + 5)
#define DISPID_ICRROTATEBVR_BUILDBVRFRAGS			(DISPID_ROTATEBVR_BASE + 6)

#define DISPID_SCALEBVR_BASE						1
#define DISPID_ICRSCALEBVR_FROM						(DISPID_SCALEBVR_BASE + 0)
#define DISPID_ICRSCALEBVR_TO					    (DISPID_SCALEBVR_BASE + 1)
#define DISPID_ICRSCALEBVR_BY						(DISPID_SCALEBVR_BASE + 2)
#define DISPID_ICRSCALEBVR_TYPE						(DISPID_SCALEBVR_BASE + 3)
#define DISPID_ICRSCALEBVR_MODE						(DISPID_SCALEBVR_BASE + 4)
#define DISPID_ICRSCALEBVR_ANIMATES					(DISPID_SCALEBVR_BASE + 5)
#define DISPID_ICRSCALEBVR_BUILDBVRFRAGS			(DISPID_SCALEBVR_BASE + 6)

#define DISPID_MOVEBVR_BASE							1
#define DISPID_ICRMOVEBVR_FROM						(DISPID_MOVEBVR_BASE + 0)
#define DISPID_ICRMOVEBVR_TO						(DISPID_MOVEBVR_BASE + 1)
#define DISPID_ICRMOVEBVR_BY						(DISPID_MOVEBVR_BASE + 2)
#define DISPID_ICRMOVEBVR_ANIMATES					(DISPID_MOVEBVR_BASE + 3)
#define DISPID_ICRMOVEBVR_V							(DISPID_MOVEBVR_BASE + 4)
#define DISPID_ICRMOVEBVR_TYPE						(DISPID_MOVEBVR_BASE + 5)
#define DISPID_ICRMOVEBVR_MODE						(DISPID_MOVEBVR_BASE + 6)
#define DISPID_ICRMOVEBVR_DIRECTION					(DISPID_MOVEBVR_BASE + 7)
#define DISPID_ICRMOVEBVR_BUILDBVRFRAGS				(DISPID_MOVEBVR_BASE + 8)

#define DISPID_ICRMOVEBVR_CURRENTX					(DISPID_MOVEBVR_BASE + 9)
#define DISPID_ICRMOVEBVR_CURRENTY					(DISPID_MOVEBVR_BASE + 10)

#define DISPID_PATHBVR_BASE							1
#define DISPID_ICRPATHBVR_V							(DISPID_PATHBVR_BASE + 0)
#define DISPID_ICRPATHBVR_DATRANSFORM				(DISPID_PATHBVR_BASE + 1)

#define DISPID_NUMBERBVR_BASE						1
#define DISPID_ICRNUMBERBVR_FROM					(DISPID_NUMBERBVR_BASE + 0)
#define DISPID_ICRNUMBERBVR_TO						(DISPID_NUMBERBVR_BASE + 1)
#define DISPID_ICRNUMBERBVR_BY						(DISPID_NUMBERBVR_BASE + 2)
#define DISPID_ICRNUMBERBVR_TYPE					(DISPID_NUMBERBVR_BASE + 3)
#define DISPID_ICRNUMBERBVR_MODE					(DISPID_NUMBERBVR_BASE + 4)
#define DISPID_ICRNUMBERBVR_PROPERTY				(DISPID_NUMBERBVR_BASE + 5)
#define DISPID_ICRNUMBERBVR_EXPRESSION				(DISPID_NUMBERBVR_BASE + 6)
#define DISPID_ICRNUMBERBVR_ANIMATES				(DISPID_NUMBERBVR_BASE + 7)
#define DISPID_ICRNUMBERBVR_BUILDBVRFRAGS			(DISPID_NUMBERBVR_BASE + 8)

#define DISPID_SETBVR_BASE							1
#define DISPID_ICRSETBVR_VALUE						(DISPID_SETBVR_BASE + 0)
#define DISPID_ICRSETBVR_PROPERTY					(DISPID_SETBVR_BASE + 1)
#define DISPID_ICRSETBVR_TYPE						(DISPID_SETBVR_BASE + 2)
#define DISPID_ICRSETBVR_ANIMATES					(DISPID_SETBVR_BASE + 3)
#define DISPID_ICRSETBVR_BUILDBVRFRAGS				(DISPID_SETBVR_BASE + 4)

#define DISPID_ACTORBVR_BASE						1
#define DISPID_ICRACTORBVR_ANIMATES					(DISPID_ACTORBVR_BASE + 0)
#define DISPID_ICRACTORBVR_SCALE					(DISPID_ACTORBVR_BASE + 1)
#define DISPID_ICRACTORBVR_PIXELSCALE				(DISPID_ACTORBVR_BASE + 2)
#define DISPID_ICRACTORBVR_ADDBEHAVIORFRAGMENT		(DISPID_ACTORBVR_BASE + 3)
#define DISPID_ICRACTORBVR_ADDMOUSELISTENER			(DISPID_ACTORBVR_BASE + 4)
#define DISPID_ICRACTORBVR_REMOVEMOUSELISTENER		(DISPID_ACTORBVR_BASE + 5)
#define DISPID_ICRACTORBVR_GETACTORBEHAVIOR			(DISPID_ACTORBVR_BASE + 6)

#define DISPID_ICRACTORBVR_ADDBEHAVIORFRAGMENTEX	(DISPID_ACTORBVR_BASE + 7)
#define DISPID_ICRACTORBVR_REMOVEBEHAVIORFRAGMENT	(DISPID_ACTORBVR_BASE + 8)
#define DISPID_ICRACTORBVR_REQUESTREBUILD			(DISPID_ACTORBVR_BASE + 9)
#define DISPID_ICRACTORBVR_CANCELREBUILDREQUESTS	(DISPID_ACTORBVR_BASE + 10)
#define DISPID_ICRACTORBVR_REBUILDNOW				(DISPID_ACTORBVR_BASE + 11)
#define DISPID_ICRACTORBVR_GETSTATIC				(DISPID_ACTORBVR_BASE + 12)
#define DISPID_ICRACTORBVR_SETSTATIC				(DISPID_ACTORBVR_BASE + 13)
#define DISPID_ICRACTORBVR_GETDYNAMIC				(DISPID_ACTORBVR_BASE + 14)
#define DISPID_ICRACTORBVR_APPLYSTATICS				(DISPID_ACTORBVR_BASE + 15)
#define DISPID_ICRACTORBVR_APPLYDYNAMICS			(DISPID_ACTORBVR_BASE + 16)

#define DISPID_EFFECTBVR_BASE						1
#define DISPID_ICREFFECTBVR_TYPE					(DISPID_EFFECTBVR_BASE + 0)
#define DISPID_ICREFFECTBVR_ANIMATES				(DISPID_EFFECTBVR_BASE + 1)
#define DISPID_ICREFFECTBVR_CLASSID					(DISPID_EFFECTBVR_BASE + 2)
#define DISPID_ICREFFECTBVR_TRANSITION				(DISPID_EFFECTBVR_BASE + 3)
#define DISPID_ICREFFECTBVR_PROGID					(DISPID_EFFECTBVR_BASE + 4)
#define DISPID_ICREFFECTBVR_BUILDBVRFRAGS			(DISPID_EFFECTBVR_BASE + 5)
#define DISPID_ICREFFECTBVR_DIRECTION				(DISPID_EFFECTBVR_BASE + 6)
#define DISPID_ICREFFECTBVR_IMAGE					(DISPID_EFFECTBVR_BASE + 7)
		
#define DISPID_ACTIONBVR_BASE						1
#define DISPID_ICRACTION_BUILDBVRFRAGS				(DISPID_ACTIONBVR_BASE + 0)

//*********************************************************************************
//
// End of File
//
//*********************************************************************************
#endif //__CRBEHAVIORDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\attrib.h ===
#pragma once
#ifndef __ATTRIB_H_
#define __ATTRIB_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    attrib.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    definition of attribute strings
// Modifications:
// 10/07/98 jeffort created file
//
//*****************************************************************************

#define BEHAVIOR_TYPE_COLOR                L"color"
#define BEHAVIOR_TYPE_ROTATE               L"rotate"
#define BEHAVIOR_TYPE_SCALE                L"scale"
#define BEHAVIOR_TYPE_MOVE                 L"move"
#define BEHAVIOR_TYPE_PATH                 L"path"
#define BEHAVIOR_TYPE_NUMBER               L"number"
#define BEHAVIOR_TYPE_SET                  L"set"
#define BEHAVIOR_TYPE_ACTOR                L"actor"
#define BEHAVIOR_TYPE_EFFECT               L"effect"
#define BEHAVIOR_TYPE_ACTION			   L"action"
#define BEHAVIOR_TYPE_DA                   L"da"

#define BEHAVIOR_PROPERTY_BY               L"by"
#define BEHAVIOR_PROPERTY_TO               L"to"
#define BEHAVIOR_PROPERTY_FROM             L"from"
#define BEHAVIOR_PROPERTY_DIRECTION        L"direction"
#define BEHAVIOR_PROPERTY_PROPERTY         L"property"
#define BEHAVIOR_PROPERTY_ANIMATES         L"animates"
#define BEHAVIOR_PROPERTY_V                L"v"
#define BEHAVIOR_PROPERTY_EXPRESSION       L"expression"
#define BEHAVIOR_PROPERTY_VALUE            L"value"

#define BEHAVIOR_PROPERTY_TYPE             L"type"
#define BEHAVIOR_PROPERTY_MODE			   L"mode"
#define BEHAVIOR_PROPERTY_CLASSID          L"classid"
#define BEHAVIOR_PROPERTY_TRANSITION       L"transition"
#define BEHAVIOR_PROPERTY_PROGID           L"progid"

#define BEHAVIOR_PROPERTY_OFFSET           L"offset"
#define BEHAVIOR_PROPERTY_DIRECTION        L"direction"
#define BEHAVIOR_PROPERTY_IMAGE		       L"image"

#define BEHAVIOR_PROPERTY_ROTATION		   L"rotation"
#define BEHAVIOR_PROPERTY_SCALE			   L"scale"
#define BEHAVIOR_PROPERTY_TRANSFORMCENTER  L"transformcenter"
#define BEHAVIOR_PROPERTY_PIXELSCALE	   L"pixelscale"

#define BEHAVIOR_TYPE_ABSOLUTE			   L"absolute"
#define BEHAVIOR_TYPE_RELATIVE		       L"relative"

#define BEHAVIOR_DIRECTION_CLOCKWISE       L"clockwise"
#define BEHAVIOR_DIRECTION_NOHUE           L"nohue"
#define BEHAVIOR_DIRECTION_COUNTERCLOCKWISE L"cclockwise"
//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__ATTRIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\actorbvr.h ===
#pragma once
#ifndef __ACTORBVR_H__
#define __ACTORBVR_H__
  
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:        actorbvr.h
//
// Author:          ColinMc
//
// Created:         10/15/98
//
// Abstract:        The CrIME Actor behavior.
//
// Modifications:
// 10/15/98 ColinMc Created this file
// 11/17/98 Kurtj	Added support for events and actor construction
// 11/18/98 kurtj   now animates the element to which it is attached
// 11/18/98 markhal	Added ApplyImageBvrToElement
// 11/19/98 markhal Added CColorBvrTrack
// 11/20/98 markhal Added CStringBvrTrack
//
//*****************************************************************************


//get the std library vector
#include <list>

#include <resource.h>
#include "basebvr.h"
#include "dispmethod.h"
#include "evtmgrclient.h"
#include "eventmgr.h"
#include "sampler.h"
#include "elementprop.h"

//*****************************************************************************

#ifdef    CRSTANDALONE
#define TYPELIBID &LIBID_ChromeBehavior
#else  // CRSTANDALONE
#define TYPELIBID &LIBID_LiquidMotion
#endif // CRSTANDALONE

//*****************************************************************************
//
// The Actor Behavior Class
//
// The intermediary between "real" behaviors and the actual element being
// animated.
// The Actor performs in a number of ways:
// *   Adds new properties to an HTML element that we wish were
//     just part of the element (like static rotation and scale).
// *   Abstracts away the necessary action code from the behavior
//     and underlying element (specifically rotating a VML element
//     is easy, rotating and HTML element is hard). The actor does
//     the mapping so the behavior doesn't have to worry about it.
// *   Disambiguates overlapping behaviors (either just letting one
//     win or composing them).
// See the file header for a description of the actor behavrtio
//
//*****************************************************************************

#define NUM_ACTOR_PROPS 3

typedef enum PosAttrib
{
	e_posattribLeft,
	e_posattribTop,
	e_posattribWidth,
	e_posattribHeight
}PosAttrib;

typedef enum ValueOnChangeType
{
	on_no_change,
	on_change,
	value_no_change,
	value_change
}ValueOnChangeType;

typedef enum PositioningType
{
	e_posAbsolute,
	e_posRelative,
	e_posStatic
} PositioningType;

typedef enum UnitType
{
	e_unknownUnit = -1,
	e_in = 0,
	e_cm,
	e_mm,
	e_pt,
	e_pc,
	e_em,
	e_ex,
	e_px,
	e_percent
} UnitType;

//where a ratio is lNum/lDenom
struct Ratio
{
	long lNum;
	long lDenom;
};

class CActorBvr;

class COnResizeHandler: public CDispatchMethod
{
public:
	COnResizeHandler( CActorBvr* parent );
	~COnResizeHandler();

	void Invalidate() { m_pActor = NULL; }

	HRESULT HandleEvent();
private:
	CActorBvr *m_pActor;
};

class COnUnloadHandler: public CDispatchMethod
{
public:
	COnUnloadHandler(CActorBvr* parent);
	~COnUnloadHandler();

	void Invalidate(){ m_pActor = NULL; }

	HRESULT HandleEvent();
private:
	CActorBvr *m_pActor;
};


class CVarEmptyString
{
public:
	CVarEmptyString();
	~CVarEmptyString();

	const VARIANT	*GetVar();
private:
	VARIANT m_varEmptyString;
};//CVarEmptyString

class CBehaviorRebuild;
typedef std::list<CBehaviorRebuild*> BehaviorRebuildList;

class CBehaviorFragmentRemoval;
typedef std::list<CBehaviorFragmentRemoval*> BehaviorFragmentRemovalList;

class ATL_NO_VTABLE CActorBvr :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CActorBvr, &CLSID_CrActorBvr>,
    public IConnectionPointContainerImpl<CActorBvr>,
    public IPropertyNotifySinkCP<CActorBvr>,
    public IPersistPropertyBag2,
    public IDispatchImpl<ICrActorBvr2, &IID_ICrActorBvr2, TYPELIBID>,
    public IElementBehavior,
	public IEventManagerClient,
	public IPropertyNotifySink,
    public CBaseBehavior,
	public IElementLocalTimeListener
{

// COM Map
BEGIN_COM_MAP(CActorBvr)
    COM_INTERFACE_ENTRY(ICrActorBvr)
	COM_INTERFACE_ENTRY(ICrActorBvr2)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPropertyNotifySink)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CActorBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

    //*************************************************************************
    //
    // Nested classes
    //
    //*************************************************************************

    //*************************************************************************
    //
    // class CTimelineSampler
    //
    //*************************************************************************
	class CBvrTrack;

	class CTimelineSampler : public CSampler
	{
	private:
		CBvrTrack *m_pTrack;
		double m_prevSample;
		double m_currSample;
		double m_prevSampleTime;
		double m_currSampleTime;
		double m_lastOnTime;
		double m_lastOffTime;
		int    m_signDerivative;
		bool   m_fRestarted;

	public:
							CTimelineSampler(CBvrTrack *pTrack);
		DWORD				RestartMask();
		void				TurnOn();
		void				TurnOff();

		static HRESULT TimelineCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

	};

    //*************************************************************************
    //
    // class CBvrTrack
    //
    //*************************************************************************

    class CBvrTrack
    {
	protected:
        //*********************************************************************
        //
        // class CBvrFragment
        //
        // Private class which represents a single fragment in the list of
        // behaviors for a track.
        //
        //*********************************************************************

        class CBvrFragment
        {
        public:
        
			ActorBvrFlags	m_eFlags;				// The flags
            IDABehavior    *m_pdabvrAction;         // The action action to take.
            IDABoolean     *m_pdaboolActive;        // True when this behavior is
                                                    // active
			IDANumber	   *m_pdanumTimeline;		// Goes from 0 to dur for the behavior
			IDABehavior	   *m_pModifiableIntermediate;// A modifiable behavior
													// representing the composed
													// behaviors so far. Used in getIntermediate
			IDABehavior	   *m_pModifiableFrom;		// A switchable behavior representing from

			IHTMLElement   *m_pelemBehaviorElement; //a pointer to the IHTMLElement of the element
													// to which the behavior that added this fragment
													//  is attached
			long			m_lCookie;				//the cookie that uniquely identifies this fragment in this actor

			CBvrFragment   *m_pfragNext;			//The next fragment in the list


                            CBvrFragment(ActorBvrFlags eFlags,
										 IDABehavior *pdabvrAction,
                                         IDABoolean  *pdaboolActive,
										 IDANumber	 *pdanumTimeline,
										 IDispatch	 *pdispBehaviorElement,
								         long 		 lCookie);
                           ~CBvrFragment();

			//returns the long that fragments should be compared with for sorting and
			//  searching.
			long GetOrderLong() const;

			//returns the cookie that uniquely identifies this behavior fragment for this actor
			long GetCookie() const;


        }; // CBvrFragment

	protected:

		bool			m_bStyleProp;			// True if we are animating a style property
        CActorBvr      *m_pbvrActor;            // Our parent actor
        BSTR            m_bstrPropertyName;     // Name of property being animated
		BSTR		   *m_pNameComponents;		// Array of components making up the property name
		int				m_cNumComponents;		// Number of components
        ActorBvrType    m_eType;                // Type of this track
		

		CBvrFragment   *m_pfragAbsListHead;		//pointer to the head of the absolute fragment list

		CBvrFragment   *m_pfragRelListHead;     //pointer to the head of the relative fragment list

        IDABehavior    *m_pdabvrFinal;          // Final computed bvr.
		bool			m_bFinalComputed;		// True if final has been computed
		bool			m_bFinalExternallySet;  // True if someone external set the final bvr
		bool			m_fApplied;				// True if this track has already been applied
		
		IDABehavior	   *m_pdabvrComposed;		// The composed bvr
		bool			m_bComposedComputed;	// True if composed has been computed
		IDABehavior	   *m_pModifiableStatic;	// A modifiable behavior representing
		IDABehavior	   *m_pModifiableComposed;	// A modifiable behavior representing the composed behavior
		IDABehavior	   *m_pModifiableFinal;  	// A modifiable behavior representing the final behavior
												// the static behavior.  Used in getIntermediate
		IDABehavior	   *m_pModifiableFrom;		// A modifiable behavior representing a returned from behavior
		IDABehavior    *m_pModifiableIntermediate; //the cached value for the intermediate value that the next 
												   //fragment to be added has requested.
        CBvrTrack      *m_pNext;                // Next track in the track list

		int				m_cFilters;		// True if a filter has been added to the relative list

		bool			m_bDoNotApply;			// True if the track should not be applied

		CSampler		*m_pOnSampler;			//samples the bvr that tells us whether or not this track
												// is on
		VARIANT_BOOL	m_varboolOn;				//VARIANT_TRUE when one of the fragments in this track is on
												// VARIANT_FALSE otherwise.

		CSampler		*m_pIndexSampler;		// Sampler for absolute index

		CSampler		**m_ppMaskSamplers;		// Samplers for masks

		DWORD			*m_pCurrMasks;			// Current mask values

		DWORD			*m_pNewMasks;			// New mask values

		CTimelineSampler **m_ppTimelineSamplers; // Samplers for timeline

		int				m_numIndices;			// The count of indices we are tracking

		int				m_numMasks;				// The count of masks we are tracking

		IDANumber		*m_pIndex;

		int				m_currIndex;

		double			*m_pIndexTimes;			// Times when the absolute behaviors became active

		IDABehavior		**m_ppAccumBvrs;			// Accumulated behaviors for e_RelativeAccum

		static CVarEmptyString s_emptyString;		//a static variable containing the empty string

        HRESULT         ComposeAbsBvrFragList(IDABehavior *pStatic, IDABehavior **ppdabvrComposite);
        HRESULT         ComposeRelBvrFragList(IDABehavior *pAbsolute, IDABehavior **ppdabvrComposite);

		IDABoolean		*m_pdaboolOn;
        bool			m_fOnSampled;
        VARIANT			m_varStaticValue;
        VARIANT         m_varCurrentValue;
		bool			m_fValueSampled;
		bool			m_fValueChangedThisSample;
		bool			m_fForceValueChange;
		long 			m_lOnId;

		long			m_lFirstIndexId;

		HRESULT			UpdateOnValueState( ValueOnChangeType type );

		//tracking of behaivors added to TIME
		DWORD			m_dwAddedBehaviorFlags;

		long			m_lOnCookie;

		bool			m_bDirty; //true if this track has been modified in some way.

		bool			m_bWasAnimated;

		bool			IsRelativeTrack( ActorBvrFlags eFlags );


		HRESULT			AddBehaviorToTIME( IDABehavior *pdabvrToAdd, long* plCookie, DWORD flag );
		HRESULT			RemoveBehaviorFromTIME( long lCookie, DWORD flag );

		void			InsertInOrder( CBvrFragment** vect, CBvrFragment* pfragToInsert );

		bool			FindFragmentInList( CBvrFragment *pfragListHead,
											long cookie, 
											CBvrFragment** ppfragPrev,
											CBvrFragment** ppfragFragment );


		bool			m_fChangesLockedOut;
		bool			m_fSkipNextStaticUpdate;

		virtual HRESULT			UpdateStaticBvr();

		virtual HRESULT	GetComposedBvr(IDABehavior *pStatic, IDABehavior **ppComposite, bool fStaticSetExternally );

		virtual HRESULT	GetFinalBvr(IDABehavior *pStatic, IDABehavior **ppFinal, bool fStaticSetExternally );

		bool			AttribIsTimeAnimated();

		
    public:
                        CBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
        virtual        ~CBvrTrack();

        CActorBvr*      Actor(void) const;

        HRESULT         SetPropertyName(BSTR bstrPropertyName);

        HRESULT         AddBvrFragment(ActorBvrFlags  eFlags,
                                       IDABehavior   *pdabvrAction,
                                       IDABoolean    *pdaboolActive,
									   IDANumber	 *pdanumTimline,
									   IDispatch	 *pdispBehaivorElement,
									   long			 *pCookie);

		HRESULT			RemoveBvrFragment( ActorBvrFlags eFlags,
										   long cookie );

		bool			IsRelativeFragment( ActorBvrFlags eFlags );

		HRESULT         ApplyBvrToElement(IDABehavior *pBvr);

		HRESULT			SetPropFromVariant(VARIANT *pVal);

		void			DoNotApply()	{ m_bDoNotApply = true; }

		virtual HRESULT HookBvr(IDABehavior *pBvr) { return E_FAIL; }

		virtual HRESULT HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult) { return E_FAIL; }

        // Return an identity behavior for this type of behavior track. The
        // actual type of this behavior is dependent on the track type, for
        // example, for number behaviors this is simply a DA number behavior
        // for the value zero, for a move behavior its a translation of 0, 0 etc.
        // Each behavior track type must override this and provide the appropriate
        // type of identity behavior
        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity) = 0;

        // Return the static behavior for this behavior track. This involves
        // querying the actor for the properties initial value, converting
        // that property value into an appropriate type for track type and
        // building a DA behavior which simply holds that value forever.
        virtual HRESULT StaticBvr(IDABehavior** ppdabvrStatic) = 0;

		// Return an uninitialized behavior for this behavior track
		virtual HRESULT UninitBvr(IDABehavior **ppUninit);

		//Return a switchable behavior for this behavior track
		virtual HRESULT ModifiableBvr( IDABehavior **ppModifiable );

		//Return a switchable behavior for this behavior track that has pdabvrInitialValue as
		// its initial value.
		virtual HRESULT ModifiableBvr( IDABehavior* pdabvrInitalValue, IDABehavior **ppModifiable);

		// Return the inverse behavior for this track
		virtual HRESULT InverseBvr(IDABehavior *pOriginal, IDABehavior **ppInverse) { return E_NOTIMPL; }

        // Compose two relative behaviors together. The actual composition action
        // is dependent on the type of the behavior track. For example, for number
        // behaviors this is a simple addition, for move behaviors this is a
        // translation etc.
        // Each behavior track type must override this and provide the appropriate
        // type of composition action
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult) = 0;

		// Called to process the behavior before it is composed
		virtual HRESULT ProcessBvr(IDABehavior *pOriginal,
								   ActorBvrFlags eFlags,
								   IDABehavior **ppResult);
        //Called to process the intermediate behavior before it is used to initialize the
        //  intermediate value for a track.
        virtual HRESULT ProcessIntermediate( IDABehavior *pOriginal,
                                             ActorBvrFlags eFlags,
								             IDABehavior **ppResult);

		// Computes the composed bvr value, given a static value
		virtual HRESULT ComputeComposedBvr(IDABehavior *pStatic, bool fStaticSetExternally );

		// Returns the composed bvr value, given a static value
		virtual HRESULT	GetComposedBvr(IDABehavior *pStatic, IDABehavior **ppComposite);

		// Returns the composed bvr value, computing the static value itself
		virtual HRESULT GetComposedBvr(IDABehavior **ppComposite);
		
		// Returns the final bvr value, given a static value
		virtual HRESULT	GetFinalBvr(IDABehavior *pStatic, IDABehavior **ppFinal);

		// Returns the final bvr value, computing the static value itself
        virtual HRESULT GetFinalBvr(IDABehavior **ppFinal);

		// Sets the final bvr value - probably means that someone got the composed
		// value, did something to it, and are now setting it back as the final bvr
		virtual HRESULT SetFinalBvr(IDABehavior *pFinal, bool fCalledExternally = true);

		// Returns a bvr value (static, intermediate, composed, or final)
		virtual HRESULT	GetBvr(ActorBvrFlags eFlags, IDABehavior **ppResult);

		// Builds and applies the final bvr to the track's property, but only if
		// noone has called ComputeFinalBvr or GetFinalBvr, which implies that the track
		// has been used already.
        virtual HRESULT ApplyIfUnmarked(void);

		//Rebuilds the track after changes have been made.  Does nothing if
		// the track is not dirty.
		virtual HRESULT BeginRebuild(void);

		//forces a rebuild of this track even if it has not had any fragments added to it
		// or removed from it.
		virtual HRESULT ForceRebuild();

		inline bool IsDirty(){return m_bDirty;}

		inline bool IsAnimated() {return (m_pfragRelListHead != NULL || m_pfragAbsListHead != NULL || m_bFinalExternallySet ); }

		inline bool IsOn(){ return m_varboolOn != VARIANT_FALSE; }

        virtual HRESULT CleanTrackState( void );

		virtual bool	ContainsFilter();

		virtual HRESULT SwitchAccum(IDABehavior *pModifiable);

		HRESULT			GetTrackOn( IDABoolean **ppdaboolAbsoluteOn );
		HRESULT			OrWithOnBvr( IDABoolean *pdaboolToOr );

		void			ReleaseAllFragments();

		//called by m_pOnSampler when the overall on boolean is sampled by DA.
		static HRESULT OnCallback(void *thisPtr,
								  long id,
								  double startTime,
								  double globalNow,
								  double localNow,
								  IDABehavior * sampleVal,
								  IDABehavior **ppReturn);

		HRESULT	OnSampled( VARIANT_BOOL varboolOn );

		//called by m_pIndexSampler when the index into the absolute bvr list changes.
		static HRESULT IndexCallback(void *thisPtr,
								  long id,
								  double startTime,
								  double globalNow,
								  double localNow,
								  IDABehavior * sampleVal,
								  IDABehavior **ppReturn);

		//called by mask sampler
		static HRESULT MaskCallback(void *thisPtr,
								  long id,
								  double startTime,
								  double globalNow,
								  double localNow,
								  IDABehavior * sampleVal,
								  IDABehavior **ppReturn);

		HRESULT			ComputeIndex(long id, double currTime, IDABehavior **ppReturn);

		//detach this track from anything that might call it back
		// this should be called before any modifications to the track are made.
		virtual HRESULT	Detach();

		virtual HRESULT PutStatic( VARIANT *pvarStatic );
		HRESULT	SkipNextStaticUpdate();

		virtual HRESULT GetStatic( VARIANT *pvarStatic );

		virtual HRESULT GetDynamic( VARIANT *pvarDynamic );

		virtual HRESULT DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr );

		HRESULT			AcquireChangeLockout();
		HRESULT			ReleaseChangeLockout();

		HRESULT			ApplyStatic();
		HRESULT			ApplyDynamic();

		//called when the structure around the behavior output by this track could change
		//  This will cause the track to ditch the behavior ids that it is currently using
		//  to track its da behaviors.  It will pick up new ones on the next sample.
		void			StructureChange() { m_lFirstIndexId = -1; m_lOnId = -1; }
		
        friend CActorBvr;
    }; // CBvrTrack

    //*****************************************************************************
    //
    // class CTransformBvrTrack
    //
    //*****************************************************************************

    class CTransformBvrTrack :
        public CBvrTrack
    {
	private:
		CSampler		*m_pSampler;
		double			m_lastX;
		double			m_lastY;
		long			m_lTransformId;

    public:
                        CTransformBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
		virtual			~CTransformBvrTrack();
        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity);
        virtual HRESULT StaticBvr(IDABehavior **ppdabvrStatic);
		virtual HRESULT UninitBvr(IDABehavior **ppUninit);
		virtual HRESULT ModifiableBvr( IDABehavior **ppModifiable );
		virtual HRESULT InverseBvr(IDABehavior *pOriginal, IDABehavior **ppInverse);
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult);


		virtual HRESULT SwitchAccum(IDABehavior *pModifiable);

		virtual HRESULT HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult);

		HRESULT GetAbsoluteMapTransform2( IDATransform2 **ppdatfm2Map );

        static HRESULT  CreateInstance(CActorBvr     *pbvrActor,
                                       BSTR           bstrPropertyName,
                                       ActorBvrType   eType,
                                       CBvrTrack    **pptrackResult);

		static HRESULT TransformCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

    }; // CTransformBvrTrack

    //*****************************************************************************
    //
    // class CNumberBvrTrack
    //
    //*****************************************************************************

    class CNumberBvrTrack :
        public CBvrTrack    
    {
	private:
		CSampler		*m_pSampler;				// Our sampler
		double			m_currVal;
		double			m_currStatic;
		CSampler		*m_pAccumSampler;
		double			m_currAccumVal;
		long			m_lAccumId;
		BSTR			m_bstrUnits;

		long			m_lNumberCookie;
		long			m_lNumberId;

		bool			m_fSkipNextStaticUpdate;

    public:
                        CNumberBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
		virtual			~CNumberBvrTrack();
        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity);
        virtual HRESULT StaticBvr(IDABehavior **ppdabvrStatic);
		virtual HRESULT UninitBvr(IDABehavior **ppUninit);
		virtual HRESULT ModifiableBvr( IDABehavior **ppModifiable );
		virtual HRESULT ModifiableBvr( IDABehavior* pdabvrInitalValue, IDABehavior **ppModifiable);
		virtual HRESULT InverseBvr(IDABehavior *pOriginal, IDABehavior **ppInverse);
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult);

		virtual HRESULT SwitchAccum(IDABehavior *pModifiable);

		virtual HRESULT HookBvr(IDABehavior *pBvr);

		virtual HRESULT HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult);

		HRESULT			ValueSampled(double val, bool firstSample );

        static HRESULT  CreateInstance(CActorBvr     *pbvrActor,
                                       BSTR           bstrPropertyName,
                                       ActorBvrType   eType,
                                       CBvrTrack    **pptrackResult);

		static HRESULT NumberCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		static HRESULT AccumNumberCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		BSTR GetUnits();

		virtual HRESULT Detach();

		virtual HRESULT DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr );
		

    }; // CNumberBvrTrack

    //*****************************************************************************
    //
    // class CImageBvrTrack
    //
    //*****************************************************************************

    class CImageBvrTrack :
        public CBvrTrack
    {
    public:
						CImageBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity);
        virtual HRESULT StaticBvr(IDABehavior **ppdabvrStatic);
		virtual HRESULT UninitBvr(IDABehavior **ppUninit);
		virtual HRESULT ModifiableBvr( IDABehavior **ppModifiable );
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult);
		virtual HRESULT ProcessBvr(IDABehavior *pOriginal,
								   ActorBvrFlags eFlags,
								   IDABehavior **ppResult);
        virtual HRESULT ProcessIntermediate( IDABehavior *pOriginal,
                                             ActorBvrFlags eFlags,
								             IDABehavior **ppResult);

        static HRESULT  CreateInstance(CActorBvr     *pbvrActor,
                                       BSTR           bstrPropertyName,
                                       ActorBvrType   eType,
                                       CBvrTrack    **pptrackResult);
    }; // CImageBvrTrack

    //*****************************************************************************
    //
    // class CColorBvrTrack
    //
    //*****************************************************************************

    class CColorBvrTrack :
        public CBvrTrack
    {
	private:
		CSampler	*m_pRedSampler;
		CSampler	*m_pGreenSampler;
		CSampler	*m_pBlueSampler;
		short		m_currRed;
		short		m_currGreen;
		short		m_currBlue;
		short		m_newRed;
		short		m_newGreen;
		short		m_newBlue;
		short		m_newCount;

		//time cookie tracking
		long 		m_lRedCookie;
		long		m_lGreenCookie;
		long		m_lBlueCookie;
		long		m_lColorId;

		bool		m_fFirstSample;

    public:
						CColorBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
		virtual			~CColorBvrTrack();
        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity);
        virtual HRESULT StaticBvr(IDABehavior **ppdabvrStatic);
		virtual HRESULT UninitBvr(IDABehavior **ppUninit);
		virtual HRESULT ModifiableBvr( IDABehavior ** ppModifiable );
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult);

		virtual HRESULT HookBvr(IDABehavior *pBvr);
		virtual HRESULT HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult);
		virtual HRESULT SwitchAccum(IDABehavior *pModifiable);

		HRESULT			SetNewValue(double value, short *pNew );
		HRESULT			ValueSampled(short red, short green, short blue, bool fFirstSample );
		inline OLECHAR	HexChar(short n) { return (n<=9) ? (L'0'+n) : (L'A' + (n-10)); }

        static HRESULT  CreateInstance(CActorBvr     *pbvrActor,
                                       BSTR           bstrPropertyName,
                                       ActorBvrType   eType,
                                       CBvrTrack    **pptrackResult);

		static HRESULT RedCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		static HRESULT GreenCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		static HRESULT BlueCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		virtual HRESULT Detach();

		virtual HRESULT DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr );



    }; // CColorBvrTrack

    //*****************************************************************************
    //
    // class CStringBvrTrack
    //
    //*****************************************************************************

    class CStringBvrTrack :
        public CBvrTrack
    {
	protected:
		IDAString		*m_pEmptyString;
		CSampler		*m_pSampler;
		BSTR			m_bstrCurrValue;

		//time cookie tracking
		long			m_lStringCookie;

		long 			m_lStringId;

    public:
						CStringBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
		virtual			~CStringBvrTrack();

        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity);
        virtual HRESULT StaticBvr(IDABehavior **ppdabvrStatic);
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult);

		virtual HRESULT HookBvr(IDABehavior *pBvr);

		HRESULT			ValueSampled(BSTR bstrValue, bool fFirstSample );

        static HRESULT  CreateInstance(CActorBvr     *pbvrActor,
                                       BSTR           bstrPropertyName,
                                       ActorBvrType   eType,
                                       CBvrTrack    **pptrackResult);

		static HRESULT StringCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		virtual HRESULT Detach();

		virtual HRESULT DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr );
    }; // CStringBvrTrack

    //*****************************************************************************
    //
    // class CFloatManager
    //
    //*****************************************************************************

	class CFloatManager
	{
	protected:
		CActorBvr		*m_pActor;
		IDispatch		*m_pFilter;
		IHTMLElement	*m_pElement;
		IHTMLElement2	*m_pElement2;
		CSampler		*m_pWidthSampler;
		CSampler		*m_pHeightSampler;
		double			 m_currWidth;
		double			 m_currHeight;
		long			 m_origWidth;
		long			 m_origHeight;
		long			 m_origLeft;
		long			 m_origTop;

		long			 m_lWidthCookie;
		long			 m_lHeightCookie;
	public:
						CFloatManager(CActorBvr *pActor);
						~CFloatManager();

		HRESULT			GetElement(IHTMLElement **ppElement);
		HRESULT			GetFilter(IDispatch **ppFilter);
		HRESULT			Detach();
		HRESULT			ApplyImageBvr(IDAImage *pImage);
		HRESULT			HookBvr(IDABehavior *pBvr,
								SampleCallback callback,
								CSampler **ppSampler,
								long *plCookie);
		HRESULT			UpdateElementRect();

		HRESULT			UpdateZIndex();
		HRESULT			UpdateVisibility();
		HRESULT			UpdateDisplay();

		HRESULT			UpdateRect(long left, long top, long width, long height);

		static HRESULT	widthCallback(void *thisPtr,
									  long id,
									  double startTime,
								      double globalNow,
								      double localNow,
								      IDABehavior * sampleVal,
									  IDABehavior **ppReturn);

		static HRESULT	heightCallback(void *thisPtr,
									  long id,
									  double startTime,
								      double globalNow,
								      double localNow,
								      IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		friend	CActorBvr;

	};
    //*****************************************************************************
    //
    // class CImageInfo
    //
    //*****************************************************************************
	class CImageInfo
	{
	public:

		CImageInfo( IDA2Image* pdaimg2Cropped, IDA2Behavior* pdabvrSwitchable );
		~CImageInfo();

		void			SetNext( CImageInfo* pNext );
		CImageInfo		*GetNext();
		IDA2Image		*GetCroppedNoRef(); //does not add a reference to the bvr
		IDA2Behavior	*GetSwitchableNoRef(); //does not add a reference to the bvr

	private:
		CImageInfo		*m_pNext;
		IDA2Image		*m_pdaimg2Cropped;
		IDA2Behavior	*m_pdabvr2Switchable;

		friend CActorBvr;
	};

	//*****************************************************************************
    //
    // class CFinalDimensionSampler
    //
    //*****************************************************************************
	class CFinalDimensionSampler
	{
	public:
		CFinalDimensionSampler(CActorBvr *pParent );
		~CFinalDimensionSampler( );
		
		HRESULT Attach( IDANumber* pFinalWidth, IDANumber *pFinalHeight );
		HRESULT	Detach();

	private:

		CActorBvr					   *m_pActor;

		CSampler					   *m_pFinalWidthSampler;
		CSampler					   *m_pFinalHeightSampler;
		bool							m_fFinalWidthSampled;
		bool							m_fFinalHeightSampled;
		long							m_lFinalWidthId;
		long							m_lFinalHeightId;
		double							m_dLastFinalWidthValue;
		double							m_dLastFinalHeightValue;
		bool							m_fFinalDimensionChanged;

		HRESULT							CollectFinalDimensionSamples( );

		static HRESULT					FinalWidthCallback(void *thisPtr,
															long id,
															double startTime,
															double globalNow,
															double localNow,
															IDABehavior * sampleVal,
															IDABehavior **ppReturn);
		static HRESULT					FinalHeightCallback(void *thisPtr,
															long id,
															double startTime,
															double globalNow,
															double localNow,
															IDABehavior * sampleVal,
															IDABehavior **ppReturn);

	public:
		CActorBvr						*Actor() { return m_pActor; }

		long							m_lWidthCookie;
		long							m_lHeightCookie;
		friend CActorBvr;
	};

	//*****************************************************************************
    //
    // class CCookieMap
    //
    //*****************************************************************************
	class CCookieMap
	{
	public:
		class CCookieData
		{
		public:
			CCookieData( long lCookie, CBvrTrack *pTrack, ActorBvrFlags eFlags );

			long m_lCookie;
			
			CBvrTrack* m_pTrack;
			ActorBvrFlags m_eFlags;

			CCookieData *m_pNext;
		};
	public:
		CCookieMap();
		~CCookieMap();

		void Insert( long lCookie, CBvrTrack* pTrack, ActorBvrFlags eFlags );
		void Remove( long lCookie );
		void Clear();
		CCookieData *GetDataFor( long lCookie );
	private:
		CCookieData *m_pHead;


		friend CActorBvr;
	};


public:

DECLARE_REGISTRY_RESOURCEID(IDR_ACTORBVR)

                                    CActorBvr();
                                   ~CActorBvr();
    HRESULT                         FinalConstruct();

    // IElementBehavior
    STDMETHOD(Init)                 (IElementBehaviorSite *pBehaviorSite);
    STDMETHOD(Notify)               (LONG event, VARIANT *pVar);
    STDMETHOD(Detach)               (void);

    // ICrActorBvr
	STDMETHOD(put_animates)			(VARIANT  varAnimates);
	STDMETHOD(get_animates)			(VARIANT* pvarAnimates);
    STDMETHOD(put_scale)            (VARIANT  varScale);
    STDMETHOD(get_scale)            (VARIANT *pvarScale);
    STDMETHOD(put_pixelScale)		(VARIANT  varPixelScale);
    STDMETHOD(get_pixelScale)		(VARIANT *pvarPixelScale);

	STDMETHOD(getActorBehavior)		(BSTR			bstrProperty,
									 ActorBvrFlags	eFlags,
									 ActorBvrType	eType,
									 VARIANT		*pvarRetBvr);

    STDMETHOD(addBehaviorFragment)  (BSTR           bstrProperty,
                                     IUnknown      *punkAction,
                                     IUnknown      *punkActive,
									 IUnknown	   *punkTimline,
                                     ActorBvrFlags  eFlags,
                                     ActorBvrType   eType);
	
    STDMETHOD(addMouseEventListener)		(IUnknown * pUnkListener );
    STDMETHOD(removeMouseEventListener)		(IUnknown * pUnkListener );

	//ICrActorBvr2

    STDMETHOD(addBehaviorFragmentEx)    (BSTR           bstrProperty,
                                         IUnknown      *punkAction,
                                         IUnknown      *punkActive,
									     IUnknown	   *punkTimline,
                                         ActorBvrFlags  eFlags,
                                         ActorBvrType   eType,
		                                 IDispatch     *pdispBehaviorElement,
										 long          *pCookie);
	STDMETHOD(removeBehaviorFragment)	( long cookie );
	STDMETHOD(requestRebuild)			( IDispatch *pdispBehaviorElement );
	// A behavior should call this if they are removed with a rebuild request pending.
	STDMETHOD(cancelRebuildRequests)	( IDispatch *pdispBehaviorElement );
	STDMETHOD(rebuildNow)				();

	STDMETHOD(getStatic)				( BSTR bstrTrackName, VARIANT *varRetStatic );
	STDMETHOD(setStatic)				( BSTR bstrTrackName, VARIANT varStatic );

	STDMETHOD(getDynamic)				( BSTR bstrTrackName, VARIANT *varRetDynamic );

	STDMETHOD(applyStatics)				( );
	STDMETHOD(applyDynamics)			( );

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

	// IPropertyNotifySink methods
	STDMETHOD(OnChanged)(DISPID dispID);
	STDMETHOD(OnRequestEdit)(DISPID dispID);
 

	// IEventManagerClient
	virtual IHTMLElement*			GetElementToSink		();
	virtual IElementBehaviorSite*	GetSiteToSendFrom		();
	virtual HRESULT					TranslateMouseCoords	( long x, long y, long * pxTrans, long * pyTrans );

	//Event callbacks
	virtual void					OnLoad					();
	virtual void					OnUnload				();
	virtual void					OnReadyStateChange		( e_readyState state );

	//IElementLocalTimeListener
	STDMETHOD(OnLocalTimeChange)( float localTime );

    HRESULT                         GetTypeInfo(ITypeInfo **ppInfo);
    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrActorBvr *) this ; }
	
protected:
	HRESULT							UpdatePixelDimensions();

    virtual HRESULT                 BuildAnimationAsDABehavior();
	HRESULT							BuildChildren();
	HRESULT							BuildAnimation();
    virtual VARIANT *				VariantFromIndex(ULONG iIndex);
    virtual HRESULT					GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT					GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    virtual WCHAR *					GetBehaviorTypeAsURN(){return DEFAULT_ACTOR_URN;};
    // The actor does not need an actor attached to what it
    // is animating since it is this.
    virtual HRESULT					AttachActorBehaviorToAnimatedElement();
	HRESULT							InitPropertySink();
	HRESULT							UnInitPropertySink();
	HRESULT							GetCurrStyleNotifyConnection(IConnectionPoint **ppConnection);
	HRESULT							InitPixelWidthHeight();

	//rebuilds all the dirty tracks in this actor and all of the elements of the actor that need
	//  to be rebuilt as a result of those rebuilds.
	HRESULT							RebuildActor();
	HRESULT							ProcessPendingRebuildRequests();

	//returns S_OK if any of the transform tracks is dirty, and S_FALSE otherwise.
	HRESULT							TransformTrackIsDirty( DWORD *pdwState );
	bool							IsAnyTrackDirty(); //returns true if a track is dirty.

	//returns S_OK if the image track is dirty, and S_FALSE otherwise.
	HRESULT							ImageTrackIsDirty();

public:
	HRESULT							ApplyImageBvrToFloatElement(IDAImage *pImage);
	HRESULT							SetElementOnFilter();
	HRESULT							SetElementOnFilter(IDispatch *pFilter, IHTMLElement *pElement);
	HRESULT							GetElementFilter(IDispatch **pFilter);
	HRESULT							GetElementFilter(IHTMLElement *pElement, IDispatch **ppFilter);

	HRESULT							RemoveElementFilter( );
	HRESULT							RemoveElementFilter( IHTMLElement* pElement );

	HRESULT							OnWindowUnload();

private:
    // Properties
	VARIANT                         m_varAnimates;
    VARIANT                         m_varScale;
	VARIANT							m_varPixelScale;

	bool							m_bEditMode;

	PositioningType					m_desiredPosType;

	PositioningType					m_currPosType;

	bool							m_simulDispNone;
	bool							m_simulVisHidden;

	DWORD							m_dwAdviseCookie;

    static WCHAR				   *m_rgPropNames[NUM_ACTOR_PROPS]; 

    IDATransform2                  *m_pScale;				 // Final composite scale bvr
    IDATransform2                  *m_pRotate;				 // Final composite rotate bvr
    IDATransform2                  *m_pTranslate;			 // Final composite translate bvr

	IDAPoint2					   *m_pOrigLeftTop;			 // Original top and left (before scales and translates)
	IDAVector2					   *m_pOrigWidthHeight;		 // Original width and height

	IDANumber					   *m_pPixelWidth;			 // The width of the element in pixels
	IDANumber					   *m_pPixelHeight;

	long							m_pixelWidth;
	long							m_pixelHeight;

	long							m_pixelLeft;
	long							m_pixelTop;

	long 							m_nextFragmentCookie;	 //The next cookie for a behavior fragment  starts at 1

	IDAPoint2					   *m_pBoundsMin;			 // Bounds of the element (in DA coord space)
	IDAPoint2					   *m_pBoundsMax;

    IDAVector2					   *m_pTransformCenter;		 // Center of transform

	IDAImage					   *m_pElementImage;		 // Image filtered from element

	IDispatch					   *m_pElementFilter;		 // The filter on the element

    CBvrTrack                      *m_ptrackHead;            // Head of track list

    CBvrTrack				   	   *m_ptrackTop;			 //the top track
    CBvrTrack				   	   *m_ptrackLeft;			 //the left track

	CEventMgr					   *m_pEventManager;		 //The manager for events coming from the DOM

	CFloatManager				   *m_pFloatManager;		 // The manager for the float element

	IHTMLStyle					   *m_pRuntimeStyle;		 // The runtimeStyle object of the element we are animating

	IHTMLStyle					   *m_pStyle;				 // The style object of the element we are animating

	IDispatch					   *m_pVMLRuntimeStyle;		 // The runtimeStyle object from VML


	IDispatch					   *m_pBodyElement;			 // The body element


	CCookieMap						m_mapCookieToTrack;		 //map from cookie to the fragment to which it corresponds to

	bool							m_fRebuildRequested;	 //true if a rebuild of the graph has been requested

	CElementPropertyMonitor		   *m_pBodyPropertyMonitor;	 //monitors props on the body element

	//body event monitor management
	HRESULT							EnsureBodyPropertyMonitorAttached(); //attached the body prop monitor if it isn't already
	HRESULT							AttachBodyPropertyMonitor();  //attaches the body prop monitor to the body of the
															   //  document of the element to which this actor is attached
	HRESULT							DetachBodyPropertyMonitor();  //detaches the body prop monitor from the body, but does not
															   // destroy it.
	HRESULT							DestroyBodyPropertyMonitor(); //destroy the body prop monitor

	COnResizeHandler				*m_pOnResizeHandler;//a handler for the onresize event on the animated element.
	COnUnloadHandler				*m_pOnUnloadHandler;//a handler for the onunload event on IHTMLWindow3 

	bool							m_fUnloading;

	bool							m_fVisSimFailed;

	HRESULT							AttachEvents(); //attaches to events on the animated element
	HRESULT							DetachEvents(); //detaches from events on the animated element


	BehaviorFragmentRemovalList		m_listPendingRemovals;
	BehaviorRebuildList				m_listPendingRebuilds;
	BehaviorRebuildList				m_listUpdatePendingRebuilds;
	bool							m_bPendingRebuildsUpdating;
	bool							m_bRebuildListLockout;
	void							ReleaseRebuildLists();

	inline long				        GetNextFragmentCookie();  //returns the next fragment cookie

	//Image management
	CImageInfo					   *m_pImageInfoListHead;	//The head of the image info list
	HRESULT						    AddImageInfo( IDA2Image* pdaimgCropped, IDABehavior* pdabvrSwitchable );
	HRESULT						    SetRenderResolution( double dX, double dY );

	// Methods

	//returns DANumbers that represent the final dimensions of the animated element.  When a floating Div is 
	//  being used, the width and height returned are the width and height of that div.  Otherwise the width
	//  and height returned are those of the animated element itself, as changed by all behaviors.
	HRESULT						   GetFinalElementDimension( IDANumber** ppdanumWidth, IDANumber** ppdanumHeight);
	HRESULT						   SetFinalElementDimension( IDANumber* pdanumWidth, IDANumber* pdanumHeight, bool fHook );
	IDANumber					   *m_pdanumFinalElementWidth;
	IDANumber					   *m_pdanumFinalElementHeight;
	CFinalDimensionSampler		   *m_pFinalElementDimensionSampler;

    // Methods

    void                            DiscardBvrCache(void);

	//DATIME Cookie tracking
	DWORD							m_dwAddedBehaviorFlags;

	long							m_lOnCookie;

	HRESULT							AddBehaviorToTIME( IDABehavior *pbvrAdd, long *plCookie );
	HRESULT							AddBehaviorToTIME( IDABehavior *pbvrAdd );
	HRESULT							RemoveBehaviorFromTIME( long cookie );

    // BUGBUG (ColinMc): These methods should be encapsulated in a track manager class.
    HRESULT							FindTrack(LPWSTR       wzPropertyName,
                                              ActorBvrType eType,
											  CBvrTrack **ppTrack);
	HRESULT							FindTrackNoType(LPWSTR       wzPropertyName,
       												CBvrTrack	 **ppTrack);
   
    HRESULT                         CreateTrack(BSTR           bstrPropertyName,
                                                ActorBvrType   eType,
                                                CBvrTrack    **pptrack);
    HRESULT                         GetTrack(BSTR           bstrPropertyName,
                                             ActorBvrType   eType,
                                             CBvrTrack    **pptrack);
	DWORD							m_dwCurrentState;
	HRESULT							GetCurrentState( DWORD *pdwState );
	HRESULT							UpdateCurrentState( );

	HRESULT							IsStaticRotationSet( bool *pfIsSet );
	HRESULT							IsStaticScaleSet( bool *pfIsSet );

	HRESULT							UpdateLayout();

	HRESULT							RequestRebuildFromExternal();

public:
    HRESULT                         GetPropAsDANumber(IHTMLElement *pElement,
													  LPWSTR       *pPropNames,
													  int		    numPropNames,
                                                      IDANumber   **ppdanum,
													  BSTR		    *pRetUnits);

    HRESULT                         GetElementPropAsDANumber(LPWSTR     *pPropNames,
															 int		 numPropNames,
                                                             IDANumber **ppdanum,
															 BSTR		*pRetUnits);

	HRESULT							GetPropFromElement(IHTMLElement *pElement,
													   LPWSTR		*pPropNames,
													   int			 numPropNames,
													   bool			 current,
													   VARIANT		*varResult);
													   
	HRESULT							GetPropFromAnimatedElement( LPWSTR		*pPropNames,
																int			numPropNames,
																bool		current,
																VARIANT		*pvarResult );

	HRESULT							GetPropertyAsDispatch(IDispatch *pDispatch,
														  BSTR name,
														  IDispatch **ppDispatch);

	HRESULT							GetPropertyOnDispatch(IDispatch *pDispatch,
														  BSTR name,
														  VARIANT *pReturn);

	HRESULT							SetPropertyOnDispatch(IDispatch *pDispatch,
														  BSTR name,
														  VARIANT *pVal);

	HRESULT							GetElementImage(IDAImage **ppElementImage);

	HRESULT							GetOriginalTranslation( IDATransform2 **ppdatfmOrig );
	HRESULT							GetOriginalRotation( IDANumber **ppRotation );
	HRESULT							GetOriginalScale( IDATransform2 **ppdatfmOrig );
	HRESULT							IsAnimatedElementVML(bool *pResult);
	HRESULT							GetAnimatedElement(IHTMLElement** ppElem);
	HRESULT							GetAnimatedElementId(VARIANT *pvarId);
	HRESULT							GetRuntimeStyle(IHTMLStyle **ppStyle);
	HRESULT							GetCurrentStyle(IHTMLCurrentStyle **ppResult);
	HRESULT							GetStyle(IHTMLStyle **ppStyle);
	HRESULT							SetVMLAttribute(BSTR propertyName, VARIANT *pVal);
	HRESULT							ConvertToDegrees(IDANumber *pNumber, BSTR units, IDANumber **ppConverted);

	double							MapGlobalTime(double gTime);
	bool							IsAnimatingVML();

	HRESULT							AnimatedElementOnResize();

private:
	HRESULT							GetPositioningAttributeAsVariant( IHTMLElement *pElement, PosAttrib attrib, VARIANT *pvarAttrib );

	HRESULT							GetPositioningAttributeAsDouble( IHTMLElement *pElement, PosAttrib attrib, double *pDouble, BSTR *pRetUnits);
	HRESULT							GetPositioningAttributeAsDANumber( IHTMLElement *pElement, PosAttrib attrib, IDANumber **ppdanum, BSTR *pRetUnits );
	HRESULT							FindCSSUnits( BSTR bstrValWithUnits, OLECHAR** ppUnits );
	HRESULT							GetCurrentStyle( IHTMLElement *pElement, IHTMLCurrentStyle **ppstyleCurrent );

	HRESULT							GetComposedBvr(LPWSTR          wzPropertyName,
												   ActorBvrType    eType,
												   IDABehavior   **ppResult);

	HRESULT							GetFinalBvr(LPWSTR          wzPropertyName,
												ActorBvrType    eType,
												IDABehavior   **ppResult);
	
	HRESULT                         GetTransformFinalBvr(LPWSTR          wzPropertyName,
                                                         ActorBvrType    eType,
                                                         IDATransform2 **ppdabvrScale);

	HRESULT							GetRotationFinalBvr(IDATransform2 **ppRotation);

//    HRESULT                         GetTopLeftBvr(IDAPoint2 **ppdapnt2TopLeft);
//    HRESULT                         GetWidthHeightBvr(IDAVector2 **ppdavct2WidthHeight);
	HRESULT							BuildTransformCenter();
	HRESULT							ConvertTransformCenterUnits(IDAVector2 **ppCenter);
	HRESULT							GetUnitConversionBvr(BSTR bstrFrom, BSTR bstrTo, IDANumber ** ppnumConvert, double dPixelPerPercent=1.0);
	HRESULT							GetUnitToMeterBvr(BSTR bstrUnit, IDANumber ** ppnumConvert, double dPixelPerPercent=1.0);
	HRESULT							GetPixelsPerPercentValue(double& dPixelPerPercentX, double& dPixelPerPercentY);
	
//    HRESULT                         ApplyTransformsToHTMLElement(void);

	HRESULT							ApplyImageTracks();
	HRESULT							ApplyTransformTracks();

    HRESULT                         PrepareImageForDXTransform( IDAImage *pOriginal, IDAImage **ppResult);
	HRESULT							ApplyClipToImage( IDAImage *pImageIn, IDAPoint2 *pMin, IDAPoint2 *pMax, IDAImage** ppImageOut );


	HRESULT							CallBuildBehaviors( IDispatch *pDisp, DISPPARAMS *pParams, VARIANT* pResult );

	HRESULT							ProcessRebuildRequests();
	
	//resource management
	HRESULT							ReleaseAnimation();
	void							ReleaseFinalElementDimensionSampler();
	void							ReleaseFloatManager();
	void							ReleaseTracks();
	void							ReleaseImageInfo();
	void							ReleaseEventManager();

	HRESULT							CalculateVGXLeftPixelOffset( IHTMLElement *pelem, long *plOffset );
	HRESULT							GetInlineMarginLeftAsPixel( IHTMLStyle *pstyleInline, long* plMargin );

	HRESULT							CalculateVGXTopPixelOffset( IHTMLElement *pelem, long *plOffset );
	HRESULT							GetInlineMarginTopAsPixel( IHTMLStyle *pstyleInline, long* plMargin );

	HRESULT							GetMarginLeftAsPixel( IHTMLElement *pelem, IHTMLCurrentStyle *pstyleCurrent, long *plMargin);
	HRESULT							GetMarginTopAsPixel( IHTMLElement* pelem, IHTMLCurrentStyle *pstyleCurrent, long *plMargin);
	HRESULT							GetPixelValue( VARIANT *pvarStringWithUnit, long *plResult, bool bHorizontal );
	HRESULT							VariantToPixelLong( VARIANT* pvar, long* pLong, bool fHorizontal );

	bool							IsDocumentInEditMode();

	HRESULT							GetBodyElement(IDispatch **ppResult);
	HRESULT							GetParentWindow( IHTMLWindow2 **ppWindow );
	HRESULT							InitVisibilityDisplay();
	HRESULT							UpdateVisibilityDisplay();
	HRESULT							UpdateDesiredPosition();

	HRESULT							VisSimSetOffscreen( IHTMLStyle *pRuntimeStyle, bool fResample );

	HRESULT							DebugPrintBoundingClientRect();

	static Ratio					s_unitConversion[5][5];

	int								GetPixelsPerInch( bool fHorizontal );
	UnitType						GetUnitTypeFromString( LPOLESTR strUnits );

	IConnectionPoint				*m_pcpCurrentStyle;

	friend CCookieMap;
	friend CFloatManager;
	friend CBvrTrack;
	friend CNumberBvrTrack;
	friend CImageBvrTrack;
	friend CTransformBvrTrack;
	friend CColorBvrTrack;
	friend CStringBvrTrack;
	friend CImageInfo;
	friend CFinalDimensionSampler;

}; // CActorBvr


//*****************************************************************************
//
// Helper Classes
//
//*****************************************************************************

class CBehaviorRebuild
{
public:
	
					CBehaviorRebuild				( IDispatch *pdispBehaviorElem );
					~CBehaviorRebuild				();

	HRESULT			RebuildBehavior				( DISPPARAMS *pParams, VARIANT* pResult );
	bool			IsRebuildFor				( IUnknown* punkBehaviorElem ) { return m_punkBehaviorElem == punkBehaviorElem; }
	
private:

	IDispatch *m_pdispBehaviorElem;
	IUnknown  *m_punkBehaviorElem;
};

class CBehaviorFragmentRemoval
{
public:
					CBehaviorFragmentRemoval( long cookie ):m_lCookie(cookie){}
					~CBehaviorFragmentRemoval(){}

	long			GetCookie() { return m_lCookie; }
private:
	long			m_lCookie;
};


//*****************************************************************************
//
// Inlines
//
//*****************************************************************************

inline const VARIANT*
CVarEmptyString::GetVar()
{
	return &m_varEmptyString;
}

//*****************************************************************************

inline CActorBvr*
CActorBvr::CBvrTrack::Actor(void) const
{
    DASSERT(NULL != m_pbvrActor);
    return m_pbvrActor;
} // Actor

//*****************************************************************************

inline
CActorBvr::CImageBvrTrack::CImageBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType)
:   CBvrTrack(pbvrActor, eType)
{
} // CImageBvrTrack

//*****************************************************************************

inline BSTR
CActorBvr::CNumberBvrTrack::GetUnits()
{
	return m_bstrUnits;
}

//*****************************************************************************

inline
void
CActorBvr::CImageInfo::SetNext( CActorBvr::CImageInfo* pNext )
{
	m_pNext = pNext;
}

//*****************************************************************************

inline
CActorBvr::CImageInfo *
CActorBvr::CImageInfo::GetNext()
{
	return m_pNext;
}

//*****************************************************************************

inline
IDA2Image*
CActorBvr::CImageInfo::GetCroppedNoRef()
{
	return m_pdaimg2Cropped;
}

//*****************************************************************************

inline
IDA2Behavior*
CActorBvr::CImageInfo::GetSwitchableNoRef()
{
	return m_pdabvr2Switchable;
}

//*****************************************************************************


inline HRESULT
CActorBvr::GetTypeInfo(ITypeInfo **ppInfo)
{
    return GetTI(GetUserDefaultLCID(), ppInfo);
} // GetTypeInfo

//*****************************************************************************

inline long
CActorBvr::GetNextFragmentCookie()
{
	//always skip 0
	if( m_nextFragmentCookie + 1 == 0 )
		m_nextFragmentCookie ++;
	return m_nextFragmentCookie++;
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************

#endif // __ACTORBVR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\colorbvr.h ===
#pragma once
#ifndef __COLORBVR_H_
#define __COLORBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    colorbvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    color behavior class definition
// Modifications:
// 10/07/98 jeffort created file
// 11/19/98 markhal added buildBehaviorFragments
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#define NUM_COLOR_PROPS 4

//*****************************************************************************

class ATL_NO_VTABLE CColorBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CColorBvr, &CLSID_CrColorBvr>,
    public IConnectionPointContainerImpl<CColorBvr>,
    public IPropertyNotifySinkCP<CColorBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrColorBvr, &IID_ICrColorBvr, &LIBID_ChromeBehavior>,
    error me here
#else
	public IDispatchImpl<ICrColorBvr, &IID_ICrColorBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CColorBvr)
	COM_INTERFACE_ENTRY(ICrColorBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CColorBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_COLORBVR)

	CColorBvr();
    virtual ~CColorBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrColorBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrColorBehavior
	STDMETHOD(put_from)(VARIANT varFrom);
	STDMETHOD(get_from)(VARIANT *pRetFrom);
	STDMETHOD(put_to)(VARIANT varTo);
	STDMETHOD(get_to)(VARIANT *pRetTo);
	STDMETHOD(put_property)(VARIANT varProperty);
	STDMETHOD(get_property)(VARIANT *pRetProperty);
	STDMETHOD(put_direction)(VARIANT varDirection);
	STDMETHOD(get_direction)(VARIANT *pRetDirection);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:

	HRESULT GetColorToBvr(IDispatch *pActorDisp, IDAColor **ppResult);

    HRESULT BuildHueNumber(float, float, IDANumber*, IDANumber**);

    HRESULT NormalizeProgressValue(IDA2Statics *pDAStatics,
                                     IDANumber *pbvrProgress, 
                                     float flStartPercentage,
                                     float flEndPercentage,
                                     IDANumber **ppbvrReturn);
    static WCHAR                *m_rgPropNames[NUM_COLOR_PROPS]; 
    VARIANT                     m_varFrom;
    VARIANT                     m_varTo;
    VARIANT                     m_varProperty;
    VARIANT                     m_varDirection;

    IDispatch					*m_pdispActor;
    long						m_lCookie;

    HRESULT						RemoveFragment();

}; // CColorBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__COLORBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\defaults.h ===
#pragma once
#ifndef __DEFAULTS_H_
#define __DEFAULTS_H_
//*****************************************************************************
//
// Microsoft Chrome
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    defaults.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    default definitions for this project
// Modifications:
// 10/07/98 jeffort created file
// 10/21/98 jeffort added additional scale defaults
//
//*****************************************************************************

#define DEFAULT_BEHAVIOR_AS_TAG_URL L"anim"

#define DEFAULT_COLORBVR_FROM       0x00000000
#define DEFAULT_COLORBVR_TO         0x00FFFFFF

#define DEFAULT_SCALE_HEIGHT        0x00000100
#define DEFAULT_SCALE_WIDTH         0x00000100

#define DEFAULT_MOVE_TOP            0x00000100
#define DEFAULT_MOVE_LEFT           0x00000100

#define DEFAULT_ROTATEBVR_PROPERTY  L"style.rotation"
#define DEFAULT_COLORBVR_PROPERTY   L"style.color"
#define DEFAULT_SCALEBVR_PROPERTY   L"style."

#define PROPERTY_INVALIDCOLOR       0x99999999

#define MIN_NUM_SCALE_VALUES        2
#define MIN_NUM_MOVE_VALUES         2
#define NUM_VECTOR_VALUES_2D        2
#define NUM_VECTOR_VALUES_3D        3

#define DEFAULT_ACTOR_URN    L"LMBehavior_Actor_Behavior"

#define WZ_DEFAULT_BEHAVIOR_NAME	L"LMBehavior_DefaultName"

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__DEFAULTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\basebvr.h ===
#pragma once
#ifndef __BASEBEHAVIOR_H_
#define __BASEBEHAVIOR_H_
//*****************************************************************************
//
// File:    basebvr.h
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Definition of CBaseBehavior object 
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/16/98 jeffort     Renamed functions, added functions to apply
//                      DA behavior to a property
// 10/21/98 jeffort     added BuildTIMEInterpolatedNumber()
// 11/16/98 markhal		added ApplyImageToAnimationElement
// 11/17/98 kurtj		support for actor construction.
// 11/18/98 kurtj       moved addImageToTime into protected for actor
//
//*****************************************************************************

#include "autobase.h"
#include "..\idl\crbvrdispid.h"
#include "defaults.h"

//*****************************************************************************

class ATL_NO_VTABLE CBaseBehavior:
		public CAutoBase
{

public:
	CBaseBehavior();
	virtual ~CBaseBehavior();

	//IElementBehavior methods
	HRESULT Init(IElementBehaviorSite *pSite);
	HRESULT Notify(LONG event, VARIANT *pVar);
	HRESULT Detach();
protected:

    HRESULT SetAnimatesProperty(VARIANT varAnimates);
    HRESULT GetAnimatesProperty(VARIANT *pvarAnimates);
    HRESULT SetOffsetProperty(VARIANT varOffset);
    HRESULT GetOffsetProperty(VARIANT *pvrOffset);

    HRESULT GetIdOfAnimatedElement(VARIANT *pvarId);

    virtual HRESULT BuildAnimationAsDABehavior() = 0;
    HRESULT GetAnimatedParentElement(IHTMLElement **ppElementReturn);
/*
    HRESULT GetAttributeFromHTMLElement(IHTMLElement *pElement,
                                        WCHAR *pwzAttributeName,
										boolean current,
                                        VARIANT *pvarReturn);
    HRESULT GetAttributeFromHTMLElement(IHTMLElement *pElement,
                                        WCHAR *pwzAttributeName, 
                                        VARIANT *pvarReturn);
	HRESULT GetCurrAttribFromHTMLElement(IHTMLElement *pElement,
										 WCHAR *pwzAttributeName,
										 VARIANT *pvarReturn);
    HRESULT GetAttributeFromHTMLElement(WCHAR *pwzAttributeName, 
                                    VARIANT *pvarReturn);
	HRESULT GetCurrAttribFromHTMLElement(WCHAR *pwzAttributeName,
										VARIANT *pvarReturn);
    HRESULT GetAttributeFromParentHTMLElement(WCHAR *pwzAttributeName, 
                                          VARIANT *pvarReturn);
	HRESULT GetCurrAttribFromParentHTMLElement(WCHAR *pwzAttributeName,
												VARIANT *pvarReturn);
    HRESULT GetAttributeFromAnimatedHTMLElement(WCHAR *pwzAttributeName, 
                                          VARIANT *pvarReturn);
*/
    // For behavior that implement a direction, they
    // may want to reverse this progress number.  We
    // will decalre this as virtual and let them override
    // it so that this can occur
    virtual HRESULT GetTIMEProgressNumber(IDANumber **ppbvrRet);
    virtual HRESULT GetTIMETimelineBehavior(IDANumber **ppbvrRet);
    HRESULT GetTIMEBooleanBehavior(IDABoolean **ppbvrRet);

    HRESULT GetTIMEImageBehaviorFromElement(IHTMLElement *pElement,
                                            IDAImage **pbvrReturnImage);

    HRESULT GetElementToAnimate(IHTMLElement **ppElementReturn);

	// TODO (markhal): All these apply methods go away when behaviors talk to actor
    HRESULT ApplyColorBehaviorToAnimationElement(IDAColor *pbvrColor,
                                                 WCHAR *pwzProperty);    
    HRESULT ApplyNumberBehaviorToAnimationElement(IDANumber *pbvrNumber,
                                                  WCHAR *pwzProperty);    
    HRESULT ApplyStringBehaviorToAnimationElement(IDAString *pbvrString,
                                                  WCHAR *pwzProperty);    
    HRESULT ApplyRotationBehaviorToAnimationElement(IDANumber *pbvrNumber,
                                                  WCHAR *pwzProperty);  
    HRESULT ApplyEffectBehaviorToAnimationElement(IUnknown *pbvrUnk, 
                                                  IDABehavior **ppbvrInputs,
                                                  long cInputs);
	HRESULT ApplyImageBehaviorToAnimationElement(IDAImage *pbvrImage);

	// These are the methods for talking to the actor
	HRESULT GetImageFromActor(IDispatch   *pActorDisp,
								 IDAImage	 **ppImage);

	HRESULT GetBvrFromActor(IDispatch *pActorDisp,
							WCHAR *pwzProperty,
							ActorBvrFlags eFlags,
							ActorBvrType eType,
							IDABehavior **ppResult);
								 
	HRESULT AttachBehaviorToActor(IDispatch   *pActorDisp,
								  IDABehavior *pbvrAttach,
                                  BSTR        bstrProperty,
                                  ActorBvrFlags  eFlags,
                                  ActorBvrType   eType);

    HRESULT AttachBehaviorToActorEx( IDispatch     *pActorDisp,
                                     IDABehavior   *pbvrAttach,
                                     BSTR           bstrProperty,
                                     ActorBvrFlags  eFlags,
                                     ActorBvrType   eType,
                                     IDispatch     *pdispBehaviorElement,
                                     long          *pCookie);

    HRESULT RemoveBehaviorFromActor( IDispatch     *pActorDisp,
                                     long           cookie );

    HRESULT RemoveBehaviorFromActor( long cookie );

    HRESULT AttachEffectToActor(IDispatch *pActorDisp,
								IUnknown *pbvrUnk, 
                                IDABehavior **ppbvrInputs,
                                long cInputs,
                                IDispatch *pdispThis,
                                long *pCookie);

    HRESULT BuildTIMEInterpolatedNumber(float flFrom,
                                        float flTo,
                                        float flOriginal,
                                        IDANumber **ppbvrReturn);

    HRESULT BuildTIMEInterpolatedNumber(float flFrom,
                                        float flTo,
                                        IDANumber **ppbvrReturn);

    HRESULT BuildTIMEInterpolatedNumber(IDANumber *pFrom,
                                        IDANumber *pTo,
                                        IDANumber **ppResult);

    HRESULT CallInvokeOnHTMLElement(IHTMLElement *pElement,
                                    LPWSTR lpProperty,
                                    WORD wFlags,
                                    DISPPARAMS *pdispParms,
                                    VARIANT *pvarResult);
	HRESULT CallInvokeOnDispatch(IDispatch* pDisp,
                                 LPWSTR lpProperty,
                                 WORD wFlags,
                                 DISPPARAMS *pdispParms,
                                 VARIANT *pvarResult);
    virtual HRESULT AttachActorBehaviorToAnimatedElement();

	HRESULT	AttachDABehaviorsToElement( IHTMLElement *pElement );

	HRESULT	RequestRebuild();
	HRESULT CancelRebuildRequests();


    HRESULT FinalConstruct();
    IHTMLElement *GetHTMLElement();

    HRESULT GetHTMLElementDispatch( IDispatch **ppdisp );

    HRESULT ApplyRelative2DMoveBehavior(IDATransform2 *pbvrMove, float, float);
    HRESULT ApplyAbsolute2DMoveBehavior(IDATransform2 *pbvrMove, float, float);

	HRESULT AddBehaviorToTIME(IDABehavior *pbvrAdd);
	HRESULT AddImageToTIME(IHTMLElement *pElement, IDAImage *pbvrAdd, bool enable);

	ActorBvrFlags FlagFromTypeMode(bool relative, VARIANT *pVarType, VARIANT *pVarMode);
	ActorBvrFlags FlagFromTypeMode(ActorBvrFlags flags, VARIANT *pVarType, VARIANT *pVarMode);

    HRESULT NotifyPropertyChanged(DISPID dispid);
	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return m_fPropertiesDirty;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames) = 0;
    virtual VARIANT *VariantFromIndex(ULONG iIndex) = 0;
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP) = 0;
    virtual WCHAR *GetBehaviorTypeAsURN(void){return NULL;};
    virtual WCHAR *GetBehaviorName( ){ return WZ_DEFAULT_BEHAVIOR_NAME; }
    CLSID   m_clsid;

   	HRESULT SafeCond( IDA2Statics *pstatics, 
					  IDABoolean *pdaboolCondition, 
					  IDABehavior *pdabvrIfTrue, 
				  	  IDABehavior *pdabvrIfFalse, 
				  	  IDABehavior **ppdabvrResult );


	HRESULT	AddBehaviorToAnimatedElement( IDABehavior* pdabvr, long *plCookie );
	HRESULT RemoveBehaviorFromAnimatedElement( long cookie );

public:
    IDA2Statics *GetDAStatics();

private:
    HRESULT GetDAStaticsFromTime(IDA2Statics **ppReturn);
    HRESULT CheckElementForActor( IHTMLElement*pElement, bool *pfActorPresent);
    HRESULT CheckElementForBehaviorURN(IHTMLElement *pElement, WCHAR *wzURN, bool *pfReturn);
    HRESULT CheckElementForDA(IHTMLElement* pElement, bool *pfReturn);
    HRESULT Apply2DMoveBvrToPoint(IDATransform2 *pbvrMove, IDAPoint2 *pbvrOrg, float, float);

	IElementBehaviorSite  					*m_pBehaviorSite;
    IHTMLElement                            *m_pHTMLElement;
    IDA2Statics                             *m_pDAStatics;
    VARIANT                                 m_varAnimates;
    bool                                    m_fPropertiesDirty;

    bool									m_fAcceptRebuildRequests;

	IDANumber								*m_pdanumZero;
    IDANumber								*m_pdanumOne;

    IHTMLElement							*m_pelemAnimatedParent;
}; // CBaseBehavior

//*****************************************************************************
// 
// Inline methods
//
//*****************************************************************************

inline IHTMLElement *
CBaseBehavior::GetHTMLElement()
{
    return m_pHTMLElement;
} // GetHTMLElement

//*****************************************************************************

inline IDA2Statics *
CBaseBehavior::GetDAStatics()
{
    return m_pDAStatics;
} // GetDAStatics

//*****************************************************************************
//
// End of File
//
//*****************************************************************************

#endif //__BASEBEHAVIOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\autobase.h ===
#pragma once
#ifndef __CRAUTOBASE_H__
#define __CRAUTOBASE_H__

//*****************************************************************************
//
// FileName:	    autobase.h
//
// Created:	    10/08/97
//
// Author:	    ColinMc
//
// Abstract:	    The base class for all automatable objects
//                  in Trident3D. Stuff that is common across
//                  all scriptable objects should be placed
//                  here
//
// Modifications:
// 10/08/97 ColinMc Created this file
//
//*****************************************************************************


class ATL_NO_VTABLE CAutoBase
{

protected:
    // The constructor and destructor are protected to ensure
    // nobody external ever tries to create one of these
    // babies
		    CAutoBase();
    virtual        ~CAutoBase();

public:
    // Automation compatible error reporting functions
    HRESULT         SetErrorInfo(HRESULT   hr,
			         UINT      nDescriptionID = 0U,
			         LPGUID    pguidInterface = NULL,
			         DWORD     dwHelpContext  = 0UL,
			         LPOLESTR  szHelpFile    = NULL,
			         UINT      nProgID        = 0U);
    void            ClearErrorInfo();

protected:
    HRESULT         GetErrorInfo(IErrorInfo** pperrinfo);
    HINSTANCE       GetErrorModuleHandle();
}; // CAutoBase

//*****************************************************************************
//
// End of file
//
//*****************************************************************************

#endif // __CRAUTOBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\effect.h ===
#pragma once
#ifndef __EFFECTBVR_H_
#define __EFFECTBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    EffectBvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    effect behavior class definition
// Modifications:
// 10/07/98 jeffort created file
//
//*****************************************************************************

#include <resource.h>
#include "dispex.h"
#include "dxtrans.h"
#include "basebvr.h"

#define NUM_EFFECT_PROPS 6

#ifndef CHECK_RETURN_SET_NULL
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}
#endif

//*****************************************************************************

class ATL_NO_VTABLE CEffectBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEffectBvr, &CLSID_CrEffectBvr>,
    public IConnectionPointContainerImpl<CEffectBvr>,
    public IPropertyNotifySinkCP<CEffectBvr>,
    public ICrEffectBvr,
    public IDispatchEx,
	public IElementBehavior,
    public IPersistPropertyBag2,
    public IOleClientSite,
    public IServiceProvider,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CEffectBvr)
    COM_INTERFACE_ENTRY2(IDispatch, IDispatchEx)
    COM_INTERFACE_ENTRY(IDispatchEx)
	COM_INTERFACE_ENTRY(ICrEffectBvr)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IOleClientSite)
	COM_INTERFACE_ENTRY(IServiceProvider)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CEffectBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_EFFECTBVR)

	CEffectBvr();
    virtual ~CEffectBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrEffectBvr *) this ; }
	
	STDMETHOD(put_type)(VARIANT varType);
	STDMETHOD(get_type)(VARIANT *pRetType);
	STDMETHOD(put_transition)(VARIANT varTransition);
	STDMETHOD(get_transition)(VARIANT *pRetTransition);
	STDMETHOD(put_classid)(VARIANT varClassId);
	STDMETHOD(get_classid)(VARIANT *pRetClassId);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(put_progid)(VARIANT varProgId);
	STDMETHOD(get_progid)(VARIANT *pRetProgId);
	STDMETHOD(put_direction)(VARIANT varDirection);
	STDMETHOD(get_direction)(VARIANT *pRetDirection);
	STDMETHOD(put_image)(VARIANT varImage);
	STDMETHOD(get_image)(VARIANT *pRetImage);
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

    // IDispatch and IDispatchEx methods
    STDMETHOD(GetTypeInfoCount)(/*[out]*/UINT FAR* pctinfo);
    STDMETHOD(GetTypeInfo)(/*[in]*/UINT itinfo, 
                            /*[in]*/LCID lcid, 
                            /*[out]*/ITypeInfo ** pptinfo);
    STDMETHOD(GetIDsOfNames)(/*[in]*/REFIID riid,
                            /*[in,size_is(cNames)]*/LPOLESTR * rgszNames,
                            /*[in]*/UINT cNames,
                            /*[in]*/LCID lcid,
                            /*[out,size_is(cNames)]*/DISPID FAR* rgdispid);
    STDMETHOD(Invoke)(/*[in]*/DISPID dispidMember,
                        /*[in]*/REFIID riid,
                        /*[in]*/LCID lcid,
                        /*[in]*/WORD wFlags,
                        /*[in,out]*/DISPPARAMS * pdispparams,
                        /*[out]*/VARIANT * pvarResult,
                        /*[out]*/EXCEPINFO * pexcepinfo,
                        /*[out]*/UINT * puArgErr);
    STDMETHOD(GetDispID)(/*[in]*/BSTR bstrName,
                            /*[in]*/DWORD grfdex,
                            /*[out]*/DISPID *pid);
    STDMETHOD(InvokeEx)(/*[in]*/DISPID dispidMember,
                        /*[in]*/LCID lcid,
                        /*[in]*/WORD wFlags,
                        /*[in]*/DISPPARAMS * pdispparams,
                        /*[in,out,unique]*/VARIANT * pvarResult,
                        /*[in,out,unique]*/EXCEPINFO * pexcepinfo,
                        /*[in,unique]*/IServiceProvider *pSrvProvider);
    STDMETHOD(DeleteMemberByName)(/*[in]*/BSTR bstr,
                                    /*[in]*/DWORD grfdex);
    STDMETHOD(DeleteMemberByDispID)(/*[in]*/DISPID id);
    STDMETHOD (GetMemberProperties)(/*[in]*/DISPID id,
                                    /*[in]*/DWORD grfdexFetch,
                                    /*[out]*/DWORD *pgrfdex);
    STDMETHOD (GetMemberName)(/*[in]*/DISPID id,
                              /*[out]*/BSTR *pbstrName);
    STDMETHOD (GetNextDispID)(/*[in]*/DWORD grfdex,
                                /*[in]*/DISPID id,
                                /*[out]*/DISPID *prgid);
    STDMETHOD (GetNameSpaceParent)(/*[out]*/IUnknown **ppunk);

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    // IOleClientSite interfaces
    STDMETHOD(SaveObject)()
    { return E_NOTIMPL; }
    STDMETHOD(GetMoniker)(DWORD dwAssign,
                          DWORD dwWhichMoniker, 
                          LPMONIKER * ppmk)
    { CHECK_RETURN_SET_NULL(ppmk); return E_NOTIMPL; }
    STDMETHOD(GetContainer)(LPOLECONTAINER * ppContainer)
    { CHECK_RETURN_SET_NULL(ppContainer); return E_NOTIMPL; }
    STDMETHOD(ShowObject)()
    { return E_NOTIMPL; }
    STDMETHOD(OnShowWindow)(BOOL fShow)
    { return E_NOTIMPL; }
    STDMETHOD(RequestNewObjectLayout)()
    { return E_NOTIMPL; }

    // IServiceProvider interfaces
    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);
protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    virtual HRESULT GetTIMEProgressNumber(IDANumber **ppbvrRet);


private:
    // Type information helper class "borrowed" from ATL's IDispatch code
    static CComTypeInfoHolder s_tihTypeInfo;

    HRESULT GetClassIdFromType(WCHAR **pwzClassId);
    HRESULT BuildTransform();

    static WCHAR                *m_rgPropNames[NUM_EFFECT_PROPS]; 
    VARIANT                     m_varType;
    VARIANT                     m_varTransition;
    VARIANT                     m_varClassId;
    VARIANT                     m_varProgId;
    VARIANT                     m_varDirection;
    VARIANT                     m_varImage;
    IDXTransform                *m_pTransform;
    IServiceProvider            *m_pSp;
    IHTMLDocument2              *m_pHTMLDoc;

    IDispatch					*m_pdispActor;
    long						m_lCookie;

}; // CEffectBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__EFFECTBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\elementprop.h ===
#pragma once
#ifndef __ELEMENTPROP_H__
#define __ELEMENTPROP_H__
  
//*****************************************************************************
//
// Microsoft LMRT
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:        elementprop.h
//
// Author:          KurtJ
//
// Created:         2/14/99
//
// Abstract:        Sinks IHTMLElement property changes.
//
// Modifications:
// 1/14/98 KurtJ Created this file
//
//*****************************************************************************


class IElementLocalTimeListener
{
public:
    STDMETHOD(OnLocalTimeChange)( float localTime )=0;
};


class CElementPropertyMonitor:
	public IPropertyNotifySink
{
public:

								CElementPropertyMonitor			();
								~CElementPropertyMonitor		();

    //IUnknown
    STDMETHOD					(QueryInterface)				( REFIID riid, void** ppv );

    STDMETHOD_					(ULONG, AddRef)					();

    STDMETHOD_					(ULONG, Release)				();

	//IPropertyNotifySink
	STDMETHOD					(OnChanged)						( DISPID dispid );
	STDMETHOD					(OnRequestEdit)					( DISPID dispid );

    //IElementEventMonitor
    STDMETHOD					(SetLocalTimeListener)			( IElementLocalTimeListener *pListener );

    STDMETHOD					(Attach)						( IHTMLElement* pelemToListen );
    STDMETHOD					(Detach)						();
	bool						IsAttached						(){return (m_pelemElement != NULL);};

	STDMETHOD					(UpdateDISPIDCache)				();

private:

    IElementLocalTimeListener	*m_pLocalTimeListener;

	DWORD						m_dwElementPropertyConPtCookie;
    IConnectionPoint            *m_pconptElement;

    IHTMLElement                *m_pelemElement;
	IDispatch					*m_pdispElement;

	DISPID						m_dispidLocalTime;

    long                        m_refCount;

    HRESULT						ProcessLocalTimeChange			();
    
    HRESULT                     AttachToElementConPt			();
    HRESULT                     DetachFromElementConPt			();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\dispmethod.h ===
#pragma once
#ifndef __DISPMETHOD_H__
#define __DISPMETHOD_H__


/************************************************************
*
*
*************************************************************/

typedef HRESULT (*InvokeProxy)(void* pvData);

class CDispatchMethod: public IDispatch
{
public:
	CDispatchMethod();
	virtual ~CDispatchMethod();

	//IUnknown
   	STDMETHOD(QueryInterface)           ( REFIID riid, void** ppv );

    STDMETHOD_(ULONG, AddRef)           ();

    STDMETHOD_(ULONG, Release)          ();

    //IDispatch
    STDMETHOD(GetTypeInfoCount)         (UINT *pctInfo);

    STDMETHOD(GetTypeInfo)              ( UINT iTypeInfo,
                                          LCID lcid,
                                          ITypeInfo** ppTypeInfo);

    STDMETHOD(GetIDsOfNames)            ( REFIID riid,
                                          LPOLESTR* rgszNames,
                                          UINT cNames,
                                          LCID lcid,
                                          DISPID* rgid );

    STDMETHOD(Invoke)                   ( DISPID id,
                                          REFIID riid,
                                          LCID lcid,
                                          WORD wFlags,
                                          DISPPARAMS *pDispParams,
                                          VARIANT *pvarResult,
                                          EXCEPINFO *pExcepInfo,
                                          UINT *puArgErr );
    //subclasses should implement this to determine event specific behavior.

    virtual HRESULT	HandleEvent			()=0;
                                              
private:

	ULONG								m_cRefs;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\eventsink.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventSink.h
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#ifndef _EVENTSINK_H
#define _EVENTSINK_H

#include "evtmgrclient.h"

enum ELEMENT_EVENT
{
    EE_ONPROPCHANGE = 0,
    //add non-input related events to hook here
    EE_ONREADYSTATECHANGE, 
    EE_ONMOUSEMOVE,
    EE_ONMOUSEDOWN,
    EE_ONMOUSEUP,
    EE_ONKEYDOWN,
    EE_ONKEYUP,
    EE_ONBLUR,
    //add input related events here
    EE_MAX
};

class CEventSink
    : public IDispatch
{
  public:
    CEventSink(IEventManagerClient* bvr, CEventMgr *pEventMgr);
    ~CEventSink();

    //methods
    HRESULT Init();
    HRESULT Deinit();
    HRESULT InitMouse();

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);


  protected:
    //methods
    HRESULT                           AttachEvents();
    HRESULT                           DetachEvents();
    HRESULT                           NotifyReadyState(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyPropertyChange(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseMove(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseUp(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseDown(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyKeyDown(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyKeyUp(IHTMLEventObj *pEventObj);

    //properties
    IHTMLElement *                    m_pElement;
    IEventManagerClient*			  m_client;
    long                              m_refCount;
    DWORD                             m_dwElementEventConPtCookie;
    CComPtr<IConnectionPoint>         m_pElementConPt;
    CEventMgr *                       m_pEventMgr;

};

#endif /* _EVENTSINK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\eventmgr.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventMgr.h
//
// Abstract:
//
///////////////////////////////////////////////////////////////

#ifndef _EVENTMGR_H
#define _EVENTMGR_H

#include "basebvr.h"
#include "evtmgrclient.h"

#include <list>
using namespace std;

typedef list<IUnknown *>	ListUnknowns;

enum TIME_EVENT
{
    TE_ONBEGIN = 0,
    TE_ONPAUSE, 
    TE_ONRESUME, 
    TE_ONEND,
    TE_ONRESYNC,
    TE_ONREPEAT,
    TE_ONREVERSE,
    TE_ONMEDIACOMPLETE,
    TE_MAX
};

class CEventSink;

class CEventMgr
    : public IDispatch
{
  public:
    CEventMgr(IEventManagerClient *bvr);
    ~CEventMgr();

    //methods
    HRESULT Init();
    HRESULT Deinit();    
    //  Parameters needed to be packed into Variants by the caller
    HRESULT FireEvent(TIME_EVENT TimeEvent, 
                      long Count, 
                      LPWSTR szParamNames[], 
                      VARIANT varParams[]); 

	HRESULT AddMouseEventListener( LPUNKNOWN pUnkListener );
	HRESULT RemoveMouseEventListener( LPUNKNOWN pUnkListener );
	
    void ReadyStateChange(BSTR ReadyState);
    void PropertyChange(BSTR PropertyName);

    void MouseEvent(long x, 
                    long y, 
                    VARIANT_BOOL bMove,
                    VARIANT_BOOL bUp,
                    VARIANT_BOOL bShift, 
                    VARIANT_BOOL bAlt,
                    VARIANT_BOOL bCtrl,
                    long button);
    
    void KeyEvent(VARIANT_BOOL bLostFocus,
                  VARIANT_BOOL bUp,
                  VARIANT_BOOL bShift, 
                  VARIANT_BOOL bAlt,
                  VARIANT_BOOL bCtrl,
                  long KeyCode,
                  long RepeatCount);

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

  protected:
	bool	FindUnknown( const ListUnknowns& listUnknowns,
						 LPUNKNOWN pUnk,
						 ListUnknowns::iterator& iterator );
	
  protected:
    //Cookie for the Window ConnectionPoint
    IEventManagerClient*              m_client;
    CEventSink *                      m_pEventSink;
    CComPtr<IConnectionPoint>         m_pWndConPt;
    CComPtr<IConnectionPoint>         m_pDocConPt;
    CComPtr<IHTMLWindow2>             m_pWindow;
    
    IHTMLElement *                    m_pElement;
    IHTMLElement2 **                  m_pBeginElement;
    IHTMLElement2 **                  m_pEndElement;
    long                              m_lBeginEventCount;
    long                              m_lEndEventCount;
    long                              m_lRepeatCount;
    BOOL                              m_bAttached;

    //Cookies
    DWORD                             m_cookies[TE_MAX];
    DWORD                             m_dwWindowEventConPtCookie;
    DWORD                             m_dwDocumentEventConPtCookie;
    
    //reference goo
    long                              m_refCount;
    
    HRESULT                           RegisterEvents();
    HRESULT                           Attach(BSTR Event, BOOL bAttach, IHTMLElement2 *pEventElement[], long Count);
    HRESULT                           ConnectToContainerConnectionPoint();
    HRESULT                           GetEventName(BSTR bstrEvent, BSTR **pElementName, BSTR **pEventName, long Count);
    long                              GetEventCount(BSTR bstrEvent);
    bool                              MatchEvent(BSTR bstrEvent, IHTMLEventObj *pEventObj, long Count);
    BYTE                              GetModifiers(VARIANT_BOOL bShift, VARIANT_BOOL bCtrl, VARIANT_BOOL bAlt);
        
        //input event parameters
    BYTE                              m_lastKeyMod;
    DWORD                             m_lastKey;
    int                               m_lastKeyCount;
    HWND                              m_hwndCurWnd;    
    long                              m_lastX;
    long                              m_lastY;
    long                              m_lastButton;
    BYTE                              m_lastMouseMod;
	ListUnknowns					  m_listMouseEventListeners;
};

#endif /* _EVENTMGR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\evtmgrclient.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: evtmgrclient.h
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#ifndef __EVTMGRCLIENT_H
#define __EVTMGRCLIENT_H


enum e_readyState {
	EVTREADYSTATE_UNKNOWN = 0,
	EVTREADYSTATE_COMPLETE = 1,
	EVTREADYSTATE_INTERACTIVE = 2 
};
class IEventManagerClient
{

public:

	//information methods
	virtual IHTMLElement*			GetElementToSink		()=0;
	virtual IElementBehaviorSite*	GetSiteToSendFrom		()=0;
	virtual HRESULT					TranslateMouseCoords	( long lX, long lY, long * pXTrans, long * pYTrans )=0;
	
	//Event callbacks
	virtual void					OnLoad					()=0;
	virtual void					OnUnload				()=0;
	virtual void					OnReadyStateChange		( e_readyState state )=0;
};

#endif //__EVTMGRCLIENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\lmtrace.h ===
#ifndef _LM_TRACE_INC_
#define _LM_TRACE_INC_
/////////////////////////////////////////////////////////////
//trace definitions stolen from ATL 30 headers and customized
/////////////////////////////////////////////////////////////

/////////////////////////////////////
// LM DEBUG Defines
////////////////////////////////////
#ifdef _DEBUG
#include <assert.h>
#define LMASSERT(expr) assert((expr))

#define LM_TRACE_CATEGORY	(lmTraceNone)
#define LM_TRACE_LEVEL		(0)
#else
#define LMASSERT(expr) ((void)0)
#endif //_DEBUG
////////////////////////////////////
// End LM DEBUG Defines
////////////////////////////////////

enum lmTraceFlags
{
	//LM defined categories
	lmTraceNone					= 0x00000000,
	lmTraceLMRT 				= 0x00000001,
	lmTraceBaseBehavior			= 0x00000002,
	lmTraceMoveBehavior			= 0x00000004,
	lmTraceColorBehavior 		= 0x00000008,
	lmTraceAll					= 0xFFFFFFFF,
};

#ifndef LM_TRACE_CATEGORY
#define LM_TRACE_CATEGORY (lmTraceAll)
#endif

#ifdef _DEBUG

#ifndef LM_TRACE_LEVEL
#define LM_TRACE_LEVEL 0
#endif

inline void _cdecl LmTrace(LPCSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[512];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	LMASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringA(szBuffer);
	va_end(args);
}
inline void _cdecl LmTrace2(DWORD category, UINT level, LPCSTR lpszFormat, ...)
{
	if (category & LM_TRACE_CATEGORY && level <= LM_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		char szBuffer[512];

		nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
		LMASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringA("LM: ");
		OutputDebugStringA(szBuffer);
		va_end(args);
	}
}
#ifndef OLE2ANSI
inline void _cdecl LmTrace(LPCWSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512];

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]), lpszFormat, args);
	LMASSERT(nBuf < sizeof(szBuffer) / sizeof(szBuffer[0]));//Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringW(szBuffer);
	va_end(args);
}
inline void _cdecl LmTrace2(DWORD category, UINT level, LPCWSTR lpszFormat, ...)
{
	if (category & LM_TRACE_CATEGORY && level <= LM_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		WCHAR szBuffer[512];

		nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]), lpszFormat, args);
		LMASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringW(L"LM: ");
		OutputDebugStringW(szBuffer);
		va_end(args);
	}
}
#endif //!OLE2ANSI


#ifndef LMTRACE
#define LMTRACE            LmTrace
#define LMTRACE2           LmTrace2
#endif
#define LMTRACENOTIMPL(funcname)   LMTRACE2(lmTraceNotImpl, 2, _T("LM: %s not implemented.\n"), funcname); return E_NOTIMPL
#else // !DEBUG
inline void _cdecl LmTrace(LPCSTR , ...){}
inline void _cdecl LmTrace2(DWORD, UINT, LPCSTR , ...){}
#ifndef OLE2ANSI
inline void _cdecl LmTrace(LPCWSTR , ...){}
inline void _cdecl LmTrace2(DWORD, UINT, LPCWSTR , ...){}
#endif //OLE2ANSI
#ifndef LMTRACE
#define LMTRACE            1 ? (void)0 : LmTrace
#define LMTRACE2			1 ? (void)0 : LmTrace2
#endif //LMTRACE
#define LMTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG

#endif //_LM_TRACE_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\factory.h ===
#pragma once
#ifndef __CRBEHAVIORFACTORY_H_
#define __CRBEHAVIORFACTORY_H_

//*****************************************************************************
//
// File: factory.h
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Definition of CCrBehaviorFactory object which implements
//           the chromeffects factory of DHTML behaviors
//
// Modification List:
// Date     Author      Change
// 09/26/98 jeffort     Created this file
//
//*****************************************************************************

#include <resource.h>
#include "autobase.h"

//*****************************************************************************

typedef enum
{
    crbvrRotate,
    crbvrScale,
    crbvrSet,
    crbvrNumber,
    crbvrMove,
    crbvrPath,
    crbvrColor,
    crbvrActor,
    crbvrEffect,
    crbvrAction,
    crbvrDA,
    crbvrUnknown
} ECRBEHAVIORTYPE;



class ATL_NO_VTABLE CCrBehaviorFactory : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CCrBehaviorFactory, &CLSID_CrBehaviorFactory>,
#ifdef CRSTANDALONE
    public IDispatchImpl<ICrBehaviorFactory, &IID_ICrBehaviorFactory, &LIBID_ChromeBehavior>,
#else
    public IDispatchImpl<ICrBehaviorFactory, &IID_ICrBehaviorFactory, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
    public IObjectSafetyImpl<CCrBehaviorFactory>,
    public CAutoBase,
    public IElementBehaviorFactory
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_CRBVRFACTORY)

    CCrBehaviorFactory()
    {
    }

    // IObjectSafetyImpl
    STDMETHOD(SetInterfaceSafetyOptions)(
                            /* [in] */ REFIID riid,
                            /* [in] */ DWORD dwOptionSetMask,
                            /* [in] */ DWORD dwEnabledOptions);
    STDMETHOD(GetInterfaceSafetyOptions)(
                            /* [in] */ REFIID riid, 
                            /* [out] */DWORD *pdwSupportedOptions, 
                            /* [out] */DWORD *pdwEnabledOptions);
    //
    // IElementBehaviorFactory
    //

    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace, 
                            LPOLESTR pchTagName, 
                            IElementBehaviorSite *pUnkArg, 
                            IElementBehavior **ppBehavior)
    {
        return FindBehavior(pchNameSpace, pchTagName, static_cast<IUnknown*>(pUnkArg), ppBehavior);
    }

    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace, 
                            LPOLESTR pchTagName, 
                            IUnknown *pUnkArg, 
                            IElementBehavior **ppBehavior);

    STDMETHODIMP UIDeactivate() 
    { 
        return S_OK; 
    } // UIDeactivate
    
DECLARE_PROTECT_FINAL_CONSTRUCT()
BEGIN_COM_MAP(CCrBehaviorFactory)
    COM_INTERFACE_ENTRY(ICrBehaviorFactory)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehaviorFactory)
END_COM_MAP()


private:
    ECRBEHAVIORTYPE GetBehaviorTypeFromBstr(BSTR bstrBehaviorType);
    DWORD m_dwSafety;
}; // CCrBehaviorFactory

//*****************************************************************************
//
// End of File
//
//*****************************************************************************

#endif //__CRBEHAVIORFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\number.h ===
#pragma once
#ifndef __NUMBERBVR_H_
#define __NUMBERBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    numberbvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    number behavior class definition
// Modifications:
// 10/07/98 jeffort created file
// 11/16/98 jeffort implemented expression attribute
// 11/17/98 kurtj	moved to actor construction model
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#define NUM_NUMBER_PROPS 6

//*****************************************************************************

class ATL_NO_VTABLE CNumberBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNumberBvr, &CLSID_CrNumberBvr>,
    public IConnectionPointContainerImpl<CNumberBvr>,
    public IPropertyNotifySinkCP<CNumberBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrNumberBvr, &IID_ICrNumberBvr, &LIBID_ChromeBehavior>,
    error me here
#else
	public IDispatchImpl<ICrNumberBvr, &IID_ICrNumberBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public IDABvrHook,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CNumberBvr)
	COM_INTERFACE_ENTRY(ICrNumberBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CNumberBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_NUMBERBVR)

	CNumberBvr();
    virtual ~CNumberBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrNumberBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrNumberBehavior
	STDMETHOD(put_from)(VARIANT varFrom);
	STDMETHOD(get_from)(VARIANT *pRetFrom);
	STDMETHOD(put_to)(VARIANT varTo);
	STDMETHOD(get_to)(VARIANT *pRetTo);
	STDMETHOD(put_by)(VARIANT varBy);
	STDMETHOD(get_by)(VARIANT *pRetBy);
	STDMETHOD(put_type)(VARIANT varType);
	STDMETHOD(get_type)(VARIANT *pRetType);
	STDMETHOD(put_mode)(VARIANT varMode);
	STDMETHOD(get_mode)(VARIANT *pRetMode);
	// Unfortunately, there is an IE5 bug where executing
	// script does not return the correct value, so we can
	// not support expression at this time.  Therefor, these
    // methods are not exposed by any interface at this time
	STDMETHOD(put_expression)(VARIANT varExpression);
	STDMETHOD(get_expression)(VARIANT *pRetExpression);
	STDMETHOD(put_property)(VARIANT varProperty);
	STDMETHOD(get_property)(VARIANT *pRetProperty);
	STDMETHOD(get_beginProperty)(VARIANT *pRetBeginProperty);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

    // IDABvrHook
    virtual HRESULT STDMETHODCALLTYPE Notify(LONG id,
                                             VARIANT_BOOL startingPerformance,
                                             double startTime,
                                             double gTime,
                                             double lTime,
                                             IDABehavior *sampleVal,
                                             IDABehavior *curRunningBvr,
                                             IDABehavior **ppBvr);
	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:

    HRESULT EvaluateScriptExpression(WCHAR *wzScript, float &flReturn);

    static WCHAR                *m_rgPropNames[NUM_NUMBER_PROPS]; 
    VARIANT                     m_varFrom;
    VARIANT                     m_varTo;
    VARIANT                     m_varBy;
	VARIANT						m_varType;
	VARIANT						m_varMode;
    VARIANT                     m_varProperty;
    VARIANT                     m_varExpression;
    VARIANT                     m_varBeginProperty;

    IDispatch					*m_pdispActor;
    long						m_lCookie;

    HRESULT						RemoveFragment();

}; // CNumberBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__NUMBERBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\path.h ===
#pragma once
#ifndef __PATH_H_
#define __PATH_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    path.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    path behavior class definition
// Modifications:
// 10/07/98 jeffort  created file
// 11/09/98 jeffwall split out extra objects
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#include "pmanager.h"

#define NUM_PATH_PROPS 1

//*****************************************************************************

class ATL_NO_VTABLE CPathBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPathBvr, &CLSID_CrPathBvr>,
    public IConnectionPointContainerImpl<CPathBvr>,
    public IPropertyNotifySinkCP<CPathBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrPathBvr, &IID_ICrPathBvr, &LIBID_ChromeBehavior>,
    error me here
#else
	public IDispatchImpl<ICrPathBvr, &IID_ICrPathBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CPathBvr)
	COM_INTERFACE_ENTRY(ICrPathBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CPathBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_PATHBVR)

	CPathBvr();
    virtual ~CPathBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrPathBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrPathBehavior
	STDMETHOD(put_v)(VARIANT varPath);
	STDMETHOD(get_v)(VARIANT *pRetPath);
    STDMETHOD(GetDATransform)(IDispatch *pDispProgress, 
                              VARIANT *pRetTrans);
	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:
    static WCHAR                *m_rgPropNames[NUM_PATH_PROPS]; 
    VARIANT                     m_varPath;
    CPathManager                *m_pPathManager;
}; // CPathBvr

#endif //__PATH_H_ 

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\pathline.h ===
#pragma once
#ifndef __PATHLINE_H_
#define __PATHLINE_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    pathline.h
//
// Author:	jeffwall
//
// Created:	11/09/98
//
// Abstract:    path line seqment class definition
// Modifications:
// 11/09/98 jeffwall created file from path.h
//
//*****************************************************************************

#include "pelement.h"

//*****************************************************************************

class CPathLineSegment : public CPathElement
{
public:
    CPathLineSegment();
    virtual ~CPathLineSegment();
    float Distance();
    void SetValues(float flStartX, float flStartY, float flEndX, float flEndY);
    virtual HRESULT BuildTransform(IDA2Statics *pDAStatics,
                                   IDANumber *pbvrProgress, 
                                   float flStartPercentage,
                                   float flEndPercentage,
                                   IDATransform2 **ppbvrResult);

    float m_flStartX;
    float m_flStartY;
    float m_flEndX;
    float m_flEndY;
}; // CPathLineSegment

#endif // __PATHLINE_H_


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\pcurve.h ===
#pragma once
#ifndef __PATHCURV_H_
#define __PATHCURV_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    pathcurv.h
//
// Author:	jeffwall
//
// Created:	11/09/98
//
// Abstract:    path curve class definition
// Modifications:
// 11/09/98 jeffwall created file from path.h
//
//*****************************************************************************

#include "pelement.h"
#include "pathline.h"

//*****************************************************************************

class CPathCurve : public CPathElement
{
public:
    CPathCurve();
    virtual ~CPathCurve();
    float Distance();
    HRESULT SetValues(float flStartX, 
                   float flStartY, 
                   float flControl1X,
                   float flControl1Y,
                   float flControl2X,
                   float flControl2Y,
                   float flEndX, 
                   float flEndY);

    virtual HRESULT BuildTransform(IDA2Statics *pDAStatics,
                                   IDANumber *pbvrProgress, 
                                   float flStartPercentage,
                                   float flEndPercentage,
                                   IDATransform2 **ppbvrResult);
private:
    HRESULT createCurveSegments(float *pflXComponents,
                                 float *pflYComponents,
                                 float *pflLength,
                                 float flTolerance);

    float m_flStartX;
    float m_flStartY;
    float m_flControl1X;
    float m_flControl1Y;
    float m_flControl2X;
    float m_flControl2Y;
    float m_flEndX;
    float m_flEndY;
    float m_flDistance;
    int   m_segCount;

    CPathLineSegment *m_pListHead;
    CPathLineSegment *m_pListTail;
}; // CPathCurve

#endif //__PATHCURV_H_


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\move.h ===
#pragma once
#ifndef __MOVEBVR_H_
#define __MOVEBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    MoveBvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    move behavior class definition
// Modifications:
// 10/07/98 jeffort created file
// 10/21/98 jeffort brought closer to spec including 3D and percentage work
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"
#include "path.h"
#include "sampler.h"

#define NUM_MOVE_PROPS 7
//*****************************************************************************

class ATL_NO_VTABLE CMoveBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMoveBvr, &CLSID_CrMoveBvr>,
    public IConnectionPointContainerImpl<CMoveBvr>,
    public IPropertyNotifySinkCP<CMoveBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrMoveBvr2, &IID_ICrMoveBvr2, &LIBID_ChromeBehavior>,
#else
	public IDispatchImpl<ICrMoveBvr2, &IID_ICrMoveBvr2, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior	
{

BEGIN_COM_MAP(CMoveBvr)
	COM_INTERFACE_ENTRY(ICrMoveBvr)
	COM_INTERFACE_ENTRY(ICrMoveBvr2)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CMoveBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_MOVEBVR)

	CMoveBvr();
    virtual ~CMoveBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrMoveBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrColorBehavior
	STDMETHOD(put_from)(VARIANT varFrom);
	STDMETHOD(get_from)(VARIANT *pRetFrom);
	STDMETHOD(put_to)(VARIANT varTo);
	STDMETHOD(get_to)(VARIANT *pRetTo);
	STDMETHOD(put_by)(VARIANT varBy);
	STDMETHOD(get_by)(VARIANT *pRetBy);
	STDMETHOD(put_v)(VARIANT varPath);
	STDMETHOD(get_v)(VARIANT *pRetPath);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
    STDMETHOD(put_type)(VARIANT varType);
    STDMETHOD(get_type)(VARIANT *pRetType);
	STDMETHOD(put_mode)(VARIANT varMode);
	STDMETHOD(get_mode)(VARIANT *pRetMode);
    STDMETHOD(put_direction)(VARIANT varDirection);
    STDMETHOD(get_direction)(VARIANT *pRetDirection);
	STDMETHOD(buildBehaviorFragments)(IDispatch *pActorDisp);

	// ICrMoveBvr2
	STDMETHOD(get_currentX)(VARIANT *pRetCurrent);
	STDMETHOD(get_currentY)(VARIANT *pRetCurrent);
	
	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //sample callback
    static HRESULT PositionSampled( void *thisPtr,
								  	long id,
								  	double startTime,
								  	double globalNow,
								  	double localNow,
								  	IDABehavior * sampleVal,
								  	IDABehavior **ppReturn);

	HRESULT	UpdatePosition( IDABehavior *sampleVal );

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    virtual HRESULT GetTIMEProgressNumber(IDANumber **ppbvrRet);

private:

    HRESULT InitializeProperties();
    HRESULT GetMove2DVectorValues(float  rgflFrom[2],
                                float  rgflTo[2]);
    HRESULT Build2DTransform(IDispatch *pActorDisp, IDATransform2 **ppbvrTransform);
	HRESULT GetMoveToTransform(IDispatch *pActorDisp, IDATransform2 **ppResult);


    static WCHAR                *m_rgPropNames[NUM_MOVE_PROPS]; 
    CPathManager                *m_pPathManager;
    VARIANT                     m_varFrom;
    VARIANT                     m_varTo;
    VARIANT                     m_varBy;
    VARIANT                     m_varPath;
    VARIANT                     m_varType;
	VARIANT						m_varMode;
    VARIANT                     m_varDirection;
    ActorBvrFlags               m_DefaultType;

    IDispatch					*m_pdispActor;
    long						m_lCookie;

    CSampler					*m_pSampler;
    long						m_lSampledCookie;

    VARIANT						m_varCurrentX;
    VARIANT						m_varCurrentY;
}; // CMoveBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__MOVEBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\pellipse.h ===
#pragma once
#ifndef __PATHANGE_H_
#define __PATHANGE_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    pathange.h
//
// Author:	jeffwall
//
// Created:	11/09/98
//
// Abstract:    path AngleElipse class definition
// Modifications:
// 11/09/98 jeffwall created file
//
//*****************************************************************************

#include "pelement.h" 

//*****************************************************************************

class CPathEllipse : public CPathElement
{
public:
    CPathEllipse();
    virtual ~CPathEllipse();
    float Distance();
    void SetValues(float flCenterX, 
                      float flCenterY, 
                      float flWidth,
                      float flHeight,
                      float flStartAngle,
                      float flSweep,
                      float *flStartX,
                      float *flStartY,
                      float *flEndX,
                      float *flEndY);

    virtual HRESULT BuildTransform(IDA2Statics *pDAStatics,
                                   IDANumber *pbvrProgress, 
                                   float flStartPercentage,
                                   float flEndPercentage,
                                   IDATransform2 **ppbvrResult);
private:

    float internalDistance();

    float m_flHeight;
    float m_flWidth;
    float m_flStartAngle;
    float m_flSweep;
    float m_flDistance;
    float m_flCenterX;
    float m_flCenterY;
}; // CPathEllipse

#endif //__PATHANGE_H_


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\pmanager.h ===
#pragma once
#ifndef __PATHMNGR_H_
#define __PATHMNGR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    pathmngr.h
//
// Author:	jeffwall
//
// Created:	11/09/98
//
// Abstract:    path manager class definition
// Modifications:
// 11/09/98 jeffwall created file from path.h
//
//*****************************************************************************

#include "pelement.h"

//*****************************************************************************

class CPathManager : CPathElement
{
public:
    CPathManager();
    virtual ~CPathManager();
    virtual HRESULT Initialize(BSTR bstrPath);
    virtual HRESULT BuildTransform(IDA2Statics *pDAStatics,
                                   IDANumber *pbvrProgress, 
                                   float flStartPercentage,
                                   float flEndPercentage,
                                   IDATransform2 **ppbvrResult);
    float Distance();
    void AddPathObjectToList(CPathElement *pObject);

private:

	void DeletePathList();
	
    HRESULT ParseForPathElements(BSTR *pbstrPath);
    HRESULT ParseLineElement(BSTR *pbstrPath);
    HRESULT ParseCurveElement(BSTR *pbstrPath);
    HRESULT ParseEllipseElement(BSTR *pbstrPath);
    HRESULT ParseArcElement(BSTR *pbstrPath);
    HRESULT ParseEllipseQuadrant(BSTR *pbstrPath);

    void GetAngle(float, float, float*);

    HRESULT RecursiveBuildAllPathTransforms(IDA2Statics *pDAStatics,
                                            IDANumber *pbvrProgress,
                                            CPathElement *pPathObj,
                                            float flStartPercentage,
                                            float flTotalPercentage,
                                            float flTotalDistance,
                                            IDATransform2 **ppbvrResult);
    CPathElement    *m_pPathTail;
    CPathElement    *m_pPathHead;
    float           m_flStartX;
    float           m_flStartY;
    float           m_flEndX;
    float           m_flEndY;
}; // CPathManager

#endif // __PATHMNGR_H_


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\pelement.h ===
#pragma once
#ifndef __PATHELMT_H_
#define __PATHELMT_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    pathelmt.h
//
// Author:	jeffwall
//
// Created:	11/09/98
//
// Abstract:    path Element class definition
// Modifications:
// 11/09/98 jeffwall created file from path.h
//
//*****************************************************************************

#include <resource.h>

//*****************************************************************************

class CPathElement
{
public:
    CPathElement();
    virtual ~CPathElement();
    virtual HRESULT Initialize(BSTR *pbstrPath, float flStartX, float flStartY)
    {
        return S_OK;
    }
    virtual HRESULT BuildTransform(IDA2Statics *pDAStatics,
                                   IDANumber *pbvrProgress, 
                                   float flStartPercentage,
                                   float flEndPercentage,
                                   IDATransform2 **pbvrResult) = 0;
    virtual float Distance() = 0;
    CPathElement    *m_pNext;

protected:
    // this is a helper function that every path element
    // will most likely need
    HRESULT NormalizeProgressValue(IDA2Statics *pDAStatics,
                           IDANumber *pbvrProgress, 
                           float flStartPercentage,
                           float flEndPErcentage,
                           IDANumber **ppbvrReturn);
}; // CPathElement

#endif // __PATHELMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\resource.h ===
#pragma once
#ifndef _CRRESOURCE_H
#define _CRRESOURCE_H
//*****************************************************************************
//
// Microsoft Chrome
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    resource.h
//
// Author:	    jeffort
//
// Created:	    10/07/98
//
// Abstract:    resource definitions for this project
// Modifications:
// 10/07/98 jeffort created file
// 11/03/98 kurtj   relocated idrs to allow space for lmrt idrs
//
//*****************************************************************************

//these should be offset from the top end of the resources allocated for lmrt
// but doing addition in a resid is apparently a no no.

#define IDR_CRBVRFACTORY        301
#define IDR_COLORBVR		302
#define IDR_ROTATEBVR           303
#define IDR_SCALEBVR            304
#define IDR_MOVEBVR             305
#define IDR_PATHBVR             306
#define IDR_NUMBERBVR           307
#define IDR_SETBVR              308
#define IDR_ACTORBVR            309
#define IDR_EFFECTBVR           310
#define IDR_ACTIONBVR           311

// We could potentially be included in the lmrt resource file, which will define 
// this for itself, so we only want it defined if it is currently not defined
#ifndef RESID_TYPELIB
#define RESID_TYPELIB           1
#endif // RESID_TYPELIB


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif /* _CRRESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\set.h ===
#pragma once
#ifndef __SETBVR_H_
#define __SETBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    setbvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    set behavior class definition
// Modifications:
// 10/07/98 jeffort created file
// 11/20/98 markhal	converted to work with actor
//
//*****************************************************************************

#include <resource.h>

#include "basebvr.h"

#define NUM_SET_PROPS 3

//*****************************************************************************

class ATL_NO_VTABLE CSetBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSetBvr, &CLSID_CrSetBvr>,
    public IConnectionPointContainerImpl<CSetBvr>,
    public IPropertyNotifySinkCP<CSetBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrSetBvr, &IID_ICrSetBvr, &LIBID_ChromeBehavior>,
    error me here
#else
	public IDispatchImpl<ICrSetBvr, &IID_ICrSetBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CSetBvr)
	COM_INTERFACE_ENTRY(ICrSetBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CSetBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_SETBVR)

	CSetBvr();
    virtual ~CSetBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrSetBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrSetBehavior
	STDMETHOD(put_value)(VARIANT varValue);
	STDMETHOD(get_value)(VARIANT *pRetValue);
	STDMETHOD(put_property)(VARIANT varProperty);
	STDMETHOD(get_property)(VARIANT *pRetProperty);
    STDMETHOD(put_type)(VARIANT varType);
    STDMETHOD(get_type)(VARIANT *pRetType);
    STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:

    HRESULT ExtractColor(VARIANT, IDAColor **);
    HRESULT ExtractNumber(VARIANT, IDANumber **);

    static WCHAR                *m_rgPropNames[NUM_SET_PROPS]; 
    VARIANT                     m_varValue;
    VARIANT                     m_varProperty;
    VARIANT                     m_varType;

    long                        m_lCookie;
    IDispatch                   *m_pdispActor;
}; // CSetBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__SETBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\rotate.h ===
#pragma once
#ifndef __ROTATEBVR_H_
#define __ROTATEBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    RotateBvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    rotate behavior class definition
// Modifications:
// 10/07/98 jeffort created file
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#define NUM_ROTATE_PROPS 5
//*****************************************************************************

class ATL_NO_VTABLE CRotateBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRotateBvr, &CLSID_CrRotateBvr>,
    public IConnectionPointContainerImpl<CRotateBvr>,
    public IPropertyNotifySinkCP<CRotateBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrRotateBvr, &IID_ICrRotateBvr, &LIBID_ChromeBehavior>,
#else
	public IDispatchImpl<ICrRotateBvr, &IID_ICrRotateBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CRotateBvr)
	COM_INTERFACE_ENTRY(ICrRotateBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CRotateBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_ROTATEBVR)

	CRotateBvr();
    virtual ~CRotateBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrRotateBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrColorBehavior
	STDMETHOD(put_from)(VARIANT varFrom);
	STDMETHOD(get_from)(VARIANT *pRetFrom);
	STDMETHOD(put_to)(VARIANT varTo);
	STDMETHOD(get_to)(VARIANT *pRetTo);
	STDMETHOD(put_by)(VARIANT varBy);
	STDMETHOD(get_by)(VARIANT *pRetBy);
	STDMETHOD(put_type)(VARIANT varType);
	STDMETHOD(get_type)(VARIANT *pRetType);
	STDMETHOD(put_mode)(VARIANT varMode);
	STDMETHOD(get_mode)(VARIANT *pRetMode);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:

    HRESULT InitializeProperties();

    static WCHAR                *m_rgPropNames[NUM_ROTATE_PROPS]; 

    VARIANT                     m_varFrom;
    VARIANT                     m_varTo;
    VARIANT                     m_varBy;
	VARIANT						m_varType;
	VARIANT						m_varMode;

	IDispatch					*m_pdispActor;
	long						m_lCookie;

	HRESULT						RemoveFragment();
}; // CRotateBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__ROTATEBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\messages\usa\makefile.inc ===
crbvr.rc : $(TARGETPATH)\$(TARGET_DIRECTORY)\crbvr.tlb \
          crfactory.rgs \
		  crcolor.rgs		\
		  crrotate.rgs	\
		  crscale.rgs	\
		  crmove.rgs	\
		  crpath.rgs   \
		  craction.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\utils.h ===
#pragma once
#ifndef _UTILS_H_
#define _UTILS_H_

//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1997
//
// FileName:	    utils.h
//
// Created:	        10/07/98
//
// Author:	        jeffort
// 
// Abstract:	    shared utility functions
//
// Change History:
// 10/07/98 jeffort Created this file.
// 10/16/98 jeffort added InsurePropertyVariantAsFloat
// 11/17/98 kurtj   added ARRAY_SIZE
//
//*****************************************************************************


#pragma warning(disable:4002)
#define DPFINIT(h,s)
#define DPF()
#ifdef _DEBUG
#define DPF_ERR(x)\
{\
	char buffer[512];\
	int ret = sprintf( buffer, "%s file:%s line:%d\n", x, __FILE__, __LINE__ ); \
	DASSERT( ret < 512 ); \
	OutputDebugStringA( buffer );\
}
#else
#define DPF_ERR(x)
#endif
#define DPGUID(s,r)
#define DASSERT(condition)
#define DVERIFY(condition)   (condition)

#include "lmtrace.h"

//*****************************************************************************

#define LCID_ENGLISH MAKELCID(MAKELANGID(0x09, 0x01), SORT_DEFAULT)
//use English for all scripting
#define LCID_SCRIPTING 0x0409

//*****************************************************************************

#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))

//*****************************************************************************

#if (_M_IX86 >= 300) && defined(DEBUG)
  #define PSEUDORETURN(dw)    _asm { mov eax, dw }
#else
  #define PSEUDORETURN(dw)
#endif // not _M_IX86
//*****************************************************************************

#define CheckBitSet( pattern, bit ) ( ( pattern & bit ) != 0 )

//*****************************************************************************

#define CheckBitNotSet( pattern, bit ) ( ( pattern & bit ) == 0 )

//*****************************************************************************

#define SetBit( pattern, bit ) ( pattern |= bit )

//*****************************************************************************

#define ClearBit( pattern, bit ) ( pattern &= ~bit )

//*****************************************************************************
//
// ReleaseInterface calls 'Release' and NULLs the pointer
// The Release() return will be in eax for IA builds.
//
//*****************************************************************************
#define ReleaseInterface(p)\
{\
    ULONG cRef = 0u; \
    if (NULL != (p))\
    {\
        cRef = (p)->Release();\
        DASSERT((int)cRef>=0);\
        (p) = NULL;\
    }\
    PSEUDORETURN(cRef) \
} 

//*****************************************************************************

#define CheckHR( hr, msg, label )\
if( FAILED( hr ) )\
{\
	DPF_ERR(msg);\
	goto label;\
}

//*****************************************************************************

#define CheckPtr( pointer, hr, newHr, msg, label )\
if( pointer == NULL )\
{\
	DPF_ERR(msg);\
	hr = newHr;\
	goto label;\
}

//*****************************************************************************

#define ReturnIfArgNull( pointer )\
if( pointer == NULL )\
{\
	DPF_ERR("argument is null");\
	return E_INVALIDARG;\
}

//*****************************************************************************

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

//*****************************************************************************

class CUtils
{
public:
    static HRESULT InsurePropertyVariantAsBSTR(VARIANT *varValue);
    static HRESULT InsurePropertyVariantAsFloat(VARIANT *varFloat);
    static HRESULT InsurePropertyVariantAsBool(VARIANT *varFloat);
    static DWORD GetColorFromVariant(VARIANT *varColor);
    static void GetHSLValue(DWORD dwInputColor, 
						 float *pflHue, 
						 float *pflSaturation, 
						 float *pflLightness);
    static HRESULT GetVectorFromVariant(VARIANT *varVector,
                                        int *piFloatsReturned, 
                                        float *pflX = NULL, 
                                        float *pflY = NULL, 
                                        float *pflZ = NULL);
    static void SkipWhiteSpace(LPWSTR *ppwzString);

    static HRESULT ParseFloatValueFromString(LPWSTR *ppwzFloatString, 
                                             float *pflRet);
    static bool CompareForEqualFloat(float flComp1, float flComp2);

}; // CUtils

//************************************************************
//
// Inline methods
//
//************************************************************

inline void CUtils::SkipWhiteSpace(LPWSTR *ppwzString)
{
  while(iswspace(**ppwzString))
    (*ppwzString)++;
} // SkipWhiteSpace

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\sampler.h ===
//*****************************************************************************
//
// File:            sampler.h
// Author:          kurtj
// Date Created:    11/10/98
//
// Abstract: Abstracts the notion of sampling a behavior
//
//*****************************************************************************

#ifndef __SAMPLER_H
#define __SAMPLER_H

#include "lmrt.h"

// Definition of a pointer to a callback function
typedef HRESULT (*SampleCallback)(void *thisPtr,
								  long id,
								  double startTime,
								  double globalNow,
								  double localNow,
								  IDABehavior * sampleVal,
								  IDABehavior **ppReturn);

class CSampler :
    public IDABvrHook
{
public:
    //
    // IUnknown Interface
    //
    STDMETHOD(QueryInterface)( REFIID riid, void** ppv );
    STDMETHOD_(ULONG,  AddRef)();
    STDMETHOD_(ULONG, Release)();


    CSampler( ILMSample* target );
	CSampler( SampleCallback callback, void *thisPtr );
    ~CSampler();

    
    STDMETHOD(Invalidate)();
    STDMETHOD(Attach)( IDABehavior* bvrToHook, IDABehavior** result );

    //
    //IDABvrHook Interface
    //
    STDMETHOD(Notify)( LONG id,
                        VARIANT_BOOL startingPerformance,
                        double startTime,
                        double gTime,
                        double lTime,
                        IDABehavior * sampleVal,
                        IDABehavior * curRunningBvr,
                        IDABehavior ** ppBvr);
private:
    //weak ref.
    ILMSample* m_target;

	// callback function
	SampleCallback m_callback;

	// This ptr (uggh)
	void	*m_thisPtr;

    //refcount
    ULONG m_cRefs;

};
#endif // __SAMPLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\include\scale.h ===
#pragma once
#ifndef __SCALEBVR_H_
#define __SCALEBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    ScaleBvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    scale behavior class definition
// Modifications:
// 10/07/98 jeffort created file
// 10/21/98 jeffort brought closer to spec including 3D and percentage work
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#define NUM_SCALE_PROPS 5

//*****************************************************************************

class ATL_NO_VTABLE CScaleBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CScaleBvr, &CLSID_CrScaleBvr>,
    public IConnectionPointContainerImpl<CScaleBvr>,
    public IPropertyNotifySinkCP<CScaleBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrScaleBvr, &IID_ICrScaleBvr, &LIBID_ChromeBehavior>,
#else
	public IDispatchImpl<ICrScaleBvr, &IID_ICrScaleBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CScaleBvr)
	COM_INTERFACE_ENTRY(ICrScaleBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CScaleBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_SCALEBVR)

	CScaleBvr();
    virtual ~CScaleBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrScaleBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrColorBehavior
	STDMETHOD(put_from)(VARIANT varFrom);
	STDMETHOD(get_from)(VARIANT *pRetFrom);
	STDMETHOD(put_to)(VARIANT varTo);
	STDMETHOD(get_to)(VARIANT *pRetTo);
	STDMETHOD(put_by)(VARIANT varBy);
	STDMETHOD(get_by)(VARIANT *pRetBy);
	STDMETHOD(put_type)(VARIANT varType);
	STDMETHOD(get_type)(VARIANT *pRetType);
	STDMETHOD(put_mode)(VARIANT varMode);
	STDMETHOD(get_mode)(VARIANT *pRetMode);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(buildBehaviorFragments)(IDispatch *pActorDisp);
	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:

    HRESULT InitializeProperties();
    HRESULT GetScaleVectorValues(float  rgflFrom[3],
                                 float  rgflTo[3],
                                 int    *piNumValues,
								 bool	*prelative);
    HRESULT Build2DTransform(float  rgflFrom[3],
                             float  rgflTo[3],
                             IDATransform2 **ppbvrTransform);

	HRESULT GetScaleToTransform(IDispatch *pActorDisp, IDATransform2 **ppResult);

//    HRESULT Build3DTransform(float  rgflFrom[3],
//                             float  rgflTo[3],
//                             IDATransform3 **ppbvrTransform);
//    HRESULT Apply2DScaleBehaviorToAnimationElement(IDATransform2 *pbvrScale);

    static WCHAR                *m_rgPropNames[NUM_SCALE_PROPS]; 
    VARIANT                     m_varFrom;
    VARIANT                     m_varTo;
    VARIANT                     m_varBy;
	VARIANT						m_varType;
	VARIANT						m_varMode;

	long						m_lCookie;
	IDispatch					*m_pdispActor;
}; // CScaleBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__SCALEBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\action.cpp ===
//*****************************************************************************
//
// File:    setbvr.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CActionBvr object which implements
//			 the chromeffects Action.  Simple behavior that just forwards
//           buildBehaviorFragments calls to its children
//
// Modification List:
// Date		Author		Change
// 11-23-98	kurtj		Created this file
//*****************************************************************************

#include "headers.h"

#include "action.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CActionBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important


WCHAR * CActionBvr::m_rgPropNames[] = {NULL};

//*****************************************************************************

CActionBvr::CActionBvr() 
{
    m_clsid = CLSID_CrActionBvr;
} // CActionBvr

//*****************************************************************************

CActionBvr::~CActionBvr()
{
} // ~ActionBvr

//*****************************************************************************

HRESULT CActionBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in action behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CActionBvr::VariantFromIndex(ULONG iIndex)
{
	DASSERT(FALSE);
    return NULL;
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CActionBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_ACTION_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CActionBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CActionBvr::Notify(LONG event, VARIANT *pVar)
{
	return SUPER::Notify(event, pVar);
} // Notify

//*****************************************************************************

STDMETHODIMP
CActionBvr::Detach()
{
	return SUPER::Detach();
} // Detach 

//*****************************************************************************

HRESULT 
CActionBvr::BuildAnimationAsDABehavior()
{
	// TODO (markhal): This will go away when all behaviors have been converted
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CActionBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
	if( pActorDisp == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;

	hr = BuildChildren(pActorDisp);
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to build the children of an action");
	}

	return hr;
} //buildBehaviorFragments

//*****************************************************************************

HRESULT
CActionBvr::BuildChildren( IDispatch *pdispActor )
{
	if( pdispActor == NULL )
		return E_INVALIDARG;
	//cycle through out direct children calling buildAnimationFragments

	HRESULT hr = E_FAIL;
	
	IHTMLElement* pElem;
	pElem = GetHTMLElement( );
	if( pElem != NULL )
	{
		IDispatch *pChildrenDisp;
		hr = pElem->get_children( &pChildrenDisp );
		if( SUCCEEDED( hr ) )
		{
			IHTMLElementCollection *pChildrenCol;
			hr = pChildrenDisp->QueryInterface( IID_TO_PPV( IHTMLElementCollection, &pChildrenCol ) );
			ReleaseInterface( pChildrenDisp );
			if( SUCCEEDED( hr ) )
			{
				long length;

				hr = pChildrenCol->get_length(&length);
				if( SUCCEEDED( hr ) )
				{
					if( length != 0 )
					{
						VARIANT name;
						VARIANT index;
						VARIANT rgvarInput[1];

						IDispatch *pCurrentElem;
						
						VariantInit( &name );
						V_VT(&name) = VT_I4;

						VariantInit( &index );
						V_VT(&index) = VT_I4;
						V_I4(&index) = 0;

						VariantInit( &rgvarInput[0] );
						V_VT( &rgvarInput[0] ) = VT_DISPATCH;
						V_DISPATCH( &rgvarInput[0] ) = pdispActor;

						DISPPARAMS params;
						params.rgvarg				= rgvarInput;
						params.rgdispidNamedArgs	= NULL;
						params.cArgs				= 1;
						params.cNamedArgs			= 0;

						for(V_I4(&name) = 0; V_I4(&name) < length ; V_I4(&name)++ )
						{
							hr = pChildrenCol->item( name, index, &pCurrentElem );
							if( SUCCEEDED( hr ) )
							{
								CallBuildBehaviors( pCurrentElem, &params, NULL );
								ReleaseInterface( pCurrentElem );
							}
						}
					}
				}
				else //failed to get the length from the children collection
				{
					DPF_ERR("failed to get the length from the children collection");
				}
				ReleaseInterface( pChildrenCol );
			}
			else //failed to get IHTMLElementCollection from dispatch returned from elem->get_children
			{
				DPF_ERR("failed to get IHTMLElementCollection from dispatch returned from elem->get_children");
			}
		}
		else //failed to get the children collection from the actor element
		{
			DPF_ERR("failed to get the children collection from the actor element");
		}

	}
	else//failed to get the actor element
	{
		DPF_ERR("failed to get the actor element");
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActionBvr::CallBuildBehaviors( IDispatch *pDisp, DISPPARAMS *pParams, VARIANT* pResult)
{
	HRESULT hr = S_OK;

	DISPID dispid;

	WCHAR* wszBuildMethodName = L"buildBehaviorFragments";

	hr = pDisp->GetIDsOfNames( IID_NULL,
							   &wszBuildMethodName,
							   1,
							   LOCALE_SYSTEM_DEFAULT,
							   &dispid);
	if( SUCCEEDED( hr ) )
	{
		EXCEPINFO		excepInfo;
		UINT			nArgErr;
		hr = pDisp->Invoke( dispid,
							IID_NULL,
							LOCALE_SYSTEM_DEFAULT,
							DISPATCH_METHOD,
							pParams,
							pResult,
							&excepInfo,
							&nArgErr );
		if( FAILED( hr ) )
		{
			if( pResult != NULL )
				VariantClear( pResult );
		}

	}
	else//failed to get the id of "buildBehaviors" on pDisp
	{
		if( pResult != NULL )
			VariantClear( pResult );
	}


	return hr;
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\actorbvr.cpp ===
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:        actorbvr.cpp
//
// Author:          ColinMc
//
// Created:         10/15/98
//
// Abstract:        The CrIME Actor behavior.
//
// Modifications:
// 10/15/98 ColinMc Created this file
// 11/17/98 Kurtj	construction algorithm
// 11/18/98 kurtj   now animates the element to which it is attached
// 11/19/98 markhal Added CImageBvrTrack and CColorBvrTrack
//
//*****************************************************************************

#include "headers.h"

#include "actorbvr.h"
#include "attrib.h"
#include "dautil.h"


#undef THIS
#define THIS CActorBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_ANIMATES			0
#define VAR_SCALE				1
#define VAR_PIXELSCALE			2

#define INVALID_SAMPLE_TIME		-1.0

WCHAR * CActorBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_ANIMATES,
                                     BEHAVIOR_PROPERTY_SCALE,
									 BEHAVIOR_PROPERTY_PIXELSCALE
                                    };

CVarEmptyString CActorBvr::CBvrTrack::s_emptyString;

static const double	METERS_PER_INCH	= 0.0254;
static const double POINTS_PER_INCH = 72.0;
static const double POINTS_PER_PICA = 12.0;

// These are used to define the number of absolute fragments we can handle and
// the bit patterns we use in masking and indexing
#define MSK_INDEX_BITS	4		// Number of bits to be used as an index
#define MSK_FREE_BITS	28		// Number of bits free to be used for the mask
#define MSK_INDEX_MASK	0xf		// Mask used to give index
#define MSK_MAX_FRAGS	448		// Max number of fragments we can handle with this scheme

//bits that are used to describe which cookie values have been set in the actor

//for BvrTrack
#define ONBVR_COOKIESET			0x00000001

//for NumberBvrTrack
#define NUMBERBVR_COOKIESET		0x00000002

//for ColorBvrTrack
#define REDBVR_COOKIESET		0x00000002
#define GREENBVR_COOKIESET		0x00000004
#define BLUEBVR_COOKIESET		0x00000008


//for StringBvrTrack
#define STRINGBVR_COOKIESET		0x00000002

//These are used to create a bit pattern that gives us state on what
// tracks are dirty for a particular rebuild pass.

#define TRANSLATION_DIRTY	0x00000001
#define SCALE_DIRTY			0x00000002
#define ROTATION_DIRTY		0x00000004
#define TOP_DIRTY			0x00000008
#define LEFT_DIRTY			0x00000010
#define WIDTH_DIRTY			0x00000020
#define HEIGHT_DIRTY		0x00000040

//flags to determine the current state of the actor so that we don't
// have to talk to trident for every one.

#define PIXEL_SCALE_ON		0x00000001
#define STATIC_SCALE		0x00000002
#define STATIC_ROTATION		0x00000004
#define ELEM_IS_VML			0x00000008
#define FLOAT_ON			0x00000010

// Determines the smallest change in time that the timeline sampler will accept as a change
// in time.  This is to workaround a bogosity in TIME where a paused movie will cause tiny
// changes in time.  Why they couldn't do this on their side is beyond me.
#define MIN_TIMELINE_DIFF	0.00000001


//*****************************************************************************
// Unit conversion table
//*****************************************************************************

Ratio CActorBvr::s_unitConversion[5][5] = 
{
	{//from in
		{1,1}, //to in
		{254, 100}, //to cm
		{254, 10}, //to mm
		{72, 1}, //to pt
		{72, 12 }  //to pc
	},
	{//from cm
		{100, 254}, //to in
		{1, 1}, //to cm
		{10, 1}, //to mm
		{7200, 254}, //to pt
		{7200, 254*12}  //to pc
	},
	{//from mm
		{10, 254}, //to in
		{1, 10}, //to cm
		{1,1}, //to mm
		{720, 254}, //to pt
		{720, 254*12}  //to pc
	},
	{	//from pt
		{1, 72}, //to in
		{254, 7200}, //to cm
		{254, 720}, //to mm
		{1, 1}, //to pt
		{1, 12}  //to pc
	},
	{//from pc
		{12, 72}, //to in
		{254*12, 7200}, //to cm
		{254*12, 720}, //to mm
		{12, 1}, //to pt
		{1, 1}  //to pc
	},
};


//*****************************************************************************
//
// Table of useful information about ActorBvrType(s).
//
// Currently contains only a pointer to a function to instantiate a bvr track
// of the appropriate type.
//
//*****************************************************************************

typedef HRESULT (*CreateTrackInstance)(CActorBvr             *pbvrActor,
                                       BSTR                   bstrPropertyName,
                                       ActorBvrType           eType,
                                       CActorBvr::CBvrTrack **pptrackResult);

class CActorBvrType
{
public:
    ActorBvrType        m_eType;
    CreateTrackInstance m_fnCreate;
}; // CActorBvrType

static CActorBvrType
s_rgActorBvrTable[] =
{
    { e_Translation, &CActorBvr::CTransformBvrTrack::CreateInstance },
    { e_Rotation,    &CActorBvr::CTransformBvrTrack::CreateInstance },
    { e_Scale,       &CActorBvr::CTransformBvrTrack::CreateInstance },
    { e_Number,      &CActorBvr::CNumberBvrTrack::CreateInstance    },
	{ e_String,      &CActorBvr::CStringBvrTrack::CreateInstance    },
	{ e_Color,       &CActorBvr::CColorBvrTrack::CreateInstance     },
	{ e_Image,       &CActorBvr::CImageBvrTrack::CreateInstance		},
}; // s_rgActorBvrTable

const int s_cActorBvrTableEntries = (sizeof(s_rgActorBvrTable) / sizeof(CActorBvrType));


//*****************************************************************************
//
// class COnResizeHandler
//
//*****************************************************************************
COnResizeHandler::COnResizeHandler( CActorBvr* parent ):
	m_pActor( parent )
{
}

COnResizeHandler::~COnResizeHandler()
{
	m_pActor = NULL;
}

HRESULT
COnResizeHandler::HandleEvent()
{ 
	if( m_pActor!= NULL ) 
		return m_pActor->AnimatedElementOnResize(); 
	else 
		return S_OK;
}

//*****************************************************************************
//
// class COnUnloadHandler
//
//*****************************************************************************

COnUnloadHandler::COnUnloadHandler( CActorBvr *parent):
	m_pActor( parent )
{
}

COnUnloadHandler::~COnUnloadHandler()
{
	m_pActor = NULL;
}

HRESULT
COnUnloadHandler::HandleEvent()
{
	if( m_pActor != NULL )
		return m_pActor->OnWindowUnload();
	else
		return S_OK;
}

//*****************************************************************************
//
// class CBehaviorRebuild
//
//*****************************************************************************

CBehaviorRebuild::CBehaviorRebuild( IDispatch *pdispBehaviorElem )
{
	if( pdispBehaviorElem != NULL )
	{
		m_pdispBehaviorElem = pdispBehaviorElem;
		m_pdispBehaviorElem->AddRef();

		m_pdispBehaviorElem->QueryInterface( IID_TO_PPV( IUnknown, &m_punkBehaviorElem ) );
	}
	else
	{
		m_pdispBehaviorElem = NULL;
		m_punkBehaviorElem = NULL;
	}
}

//*****************************************************************************


CBehaviorRebuild::~CBehaviorRebuild()
{
	ReleaseInterface(m_pdispBehaviorElem);
	ReleaseInterface(m_punkBehaviorElem);
}

//*****************************************************************************

HRESULT
CBehaviorRebuild::RebuildBehavior( DISPPARAMS *pParams, VARIANT* pResult )
{
	if( pParams == NULL )
		return E_INVALIDARG;

	//it is legal to request a rebuild with null as the arg
	if( m_pdispBehaviorElem == NULL )
		return S_OK;

	//if they gave us a behavior disp to call through call through that,
	// otherwise call through the element

	HRESULT hr = S_OK;

//	IDispatch *pdispBehavior = NULL;

	DISPID dispid;

	WCHAR* wszBuildMethodName = L"buildBehaviorFragments";

/*
	IDispatch *pdispBehaviorElem = NULL;

	hr = m_pdispBehaviorElem->QueryInterface( IID_TO_PPV( IDispatch, &pdispBehaviorElem ) );
	CheckHR( hr, "", end );

	hr = CUtils::FindLMRTBehavior( pdispBehaviorElem, &pdispBehavior );
	ReleaseInterface( pdispBehaviorElem );
	CheckHR( hr, "Failed to get the lmrt behavior off of the element", end );

	hr = pdispBehavior->GetIDsOfNames( IID_NULL,
											 &wszBuildMethodName,
											 1,
											 LOCALE_SYSTEM_DEFAULT,
											 &dispid);

	CheckHR( hr, "Failed to find the id for buildBehaviorFragments on the dispatch", end );

	hr = pdispBehavior->Invoke( dispid,
									  IID_NULL,
									  LOCALE_SYSTEM_DEFAULT,
									  DISPATCH_METHOD,
									  pParams,
									  pResult,
									  NULL,
									  NULL );

	CheckHR( hr, "Failed to invoke buildBehaviorFragments on the behavior element", end );

*/
	hr = m_pdispBehaviorElem->GetIDsOfNames( IID_NULL,
											 &wszBuildMethodName,
											 1,
											 LOCALE_SYSTEM_DEFAULT,
											 &dispid);

	CheckHR( hr, "Failed to find the id for buildBehaviorFragments on the dispatch", end );

	

	hr = m_pdispBehaviorElem->Invoke( dispid,
									  IID_NULL,
									  LOCALE_SYSTEM_DEFAULT,
									  DISPATCH_METHOD,
									  pParams,
									  pResult,
									  NULL,
									  NULL );

	CheckHR( hr, "Failed to invoke buildBehaviorFragments on the behavior element", end );
		
end:

	//ReleaseInterface( pdispBehavior );
	if( FAILED( hr ) )
	{
		if( pResult != NULL )
			VariantClear( pResult );
	}

	return hr;

}

//*****************************************************************************
//
// class CBvrFragment
//
//*****************************************************************************

//*****************************************************************************

CActorBvr::CBvrTrack::CBvrFragment::CBvrFragment(ActorBvrFlags eFlags,
												 IDABehavior *pdabvrAction,
                                                 IDABoolean  *pdaboolActive,
												 IDANumber   *pdanumTimeline,
												 IDispatch	 *pdispBehaviorElement,
												 long		 lCookie)
{
    DASSERT(NULL != pdabvrAction);
    DASSERT(NULL != pdaboolActive);
	DASSERT(NULL != pdanumTimeline);
	DASSERT(pdispBehaviorElement != NULL);

	m_eFlags = eFlags;
    m_pdabvrAction  = pdabvrAction;
    m_pdabvrAction->AddRef();
    m_pdaboolActive = pdaboolActive;
    m_pdaboolActive->AddRef();
	m_pdanumTimeline = pdanumTimeline;
	m_pdanumTimeline->AddRef();
	HRESULT hr = pdispBehaviorElement->QueryInterface( IID_TO_PPV(IHTMLElement, &m_pelemBehaviorElement) );
	if( FAILED( hr ) )
	{
		DPF_ERR("QI for IHTMLElement on the dispatch of the element failed.  An invalid behavior fragment has been created." );
		m_pelemBehaviorElement = NULL;
	}
	m_pModifiableIntermediate = NULL;
	m_pModifiableFrom = NULL;

	m_lCookie = lCookie;
} // CBvrFragment

//*****************************************************************************

CActorBvr::CBvrTrack::CBvrFragment::~CBvrFragment()
{
    ReleaseInterface(m_pdabvrAction);
    ReleaseInterface(m_pdaboolActive);
	ReleaseInterface(m_pdanumTimeline);
	ReleaseInterface(m_pelemBehaviorElement);
	ReleaseInterface(m_pModifiableIntermediate);
	ReleaseInterface(m_pModifiableFrom);
} // ~CBvrFragment

//*****************************************************************************

/**
*  Returns a long that establishes a strict ordering for any list of behavior
*  fragments.  
*  Currently this method requires that no more that one behaviorFrag per 
*  vector (absolute or relative) per track comes from the same element.
*/
long
CActorBvr::CBvrTrack::CBvrFragment::GetOrderLong() const
{
	DASSERT( pelemBehaviorElement != NULL );
	
	long orderLong = -1;

	HRESULT hr = m_pelemBehaviorElement->get_sourceIndex( &orderLong );
	if( FAILED( hr ) )
	{
		DPF_ERR( "Failed to get the source index from a behavior fragment" );
	}

	return orderLong;
	
}

//*****************************************************************************

long
CActorBvr::CBvrTrack::CBvrFragment::GetCookie() const
{
	return m_lCookie;
}

//*****************************************************************************

CVarEmptyString::CVarEmptyString()
{
	VariantInit( &m_varEmptyString );
	V_VT(&m_varEmptyString) = VT_BSTR;
	V_BSTR(&m_varEmptyString) = SysAllocString( L"" );
}

//*****************************************************************************

CVarEmptyString::~CVarEmptyString()
{
	VariantClear( &m_varEmptyString );
}

//*****************************************************************************
//
// class CTimelineSampler
//
//*****************************************************************************

#define REQ_SAMPLE		0x1
#define REQ_OVERRIDE	0x2
#define REQ_OFF			0x4

CActorBvr::CTimelineSampler::CTimelineSampler(CBvrTrack *pTrack)
:	CSampler(TimelineCallback, (void*)this),
	m_pTrack(pTrack),
	m_currSampleTime(-1),
	m_prevSampleTime(-1),
	m_lastOnTime(-1),
	m_lastOffTime(-1),
	m_signDerivative(0),
	m_fRestarted( false )
{	
}

DWORD
CActorBvr::CTimelineSampler::RestartMask()
{
	// This is called to determine whether we think we have restarted,
	// either because of a loop or a beginEvent while we were running
	if (m_currSampleTime == -1 || m_prevSampleTime == -1)
	{
		// we're just starting up, assume we're not restarting
		// assume derivative is not negative yet
		return 0;
	}

	double diff = m_currSample - m_prevSample;

	if (diff > -MIN_TIMELINE_DIFF && diff < MIN_TIMELINE_DIFF)
		diff = 0;

	bool fRestarted = false;


	DWORD result = 0;

	if (diff < 0)
	{
		// Moving backward

		// Did we just start going backwards?  Does this mean we've autoreversed
		// or does it mean we've restarted?
		if (m_signDerivative != -1 && diff < -2*(m_currSampleTime - m_prevSampleTime))
		{
			LMTRACE2( 1, 2, "requested sample because of a big jump diff:%lg big: %lg\n", diff, -2*(m_currSampleTime - m_prevSampleTime) );
			// We detected a 'big jump' - request a sample and an override
			result = REQ_SAMPLE | REQ_OVERRIDE;

			fRestarted = true;
		}			
		
		m_signDerivative = -1;
	}
	else if (diff > 0)
	{
		// Moving forward
		if (m_signDerivative == -1 && !m_fRestarted )
		{
			LMTRACE2( 1, 2, "Requesting a sample because we bounced off the beginning of time\n" );
			// This is the 'bounce' condition where we bounce off the beginning time
			// Override and sample
			result = REQ_SAMPLE | REQ_OVERRIDE;
		}
		else if (m_signDerivative == 0 && m_lastOnTime != m_prevSampleTime)
		{
			LMTRACE2( 1, 2, "Requesting a sample because of a transition to endhold\n" );
			// This is a 'fudge' condition because the on boolean we get from DA
			// is messed up in autoReverse and endHold conditions, which means that
			// we miss the on transition.  This is an attempt to notice this by
			// seeing when we go from 0 derivative to positive derivative.  We try
			// not to do this when we sent an 'on' condition at the last sample
			result = REQ_SAMPLE | REQ_OVERRIDE;
		}

		m_signDerivative = 1;
	}
	else
	{
		m_signDerivative = 0;
	}

	m_fRestarted = fRestarted;

	return result;
}

void
CActorBvr::CTimelineSampler::TurnOn()
{
	m_lastOnTime = m_currSampleTime;
}

void
CActorBvr::CTimelineSampler::TurnOff()
{
	m_lastOffTime = m_currSampleTime;
}

HRESULT
CActorBvr::CTimelineSampler::TimelineCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	CTimelineSampler *pSampler = (CTimelineSampler*)thisPtr;

	if (pSampler == NULL)
		return E_FAIL;

	globalNow = pSampler->m_pTrack->Actor()->MapGlobalTime(globalNow);

	if (globalNow != pSampler->m_currSampleTime)
	{
		pSampler->m_prevSample = pSampler->m_currSample;
		pSampler->m_prevSampleTime = pSampler->m_currSampleTime;

		pSampler->m_currSample = value;
		pSampler->m_currSampleTime = globalNow;
	}

	return S_OK;
}

//*****************************************************************************
//
// class CBvrTrack
//
//*****************************************************************************

CActorBvr::CBvrTrack::CBvrTrack(CActorBvr    *pbvrActor,
                                ActorBvrType  eType)
:   m_pbvrActor(pbvrActor),
    m_eType(eType),
    m_bstrPropertyName(NULL),
	m_pNameComponents(NULL),
	m_cNumComponents(0),
	m_bStyleProp(false),
	m_pfragAbsListHead( NULL ),
	m_pfragRelListHead( NULL ),
    m_pdabvrFinal(NULL),
	m_bFinalComputed(false),
	m_bFinalExternallySet(false),
	m_pdabvrComposed(NULL),
	m_bComposedComputed(false),
	m_pModifiableStatic(NULL),
	m_pModifiableComposed(NULL),
	m_pModifiableFinal(NULL),
	m_pModifiableFrom(NULL),
	m_pModifiableIntermediate( NULL ),
    m_pNext(NULL),
	m_cFilters(0),
	m_bDoNotApply(false),
	m_pOnSampler( NULL ),
	m_varboolOn( VARIANT_FALSE ),
	m_pdaboolOn( NULL ),
	m_pIndexSampler(NULL),
	m_ppMaskSamplers(NULL),
	m_pCurrMasks(NULL),
	m_pNewMasks(NULL),
	m_ppTimelineSamplers(NULL),
	m_numIndices(0),
	m_numMasks(0),
	m_pIndex(NULL),
	m_currIndex(0),
	m_pIndexTimes(NULL),
	m_ppAccumBvrs(NULL),
    m_fOnSampled( false ),
	m_fValueSampled( false ),
	m_fValueChangedThisSample( false ),
	m_fForceValueChange( false ),
	m_dwAddedBehaviorFlags( 0 ),
	m_lOnCookie( 0 ),
	m_bDirty( false ),
	m_fApplied( false ),
	m_fChangesLockedOut(false),
	m_fSkipNextStaticUpdate( false ),
	m_lOnId( -1 ),
	m_lFirstIndexId( -1 ),
	m_bWasAnimated( false )
{
    DASSERT(NULL != pbvrActor);

    VariantInit( &m_varCurrentValue );
    VariantInit( &m_varStaticValue );

} // CBvrTrack

//*****************************************************************************

CActorBvr::CBvrTrack::~CBvrTrack()
{

	//detach this track from DA
	Detach();
	
    // Discard the property name
    ::SysFreeString(m_bstrPropertyName);

	// Discard name components
	if (m_pNameComponents != NULL)
	{
		for (int i=0; i<m_cNumComponents; i++)
			::SysFreeString(m_pNameComponents[i]);

		delete m_pNameComponents;
	}

	if( m_pOnSampler != NULL )
	{
		m_pOnSampler->Invalidate();
		m_pOnSampler = NULL;
	}

	if (m_pIndexSampler != NULL)
	{
		m_pIndexSampler->Invalidate();
		m_pIndexSampler = NULL;
	}

	if (m_ppMaskSamplers != NULL)
	{
		for (int i=0; i<m_numMasks; i++)
		{
			if (m_ppMaskSamplers[i] != NULL)
			{
				m_ppMaskSamplers[i]->Invalidate();
			}
		}
		delete[] m_ppMaskSamplers;
		m_ppMaskSamplers = NULL;
	}

	if (m_ppTimelineSamplers != NULL)
	{
		for (int i=0; i<m_numIndices; i++)
		{
			if (m_ppTimelineSamplers[i] != NULL)
			{
				m_ppTimelineSamplers[i]->Invalidate();
			}
		}
		delete[] m_ppTimelineSamplers;
		m_ppTimelineSamplers = NULL;
	}

	if (m_pCurrMasks != NULL)
	{
		delete[] m_pCurrMasks;
	}

	if (m_pNewMasks != NULL)
	{
		delete[] m_pNewMasks;
	}

	if (m_pIndexTimes != NULL)
	{
		delete[] m_pIndexTimes;
	}

	if (m_ppAccumBvrs != NULL)
	{
		for (int i=0; i<m_numIndices; i++)
			ReleaseInterface(m_ppAccumBvrs[i]);
		delete[] m_ppAccumBvrs;
		m_ppAccumBvrs = NULL;
	}

	VariantClear( &m_varCurrentValue );
	VariantClear( &m_varStaticValue );


	ReleaseAllFragments();

    ReleaseInterface(m_pdabvrFinal);
	ReleaseInterface(m_pdabvrComposed);
	ReleaseInterface(m_pModifiableStatic);
	ReleaseInterface(m_pModifiableComposed);
	ReleaseInterface(m_pModifiableFinal);
	ReleaseInterface(m_pModifiableFrom);
	ReleaseInterface(m_pdaboolOn);
	ReleaseInterface(m_pIndex);
	
} // ~CBvrTrack

//*****************************************************************************

bool
CActorBvr::CBvrTrack::ContainsFilter()
{
	// TODO (markhal): Rename this to absRelative?
	return (m_cFilters != 0);
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::BeginRebuild()
{
	//return S_FALSE if a rebuild was not required.
	if( !m_bDirty )
		return S_FALSE;

	HRESULT hr = S_OK;

	//detach all behaviors from time.
	Detach();

	//clean up state left by the last build of this track.
	CleanTrackState();

	//mark the track as clean
	m_bDirty = false;

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ForceRebuild()
{
	m_bDirty = true;

	return BeginRebuild();
}


//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::CleanTrackState()
{

	//reset all on/value state
	m_fOnSampled = false;
	m_fValueSampled = false;
	m_fValueChangedThisSample = false;
	m_fForceValueChange = false;
    //release the non switcher final
	m_bFinalComputed = false;
	m_bFinalExternallySet = false;
	ReleaseInterface( m_pdabvrFinal );

    //release the non switchabe composed bvr
	m_bComposedComputed = false;
	ReleaseInterface( m_pdabvrComposed );

	//release on sampling 
	if (m_pOnSampler != NULL )
	{
		m_pOnSampler->Invalidate();
		m_pOnSampler = NULL;
	}
	ReleaseInterface( m_pdaboolOn );

    //release the index sampler
	if( m_pIndexSampler != NULL )
	{
		m_pIndexSampler->Invalidate();
		m_pIndexSampler = NULL;
	}

    //release the index behavior
	ReleaseInterface( m_pIndex );
	m_lFirstIndexId = -1;

    //release the mask samplers if there are any
	if (m_ppMaskSamplers != NULL)
	{
		for (int i=0; i<m_numMasks; i++)
		{
			if (m_ppMaskSamplers[i] != NULL)
			{
				m_ppMaskSamplers[i]->Invalidate();
			}
		}
		delete[] m_ppMaskSamplers;
		m_ppMaskSamplers = NULL;
	}

    //release the index times
	delete[] m_pIndexTimes;
    m_pIndexTimes = NULL;

    //release the accumulated behaviors
	if (m_ppAccumBvrs != NULL)
	{
		for (int i=0; i<m_numIndices; i++)
			ReleaseInterface(m_ppAccumBvrs[i]);
		delete[] m_ppAccumBvrs;
		m_ppAccumBvrs = NULL;
	}

    //release the timeline samplers
	if (m_ppTimelineSamplers != NULL)
	{
		for (int i=0; i<m_numIndices; i++)
		{
			if (m_ppTimelineSamplers[i] != NULL)
			{
				m_ppTimelineSamplers[i]->Invalidate();
			}
		}
		delete[] m_ppTimelineSamplers;
		m_ppTimelineSamplers = NULL;
	}

	m_fApplied = false;

    //when the light is green the track is clean...

    return S_OK;
	
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::UninitBvr(IDABehavior **ppUninit)
{
	// This needs to be overridden
	return E_NOTIMPL;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ModifiableBvr( IDABehavior **ppModifiable )
{
	return E_NOTIMPL;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ModifiableBvr( IDABehavior *pdabvrInitialValue, IDABehavior **ppModifiable )
{
	return E_NOTIMPL;
}

//*****************************************************************************

// Compose all of the absolute behavior fragments into a single composite
// behavior based on the boolean active parameters.
//
// NOTE: The list is organized in ascending priority order (highest priority
// behavior at the tail of the list - lowest at the head).

HRESULT
CActorBvr::CBvrTrack::ComposeAbsBvrFragList(IDABehavior *pStatic, IDABehavior **ppdabvrComposite)
{
	HRESULT hr = S_OK;

    DASSERT(NULL != ppdabvrComposite);
    *ppdabvrComposite = NULL;

	// Count up the number of fragments
	int count =  0;
	CBvrFragment* pfragCurrent = m_pfragAbsListHead;
	while(pfragCurrent != NULL)
	{
		count++;
		pfragCurrent = pfragCurrent->m_pfragNext;
	}

	// Return static if there are no frags
	if (count == 0)
	{
		*ppdabvrComposite = pStatic;
		if (pStatic != NULL)
			pStatic->AddRef();
		return S_OK;
	}

	// Can only handle x of these :-)
	if (count > MSK_MAX_FRAGS)
		return E_FAIL;

	// Allocate count index times
	if (m_pIndexTimes != NULL)
		delete[] m_pIndexTimes;

	m_pIndexTimes = new double[count];
	if (m_pIndexTimes == NULL)
		return E_FAIL;

	for (int i=0; i<count; i++)
		m_pIndexTimes[i] = -1;

	//free the accumBvrs
	if (m_ppAccumBvrs != NULL)
	{
		for (int i=0; i<m_numIndices; i++)
			ReleaseInterface(m_ppAccumBvrs[i]);
		delete[] m_ppAccumBvrs;
		m_ppAccumBvrs = NULL;
	}
	

	// Allocate this many timeline samplers
	if (m_ppTimelineSamplers != NULL)
	{
		for( int curSampler = 0; curSampler < m_numIndices; curSampler++ )
		{
			if( m_ppTimelineSamplers[curSampler] != NULL )
				m_ppTimelineSamplers[curSampler]->Invalidate();
		}
		delete[] m_ppTimelineSamplers;
	}

	m_numIndices = count;


	m_ppTimelineSamplers = new CTimelineSampler*[m_numIndices];
	if (m_ppTimelineSamplers == NULL)
		return E_FAIL;

	for (i=0; i<m_numIndices; i++)
		m_ppTimelineSamplers[i] = NULL;

	// Allocate this number of curr and new masks and samplers
	if (m_ppMaskSamplers != NULL)
	{
		for( int curSampler = 0; curSampler < m_numMasks; curSampler++ )
		{
			if( m_ppMaskSamplers[curSampler] != NULL )
				m_ppMaskSamplers[curSampler]->Invalidate();
		}
		delete[] m_ppMaskSamplers;
	}

	// Figure out how many masks we'll need
	m_numMasks = ((m_numIndices-1) / MSK_FREE_BITS) + 1;


	m_ppMaskSamplers = new CSampler*[m_numMasks];
	if (m_ppMaskSamplers == NULL)
		return E_FAIL;

	for (i=0; i<m_numMasks; i++)
		m_ppMaskSamplers[i] = NULL;

	if (m_pCurrMasks != NULL)
		delete[] m_pCurrMasks;

	m_pCurrMasks = new DWORD[m_numMasks];
	if (m_pCurrMasks == NULL)
		return E_FAIL;

	if (m_pNewMasks != NULL)
		delete[] m_pNewMasks;

	m_pNewMasks = new DWORD[m_numMasks];
	if (m_pNewMasks == NULL)
		return E_FAIL;

	for (i=0; i<m_numMasks; i++)
	{
		m_pCurrMasks[i] = m_pNewMasks[i] = 0;
	}

	// Allocate count+1 bvrs
	// These things are released in the failure goto
	IDABehavior **ppBvrs = new IDABehavior*[count+1];
	IDANumber *pIndex = NULL;
	IDANumber *pLocalIndex = NULL;
	IDANumber *pLocalTimeline = NULL;
	IDANumber *pZero = NULL;
	IDABehavior *pTemp = NULL;
	IDANumber *pNumTemp = NULL;
	IDAArray *pArray = NULL;
	int multiplier = 1 << MSK_INDEX_BITS;
	int position = 1;
	int currIndex = 0;


	// NULL them out so we can do error recovery
	for (i=0; i<=count; i++)
		ppBvrs[i] = NULL;

	// Put static in slot 0
	if (pStatic != NULL)
	{
		ppBvrs[0] = pStatic;
		pStatic->AddRef();
	}
	else
	{
		// static is NULL, put in the identity
		hr = IdentityBvr(&(ppBvrs[0]));
		if (FAILED(hr))
		{
			ppBvrs[0] = NULL;
			goto failure;
		}
	}

	// Get zero number
	hr = Actor()->GetDAStatics()->DANumber(0, &pZero);
	if (FAILED(hr))
	{
		pZero = NULL;
		goto failure;
	}

	// Initialize local index with 0 
	pLocalIndex = pZero;
	pZero->AddRef();

	// Loop through other behaviors putting them in and making up a bit pattern from the
	// booleans
	pfragCurrent = m_pfragAbsListHead;
    while (pfragCurrent != NULL)
    {
        CBvrFragment* pfragNext = pfragCurrent->m_pfragNext;

		// Process the bvr
		IDABehavior *pProcessed = NULL;
		hr = ProcessBvr(pfragCurrent->m_pdabvrAction, pfragCurrent->m_eFlags, &pProcessed);
		if (FAILED(hr))
			goto failure;

		// Handle RelativeAccum and RelativeReset
		if (pfragCurrent->m_eFlags == e_Absolute)
		{
			if (pfragCurrent->m_pModifiableFrom != NULL)
			{
				// Initialize with static
				hr = pfragCurrent->m_pModifiableFrom->SwitchTo(ppBvrs[0]);
				if (FAILED(hr))
					goto failure;
			}
		}
		else if (pfragCurrent->m_eFlags == e_AbsoluteAccum)
		{
			if (pfragCurrent->m_pModifiableFrom != NULL)
			{
				// Initialize with sample

				// Allocate m_ppAccumBvrs if necessary, because we don't
				// always allocate it
				if (m_ppAccumBvrs == NULL)
				{
					m_ppAccumBvrs = new IDABehavior*[m_numIndices];
					if (m_ppAccumBvrs == NULL)
						goto failure;

					for (int i=0; i<m_numIndices; i++)
						m_ppAccumBvrs[i] = NULL;
				}

				// Create a modifiable behavior based on the static value
				hr = Actor()->GetDAStatics()->ModifiableBehavior(ppBvrs[0], &m_ppAccumBvrs[position-1]);
				if (FAILED(hr))
				{
					m_ppAccumBvrs[position-1] = NULL;
					goto failure;
				}

				hr = pfragCurrent->m_pModifiableFrom->SwitchTo(m_ppAccumBvrs[position-1]);
				if (FAILED(hr))
					goto failure;
			}
		}
		else if (pfragCurrent->m_eFlags == e_RelativeReset)
		{
			if (pfragCurrent->m_pModifiableFrom != NULL)
			{
				// Initialize with identity
				IDABehavior *pIdentity = NULL;
				hr = IdentityBvr(&pIdentity);
				if (FAILED(hr))
					goto failure;

				hr = pfragCurrent->m_pModifiableFrom->SwitchTo(pIdentity);
				ReleaseInterface(pIdentity);
				if (FAILED(hr))
					goto failure;
			}

			// In this case we simply compose the behavior with the static value
			hr = Compose(ppBvrs[0], pProcessed, &pTemp);
			ReleaseInterface(pProcessed);
			if (FAILED(hr))
				goto failure;
			pProcessed = pTemp;
			pTemp = NULL;
		}
		else if (pfragCurrent->m_eFlags == e_RelativeAccum)
		{
			// Allocate m_ppAccumBvrs if necessary, because we don't
			// always allocate it
			if (m_ppAccumBvrs == NULL)
			{
				m_ppAccumBvrs = new IDABehavior*[m_numIndices];
				if (m_ppAccumBvrs == NULL)
					goto failure;

				for (int i=0; i<m_numIndices; i++)
					m_ppAccumBvrs[i] = NULL;
			}

			// Create a modifiable behavior based on the static value
			hr = Actor()->GetDAStatics()->ModifiableBehavior(ppBvrs[0], &m_ppAccumBvrs[position-1]);
			if (FAILED(hr))
			{
				m_ppAccumBvrs[position-1] = NULL;
				goto failure;
			}

			if (pfragCurrent->m_pModifiableFrom != NULL)
			{
				// Initialize with accum-static and compose with static
				IDABehavior *pInverse = NULL;
				hr = InverseBvr(ppBvrs[0], &pInverse);
				if (FAILED(hr))
					goto failure;

				IDABehavior *pInitial = NULL;
				hr = Compose(m_ppAccumBvrs[position-1], pInverse, &pInitial);
				ReleaseInterface(pInverse);
				if (FAILED(hr))
					goto failure;

				hr = pfragCurrent->m_pModifiableFrom->SwitchTo(pInitial);
				ReleaseInterface(pInitial);
				if (FAILED(hr))
					goto failure;

				// Compose with static
				hr = Compose(ppBvrs[0], pProcessed, &pTemp);
				ReleaseInterface(pProcessed);
				if (FAILED(hr))
					goto failure;
				pProcessed = pTemp;
				pTemp = NULL;
			}
			else
			{
				// Compose with the modifiable
				hr = Compose(m_ppAccumBvrs[position-1], pProcessed, &pTemp);
				ReleaseInterface(pProcessed);
				if (FAILED(hr))
					goto failure;
				pProcessed = pTemp;
				pTemp = NULL;
			}
		}

		// Put it in the array
		ppBvrs[position] = pProcessed;
		pProcessed = NULL;

        // Build the boolean for on
        IDABehavior* pTemp = NULL;
		IDANumber *pNum = NULL;
		hr = Actor()->GetDAStatics()->DANumber(multiplier, &pNum);
		if (FAILED(hr))
			goto failure;

		/*
        hr = Actor()->GetDAStatics()->Cond(pfragCurrent->m_pdaboolActive,
                                           pNum,
                                           pZero,
                                           &pTemp);
        */
        hr = Actor()->SafeCond( Actor()->GetDAStatics(),
					   		   pfragCurrent->m_pdaboolActive,
        			   		   pNum,
        			   		   pZero,
        			   		   &pTemp );
        			   
		ReleaseInterface(pNum);
		if (FAILED(hr))
			goto failure;

		// Get the num back out and add it to the local index
		hr = pTemp->QueryInterface(IID_TO_PPV(IDANumber, &pNum));
		ReleaseInterface(pTemp);
		if (FAILED(hr))
			goto failure;

		if (pLocalIndex == NULL)
			pLocalIndex = pNum;
		else
		{
			IDANumber *pTotal = NULL;
			hr = Actor()->GetDAStatics()->Add(pLocalIndex, pNum, &pTotal);
			ReleaseInterface(pNum);
			ReleaseInterface(pLocalIndex);
			if (FAILED(hr))
				goto failure;
			pLocalIndex = pTotal;
		}

		// Sample the timeline
		m_ppTimelineSamplers[position-1] = new CTimelineSampler(this);
		if (m_ppTimelineSamplers[position-1] == NULL)
			goto failure;

		hr = m_ppTimelineSamplers[position-1]->Attach(pfragCurrent->m_pdanumTimeline, &pTemp);
		if (FAILED(hr))
			goto failure;

		hr = pTemp->QueryInterface(IID_TO_PPV(IDANumber, &pNum));
		ReleaseInterface(pTemp);
		if (FAILED(hr))
			goto failure;

		if (pLocalTimeline == NULL)
			pLocalTimeline = pNum;
		else
		{
			IDANumber *pTotal = NULL;
			hr = Actor()->GetDAStatics()->Add(pLocalTimeline, pNum, &pTotal);
			ReleaseInterface(pNum);
			ReleaseInterface(pLocalTimeline);
			if (FAILED(hr))
				goto failure;
			pLocalTimeline = pTotal;
		}

		pfragCurrent = pfragNext;

		if ((position % MSK_FREE_BITS) != 0 && pfragCurrent != NULL)
		{
			// Normal case - step to next position/bit
			position++;
			multiplier *= 2;
		}
		else
		{
			// We've used up all our free bits or fragments.
			// We sample local forward and local index

			// Create a sampler for local forward
			m_ppMaskSamplers[currIndex] = new CSampler(MaskCallback, (void*)this);
			if (m_ppMaskSamplers[currIndex] == NULL)
				goto failure;

			hr = m_ppMaskSamplers[currIndex]->Attach(pLocalIndex, &pTemp);
			ReleaseInterface(pLocalIndex);
			if (FAILED(hr))
				goto failure;

			hr = pTemp->QueryInterface(IID_TO_PPV(IDANumber, &pLocalIndex));
			ReleaseInterface(pTemp);
			if (FAILED(hr))
				goto failure;

			// Subtract pLocalTimeline from pLocalIndex.  Add to pIndex
			hr = Actor()->GetDAStatics()->Sub(pLocalIndex, pLocalTimeline, &pNumTemp);
			ReleaseInterface(pLocalTimeline);
			ReleaseInterface(pLocalIndex);
			if (FAILED(hr))
				goto failure;

			if (pIndex == NULL)
			{
				pIndex = pNumTemp;
			}
			else
			{
				hr = Actor()->GetDAStatics()->Add(pIndex, pNumTemp, &pLocalIndex);
				ReleaseInterface(pIndex);
				ReleaseInterface(pNumTemp);
				if (FAILED(hr))
					goto failure;
				pIndex = pLocalIndex;
				pLocalIndex = NULL;
			}

			if (pfragCurrent != NULL)
			{
				// Set up for next time around the loop
				currIndex++;
				position++;
				multiplier = 1 << MSK_INDEX_BITS;

				hr = Actor()->GetDAStatics()->DANumber(currIndex, &pLocalIndex);
				if (FAILED(hr))
					goto failure;
			}
		}
	}

	// Sample the index behavior
	m_pIndexSampler = new CSampler(IndexCallback, (void*)this);
	if (m_pIndexSampler == NULL)
		goto failure;

	hr = m_pIndexSampler->Attach(pIndex, &pTemp);
	ReleaseInterface(pIndex);
	if (FAILED(hr))
		goto failure;
	
	hr = pTemp->QueryInterface(IID_TO_PPV(IDANumber, &pIndex));
	ReleaseInterface(pTemp);
	if (FAILED(hr))
		goto failure;

	// Create an array of bvrs
	hr = Actor()->GetDAStatics()->DAArrayEx(count+1, ppBvrs, &pArray);
	if (FAILED(hr))
		goto failure;

	// Index into it
	IDABehavior *pResult;
	hr = pArray->NthAnim(pIndex, &pResult);
	ReleaseInterface(pIndex);
	ReleaseInterface(pArray);
	if (FAILED(hr))
		goto failure;

	if (m_ppAccumBvrs != NULL)
	{
		// We need to hook the result
		hr = HookAccumBvr(pResult, &pTemp);
		ReleaseInterface(pResult);
		if (FAILED(hr))
			goto failure;

		pResult = pTemp;
		pTemp = NULL;
	}

	*ppdabvrComposite = pResult;
	pResult = NULL;

    hr = S_OK;

failure:
	// Need to release all the entries in the array
	for (i=0; i<=count; i++)
		ReleaseInterface(ppBvrs[i]);

	delete[] ppBvrs;

	ReleaseInterface(pIndex);
	ReleaseInterface(pLocalIndex);
	ReleaseInterface(pLocalTimeline);
	ReleaseInterface(pZero);

	return hr;
} // ComposeAbsBvrFragList

HRESULT
CActorBvr::CBvrTrack::ComputeIndex(long id, double currTime, IDABehavior **ppReturn)
{
	DWORD changedMask;
	DWORD onMask;
	int newIndex;

	if( m_lFirstIndexId == -1 )
		m_lFirstIndexId = id;

	if ( m_lFirstIndexId != id )
	{
		newIndex = m_currIndex;
	}
	else
	{


		int currMask = -1;
		int maxPos = -1;
		double max = -1;
		for (int i=0; i<m_numIndices; i++)
		{
			if (i % MSK_FREE_BITS == 0)
			{
				// We've switched to a new set of masks
				currMask++;

				// Figure out who has changed on/off
				changedMask = m_pNewMasks[currMask] ^ m_pCurrMasks[currMask];
				m_pCurrMasks[currMask] = m_pNewMasks[currMask];

				onMask = m_pNewMasks[currMask];
			}

			// Figure out whether we should resample and/or override
			DWORD sampleOverrideMask = m_ppTimelineSamplers[i]->RestartMask();

			if ((changedMask & 0x1) != 0 || sampleOverrideMask != 0)
			{
				// This index either turned on/off or restarted
				if ((onMask & 0x1) == 0)
				{
					// This index is off now
					m_pIndexTimes[i] = -1;

					// Tell the sampler that we've turned off
					m_ppTimelineSamplers[i]->TurnOff();
				}
				else if ((sampleOverrideMask & REQ_OFF) != 0)
				{
					// This is a special 'fudge' condition that occurs when
					// the boolean is incorrect and we need to estimate when we turned off
					m_pIndexTimes[i] = -1;
				}
				else
				{
					if ((changedMask & 0x1) != 0)
					{
						LMTRACE2( 1, 2, "Requesting sample because we turned on" );
						// We turned on, always want to sample and override
						sampleOverrideMask = REQ_SAMPLE | REQ_OVERRIDE;

						// Tell the sampler that we've turned on so it can record the time
						m_ppTimelineSamplers[i]->TurnOn();
					}

					if ((sampleOverrideMask & REQ_OVERRIDE) != 0)
					{
						// Need to override others
						m_pIndexTimes[i] = currTime;
					}

					// Do we need to resample?
					if ((sampleOverrideMask & REQ_SAMPLE) != 0 &&
						m_ppAccumBvrs != NULL &&
						m_ppAccumBvrs[i] != NULL)
					{
						SwitchAccum(m_ppAccumBvrs[i]);
					}
				}
			}

			// Check if we got a new max
			if (m_pIndexTimes[i] >= max)
			{
				max = m_pIndexTimes[i];
				maxPos = i;
			}

			changedMask >>= 1;
			onMask >>= 1;
		}

		if (max == -1)
		{
			// Nothing is on, just use 0
			newIndex = 0;
		}
		else
		{
			// Something was on, the index we want to return is maxPos+1,
			// since we have the static in pos 0 of the array
			newIndex = maxPos+1;
		}
	}

	if (m_currIndex != newIndex || m_pIndex == NULL)
	{
		LMTRACE2( 1, 2, "Index changed! %d->%d\n", m_currIndex, newIndex );
		m_currIndex = newIndex;

		ReleaseInterface(m_pIndex);

		HRESULT hr = Actor()->GetDAStatics()->DANumber(newIndex, &m_pIndex);
		if (FAILED(hr))
			return hr;
	}

	*ppReturn = m_pIndex;
	m_pIndex->AddRef();

	return S_OK;
}

HRESULT
CActorBvr::CBvrTrack::IndexCallback(void* thisPtr,
						long id,
						double startTime,
						double globalNow,
						double localNow,
						IDABehavior* sampleVal,
						IDABehavior **ppReturn)
{

	CBvrTrack *pTrack = reinterpret_cast<CBvrTrack*>(thisPtr);

	if( pTrack == NULL )
		return E_FAIL;

	globalNow = pTrack->Actor()->MapGlobalTime(globalNow);

	pTrack->ComputeIndex(id, globalNow, ppReturn);

	return S_OK;
}

HRESULT
CActorBvr::CBvrTrack::MaskCallback(void* thisPtr,
						long id,
						double startTime,
						double globalNow,
						double localNow,
						IDABehavior* sampleVal,
						IDABehavior **ppReturn)
{
	CBvrTrack *pTrack = reinterpret_cast<CBvrTrack*>(thisPtr);

	if( pTrack == NULL || sampleVal == NULL )
		return E_INVALIDARG;

	HRESULT hr;

	// Extract the sampled value
	IDANumber *pSample = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pSample));
	if (FAILED(hr))
		return hr;

	double val = 0;
	hr = pSample->Extract(&val);
	ReleaseInterface(pSample);
	if (FAILED(hr))
		return hr;

	// Cast it to a DWORD
	DWORD mask = (DWORD)val;

	// Figure out which index to put it into
	int index = mask & MSK_INDEX_MASK;

	// Figure out what the real mask is
	mask >>= MSK_INDEX_BITS;

	// Stick it into the array
	if (index < pTrack->m_numMasks)
		pTrack->m_pNewMasks[index] = mask;

	return S_OK;
}

HRESULT
CActorBvr::CBvrTrack::SwitchAccum(IDABehavior *pModifiable)
{
	// Base implementation does nothing
	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::Detach()
{
	HRESULT hr = S_OK;

	hr = RemoveBehaviorFromTIME( m_lOnCookie, ONBVR_COOKIESET );
	m_lOnId = -1;
    
	return hr;
	
}

//*****************************************************************************
//  changes the current value of the static property as this track sees it.

HRESULT
CActorBvr::CBvrTrack::PutStatic( VARIANT *pvarNewStatic )
{

	if( pvarNewStatic == NULL )
		return E_INVALIDARG;
	//TODO: do we want to update the value on the element itself here?
	HRESULT hr = S_OK;

	IDABehavior *pdabvrStatic = NULL;

	//we have to change the static to a string here, since some attributes, event
	// though they return non strings when you get them, dont like it when you 
	// set that same non string back into them. ( i.e. color properties on VML )
	hr = VariantChangeTypeEx( &m_varStaticValue, pvarNewStatic, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR );
	CheckHR( hr, "Failed to change the passed static to a string", end );
	
	/*
	//copy the value of the variant into our internal variant
	hr = VariantCopy( &m_varStaticValue, pvarNewStatic );
	CheckHR( hr, "Failed to copy the new static value into the track", end );
	*/

	//convert the variant into a da behavior of the correct type for this track
	hr = DABvrFromVariant( pvarNewStatic, &pdabvrStatic );
	CheckHR( hr, "Failed to create a DA Behavior for the variant", end );

	//if the switchable static value has not yet been created
	if( m_pModifiableStatic == NULL )
	{
		//create it.
		hr = Actor()->GetDAStatics()->ModifiableBehavior( pdabvrStatic, &m_pModifiableStatic );

		if( FAILED( hr ) )
		{
			LMTRACE2(1, 1000, "Failure to create modifiable behavior for %S\n", m_bstrPropertyName );
		}

		CheckHR( hr, "Failed to create a modifiable behavior for the static", end );
	}
	else
	{
		//switch the new value into the static behavior.
		hr = m_pModifiableStatic->SwitchTo( pdabvrStatic );
		CheckHR( hr, "Failed to switch in new static bvr", end );
	}

end:
	ReleaseInterface( pdabvrStatic );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::SkipNextStaticUpdate()
{
	m_fSkipNextStaticUpdate = true;

	return S_OK;
}


//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::GetStatic( VARIANT *pvarStatic )
{
	if( pvarStatic == NULL )
		return E_INVALIDARG;
		
	HRESULT hr = S_OK;

	hr = VariantCopy( pvarStatic, &m_varStaticValue );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::GetDynamic( VARIANT *pvarDynamic )
{

	if( pvarDynamic == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	hr = VariantCopy( pvarDynamic, &m_varCurrentValue );

	return hr;
	
}


//*****************************************************************************
// subclasses should convert the variant into the proper type of DA Behavior and
//   return that as ppdabvr.

HRESULT
CActorBvr::CBvrTrack::DABvrFromVariant( VARIANT *pvarVariant, IDABehavior **ppdabvr )
{
	return E_NOTIMPL;
}

//*****************************************************************************


HRESULT
CActorBvr::CBvrTrack::AcquireChangeLockout()
{
	LMTRACE2(1, 1000, L"Change lockout for track %s acquired\n", m_bstrPropertyName );
	m_fChangesLockedOut = true;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ReleaseChangeLockout()
{
	LMTRACE2( 1, 1000, L"Change lockout for track %s released\n", m_bstrPropertyName );
	m_fChangesLockedOut = false;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ApplyStatic()
{
	HRESULT hr = S_OK;
	
	if( m_bStyleProp )
	{
		//remove the settings in the runtime style
		hr = SetPropFromVariant( const_cast<VARIANT*>(s_emptyString.GetVar()));
	}
	else
	{
		//set back the static value into the property
		hr = SetPropFromVariant( &m_varStaticValue );
	}

	return hr;
}

//*****************************************************************************


HRESULT
CActorBvr::CBvrTrack::ApplyDynamic()
{
	HRESULT hr;

	hr = SetPropFromVariant( &m_varCurrentValue );

	return hr;
}

//*****************************************************************************

// Compose all of the relative behavior fragments into a single composite
// behavior based on the boolean active parameters.
//
// NOTE: The list is organized in ascending priority order (highest priority
// behavior at the tail of the list - lowest at the head).
HRESULT
CActorBvr::CBvrTrack::ComposeRelBvrFragList(IDABehavior *pAbsolute, IDABehavior **ppdabvrComposite)
{
    DASSERT(NULL != ppdabvrComposite);
    *ppdabvrComposite = NULL;

    // Compute the identity for this track.
    IDABehavior* pIdentity = NULL;
    HRESULT hr = IdentityBvr(&pIdentity);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to create the identity behavior for this track type");
        return hr;
    }

	// This is the composite. pAbsolute might be NULL
	IDABehavior *pComposite = pAbsolute;
	if (pComposite != NULL)
		pComposite->AddRef();

	//init the head intermediate with the absolute value.
	if( m_pfragRelListHead != NULL && 
		m_pfragRelListHead->m_pModifiableIntermediate != NULL )
	{
		//process the absolute behavior
		IDABehavior *pInitWith;
        hr = ProcessIntermediate( pAbsolute, m_pfragRelListHead->m_eFlags, &pInitWith );
        if( FAILED(hr) )
        {
			DPF_ERR("Failed to process intermediate");
			return hr;
        }

		//switch in the intermediate value for the first fragment
		hr = m_pfragRelListHead->m_pModifiableIntermediate->SwitchTo(pInitWith);
        ReleaseInterface( pInitWith );
		if (FAILED(hr))
		{
			DPF_ERR("Failed to initialize intermediate");
			return hr;
		}
	}

	CBvrFragment* pfragCurrent = m_pfragRelListHead;

    while (pfragCurrent != NULL)
    {
		CBvrFragment* pfragNext = pfragCurrent->m_pfragNext;

        // Build a behavior which consists of the identity
        // behavior when the boolean is not active and the fragment
		// behavior when it is.
        IDABehavior* pTemp1 = NULL;
		IDABehavior* pTemp2 = NULL;

		// Process the bvr
		IDABehavior *pProcessed = NULL;
		hr = ProcessBvr(pfragCurrent->m_pdabvrAction, pfragCurrent->m_eFlags, &pProcessed);
		if (FAILED(hr))
		{
			ReleaseInterface(pComposite);
			ReleaseInterface(pIdentity);
			return hr;
		}

		if (pfragCurrent->m_eFlags == e_Filter)
		{
			// if pComposite it still NULL, make it the identity
			if (pComposite == NULL)
			{
				hr = IdentityBvr(&pComposite);
				if (FAILED(hr))
				{
					DPF_ERR("Failed to get identity");
					ReleaseInterface(pIdentity);
					return hr;
				}
			}

			// Filters are like absolute things in the middle of a relative list
			/*
			hr = Actor()->GetDAStatics()->Cond(pfragCurrent->m_pdaboolActive,
											   pProcessed,
											   pComposite,
											   &pTemp1);
			*/
			
			hr = Actor()->SafeCond( Actor()->GetDAStatics(),
								   pfragCurrent->m_pdaboolActive,
								   pProcessed,
								   pComposite,
								   &pTemp1 );
								   
			ReleaseInterface(pProcessed);
			ReleaseInterface(pComposite);
			if (FAILED(hr))
			{
				ReleaseInterface(pIdentity);
				DPF_ERR("Failed to create conditional");
				return hr;
			}
			
			pComposite = pTemp1;
			/*
			ReleaseInterface(pComposite );
			pComposite = pProcessed;
			*/
		}
		else
		{

			/*
			hr = Actor()->GetDAStatics()->Cond(pfragCurrent->m_pdaboolActive,
											   pProcessed,
											   pIdentity,
											   &pTemp1);
			*/
			hr = Actor()->SafeCond( Actor()->GetDAStatics(),
					   			   pfragCurrent->m_pdaboolActive,
					   			   pProcessed,
					   			   pIdentity,
					   			   &pTemp1 );
			ReleaseInterface(pProcessed);
			if (FAILED(hr))
			{
				ReleaseInterface(pComposite);
				ReleaseInterface(pIdentity);
				DPF_ERR("Failed to create conditional");
				return hr;
			}

			if (pComposite == NULL)
			{
				// No composite just yet
				pComposite = pTemp1;
				pTemp1 = NULL;
			}
			else
			{
				// Compose this conditional with the existing composite
				HRESULT hr = Compose(pTemp1,
									 pComposite,
									 &pTemp2);
				ReleaseInterface(pTemp1);
				ReleaseInterface(pComposite);
				if (FAILED(hr))
				{
					ReleaseInterface(pComposite);
					ReleaseInterface(pIdentity);
					DPF_ERR("Failed to compose");
					return hr;
				}
				pComposite = pTemp2;
				pTemp2 = NULL;
			}
		}

		// If there is a modifiable intermediate on the next fragment, switch it now
		if (pfragNext != NULL && pfragNext->m_pModifiableIntermediate != NULL)
		{
            IDABehavior *pInitWith;
            hr = ProcessIntermediate( pComposite, pfragNext->m_eFlags, &pInitWith );
            if( FAILED(hr) )
            {
                ReleaseInterface(pComposite);
				ReleaseInterface(pIdentity);
				DPF_ERR("Failed to process intermediate");
				return hr;
            }

			hr = pfragNext->m_pModifiableIntermediate->SwitchTo(pInitWith);
            ReleaseInterface( pInitWith );
			if (FAILED(hr))
			{
				ReleaseInterface(pComposite);
				ReleaseInterface(pIdentity);
				DPF_ERR("Failed to initialize intermediate");
				return hr;
			}
		}

		pfragCurrent = pfragNext;

    }

	ReleaseInterface(pIdentity);

    *ppdabvrComposite = pComposite;

    return S_OK;
} // ComposeRelBvrFragList

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ProcessBvr(IDABehavior *pOriginal,
								 ActorBvrFlags eFlags,
								 IDABehavior **ppResult)
{
	// Default implementation does no processing
	DASSERT(ppResult != NULL);

	*ppResult = pOriginal;
	pOriginal->AddRef();

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ProcessIntermediate( IDABehavior *pOriginal,
                                           ActorBvrFlags eFlags,
								           IDABehavior **ppResult )
{
    if( ppResult == NULL )
        return E_INVALIDARG;

    *ppResult = pOriginal;
    pOriginal->AddRef();

    return S_OK;
}

//*****************************************************************************


HRESULT
CActorBvr::CBvrTrack::GetTrackOn(IDABoolean **ppdaboolTrackOn)
{
	if( ppdaboolTrackOn == NULL )
		return E_INVALIDARG;

	if( m_pdaboolOn != NULL )
	{
		m_pdaboolOn->AddRef();
		(*ppdaboolTrackOn) = m_pdaboolOn;
		return S_OK;
	}

	HRESULT hr = E_FAIL;

	IDABoolean *pdaboolComposite = NULL;

    CBvrFragment* pfragCurrent = m_pfragAbsListHead;

	if( pfragCurrent != NULL )
	{
		pdaboolComposite = pfragCurrent->m_pdaboolActive;
		pfragCurrent->m_pdaboolActive->AddRef();
		pfragCurrent = pfragCurrent->m_pfragNext;
	}

	CBvrFragment *pfragNext = NULL;
    while( pfragCurrent != NULL )
    {
		pfragNext = pfragCurrent->m_pfragNext;
        
		IDABoolean *pdaboolTemp;
        hr = Actor()->GetDAStatics()->Or( pfragCurrent->m_pdaboolActive, pdaboolComposite, &pdaboolTemp );
        ReleaseInterface(pdaboolComposite);

        if (FAILED(hr))
        {
            DPF_ERR("Failed to or active booleans");
            return hr;
        }
        // Replace the current composite behavior with the newely computed
        // one.
        pdaboolComposite = pdaboolTemp;

		pfragCurrent = pfragNext;
    }

	pfragCurrent = m_pfragRelListHead;

	if( pdaboolComposite == NULL && pfragCurrent != NULL )
	{
		pdaboolComposite = pfragCurrent->m_pdaboolActive;
		pdaboolComposite->AddRef();
		pfragCurrent = pfragCurrent->m_pfragNext;
	}

    while( pfragCurrent != NULL )
    {
		pfragNext = pfragCurrent->m_pfragNext;
		
		IDABoolean *pdaboolTemp;
        hr = Actor()->GetDAStatics()->Or( pfragCurrent->m_pdaboolActive, pdaboolComposite, &pdaboolTemp );
        ReleaseInterface(pdaboolComposite);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to or active booleans");
            return hr;
        }
        // Replace the current composite behavior with the newely computed
        // one.
        pdaboolComposite = pdaboolTemp;

		pfragCurrent = pfragNext;
    }

	m_pdaboolOn = pdaboolComposite;
	if( m_pdaboolOn != NULL )
		m_pdaboolOn->AddRef();
    *ppdaboolTrackOn = pdaboolComposite;

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::OrWithOnBvr( IDABoolean *pdaboolToOr )
{
	if( pdaboolToOr == NULL )
		return S_OK;

	HRESULT hr = E_FAIL;
	
	IDABoolean *pdaboolCurrentOn;

	hr = GetTrackOn( &pdaboolCurrentOn );
	CheckHR( hr, "Failed to get the Track on", cleanup );

	if( pdaboolCurrentOn == NULL )
	{
		m_pdaboolOn = pdaboolToOr;
		m_pdaboolOn->AddRef();
		return S_OK;
	}

	IDABoolean *pdaboolNewOn;
	hr = Actor()->GetDAStatics()->Or( pdaboolCurrentOn, pdaboolToOr, &pdaboolNewOn );
	ReleaseInterface( pdaboolCurrentOn );
	CheckHR( hr, "Failed to or the passed booleanbvr with the current one", cleanup );

	ReleaseInterface( m_pdaboolOn );
	m_pdaboolOn = pdaboolNewOn;

cleanup:
	return hr;
}

//*****************************************************************************

void
CActorBvr::CBvrTrack::ReleaseAllFragments()
{
	CBvrFragment *pfragCurrent = m_pfragAbsListHead;
	CBvrFragment *pfragNext = NULL;
	
	while( pfragCurrent != NULL )
	{
		pfragNext = pfragCurrent->m_pfragNext;
		delete pfragCurrent;
		pfragCurrent = pfragNext;
	}

	pfragCurrent = m_pfragRelListHead;

	while( pfragCurrent != NULL )
	{
		pfragNext = pfragCurrent->m_pfragNext;
		delete pfragCurrent;
		pfragCurrent = pfragNext;
	}

	m_pfragAbsListHead = NULL;

	m_pfragRelListHead = NULL;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ComputeComposedBvr(IDABehavior *pStatic, bool fStaticSetExternally )
{
    // If there is an existing final behavior blow it away.
    ReleaseInterface(m_pdabvrComposed);

	HRESULT hr = S_OK;

	// If there is an uninitialized static, initialize it now
	if (m_pModifiableStatic != NULL && fStaticSetExternally )
	{
		if (pStatic == NULL)
		{
			// Need to set static to the identity
			hr = IdentityBvr(&pStatic);
			if (FAILED(hr))
			{
				DPF_ERR("Failed to compute static");
				return hr;
			}
		}

		hr = m_pModifiableStatic->SwitchTo(pStatic);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to initialize static uninit");
			return hr;
		}
	}

    // Build the composite absolute behaviors, passing in the static value

    IDABehavior* pAbsolute = NULL;
    hr = ComposeAbsBvrFragList(pStatic, &pAbsolute);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to compose the absolute behaviors");
        return hr;
    }


    // Build the composite relative behaviors onto the absolute
    hr = ComposeRelBvrFragList(pAbsolute, &m_pdabvrComposed);
	ReleaseInterface(pAbsolute);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to compose the relative behaviors");
		m_pdabvrFinal = NULL;
        return hr;
    }	

	if (m_pModifiableComposed != NULL)
	{
		hr = m_pModifiableComposed->SwitchTo(m_pdabvrComposed);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to initialize composed uninit");
			return hr;
		}
	}
	
	m_bComposedComputed = true;

    return S_OK;
}

//*****************************************************************************

/**
* Get composed bvr using the given static value
*/
HRESULT
CActorBvr::CBvrTrack::GetComposedBvr(IDABehavior *pStatic, IDABehavior **ppComposite, bool fStaticSetExternally)
{
	DASSERT(ppComposite != NULL);
	*ppComposite = NULL;

    // If we haven't got a composed behavior yet then generate one now.
    if (!m_bComposedComputed || m_bDirty)
    {
		// Compute the composed behavior

        HRESULT hr = ComputeComposedBvr(pStatic, fStaticSetExternally);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to compute composed behavior");
            return hr;
        }
        
    }

	if (m_pdabvrComposed != NULL)
		m_pdabvrComposed->AddRef();
    *ppComposite = m_pdabvrComposed;

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::GetComposedBvr(IDABehavior *pStatic, IDABehavior **ppComposite)
{
	return GetComposedBvr( pStatic, ppComposite, true );
}

//*****************************************************************************


/**
* Get composed bvr without being given a static value (get it from the property)
*/
HRESULT
CActorBvr::CBvrTrack::GetComposedBvr(IDABehavior **ppComposite)
{
	HRESULT hr;

	if (!m_bComposedComputed || m_bDirty )
	{
		// Need to get the static value
		IDABehavior *pStatic = NULL;
		hr = StaticBvr(&pStatic);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get static value");
			return hr;
		}

		hr = GetComposedBvr(pStatic, ppComposite, false);
		ReleaseInterface(pStatic);
		return hr;
	}

	*ppComposite = m_pdabvrComposed;
	if (m_pdabvrComposed != NULL)
		m_pdabvrComposed->AddRef();
	return S_OK;
}

//*****************************************************************************


HRESULT
CActorBvr::CBvrTrack::UpdateStaticBvr()
{
	//get the current value of the static by getting the current value
	//  of the property from the element.

	HRESULT hr = S_OK;
	VARIANT varStatic;
	
	::VariantInit( &varStatic );

	hr = Actor()->GetPropFromAnimatedElement( m_pNameComponents, m_cNumComponents, true, &varStatic );
	CheckHR( hr, "Failed to get the property from the animated element", end );

	if( m_eType == e_Number &&
		m_bstrPropertyName != NULL && 
		( wcsicmp( L"style.top", m_bstrPropertyName ) == 0 || 
		  wcsicmp( L"style.left", m_bstrPropertyName) == 0 ) 
	  )
	{
		if( V_VT( &varStatic ) == VT_R8 && V_R8( &varStatic ) < -8000.0 )
		{
			goto end;
		}
	}
	
	//put the new value for the static into the track.
	hr = PutStatic( &varStatic );
	CheckHR( hr, "Failed to put the static in update Static bvr", end );
	
end:
	::VariantClear( &varStatic );
	return hr;
}

//*****************************************************************************

/**
* Get final bvr using the given static value
*/
HRESULT
CActorBvr::CBvrTrack::GetFinalBvr(IDABehavior *pStatic, IDABehavior **ppFinal, bool fStaticSetExternally )
{
    // If we haven't got a final behavior yet then generate one now.
    if (!m_bFinalComputed || m_bDirty)
    {
		// Get the composed behavior
		IDABehavior *pComposed = NULL;
        HRESULT hr = GetComposedBvr(pStatic, &pComposed, fStaticSetExternally);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to compute composed behavior");
            return hr;
        }
		
		// Set it as the final behavior
		hr = SetFinalBvr(pComposed, false);
		ReleaseInterface(pComposed);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to set final bvr");
			return hr;
		}
    }

    *ppFinal = m_pdabvrFinal;
	if (m_pdabvrFinal != NULL)
		m_pdabvrFinal->AddRef();

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::GetFinalBvr( IDABehavior *pStatic, IDABehavior **ppFinal )
{
	return GetFinalBvr( pStatic, ppFinal, true );
}

//*****************************************************************************

/**
* Get final bvr without being given a static value (get it from the property)
*/
HRESULT
CActorBvr::CBvrTrack::GetFinalBvr(IDABehavior **ppFinal)
{
	HRESULT hr = S_OK;

	if (!m_bFinalComputed || m_bDirty )
	{
		// Need to get the static value
		IDABehavior *pStatic = NULL;
		hr = StaticBvr(&pStatic);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get static value");
			return hr;
		}

		hr = GetFinalBvr(pStatic, ppFinal, false);
		ReleaseInterface(pStatic);
		return hr;
	}

	*ppFinal = m_pdabvrFinal;
	if (m_pdabvrFinal != NULL)
		m_pdabvrFinal->AddRef();
	return S_OK;
}

//*****************************************************************************

/**
* Set final bvr
*/
HRESULT
CActorBvr::CBvrTrack::SetFinalBvr(IDABehavior *pFinal, bool fCalledExternally)
{
	HRESULT	hr = S_OK;
	
	if (m_pdabvrFinal != NULL)
	{
		ReleaseInterface( m_pdabvrFinal);
	}

	m_bFinalComputed = true;
	m_pdabvrFinal = pFinal;
	if (fCalledExternally)
		m_bFinalExternallySet = true;
	
	if (m_pdabvrFinal != NULL)
	{
		m_pdabvrFinal->AddRef();

		if (m_pModifiableFinal != NULL)
		{
			hr = m_pModifiableFinal->SwitchTo(m_pdabvrFinal);
			if (FAILED(hr))
			{
				DPF_ERR("Failed to initialize final uninit");
				return hr;
			}
		}
	}
	
	return hr;
}

//*****************************************************************************

/**
* Return value of the bvr specified (static, intermediate, composed, final).
* Most tracks cannot do this, so
* this base implementation fails.
*/
HRESULT
CActorBvr::CBvrTrack::GetBvr(ActorBvrFlags eFlags, IDABehavior **ppResult)
{
	// TODO (markhal): Currently this only works for relative tracks like image
	// To include absolute tracks we'd probably have to compose them?

	if (ppResult == NULL)
	{
		DPF_ERR("NULL pointer passed as argument");
		return E_POINTER;
	}

    HRESULT hr = S_OK;

	*ppResult = NULL;
    IDABehavior **ppSource = NULL;
		
    //NOTE: The from and intermediate are stored temporarily in the track
    //  and transferred to the fragment when it is added.

	// Return from behavior
	if (eFlags == e_From)
	{
        ppSource = &m_pModifiableFrom;
	}
	//Intermediate behavior
	else if( eFlags == e_Intermediate )
	{
        ppSource = &m_pModifiableIntermediate;
	}
	// static behavior
	else if ((eFlags == e_Static))
    {
        ppSource = &m_pModifiableStatic;
	}
	// Composed behavior
	else if (eFlags == e_Composed)
	{
		ppSource = &m_pModifiableComposed;
	}
	// Final behavior
	else //if (eFlags == e_Final)
	{
		ppSource = &m_pModifiableFinal;
	}

    //now we know what the source is...
    //if the source is non null
    if( (*ppSource) != NULL )
    {
        //return it
        (*ppResult) = (*ppSource);
        (*ppResult)->AddRef();
    }
    else  //the source is null
    {
	    // Create an uninitialized variable
	    hr = ModifiableBvr(ppResult);
        CheckHR( hr, "Failed to create Modifiable behavior", end );

        //store it away in the source
        (*ppSource) = (*ppResult);
        (*ppSource)->AddRef();
    }
end:
	
	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::SetPropertyName(BSTR bstrPropertyName)
{
    DASSERT(NULL != bstrPropertyName);
    DASSERT(NULL == m_bstrPropertyName);

    m_bstrPropertyName = ::SysAllocString(bstrPropertyName);
    if (NULL == m_bstrPropertyName)
    {
        DPF_ERR("Insufficient memory to allocate the property name");
        return E_OUTOFMEMORY;
    }

	// Figure out whether we are animating a property on the element or on the element's style.
	// Break the name out into components

	// First count the number of .'s in it
	int count = 0;
	OLECHAR *c = m_bstrPropertyName;
	while (c != NULL)
	{
		c = wcschr(c, L'.');
		
		if (c != NULL)
		{
			count++;
			c++;
		}
	}

	// There is 1 more string than .'s
	count++;

	// Allocate this many strings
	m_pNameComponents = new BSTR[count];
	if (m_pNameComponents == NULL)
		return E_FAIL;

	m_cNumComponents = count;

	// Copy them in
	OLECHAR *start = m_bstrPropertyName;
	for (int i=0; i<count; i++)
	{
		OLECHAR *end = wcschr(start, L'.');

		if (end == NULL)
		{
			// Copy all the rest
			m_pNameComponents[i] = ::SysAllocString(start);
		}
		else
		{
			// Copy up until just before the .
			m_pNameComponents[i] = ::SysAllocStringLen(start, end-start);
			start = end+1;
		}

		if (m_pNameComponents[i] == NULL)
		{
			// This is bad
			delete m_pNameComponents;
			m_pNameComponents = NULL;
			m_cNumComponents = 0;
			return E_FAIL;
		}
	}

	// Detect special case of animating style
	if (count == 2 && wcscmp(L"style", m_pNameComponents[0]) == 0)
	{
		// Property name begins with style.
		m_bStyleProp = true;
	}

    return S_OK;
} // SetPropertyName

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::AddBvrFragment(ActorBvrFlags  eFlags,
                                     IDABehavior   *pdabvrAction,
                                     IDABoolean    *pdaboolActive,
									 IDANumber	   *pdanumTimeline,
									 IDispatch     *pdispBehaviorElement,
									 long		   *pCookie)
{
    DASSERT(NULL != pdabvrAction);
    DASSERT(NULL != pdaboolActive);
	DASSERT(pCookie != NULL );

	long fragCookie = Actor()->GetNextFragmentCookie();
    // Create the new fragment.
    CBvrFragment *pfragNew = new CBvrFragment(eFlags, pdabvrAction, pdaboolActive, pdanumTimeline, pdispBehaviorElement, fragCookie);
    if (NULL == pfragNew)
    {
        DPF_ERR("Insufficient memory to allocate the new fragment");
        return E_OUTOFMEMORY;
    }

	(*pCookie) = fragCookie;

	// Transfer over any modifiable from
	if (m_pModifiableFrom != NULL)
	{
		pfragNew->m_pModifiableFrom = m_pModifiableFrom;
		m_pModifiableFrom = NULL;
	}

	//Transfer over any modifiable intermediate
	if( m_pModifiableIntermediate != NULL )
	{
		pfragNew->m_pModifiableIntermediate = m_pModifiableIntermediate;
		m_pModifiableIntermediate = NULL;
	}

	if (eFlags == e_Filter)
		m_cFilters++;

    // Which list to add the fragment to?
	// TODO (markhal): This is icky, but I cannot OR enums?
	// TODO (markhal): Call this something more generic like e_AbsRelative?
    if ( IsRelativeFragment( eFlags ) )
    {
		//insert the fragment into the relative list in order
		InsertInOrder( &m_pfragRelListHead, pfragNew );
    }
    else
    {
		//insert the fragment into the absolute list in order
		InsertInOrder( &m_pfragAbsListHead, pfragNew );
    }

    m_bWasAnimated = false;

	m_bDirty = true;

    return S_OK;
} // AddBvrFragment

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::RemoveBvrFragment( ActorBvrFlags eFlags, long cookie )
{
	CBvrFragment *pfragToRemove = NULL;
	CBvrFragment *pfragPrev = NULL;
	//find the behavior in the given track that has a matching cookie
	if( IsRelativeFragment( eFlags ) )
	{
		if( FindFragmentInList( m_pfragRelListHead, cookie, &pfragPrev, &pfragToRemove ) )
		{
			if( pfragToRemove->m_eFlags == e_Filter )
				m_cFilters--;
			//if this is not the first element in the list
			if( pfragPrev != NULL )
			{
				//remove the element
				pfragPrev->m_pfragNext = pfragToRemove->m_pfragNext;
			}
			else//it's the first element
			{
				//update the head of the list
				m_pfragRelListHead = pfragToRemove->m_pfragNext;
			}

			//mark the track as needing a rebuild
			m_bDirty = true;

			delete pfragToRemove;
		}
		else
		{
			return E_FAIL;
		}
	}
	else //it's an absoute fragment
	{
		if( FindFragmentInList( m_pfragAbsListHead, cookie, &pfragPrev, &pfragToRemove ) )
		{
			if( pfragToRemove->m_eFlags == e_Filter )
				m_cFilters--;

			if( pfragPrev != NULL )
			{
				//remove the element
				pfragPrev->m_pfragNext = pfragToRemove->m_pfragNext;
			}
			else // it's the first element
			{
				//update the head of the list
				m_pfragAbsListHead = pfragToRemove->m_pfragNext;
			}
			
			//mark the track as needing a rebuild.
			m_bDirty = true;

			delete pfragToRemove;
		}
		else//cookie not found
		{
			return E_FAIL;
		}
	}

	m_bWasAnimated = ( m_pfragAbsListHead == NULL && m_pfragRelListHead == NULL );

	return S_OK;
}//RemoveBvrFragment

//*****************************************************************************

bool
CActorBvr::CBvrTrack::FindFragmentInList( CBvrFragment *pfragListHead, 
										   long cookie, 
										   CBvrFragment** ppfragPrev,
										   CBvrFragment** ppfragFragment)
{
	DASSERT( ppfragFragment != NULL && ppfragPrev != NULL );
	CBvrFragment *pfragCurrent = pfragListHead;
	CBvrFragment *pfragPrev = NULL;
	bool bFound = false;

	//loop through the fragment list
	while( pfragCurrent != NULL )
	{
		//if we found a match stop looping
		if( pfragCurrent->GetCookie() == cookie )
		{
			bFound = true;
			break;
		}
		pfragPrev = pfragCurrent;
		pfragCurrent = pfragCurrent->m_pfragNext;
	}

	(*ppfragPrev) = pfragPrev;
	(*ppfragFragment) = pfragCurrent;
	return bFound;
}

//*****************************************************************************

bool
CActorBvr::CBvrTrack::IsRelativeFragment( ActorBvrFlags eFlags )
{
	return (eFlags == e_Relative ||
			eFlags == e_Filter ||
			eFlags == e_ScaledImage ||
			eFlags == e_UnscaledImage);
}//IsRelativeFragment

//*****************************************************************************

void
CActorBvr::CBvrTrack::InsertInOrder( CBvrFragment** ppListHead, CBvrFragment* pfragToInsert )
{
	CBvrFragment* pfragCurrent = (*ppListHead);

	//if the list is empty then insert at the top
	if( pfragCurrent == NULL )
	{
		//first element
		(*ppListHead) = pfragToInsert;
		pfragToInsert->m_pfragNext = NULL;
		return;
	}

	CBvrFragment* pfragPrev = NULL;
	while( pfragCurrent != NULL && 
		   pfragCurrent->GetOrderLong() < pfragToInsert->GetOrderLong() )
	{
		pfragPrev = pfragCurrent;
		pfragCurrent = pfragCurrent->m_pfragNext;
	}
	//pfragPrev will point to the last element whose order long is < the
	//order long of the element that we are inserting, or null if there is no such
	//element in the list.

	if( pfragPrev != NULL )
	{
		//insert after pfragPrev
		pfragToInsert->m_pfragNext = pfragPrev->m_pfragNext;
		pfragPrev->m_pfragNext = pfragToInsert;
		
	}
	else
	{
		//insert at the top of the list.
		pfragToInsert->m_pfragNext = (*ppListHead);
		(*ppListHead) = pfragToInsert;
	}
}

//*****************************************************************************

/**
* This method works for the types e_Number, e_Color, and e_String.  Other
* bvr types need to override and do whatever they want (like nothing)
*/
// TODO (markhal): Change the name of this?
HRESULT
CActorBvr::CBvrTrack::ApplyIfUnmarked(void)
{
	HRESULT hr = S_OK;

	if (m_eType != e_Number &&
		m_eType != e_Color &&
		m_eType != e_String)
	{
		// This is not a failure, just a do-nothing
		return S_OK;
	}

	//do not apply this track again if it is already applied
	if( m_fApplied )
		return S_OK;

	if (m_bDoNotApply)
		return S_OK;

    DASSERT(NULL != m_bstrPropertyName);

	// We compute the behaviors if
	// 1) There is a final behavior already set OR
	// 2) There are fragments present OR
	// 3) Someone asked for the final or composed behaviors
	// This avoids applying tracks like width and height that were created simply
	// to get composed DA versions of their static values
	if (!m_bFinalComputed &&
		m_pfragAbsListHead == NULL&&
		m_pfragRelListHead ==NULL &&
		m_pModifiableFinal == NULL &&
		m_pModifiableComposed == NULL)
	{
		//if this track was animated, and just lost all of its animated components
		// then we need to reset the value in the document.
		if( m_bWasAnimated )
		{
			ApplyStatic();
			m_bWasAnimated = false;
		}
		
		m_varboolOn = VARIANT_FALSE;

		return S_OK;
	}

	// Get the final behavior, passing no static.  The static value will be pulled off
	// the property.
    IDABehavior *pdabvrFinal = NULL;
    hr = GetFinalBvr(&pdabvrFinal);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get a final behavior");
        return hr;
    }
    
	// We apply this track if:
	// 1) There is a final behavior already set OR
	// 2) There are fragments present
	// REVIEW: would it be enough to have saved the value of m_bFinalComputed before
	// calling GetFinalBvr(), instead of introducing m_bFinalSetExternally?
	if (!m_bFinalExternallySet && 
		m_pfragAbsListHead == NULL && 
		m_pfragRelListHead == NULL )
		return hr;
	
	if (pdabvrFinal != NULL)
	{
		DASSERT(NULL != Actor());
		hr = ApplyBvrToElement(pdabvrFinal);
		ReleaseInterface(pdabvrFinal);
		if (FAILED(hr))
		{
			DPF_ERR("Could not apply behavior to animated element");
			return hr;
		}
	}

	m_fApplied = true;

	//if this track is a style track and it is no longer animated
	if( !IsAnimated() )
	{
		ApplyStatic();
		m_varboolOn = VARIANT_FALSE;
	}

	#ifdef _DEBUG
	if( m_bstrPropertyName != NULL )
		LMTRACE2(1, 1000, L"Added behaivor %s to da\n", m_bstrPropertyName );
	else
		LMTRACE2(1, 1000, L"Added non property behavior to da\n" );
	#endif

    return S_OK;
} // Apply

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ApplyBvrToElement(IDABehavior *pBvr)
{
	HRESULT hr = S_OK;

	hr = HookBvr(pBvr);
	if (FAILED(hr))
		return hr;

	//hook the overall on booleanbvr for this track so that we can unset the value
	//  when it goes off.
	if( m_pOnSampler != NULL )
	{
		m_pOnSampler->Invalidate();
		m_pOnSampler = NULL;
	}

	IDABoolean *pdaboolOn = NULL;
	hr = GetTrackOn( &pdaboolOn );
	if( FAILED( hr ) )
		return hr;

	if( pdaboolOn != NULL )
	{
		m_pOnSampler = new CSampler( OnCallback, reinterpret_cast<void*>(this) );

		if( m_pOnSampler == NULL )
		{
			ReleaseInterface( pdaboolOn );
			return E_FAIL;
		}

		IDABehavior *pdabvrHooked;
		hr = m_pOnSampler->Attach( pdaboolOn, &pdabvrHooked );
		ReleaseInterface( pdaboolOn );
		if( FAILED( hr ) )
			return hr;

		hr = AddBehaviorToTIME( pdabvrHooked, &m_lOnCookie, ONBVR_COOKIESET);
		ReleaseInterface( pdabvrHooked );
		if( FAILED( hr ) )
			return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::UpdateOnValueState( ValueOnChangeType type )
{
	//ensure that this method doesn't get called more than once per tick for each on and value, 
	//respectively
	//ASSERT( m_lastOnSampleTime != globalTimeOfChange && m_lastValueSampleTime != globalTimeOfChange );

	HRESULT hr = S_OK;
	switch( type )
	{
	case on_no_change:
		{
			//if value has already been sampled
			if( m_fValueSampled )
			{
				//clear out the sampled flags
				m_fValueSampled = false;
				//if we are currently on
				if( m_varboolOn != VARIANT_FALSE )
				{
					//if the value changed
					if( m_fValueChangedThisSample )
					{
						// apply the new value to property
						SetPropFromVariant( &m_varCurrentValue);
					}
				}//else the property should already be ""
				// reset the valueChanged state
				m_fValueChangedThisSample = false;
			}
			else
			{
				m_fOnSampled = true;
			}
		}break;
	case on_change:
		{

			//if we are off now
			if( m_varboolOn == VARIANT_FALSE )
			{
				//check the current value of the property on the element
				// to see if it is different from what we origianlly set.
				// if so then we should not set the runtime style to ""
				//set the property to ""
				if( !AttribIsTimeAnimated() )
				{
					if( m_bStyleProp )	
					{
						SetPropFromVariant( const_cast<VARIANT*>(s_emptyString.GetVar()));
					}
					else
					{
						//set the static value back.
						SetPropFromVariant( &m_varStaticValue );
					}
					m_fValueChangedThisSample = false;
				}
				//else // don't set anything
			}
			else//else we are on now
			{
				if( !m_fSkipNextStaticUpdate )
					UpdateStaticBvr();
				else
					m_fSkipNextStaticUpdate = false;
				
				//if we have already sampled the value
				if( m_fValueSampled)
				{
					//set value to prop
					SetPropFromVariant( &m_varCurrentValue);
					m_fValueChangedThisSample = false;
				}
				else//else value has not yet been sampled
				{
					//indicate that we are forcing a value set when value is sampled
					m_fForceValueChange = true;
				}
			}
			if( m_fValueSampled )
				m_fValueSampled = false;
			else
				m_fOnSampled = true;
		}break;
	case value_no_change:
		{
			//if we are being forced to set value to property
			if( m_fForceValueChange )
			{				
				//set value to property
				SetPropFromVariant( &m_varCurrentValue);
				//clear the force flag
				m_fForceValueChange = false;
			}
			if( m_fOnSampled )
				m_fOnSampled = false;
			else
				m_fValueSampled = true;
		}break;
	case value_change:
		{
			//if on has been sampled
			if( m_fOnSampled )
			{
				//reset state, we're done.
				m_fOnSampled = false;

				//if we are on
				if( m_varboolOn != VARIANT_FALSE )
				{
					//commit value to property
					SetPropFromVariant( &m_varCurrentValue );
				}
				m_fForceValueChange = false;
			}
			else//else on has not been sampled yet
			{
				m_fValueSampled = true;
				//indicate that the value has changed and needs to be set.
				m_fValueChangedThisSample = true;
			}
		}break;
	}

	return hr;
}//UpdateOnValueState

//*****************************************************************************

bool
CActorBvr::CBvrTrack::AttribIsTimeAnimated()
{
	if( !m_bStyleProp )
		return false;

	//this attribute could be animated by time if is is display or visibility.
	if( ( wcsicmp( L"visibility", m_pNameComponents[1]) == 0 ) ||
	  	( wcsicmp( L"display", m_pNameComponents[1] ) == 0 ) )
	{
		HRESULT hr = S_OK;
		//get the t:timeAction property off of the animated element
		CComVariant varTimeAction;
		CComPtr<IHTMLElement> pelemAnimated;

		hr = Actor()->GetAnimatedElement( &pelemAnimated );
		if( FAILED( hr ) || pelemAnimated == NULL )
			return false;

		hr = pelemAnimated->getAttribute( L"timeAction", 0, &varTimeAction );
		if( FAILED( hr ) )
			return false;

		hr = varTimeAction.ChangeType( VT_BSTR );
		if( FAILED( hr ) )
			return false;
		// if t:timeaction == m_pNameComponents[1] 
		return ( wcsicmp( m_pNameComponents[1], V_BSTR( &varTimeAction ) ) == 0 );
			//time and this track are animating the same attribute
	}
	else
		return false;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::OnCallback(void* thisPtr, 
								 long id, 
								 double startTime, 
								 double globalNow, 
								 double localNow, 
								 IDABehavior* sampleVal, 
								 IDABehavior **ppReturn)
{
	CBvrTrack *pTrack = reinterpret_cast<CBvrTrack*>(thisPtr);

	if( pTrack == NULL || sampleVal == NULL )
		return E_INVALIDARG;

	HRESULT hr;
	VARIANT_BOOL varboolOn = VARIANT_FALSE;
	IDABoolean *pdaboolOn = NULL;


	if( pTrack->m_lOnId == -1 )
		pTrack->m_lOnId = id;

	//bail if this is an instance we don't care about.
	if( pTrack->m_lOnId != id )
		goto cleanup;
		
	hr = sampleVal->QueryInterface( IID_TO_PPV( IDABoolean, &pdaboolOn ) );
	CheckHR( hr, "Failed to get IDABoolean from the sampled behavior", cleanup );

	hr = pdaboolOn->Extract( &varboolOn );
	ReleaseInterface( pdaboolOn );
	CheckHR( hr, "Failed to extract the boolean val from the sampled value", cleanup );

	hr = pTrack->OnSampled( varboolOn );

cleanup:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::OnSampled( VARIANT_BOOL varboolOn )
{
    if( varboolOn != m_varboolOn )
	{
		m_varboolOn = varboolOn;
		UpdateOnValueState( on_change );
    }
	else
	{
		UpdateOnValueState( on_no_change );
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::SetPropFromVariant(VARIANT *pVal )
{
	if( m_fChangesLockedOut )
		return S_OK;
		
	HRESULT hr = S_OK;
    
	if (m_bStyleProp)
	{

#if 0		
		#ifdef _DEBUG
		if( V_VT( pVal ) == VT_BSTR )
			LMTRACE2( 1, 2, L"track %s setting value %s\n", m_bstrPropertyName, V_BSTR( pVal ) );
		else if( V_VT( pVal ) == VT_R8 )
			LMTRACE2( 1, 2, L"track %s setting value %f\n", m_bstrPropertyName, V_R8( pVal ) );

		if( Actor()->IsAnimatingVML() )
		{
			LMTRACE2( 1, 1000, L"This is a vml shape\n" );
		}
		#endif
#endif
		
		if (Actor()->IsAnimatingVML())
		{
			// If VML, then attempt to set it using special accessor method.
			// If this fails, fall back to runtimeStyle
			hr = Actor()->SetVMLAttribute(m_pNameComponents[1], pVal);

			if (SUCCEEDED(hr))
				return S_OK;
		}

		// Animate property on runtimeStyle
		IHTMLStyle *pStyle = NULL;
		hr = Actor()->GetRuntimeStyle(&pStyle);
		//hr = Actor()->GetStyle(&pStyle);
		if (FAILED(hr))
			return S_OK;
		
		hr = pStyle->setAttribute(m_pNameComponents[1], *pVal, 0);
		ReleaseInterface(pStyle);
	
		// NOTE: We don't really care what happened here.  There might have
		// been an error returned, but we don't want to break if people set bogus values
		return S_OK;
	}
	else if (m_cNumComponents == 1)
	{
		// Must be a property on the element itself
		IHTMLElement *pElement = NULL;
		hr = Actor()->GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		hr = pElement->setAttribute(m_pNameComponents[0], *pVal, 0);
		ReleaseInterface(pElement);

		// NOTE: We don't really care what happened here.  There might have
		// been an error returned, but we don't want to break if people set bogus values
		return S_OK;
	}
	else
	{
		// Multicomponent name
		// Do property gets and a final set to drill down

		// Start with the element itself
		IHTMLElement *pElement = NULL;
		hr = Actor()->GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		// Get a dispatch from it
		IDispatch *pDispatch = NULL;
		hr = pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDispatch));
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;

		// Now loop over the stored property names, except the last one, doing getDispatch
		// Note that we don't care if we fail
		for (int i=0; i<m_cNumComponents-1; i++)
		{
			IDispatch *pPropDispatch = NULL;
			hr = Actor()->GetPropertyAsDispatch(pDispatch, m_pNameComponents[i], &pPropDispatch);
			ReleaseInterface(pDispatch);
			if (FAILED(hr))
				return S_OK;
	
			pDispatch = pPropDispatch;
		}

		// Now set the final one
		hr = Actor()->SetPropertyOnDispatch(pDispatch, m_pNameComponents[m_cNumComponents-1], pVal);
		ReleaseInterface(pDispatch);
		
		return S_OK;
	}
}


//*****************************************************************************

/**
 * Call this to add a behaivor to the time behavior.  plCookie should be set to the old value
 * of the cookie for the behaivor to be added in the case that that behavior's cookie flag
 * has not yet been removed from the set of added behavior flags( it has not been removed
 * from time yet).
*/
HRESULT
CActorBvr::CBvrTrack::AddBehaviorToTIME( IDABehavior* pdabvrToAdd, long* plCookie, DWORD flag )
{
	if( pdabvrToAdd == NULL || plCookie == NULL || flag == 0 )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	//if the cookie is already set
	if( ( m_dwAddedBehaviorFlags & flag ) != 0 )
	{
		//we have to remove it.
		hr = RemoveBehaviorFromTIME( (*plCookie), flag );
		CheckHR( hr, "Failed to remove a previously set behavior from TIME", end );
	}
	
	hr = Actor()->AddBehaviorToTIME( pdabvrToAdd, plCookie );
	CheckHR( hr, "Failed to add a behaivor to time from the track", end );

	
	m_dwAddedBehaviorFlags |= flag;
	
  end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::RemoveBehaviorFromTIME( long lCookie, DWORD flag )
{
	if( flag == 0 )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = S_OK;

	//if the cookie is not set there is nothing to do
	if( ( m_dwAddedBehaviorFlags & flag ) == 0 )
		return S_OK;

	//otherwise remove the behavior
	Actor()->RemoveBehaviorFromTIME( lCookie );
	CheckHR( hr, "Failed to remove a behavior from time", end);
	
	ClearBit( m_dwAddedBehaviorFlags, flag );

  end:
	return hr;
}

//*****************************************************************************
//
// class CTransformBvrTrack
//
//*****************************************************************************

//*****************************************************************************

CActorBvr::CTransformBvrTrack::CTransformBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType)
:   CBvrTrack(pbvrActor, eType),
	m_pSampler(NULL),
	m_lTransformId(-1)
{
}

CActorBvr::CTransformBvrTrack::~CTransformBvrTrack()
{
	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}
}

HRESULT
CActorBvr::CTransformBvrTrack::IdentityBvr(IDABehavior **ppdabvrIdentity)
{
    DASSERT(NULL != ppdabvrIdenity);
    *ppdabvrIdentity = NULL;

    IDATransform2 *pdabvrTemp = NULL;
    HRESULT hr = Actor()->GetDAStatics()->get_IdentityTransform2(&pdabvrTemp);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to create the transform bvr's identity behavior");
        return hr;
    }

    *ppdabvrIdentity = pdabvrTemp;

    return S_OK;
} // IdentityBvr

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::StaticBvr(IDABehavior **ppdabvrStatic)
{
	// The static defaults to the identity.  Usually the get methods will be
	// called with an alternative static
	return IdentityBvr(ppdabvrStatic);
} // StaticBvr

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::UninitBvr(IDABehavior **ppUninit)
{
	DASSERT(ppUninit != NULL);

	*ppUninit = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DATransform2, 
								  NULL, 
								  CLSCTX_INPROC_SERVER, 
								  IID_IDABehavior, 
								  (void**)ppUninit);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to cocreate uninit transform2");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::ModifiableBvr( IDABehavior **ppModifiable )
{
	ReturnIfArgNull(ppModifiable );

	*ppModifiable = NULL;

	HRESULT hr = S_OK;

	IDATransform2* pIdentity = NULL;

	hr = Actor()->GetDAStatics()->get_IdentityTransform2( &pIdentity );
	CheckHR( hr, "Failed to get identity transform2 from DA", end );
	
	Actor()->GetDAStatics()->ModifiableBehavior( pIdentity, ppModifiable );
	CheckHR( hr, "Failed to create a modifiable behavior for a transform track", end );

end:
	ReleaseInterface( pIdentity );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::InverseBvr(IDABehavior *pOriginal, IDABehavior **ppInverse)
{
	HRESULT hr = S_OK;

	DASSERT(pBehavior != NULL);
	DASSERT(ppInverse != NULL);

	*ppInverse = NULL;

	IDATransform2 *pOrigTrans = NULL;
	hr = pOriginal->QueryInterface(IID_TO_PPV(IDATransform2, &pOrigTrans));
	if (FAILED(hr))
		return hr;

	IDATransform2 *pInverse = NULL;
	hr = pOrigTrans->Inverse(&pInverse);
	ReleaseInterface(pOrigTrans);
	if (FAILED(hr))
		return hr;

	*ppInverse = pInverse;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::Compose(IDABehavior*  pdabvr1,
                                       IDABehavior*  pdabvr2,
                                       IDABehavior** ppdabvrResult)
{
    DASSERT(NULL != pdabvr1);
    DASSERT(NULL != pdabvr2);
    DASSERT(NULL != ppdabvrResult);
    *ppdabvrResult = NULL;

    IDATransform2 *pdabvrTrans1 = NULL;
    HRESULT hr = pdabvr1->QueryInterface( IID_TO_PPV(IDATransform2, &pdabvrTrans1) );
    if (FAILED(hr))
    {
        DPF_ERR("Failed to QI for IDATransform2 from input behavior 1");
        return hr;
    }
    IDATransform2 *pdabvrTrans2 = NULL;
    hr = pdabvr2->QueryInterface( IID_TO_PPV(IDATransform2, &pdabvrTrans2) );
    if (FAILED(hr))
    {
        DPF_ERR("Failed to QI for IDATransform2 from input behavior 2");
        ReleaseInterface(pdabvrTrans1);
        return hr;
    }

	IDATransform2 *pResult = NULL;
    hr = Actor()->GetDAStatics()->Compose2(pdabvrTrans1,
                                           pdabvrTrans2,
                                           &pResult);
    ReleaseInterface(pdabvrTrans1);
    ReleaseInterface(pdabvrTrans2);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to compose two transform behaviors");
        return hr;
    }

	*ppdabvrResult = pResult;

    return S_OK;
} // Compose

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::SwitchAccum(IDABehavior *pModifiable)
{
	HRESULT hr = S_OK;

	if (pModifiable == NULL)
		return E_FAIL;

	if (m_lTransformId != -1)
	{
		IDATransform2 *pTransform = NULL;
		if (m_eType == e_Scale)
		{
			hr = Actor()->GetDAStatics()->Scale2(m_lastX, m_lastY, &pTransform);
			if (FAILED(hr))
				return hr;
		}
		else
		{
			hr = Actor()->GetDAStatics()->Translate2(m_lastX, m_lastY, &pTransform);
			if (FAILED(hr))
				return hr;
		}

		hr = pModifiable->SwitchTo(pTransform);
		ReleaseInterface(pTransform);
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult)
{
	HRESULT hr = S_OK;

	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}
	// We need to hook this behavior
	m_pSampler = new CSampler(TransformCallback, (void*)this);

	if (m_pSampler == NULL)
		return E_FAIL;

	// Originally I tried just hooking the transform, but this did not let
	// me use the sampled value for anything useful.  Instead I'll transform a point
	// and sample the transformed x and y.  Uggh.
	IDAPoint2 *pPoint = NULL;
	if (m_eType == e_Scale)
	{
		// Need to transform 1,1
		hr = Actor()->GetDAStatics()->Point2(1, 1, &pPoint);
		if (FAILED(hr))
			return hr;
	}
	else
	{
		// Need to transform 0, 0
		hr = Actor()->GetDAStatics()->get_Origin2(&pPoint);
		if (FAILED(hr))
			return hr;
	}

	IDATransform2 *pTransform = NULL;
	hr = pBvr->QueryInterface(IID_TO_PPV(IDATransform2, &pTransform));
	if (FAILED(hr))
	{
		ReleaseInterface(pPoint);
		return hr;
	}

	IDAPoint2 *pTransPoint = NULL;
	hr = pPoint->Transform(pTransform, &pTransPoint);
	ReleaseInterface(pTransform);
	ReleaseInterface(pPoint);
	if (FAILED(hr))
		return hr;

	IDABehavior *pHooked = NULL;
	hr = m_pSampler->Attach(pTransPoint, &pHooked);
	ReleaseInterface(pTransPoint);
	if (FAILED(hr))
		return hr;

	hr = pHooked->QueryInterface(IID_TO_PPV(IDAPoint2, &pTransPoint));
	ReleaseInterface(pHooked);
	if (FAILED(hr))
		return hr;

	IDANumber *pX = NULL;
	hr = pTransPoint->get_X(&pX);
	if (FAILED(hr))
	{
		ReleaseInterface(pTransPoint);
		return hr;
	}

	IDANumber *pY = NULL;
	hr = pTransPoint->get_Y(&pY);
	ReleaseInterface(pTransPoint);
	if (FAILED(hr))
		return hr;

	if (m_eType == e_Scale)
		hr = Actor()->GetDAStatics()->Scale2Anim(pX, pY, &pTransform);
	else
		hr = Actor()->GetDAStatics()->Translate2Anim(pX, pY, &pTransform);
	ReleaseInterface(pX);
	ReleaseInterface(pY);
	if (FAILED(hr))
		return hr;

	*ppResult = pTransform;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::TransformCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CTransformBvrTrack *pTrack = (CTransformBvrTrack*)thisPtr;

	if (pTrack == NULL)
		return E_FAIL;

	if( pTrack->m_lTransformId == -1 )
		pTrack->m_lTransformId = id;

	if( pTrack->m_lTransformId != id )
		return S_OK;
		
	// Get the point and get x and y
	IDAPoint2 *pPoint = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDAPoint2, &pPoint));
	if (FAILED(hr))
		return hr;

	IDANumber *pNum = NULL;
	hr = pPoint->get_X(&pNum);
	if (FAILED(hr))
	{
		ReleaseInterface(pPoint);
		return hr;
	}

	hr = pNum->Extract(&(pTrack->m_lastX));
	ReleaseInterface(pNum);
	if (FAILED(hr))
	{
		ReleaseInterface(pPoint);
		return hr;
	}

	hr = pPoint->get_Y(&pNum);
	ReleaseInterface(pPoint);
	if (FAILED(hr))
		return hr;

	hr = pNum->Extract(&(pTrack->m_lastY));
	ReleaseInterface(pNum);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::CreateInstance(CActorBvr             *pbvrActor,
                                              BSTR                   bstrPropertyName,
                                              ActorBvrType           eType,
                                              CActorBvr::CBvrTrack **pptrackResult)
{
    DASSERT(NULL != pbvrActor);
    DASSERT(NULL != bstrPropertyName);
    DASSERT(NULL != pptrackResult);
    *pptrackResult = NULL;

    // Create the new bvr track
    CBvrTrack* ptrack = new CTransformBvrTrack(pbvrActor, eType);
    if (NULL == ptrack)
    {
        DPF_ERR("Insufficient memory to allocate a new transform bvr track");
        return E_OUTOFMEMORY;
    }

    // Set the property name
    HRESULT hr = ptrack->SetPropertyName(bstrPropertyName);
    if (FAILED(hr))
    {
        DPF_ERR("Could not set the bvr track's property name");
        delete ptrack;
        return hr;
    }

    *pptrackResult = ptrack;
    return hr;
} // CreateInstance

//*****************************************************************************
//
// class CNumberBvrTrack
//
//*****************************************************************************

CActorBvr::CNumberBvrTrack::CNumberBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType)
:   CBvrTrack(pbvrActor, eType),
	m_pSampler(NULL),
	m_currVal(0),
	m_pAccumSampler(NULL),
	m_currAccumVal(0),
	m_lAccumId(-1),
	m_bstrUnits(NULL),
	m_lNumberCookie( 0 ),
	m_lNumberId( -1 )
{
} // CNumberBvrTrack

//*****************************************************************************

CActorBvr::CNumberBvrTrack::~CNumberBvrTrack()
{
	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}

	if (m_pAccumSampler != NULL)
	{
		m_pAccumSampler->Invalidate();
		m_pAccumSampler = NULL;
	}

	if (m_bstrUnits != NULL)
		::SysFreeString(m_bstrUnits);

}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::IdentityBvr(IDABehavior **ppdabvrIdentity)
{
    DASSERT(NULL != ppdabvrIdentity);
    *ppdabvrIdentity = NULL;

    IDANumber *pdanumTemp = NULL;
    HRESULT hr = Actor()->GetDAStatics()->DANumber(0.0, &pdanumTemp);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to create the number bvr's identity behavior");
        return hr;
    }

    *ppdabvrIdentity = pdanumTemp;
    return S_OK;
} // IdentityBvr

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::StaticBvr(IDABehavior **ppdabvrStatic)
{
    DASSERT(NULL != ppdabvrStatic);
    HRESULT hr = S_OK;
    *ppdabvrStatic = NULL;

	if( m_pModifiableStatic == NULL )
	{
		hr = UpdateStaticBvr();
	}

	if( SUCCEEDED( hr ) )
	{
		(*ppdabvrStatic) = m_pModifiableStatic;
		(*ppdabvrStatic)->AddRef();
	}
    else
    {
        // Need to return something
		return IdentityBvr(ppdabvrStatic);
    }

    return S_OK;
} // StaticBvr

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::UninitBvr(IDABehavior **ppUninit)
{
	DASSERT(ppUninit != NULL);

	*ppUninit = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DANumber, 
								  NULL, 
								  CLSCTX_INPROC_SERVER, 
								  IID_IDABehavior, 
								  (void**)ppUninit);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to cocreate uninit number");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::ModifiableBvr( IDABehavior **ppModifiable )
{
	ReturnIfArgNull( ppModifiable );

	HRESULT hr = S_OK;

	(*ppModifiable) = NULL;

	IDANumber *pNum = NULL;

	hr = Actor()->GetDAStatics()->ModifiableNumber( 0.0, &pNum );
	CheckHR( hr, "Failed to create a modifiable number", end );

	hr = pNum->QueryInterface( IID_TO_PPV( IDABehavior, ppModifiable) );
	CheckHR( hr, "Failed to QI number returned from modifiable number for IDABehavior", end);

end:
	ReleaseInterface( pNum );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::ModifiableBvr( IDABehavior *pdabvrInitialValue, IDABehavior **ppModifiable )
{
	if( pdabvrInitialValue == NULL || ppModifiable == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	(*ppModifiable) = NULL;

	hr = Actor()->GetDAStatics()->ModifiableBehavior( pdabvrInitialValue, ppModifiable );
	CheckHR( hr, "Failed to create a modifiable behavior for the number track", end );
	

end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::InverseBvr(IDABehavior *pOriginal, IDABehavior **ppInverse)
{
	HRESULT hr = S_OK;

	DASSERT(pBehavior != NULL);
	DASSERT(ppInverse != NULL);

	*ppInverse = NULL;

	IDANumber *pOrigNum = NULL;
	hr = pOriginal->QueryInterface(IID_TO_PPV(IDANumber, &pOrigNum));
	if (FAILED(hr))
		return hr;

	IDANumber *pInverse = NULL;
	hr = Actor()->GetDAStatics()->Neg(pOrigNum, &pInverse);
	ReleaseInterface(pOrigNum);
	if (FAILED(hr))
		return hr;

	*ppInverse = pInverse;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::Compose(IDABehavior  *pdabvr1,
                                    IDABehavior  *pdabvr2,
                                    IDABehavior **ppdabvrResult)
{
    // Composition for number behaviors is currently defined as simply addition
    DASSERT(NULL != pdabvr1);
    DASSERT(NULL != pdabvr2);
    DASSERT(NULL != ppdabvrResult);
    *ppdabvrResult = NULL;

    // Get the number behavior interfaces
    IDANumber* pdanum1 = NULL;
    HRESULT hr = pdabvr1->QueryInterface( IID_TO_PPV( IDANumber, &pdanum1) );
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for IDANumber from bvr1 of number track's compose");
        return hr;
    }
    IDANumber* pdanum2 = NULL;
    hr = pdabvr2->QueryInterface( IID_TO_PPV(IDANumber, &pdanum2) );
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for IDANumber from bvr2 of number track's compose");
        ReleaseInterface(pdanum1);
        return hr;
    }

    // Now create an addition behavior to add the two numbers up.
    IDANumber *pdanumTemp = NULL;
    hr = Actor()->GetDAStatics()->Add(pdanum1, pdanum2, &pdanumTemp);
    ReleaseInterface(pdanum1);
    ReleaseInterface(pdanum2);
    if (FAILED(hr))
    {
        DPF_ERR("Could not create the Add behavior in number track's compose");
        return hr;
    }

    *ppdabvrResult = pdanumTemp;

    return S_OK;
} // Compose

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::HookBvr(IDABehavior *pBvr)
{
	HRESULT hr = S_OK;

	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}
	
	// We need to hook this behavior
	m_pSampler = new CSampler(NumberCallback, (void*)this);

	if (m_pSampler == NULL)
		return E_FAIL;

	IDABehavior *pHookedBvr = NULL;
	hr = m_pSampler->Attach(pBvr, &pHookedBvr);
	if (FAILED(hr))
		return hr;

	// Add the behavior to the TIME element so it runs and samples
	hr = AddBehaviorToTIME( pHookedBvr, &m_lNumberCookie, NUMBERBVR_COOKIESET );
	ReleaseInterface(pHookedBvr);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::NumberCallback(void *thisPtr,
										   long	id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CNumberBvrTrack *pTrack = (CNumberBvrTrack*)thisPtr;
	bool firstSample = false;

	if( pTrack->m_lNumberId == -1 )
	{
		firstSample = true;
		pTrack->m_lNumberId = id;
	}

	//if this is a sample of an instance that we are not watching.
	if( pTrack->m_lNumberId != id )
		return S_OK;

	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;
		
	if (pTrack == NULL)
		return E_FAIL;

	return pTrack->ValueSampled(value, firstSample);
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::ValueSampled(double val, bool firstSample )
{
	HRESULT hr = S_OK;

	if (m_currVal != val || firstSample )
	{			
		m_currVal = val;

		// Value has changed, push it through
		::VariantClear( &m_varCurrentValue );

		if (m_bstrUnits == NULL || wcsicmp(m_bstrUnits, L"px") == 0)
		{
			// No units, set as R8	
			V_VT(&m_varCurrentValue) = VT_R8;
			V_R8(&m_varCurrentValue) = val;
		}
		else
		{
			// Set as BSTR with units appended.  Grrr.
			char buffer[1024];
			if (sprintf(buffer, "%f", val) >= 1)
			{
				CComBSTR stringVal(buffer);
				stringVal += m_bstrUnits;

				V_VT(&m_varCurrentValue) = VT_BSTR;
				V_BSTR(&m_varCurrentValue) = stringVal.Detach();
			}
			else
				return S_OK;
		}

		hr = UpdateOnValueState( value_change );

	}
	else
	{
		hr = UpdateOnValueState( value_no_change );
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::SwitchAccum(IDABehavior *pModifiable)
{
	HRESULT hr = S_OK;

	if (pModifiable == NULL)
		return E_FAIL;

	if (m_lAccumId != -1)
		hr = pModifiable->SwitchToNumber(m_currAccumVal);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult)
{
	HRESULT hr = S_OK;

	if (m_pAccumSampler != NULL)
	{
		m_pAccumSampler->Invalidate();
		m_pAccumSampler = NULL;
	}
	
	// We need to hook this behavior
	m_pAccumSampler = new CSampler(AccumNumberCallback, (void*)this);

	if (m_pAccumSampler == NULL)
		return E_FAIL;

	hr = m_pAccumSampler->Attach(pBvr, ppResult);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::AccumNumberCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CNumberBvrTrack *pTrack = (CNumberBvrTrack*)thisPtr;

	if( pTrack->m_lAccumId == -1 )
		pTrack->m_lAccumId = id;

	if( pTrack->m_lAccumId != id )
		return S_OK;


	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	if (pTrack == NULL)
		return E_FAIL;

	pTrack->m_currAccumVal = value;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::CreateInstance(CActorBvr     *pbvrActor,
                                           BSTR           bstrPropertyName,
                                           ActorBvrType   eType,
                                           CBvrTrack    **pptrackResult)
{
    DASSERT(NULL != pbvrActor);
    DASSERT(NULL != bstrPropertyName);
    DASSERT(NULL != pptrackResult);
    *pptrackResult = NULL;

    // Create the new bvr track
    CBvrTrack* ptrack = new CNumberBvrTrack(pbvrActor, eType);
    if (NULL == ptrack)
    {
        DPF_ERR("Insufficient memory to allocate a new number bvr track");
        return E_OUTOFMEMORY;
    }

    // Set the property name
    HRESULT hr = ptrack->SetPropertyName(bstrPropertyName);
    if (FAILED(hr))
    {
        DPF_ERR("Could not set the bvr track's property name");
        delete ptrack;
        return hr;
    }

    *pptrackResult = ptrack;
    return hr;
} // CreateInstance

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::Detach()
{
	HRESULT hr = S_OK;

	m_lNumberId = -1;
	m_lAccumId = -1;
	hr = RemoveBehaviorFromTIME( m_lNumberCookie, NUMBERBVR_COOKIESET );
	CheckHR( hr, "Failed to remove number behavior from time", end );

	hr = CBvrTrack::Detach();

  end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr )
{
	if( pvarValue == NULL || ppdabvr == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	VARIANT varValue;
	IDANumber *pdanum = NULL;

	::VariantInit( &varValue );

	//copy the incoming varaint
	hr = ::VariantCopy( &varValue, pvarValue );
	CheckHR( hr, "Failed to copy the variant", end );

	//if the type of the variant is a bstr
	if( V_VT( &varValue ) == VT_BSTR )
	{
		//strip the unit string off of the variant
		BSTR bstrVal = V_BSTR(&varValue);
		OLECHAR* pUnits;

		hr = Actor()->FindCSSUnits( bstrVal, &pUnits );
		if( SUCCEEDED(hr) && pUnits != NULL )
		{
			SysFreeString( m_bstrUnits );
			m_bstrUnits = SysAllocString( pUnits );
			
			(*pUnits) = L'\0';
			BSTR bstrNewVal = SysAllocString(bstrVal);
			V_BSTR(&varValue) = bstrNewVal;
			SysFreeString(bstrVal);
		}
	}

	

	//convert the unitless variant to a double
	hr = ::VariantChangeTypeEx( &varValue, &varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8 );
	CheckHR( hr, "Failed to change the type of the variant", end );

	//create a danumber from the converted value
	hr = Actor()->GetDAStatics()->DANumber( V_R8(&varValue), &pdanum );
	CheckHR( hr, "Failed to create a danumber for the variant", end );

	if (m_bstrUnits != NULL)
	{
		// See if we need to convert to degrees
		IDANumber *pConverted = NULL;
		hr = Actor()->ConvertToDegrees(pdanum, m_bstrUnits, &pConverted);

		if (SUCCEEDED(hr))
		{
			// This means that we did do a conversion, so grab the converted
			// and toss our units
			ReleaseInterface(pdanum);
			pdanum = pConverted;
			::SysFreeString(m_bstrUnits);
			m_bstrUnits = NULL;
		}
	}
	
	//return a bvr
	hr = pdanum->QueryInterface( IID_TO_PPV( IDABehavior, ppdabvr ) );
	CheckHR( hr, "QI for IDABehavior on IDANumber failed", end );

end:
	::VariantClear( &varValue );
	ReleaseInterface( pdanum );

	return hr;
}


//*****************************************************************************
//
// class CImageBvrTrack
//
//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::IdentityBvr(IDABehavior **ppdabvrIdentity)
{
    DASSERT(NULL != ppdabvrIdentity);
    *ppdabvrIdentity = NULL;

    IDAImage *pImage = NULL;
    HRESULT hr = Actor()->GetDAStatics()->get_EmptyImage(&pImage);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to create the image bvr's identity behavior");
        return hr;
    }

    *ppdabvrIdentity = pImage;
    return S_OK;
} // IdentityBvr

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::StaticBvr(IDABehavior **ppdabvrStatic)
{
	// This returns the Identity.  Usually an appropriate static will be passed in.

	return IdentityBvr(ppdabvrStatic);
} // StaticBvr

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::UninitBvr(IDABehavior **ppUninit)
{
	DASSERT(ppUninit != NULL);

	*ppUninit = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DAImage, 
								  NULL, 
								  CLSCTX_INPROC_SERVER, 
								  IID_IDABehavior, 
								  (void**)ppUninit);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to cocreate uninit image");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::ModifiableBvr( IDABehavior **ppModifiable )
{
	ReturnIfArgNull( ppModifiable );

	HRESULT hr = S_OK;

	(*ppModifiable) = NULL;

	IDAImage *pEmpty = NULL;

	hr = Actor()->GetDAStatics()->get_EmptyImage( &pEmpty );
	CheckHR( hr, "Failed to get the empty image from DA", end );

	hr = Actor()->GetDAStatics()->ModifiableBehavior( pEmpty, ppModifiable );
	CheckHR( hr, "Failed to create a modifiable image from the empty image", end );

end:
	ReleaseInterface( pEmpty );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::Compose(IDABehavior  *pdabvr1,
                                    IDABehavior  *pdabvr2,
                                    IDABehavior **ppdabvrResult)
{
    // Composition for image behaviors is defined as overlay
    DASSERT(NULL != pdabvr1);
    DASSERT(NULL != pdabvr2);
    DASSERT(NULL != ppdabvrResult);
    *ppdabvrResult = NULL;

    // Get the image behavior interfaces
    IDAImage* pImage1 = NULL;
    HRESULT hr = pdabvr1->QueryInterface(IID_TO_PPV(IDAImage, &pImage1));
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for IDAImage from bvr1 of image track's compose");

        return hr;
    }
    IDAImage* pImage2 = NULL;
    hr = pdabvr2->QueryInterface(IID_TO_PPV(IDAImage, &pImage2));
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for IDAImage from bvr2 of image track's compose");
        ReleaseInterface(pImage1);
        return hr;
    }

    // Now create an overlay behavior.
    IDAImage *pImageTemp = NULL;
    hr = Actor()->GetDAStatics()->Overlay(pImage1, pImage2, &pImageTemp);
    ReleaseInterface(pImage1);
    ReleaseInterface(pImage2);
    if (FAILED(hr))
    {
        DPF_ERR("Could not create the Overlay behavior in image track's compose");
        return hr;
    }

    *ppdabvrResult = pImageTemp;

    return S_OK;
} // Compose

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::ProcessBvr(IDABehavior *pOriginal,
								      ActorBvrFlags eFlags,
								      IDABehavior **ppResult)
{
	// If flag is set to e_ScaledImage, then scale it if there is a scale
	// matrix
	DASSERT(ppResult != NULL);
	*ppResult = NULL;

	HRESULT hr = S_OK;

	if (eFlags == e_ScaledImage && Actor()->m_pScale != NULL)
	{
		// Scale the image
		IDAImage *pImage = NULL;
		hr = pOriginal->QueryInterface(IID_TO_PPV(IDAImage, &pImage));
		if (FAILED(hr))
			return hr;

		IDAImage *pScaledImage = NULL;
		hr = pImage->Transform(Actor()->m_pScale, &pScaledImage);
		ReleaseInterface(pImage);
		if (FAILED(hr))
			return hr;

		*ppResult = pScaledImage;
	}
	else
	{
		// Just return original with no processing
		*ppResult = pOriginal;
		pOriginal->AddRef();
	}

	return S_OK;
}

//*****************************************************************************

HRESULT 
CActorBvr::CImageBvrTrack::ProcessIntermediate( IDABehavior *pOriginal,
                                                ActorBvrFlags eFlags,
								                IDABehavior **ppResult)
{
    if( pOriginal == NULL || ppResult == NULL )
        return E_INVALIDARG;

    HRESULT hr;

    IDAImage *pdaimgOriginal = NULL;
    IDAImage *pdaimgPrepared = NULL;

    hr = pOriginal->QueryInterface( IID_TO_PPV(IDAImage, &pdaimgOriginal));
    CheckHR( hr, "Failed to QI the incoming original for IDAImage", cleanup );

    hr = Actor()->PrepareImageForDXTransform( pdaimgOriginal, &pdaimgPrepared );
    CheckHR( hr, "Failed to prepare the image for a DX Transform", cleanup );

    hr = pdaimgPrepared->QueryInterface( IID_TO_PPV( IDABehavior, ppResult ) );
    CheckHR( hr, "Failed QI of image for IDABehavoir", cleanup );

cleanup:

    if( FAILED( hr ) )
    {
        *ppResult = NULL;
    }
    ReleaseInterface( pdaimgOriginal );
    ReleaseInterface( pdaimgPrepared );

    return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::CreateInstance(CActorBvr     *pbvrActor,
                                           BSTR           bstrPropertyName,
                                           ActorBvrType   eType,
                                           CBvrTrack    **pptrackResult)
{
    DASSERT(NULL != pbvrActor);
    DASSERT(NULL != pptrackResult);
    *pptrackResult = NULL;

    // Create the new bvr track
    CBvrTrack* ptrack = new CImageBvrTrack(pbvrActor, eType);
    if (NULL == ptrack)
    {
        DPF_ERR("Insufficient memory to allocate a new image bvr track");
        return E_OUTOFMEMORY;
    }

    // Set the property name
    HRESULT hr = ptrack->SetPropertyName(bstrPropertyName);
    if (FAILED(hr))
    {
        DPF_ERR("Could not set the bvr track's property name");
        delete ptrack;
        return hr;
    }

    *pptrackResult = ptrack;

    return hr;
} // CreateInstance

//*****************************************************************************
//
// class CColorBvrTrack
//
//*****************************************************************************

CActorBvr::CColorBvrTrack::CColorBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType)
:   CBvrTrack(pbvrActor, eType),
	m_pRedSampler(NULL),
	m_pGreenSampler(NULL),
	m_pBlueSampler(NULL),
	m_currRed(-1),
	m_currGreen(-1),
	m_currBlue(-1),
	m_newCount(0),
	m_lRedCookie(0),
	m_lGreenCookie(0),
	m_lBlueCookie(0),
	m_lColorId(-1),
	m_fFirstSample( true )
{
} // CColorBvrTrack

//*****************************************************************************

CActorBvr::CColorBvrTrack::~CColorBvrTrack()
{
	if (m_pRedSampler != NULL)
		m_pRedSampler->Invalidate();

	if (m_pGreenSampler != NULL)
		m_pGreenSampler->Invalidate();

	if (m_pBlueSampler != NULL)
		m_pBlueSampler->Invalidate();
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::IdentityBvr(IDABehavior **ppdabvrIdentity)
{
	HRESULT hr = S_OK;

    DASSERT(NULL != ppdabvrIdentity);
    *ppdabvrIdentity = NULL;

    // There is not really an identity for color (you cannot compose colors)
	// but in some situations we really need a color.  Return white just for the
	// fun of it
	IDAColor *pColor = NULL;

	hr = Actor()->GetDAStatics()->get_White(&pColor);
	if (FAILED(hr))
		return hr;

	*ppdabvrIdentity = pColor;

    return S_OK;
} // IdentityBvr

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::StaticBvr(IDABehavior **ppdabvrStatic)
{
    DASSERT(NULL != ppdabvrStatic);
    HRESULT hr = S_OK;
    *ppdabvrStatic = NULL;

	if( m_pModifiableStatic == NULL )
	{
		hr = UpdateStaticBvr();
	}

	if( SUCCEEDED( hr ) )
	{
		(*ppdabvrStatic) = m_pModifiableStatic;
		(*ppdabvrStatic)->AddRef();
	}
    else
    {
        // Need to return something
		return IdentityBvr(ppdabvrStatic);
    }

    return S_OK;
} // StaticBvr

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::UninitBvr(IDABehavior **ppUninit)
{
	DASSERT(ppUninit != NULL);

	*ppUninit = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DAColor, 
								  NULL, 
								  CLSCTX_INPROC_SERVER, 
								  IID_IDABehavior, 
								  (void**)ppUninit);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to cocreate uninit color");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::ModifiableBvr( IDABehavior **ppModifiable )
{
	ReturnIfArgNull( ppModifiable );

	HRESULT hr = S_OK;

	(*ppModifiable) = NULL;

	IDAColor *pRed = NULL;

	hr = Actor()->GetDAStatics()->get_Red( &pRed );
	CheckHR( hr, "Failed to get red from da", end );

	hr = Actor()->GetDAStatics()->ModifiableBehavior( pRed, ppModifiable );
	CheckHR( hr, "Failed to create a modifiable behavior for a color track", end );

end:
	ReleaseInterface( pRed );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::Compose(IDABehavior  *pdabvr1,
                                    IDABehavior  *pdabvr2,
                                    IDABehavior **ppdabvrResult)
{
	// Cannot compose Colors

    return E_NOTIMPL;
} // Compose

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::HookBvr(IDABehavior *pBvr)
{
	HRESULT hr = S_OK;

	// We need to hook this behavior
	m_pRedSampler = new CSampler(RedCallback, (void*)this);
	m_pGreenSampler = new CSampler(GreenCallback, (void*)this);
	m_pBlueSampler = new CSampler(BlueCallback, (void*)this);

	if (m_pRedSampler == NULL || m_pGreenSampler == NULL || m_pBlueSampler == NULL)
		return E_FAIL;

	IDAColor *pColor = NULL;
	hr = pBvr->QueryInterface(IID_TO_PPV(IDAColor, &pColor));
	if (FAILED(hr))
		return hr;

	IDANumber *pNumber = NULL;
	IDABehavior *pHooked = NULL;

	// Hook Red
	pColor->get_Red(&pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = m_pRedSampler->Attach(pNumber, &pHooked);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = AddBehaviorToTIME( pHooked, &m_lRedCookie, REDBVR_COOKIESET );
	ReleaseInterface(pHooked);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}

	// Hook Green
	pColor->get_Green(&pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = m_pGreenSampler->Attach(pNumber, &pHooked);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = AddBehaviorToTIME( pHooked, &m_lGreenCookie, GREENBVR_COOKIESET );
	ReleaseInterface(pHooked);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}

	// Hook Blue
	pColor->get_Blue(&pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = m_pBlueSampler->Attach(pNumber, &pHooked);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = AddBehaviorToTIME( pHooked, &m_lBlueCookie, BLUEBVR_COOKIESET );
	ReleaseInterface(pHooked);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}

	ReleaseInterface(pColor);

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::RedCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CColorBvrTrack *pTrack = (CColorBvrTrack*)thisPtr;

	if( pTrack->m_lColorId == -1 )
	{
		pTrack->m_fFirstSample = true;
		pTrack->m_lColorId = id;
	}

	if( pTrack->m_lColorId != id )
		return S_OK;
	

	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	return pTrack->SetNewValue(value, &(pTrack->m_newRed) );
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::GreenCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CColorBvrTrack *pTrack = (CColorBvrTrack*)thisPtr;

	if( pTrack->m_lColorId == -1 )
	{
		pTrack->m_fFirstSample = true;
		pTrack->m_lColorId = id;
	}

	if( pTrack->m_lColorId != id )
		return S_OK;


	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	return pTrack->SetNewValue(value, &(pTrack->m_newGreen) );
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::BlueCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CColorBvrTrack *pTrack = (CColorBvrTrack*)thisPtr;

	if( pTrack->m_lColorId == -1 )
	{
		pTrack->m_fFirstSample = true;
		pTrack->m_lColorId = id;
	}

	if( pTrack->m_lColorId != id )
		return S_OK;


	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	return pTrack->SetNewValue(value, &(pTrack->m_newBlue) );
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::SetNewValue(double value, short *pNew )
{
	*pNew = (short)(value * 255.0);

	// Need to count up to three Sets

	m_newCount++;

	if (m_newCount == 3)
	{
		m_newCount = 0;

		HRESULT hr = ValueSampled(m_newRed, m_newGreen, m_newBlue, m_fFirstSample );

		m_fFirstSample = false;

		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::ValueSampled(short red, short green, short blue, bool fFirstSample )
{
	HRESULT hr = S_OK;

	if (m_currRed != red || m_currGreen != green || m_currBlue != blue || fFirstSample )
	{
		m_currRed = red;
		m_currGreen = green;
		m_currBlue = blue;

		short nRed =	(red<0)	? 0 :	((red>255) ? 255 :red);
		short nGreen =	(green<0) ? 0 : ((green>255) ? 255 : green);
		short nBlue =	(blue<0) ? 0 :	((blue>255) ? 255 : blue);

		::VariantClear( &m_varCurrentValue );

		// Value has changed, push it through
		V_VT(&m_varCurrentValue) = VT_BSTR;
		V_BSTR(&m_varCurrentValue) = ::SysAllocStringLen(NULL, 7); 

		m_varCurrentValue.bstrVal[0] = L'#';
		m_varCurrentValue.bstrVal[1] = HexChar(nRed >> 4);
		m_varCurrentValue.bstrVal[2] = HexChar(nRed & 0xf);
		m_varCurrentValue.bstrVal[3] = HexChar(nGreen >> 4);
		m_varCurrentValue.bstrVal[4] = HexChar(nGreen & 0xf);
		m_varCurrentValue.bstrVal[5] = HexChar(nBlue >> 4);
		m_varCurrentValue.bstrVal[6] = HexChar(nBlue & 0xf);

		hr = UpdateOnValueState( value_change );
	}
	else
	{
		hr = UpdateOnValueState( value_no_change );
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::SwitchAccum(IDABehavior *pModifiable)
{
	HRESULT hr = S_OK;

	if (pModifiable == NULL)
		return E_FAIL;

	if (m_lColorId != -1)
	{
		IDAColor *pColor = NULL;
		hr = Actor()->GetDAStatics()->ColorRgb255(m_currRed, m_currGreen, m_currBlue, &pColor);
		if (FAILED(hr))
			return hr;

		hr = pModifiable->SwitchTo(pColor);
		ReleaseInterface(pColor);
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult)
{
	*ppResult = pBvr;
	pBvr->AddRef();

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::CreateInstance(CActorBvr     *pbvrActor,
                                           BSTR           bstrPropertyName,
                                           ActorBvrType   eType,
                                           CBvrTrack    **pptrackResult)
{
    DASSERT(NULL != pbvrActor);
    DASSERT(NULL != pptrackResult);
    *pptrackResult = NULL;

    // Create the new bvr track
    CBvrTrack* ptrack = new CColorBvrTrack(pbvrActor, eType);
    if (NULL == ptrack)
    {
        DPF_ERR("Insufficient memory to allocate a new color bvr track");
        return E_OUTOFMEMORY;
    }

    // Set the property name
    HRESULT hr = ptrack->SetPropertyName(bstrPropertyName);
    if (FAILED(hr))
    {
        DPF_ERR("Could not set the bvr track's property name");
        delete ptrack;
        return hr;
    }

    *pptrackResult = ptrack;

    return hr;
} // CreateInstance

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::Detach()
{
	HRESULT hr = S_OK;

	hr = RemoveBehaviorFromTIME( m_lRedCookie, REDBVR_COOKIESET );
	CheckHR( hr, "Failed to remove the red behaivor from time in detach", end );

	hr = RemoveBehaviorFromTIME( m_lGreenCookie, GREENBVR_COOKIESET );
	CheckHR( hr, "Failed to remove the green behaivor from time in detach", end );

	hr = RemoveBehaviorFromTIME( m_lBlueCookie, BLUEBVR_COOKIESET );
	CheckHR( hr, "Failed to remove the blue behaivor from time in detach", end );

	m_lColorId = -1;
	
	hr = CBvrTrack::Detach();

  end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr )
{
	if( pvarValue == NULL || ppdabvr == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	VARIANT varValue;
	DWORD color = 0;
	float colorH = 0.0; 
	float colorS = 0.0;
	float colorL = 0.0;
	IDAColor *pColor = NULL;

	VariantInit( &varValue );

	
	hr = VariantChangeTypeEx(&varValue, pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
	CheckHR( hr, "Could not get color property as string", end );
	
	color = CUtils::GetColorFromVariant(&varValue);

	if (color == PROPERTY_INVALIDCOLOR)
	{
		DPF_ERR("Could not translate property into color value");
		hr = E_FAIL;
		goto end;
	}

    CUtils::GetHSLValue(color, &colorH, &colorS, &colorL);

	hr = CDAUtils::BuildDAColorFromStaticHSL( Actor()->GetDAStatics(), colorH, colorS, colorL, &pColor);
	CheckHR( hr, "Failed to build DA color from HSL", end );

	hr = pColor->QueryInterface( IID_TO_PPV( IDABehavior, ppdabvr ) );
	CheckHR( hr, "Failed to get the dabehavior from the color bvr", end );
	
end:
	ReleaseInterface( pColor );

	VariantClear( &varValue );

    return S_OK;

}


//*****************************************************************************
//
// class CStringBvrTrack
//
//*****************************************************************************

CActorBvr::CStringBvrTrack::CStringBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType)
:   CBvrTrack(pbvrActor, eType),
	m_pEmptyString(NULL),
	m_pSampler(NULL),
	m_bstrCurrValue(NULL),
	m_lStringCookie(0),
	m_lStringId(-1)
{
}

//*****************************************************************************

CActorBvr::CStringBvrTrack::~CStringBvrTrack()
{
	ReleaseInterface(m_pEmptyString);

	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}
	
	if (m_bstrCurrValue != NULL)
		::SysFreeString(m_bstrCurrValue);
}

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::IdentityBvr(IDABehavior **ppdabvrIdentity)
{
    DASSERT(NULL != ppdabvrIdentity);
    *ppdabvrIdentity = NULL;

	HRESULT hr = E_FAIL;

    if (m_pEmptyString == NULL)
	{
		CComBSTR empty = L"";

		hr = Actor()->GetDAStatics()->DAString(empty, &m_pEmptyString);

		if (FAILED(hr))
		{
			m_pEmptyString = NULL;
			DPF_ERR("Failed to create empty string");
			return hr;
		}
	}

	*ppdabvrIdentity = m_pEmptyString;
	m_pEmptyString->AddRef();

    return S_OK;
} // IdentityBvr

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::StaticBvr(IDABehavior **ppdabvrStatic)
{
    DASSERT(NULL != ppdabvrStatic);
    HRESULT hr = S_OK;
    *ppdabvrStatic = NULL;

	if( m_pModifiableStatic == NULL )
	{
		hr = UpdateStaticBvr();
	}

	if( SUCCEEDED( hr ) )
	{
		(*ppdabvrStatic) = m_pModifiableStatic;
		(*ppdabvrStatic)->AddRef();
	}
	else
	{
		return IdentityBvr( ppdabvrStatic );
	}
		

	return S_OK;
} // StaticBvr

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::Compose(IDABehavior  *pdabvr1,
                                    IDABehavior  *pdabvr2,
                                    IDABehavior **ppdabvrResult)
{
	// Cannot compose Strings

	// TODO (markhal): Potentially do composition as concatenation

    return E_NOTIMPL;
} // Compose

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::HookBvr(IDABehavior *pBvr)
{
	HRESULT hr = S_OK;

	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}

	// We need to hook this behavior
	m_pSampler = new CSampler(StringCallback, (void*)this);

	if (m_pSampler == NULL)
		return E_FAIL;

	IDABehavior *pHookedBvr = NULL;
	hr = m_pSampler->Attach(pBvr, &pHookedBvr);
	if (FAILED(hr))
		return hr;

	// Add the behavior to the TIME element so it runs and samples
	hr = AddBehaviorToTIME( pHookedBvr, &m_lStringCookie, STRINGBVR_COOKIESET );
	ReleaseInterface(pHookedBvr);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::StringCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	if( thisPtr == NULL )
		return E_INVALIDARG;
		
	HRESULT hr = S_OK;

	CStringBvrTrack *pTrack = (CStringBvrTrack*)thisPtr;

	bool fFirstSample = false;

	if( pTrack->m_lStringId == -1 )
	{
		pTrack->m_lStringId = id;
		fFirstSample = true;
	}

	if( pTrack->m_lStringId != id )
		return S_OK;

	IDAString *pString = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDAString, &pString));
	if (FAILED(hr))
		return hr;

	BSTR value;
	hr = pString->Extract(&value);
	ReleaseInterface(pString);
	if (FAILED(hr))
		return hr;

	if (pTrack == NULL)
		return E_FAIL;

	hr = pTrack->ValueSampled( value, fFirstSample );

	::SysFreeString(value);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::ValueSampled(BSTR val, bool fFirstSample )
{
	HRESULT hr = S_OK;

	if (m_bstrCurrValue == NULL || wcscmp(val, m_bstrCurrValue) != 0 || fFirstSample )
	{
		if (m_bstrCurrValue != NULL)
			::SysFreeString(m_bstrCurrValue);

		m_bstrCurrValue = ::SysAllocString(val);

		// Value has changed, push it through
		::VariantClear( &m_varCurrentValue );
		V_VT(&m_varCurrentValue) = VT_BSTR;
		V_BSTR(&m_varCurrentValue) = ::SysAllocString(val); 

		hr = UpdateOnValueState( value_change );
	}
	else
	{
		hr = UpdateOnValueState( value_no_change );
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::CreateInstance(CActorBvr     *pbvrActor,
                                           BSTR           bstrPropertyName,
                                           ActorBvrType   eType,
                                           CBvrTrack    **pptrackResult)
{
    DASSERT(NULL != pbvrActor);
    DASSERT(NULL != pptrackResult);
    *pptrackResult = NULL;

    // Create the new bvr track
    CBvrTrack* ptrack = new CStringBvrTrack(pbvrActor, eType);
    if (NULL == ptrack)
    {
        DPF_ERR("Insufficient memory to allocate a new string bvr track");
        return E_OUTOFMEMORY;
    }

    // Set the property name
    HRESULT hr = ptrack->SetPropertyName(bstrPropertyName);
    if (FAILED(hr))
    {
        DPF_ERR("Could not set the bvr track's property name");
        delete ptrack;
        return hr;
    }

    *pptrackResult = ptrack;

    return hr;
} // CreateInstance

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::Detach()
{
	HRESULT hr = S_OK;

	m_lStringId = -1;
	hr = RemoveBehaviorFromTIME( m_lStringCookie, STRINGBVR_COOKIESET );
	CheckHR( hr, "Could not remove the string bvr from time in detach", end );
	
	hr = CBvrTrack::Detach();
	
  end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr)
{
	if( pvarValue == NULL || ppdabvr == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	VARIANT varString;
	IDAString *pdastr = NULL;

	::VariantInit( &varString );

	hr = ::VariantChangeTypeEx( &varString, pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR );
	CheckHR( hr, "Failed to change the type of the variant to a string", end );

	hr = Actor()->GetDAStatics()->DAString( V_BSTR( &varString ), &pdastr );
	CheckHR( hr, "Failed to create a da string from the variant", end );

	hr = pdastr->QueryInterface( IID_TO_PPV( IDABehavior, ppdabvr ) );
	CheckHR( hr, "Failed to QI final string for IDABehavior", end );

end:
	::VariantClear( &varString );
	ReleaseInterface( pdastr );

	return hr;
}


//*****************************************************************************
//
// class CFloatManager
//
//*****************************************************************************

CActorBvr::CFloatManager::CFloatManager(CActorBvr *pActor)
:	m_pActor(pActor),
	m_pFilter(NULL),
	m_pElement(NULL),
	m_pElement2(NULL),
	m_pWidthSampler(NULL),
	m_pHeightSampler(NULL),
	m_currWidth(0),
	m_currHeight(0),
	m_origWidth(0),
	m_origHeight(0),
	m_origLeft(-1),
	m_origTop(-1),
	m_lWidthCookie(0),
	m_lHeightCookie(0)
{
}

CActorBvr::CFloatManager::~CFloatManager()
{
	ReleaseInterface(m_pFilter);
	ReleaseInterface(m_pElement);
	ReleaseInterface(m_pElement2);

	if (m_pWidthSampler != NULL)
		m_pWidthSampler->Invalidate();

	if (m_pHeightSampler != NULL)
		m_pHeightSampler->Invalidate();
}

HRESULT
CActorBvr::CFloatManager::GetElement(IHTMLElement **ppElement)
{
	DASSERT(ppElement != NULL);
	*ppElement = NULL;

	if (m_pElement == NULL)
	{
		// Create the floating element using markup services
		HRESULT hr = E_FAIL;

		// Get animated element
		IHTMLElement *pAnimatedElement;
		hr = m_pActor->GetAnimatedElement( &pAnimatedElement );
		if (FAILED( hr ))
		{
			DPF_ERR("Error getting element to animate");
			return hr;
		}

		// Get document
		IDispatch *pDocumentDisp;
		hr = pAnimatedElement->get_document(&pDocumentDisp);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get document");
			return hr;
		}

		// Query for markup services
		IMarkupServices *pMarkupServices = NULL;
		hr = pDocumentDisp->QueryInterface(IID_TO_PPV(IMarkupServices, &pMarkupServices));
		ReleaseInterface(pDocumentDisp);
		if (FAILED(hr))
		{
			ReleaseInterface(pAnimatedElement);
			return hr;
		}

		// Create a div
		IHTMLElement *pElement = NULL;
		hr = pMarkupServices->CreateElement(TAGID_DIV, L"style=position:absolute;background-color:green;border:1 solid black", &pElement);
		if (FAILED(hr))
		{
			m_pElement = NULL;
			ReleaseInterface(pMarkupServices);
			ReleaseInterface(pAnimatedElement);
			return hr;
		}

		// Position a pointer after the animated element
		IMarkupPointer *pPointer = NULL;
		hr = pMarkupServices->CreateMarkupPointer(&pPointer);
		if (FAILED(hr))
		{
			ReleaseInterface(pMarkupServices);
			ReleaseInterface(pAnimatedElement);
			ReleaseInterface(pElement);
			return hr;
		}

		hr = pPointer->MoveAdjacentToElement(pAnimatedElement, ELEM_ADJ_BeforeBegin);
		ReleaseInterface(pAnimatedElement);
		if (FAILED(hr))
		{
			ReleaseInterface(pMarkupServices);
			ReleaseInterface(pElement);
			return hr;
		}

		// Insert the new element
		hr = pMarkupServices->InsertElement(pElement, pPointer, NULL);
		ReleaseInterface(pPointer);
		ReleaseInterface(pMarkupServices);
		if (FAILED(hr))
		{
			ReleaseInterface(pElement);
			return hr;
		}

		// Succeeded
		m_pElement = pElement;
		pElement = NULL;

		hr = m_pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &m_pElement2));
		if (FAILED(hr))
			return hr;

		// Make sure we are in sync with zIndex, visibility, display
		UpdateZIndex();
		UpdateVisibility();
		UpdateDisplay();

		// Make sure we are in sync with width and height
		UpdateRect(m_pActor->m_pixelLeft,
				   m_pActor->m_pixelTop,
				   m_pActor->m_pixelWidth,
				   m_pActor->m_pixelHeight);
	}

	*ppElement = m_pElement;
	m_pElement->AddRef();

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::GetFilter(IDispatch **ppFilter)
{
	HRESULT hr = S_OK;

	*ppFilter = NULL;

	if (m_pFilter == NULL)
	{
		// Get the float element
		IHTMLElement *pElement = NULL;
		hr = GetElement(&pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get float element");
			return hr;
		}

		// Get a filter from it
		hr = m_pActor->GetElementFilter(pElement, &m_pFilter);
		ReleaseInterface(pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get filter");
			return hr;
		}
	}

	*ppFilter = m_pFilter;
	m_pFilter->AddRef();

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::Detach()
{
	if (m_pFilter != NULL)
		m_pActor->SetElementOnFilter(m_pFilter, NULL);
	
	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::ApplyImageBvr(IDAImage *pImage)
{
	DASSERT(pImage != NULL);

	HRESULT hr = S_OK;

	//if we have already added a sampled witdth to time
	if( m_lWidthCookie != 0 )
	{
		//remove the sampled value from time.
		hr = m_pActor->RemoveBehaviorFromTIME( m_lWidthCookie );
		if( FAILED( hr ) )
		{
			return hr;
		}

		m_pWidthSampler->Invalidate();
		m_pWidthSampler = NULL;

		m_lWidthCookie = 0;
	}

	//if we have already added a sampled height to time
	if( m_lHeightCookie != 0 )
	{
		//remove th esampled value from time.
		hr = m_pActor->RemoveBehaviorFromTIME( m_lHeightCookie );
		if( FAILED( hr ) )
		{
			return hr;
		}

		m_pHeightSampler->Invalidate();
		m_pHeightSampler = NULL;

		m_lHeightCookie = 0;
	}

	// Attach image to TIME element but disable rendering
	hr = m_pActor->AddImageToTIME(m_pActor->GetHTMLElement(), pImage, false);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to apply image to element");
		return hr;
	}

	// Set original element on filter
	IDispatch *pFilter = NULL;
	hr = GetFilter(&pFilter);
	if (FAILED(hr))
		return hr;

	hr = m_pActor->SetElementOnFilter(pFilter, m_pActor->GetHTMLElement());
	ReleaseInterface(pFilter);
	if (FAILED(hr))
		return hr;

	// Observe width and height of image
	// Get bounding box
	IDABbox2 *pBbox = NULL;
	hr = pImage->get_BoundingBox(&pBbox);
	if (FAILED(hr))
		return hr;

	// Get max and min
	IDAPoint2 *pMin = NULL;
	IDAPoint2 *pMax = NULL;
	hr = pBbox->get_Min(&pMin);
	if (FAILED(hr))
	{
		ReleaseInterface(pBbox);
		return hr;
	}

	hr = pBbox->get_Max(&pMax);
	ReleaseInterface(pBbox);
	if (FAILED(hr))
	{
		ReleaseInterface(pMin);
		return hr;
	}

	// Get diff
	IDAVector2 *pDiff = NULL;
	hr = m_pActor->GetDAStatics()->SubPoint2(pMax, pMin, &pDiff);
	ReleaseInterface(pMax);
	ReleaseInterface(pMin);
	if (FAILED(hr))
		return hr;

	// Scale into pixels
	IDANumber *pPixel = NULL;
	hr = m_pActor->GetDAStatics()->get_Pixel(&pPixel);
	if (FAILED(hr))
	{
		ReleaseInterface(pDiff);
		return hr;
	}

	IDAVector2 *pTemp = NULL;
	hr = pDiff->DivAnim(pPixel, &pTemp);
	ReleaseInterface(pDiff);
	ReleaseInterface(pPixel);
	if (FAILED(hr))
		return hr;
	pDiff = pTemp;
	pTemp = NULL;

	// Get width
	IDANumber *pWidth = NULL;
	hr = pDiff->get_X(&pWidth);
	if (FAILED(hr))
	{
		ReleaseInterface(pDiff);
		return hr;
	}

	
	
	// Hook it
	hr = HookBvr(pWidth, widthCallback, &m_pWidthSampler, &m_lWidthCookie);
	ReleaseInterface(pWidth);
	if (FAILED(hr))
	{
		ReleaseInterface(pDiff);
		return hr;
	}

	// Get height
	IDANumber *pHeight = NULL;
	hr = pDiff->get_Y(&pHeight);
	ReleaseInterface(pDiff);
	if (FAILED(hr))
		return hr;

	// Hook it
	hr = HookBvr(pHeight, heightCallback, &m_pHeightSampler, &m_lHeightCookie);
	ReleaseInterface(pHeight);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::HookBvr(IDABehavior *pBvr,
								  SampleCallback callback,
								  CSampler **ppSampler,
								  long *plCookie)
{
	if( plCookie == NULL )
		return E_INVALIDARG;
	HRESULT hr = S_OK;

	// Create sampler for height
	if (*ppSampler == NULL)
	{
		*ppSampler = new CSampler(callback, (void*)this);

		if (*ppSampler == NULL)
			return E_FAIL;
	}

	// Ask it to hook the bvr
	IDABehavior *pHookedBvr = NULL;
	hr = (*ppSampler)->Attach(pBvr, &pHookedBvr);
	if (FAILED(hr))
		return hr;

	// Add the behavior to the TIME element so it runs and samples
	hr = m_pActor->AddBehaviorToTIME(pHookedBvr, plCookie);
	ReleaseInterface(pHookedBvr);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::UpdateElementRect()
{
	HRESULT hr = S_OK;

	if( m_currWidth == -HUGE_VAL || m_currHeight == -HUGE_VAL )
		return S_OK;


	// Get style
	IHTMLStyle *pStyle = NULL;
	hr = m_pElement2->get_runtimeStyle(&pStyle);
	if (FAILED(hr))
		return hr;

	// Ignore errors
	pStyle->put_pixelLeft((long)((m_origLeft + ((double)m_origWidth)/2 - m_currWidth/2) + .5));
	pStyle->put_pixelTop((long)((m_origTop + ((double)m_origHeight)/2 - m_currHeight/2) + .5));
	pStyle->put_pixelWidth((long)(m_currWidth + .5));
	pStyle->put_pixelHeight((long)(m_currHeight + .5));

	ReleaseInterface(pStyle);

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::UpdateRect(long left, long top, long width, long height)
{
	m_origLeft = left;
	m_origTop = top;
	m_origWidth = width;
	m_origHeight = height;

	return UpdateElementRect();
}

HRESULT
CActorBvr::CFloatManager::UpdateZIndex()
{
	HRESULT hr = S_OK;

	if (m_pElement2 == NULL)
		return S_OK;

	// Get the current style for the animated element
	IHTMLElement *pElement = NULL;
	hr = m_pActor->GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;

	IHTMLCurrentStyle *pCurrStyle = NULL;
	hr = m_pActor->GetCurrentStyle(pElement, &pCurrStyle);
	ReleaseInterface(pElement);
	if (FAILED(hr))
		return hr;

	// Get the zIndex
	VARIANT varValue;
	VariantInit(&varValue);
	hr = pCurrStyle->get_zIndex(&varValue);
	ReleaseInterface(pCurrStyle);
	if (FAILED(hr))
		return hr;

	// Get the runtime style
	IHTMLStyle *pStyle = NULL;
	hr = m_pElement2->get_runtimeStyle(&pStyle);
	if (FAILED(hr))
	{
		VariantClear(&varValue);
		return hr;
	}

	// Set the zIndex on it
	hr = pStyle->put_zIndex(varValue);
	VariantClear(&varValue);
	if (FAILED(hr))
	{
		// There is currently a bug in IE that if you set zIndex to auto
		// this fails.  Since this is a primary use case, we're going to have
		// to hack it to set it to 0 at this point.  When the bug in IE is
		// fixed this code will never get hit
		V_VT(&varValue) = VT_I4;
		V_I4(&varValue) = 0;
		hr = pStyle->put_zIndex(varValue);
		VariantClear(&varValue);
		if (FAILED(hr))
			return hr;
	}	
	ReleaseInterface(pStyle);

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::UpdateVisibility()
{
	HRESULT hr = S_OK;

	if (m_pElement2 == NULL)
		return S_OK;

	// Get the current style for the animated element
	IHTMLElement *pElement = NULL;
	hr = m_pActor->GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;

	IHTMLCurrentStyle *pCurrStyle = NULL;
	hr = m_pActor->GetCurrentStyle(pElement, &pCurrStyle);
	ReleaseInterface(pElement);
	if (FAILED(hr))
		return hr;

	// Get the visibility
	BSTR bstrVal;
	hr = pCurrStyle->get_visibility(&bstrVal);
	ReleaseInterface(pCurrStyle);
	if (FAILED(hr))
		return hr;

	// Get the runtime style
	IHTMLStyle *pStyle = NULL;
	hr = m_pElement2->get_runtimeStyle(&pStyle);
	if (FAILED(hr))
	{
		::SysFreeString(bstrVal);
		return hr;
	}

	// Set the visibility on it
	hr = pStyle->put_visibility(bstrVal);
	ReleaseInterface(pStyle);
	::SysFreeString(bstrVal);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::UpdateDisplay()
{
	HRESULT hr = S_OK;

	if (m_pElement2 == NULL)
		return S_OK;

	// Get the current style for the animated element
	IHTMLElement *pElement = NULL;
	hr = m_pActor->GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;

	IHTMLCurrentStyle *pCurrStyle = NULL;
	hr = m_pActor->GetCurrentStyle(pElement, &pCurrStyle);
	ReleaseInterface(pElement);
	if (FAILED(hr))
		return hr;

	// Get the display
	BSTR bstrVal;
	hr = pCurrStyle->get_display(&bstrVal);
	ReleaseInterface(pCurrStyle);
	if (FAILED(hr))
		return hr;

	// Get the runtime style
	IHTMLStyle *pStyle = NULL;
	hr = m_pElement2->get_runtimeStyle(&pStyle);
	if (FAILED(hr))
	{
		::SysFreeString(bstrVal);
		return hr;
	}

	// Set the visibility on it
	hr = pStyle->put_display(bstrVal);
	ReleaseInterface(pStyle);
	::SysFreeString(bstrVal);
	if (FAILED(hr))
		return hr;

	return S_OK;
}



HRESULT
CActorBvr::CFloatManager::widthCallback(void *thisPtr,
										long id,
										double startTime,
										double globalNow,
										double localNow,
										IDABehavior * sampleVal,
										IDABehavior **ppReturn)
{
	IDANumber *pNumber = NULL;
	HRESULT hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double val = 0;
	hr = pNumber->Extract(&val);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	CFloatManager *pManager = (CFloatManager*)thisPtr;

	if (val != pManager->m_currWidth)
	{
		pManager->m_currWidth = val;

		pManager->UpdateElementRect();
	}

	return S_OK;
}
 
HRESULT
CActorBvr::CFloatManager::heightCallback(void *thisPtr,
										long id,
										double startTime,
										double globalNow,
										double localNow,
										IDABehavior * sampleVal,
										IDABehavior **ppReturn)
{
	IDANumber *pNumber = NULL;
	HRESULT hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double val = 0;
	hr = pNumber->Extract(&val);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	CFloatManager *pManager = (CFloatManager*)thisPtr;

	if (val != pManager->m_currHeight)
	{
		pManager->m_currHeight = val;

		pManager->UpdateElementRect();
	}

	return S_OK;
}

//*****************************************************************************
//
// class CImageInfo
//
//*****************************************************************************

CActorBvr::CImageInfo::CImageInfo( IDA2Image* pdaimg2Cropped, 
								   IDA2Behavior* pdabvrSwitchable )
:	m_pdaimg2Cropped( pdaimg2Cropped ),
	m_pdabvr2Switchable( pdabvrSwitchable ),
	m_pNext( NULL )
{
	m_pdaimg2Cropped->AddRef();
	m_pdabvr2Switchable->AddRef();
}

//*****************************************************************************

CActorBvr::CImageInfo::~CImageInfo()
{
	ReleaseInterface( m_pdaimg2Cropped );
	ReleaseInterface( m_pdabvr2Switchable );
}


//*****************************************************************************
//
// class CFinalDimensionSampler
//
//*****************************************************************************
CActorBvr::CFinalDimensionSampler::CFinalDimensionSampler( CActorBvr* pParent )
:
m_pActor( pParent ),
m_pFinalWidthSampler( NULL ),
m_pFinalHeightSampler( NULL ),
m_lFinalWidthId(-1),
m_lFinalHeightId(-1),
m_fFinalWidthSampled( false ),
m_fFinalHeightSampled( false ),
m_dLastFinalWidthValue( -1.0 ),
m_dLastFinalHeightValue( -1.0 ),
m_fFinalDimensionChanged( true ),
m_lWidthCookie(0),
m_lHeightCookie(0)
{
	DASSERT(pParent != NULL );
}

//*****************************************************************************

CActorBvr::CFinalDimensionSampler::~CFinalDimensionSampler( )
{	
	Detach();
}

//*****************************************************************************

HRESULT
CActorBvr::CFinalDimensionSampler::Attach( IDANumber* pFinalWidth, IDANumber* pFinalHeight )
{

	if( pFinalWidth == NULL || pFinalHeight == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	IDABehavior *pbvrHooked = NULL;

	//hook the final width behavior
	m_pFinalWidthSampler = new CSampler( FinalWidthCallback, reinterpret_cast<void*>(this) );
	if( m_pFinalWidthSampler == NULL )
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	hr = m_pFinalWidthSampler->Attach( pFinalWidth, &pbvrHooked );
	CheckHR( hr, "Failed to hook the final width", cleanup );

	hr = m_pActor->AddBehaviorToTIME( pbvrHooked, &m_lWidthCookie );
	ReleaseInterface( pbvrHooked );
	CheckHR( hr, "Failed to add hooked final width behaivor to time", cleanup );

	//hook the final height behavior

	m_pFinalHeightSampler = new CSampler( FinalHeightCallback, reinterpret_cast<void*>(this) );
	if( m_pFinalHeightSampler == NULL )
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	hr = m_pFinalHeightSampler->Attach( pFinalHeight, &pbvrHooked );
	CheckHR( hr, "Failed to hook the final Height", cleanup );

	hr = m_pActor->AddBehaviorToTIME( pbvrHooked, &m_lHeightCookie );
	ReleaseInterface( pbvrHooked );
	CheckHR( hr, "Failed to add hooked final Height behaivor to time", cleanup );

cleanup:
	if( FAILED( hr ) )
	{
		Detach();
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CFinalDimensionSampler::Detach()
{
	m_lFinalWidthId = -1;
	m_lFinalHeightId = -1;
	if( m_pFinalWidthSampler != NULL )
	{
		m_pFinalWidthSampler->Invalidate();
		m_pFinalWidthSampler = NULL;
	}

	if( m_pFinalHeightSampler != NULL )
	{
		m_pFinalHeightSampler->Invalidate();
		m_pFinalHeightSampler = NULL;
	}
	
	return S_OK;
}

//*****************************************************************************


HRESULT
CActorBvr::CFinalDimensionSampler::CollectFinalDimensionSamples( )
{
	if( m_fFinalWidthSampled && m_fFinalHeightSampled )
	{
		m_fFinalWidthSampled = false;
		m_fFinalHeightSampled = false;
		if( m_fFinalDimensionChanged )
		{
			m_fFinalDimensionChanged = false;
			return m_pActor->SetRenderResolution( m_dLastFinalWidthValue, m_dLastFinalHeightValue );
		}
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CFinalDimensionSampler::FinalWidthCallback(void *thisPtr,
							  long id,
   						      double startTime,
						      double globalNow,
						      double localNow,
						      IDABehavior * sampleVal,
						      IDABehavior **ppReturn)
{
	if( thisPtr == NULL || sampleVal == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	//cast the this pointer
	CFinalDimensionSampler *pThis = reinterpret_cast<CFinalDimensionSampler*>(thisPtr);

	bool fFirstSample = false;

	if( pThis->m_lFinalWidthId == -1 )
	{
		pThis->m_lFinalWidthId = id;
		fFirstSample = true;
	}

	if( pThis->m_lFinalWidthId != id )
		return S_OK;

	//extract the current value from the sample
	IDANumber *pdanumCurrVal = NULL;
	hr = sampleVal->QueryInterface( IID_TO_PPV( IDANumber, &pdanumCurrVal ) );
	CheckHR( hr, "Failed to QI the sample val for IDANubmer", cleanup );

	double currVal;
	hr = pdanumCurrVal->Extract(&currVal);
	ReleaseInterface( pdanumCurrVal );
	CheckHR( hr, "Failed to extract the current value from the sampled behavior", cleanup );

	//if the value has changed mark for update
	if( pThis->m_dLastFinalWidthValue != currVal || fFirstSample )
	{
		pThis->m_dLastFinalWidthValue = currVal;
		pThis->m_fFinalDimensionChanged = true;

	}

	pThis->m_fFinalWidthSampled = true;

	//collect samples
	pThis->CollectFinalDimensionSamples();

cleanup:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CFinalDimensionSampler::FinalHeightCallback(void *thisPtr,
					long id,
					double startTime,
					double globalNow,
					double localNow,
					IDABehavior * sampleVal,
					IDABehavior **ppReturn)
{
	if( thisPtr == NULL || sampleVal == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	//cast the this pointer
	CFinalDimensionSampler *pThis = reinterpret_cast<CFinalDimensionSampler*>(thisPtr);

	bool fFirstSample = false;

	if( pThis->m_lFinalHeightId == -1 )
	{
		pThis->m_lFinalHeightId = id;
		fFirstSample = true;
	}

	if( pThis->m_lFinalHeightId != id )
		return S_OK;

	//extract the current value from the sample
	IDANumber *pdanumCurrVal = NULL;
	hr = sampleVal->QueryInterface( IID_TO_PPV( IDANumber, &pdanumCurrVal ) );
	CheckHR( hr, "Failed to QI the sample val for IDANubmer", cleanup );

	double currVal;
	hr = pdanumCurrVal->Extract(&currVal);
	ReleaseInterface( pdanumCurrVal );
	CheckHR( hr, "Failed to extract the current value from the sampled behavior", cleanup );

	//if the value has changed mark for update
	if( pThis->m_dLastFinalHeightValue != currVal || fFirstSample )
	{
		pThis->m_dLastFinalHeightValue = currVal;
		pThis->m_fFinalDimensionChanged = true;

	}

	//set the last sample time
	pThis->m_fFinalHeightSampled = true;

	//collect samples
	pThis->CollectFinalDimensionSamples();

cleanup:
	return hr;
}


//*****************************************************************************
//
// class CCookieData
//
//*****************************************************************************

CActorBvr::CCookieMap::CCookieData::CCookieData( long lCookie, CBvrTrack *pTrack, ActorBvrFlags eFlags ):
	m_pNext( NULL ),
	m_lCookie( lCookie ),
	m_pTrack( pTrack ),
	m_eFlags( eFlags )
{
}


//*****************************************************************************
//
// class CCookieMap
//
//*****************************************************************************


CActorBvr::CCookieMap::CCookieMap():
	m_pHead(NULL)
{
}

//*****************************************************************************

CActorBvr::CCookieMap::~CCookieMap()
{
	Clear();
}

//*****************************************************************************

void
CActorBvr::CCookieMap::Insert( long lCookie, CActorBvr::CBvrTrack *pTrack, ActorBvrFlags eFlags )
{

	CCookieData *pNew = new CCookieData( lCookie, pTrack, eFlags );
	if( pNew == NULL )
	{
		DPF_ERR("Failed to build a cookie data.  Out of memory" );
		return;
	}

	//if the list is empty insert at the top.
	if( m_pHead == NULL )
	{
		m_pHead = pNew;
		pNew->m_pNext = NULL;
		return;
	}

	CCookieData *pCurrent = m_pHead;
	CCookieData *pPrev = NULL;

	//look for the first cookieData that has a cookie >= the
	//  cookie to be inserted.
	while( pCurrent != NULL && pCurrent->m_lCookie < lCookie )
	{
		pPrev = pCurrent;
		pCurrent = pCurrent->m_pNext;
	}

	//if we are inserting after the beginning of the list
	if( pPrev != NULL )
	{
		pNew->m_pNext = pCurrent;
		pPrev->m_pNext = pNew;
	}
	else // insert at the top
	{
		pNew->m_pNext = m_pHead;
		m_pHead = pNew;
	}
}

//*****************************************************************************

void
CActorBvr::CCookieMap::Remove( long lCookie )
{
	if( m_pHead == NULL )
	{
		return;
	}

	CCookieData *pCurrent = m_pHead;
	CCookieData *pPrev = NULL;

	//find the data in the map
	while( pCurrent != NULL && pCurrent->m_lCookie != lCookie )
	{
		pPrev = pCurrent;
		pCurrent = pCurrent->m_pNext;
	}

	if( pCurrent == NULL )
	{
		//we failed to find the cookie
		return;
	}

	//remove it
	//found a match in the list
	if( pPrev != NULL )
	{
		pPrev->m_pNext = pCurrent->m_pNext;
	}
	else //found a match at the top
	{
		m_pHead = pCurrent->m_pNext;
	}

	pCurrent->m_pNext = NULL;
	delete pCurrent;
}

//*****************************************************************************

void
CActorBvr::CCookieMap::Clear()
{
	CCookieData *pCurrent = m_pHead;
	CCookieData *pNext = NULL;

	while( pCurrent != NULL )
	{
		pNext = pCurrent->m_pNext;
		pCurrent->m_pNext = NULL;
		delete pCurrent;
		pCurrent = pNext;
	}

	m_pHead = NULL;

}
//*****************************************************************************

CActorBvr::CCookieMap::CCookieData*
CActorBvr::CCookieMap::GetDataFor( long lCookie )
{
	CCookieData *pCurrent = m_pHead;

	//find the data with the right cookie
	while( pCurrent != NULL && pCurrent->m_lCookie != lCookie )
	{
		pCurrent = pCurrent->m_pNext;
	}

	return pCurrent;

}

//*****************************************************************************
//
// The Actor Behavior Class
//
// The intermediary between "real" behaviors and the actual element being
// animated.
// The Actor performs in a number of ways:
// *   Adds new properties to an HTML element that we wish were
//     just part of the element (like static rotation and scale).
// *   Abstracts away the necessary action code from the behavior
//     and underlying element (specifically rotating a VML element
//     is easy, rotating and HTML element is hard). The actor does
//     the mapping so the behavior doesn't have to worry about it.
// *   Disambiguates overlapping behaviors (either just letting one
//     win or composing them).
// See the file header for a description of the actor behavior
//
//*****************************************************************************

CActorBvr::CActorBvr()
:   m_ptrackHead(NULL),
    m_pScale(NULL),
    m_pRotate(NULL),
    m_pTranslate(NULL),
    m_pOrigLeftTop(NULL),
    m_pOrigWidthHeight(NULL),
	m_pBoundsMin(NULL),
	m_pBoundsMax(NULL),
	m_pPixelWidth(NULL),
	m_pPixelHeight(NULL),
    m_pTransformCenter(NULL),
	m_pElementImage(NULL),
	m_pElementFilter(NULL),
	m_pFloatManager(NULL),
	m_pRuntimeStyle(NULL),
	m_pStyle(NULL),
	m_pVMLRuntimeStyle(NULL),
	m_dwAdviseCookie(0),
	m_pImageInfoListHead(NULL),
	m_pdanumFinalElementWidth(NULL),
	m_pdanumFinalElementHeight(NULL),
	m_pFinalElementDimensionSampler(NULL),
	m_bEditMode(false),
	m_simulDispNone(false),
	m_simulVisHidden(false),
	m_pBodyElement(NULL),
	m_pBodyPropertyMonitor( NULL ),
	m_bPendingRebuildsUpdating( false ),
	m_bRebuildListLockout( false ),
    m_nextFragmentCookie( 1 ),
    m_ptrackTop( NULL ),
    m_ptrackLeft( NULL ),
    m_dwCurrentState( 0 ),
    m_pOnResizeHandler( NULL ),
    m_pOnUnloadHandler( NULL ),
    m_fUnloading( false ),
	m_fVisSimFailed( false ),
	m_pcpCurrentStyle( NULL )
{
	VariantInit(&m_varAnimates);
    VariantInit(&m_varScale);
	VariantInit(&m_varPixelScale);
	m_clsid = CLSID_CrActorBvr;

	m_pEventManager = new CEventMgr( this );
} // CActorBvr

//*****************************************************************************

CActorBvr::~CActorBvr()
{
	VariantClear(&m_varAnimates);
    VariantClear(&m_varScale);
	VariantClear(&m_varPixelScale);

	ReleaseTracks();

	ReleaseInterface( m_pdanumFinalElementWidth );
	ReleaseInterface( m_pdanumFinalElementHeight );

	ReleaseInterface(m_pScale);
	ReleaseInterface(m_pRotate);
	ReleaseInterface(m_pTranslate);
    ReleaseInterface(m_pTransformCenter);
	ReleaseInterface(m_pElementImage);
	ReleaseInterface(m_pOrigLeftTop);
	ReleaseInterface(m_pOrigWidthHeight);
	ReleaseInterface(m_pPixelWidth);
	ReleaseInterface(m_pPixelHeight);
	ReleaseInterface(m_pBoundsMin);
	ReleaseInterface(m_pBoundsMax);

	ReleaseInterface(m_pStyle);
	ReleaseInterface(m_pRuntimeStyle);
	ReleaseInterface(m_pVMLRuntimeStyle);


	ReleaseInterface(m_pBodyElement);

	ReleaseFinalElementDimensionSampler();

	// TODO: Should probably remove these filters
	ReleaseInterface(m_pElementFilter);

	ReleaseFloatManager();

	ReleaseImageInfo();

    DiscardBvrCache();

	ReleaseEventManager();

	ReleaseRebuildLists();

	DestroyBodyPropertyMonitor();

} // ~CActorBvr

//*****************************************************************************

VARIANT *
CActorBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_ACTOR_PROPS);
    switch (iIndex)
    {
    case VAR_ANIMATES:
        return &m_varAnimates;
        break;
    case VAR_SCALE:
        return &m_varScale;
        break;
    case VAR_PIXELSCALE:
        return &m_varPixelScale;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CActorBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_ACTOR_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

HRESULT
CActorBvr::FinalConstruct()
{
    return SUPER::FinalConstruct();
} // FinalConstruct

//*****************************************************************************

STDMETHODIMP 
CActorBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	
	LMTRACE2( 1, 1000, L"Begin Init of ActorBvr <%p>\n", this );

	HRESULT hr = SUPER::Init( pBehaviorSite );
	CheckHR( hr, "Initialization of super class of actor failed", end );
	
	hr = m_pEventManager->Init();
	CheckHR( hr, "Failed to initialize event Manager", end );

	
	if( SUCCEEDED( hr ) )
	{
		// Are we in edit mode?
		m_bEditMode = IsDocumentInEditMode();

		// Simulate visibility/display changes if in edit mode
		if (m_bEditMode)
		{
			InitVisibilityDisplay();

			//register for the context change event
			hr = pBehaviorSite->RegisterNotification(BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE);
			CheckHR( hr, "Failed to register for the context change event", end );

		}

		// Initialize property sink (used to observe property changes on element)
		InitPropertySink();
	}

	LMTRACE2( 1, 1000, L"End Init of ActorBvr <%p>\n", this );
	
	end:

	return hr;

} // Init

//*****************************************************************************

STDMETHODIMP 
CActorBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		{
			LMTRACE2(1, 1000,  L"Actor<%p> Got Content Ready\n", this);

			//start listening to events on the animated element.
			//we wait until here to do this so that we are guarenteed that the properties have
			//  been read from the element ( we need the animates property )
			
			hr = AttachEvents();
			CheckHR( hr, "Failed to attach to events on the animated element", end );
			
			
			hr = UpdateCurrentState( );			
			CheckHR( hr, "Failed to update the current actor state", end );
		}break;	
	case BEHAVIOREVENT_DOCUMENTREADY:
		{
			LMTRACE2(1, 1000, L"Actor<%p> Got Document Ready\n", this);
						
			hr = UpdateCurrentState( );			
			CheckHR( hr, "Failed to update the current actor state", end );
		}break;
	case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		{
			LMTRACE2( 1, 2, "Got document context change\n" );

			IHTMLElement *pelemParent = NULL;

			hr = GetHTMLElement()->get_parentElement( &pelemParent );
			CheckHR( hr, "Failed to get the parent element", ccEnd );

			//if the parent of this element is null
			if( pelemParent == NULL )
			{
				// then we are being moved out of the document
				// set all the properties that we are animating back to their static values
				//this causes much badness.
				//applyStatics();
			}
			else//else we are being moved either to a different position in the document, or back into the document
			{
				//remove the filter from the element and rebuild the image track.
				hr = RemoveElementFilter();
				CheckHR( hr, "Failed to remove the element filter", ccEnd );

				ApplyImageTracks();
				CheckHR( hr, "Failed to apply the image tracks", ccEnd );

			}
		ccEnd:
			ReleaseInterface( pelemParent );
			if( FAILED( hr ) )
				goto end;
				
		}break;
	}

end:
	
	return hr;

} // Notify

//*****************************************************************************

STDMETHODIMP
CActorBvr::Detach()
{

	LMTRACE2( 1, 2, L"Detaching ActorBvr. <%p>\n", this );
	HRESULT hr = S_OK;

	// If we have a connection point detach it.  Need to do this before super.detach because it uses
	// the HTML element.
	UnInitPropertySink();

	DetachEvents();


	hr = m_pEventManager->Deinit();
	if( FAILED( hr ) )
	{
		DPF_ERR( "failed to detach the event manager" );
	}

	// If we have filters, set their elements to NULL
	if (m_pElementFilter != NULL)
		SetElementOnFilter(m_pElementFilter, NULL);

	if (m_pFloatManager != NULL)
		m_pFloatManager->Detach();

	if( m_pFinalElementDimensionSampler != NULL )
	{
		delete m_pFinalElementDimensionSampler;
		m_pFinalElementDimensionSampler = NULL;
	}

	DestroyBodyPropertyMonitor();

	ReleaseRebuildLists();

	ReleaseAnimation();

	ReleaseInterface(m_pBodyElement);

	//remove the filter from the element
	hr = RemoveElementFilter();
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to remove the element filter" );
	}

	hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to detach the superclass");
	}

	ReleaseInterface( m_pcpCurrentStyle );
	ReleaseInterface(m_pStyle);
	ReleaseInterface(m_pRuntimeStyle);
	ReleaseInterface(m_pVMLRuntimeStyle);


	LMTRACE2( 1, 2, L"End detach ActorBvr <%p>\n", this );

	return hr;
} // Detach 

//*****************************************************************************

/**
* Initializes a property sink on the current style of the animated element so that
* can observe changes in width, height, visibility, zIndex, etc.
*/
HRESULT
CActorBvr::InitPropertySink()
{
	HRESULT hr = S_OK;

	// Get connection point
	IConnectionPoint *pConnection = NULL;
	hr = GetCurrStyleNotifyConnection(&pConnection);
	if (FAILED(hr))
		return hr;

	// Advise on it
	hr = pConnection->Advise(GetUnknown(), &m_dwAdviseCookie);
	ReleaseInterface(pConnection);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::UnInitPropertySink()
{
	HRESULT hr = S_OK;

	if (m_dwAdviseCookie == 0)
		return S_OK;

	// Get connection point
	IConnectionPoint *pConnection = NULL;
	hr = GetCurrStyleNotifyConnection(&pConnection);
	if (FAILED(hr) || pConnection == NULL )
		return hr;

	// Unadvise on it
	hr = pConnection->Unadvise(m_dwAdviseCookie);
	ReleaseInterface(pConnection);
	if (FAILED(hr))
		return hr;

	m_dwAdviseCookie = 0;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetCurrStyleNotifyConnection(IConnectionPoint **ppConnection)
{
	HRESULT hr = S_OK;

	DASSERT(ppConnection != NULL);
	*ppConnection = NULL;

	if( m_pcpCurrentStyle == NULL )
	{
		IConnectionPointContainer *pContainer = NULL;
		IHTMLElement *pElement = NULL;

		// Get animated element
		hr = GetAnimatedElement(&pElement);
		CheckHR( hr, "Failed to get he animated element", getConPtend );
		CheckPtr( pElement, hr, E_POINTER, "Failed to get the animated element", getConPtend );
		
		// Get connection point container
		hr = pElement->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pContainer));
		CheckHR( hr, "QI for IConnectionPointContainer on the animated element failed", getConPtend );
		
		// Find the IPropertyNotifySink connection
		hr = pContainer->FindConnectionPoint(IID_IPropertyNotifySink, &m_pcpCurrentStyle);
		CheckHR( hr, "Failed to find a connection point IID_IPropertyNotifySink", getConPtend );

	getConPtend:
		ReleaseInterface( pElement );
		ReleaseInterface( pContainer );
		if( FAILED( hr ) )
			goto end;
	}
	
	(*ppConnection) = m_pcpCurrentStyle;
	(*ppConnection)->AddRef();

end:

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::InitPixelWidthHeight()
{
	HRESULT hr = S_OK;

	// Get the pixel width and height
	IHTMLElement *pElement = NULL;
	hr = GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;

	hr = pElement->get_offsetWidth(&m_pixelWidth);
	if (FAILED(hr))
	{
		ReleaseInterface(pElement);
		return hr;
	}

	hr = pElement->get_offsetHeight(&m_pixelHeight);
	if (FAILED(hr))
	{
		ReleaseInterface(pElement);
		return hr;
	}

	hr = pElement->get_offsetLeft(&m_pixelLeft);
	if (FAILED(hr))
	{
		ReleaseInterface(pElement);
		return hr;
	}

	hr = pElement->get_offsetTop(&m_pixelTop);
	ReleaseInterface(pElement);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

bool
CActorBvr::IsDocumentInEditMode()
{
    HRESULT hr;
    bool result = false;
    BSTR bstrMode = NULL;
    IDispatch *pDisp = NULL;
    IHTMLDocument2 *pDoc = NULL;
    IHTMLElement *pElem = GetHTMLElement();

	if (pElem == NULL)
		goto done;

    hr = pElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDoc));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDoc->get_designMode(&bstrMode);
    ReleaseInterface(pDoc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (wcsicmp(bstrMode, L"On") == 0)
    {
        result = true;
    }

    SysFreeString(bstrMode);

done:
    return result;
}

HRESULT
CActorBvr::GetBodyElement(IDispatch **ppResult)
{
	HRESULT hr = S_OK;

	if (m_pBodyElement == NULL)
	{
		IDispatch *pDocDispatch = NULL;
		IHTMLDocument2 *pDocument = NULL;
		IHTMLElement *pBody = NULL;

		hr = GetHTMLElement()->get_document(&pDocDispatch);
		CheckHR(hr, "Failed to get document", done);
		CheckPtr( pDocDispatch, hr, E_POINTER, "Got a null document from crappy trident", done );

		hr = pDocDispatch->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDocument));
		CheckHR(hr, "Failed to get IDispatch from doc", done);

		hr = pDocument->get_body(&pBody);
		CheckHR(hr, "Failed to get body element", done);
		CheckPtr( pBody, hr, E_POINTER, "Got a null pointer from crappy trident", done );

		hr = pBody->QueryInterface(IID_TO_PPV(IDispatch, &m_pBodyElement));
		CheckHR(hr, "Failed to get IDispatch from body", done);

done:
		ReleaseInterface(pDocDispatch);
		ReleaseInterface(pDocument);
		ReleaseInterface(pBody);
	}

	if (m_pBodyElement != NULL)
	{
		*ppResult = m_pBodyElement;
		m_pBodyElement->AddRef();
	}

	return hr;
}

HRESULT
CActorBvr::GetParentWindow( IHTMLWindow2 **ppWindow )
{
	if( ppWindow == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IDispatch *pdispDoc = NULL;
	IHTMLDocument2 *pdoc2Doc = NULL;
	IHTMLElement *pelemParent = NULL;

	hr = GetHTMLElement()->get_parentElement( &pelemParent );
	CheckHR( hr, "Failed to get the parent element", end );
	CheckPtr( pelemParent, hr, E_FAIL, "The parent element of the element was null: can't get the window or trident will crash", end );

	hr = GetHTMLElement()->get_document( &pdispDoc );
	CheckHR( hr, "Failed to get the document", end );
	CheckPtr( pdispDoc, hr, E_POINTER, "got a null document", end );

	hr = pdispDoc->QueryInterface( IID_TO_PPV( IHTMLDocument2, &pdoc2Doc ) );
	CheckHR( hr, "Failed to get doc2 from the doc disp", end );

	hr = pdoc2Doc->get_parentWindow( ppWindow );
	CheckHR( hr, "Failed to get the parent window", end );
	CheckPtr( (*ppWindow), hr, E_POINTER, "Got a null parent window pointer", end );

end:
	ReleaseInterface( pdispDoc );
	ReleaseInterface( pdoc2Doc );
	ReleaseInterface( pelemParent );

	return hr;
}

double
CActorBvr::MapGlobalTime(double gTime)
{
	if (!m_bEditMode)
		return gTime;

	HRESULT hr = S_OK;
	double result = -1;

	VARIANT varResult;
	VariantInit(&varResult);
	IDispatch *pBodyElement = NULL;

	hr = GetBodyElement(&pBodyElement);
	CheckHR(hr, "Failed to get body element", done);


	hr = GetPropertyOnDispatch(pBodyElement, L"localTime", &varResult);
	CheckHR(hr, "Failed to get local time", done);

	hr = VariantChangeTypeEx(&varResult, &varResult, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
	CheckHR(hr, "Failed to change type to R4", done);

	result = varResult.fltVal;

done:
	ReleaseInterface(pBodyElement);
	VariantClear(&varResult);

	return result;
}


HRESULT
CActorBvr::GetCurrentStyle(IHTMLCurrentStyle **ppResult)
{
	HRESULT hr = S_OK;

	DASSERT(ppResult != NULL);
	*ppResult = NULL;

	IHTMLElement *pElement = NULL;
	IHTMLElement2 *pElement2 = NULL;

	hr = GetAnimatedElement(&pElement);
	CheckHR(hr, "Failed to get animated element", done);
	CheckPtr( pElement, hr, E_POINTER, "Got a null animated element", done );

	hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
	CheckHR(hr, "Failed to get IHTMLElement2", done);

	hr = pElement2->get_currentStyle(ppResult);
	CheckHR(hr, "Failed to get current style", done);
	CheckPtr( (*ppResult), hr, E_POINTER, "Got a null currentStyle from Trident", done );

done:
	ReleaseInterface(pElement);
	ReleaseInterface(pElement2);

	return hr;
}

HRESULT
CActorBvr::InitVisibilityDisplay()
{
	HRESULT hr = S_OK;
	
	hr = UpdateDesiredPosition();
	CheckHR( hr, "Failed to update the preferred Position", done );

	hr = UpdateVisibilityDisplay();
	CheckHR( hr, "Failed to update the visibility and display", done );

done:
	return hr;
}

HRESULT
CActorBvr::UpdateDesiredPosition()
{
	HRESULT hr = S_OK;

	IHTMLStyle *pstyleInline = NULL;

	IHTMLStyle *pstyleRuntime = NULL;
	IHTMLStyle2 *pstyle2Runtime = NULL;

	BSTR bstrPosition = NULL;

	BSTR position = NULL;

	PositioningType oldDesiredPosType = m_desiredPosType;

	//TODO: what about positioning applied using class=?
	hr = GetStyle( &pstyleInline );
	CheckHR( hr, "Failed to get the inline style", end );

	hr = pstyleInline->get_position(&position);
	CheckHR(hr, "Failed to get position string", end);

	if (position != NULL)
	{
		if (wcsicmp(position, L"absolute") == 0)
		{
			LMTRACE2( 1,2, "Desired Position is Absolute\n" );
			m_currPosType = e_posAbsolute;
		}
		else if (wcsicmp(position, L"relative") == 0)
		{
			LMTRACE2( 1, 2, "Desired Position is Relative\n" );
			m_currPosType = e_posRelative;
		}
		else
		{
			LMTRACE2( 1, 2, "Desired Position is Static\n" );
			m_currPosType = e_posStatic;
		}

		::SysFreeString(position);
	}
	else
		m_currPosType = e_posStatic;

	m_desiredPosType = m_currPosType;

	if( m_desiredPosType != oldDesiredPosType )
	{		
		//if we are not simulating display and we are simulating visibility
		if( !m_simulDispNone && m_simulVisHidden )
		{
			hr = GetRuntimeStyle(&pstyleRuntime);
			CheckHR(hr, "Failed to get runtime style", end);
			CheckPtr( pstyleRuntime, hr, E_POINTER, "Trident gave us a null pointer for runtimeStyle", end );

			hr = pstyleRuntime->QueryInterface(IID_TO_PPV(IHTMLStyle2, &pstyle2Runtime));
			CheckHR(hr, "Failed to get IHTMLStyle2", end);
			
			if( ( oldDesiredPosType == e_posStatic || 
				  oldDesiredPosType == e_posRelative ) &&
				m_desiredPosType == e_posAbsolute )
			{
				//set the element absolute
				bstrPosition = SysAllocString( L"absolute" );
				CheckPtr( bstrPosition, hr, E_OUTOFMEMORY, "Ran out of memory trying to create a string", end );

				hr= pstyle2Runtime->put_position( bstrPosition );

				SysFreeString( bstrPosition );
				bstrPosition = NULL;
				
				CheckHR( hr, "Failed to set the position on the runtimStyle", end );
				
			}
			else if( oldDesiredPosType == e_posAbsolute && 
					 ( m_desiredPosType == e_posRelative || 
					   m_desiredPosType == e_posStatic ) 
				   )
			{
				//set the element relative
				bstrPosition = SysAllocString( L"relative" );
				CheckPtr( bstrPosition, hr, E_OUTOFMEMORY, "Ran out of memory trying to create a string", end );

				hr= pstyle2Runtime->put_position( bstrPosition );

				SysFreeString( bstrPosition );
				bstrPosition = NULL;
				
				CheckHR( hr, "Failed to set the position on the runtimeStyle", end );

			}
		}
	}

end:
	ReleaseInterface( pstyleInline );
	ReleaseInterface( pstyleRuntime );
	ReleaseInterface( pstyle2Runtime );

	return hr;

}

HRESULT
CActorBvr::UpdateVisibilityDisplay()
{
	HRESULT hr = S_OK;

	IHTMLCurrentStyle *pCurrStyle = NULL;
	IHTMLStyle *pRuntimeStyle = NULL;
	IHTMLStyle2 *pRuntimeStyle2 = NULL;

	bool visHidden = false;
	bool dispNone = false;
	bool restoreAll = false;
	bool setOffscreen = false;
	bool setAbsolute = false;
	bool setRelative = false;

	BSTR val = NULL;

	hr = GetCurrentStyle(&pCurrStyle);
	CheckHR(hr, "Failed to get current style", done);

	hr = pCurrStyle->get_visibility(&val);
	CheckHR(hr, "Failed to get visibility value", done);

	if (val != NULL)
	{
		visHidden = (wcsicmp(val, L"hidden") == 0);

		::SysFreeString(val);
	}

	hr = pCurrStyle->get_display(&val);
	CheckHR(hr, "Failed to get display value", done);

	if (val != NULL)
	{
		dispNone = (wcsicmp(val, L"none") == 0);

		::SysFreeString(val);
	}

#ifdef _DEBUG
	if (visHidden)
		::OutputDebugString("visibility: hidden   ");
	else
		::OutputDebugString("visibility: normal   ");

	if (dispNone)
		::OutputDebugString("display:none\n");
	else
		::OutputDebugString("display:normal\n");
#endif

	if (dispNone != m_simulDispNone)
	{
		// Display value differs from what we are simulating
		if (dispNone)
		{
			// Need to start simulating display:none
			setOffscreen = setAbsolute = true;
		}
		else
		{
			// Need to stop simulating display:none
			if (m_simulVisHidden)
			{
				// Still simulating visibility, if this element is not supposed to
				// be absolute then request a set back to relative
				if (m_desiredPosType != e_posAbsolute)
					setRelative = true;
			}
			else
			{
				// Not simulating visibility, restore everything
				restoreAll = true;
			}
		}

		m_simulDispNone = dispNone;
	}
	
	if (visHidden != m_simulVisHidden)
	{
		// Visibility value differs from what we are simulating
		if (visHidden)
		{
			// Need to start simulating visibility:hidden
			setOffscreen = true;

			// Cannot force to relative if this element should be absolute
			if (m_desiredPosType == e_posAbsolute)
				setAbsolute = true;
			else
				setRelative = true;
		}
		else
		{
			// Need to stop simulating visibility:hidden
			if (!m_simulDispNone)
			{
				// Not simulating display, restore everything
				restoreAll = true;
			}
		}

		m_simulVisHidden = visHidden;
	}
			

	if (restoreAll || setOffscreen || setAbsolute || setRelative)
	{
		// Need to do something

		hr = GetRuntimeStyle(&pRuntimeStyle);
		CheckHR(hr, "Failed to get runtime style", done);

		hr = pRuntimeStyle->QueryInterface(IID_TO_PPV(IHTMLStyle2, &pRuntimeStyle2));
		CheckHR(hr, "Failed to get IHTMLStyle2", done);

		VARIANT var;
		VariantInit(&var);

		if (setOffscreen)
		{
			VisSimSetOffscreen( pRuntimeStyle, true );
		}
		
		if (setAbsolute)
		{
			// Set position to absolute
			BSTR bstr = ::SysAllocString(L"absolute");
			if (bstr == NULL)
			{
				hr = E_FAIL;
				goto done;
			}

			pRuntimeStyle2->put_position(bstr);
			::SysFreeString(bstr);

//			m_currPosType = e_posAbsolute;
		}

		if (setRelative)
		{
			BSTR bstrOldPos = NULL;

			// Set position to relative
			BSTR bstr = ::SysAllocString(L"relative");
			if (bstr == NULL)
			{
				hr = E_FAIL;
				goto done;
			}

			pRuntimeStyle2->put_position(bstr);

			::SysFreeString(bstr);

//			m_currPosType = e_posRelative;
		}




		
		if (restoreAll)
		{
			
			VARIANT var;
			VariantInit(&var);
			V_VT(&var) = VT_BSTR;
			V_BSTR(&var) = ::SysAllocString(L"");

			hr = pRuntimeStyle2->put_position(V_BSTR(&var));
			
			if( CheckBitNotSet( m_dwCurrentState, ELEM_IS_VML) )
			{
				hr = pRuntimeStyle->put_top(var);
				hr = pRuntimeStyle->put_left(var);
			}
			else
			{
				//clear out the vgx runtime style.
				hr = SetVMLAttribute( L"top", &var );
				hr = SetVMLAttribute( L"left", &var );
			}

			VariantClear(&var);

			//allow the top and left track to change top and left again
			if( m_ptrackLeft != NULL )
				m_ptrackLeft->ReleaseChangeLockout();
			if( m_ptrackTop != NULL )
				m_ptrackTop->ReleaseChangeLockout();

		}
		
		
	}

done:
	ReleaseInterface(pCurrStyle);
	ReleaseInterface(pRuntimeStyle);
	ReleaseInterface(pRuntimeStyle2);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::VisSimSetOffscreen( IHTMLStyle *pRuntimeStyle, bool fResample )
{
	HRESULT hr = S_OK;
	
	VARIANT var;
	VariantInit(&var);

	IHTMLElement 	*pelemAnimated = NULL;

	hr = GetAnimatedElement( &pelemAnimated );
	CheckHR( hr, "Failed to get the animated element", done );


	if( m_ptrackTop == NULL )
	{
		//create it.
		hr = GetTrack( L"style.top", e_Number, &m_ptrackTop );
		CheckHR( hr, "track mismatch creating top track", done );
	}

	if( m_ptrackLeft == NULL )
	{
		//create it
		hr = GetTrack( L"style.left", e_Number, &m_ptrackLeft );
		CheckHR( hr, "Track mismatch creating left track", done );
	}

	//switch the current values for top and left into the top and left
	// tracks as statics.
	
	if( fResample && m_ptrackTop != NULL && m_ptrackLeft != NULL )
	{

		LMTRACE2( 1, 1000, L"VISSIM:Saving away the top and left in the top and left tracks\n" );
		
		//keep the top and left track from changing top and left
		m_ptrackTop->AcquireChangeLockout();
		m_ptrackLeft->AcquireChangeLockout();

		//we need to get the current values out of the top and left tracks so 
		// we can correct for the changes made by the track.
		

		if( !m_ptrackTop->IsOn() )
		{
			hr = m_ptrackTop->UpdateStaticBvr();
			CheckHR( hr, "The top track failed to update its static", staticUpdateDone );

		}

		hr =m_ptrackTop->SkipNextStaticUpdate();
		CheckHR( hr, "Failed to tell the track to skip its next update", staticUpdateDone );


		if( !m_ptrackLeft->IsOn() )
		{
			hr = m_ptrackLeft->UpdateStaticBvr();
			CheckHR( hr, "The left track failed to update its static", staticUpdateDone );
		}

		hr =m_ptrackLeft->SkipNextStaticUpdate();
		CheckHR( hr, "Failed to tell the track to skip its next update", staticUpdateDone );

		
	staticUpdateDone:
	
		LMTRACE2( 1, 1000, L"VISSIM: End Saving away the top and left in the top and left tracks\n" );
		
		if( FAILED( hr ) )
		{
			goto done;
		}
	}
	

	::VariantClear( &var );
	
	// Set top/left to offscreen
	V_VT(&var) = VT_I4;
	V_I4(&var) = -10000;

	if( CheckBitNotSet( m_dwCurrentState, ELEM_IS_VML ) )
	{
		hr = pRuntimeStyle->put_top(var);
		hr = pRuntimeStyle->put_left(var);
	}
	else
	{
		//animate the vgx runtime style.
		hr = SetVMLAttribute( L"top", &var );

		if( SUCCEEDED( hr ) )
		{
			hr = SetVMLAttribute( L"left", &var );
		}

		if( FAILED( hr ) )
			m_fVisSimFailed = true;
		else
			m_fVisSimFailed = false;
	}

done:
	VariantClear(&var);
	ReleaseInterface( pelemAnimated );


	return hr;
}


//*****************************************************************************


HRESULT
CActorBvr::RebuildActor()
{
	LMTRACE2(1, 1000, L"Processing rebuild requests on Actor <%p>\n", this );

	HRESULT hr = S_OK;

	UpdateCurrentState( );

	DWORD dirtyFlags = 0;
	CBvrTrack *ptrack = NULL;

	//now check to see if we need to rebuild the transform tracks
	
    hr = TransformTrackIsDirty( &dirtyFlags );
    CheckHR( hr, "Failed to check to see if a transform track is dirty", end );
    //if a transform track is dirty or the transform tracks have not been built yet.
    if( hr == S_OK || m_ptrackLeft == NULL )
    {
		LMTRACE2( 1, 1000, L"ActorBvr <%p> applying transform tracks\n", this );
    	hr = ApplyTransformTracks();
    	CheckHR( hr, "Failed to rebuild the transform tracks", end );
    }

    hr = ImageTrackIsDirty();
    CheckHR( hr, "failed to check if an image track is dirty", end );

    //we need to rebuild the image track if
    // 1) pixel scale is on and the scale track is dirty
    // 2) the element is not VML and the rotation track is dirty, or there is a static rotation
    // 3) there is a static scale on the element

    if( hr == S_OK ||  
    	( CheckBitSet(m_dwCurrentState, PIXEL_SCALE_ON ) && CheckBitSet(dirtyFlags, SCALE_DIRTY) ) ||
		( CheckBitNotSet(m_dwCurrentState, ELEM_IS_VML) && 
		  ( CheckBitSet( dirtyFlags, ROTATION_DIRTY ) || CheckBitSet(m_dwCurrentState, STATIC_ROTATION ) ) )  ||
	 	 CheckBitSet(m_dwCurrentState, STATIC_SCALE)
      )
    {
		LMTRACE2( 1, 1000, L"ActorBvr<%p> applying image tracks\n", this );
    	hr = ApplyImageTracks();
    	CheckHR( hr, "Failed to rebuild the Image tracks", end );
    }
	

	// Run the track list applying an unused tracks to their properties
    ptrack = m_ptrackHead;

    while (NULL != ptrack)
    {
		hr = ptrack->BeginRebuild();
		CheckHR( hr, "Failed to BeginRebuild Track", end );
		
        ptrack = ptrack->m_pNext;
    }

	//now apply all of the tracks that were rebuilt.
    ptrack = m_ptrackHead;

    while( ptrack != NULL )
    {
    	hr = ptrack->ApplyIfUnmarked();
    	CheckHR( hr, "Failed to apply track", end );
    	
    	ptrack = ptrack->m_pNext;
    }

end:

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::UpdatePixelDimensions()
{

	// Something changed, compute offset left, top, width, height
	// You would think you could just get offsetLeft etc, but for some
	// IE reason they aren't updated all the time.


	HRESULT hr = S_OK;
	
	IHTMLElement *pElement = NULL;
	hr = GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;

	IHTMLElement *pOffsetParent = NULL;
	hr = pElement->get_offsetParent(&pOffsetParent);
	if (FAILED(hr) || pOffsetParent == NULL )
	{
		LMTRACE2( 1, 1000, "Offset parent problems <%p>\n", pOffsetParent );
		ReleaseInterface(pElement);
		return hr;
	}

	IHTMLElement2 *pElement2 = NULL;
	hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
	ReleaseInterface(pElement);
	if (FAILED(hr))
	{
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	IHTMLRect *pRect = NULL;
	hr = pElement2->getBoundingClientRect(&pRect);
	ReleaseInterface(pElement2);
	if (FAILED(hr) || pRect == NULL )
	{
		LMTRACE2( 1, 1000, "Bounding Client rect problems <%p>\n", pRect );
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	long left, top, right, bottom;
	hr = pRect->get_left(&left);
	if (FAILED(hr))
	{
		ReleaseInterface(pRect);
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	hr = pRect->get_top(&top);
	if (FAILED(hr))
	{
		ReleaseInterface(pRect);
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	hr = pRect->get_right(&right);
	if (FAILED(hr))
	{
		ReleaseInterface(pRect);
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	hr = pRect->get_bottom(&bottom);
	ReleaseInterface(pRect);
	if (FAILED(hr))
	{
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	hr = pOffsetParent->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
	ReleaseInterface(pOffsetParent);
	if (FAILED(hr))
		return hr;

	hr = pElement2->getBoundingClientRect(&pRect);
	ReleaseInterface(pElement2);
	if (FAILED(hr) || pRect == NULL )
	{
		LMTRACE2(1, 1000, "bounding client rect problems <%p>\n", pRect );
		return hr;
	}

	long parentLeft, parentTop;
	hr = pRect->get_left(&parentLeft);
	if (FAILED(hr))
	{
		ReleaseInterface(pRect);
		return hr;
	}

	hr = pRect->get_top(&parentTop);
	ReleaseInterface(pRect);
	if (FAILED(hr))
		return hr;

	long pixelWidth = right - left;
	long pixelHeight = bottom - top;
	long pixelTop = top - parentTop;
	long pixelLeft = left - parentLeft;

	if (pixelWidth != m_pixelWidth ||
		pixelHeight != m_pixelHeight ||
		pixelTop != m_pixelTop ||
		pixelLeft != m_pixelLeft)
	{
#if 0
		LMTRACE2( 1, 2, "Change! pixelTop: %d pixelLeft:%d pixelWidth:%d pixelHeight:%d\n", pixelTop, pixelLeft, pixelWidth, pixelHeight );
#ifdef _DEBUG

		//get the current values from the top and left tracks
		if( m_ptrackLeft != NULL )
		{
			VARIANT varLeft;
			VariantInit( &varLeft );

			m_ptrackLeft->GetDynamic( &varLeft );
			VariantChangeTypeEx( &varLeft, &varLeft, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR );
			LMTRACE2( 1, 2, "Left track dynamic: %S", V_BSTR( &varLeft ) );
			VariantClear( &varLeft );

			m_ptrackLeft->GetStatic( &varLeft );
			VariantChangeTypeEx( &varLeft, &varLeft, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR );
			LMTRACE2( 1, 2, "Left Track static: %S\n", V_BSTR( &varLeft ) );
			VariantClear( &varLeft );

			if( m_ptrackLeft->IsOn() )
				LMTRACE2( 1, 2, "On\n" );
			else
				LMTRACE2( 1, 2, "Off\n" );

			IHTMLCurrentStyle *pstyle = NULL;

			GetCurrentStyle( &pstyle );
			if( pstyle != NULL )
			{
				long pixel = 0;

				pstyle->get_left( &varLeft );

				VariantChangeTypeEx( &varLeft, &varLeft, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR );
				VariantToPixelLong( &varLeft, &pixel, true );
				LMTRACE2( 1, 2, "CurrentStyle.left: %S %d\n", V_BSTR(&varLeft ), pixel );
				VariantClear( &varLeft );
			}
			ReleaseInterface( pstyle );
		}
#endif
#endif

		if (m_pixelWidth != pixelWidth && m_pPixelWidth != NULL)
			m_pPixelWidth->SwitchToNumber(pixelWidth);

		if (m_pixelHeight != pixelHeight && m_pPixelHeight != NULL)
			m_pPixelHeight->SwitchToNumber(pixelHeight);

		if (m_pFloatManager != NULL)
		{
			m_pFloatManager->UpdateRect(pixelLeft, pixelTop, pixelWidth, pixelHeight);
		}
		else
		{
			hr = SetRenderResolution( pixelWidth, pixelHeight );
			if( FAILED( hr ) )
				return hr;
		}


		m_pixelWidth = pixelWidth;
		m_pixelHeight = pixelHeight;
		m_pixelTop = pixelTop;
		m_pixelLeft = pixelLeft;
	}

	return hr;
}

//*****************************************************************************
// IPropertyNotifySink
//*****************************************************************************

STDMETHODIMP
CActorBvr::OnChanged(DISPID dispID)
{
	HRESULT hr = S_OK;

	if (dispID == DISPID_IHTMLCURRENTSTYLE_TOP ||
		dispID == DISPID_IHTMLCURRENTSTYLE_LEFT )
	{
		//width and height changes are handled by onresize
		
		// TODO: Should only do this when really necessary
		
		hr = UpdatePixelDimensions();

	}

/*
	if (dispID == DISPID_IHTMLCURRENTSTYLE_WIDTH ||
		dispID == DISPID_IHTMLCURRENTSTYLE_HEIGHT)
	{
		// Width or height changed

		// Get the pixel width and height
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		long offsetWidth;
		hr = pElement->get_offsetWidth(&offsetWidth);
		if (FAILED(hr))
		{
			ReleaseInterface(pElement);
			return hr;
		}

		long offsetHeight;
		hr = pElement->get_offsetHeight(&offsetHeight);
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;

		if (offsetWidth != m_pixelWidth ||
			offsetHeight != m_pixelHeight)
		{
			m_pixelWidth = offsetWidth;
			m_pixelHeight = offsetHeight;

			if (m_pPixelWidth != NULL)
				m_pPixelWidth->SwitchToNumber(m_pixelWidth);

			if (m_pPixelHeight != NULL)
				m_pPixelHeight->SwitchToNumber(m_pixelHeight);

			if (m_pFloatManager != NULL)
				m_pFloatManager->UpdateWidthHeight(offsetWidth, offsetHeight);
		}
	}

	if (dispID == DISPID_IHTMLCURRENTSTYLE_TOP ||
		dispID == DISPID_IHTMLCURRENTSTYLE_LEFT)
	{
		// Top or left changed

		// Get the pixel left and top
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		long offsetLeft;
		hr = pElement->get_offsetLeft(&offsetLeft);
		if (FAILED(hr))
		{
			ReleaseInterface(pElement);
			return hr;
		}

		long offsetTop;
		hr = pElement->get_offsetTop(&offsetTop);
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;

		if (offsetLeft != m_pixelLeft ||
			offsetTop != m_pixelTop)
		{
			m_pixelLeft = offsetLeft;
			m_pixelTop = offsetTop;

			if (m_pFloatManager != NULL)
				m_pFloatManager->UpdateLeftTop(offsetLeft, offsetTop);
		}
	}
*/
	if (dispID == DISPID_IHTMLCURRENTSTYLE_ZINDEX)
	{
		// zIndex changed
		if (m_pFloatManager != NULL)
			return m_pFloatManager->UpdateZIndex();
	}

	if (dispID == DISPID_IHTMLCURRENTSTYLE_VISIBILITY)
	{
		// visibility changed
		if (m_pFloatManager != NULL)
			return m_pFloatManager->UpdateVisibility();

		if (m_bEditMode)
			UpdateVisibilityDisplay();
	}

	if (dispID == DISPID_IHTMLCURRENTSTYLE_DISPLAY)
	{
		//trident may have delayed processing the bounding box of this element until it became 
		// visible.

		UpdateLayout();
		if( FAILED( hr ) )
		{
			DPF_ERR("Failed to update the pixel dimensions on a display change" );
		}

		// display changed
		if (m_pFloatManager != NULL)
			return m_pFloatManager->UpdateDisplay();

		if (m_bEditMode)
			UpdateVisibilityDisplay();
	}

	if( dispID == DISPID_IHTMLSTYLE_POSITION )
	{
		LMTRACE2( 1, 2, "Static StylePosition Changed\n" );
		UpdateDesiredPosition();
	}


	return S_OK;
}

//*****************************************************************************


STDMETHODIMP
CActorBvr::OnRequestEdit(DISPID dispID)
{
	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::UpdateLayout()
{
	HRESULT hr = S_OK;
	IHTMLCurrentStyle *pstyleCurrent = NULL;
	BSTR bstrDisplay;

	hr = GetCurrentStyle( &pstyleCurrent );
	CheckHR( hr, "Failed to get the current sytle", end );

	hr = pstyleCurrent->get_display( &bstrDisplay );
	CheckHR( hr, "Failed to get the display from the current style", end );
	CheckPtr( bstrDisplay, hr, E_FAIL, "Got null for the display", end );
	
	//if the element is now not display none
	if( wcsicmp( bstrDisplay, L"none" ) != 0 )
	{
		CBvrTrack *ptrack = NULL;
		//update the pixel layout attributes for the element
		UpdatePixelDimensions();
		CheckHR( hr, "Failed to update the pixel Dimensions", end );
		/*
		// update the top and left tracks
		if( m_ptrackTop != NULL )
			m_ptrackTop->UpdateStaticBvr();
		if( m_ptrackLeft != NULL )
			m_ptrackLeft->UpdateStaticBvr();
			
		// update the width and height tracks if they exist
		FindTrackNoType( L"style.width", &ptrack );
		if( ptrack != NULL )
			ptrack->UpdateStaticBvr();

		FindTrackNoType( L"style.height", &ptrack );
		if( ptrack != NULL )
			ptrack->UpdateStaticBvr();
		*/
	}

end:
	ReleaseInterface( pstyleCurrent );
	SysFreeString( bstrDisplay );

	return hr;
		
}

//*****************************************************************************

HRESULT
CActorBvr::RequestRebuildFromExternal()
{
	HRESULT hr = S_OK;
	
	IHTMLWindow2* 	pwindow2 = NULL;
	IDispatch*		pdispExternal = NULL;

	DISPID dispid = -1;
	LPWSTR wstrMethod = L"ANRequestRebuild";


	//get window.external
	hr = GetParentWindow( &pwindow2 );
	CheckHR( hr, "Failed to get the parent window", end );

	hr = pwindow2->get_external( &pdispExternal );
	CheckHR( hr, "Failed to get the external interface from the window", end );
	CheckPtr( pdispExternal, hr, E_FAIL, "got a null external", end );

	//check to see if the external interface supports ANRequestRebuild
	
	hr = pdispExternal->GetIDsOfNames(  IID_NULL, 
										&wstrMethod, 
                              			1,
                              			LCID_SCRIPTING, 
                              			&dispid);
	CheckHR( hr, "Didn't find ANRequestRebuild on window.external", end );

	//if window.external implements LMRTRequestRebuild
	if( dispid != DISPID_UNKNOWN )
	{
		DISPPARAMS		params;
        VARIANT			varResult;
    	VARIANT			rgvarInput[1];

    	IDispatch		*pdispElem = NULL;

    	VariantInit(&varResult);
        VariantInit(&rgvarInput[0]);


    	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV(IDispatch, &pdispElem ) );
    	CheckHR( hr, "Failed to get IDispatch from element", invokeEnd );

    	V_VT(&rgvarInput[0]) = VT_DISPATCH;
    	V_DISPATCH(&rgvarInput[0]) = pdispElem;

        params.rgvarg					= rgvarInput;
        params.rgdispidNamedArgs		= NULL;
        params.cArgs					= 1;
        params.cNamedArgs				= 0;
        
		//send our element as an argument
		hr = pdispExternal->Invoke( dispid,
									IID_NULL,
									LCID_SCRIPTING,
									DISPATCH_METHOD,
									&params,
									&varResult,
									NULL,
									NULL );
		//invoke the dispid we got.

	invokeEnd:
		ReleaseInterface( pdispElem );
		VariantClear( &varResult );

		if( FAILED( hr ) )
		{
			goto end;
		}
	}

end:
	ReleaseInterface( pwindow2 );
	ReleaseInterface( pdispExternal );
	
	return hr;
}

//*****************************************************************************
// IEventManagerClient
//*****************************************************************************

IHTMLElement *
CActorBvr::GetElementToSink()
{
	return GetHTMLElement();
}

//*****************************************************************************

IElementBehaviorSite *
CActorBvr::GetSiteToSendFrom()
{
	return NULL;
}

//*****************************************************************************

HRESULT CActorBvr::TranslateMouseCoords	( long lX, long lY, long * pXTrans, long * pYTrans )
{
	if ( ( pXTrans == NULL ) || ( pYTrans == NULL ) )
		return E_POINTER;
	
	HRESULT	hr = S_OK;

	CComPtr<IHTMLElement> pElem = GetHTMLElement();
	if ( FAILED(hr) ) return hr;

	CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElement2( pElem );
	if ( pElement2 == NULL ) return E_FAIL;

	CComPtr<IHTMLRect>	pRect;
	long				left, top;

	hr = pElement2->getBoundingClientRect( &pRect );
	if ( FAILED(hr) ) return hr;

	pRect->get_left( &left );
	if ( FAILED(hr) ) return hr;
	pRect->get_top( &top );
	if ( FAILED(hr) ) return hr;

	*pXTrans = lX - left;
	*pYTrans = lY - top;
	
	return hr;
}

//*****************************************************************************

void
CActorBvr::OnLoad()
{

	RebuildActor();

	//if we are in edit mode.
	if( !m_bEditMode )
	{
		// update all of the static behaviors (they may have been changed by other behaviors)
		CBvrTrack *ptrack = m_ptrackHead;

		while( ptrack != NULL )
		{
			if( !ptrack->IsOn() )
				ptrack->UpdateStaticBvr();
			ptrack = ptrack->m_pNext;
		}
	}
}

//*****************************************************************************

//this should no longer be needed.
HRESULT
CActorBvr::BuildChildren()
{
	//cycle through out direct children calling buildAnimationFragments

	HRESULT hr = E_FAIL;
	
	IHTMLElement* pElem;
	pElem = GetHTMLElement( );
	if( pElem != NULL )
	{
		IDispatch *pChildrenDisp;
		hr = pElem->get_children( &pChildrenDisp );
		if( SUCCEEDED( hr ) )
		{
			IHTMLElementCollection *pChildrenCol;
			hr = pChildrenDisp->QueryInterface( IID_TO_PPV( IHTMLElementCollection, &pChildrenCol ) );
			ReleaseInterface( pChildrenDisp );
			if( SUCCEEDED( hr ) )
			{
				long length;

				hr = pChildrenCol->get_length(&length);
				if( SUCCEEDED( hr ) )
				{
					if( length != 0 )
					{
						VARIANT name;
						VARIANT index;
						VARIANT rgvarInput[1];

						IDispatch *pCurrentElem;
						
						VariantInit( &name );
						V_VT(&name) = VT_I4;

						VariantInit( &index );
						V_VT(&index) = VT_I4;
						V_I4(&index) = 0;

						VariantInit( &rgvarInput[0] );
						V_VT( &rgvarInput[0] ) = VT_DISPATCH;
						V_DISPATCH( &rgvarInput[0] ) = static_cast<IDispatch*>(this);

						DISPPARAMS params;
						params.rgvarg				= rgvarInput;
						params.rgdispidNamedArgs	= NULL;
						params.cArgs				= 1;
						params.cNamedArgs			= 0;

						for(V_I4(&name) = 0; V_I4(&name) < length ; V_I4(&name)++ )
						{
							hr = pChildrenCol->item( name, index, &pCurrentElem );
							if( SUCCEEDED( hr ) )
							{
								CallBuildBehaviors( pCurrentElem, &params, NULL );
								ReleaseInterface( pCurrentElem );
							}
						}
					}
				}
				else //failed to get the length from the children collection
				{
					DPF_ERR("failed to get the length from the children collection");
				}
				ReleaseInterface( pChildrenCol );
			}
			else //failed to get IHTMLElementCollection from dispatch returned from elem->get_children
			{
				DPF_ERR("failed to get IHTMLElementCollection from dispatch returned from elem->get_children");
			}
		}
		else //failed to get the children collection from the actor element
		{
			DPF_ERR("failed to get the children collection from the actor element");
		}

	}
	else//failed to get the actor element
	{
		DPF_ERR("failed to get the actor element");
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CallBuildBehaviors( IDispatch *pDisp, DISPPARAMS *pParams, VARIANT* pResult)
{
	HRESULT hr = S_OK;

	DISPID dispid;

	WCHAR* wszBuildMethodName = L"buildBehaviorFragments";

	hr = pDisp->GetIDsOfNames( IID_NULL,
							   &wszBuildMethodName,
							   1,
							   LOCALE_SYSTEM_DEFAULT,
							   &dispid);
	if( SUCCEEDED( hr ) )
	{
		EXCEPINFO		excepInfo;
		UINT			nArgErr;
		hr = pDisp->Invoke( dispid,
							IID_NULL,
							LOCALE_SYSTEM_DEFAULT,
							DISPATCH_METHOD,
							pParams,
							pResult,
							&excepInfo,
							&nArgErr );
		if( FAILED( hr ) )
		{
			if( pResult != NULL )
				VariantClear( pResult );
		}

	}
	else//failed to get the id of "buildBehaviors" on pDisp
	{
		if( pResult != NULL )
			VariantClear( pResult );
	}


	return hr;
}

//*****************************************************************************

void
CActorBvr::OnUnload()
{
}

//*****************************************************************************

void
CActorBvr::OnReadyStateChange( e_readyState state )
{
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::OnLocalTimeChange( float localTime )
{
	LMTRACE2( 1, 1000, L"Local time change to %f for Actor <%p>\n", (double)localTime, this );
	HRESULT hr = ProcessPendingRebuildRequests();
	CheckHR( hr, "Failed to process the pending rebuild requests", end );

end:

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::ProcessPendingRebuildRequests()
{
	LMTRACE2( 1, 2, "Processing pending rebuild requests\n" );
	HRESULT hr = S_OK;

	m_bPendingRebuildsUpdating = true;

	bool fNeedRebuild = false;

    bool fLeaveAttached = false;

	//if there are any pending removals
	if( !m_listPendingRemovals.empty() )
	{
		//do them now.
		CCookieMap::CCookieData *pdata = NULL;
		

		for( BehaviorFragmentRemovalList::iterator curRemoval = m_listPendingRemovals.begin();
			 curRemoval != m_listPendingRemovals.end();
			 curRemoval++)
		{
			pdata = m_mapCookieToTrack.GetDataFor( (*curRemoval)->GetCookie() );

			if( pdata != NULL )
			{
				hr = pdata->m_pTrack->RemoveBvrFragment( pdata->m_eFlags, (*curRemoval)->GetCookie() );
				if( FAILED( hr ) )
				{
					DPF_ERR( "failed to remove behaivor fragment" );
				}
			}

			delete (*curRemoval);
			(*curRemoval) = NULL;
		}
		m_listPendingRemovals.clear();

		fNeedRebuild = true;
	}

	//if any child behaivors have requested a rebuild
	if( !m_listPendingRebuilds.empty() )
	{
		//tell the pending children that they can now rebuild.

		IDispatch *pdispThis = NULL;

		hr = GetUnknown()->QueryInterface( IID_TO_PPV( IDispatch, &pdispThis ) );
		if( FAILED(hr) )
		{
			DPF_ERR("Failed to get IDispatch from our unknown" );
			return hr;
		}

		DISPPARAMS dispparamsBuildArgs;
		VARIANT varThis;

		::VariantInit( &varThis );

		V_VT(&varThis) = VT_DISPATCH;
		V_DISPATCH(&varThis) = pdispThis;

		dispparamsBuildArgs.cArgs = 1;
		dispparamsBuildArgs.cNamedArgs = 0;
		dispparamsBuildArgs.rgvarg = &varThis;
		dispparamsBuildArgs.rgdispidNamedArgs = NULL;
		

        BehaviorRebuildList::iterator iterNextData = m_listPendingRebuilds.begin();
		BehaviorRebuildList::iterator iterCurData = m_listPendingRebuilds.begin();
		while( iterCurData != m_listPendingRebuilds.end() )
		{
			hr = (*iterCurData)->RebuildBehavior( &dispparamsBuildArgs, NULL );
			
            iterNextData = iterCurData;
            iterNextData++;
            //if we didn't fail
            if( SUCCEEDED( hr ) )
            {
                //remove the request from the pending list
			    delete (*iterCurData);
			    (*iterCurData) = NULL;
                m_listPendingRebuilds.erase( iterCurData );
            }
            else //we failed to rebuild the behavior
            {
                //wait until next time to try again.
                fLeaveAttached = true;
            }

            iterCurData = iterNextData;
		}

		ReleaseInterface( pdispThis );

		//if anyone added behaviors to the pending list while we were updating
		if( !m_listUpdatePendingRebuilds.empty() )
		{
			//move the update list into the pending list.
			m_listPendingRebuilds.insert( m_listPendingRebuilds.end(), 
										  m_listUpdatePendingRebuilds.begin(), 
										  m_listUpdatePendingRebuilds.end() );
			m_listUpdatePendingRebuilds.clear();
		}

		fNeedRebuild = true;
	}

    if( !fLeaveAttached )
	{
		//we don't need to listen to local time changes until
		//  we get another rebuild or removal request
		hr = DetachBodyPropertyMonitor();
		if(FAILED( hr ) )
		{
			DPF_ERR("Failed to detach the body property monitor");
		}
	}

	m_bPendingRebuildsUpdating = false;

	//now rebuild the actor
	if( fNeedRebuild || IsAnyTrackDirty() )
	{
		hr = RebuildActor();
		if( FAILED( hr ) )
		{
			DPF_ERR("failed to rebuild the actor" );
		}
	}

	if( fLeaveAttached )
		return S_FALSE;
	else
		return hr;
}

//*****************************************************************************

void
CActorBvr::ReleaseRebuildLists()
{
	m_bRebuildListLockout = true;

	if( !m_listPendingRebuilds.empty() )
	{
		BehaviorRebuildList::iterator iterCurData = m_listPendingRebuilds.begin();
		for( ; iterCurData != m_listPendingRebuilds.end(); iterCurData++ )
		{	
			delete (*iterCurData);
			(*iterCurData) = NULL;
		}
		m_listPendingRebuilds.clear();
	}

	if( !m_listUpdatePendingRebuilds.empty() )
	{
		BehaviorRebuildList::iterator iterCurData = m_listUpdatePendingRebuilds.begin();
		for( ; iterCurData != m_listUpdatePendingRebuilds.end(); iterCurData++ )
		{	
			delete (*iterCurData);
			(*iterCurData) = NULL;
		}
		m_listUpdatePendingRebuilds.clear();
	}

	if( !m_listPendingRemovals.empty() )
	{
		BehaviorFragmentRemovalList::iterator iterCurRemoval = m_listPendingRemovals.begin();
		for( ; iterCurRemoval != m_listPendingRemovals.end(); iterCurRemoval++ )
		{
			delete (*iterCurRemoval);
			(*iterCurRemoval) = NULL;
		}
		m_listPendingRemovals.clear();
	}

	//leave the update lists locked out

}

//*****************************************************************************

STDMETHODIMP
CActorBvr::put_animates(VARIANT  varAnimates)
{
	HRESULT hr = VariantCopy(&m_varAnimates, &varAnimates);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in put_animates");
        return SetErrorInfo(hr);
    }
    return NotifyPropertyChanged(DISPID_ICRACTORBVR_ANIMATES);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CActorBvr::get_animates(VARIANT *pvarAnimates)
{
	HRESULT hr = VariantCopy(pvarAnimates, &m_varAnimates);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in get_animates");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // get_animates

//*****************************************************************************

STDMETHODIMP
CActorBvr::put_scale(VARIANT  varScale)
{
    return E_NOTIMPL;
} // put_scale

//*****************************************************************************

STDMETHODIMP
CActorBvr::get_scale(VARIANT *pvarScale)
{
    return E_NOTIMPL;
} // get_scale

//*****************************************************************************

STDMETHODIMP
CActorBvr::put_pixelScale(VARIANT varPixelScale)
{
	HRESULT hr = VariantCopy(&m_varPixelScale, &varPixelScale);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in put_pixelScale");
        return SetErrorInfo(hr);
    }
    return NotifyPropertyChanged(DISPID_ICRACTORBVR_PIXELSCALE);
} 

//*****************************************************************************

STDMETHODIMP
CActorBvr::get_pixelScale(VARIANT *pvarPixelScale)
{
	HRESULT hr = VariantCopy(pvarPixelScale, &m_varPixelScale);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in get_pixelScale");
        return SetErrorInfo(hr);
    }
    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::RemoveElementFilter( IHTMLElement* pElement)
{

	HRESULT hr = S_OK;
	
	// Get the style object
	IHTMLStyle *pStyle = NULL;
	VARIANT_BOOL varboolSuccess = VARIANT_FALSE;
	
	SetElementOnFilter( m_pElementFilter, NULL );

	hr = pElement->get_style(&pStyle);
	CheckHR( hr, "Failed to get the style off of the element", end );

	// Take the filter off
	hr = pStyle->removeAttribute( L"filter", VARIANT_FALSE, &varboolSuccess );
	ReleaseInterface(pStyle);
	CheckHR( hr, "Failed to remove the filter on the element", end );
	if( varboolSuccess == VARIANT_FALSE)
	{
		DPF_ERR("failed to remove the filter attribute from the style" );
	}

	ReleaseInterface( m_pElementFilter );

	ReleaseInterface( m_pElementImage );
	
end:
	ReleaseInterface( pStyle );

	return hr;
	
}

//*****************************************************************************

HRESULT
CActorBvr::RemoveElementFilter()
{
	if( m_pElementFilter == NULL )
		return S_OK;

	HRESULT hr = S_OK;

	IHTMLElement *pElement= NULL;

	hr = GetAnimatedElement( &pElement );
	CheckHR( hr, "Failed to get the animated element", end );

	hr = RemoveElementFilter( pElement );
	CheckHR( hr, "Failed to remove the filter from the animated element", end );

end:

	ReleaseInterface( pElement );

	return hr;
	
}

//*****************************************************************************

HRESULT
CActorBvr::GetElementFilter(IDispatch **ppFilter)
{
	HRESULT hr = S_OK;

	*ppFilter = NULL;

	if (m_pElementFilter == NULL)
	{

		// Get the animated element
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get animated element");
			return hr;
		}

		// Get a filter from it
		hr = GetElementFilter(pElement, &m_pElementFilter);
		ReleaseInterface(pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get filter");
			return hr;
		}
	}

	*ppFilter = m_pElementFilter;
	m_pElementFilter->AddRef();

	return S_OK;
}


//*****************************************************************************

HRESULT
CActorBvr::GetElementFilter(IHTMLElement *pElement, IDispatch **ppFilter)
{
	HRESULT hr = S_OK;

	*ppFilter = NULL;

	// Get the style object
	IHTMLStyle *pStyle = NULL;
	hr = pElement->get_style(&pStyle);
	if (FAILED(hr))
	{
		DPF_ERR("Error getting style from element");
		return hr;
	}

	CComBSTR filterName = L"redirect";

	// Put the filter on
	hr = pStyle->put_filter(filterName);
	ReleaseInterface(pStyle);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to put the filter on the element");
		return hr;
	}

	// Get the filter back out
	IHTMLFiltersCollection *pFilters = NULL;
	hr = pElement->get_filters(&pFilters);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to get collection of filters");
		return hr;
	}

	VARIANT varIndex;
	VARIANT varResult;
	VariantInit(&varIndex);
	VariantInit(&varResult);
	V_VT(&varIndex) = VT_I4;
	V_I4(&varIndex) = 0;

	hr = pFilters->item(&varIndex, &varResult);
	ReleaseInterface(pFilters);
	VariantClear(&varIndex);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to get filter from collection");
		return hr;
	}

	hr = VariantChangeType(&varResult, &varResult, 0, VT_DISPATCH);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to get IDispatch of filter");
		VariantClear(&varResult);
		return hr;
	}

	*ppFilter = V_DISPATCH(&varResult);
	(*ppFilter)->AddRef();
	VariantClear(&varResult);

	return S_OK;
/* This is another possible implementation that knows about the redirect effect headers
		// Need to add the redirect filter to grab the bits

		// Create the redirect effect
        IDispRedirectEffect *pRedirect = NULL;
        hr = CoCreateInstance(CLSID_RedirectEffect, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IDispRedirectEffect, 
                              (void**)&pRedirect);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to create Redirect filter");
			return hr;
		}

		// Get the animated element
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get animated element");
			ReleaseInterface(pRedirect);
			return hr;
		}

		// Query for IHTMLElement2
		IHTMLElement2 *pElement2 = NULL;
		hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
		ReleaseInterface(pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get IHTMLElement2");
			ReleaseInterface(pRedirect);
			return hr;
		}

		// Add the filter to the element
		hr = pElement2->addFilter(pRedirect);
		ReleaseInterface(pElement2);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to add filter to element");
			return hr;
		}

		// Get the image from the filter
		hr = pRedirect->ElementImage(pvarActorImage);
		ReleaseInterface(pRedirect);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get ElementImage from filter");
			VariantClear(pvarActorImage);
			return hr;
		}

		// Coerce to IUnknown
		hr = VariantChangeType(pvarActorImage, pvarActorImage, 0, VT_UNKNOWN);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to change type to IUnknown");
			VariantClear(pvarActorImage);
			return hr;
		}

		// Stash it away
		m_punkActorImage = pvarActorImage->punkVal;
		m_punkActorImage->AddRef();
*/

}

//*****************************************************************************

HRESULT
CActorBvr::GetElementImage(IDAImage **ppElementImage)
{
	HRESULT hr = E_FAIL;

	if (m_pElementImage == NULL)
	{
		IDispatch *pFilter = NULL;
		hr = GetElementFilter(&pFilter);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get filter");
			return hr;
		}

		VARIANT varImage;
		VariantInit(&varImage);
		DISPPARAMS params;
		params.rgvarg = NULL;
		params.rgdispidNamedArgs = NULL;
		params.cArgs = 0;
		params.cNamedArgs = 0;

		hr = CallInvokeOnDispatch(pFilter,
                                    L"ElementImage", 
                                    DISPATCH_METHOD,
                                    &params,
                                    &varImage);
		ReleaseInterface(pFilter);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get ElementImage from filter");
			return hr;
		}

		hr = VariantChangeType(&varImage, &varImage, 0, VT_UNKNOWN);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to change type to Unknown");
			VariantClear(&varImage);
			return hr;
		}

		// Query it for IDAImage
		hr = V_UNKNOWN(&varImage)->QueryInterface(IID_TO_PPV(IDAImage, &m_pElementImage));
		VariantClear(&varImage);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get IDAImage");
			return hr;
		}

		// Happiness abounds
	}

	// Return the stashed value
	*ppElementImage = m_pElementImage;
	m_pElementImage->AddRef();

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetCurrentStyle( IHTMLElement *pElement, IHTMLCurrentStyle **ppstyleCurrent )
{
	if( ppstyleCurrent == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;

	IHTMLElement2 *pElement2;
	hr = pElement->QueryInterface( IID_TO_PPV(IHTMLElement2, &pElement2 ) );
	if( SUCCEEDED( hr ) )
	{
		hr = pElement2->get_currentStyle(ppstyleCurrent);
		ReleaseInterface( pElement2 );
		if( FAILED( hr ) ) //failed to get the current style
		{
			DPF_ERR("failed to get the currentSyle off of the current element");
		}
	}
	else //failed to get IHTMLElement2
	{
		DPF_ERR("failed to get IHTMLElement2 off of animated element");
	}
	
	return hr;


}

//*****************************************************************************

HRESULT
CActorBvr::GetPositioningAttributeAsVariant( IHTMLElement *pElement, PosAttrib attrib, VARIANT *pvarAttrib )
{
	if( pvarAttrib == NULL )
		return E_INVALIDARG;

	::VariantClear( pvarAttrib );
	
	HRESULT hr = E_FAIL;
	//we know that this is a positioning property get.  get it without units.
	IHTMLCurrentStyle *pstyleCurrent;
	hr = GetCurrentStyle( pElement, &pstyleCurrent );
	if( SUCCEEDED( hr ) && pstyleCurrent != NULL )
	{
		VARIANT varValue;
		VariantInit(&varValue);

		//if the element we are animating is not vml
 		if( CheckBitNotSet( m_dwCurrentState, ELEM_IS_VML ) )
		{
			LMTRACE2( 1, 1000, L"Getting positioning attrib from current style" );
			switch( attrib )
			{
			case e_posattribLeft:
				hr = pstyleCurrent->get_left( &varValue );
				break;
			case e_posattribTop:
				hr = pstyleCurrent->get_top( &varValue );
				break;
			case e_posattribWidth:
				hr = pstyleCurrent->get_width( &varValue );
				break;
			case e_posattribHeight:
				hr = pstyleCurrent->get_height( &varValue );
				break;
			}
		}
		else // the element is vml get the values from the style itself
		{
			LMTRACE2( 1, 2, L"Getting attribute from vml\n");
			
			IHTMLStyle *pstyle = NULL;

			hr = pElement->get_style( &pstyle );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pstyleCurrent );
				return hr;
			}

			if( pstyle == NULL )
			{
				ReleaseInterface( pstyleCurrent );
				return E_POINTER;
			}
			
			switch( attrib )
			{
				case e_posattribLeft:
					hr = pstyle->get_left( &varValue );
					//TODO: get margin left and add that
					break;
				case e_posattribTop:
					hr = pstyle->get_top( &varValue );
					//TODO: get margin top and add that
					break;
				case e_posattribWidth:
					hr = pstyle->get_width( &varValue );
					break;
				case e_posattribHeight:
					hr = pstyle->get_height( &varValue );
					break;
					
			}
			ReleaseInterface( pstyle );
		}

		//if we got a variant from the element.
		if( SUCCEEDED( hr ) )
		{
			double dblValue = 0;

			if( V_VT(&varValue) == VT_BSTR )
			{
				int length = SysStringLen( V_BSTR(&varValue) );
				if( V_BSTR(&varValue) != NULL && length != 0 && wcsicmp( V_BSTR(&varValue), L"auto" ) != 0 )
				{
					::VariantCopy( pvarAttrib, &varValue );

					::VariantClear( &varValue );
					ReleaseInterface( pstyleCurrent );

					return S_OK;
				}
				else // varValue was either null or had no length or was equal to "auto"
				{
					LMTRACE2( 1, 1000, "value of positioning attribute from the style was empty\n");
					//this means that style.top/left/top/width/height was neither set by the inline style or by css
					// we need to get the left/top/width/height of this element as laid out by trident
					long lValue;
					bool isRelative = false;
					if( attrib == e_posattribLeft || attrib == e_posattribTop )
					{
						//get the position and figure out whether or not we are relative
						BSTR bstrPos = NULL;
						hr = pstyleCurrent->get_position( &bstrPos );
						if( SUCCEEDED( hr ) )
						{
							if( bstrPos != NULL && SysStringLen( bstrPos ) != 0 ) 
							{
								if( wcsicmp( bstrPos, L"absolute" ) != 0 )
									isRelative = true;
								else//if the element is not absolutely positioned then we will set it to relative when we begin
									isRelative = false;
							}
							else //assume we are static and will set the position to relative
								isRelative = true;
						}
						else//failed to get the position from the current style on the animated element
						{
							DPF_ERR("failed to get the position from the current style on the animated element");
						}
						::SysFreeString( bstrPos );
						bstrPos = NULL;
					}
					switch( attrib )
					{
					case e_posattribLeft:
						if( !isRelative )
						{
							hr = pElement->get_offsetLeft( &lValue );
							//we need to account for the marginLeft
							if( SUCCEEDED( hr ) )
							{
								long lMargin = 0;
								hr = GetMarginLeftAsPixel( pElement, pstyleCurrent, &lMargin );
								if( SUCCEEDED( hr ) )
									lValue -= lMargin;
								else
									//ignore errors in the margin code
									hr = S_OK;
								
								if( CheckBitSet( m_dwCurrentState, ELEM_IS_VML ) )
								{
									long lVGXOffset = 0;
									hr = CalculateVGXLeftPixelOffset( pElement, &lVGXOffset );
									if( SUCCEEDED( hr ) )
									{
										LMTRACE2( 1, 2, "\nCorrecting for vgx offset of %d\n\n", lVGXOffset );
										lValue -= lVGXOffset;
									}
									else
									{
										hr = S_OK; //ignore errors.
									}
								}

								
							}
						}
						else
							lValue = 0;
						break;
					case e_posattribTop:
						if( !isRelative )
						{
							hr = pElement->get_offsetTop( &lValue );
							//we need to account for the marginTop
							if( SUCCEEDED( hr ) )
							{
								long lMargin = 0;
								hr = GetMarginTopAsPixel( pElement, pstyleCurrent, &lMargin );
								if( SUCCEEDED( hr ) )
									lValue -= lMargin;
								else
									//ignore errors in the margin code
									hr = S_OK;
								
								if( CheckBitSet( m_dwCurrentState, ELEM_IS_VML ) )
								{
									long lVGXOffset = 0;
									hr = CalculateVGXTopPixelOffset( pElement, &lVGXOffset );
									if( SUCCEEDED( hr ) )
									{
										LMTRACE2( 1, 2, "\nCorrecting for vgx offset of %d\n\n", lVGXOffset );
										lValue -= lVGXOffset;
									}
									else
									{
										hr = S_OK; //ignore errors.
									}
								}
							}
															
						}
						else
						{
							lValue = 0;
						}
						break;
					case e_posattribWidth:
						hr = pElement->get_offsetWidth( &lValue );
						break;
					case e_posattribHeight:
						hr = pElement->get_offsetHeight( &lValue );
						break;
					}
					if( SUCCEEDED( hr ) )
					{
						dblValue = static_cast<double>(lValue);
					}
					else //failed to get offsetWidth from the animated element
					{
						DPF_ERR("failed to get offsetWidth from the animated element");
					}
				}
			}

			if( SUCCEEDED( hr ) )
			{
				// Got the value as a double so now build the VARIANT representing it
				V_VT( pvarAttrib ) = VT_R8;
				V_R8( pvarAttrib ) = dblValue;
			}
		}
		else //failed to get left/top/width/height from the current style
		{
			DPF_ERR("failed to get left, top, width, or height from the current style");
		}

		ReleaseInterface( pstyleCurrent );
		::VariantClear(&varValue);
	}
	else //failed to get the currentSyle off of the animated element
	{
		DPF_ERR("failed to get the currentSyle off of the animated element");
	}
	
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CalculateVGXTopPixelOffset( IHTMLElement *pelem, long *plOffset )
{
	if( pelem == NULL || plOffset == NULL )
	{
		return E_INVALIDARG;
	}
	
	HRESULT hr = S_OK;

	(*plOffset) = 0;

	long lRuntimeTop = 0;
	long lInlineMarginTop = 0;
	long lTopDynamic = 0;
	
	IHTMLStyle *pstyleInline = NULL;
	IHTMLStyle *pstyleRuntime = NULL;

	VARIANT varValue;

	VariantInit( &varValue );

	hr = GetRuntimeStyle( &pstyleRuntime );
	CheckHR( hr, "failed to get the runtime style", end );
	CheckPtr( pstyleRuntime, hr, E_POINTER, "runtimeStyle is null", end );

	hr = GetStyle( &pstyleInline );
	CheckHR( hr, "failed to get the inline style", end );
	CheckPtr( pstyleInline, hr, E_POINTER, "inline style is null", end );

	//get the runtime style value for top
	hr = pstyleRuntime->get_top( &varValue );
	CheckHR( hr, "Failed to get top", end );

	//if we got NULL or "" or "auto for the runtimeStyle.top then bail
	if( V_VT( &varValue ) == VT_BSTR )
	{
		if( V_BSTR(&varValue) == NULL )
		{
			LMTRACE2( 1,2, "Got Null for runtimeStyle.top" );
			goto end;
		}
		if( SysStringLen( V_BSTR(&varValue) ) == 0 || wcsicmp( L"auto", V_BSTR(&varValue) ) == 0 )
		{
			LMTRACE2( 1,2, "Got \"\" or \"auto\" for runtimeStyle.top" );
			goto end;
		}
	}

	hr = VariantToPixelLong( &varValue, &lRuntimeTop, false  );
	CheckHR( hr, "Failed to get the pixel value for runtimeStyle.top", end );
	
	VariantClear( &varValue );
	
	//get the margin top from the inline style
	hr = GetInlineMarginTopAsPixel( pstyleInline, &lInlineMarginTop );
	CheckHR( hr, "Failed to get style.marginTop", end );
	
	//get the dynamic value from the top track
	if( m_ptrackTop != NULL && m_ptrackTop->IsOn() )
	{
		hr = m_ptrackTop->GetDynamic( &varValue );
		CheckHR( hr, "Failed to get the dynamic value of the top track", end );

		hr = VariantToPixelLong( &varValue, &lTopDynamic, true );
		CheckHR( hr, "Failed to convert the topTrack dynamic to pixels", end );

		VariantClear( &varValue );
	}
	//calculate the offset that vgx has made
	LMTRACE2( 1, 2, "calculating vgx offset.  runtimeStyle.top: %d style.marginTop: %d topTrack.dynamic %d\n", lRuntimeTop, lInlineMarginTop, lTopDynamic );
	(*plOffset) = lRuntimeTop-lInlineMarginTop-lTopDynamic;
	
end:
	ReleaseInterface( pstyleInline );
	ReleaseInterface( pstyleRuntime );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetInlineMarginTopAsPixel( IHTMLStyle *pstyleInline, long* plMargin )
{
	if( pstyleInline == NULL || plMargin == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	VARIANT varMargin;
	::VariantInit( &varMargin );

	(*plMargin) = 0;
	
	//get the marginTop from the inline style.
	hr = pstyleInline->get_marginTop( &varMargin );
	CheckHR( hr, "Failed to get the marginTop from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, false );
	CheckHR( hr, "error trying to get a pixel long from marginTop", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}


	//got auto or null for inlineStyle.marginTop, try marginRight
	
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginBottom( &varMargin );
	CheckHR( hr, "Failed to get the marginBottom from the element", end );

	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginBottom", end );

	//if all of the above failed to get a valid value
	//return 0
	
end:
	::VariantClear( &varMargin );
	
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CalculateVGXLeftPixelOffset( IHTMLElement *pelem, long *plOffset )
{
	if( pelem == NULL || plOffset == NULL )
	{
		return E_INVALIDARG;
	}
	
	HRESULT hr = S_OK;

	(*plOffset) = -1;

	long lRuntimeLeft = 0;
	long lInlineMarginLeft = 0;
	long lLeftDynamic = 0;
	
	IHTMLStyle *pstyleInline = NULL;
	IHTMLStyle *pstyleRuntime = NULL;

	VARIANT varValue;

	VariantInit( &varValue );

	hr = GetRuntimeStyle( &pstyleRuntime );
	CheckHR( hr, "failed to get the runtime style", end );
	CheckPtr( pstyleRuntime, hr, E_POINTER, "runtimeStyle is null", end );

	hr = GetStyle( &pstyleInline );
	CheckHR( hr, "failed to get the inline style", end );
	CheckPtr( pstyleInline, hr, E_POINTER, "inline style is null", end );

	//get the runtime style value for left
	hr = pstyleRuntime->get_left( &varValue );
	CheckHR( hr, "Failed to get left", end );

	//if we got NULL or "" or "auto for the runtimeStyle.left then bail
	if( V_VT( &varValue ) == VT_BSTR )
	{
		if( V_BSTR(&varValue) == NULL )
		{
			LMTRACE2( 1,2, "Got Null for runtimeStyle.left" );
			goto end;
		}
		if( SysStringLen( V_BSTR(&varValue) ) == 0 || wcsicmp( L"auto", V_BSTR(&varValue) ) == 0 )
		{
			LMTRACE2( 1,2, "Got \"\" or \"auto\" for runtimeStyle.left" );
			goto end;
		}
	}

	hr = VariantToPixelLong( &varValue, &lRuntimeLeft, true  );
	CheckHR( hr, "Failed to get the pixel value for runtimeStyle.left", end );
	
	VariantClear( &varValue );
	
	//get the margin left from the inline style
	hr = GetInlineMarginLeftAsPixel( pstyleInline, &lInlineMarginLeft );
	CheckHR( hr, "Failed to get style.marginLeft", end );
	
	//get the dynamic value from the left track
	if( m_ptrackLeft != NULL && m_ptrackLeft->IsOn() )
	{
		hr = m_ptrackLeft->GetDynamic( &varValue );
		CheckHR( hr, "Failed to get the dynamic value of the left track", end );

		hr = VariantToPixelLong( &varValue, &lLeftDynamic, true );
		CheckHR( hr, "Failed to convert the leftTrack dynamic to pixels", end );

		VariantClear( &varValue );
	}
	//calculate the offset that vgx has made
	LMTRACE2( 1, 2, "calculating vgx offset.  runtimeStyle.left: %d style.marginLeft: %d leftTrack.dynamic %d\n", lRuntimeLeft, lInlineMarginLeft, lLeftDynamic );
	(*plOffset) = lRuntimeLeft-lInlineMarginLeft-lLeftDynamic;
	
end:
	ReleaseInterface( pstyleInline );
	ReleaseInterface( pstyleRuntime );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetInlineMarginLeftAsPixel( IHTMLStyle *pstyleInline, long* plMargin )
{
	if( pstyleInline == NULL || plMargin == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	VARIANT varMargin;
	::VariantInit( &varMargin );

	(*plMargin) = -1;
	
	//get the marginLeft from the inline style.
	hr = pstyleInline->get_marginLeft( &varMargin );
	CheckHR( hr, "Failed to get the marginLeft from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginLeft", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}


	//got auto or null for inlineStyle.marginLeft, try marginRight
	
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginRight( &varMargin );
	CheckHR( hr, "Failed to get the marginRight from the element", end );

	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginRight", end );

	//if all of the above failed to get a valid value
	//return 0
	
end:
	::VariantClear( &varMargin );
	
	return hr;
}


//*****************************************************************************

HRESULT
CActorBvr::GetPositioningAttributeAsDouble( IHTMLElement *pElement, PosAttrib attrib, double *pDouble, BSTR *pRetUnits)
{
	if( pDouble == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;
	//we know that this is a positioning property get.  get it without units.
	IHTMLCurrentStyle *pstyleCurrent;
	hr = GetCurrentStyle( pElement, &pstyleCurrent );
	if( SUCCEEDED( hr ) && pstyleCurrent != NULL )
	{
		VARIANT varValue;
		VariantInit(&varValue);

		//if the element we are animating is not vml
 		if( CheckBitNotSet( m_dwCurrentState, ELEM_IS_VML ) )
		{
			LMTRACE2( 1, 1000, L"Getting positioning attrib from current style" );
			switch( attrib )
			{
			case e_posattribLeft:
				hr = pstyleCurrent->get_left( &varValue );
				break;
			case e_posattribTop:
				hr = pstyleCurrent->get_top( &varValue );
				break;
			case e_posattribWidth:
				hr = pstyleCurrent->get_width( &varValue );
				break;
			case e_posattribHeight:
				hr = pstyleCurrent->get_height( &varValue );
				break;
			}
		}
		else // the element is vml get the values from the style itself
		{
			LMTRACE2( 1, 2, L"Getting attribute from vml\n");
			
			IHTMLStyle *pstyle = NULL;

			hr = pElement->get_style( &pstyle );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pstyleCurrent );
				return hr;
			}

			if( pstyle == NULL )
			{
				ReleaseInterface( pstyleCurrent );
				return E_POINTER;
			}
			
			switch( attrib )
			{
				case e_posattribLeft:
					hr = pstyle->get_left( &varValue );
					//TODO: get margin left and add that
					break;
				case e_posattribTop:
					hr = pstyle->get_top( &varValue );
					//TODO: get margin top and add that
					break;
				case e_posattribWidth:
					hr = pstyle->get_width( &varValue );
					break;
				case e_posattribHeight:
					hr = pstyle->get_height( &varValue );
					break;
					
			}
			ReleaseInterface( pstyle );
		}

		if( SUCCEEDED( hr ) )
		{
			double dblValue = 0;

			if( V_VT(&varValue) == VT_BSTR )
			{
				int length = SysStringLen( V_BSTR(&varValue) );
				if( V_BSTR(&varValue) != NULL && length != 0 && wcsicmp( V_BSTR(&varValue), L"auto" ) != 0 )
				{
					OLECHAR *pUnits = NULL;
					BSTR bstrValueWithUnits = V_BSTR(&varValue);
					hr = FindCSSUnits( bstrValueWithUnits, &pUnits );
					if( SUCCEEDED( hr )  )
					{
						BSTR bstrValue = NULL;
						if( pUnits != NULL )
						{
							// Copy to return value if necessary
							if (pRetUnits != NULL)
							{
								*pRetUnits = ::SysAllocString(pUnits);
							}

							(*pUnits) = L'\0';
							bstrValue = SysAllocString(bstrValueWithUnits);
							V_BSTR(&varValue) = bstrValue;
							SysFreeString( bstrValueWithUnits );
						}
						// Okay, we have the value as a variant but we need it as a number
						// Force the conversion.
						hr = ::VariantChangeTypeEx(&varValue,
												 &varValue,
												 LCID_SCRIPTING,
												 VARIANT_NOUSEROVERRIDE,
												 VT_R8);
						if( SUCCEEDED( hr ) )
						{
							dblValue = V_R8(&varValue);
							::VariantClear(&varValue);
						}
						else//failed to change the type of a number property to double
						{
							DPF_ERR("failed to change the type of a number property to a double" );
						}

					}
					else//failed to get the units from the returned string
					{
						dblValue = 0;
					}
				}
				else // varValue was either null or had no length or was equal to "auto"
				{
					LMTRACE2( 1, 1000, "value of positioning attribute from the style was empty\n");
					//this means that style.top/left/top/width/height was neither set by the inline style or by css
					// we need to get the left/top/width/height of this element as laid out by trident
					long lValue;
					bool isRelative = false;
					if( attrib == e_posattribLeft || attrib == e_posattribTop )
					{
						//get the position and figure out whether or not we are relative
						BSTR bstrPos = NULL;
						hr = pstyleCurrent->get_position( &bstrPos );
						if( SUCCEEDED( hr ) )
						{
							if( bstrPos != NULL && SysStringLen( bstrPos ) != 0 ) 
							{
								if( wcsicmp( bstrPos, L"absolute" ) != 0 )
									isRelative = true;
								else//if the element is not absolutely positioned then we will set it to relative when we begin
									isRelative = false;
							}
							else //assume we are static and will set the position to relative
								isRelative = true;
						}
						else//failed to get the position from the current style on the animated element
						{
							DPF_ERR("failed to get the position from the current style on the animated element");
						}
						::SysFreeString( bstrPos );
						bstrPos = NULL;
					}
					switch( attrib )
					{
					case e_posattribLeft:
						if( !isRelative )
						{
							hr = pElement->get_offsetLeft( &lValue );
							//we need to account for the marginLeft
							if( SUCCEEDED( hr ) )
							{
								long lMargin = 0;
								hr = GetMarginLeftAsPixel( pElement, pstyleCurrent, &lMargin );
								if( SUCCEEDED( hr ) )
									lValue -= lMargin;
								else
									//ignore errors in the margin code
									hr = S_OK;
							}
						}
						else
							lValue = 0;
						break;
					case e_posattribTop:
						if( !isRelative )
						{
							hr = pElement->get_offsetTop( &lValue );
							//we need to account for the marginTop
							if( SUCCEEDED( hr ) )
							{
								long lMargin = 0;
								hr = GetMarginTopAsPixel( pElement, pstyleCurrent, &lMargin );
								if( SUCCEEDED( hr ) )
									lValue -= lMargin;
								else
									//ignore errors in the margin code
									hr = S_OK;
							}
						}
						else
						{
							lValue = 0;
						}
						break;
					case e_posattribWidth:
						hr = pElement->get_offsetWidth( &lValue );
						break;
					case e_posattribHeight:
						hr = pElement->get_offsetHeight( &lValue );
						break;
					}
					if( SUCCEEDED( hr ) )
					{
						dblValue = static_cast<double>(lValue);
					}
					else //failed to get offsetWidth from the animated element
					{
						DPF_ERR("failed to get offsetWidth from the animated element");
					}
				}
			}
			else //varValue was not a bstr
			{
				//try to coerce it to a double
				hr = ::VariantChangeTypeEx(&varValue,
										 &varValue,
										 LCID_SCRIPTING,
										 VARIANT_NOUSEROVERRIDE,
										 VT_R8);
				if( SUCCEEDED( hr ) )
				{
					dblValue = V_R8(&varValue);
				}
				else//failed to change the type of a number property to double
				{
					DPF_ERR("failed to change the type of a number property to a double" );
					dblValue = 0;
				}
			}

			LMTRACE2( 1, 1000, L"Got a positioning attribute %s whose value is %f\n", ( (attrib==e_posattribLeft) ? L"left":
																			( (attrib==e_posattribTop) ?L"top" : 
																			( (attrib==e_posattribWidth)? L"width": 
																			  L"height" ) ) ) ,dblValue );
			
			if( SUCCEEDED( hr ) )
			{
				// Got the value as a double so now build the DANumber representing it.
				(*pDouble) = dblValue;
			}
			else
			{
				(*pDouble) = 0.0;
			}
		}
		else //failed to get left/top/width/height from the current style
		{
			DPF_ERR("failed to get left, top, width, or height from the current style");
			(*pDouble) = 0.0;
		}

		ReleaseInterface( pstyleCurrent );
		::VariantClear(&varValue);
	}
	else //failed to get the currentSyle off of the animated element
	{
		DPF_ERR("failed to get the currentSyle off of the animated element");
		(*pDouble) = 0.0;
	}
	
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetMarginLeftAsPixel( IHTMLElement *pelem, IHTMLCurrentStyle* pstyleCurrent, long* plMargin )
{
	if( pstyleCurrent == NULL || plMargin == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IHTMLStyle *pstyleInline = NULL;

	VARIANT varMargin;
	::VariantInit( &varMargin );

	(*plMargin) = 0;

	//get the marginLeft from the current style.
	hr = pstyleCurrent->get_marginLeft( &varMargin );
	CheckHR( hr, "Failed to get the marginLeft from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from currentStyle.marginLeft", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}
	
	//we did not get a viable value from currentStyle.marginLeft
	// try currentStyle.marginRight

	//get the marginRight from the current style.
	::VariantClear( &varMargin );
	hr = pstyleCurrent->get_marginRight( &varMargin );
	CheckHR( hr, "Failed to get the marginRight from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginRight", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}

	//we got auto or NULL for both currentStyle.marginLeft and currentStyle.marginRight
	//  fall back to the inline style.

	//get the inline style from the passed element
	hr = pelem->get_style( &pstyleInline );
	CheckHR( hr, "Failed to get the inline style", end );
	CheckPtr( pstyleInline, hr, E_POINTER, "got a null inline style from trident", end );
	
	//get the marginLeft from the inline style.
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginLeft( &varMargin );
	CheckHR( hr, "Failed to get the marginLeft from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginLeft", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}


	//got auto or null for inlineStyle.marginLeft, try marginRight
	
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginRight( &varMargin );
	CheckHR( hr, "Failed to get the marginRight from the element", end );

	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginRight", end );

	//if all of the above failed to get a valid value
	//return 0
	
end:
	ReleaseInterface( pstyleInline );
	::VariantClear( &varMargin );
	
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetMarginTopAsPixel( IHTMLElement *pelem, IHTMLCurrentStyle* pstyleCurrent, long* plMargin )
{
	if( pstyleCurrent == NULL || plMargin == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IHTMLStyle *pstyleInline = NULL;

	VARIANT varMargin;
	::VariantInit( &varMargin );

	(*plMargin) = 0;

	//get the marginTop from the current style.
	hr = pstyleCurrent->get_marginTop( &varMargin );
	CheckHR( hr, "Failed to get the marginTop from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from currentStyle.marginLeft", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}
	
	//we did not get a viable value from currentStyle.marginTop
	// try currentStyle.marginBottom

	//get the marginBottom from the current style.
	::VariantClear( &varMargin );
	hr = pstyleCurrent->get_marginBottom( &varMargin );
	CheckHR( hr, "Failed to get the marginRight from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginBottom", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}

	//we got auto or NULL for both currentStyle.marginTop and currentStyle.marginBottom
	//  fall back to the inline style.

	//get the inline style from the passed element
	hr = pelem->get_style( &pstyleInline );
	CheckHR( hr, "Failed to get the inline style", end );
	CheckPtr( pstyleInline, hr, E_POINTER, "got a null inline style from trident", end );
	
	//get the marginTop from the inline style.
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginTop( &varMargin );
	CheckHR( hr, "Failed to get the marginTop from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginTop", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}


	//got auto or null for inlineStyle.marginLeft, try marginBottom
	
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginRight( &varMargin );
	CheckHR( hr, "Failed to get the marginBottom from the element", end );

	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginBottom", end );

	//if all of the above failed to get a valid value
	//return
	
end:
	ReleaseInterface( pstyleInline );
	::VariantClear( &varMargin );
	
	return hr;
}


//*****************************************************************************

HRESULT
CActorBvr::VariantToPixelLong( VARIANT* pvar, long* pLong, bool fHorizontal )
{

	HRESULT hr = S_OK;

	(*pLong) = 0;
	
	//if the value is a bstr
	if( V_VT( pvar ) == VT_BSTR )
	{
		//if it is not null, and not auto
		if( V_BSTR(pvar) != NULL && 
			_wcsicmp( V_BSTR(pvar), L"auto" ) != 0 )
		{
			//convert it to pixels
			hr = GetPixelValue( pvar, pLong, fHorizontal );
			CheckHR( hr, "Failed to get a pixel value for the marginRight", end );
			//return
			goto end;
		}
		//we got auto or a null value
		hr = S_FALSE;
	}
	else//else it was not a bstr
	{
		//try to convert it to a long
		hr = ::VariantChangeTypeEx( pvar, pvar, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4 );
		CheckHR( hr, "Failed to change the type of returned for the value of marginRight", end );
		
		//return
		(*pLong) = V_I4( pvar );
		goto end;
	}

end:
	return hr;
}

//*****************************************************************************


HRESULT
CActorBvr::GetPixelValue( VARIANT *pvarStringWithUnit, long *plResult, bool bHorizontal )
{
	if( pvarStringWithUnit == NULL || plResult == NULL )
		return E_INVALIDARG;
	//make sure that the variant is a string
	if( V_VT(pvarStringWithUnit) != VT_BSTR || V_BSTR(pvarStringWithUnit) == NULL)
		return E_FAIL;

	HRESULT hr = S_OK;
	int ret = 0;
	//find the css units on the variant
	OLECHAR *pUnits = NULL;
	hr = FindCSSUnits( V_BSTR(pvarStringWithUnit), &pUnits );
	//if css units were not found
	if( hr != S_OK )
	{
		//this value is already in pixels
		//convert it to a long
		ret = swscanf( V_BSTR(pvarStringWithUnit), L"%ld", plResult );
		if( ret == 0 || ret == EOF )
			return E_FAIL;
		else
			return S_OK;
	}
	if( pUnits == NULL )
		return E_FAIL;
	//this value needs to be converted
	//chop the unit string off of the contents of the variant
	double dValue = 0.0;
	OLECHAR cOldValue = (*pUnits);
	(*pUnits) = L'\0';
	//parse the double out of the remaining string
	ret = swscanf( V_BSTR(pvarStringWithUnit), L"%lf", &dValue );
	(*pUnits) = cOldValue;
	if( ret == 0 || ret == EOF )
		return E_FAIL;

	double dConvertedValue = 0.0;
	//TODO:this needs to handle other units as well
	//convert the value from its unit to pixels
	//The key conversions here are
	//  2.54 cm/in
	//  1/72 in/pt
	//  12 pt/pc

	//snag the conversion from inches to pixels from the root dc
	int pixelsPerInch = 1;

	HDC hdc = ::GetDC( NULL );
	if( hdc != NULL )
	{
		if( bHorizontal )
		{
			pixelsPerInch = ::GetDeviceCaps( hdc, LOGPIXELSX );
		}
		else
		{
			pixelsPerInch = ::GetDeviceCaps( hdc, LOGPIXELSY );
		}
		::ReleaseDC( NULL, hdc );
	}
	else
	{
		return E_FAIL;
	}


	if( _wcsicmp( pUnits, L"px" ) == 0 )
	{
		//already in pixels
		dConvertedValue = dValue;
	}
	else if( _wcsicmp( pUnits, L"pt" ) == 0 )
	{
		//convert to in then to cm then to m then to pixels
		dConvertedValue = dValue/72.0*pixelsPerInch;
	}
	else if( _wcsicmp( pUnits, L"pc" ) == 0 )
	{
		//convert to pts then to in then to cm then to m then to pixels
		dConvertedValue = (dValue*12.0)/72.0*pixelsPerInch;
	}
	else if( _wcsicmp( pUnits, L"mm")  == 0 )
	{
		dConvertedValue = dValue/25.4*pixelsPerInch;
	}
	else if( _wcsicmp( pUnits, L"cm") == 0 )
	{
		dConvertedValue = dValue/2.54*pixelsPerInch;
	}
	else if( _wcsicmp( pUnits, L"in") == 0 )
	{
		//convert to cm then to m then to pixels
		dConvertedValue = dValue*pixelsPerInch;
	}
	else
	{
		return E_FAIL;
	}
	//round and assign return value
	(*plResult) = (long)(dConvertedValue + 0.5 );

	return S_OK;

}

//*****************************************************************************


HRESULT
CActorBvr::GetPositioningAttributeAsDANumber( IHTMLElement *pElement, PosAttrib attrib, IDANumber **ppdanum, BSTR *pRetUnits )
{
	if( ppdanum == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;

	double dblValue = 0.0;
	hr = GetPositioningAttributeAsDouble( pElement, attrib, &dblValue, pRetUnits );
	if( SUCCEEDED( hr ) )
	{
		hr = GetDAStatics()->DANumber(dblValue, ppdanum);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to create the number bvr");
			(*ppdanum) = NULL;
		}
	}
	else//Failed to get the positioning attribute as a double
	{
		DPF_ERR("Failed to get the positioning attribute as a double" );	
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetPropAsDANumber(IHTMLElement *pElement,
							 LPWSTR       *pPropNames,
							 int		   numPropNames,
                             IDANumber   **ppdanum,
							 BSTR		  *pRetUnits)
{
    DASSERT(NULL != ppdanum);
    *ppdanum = NULL;

	HRESULT hr = E_FAIL;

	// Check for special cases
	if (numPropNames == 2 && wcsicmp(L"style", pPropNames[0]) == 0)
	{
		if( wcsicmp( pPropNames[1], L"width" ) == 0 )
		{
			return GetPositioningAttributeAsDANumber( pElement, e_posattribWidth, ppdanum, pRetUnits );
		}
		else if( wcsicmp( pPropNames[1], L"height" ) == 0 )
		{
			return GetPositioningAttributeAsDANumber( pElement, e_posattribHeight, ppdanum, pRetUnits );
		}
		else if( wcsicmp( pPropNames[1], L"left" ) == 0 )
		{
			return GetPositioningAttributeAsDANumber( pElement, e_posattribLeft, ppdanum, pRetUnits );
		}
		else if( wcsicmp( pPropNames[1], L"top" ) == 0 )
		{
			return GetPositioningAttributeAsDANumber( pElement, e_posattribTop, ppdanum, pRetUnits );
		}
	}

	double dblValue = 0;
	// Step one is to get the property being animated as a variant.
	VARIANT varValue;
	::VariantInit(&varValue);
	hr = GetPropFromElement(pElement,
							pPropNames,
							numPropNames,
							true,
							&varValue);
	if (FAILED(hr))
	{
		DPF_ERR("Could not get property value from HTML");
		return hr;
	}
	
	//if the variant we got back is a bstr
	if( V_VT(&varValue) == VT_BSTR )
	{
		//strip off the units
		//BUGBUG kurtj we should store these away keyed by the property so that when we
		//  set the property on the element again we can append the unit string
		BSTR bstrVal = V_BSTR(&varValue);
		OLECHAR* pUnits;

		hr = FindCSSUnits( bstrVal, &pUnits );
		if( SUCCEEDED(hr) && pUnits != NULL )
		{
			// Have units.  Copy to output if necessary
			if (pRetUnits != NULL)
			{
				*pRetUnits = ::SysAllocString(pUnits);
			}

			(*pUnits) = L'\0';
			BSTR bstrNewVal = SysAllocString(bstrVal);
			V_BSTR(&varValue) = bstrNewVal;
			SysFreeString(bstrVal);
		}
		//else //no css units, oh well.
		
	}
	// Okay, we have the value as a variant but we need it as a number
	// Force the conversion.
	hr = ::VariantChangeTypeEx(&varValue,
		&varValue,
		LCID_SCRIPTING,
		VARIANT_NOUSEROVERRIDE,
		VT_R8);
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to change the type of a number property to a double" );
		::VariantClear( &varValue );
		return hr;
	}
	dblValue = V_R8(&varValue);
	::VariantClear(&varValue);
	
	// Got the value as a double so now build the DANumber representing it.
	hr = GetDAStatics()->DANumber(dblValue, ppdanum);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to create the number bvr");
		return hr;
	}

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetElementPropAsDANumber(LPWSTR      *pPropNames,
									int			numPropNames,
                                    IDANumber **ppNumber,
									BSTR	   *pRetUnits)
{
	return GetPropAsDANumber(GetHTMLElement(),pPropNames, numPropNames, ppNumber, pRetUnits);
}


//*****************************************************************************

HRESULT
CActorBvr::GetPropFromAnimatedElement( LPWSTR		*pPropNames,
									   int 			numPropNames,
									   bool			current,
									   VARIANT		*pvarResult )
{
	HRESULT hr = S_OK;
	
	IHTMLElement *pelemAnimated = NULL;

	hr = GetAnimatedElement( &pelemAnimated );
	CheckHR( hr, "Failed to get the animated element", end );

	hr = GetPropFromElement( pelemAnimated, pPropNames, numPropNames, current, pvarResult );

end:
	ReleaseInterface( pelemAnimated );
	return hr;
}


//*****************************************************************************


/**
 * Retrieves a variant that represents the value of the given attribute on
 * the given attribute.  Recognizes names that begin with style. as referencing
 * a style attribute.  If current is true, accesses style attributes in
 * currentStyle, not style.
 */
HRESULT 
CActorBvr::GetPropFromElement(IHTMLElement *pElement, 
                                  LPWSTR	   *pPropNames,
								  int			numPropNames,
								  bool			current,
                                  VARIANT		*pReturn)
{
    DASSERT(pElement != NULL);
    DASSERT(pPropNames != NULL);
    DASSERT(pReturn != NULL);

    HRESULT hr;
    // this function supports the possibility that the attribute
    // specified might be style.XXXX where XXXX is the attribute
    // of the HTML style attached to the element.  We will first
    // examine the string to determine if this is the case
    if (numPropNames == 2 && wcsicmp(pPropNames[0], L"style") == 0)
    {
        // they want a style param, we need to get this object and
        // use the string following the "style." for the attribute
		if (current)
		{

			
			if( wcsicmp( pPropNames[1], L"width" ) == 0 )
			{
				return GetPositioningAttributeAsVariant( pElement, e_posattribWidth, pReturn );
			}
			else if( wcsicmp( pPropNames[1], L"height" ) == 0 )
			{
				return GetPositioningAttributeAsVariant( pElement, e_posattribHeight, pReturn );
			}
			else if( wcsicmp( pPropNames[1], L"left" ) == 0 )
			{
				return GetPositioningAttributeAsVariant( pElement, e_posattribLeft, pReturn );
			}
			else if( wcsicmp( pPropNames[1], L"top" ) == 0 )
			{
				return GetPositioningAttributeAsVariant( pElement, e_posattribTop, pReturn );
			}
			

			// Reference currentStyle
			IHTMLCurrentStyle *pCurrStyle = NULL;
			IHTMLElement2 *pElement2 = NULL;
			hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
			if (FAILED(hr))
			{
				DPF_ERR("Error obtaining IHTMLElement2 from HTMLElement");
				return SetErrorInfo(hr);
			}

			hr = pElement2->get_currentStyle(&pCurrStyle);
			ReleaseInterface(pElement2);

			if (FAILED(hr))
			{
				DPF_ERR("Error obtaining current style element from HTML element");
				return SetErrorInfo(hr);
			}

			if(pCurrStyle == NULL)
			{
				DPF_ERR("The current style was null" );
				return E_FAIL;
			}

			hr = pCurrStyle->getAttribute(pPropNames[1], 0, pReturn);
			ReleaseInterface(pCurrStyle);
			if (FAILED(hr))
			{
				DPF_ERR("Error obtaining an attribute from a style object in GetHTMLAttributeFromElement");
    			return SetErrorInfo(hr);
			}
		}
		else
		{
			// Reference the inline style
			IHTMLStyle *pStyle = NULL;
			hr = pElement->get_style(&pStyle);

			if (FAILED(hr))
			{
				DPF_ERR("Error obtaining style element from HTML element in GetHTMLAttributeFromElement");
    			return SetErrorInfo(hr);
			}
			DASSERT(pStyle != NULL);

			hr = pStyle->getAttribute(pPropNames[1], 0, pReturn);
			ReleaseInterface(pStyle);
			if (FAILED(hr))
			{
				DPF_ERR("Error obtaining an attribute from a style object in GetHTMLAttributeFromElement");
    			return SetErrorInfo(hr);
			}
		}
    }
    else if (numPropNames == 1)
    {
		// Just get it off the element directly
        hr = pElement->getAttribute(pPropNames[0], 0, pReturn);
        if (FAILED(hr))
        {
            DPF_ERR("Error obtaining attribute from HTML element in GetHTMLAttributeFromElement");
    		return SetErrorInfo(hr);
        }
    }
	else
	{
		// Multi-component name.  Need to drill down using IDispatch

		// Get a dispatch from element
		IDispatch *pDispatch = NULL;
		hr = pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDispatch));
		if (FAILED(hr))
			return hr;

		// Now loop over the stored property names, except the last one, doing getDispatch
		// Note that we don't care if we fail
		for (int i=0; i<numPropNames-1; i++)
		{
			IDispatch *pPropDispatch = NULL;
			hr = GetPropertyAsDispatch(pDispatch, pPropNames[i], &pPropDispatch);
			ReleaseInterface(pDispatch);
			if (FAILED(hr))
				return S_OK;
	
			pDispatch = pPropDispatch;
		}

		// Now get the final one
		hr = GetPropertyOnDispatch(pDispatch, pPropNames[numPropNames-1], pReturn);
		ReleaseInterface(pDispatch);
		
		return S_OK;

	}

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetPropertyAsDispatch(IDispatch *pDispatch, BSTR name, IDispatch **ppDispatch)
{
    DASSERT(ppDispatch != NULL);
    *ppDispatch = NULL;

    HRESULT hr;
	DISPPARAMS		params;
	VARIANT			varResult;

	VariantInit(&varResult);

	params.rgvarg				= NULL;
	params.rgdispidNamedArgs	= NULL;
	params.cArgs				= 0;
	params.cNamedArgs			= 0;
	
    hr = CallInvokeOnDispatch(pDispatch,
                              name, 
                              DISPATCH_PROPERTYGET,
                              &params,
                              &varResult);

	if (FAILED(hr))
		return hr;

	// Change type to dispatch
	hr = VariantChangeType(&varResult, &varResult, 0, VT_DISPATCH);
	if (FAILED(hr))
	{
		VariantClear(&varResult);
		return hr;
	}

	*ppDispatch = V_DISPATCH(&varResult);
	(*ppDispatch)->AddRef();

	VariantClear(&varResult);

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetPropertyOnDispatch(IDispatch *pDispatch, BSTR name, VARIANT *pReturn)
{
    DASSERT(pReturn != NULL);
	VariantInit(pReturn);

    HRESULT hr;
	DISPPARAMS		params;

	params.rgvarg				= NULL;
	params.rgdispidNamedArgs	= NULL;
	params.cArgs				= 0;
	params.cNamedArgs			= 0;
	
    hr = CallInvokeOnDispatch(pDispatch,
                              name, 
                              DISPATCH_PROPERTYGET,
                              &params,
                              pReturn);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::SetPropertyOnDispatch(IDispatch *pDispatch, BSTR name, VARIANT *pVal)
{
    HRESULT hr = S_OK;
	DISPPARAMS		params;
	VARIANT			varResult;
	VariantInit(&varResult);

    DISPID mydispid = DISPID_PROPERTYPUT;
	params.rgvarg = pVal;
	params.rgdispidNamedArgs = &mydispid;
	params.cArgs = 1;
	params.cNamedArgs = 1;
	hr = CallInvokeOnDispatch(pDispatch,
							  name,
							  DISPATCH_PROPERTYPUT,
							  &params,
							  &varResult);
	VariantClear(&varResult);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::FindCSSUnits( BSTR bstrValWithUnits, OLECHAR** ppUnits )
{
	if( bstrValWithUnits == NULL || ppUnits == NULL )
		return E_INVALIDARG;
	
	int length = SysStringLen(bstrValWithUnits);
	int curChar = length - 1;
	while(curChar >= 0 && (bstrValWithUnits[curChar] < L'0' || bstrValWithUnits[curChar] > L'9') )
		curChar--;
	if( curChar >= 0 && curChar < length-1 )
	{
		(*ppUnits) = &(bstrValWithUnits[curChar+1]);
		return S_OK;
	}
	else
	{
		(*ppUnits) = NULL;
	}
	//the units were either not there or there was no number here.
	return S_FALSE;
}

//*****************************************************************************

HRESULT
CActorBvr::FindTrack(LPWSTR wzPropertyName, ActorBvrType eType, CActorBvr::CBvrTrack **ppTrack)
{
    DASSERT(NULL != wzPropertyName);
	DASSERT(NULL != ppTrack);
	*ppTrack = NULL;

    for (CBvrTrack *ptrackCurrent = m_ptrackHead;
         NULL != ptrackCurrent;
         ptrackCurrent = ptrackCurrent->m_pNext)
    {
        // BUGBUG (ColinMc): Is case insensitive comparison correct here?
        // BUGBUG (ColinMc): Move this code inside the track class?
        DASSERT(NULL != ptrackCurrent->m_bstrPropertyName);
        if (0 == wcsicmp(ptrackCurrent->m_bstrPropertyName, wzPropertyName))
		{
			// Matched the property name.  If the types are different we are in trouble,
			// since it means that we already saw a behavior with a different type
			if (ptrackCurrent->m_eType != eType)
				return E_FAIL;

            // Got a match - return this track...
			*ppTrack = ptrackCurrent;

            return S_OK;
        }
    }

    // If we got this far we have no track of this name and type, return NULL
    return S_OK;
} // FindTrack

//*****************************************************************************

HRESULT
CActorBvr::FindTrackNoType(LPWSTR wzPropertyName, CActorBvr::CBvrTrack **ppTrack)
{
    DASSERT(NULL != wzPropertyName);
	DASSERT(NULL != ppTrack);
	*ppTrack = NULL;

    for (CBvrTrack *ptrackCurrent = m_ptrackHead;
         NULL != ptrackCurrent;
         ptrackCurrent = ptrackCurrent->m_pNext)
    {
        // BUGBUG (ColinMc): Is case insensitive comparison correct here?
        // BUGBUG (ColinMc): Move this code inside the track class?
        DASSERT(NULL != ptrackCurrent->m_bstrPropertyName);
        if (0 == wcsicmp(ptrackCurrent->m_bstrPropertyName, wzPropertyName))
		{
			//WARNING: this does not check the type of the track.  The calling code should ensure that this track is not 
			//  the wrong type.
			
            // Got a match - return this track...
			*ppTrack = ptrackCurrent;

            return S_OK;
        }
    }

    // If we got this far we have no track of this name and type, return NULL
    return S_OK;
} // FindTrack


//*****************************************************************************

HRESULT
CActorBvr::CreateTrack(BSTR           bstrPropertyName,
                       ActorBvrType   eType,
                       CBvrTrack    **pptrack)
{
    DASSERT(NULL != bstrPropertyName);
    DASSERT(NULL != pptrack);
    *pptrack = NULL;

    // Locate the type record for the given type in the type table.
    int i = 0;
    while (i < s_cActorBvrTableEntries)
    {
        if (eType == s_rgActorBvrTable[i].m_eType)
        {
            // Got the entry, create the instance.
            HRESULT hr = (*s_rgActorBvrTable[i].m_fnCreate)(this,
                                                            bstrPropertyName,
                                                            eType,
                                                            pptrack);
            if (FAILED(hr))
            {
                DPF_ERR("Could not create a bvr track");
                return SetErrorInfo(hr);
            }
			//else we found the track and succeeded building it.
			return S_OK;
        }
        i++;
    }
    
    DPF_ERR("No entry found in type table for specified type");
    DASSERT(false);
    return SetErrorInfo(E_FAIL);
} // CreateTrack

//*****************************************************************************

HRESULT
CActorBvr::GetTrack(LPWSTR         wzPropertyName,
                    ActorBvrType   eType,
                    CBvrTrack    **pptrack)
{
    DASSERT(NULL != wzPropertyName);
    DASSERT(NULL != pptrack);
    *pptrack = NULL;

    // Attempt to find a track of the given type driving the given property
	CBvrTrack* ptrack;
	HRESULT hr = FindTrack(wzPropertyName, eType, &ptrack);

	if (FAILED(hr))
	{
		DPF_ERR("Probable track conflict");
		return SetErrorInfo(hr);
	}

    if (NULL == ptrack)
    {
        // No existing track of that type found so create a new one and
        // add it to the track list (at the head).
        HRESULT hr = CreateTrack(wzPropertyName, eType, &ptrack);
        if (NULL == ptrack)
        {
            DPF_ERR("Could not create a new track instance");
            return hr;
        }
        
        // Insert it into the list
        ptrack->m_pNext = m_ptrackHead;
        m_ptrackHead = ptrack;
    }

    // If we got this far we should have a valid track, return it.
    DASSERT(NULL != ptrack);
    *pptrack = ptrack;
    return S_OK;
} // GetTrack

//*****************************************************************************
HRESULT
CActorBvr::BuildAnimation()
{
	HRESULT hr;

    // Discard any cached behaviors we have...
    DiscardBvrCache();

	hr = ApplyTransformTracks();
	if (FAILED(hr))
	{
		DPF_ERR("Failed to apply transform tracks");
		return hr;
	}


	hr = ApplyImageTracks();
	if (FAILED(hr))
	{
		DPF_ERR("Failed to apply image tracks");
		DiscardBvrCache();
		return hr;
	}

	//we are done with the special cases do all of the rest now.

	// Run the track list applying an unused tracks to their properties
    CBvrTrack *ptrack = m_ptrackHead;
    while (NULL != ptrack)
    {
		hr = ptrack->ApplyIfUnmarked();
		if (FAILED(hr))
		{
			DPF_ERR("Failed to apply track to property");
			return SetErrorInfo(hr);
		}

        ptrack = ptrack->m_pNext;
    }

	return S_OK;
}
//*****************************************************************************


HRESULT
CActorBvr::BuildAnimationAsDABehavior()
{
	//this should go away soon...
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::getActorBehavior(BSTR			bstrProperty,
							ActorBvrFlags	eFlags,
							ActorBvrType	eType,
							VARIANT		*pvarRetBvr)
{
	if (NULL == bstrProperty)
	{
		DPF_ERR("Invalid property name passed to getActorBehavior");
		return SetErrorInfo(E_POINTER);
	}

	VariantInit(pvarRetBvr);

    // Attempt to locate the appropriate track for this behavior
    CBvrTrack *ptrack = NULL;
    HRESULT hr = GetTrack(bstrProperty, eType, &ptrack);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get a track for added bvr");
        return hr;
    }

    // Request the behavior from it
	IDABehavior *pResult = NULL;
    hr = ptrack->GetBvr(eFlags, &pResult);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get intermediate bvr");
        return SetErrorInfo(hr);
    }

    // All is well.  Set it into return variant
	V_VT(pvarRetBvr) = VT_UNKNOWN;
	V_UNKNOWN(pvarRetBvr) = pResult;

    return hr;
}

//*****************************************************************************

STDMETHODIMP 
CActorBvr::addBehaviorFragment(BSTR           bstrPropertyName, 
                               IUnknown      *punkAction,
                               IUnknown      *punkActive,
							   IUnknown	     *punkTimeline,
                               ActorBvrFlags  eFlags,
                               ActorBvrType   eType)
{
	return E_NOTIMPL;
} // addBehavior

//*****************************************************************************

STDMETHODIMP 
CActorBvr::addBehaviorFragmentEx(BSTR           bstrPropertyName, 
                                 IUnknown      *punkAction,
                                 IUnknown      *punkActive,
							     IUnknown	   *punkTimeline,
                                 ActorBvrFlags  eFlags,
                                 ActorBvrType   eType,
								 IDispatch		*pdispBehaviorElement,
								 long			*pCookie)
{
	//do not allow fragment adding unless we are processing
	//  rebuild requests
	if( !m_bPendingRebuildsUpdating )
	{
		DPF_ERR( "AddBehaivorFragmentEx called outside the context of a rebuild.");
		DPF_ERR( "You should call requestRebuild and then wait for the call to buildBehaviorFragments." );
		return E_UNEXPECTED;
	}

    if (NULL == bstrPropertyName)
    {
        DPF_ERR("Invalid property name passed to AddBvr");
        return SetErrorInfo(E_POINTER);
    }
    if (NULL == punkAction)
    {
        DPF_ERR("Invalid DA behavior passed to AddBvr");
        return SetErrorInfo(E_POINTER);
    }
    IDABehavior *pdabvrAction = NULL;
    HRESULT hr = punkAction->QueryInterface( IID_TO_PPV(IDABehavior, &pdabvrAction) );
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for DA behavior");
        return SetErrorInfo(hr);
    }
    if (NULL == punkActive)
    {
        DPF_ERR("Invalid DA boolean passed to AddBvr");
        ReleaseInterface(pdabvrAction);
        return SetErrorInfo(E_POINTER);
    }
    IDABoolean *pdaboolActive = NULL;
    hr = punkActive->QueryInterface(IID_TO_PPV(IDABoolean, &pdaboolActive));
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for DA behavior");
        ReleaseInterface(pdabvrAction);
        return SetErrorInfo(hr);
    }

	if (NULL == punkTimeline)
	{
		ReleaseInterface(pdabvrAction);
		ReleaseInterface(pdaboolActive);
		return SetErrorInfo(E_POINTER);
	}
	IDANumber *pdanumTimeline = NULL;
	hr = punkTimeline->QueryInterface(IID_TO_PPV(IDANumber, &pdanumTimeline));
	if (FAILED(hr))
	{
		ReleaseInterface(pdabvrAction);
		ReleaseInterface(pdaboolActive);
		return SetErrorInfo(hr);
	}

    // BUGBUG (ColinMc): Need validation on flags and type

    // Attempt to locate the appropriate track for this behavior
    CBvrTrack *ptrack = NULL;
    hr = GetTrack(bstrPropertyName, eType, &ptrack);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get a track for added bvr");
        ReleaseInterface(pdabvrAction);
        ReleaseInterface(pdaboolActive);
		ReleaseInterface(pdanumTimeline);
        return hr;
    }

    // Now add the new behavior fragment to the track
    hr = ptrack->AddBvrFragment(eFlags, pdabvrAction, pdaboolActive, pdanumTimeline, pdispBehaviorElement, pCookie );
	ReleaseInterface(pdabvrAction);
	ReleaseInterface(pdaboolActive);
	ReleaseInterface(pdanumTimeline);
    if (FAILED(hr))
    {
        DPF_ERR("Could not add the behavior fragment to the track");
        return SetErrorInfo(hr);
    }

	//keep a mapping from the cookie to the track that it was added to
	//  and the type. (needed for remove)
	m_mapCookieToTrack.Insert( (*pCookie), ptrack, eFlags );

    // All is well.
    return hr;
} // addBehavior

//*****************************************************************************

STDMETHODIMP
CActorBvr::removeBehaviorFragment( long cookie )
{
	if( m_bRebuildListLockout || m_fUnloading )
		return E_UNEXPECTED;

	//you can't remove the invalid cookie.
	if( cookie == 0 )
		return E_FAIL;

	HRESULT hr = S_OK;

	IHTMLElement *pelemParent =  NULL;


	CCookieMap::CCookieData *pdata = NULL;


	//if we are not in edit mode
	if( !m_bEditMode )
	{
		//use the queue for removals
		
		//if we are not currently running the list of rebuilds
		if( !m_bPendingRebuildsUpdating )
		{
			hr = EnsureBodyPropertyMonitorAttached();
			CheckHR( hr, "Failed to ensure that the body Poperty monitor was attached", end );

			//save this removal until the next update.
			CBehaviorFragmentRemoval *pNewRemoval = new CBehaviorFragmentRemoval( cookie );
			CheckPtr( pNewRemoval, hr, E_OUTOFMEMORY, "Ran out of memory trying to allocate a behavior removal", end );

			m_listPendingRemovals.push_back( pNewRemoval );

			goto end;

		}
	}

	pdata = m_mapCookieToTrack.GetDataFor( cookie );
	CheckPtr( pdata, hr, E_FAIL, "Failed to find a track for the given cookie in remove", end);

	hr = pdata->m_pTrack->RemoveBvrFragment( pdata->m_eFlags, cookie );
	CheckHR( hr, "Failed to remove a behavior fragment from its track", end );

	hr = GetHTMLElement()->get_parentElement( &pelemParent );

	if( pelemParent != NULL && !m_bPendingRebuildsUpdating )
	{
		hr = rebuildNow();
		CheckHR( hr, "Failed to rebuild the actor behavior after a behavior was removed.", end );
	}

end:
	ReleaseInterface( pelemParent );

	return hr;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::requestRebuild( IDispatch *pdispBehaviorElement )
{

	LMTRACE2( 1, 1000, L"Rebuild requested for element distpatch <%p> on Actor <%p>\n", pdispBehaviorElement, this );

	HRESULT hr = S_OK;
	
	if( pdispBehaviorElement == NULL )
		return E_INVALIDARG;

	if( m_bRebuildListLockout )
		return E_UNEXPECTED;

	//if there is a rebuild already pending for this dispatch then 
	// remove it

	//we have to use IUnknown to compare pointers because Trident returns different pointers
	//  for IDispatch.
	IUnknown *punkBehaviorElement = NULL;

	hr = pdispBehaviorElement->QueryInterface( IID_TO_PPV( IUnknown, &punkBehaviorElement ) );
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to QI IDisp for IUnknown !!?!" );
		return hr;
	}
	
	//loop through the pending rebuild requests removing any requests for this disp.
	BehaviorRebuildList::iterator iterCurRebuild = m_listPendingRebuilds.begin();
	
	for( iterCurRebuild = m_listPendingRebuilds.begin(); 
		 iterCurRebuild != m_listPendingRebuilds.end(); 		 	
		 iterCurRebuild ++ )
	{
		if( (*iterCurRebuild)->IsRebuildFor( punkBehaviorElement ) )
		{
            delete (*iterCurRebuild);
            (*iterCurRebuild) = NULL;
			//erase the rebuild request
			m_listPendingRebuilds.erase( iterCurRebuild );
			//there can be only one.
			break;
		}
	}

	ReleaseInterface( punkBehaviorElement );

	//add a new request at the end of the queue.
	
	CBehaviorRebuild *pNewRequest = new CBehaviorRebuild( pdispBehaviorElement );

	//if we are not currently updating the pending rebuild list
	if( !m_bPendingRebuildsUpdating )
	{
		EnsureBodyPropertyMonitorAttached();
		//add this request to the pending list
		m_listPendingRebuilds.push_back( pNewRequest );

		if( m_bEditMode )
		{
			//request that the containing app call us back to 
			// rebuild
			RequestRebuildFromExternal();
		}

	}
	else
	{
		//add this request to the update pending list so it will
		// get added after the update has completed
		m_listUpdatePendingRebuilds.push_back( pNewRequest );
	}

	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::cancelRebuildRequests( IDispatch *pdispBehaviorElement )
{
	if( pdispBehaviorElement == NULL )
		return E_FAIL;

	HRESULT hr = S_OK;

	IUnknown *punkBehaviorElement = NULL;

	hr = pdispBehaviorElement->QueryInterface( IID_TO_PPV( IUnknown, &punkBehaviorElement ) );
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to QI IDisp for IUnknown !!?!" );
		return hr;
	}

	//loop through the pending rebuild requests removing any requests for this disp.
	BehaviorRebuildList::iterator iterCurRebuild = m_listPendingRebuilds.begin();

	for( iterCurRebuild = m_listPendingRebuilds.begin(); 
		 iterCurRebuild != m_listPendingRebuilds.end(); 		 	
		 iterCurRebuild ++ )
	{
		if( (*iterCurRebuild)->IsRebuildFor( punkBehaviorElement ) )
		{
            delete (*iterCurRebuild);
            (*iterCurRebuild) = NULL;
			//erase the rebuild request
			m_listPendingRebuilds.erase( iterCurRebuild );
			//there can be only one
			break;
		}
	}

	ReleaseInterface( punkBehaviorElement );

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::rebuildNow()
{
	HRESULT hr = S_OK;

	hr = ProcessPendingRebuildRequests();
	CheckHR( hr, "Failed to rebuild the actor", end );

end:
	return hr;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::getStatic( BSTR bstrTrackName, VARIANT *varRetStatic )
{
	if( bstrTrackName == NULL || varRetStatic == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	CBvrTrack *ptrack = NULL;

	::VariantClear( varRetStatic );
	
	//find the track for bstrTrackName
	hr = FindTrackNoType( bstrTrackName, &ptrack );
	//if the track was found
	if( ptrack != NULL && ptrack->IsAnimated() )
	{
		//get the static value from the track
		hr = ptrack->GetStatic( varRetStatic );
		CheckHR( hr, "Failed to get the static from a track", end );
		//return it
	}
	else //else the track was not found
	{
		//just return null;
		hr = E_UNEXPECTED;
	}
end:

	return hr;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::setStatic( BSTR bstrTrackName, VARIANT varStatic )
{
	if( bstrTrackName == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	CBvrTrack *ptrack = NULL;
	//find the track named bstrTrackName
	hr = FindTrackNoType( bstrTrackName, &ptrack );
	CheckHR( hr, "Failed to find the track in setStatic", end );

	//if the track was found
	if( ptrack != NULL )
	{
		if( V_VT( &varStatic ) == VT_NULL )
		{
			if( !ptrack->IsOn() )
			{
				ptrack->UpdateStaticBvr();
			}
		}
		else if( V_VT( &varStatic ) == VT_EMPTY )
		{
			if( ptrack->IsOn() )
			{
				hr = S_OK;
			}
			else
			{
				hr = S_FALSE;
			}
		}
		else
		{
			//set the new static value into the track
			hr = ptrack->PutStatic( &varStatic );
			CheckHR( hr, "Failed to set the static", end );
		}
	}
	else//else the track was not found
	{
		//TODO: do we create the track here?
		hr = E_UNEXPECTED;
	}

end:
	return hr;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::getDynamic( BSTR bstrTrackName, VARIANT *varRetDynamic )
{
	if( bstrTrackName == NULL || varRetDynamic == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	CBvrTrack *ptrack = NULL;

	::VariantClear( varRetDynamic );
	
	//find the track for bstrTrackName
	hr = FindTrackNoType( bstrTrackName, &ptrack );
	//if the track was found
	if( ptrack != NULL  && ptrack->IsAnimated() )
	{
		//get the static value from the track
		hr = ptrack->GetDynamic( varRetDynamic );
		CheckHR( hr, "Failed to get the static from a track", end );
		//return it
	}
	else //else the track was not found
	{
		//just return null;
		hr = E_UNEXPECTED;
	}
end:

	return hr;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::applyStatics( )
{
	HRESULT hr = S_OK;
	//for each track
    for (CBvrTrack *ptrackCurrent = m_ptrackHead;
         NULL != ptrackCurrent;
         ptrackCurrent = ptrackCurrent->m_pNext)
    {

		//if the track is active
		if( ptrackCurrent->IsOn() )
		{
			//apply its static value to the track
			hr = ptrackCurrent->ApplyStatic();
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to apply the static for a track" );
			}
		}
	}
	
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::applyDynamics( )
{
	HRESULT hr = S_OK;
	//for each track
    for (CBvrTrack *ptrackCurrent = m_ptrackHead;
         NULL != ptrackCurrent;
         ptrackCurrent = ptrackCurrent->m_pNext)
    {

		//if the track is active
		if( ptrackCurrent->IsOn() )
		{
			//apply its synamic value to the track
			hr = ptrackCurrent->ApplyDynamic();
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to apply the dynamic for a track" );
			}
		}
	}
	
	return S_OK;
}

//*****************************************************************************


STDMETHODIMP
CActorBvr::addMouseEventListener(LPUNKNOWN pUnkListener)
{
	return m_pEventManager->AddMouseEventListener( pUnkListener );

} // addMouseListener

//*****************************************************************************

STDMETHODIMP
CActorBvr::removeMouseEventListener(LPUNKNOWN pUnkListener)
{
	return m_pEventManager->RemoveMouseEventListener( pUnkListener );

} // addMouseListener

//*****************************************************************************

HRESULT
CActorBvr::ReleaseAnimation()
{
	HRESULT hr = S_OK;
	//release all of the tracks
	ReleaseTracks();
	//release all of the image infos
	ReleaseImageInfo();
	//detach the event manager
	if( m_pEventManager != NULL )
	{
		m_pEventManager->Deinit();
	}
	//uninit the property sink
	UnInitPropertySink();
	//release the float manager
	ReleaseFloatManager();

	DiscardBvrCache();

	ReleaseInterface( m_pPixelWidth );
	ReleaseInterface( m_pPixelHeight );

	ReleaseInterface( m_pVMLRuntimeStyle );

	return hr;

}//ReleaseAnimation

//*****************************************************************************

void
CActorBvr::ReleaseFinalElementDimensionSampler()
{
	if( m_pFinalElementDimensionSampler != NULL )
	{
		delete m_pFinalElementDimensionSampler;
		m_pFinalElementDimensionSampler = NULL;
	}
}//ReleaseFinalElementDimensionSampler

//*****************************************************************************

void
CActorBvr::ReleaseFloatManager()
{
	if( m_pFloatManager != NULL )
	{
		delete m_pFloatManager;
		m_pFloatManager = NULL;
	}
}//ReleaseFloatManager

//*****************************************************************************

void
CActorBvr::ReleaseEventManager()
{
	HRESULT hr = S_OK;

	if( m_pEventManager != NULL )
	{
		hr = m_pEventManager->Deinit();
		if( FAILED( hr ) )
		{
			DPF_ERR("Failed to deinit event manager before destroying it" );
		}
		delete m_pEventManager;
	}
}

//*****************************************************************************

void
CActorBvr::ReleaseTracks()
{

	m_ptrackTop  = NULL;
	m_ptrackLeft = NULL;
	
	CBvrTrack *ptrackCurrent = m_ptrackHead;
    while (ptrackCurrent != NULL)
    {
        CBvrTrack *ptrackNext = ptrackCurrent->m_pNext;
		ptrackCurrent->Detach();
        delete ptrackCurrent;
        ptrackCurrent = ptrackNext;
    }
	m_ptrackHead = NULL;

}//ReleaseTracks

//*****************************************************************************


HRESULT
CActorBvr::GetComposedBvr(LPWSTR          wzPropertyName,
                          ActorBvrType    eType,
                          IDABehavior   **ppResult)
{
	HRESULT hr = S_OK;

    DASSERT(NULL != wzPropertyName);
	DASSERT(ppResult != NULL);
	*ppResult = NULL;

    // Get the track for this property - forces creation if not there
    CBvrTrack *ptrack = NULL;
	hr = GetTrack(wzPropertyName, eType, &ptrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	hr = ptrack->GetComposedBvr(ppResult);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get composed behavior for named bvr");
        return hr;
    }

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetFinalBvr(LPWSTR          wzPropertyName,
                       ActorBvrType    eType,
                       IDABehavior   **ppResult)
{
	HRESULT hr = S_OK;

    DASSERT(NULL != wzPropertyName);
	DASSERT(ppResult != NULL);
	*ppResult = NULL;

    // Get the track for this property - forces creation if not there
    CBvrTrack *ptrack = NULL;
	hr = GetTrack(wzPropertyName, eType, &ptrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	hr = ptrack->GetFinalBvr(ppResult);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get final behavior for named bvr");
        return hr;
    }

	return S_OK;
}

//*****************************************************************************
HRESULT
CActorBvr::IsAnimatedElementVML(bool *pResult)
{
	HRESULT hr = S_OK;

	DASSERT(pResult != NULL);
	*pResult = false;

	IHTMLElement *pElement = NULL;
	hr = GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;



	// Just look on the element to see if it supports rotation
	// (Recommended by Robert Parker)
	IDispatch *pDisp = NULL;
	hr = pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDisp));

	if (FAILED(hr))
	{
		ReleaseInterface(pElement);
        DPF_ERR("Error QI'ing IHTMLElement for IDispatch failed");
		return SetErrorInfo(hr);
	}

    DISPID dispid;
	LPWSTR propName = L"rotation";
    hr = pDisp->GetIDsOfNames(IID_NULL, 
                              &propName, 
                              1,
                              LOCALE_SYSTEM_DEFAULT, 
                              &dispid); 
	ReleaseInterface(pDisp);


	//if we failed to find that the element was vml using the more correct method
	if( FAILED( hr ) )
	{
		//try checking the scope name
		IHTMLElement2 *pelem2 = NULL;
		hr = pElement->QueryInterface( IID_TO_PPV( IHTMLElement2, &pelem2 ) );
		ReleaseInterface( pElement );
		if( FAILED( hr ) )
		{
			return hr;
		}

		BSTR bstrScopeName = NULL;

		hr = pelem2->get_scopeName( &bstrScopeName );
		ReleaseInterface( pelem2 );
		if( FAILED( hr ) )
		{
			return hr;
		}

		//we assume that the scopeName for VML shapes is "v" here.  
		if( bstrScopeName != NULL && wcsicmp( bstrScopeName, L"v" ) == 0 )
		{
			*pResult = true;
		}

		SysFreeString( bstrScopeName );
		bstrScopeName = NULL;
	} else {
		ReleaseInterface(pElement);
		*pResult = true;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetRotationFinalBvr(IDATransform2 **ppRotation)
{
    HRESULT hr = S_OK;

    DASSERT(NULL != ppRotation);
    *ppRotation = NULL;

	bool isVML;
	hr = IsAnimatedElementVML(&isVML);
	if (FAILED(hr))
		return hr;

	if (isVML)
	{
		// Do rotation normally through style.rotation
		return S_OK;
	}

    // Get the track for this property
    CBvrTrack *ptrack = NULL;
	hr = FindTrack(L"style.rotation", e_Number, &ptrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	IDANumber *pNumber = NULL;

	if (ptrack != NULL)
	{
        // We have a track driving the rotation, fetch the composite behavior

		// First, figure out what the original transform is.  We need to do this
		// here rather than in the static bvr of the transform track so that we
		// avoid creating a non-null final bvr when no-one is trying to animate
		// this transform

		//begin a rebuild for the rotation track
		ptrack->BeginRebuild();
		ptrack->StructureChange();
		
		IDANumber *pOriginal = NULL;
		hr = GetOriginalRotation(&pOriginal);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get original transform");
			return hr;
		}

		// Note: pOriginal is potentially NULL

        IDABehavior *pdabvrTemp = NULL;
		hr = ptrack->GetFinalBvr(pOriginal, &pdabvrTemp);
		ReleaseInterface(pOriginal);
        if (FAILED(hr))
        {
            DPF_ERR("Could not get final behavior for named bvr");
            return SetErrorInfo(hr);
        }

		// Mark the track as something that should not get applied
		ptrack->DoNotApply();

		if( pdabvrTemp != NULL )
		{
			// Now QI for IDANumber
			hr = pdabvrTemp->QueryInterface( IID_TO_PPV(IDANumber, &pNumber) );
			ReleaseInterface(pdabvrTemp);
			if (FAILED(hr))
			{
				DPF_ERR("Could not QI for DANumber for named bvr");
				return SetErrorInfo(hr);
			}
		}
    }
	else
	{
		// No track.  Need to check the style attribute for rotation
		hr = GetOriginalRotation(&pNumber);
		if (FAILED(hr))
			return hr;
	}

	if (pNumber == NULL)
	{
		// This is OK - it just means the overall transform is NULL
		return S_OK;
	}

	//convert the number behavior to a transform bvr
	// Negate it
	IDANumber *pNegNumber = NULL;
	hr = GetDAStatics()->Neg(pNumber, &pNegNumber);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;
	pNumber = pNegNumber;
	pNegNumber = NULL;

	// Convert to radians
	IDANumber *pNumberRadians = NULL;
	hr = GetDAStatics()->ToRadians(pNumber, &pNumberRadians);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	// Turn it into a rotation transform
	hr = GetDAStatics()->Rotate2Anim(pNumberRadians, ppRotation);
	ReleaseInterface(pNumberRadians);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetTransformFinalBvr(LPWSTR          wzPropertyName,
                                ActorBvrType    eType,
                                IDATransform2 **ppdabvrTransform)
{
    HRESULT hr = S_OK;

    DASSERT(NULL != ppdabvrTransform);
    *ppdabvrTransform = NULL;

    // Get the track for this property
    CBvrTrack *ptrack = NULL;
	hr = FindTrack(wzPropertyName, eType, &ptrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	if (ptrack != NULL && ptrack->IsAnimated() )
	{
        // We have a track driving the transform, fetch the composite behavior

		// First, figure out what the original transform is.  We need to do this
		// here rather than in the static bvr of the transform track so that we
		// avoid creating a non-null final bvr when no-one is trying to animate
		// this transform
		IDATransform2 *pOriginal = NULL;
		switch (eType)
		{
		case e_Translation:
			hr = GetOriginalTranslation(&pOriginal);
			break;

		case e_Scale:
			hr = GetOriginalScale(&pOriginal);
			break;

		default:
			hr = E_INVALIDARG;
			break;
		}

		if (FAILED(hr))
		{
			DPF_ERR("Failed to get original transform");
			return hr;
		}

		//if this is the translation track that we are getting force it to rebuild
		// since the top and/or left may have changed
		if( eType == e_Translation )
		{
			ptrack->ForceRebuild();
		}
		else
		{
			//other tracks need to begin rebuild so that they are clean.
			ptrack->BeginRebuild();
			ptrack->StructureChange();
		}

		// Note: pOriginal is potentially NULL
		
		if( eType==e_Scale && pOriginal != NULL )
		{
			IDABoolean *pdaboolTrue;
			hr = GetDAStatics()->get_DATrue( &pdaboolTrue );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pOriginal );
				DPF_ERR("Failed to get DATrue from DAStatics" );
				return SetErrorInfo(hr);
			}
			hr = ptrack->OrWithOnBvr( pdaboolTrue );
			ReleaseInterface( pdaboolTrue );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pOriginal );
				DPF_ERR("Failed to or true with the on bvr for Track" );
				return hr;
			}

		}
		

        IDABehavior *pdabvrTemp = NULL;
		hr = ptrack->GetFinalBvr(pOriginal, &pdabvrTemp);
		ReleaseInterface(pOriginal);

        if (FAILED(hr))
        {
            DPF_ERR("Could not get final behavior for named bvr");
            return SetErrorInfo(hr);
        }

		if (pdabvrTemp != NULL)
		{
			// Now QI for transform2
			hr = pdabvrTemp->QueryInterface( IID_TO_PPV(IDATransform2, ppdabvrTransform) );
			ReleaseInterface(pdabvrTemp);
			if (FAILED(hr))
			{
				DPF_ERR("Could not QI for Transform2 for named bvr");
				return SetErrorInfo(hr);
			}
		}
		else
		{
			*ppdabvrTransform = NULL;
		}
    }
	else
	{
		// No track.  For the cases of rotation and scale we also need to check the
		// actor attributes.  Note that we avoid doing this for translation, since that
		// always returns an original value gleaned from the style
		switch (eType)
		{
		case e_Translation:
			hr = S_OK;
			break;

		case e_Scale:
			hr = GetOriginalScale(ppdabvrTransform);
			break;

		default:
			hr = E_INVALIDARG;
			break;
		}

		if (FAILED(hr))
			return hr;
	}

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetOriginalTranslation( IDATransform2 **ppdatfmOrig )
{
	HRESULT hr = S_OK;

	DASSERT(ppdatfmOrig != NULL);
	*ppdatfmOrig = NULL;

	// This needs to return a translation of original top and left.  We get it
	// out of the top and left tracks so that we take into account any animation
	// that authors might have done directly on these values.
	IDABehavior *temp = NULL;
	hr = GetComposedBvr(L"style.top", e_Number, &temp);
	if (FAILED(hr))
		return hr;

	IDANumber *top = NULL;
	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &top));
	ReleaseInterface(temp);
	if (FAILED(hr))
		return hr;

	hr = GetComposedBvr(L"style.left", e_Number, &temp);
	if (FAILED(hr))
	{
		ReleaseInterface(top);
		return hr;
	}

	IDANumber *left = NULL;
	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &left));
	ReleaseInterface(temp);
	if (FAILED(hr))
	{
		ReleaseInterface(top);
		return hr;
	}

	IDATransform2 *translation = NULL;
	hr = GetDAStatics()->Translate2Anim(left, top, &translation);
	ReleaseInterface(left);
	ReleaseInterface(top);
	if (FAILED(hr))
		return hr;

	*ppdatfmOrig = translation;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetOriginalRotation( IDANumber **ppRotation )
{
	HRESULT hr = S_OK;

	if( ppRotation == NULL )
		return E_INVALIDARG;

	*ppRotation = NULL;

	IDANumber *pNumber = NULL;
	LPWSTR args[] = { L"style", L"rotation" };
	BSTR units = NULL;
	hr = GetElementPropAsDANumber(args, 2, &pNumber, &units);
	if (FAILED(hr))
	{
		// Means there is no rotation argument, return NULL
		return S_OK;
	}

	if (units != NULL)
	{
		IDANumber *pConverted = NULL;
		hr = ConvertToDegrees(pNumber, units, &pConverted);
		if (SUCCEEDED(hr))
		{
			ReleaseInterface(pNumber);
			pNumber = pConverted;
		}

		::SysFreeString(units);
	}

	*ppRotation = pNumber;

	return S_OK;
}

HRESULT
CActorBvr::ConvertToDegrees(IDANumber *pNumber, BSTR units, IDANumber **ppConverted)
{
	HRESULT hr = S_OK;

	// If there were units, we need to convert into degrees
	if (units != NULL)
	{
		if (wcsicmp(units, L"fd") == 0)
		{
			IDANumber *pfdConv = NULL;
			hr = GetDAStatics()->DANumber(65536, &pfdConv);
			if (FAILED(hr))
				return hr;

			hr = GetDAStatics()->Div(pNumber, pfdConv, ppConverted);
			ReleaseInterface(pfdConv);
			
			return hr;
		}
		else if (wcsicmp(units, L"rad") == 0)
		{
			return GetDAStatics()->ToDegrees(pNumber, ppConverted);
		}
		else if (wcsicmp(units, L"grad") == 0)
		{
		}
	}

	// No known units, no conversion
	return E_FAIL;
}


//*****************************************************************************

HRESULT
CActorBvr::GetOriginalScale( IDATransform2 **ppdatfmOrig )
{
	HRESULT hr = S_OK;

	if( ppdatfmOrig == NULL )
		return E_INVALIDARG;

	*ppdatfmOrig = NULL;

    int cReturnedValues;
	float scaleVal[3];


    hr = CUtils::GetVectorFromVariant(&m_varScale, 
                                      &cReturnedValues, 
                                      &(scaleVal[0]), 
                                      &(scaleVal[1]), 
                                      &(scaleVal[2]));

	if (FAILED(hr) || cReturnedValues != 2)
	{
		// This is OK, since it just means they didn't set an appropriate scale.
		return S_OK;
	}

	// Create a scale transform
	hr = GetDAStatics()->Scale2(scaleVal[0]/100.0f, scaleVal[1]/100.0f, ppdatfmOrig);
	if (FAILED(hr))
		return hr;
	
	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::BuildTransformCenter()
{
	//TODO(kurtj): check to see if anyone has set the transform center and use that

	HRESULT hr = S_OK;

	if( m_pTransformCenter != NULL )
		ReleaseInterface( m_pTransformCenter);

	// Currently we just do the default - which is half the original width and height
	// We use m_pOrigWidthHeight.  If this is not set yet it means there's and error
	if (m_pOrigWidthHeight == NULL)
	{
		DPF_ERR("Orig width and height are not set yet");
		return E_FAIL;
	}

	VARIANT varTransCenter;
	VariantInit(&varTransCenter);
	BSTR attrName = ::SysAllocString(L"transformCenter");
	if (attrName != NULL)
	{
		hr = GetHTMLElement()->getAttribute(attrName, 0, &varTransCenter);
		::SysFreeString(attrName);

		if (SUCCEEDED(hr))
		{
			float cx, cy, cz;
			int cValues;

			hr = CUtils::GetVectorFromVariant(&varTransCenter, &cValues, &cx, &cy, &cz);
			VariantClear(&varTransCenter);

			if (SUCCEEDED(hr) && cValues == 2)
			{
				hr = GetDAStatics()->Vector2(cx, cy, &m_pTransformCenter);
				if (SUCCEEDED(hr))
					return S_OK;
			}
		}
	}

	// Scale m_pOrigWidthHeight by .5
	hr = m_pOrigWidthHeight->Mul(.5, &m_pTransformCenter);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to scale center");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetUnitToMeterBvr(BSTR bstrFrom, IDANumber ** ppnumToMeters, double dPixelPerPercent)
{
	HRESULT	hr = S_OK;
	
	IDANumber * pnumMetersPerPixel = NULL;
	IDANumber * pnumPixelPerPercent = NULL;

	hr = GetDAStatics()->get_Pixel( &pnumMetersPerPixel );
	CheckHR(hr, L"GetUnitToMeterBvr failed", done);

	if ( bstrFrom == NULL || wcsicmp(bstrFrom, L"px") == 0 )
	{
		*ppnumToMeters = pnumMetersPerPixel;
		(*ppnumToMeters)->AddRef();
	}
	else if ( wcsicmp(bstrFrom, L"in") == 0 )
		hr = GetDAStatics()->DANumber(METERS_PER_INCH, ppnumToMeters);
	else if ( wcsicmp(bstrFrom, L"cm") == 0 )
		hr = GetDAStatics()->DANumber(0.01, ppnumToMeters);
	else if ( wcsicmp(bstrFrom, L"mm") == 0 )
		hr = GetDAStatics()->DANumber(0.001, ppnumToMeters);
	else if ( wcsicmp(bstrFrom, L"pt") == 0 )
		hr = GetDAStatics()->DANumber(1.0/POINTS_PER_INCH*METERS_PER_INCH, ppnumToMeters);
	else if ( wcsicmp(bstrFrom, L"pc") == 0 )
		hr = GetDAStatics()->DANumber(POINTS_PER_PICA * 1.0/POINTS_PER_INCH * METERS_PER_INCH, ppnumToMeters);
	else if ( wcsicmp(bstrFrom, L"%") == 0 )
	{
		hr = GetDAStatics()->DANumber(dPixelPerPercent, &pnumPixelPerPercent);
		CheckHR(hr, L"GetUnitToMeterBvr failed", done);

		hr = GetDAStatics()->Mul(pnumMetersPerPixel, pnumPixelPerPercent, ppnumToMeters);
		
	}
	// TODO: do the rest: em and ex
	else
		hr = E_FAIL;

	CheckHR(hr, L"GetUnitToMeterBvr failed", done);
	
done:
	ReleaseInterface(pnumMetersPerPixel);
	ReleaseInterface(pnumPixelPerPercent);
	
	return hr;
}

//*****************************************************************************

UnitType
CActorBvr::GetUnitTypeFromString( LPOLESTR strUnits )
{
	if ( strUnits == NULL || wcsicmp( strUnits, L"px" ) == 0 )
		return e_px;
	else if ( wcsicmp(strUnits, L"in") == 0 )
		return e_in;
	else if ( wcsicmp(strUnits, L"cm") == 0 )
		return e_cm;
	else if ( wcsicmp(strUnits, L"mm") == 0 )
		return e_mm;
	else if ( wcsicmp(strUnits, L"pt") == 0 )
		return e_pt;
	else if ( wcsicmp(strUnits, L"pc") == 0 )
		return e_pc;
	else if( wcsicmp(strUnits, L"em") ==  0 )
		return e_em;
	else if( wcsicmp(strUnits, L"ex") ==  0 )
		return e_ex;
	else if( wcsicmp(strUnits, L"%") ==  0 )
		return e_percent;

	return e_unknownUnit;
}

//*****************************************************************************

int
CActorBvr::GetPixelsPerInch( bool fHorizontal )
{
	//Note: we do not cache the pixels per inch here because if someone changes
	// the screen reslolution we would not pick up the change.
	HDC hdc = ::GetDC( NULL );

	int pixelsPerInch = 1;
	
	if( hdc != NULL )
	{
		if( fHorizontal )
		{
			pixelsPerInch = ::GetDeviceCaps( hdc, LOGPIXELSX );
		}
		else
		{
			pixelsPerInch =  ::GetDeviceCaps( hdc, LOGPIXELSY );
		}
		::ReleaseDC( NULL, hdc );
	}

	return pixelsPerInch;
}


//*****************************************************************************

HRESULT
CActorBvr::GetUnitConversionBvr(BSTR bstrFrom, BSTR bstrTo, IDANumber ** ppnumConvert, double dPixelPerPercent)
{
	if ( (bstrFrom == NULL && bstrTo == NULL) ||
		 (bstrFrom != NULL && bstrTo != NULL && wcsicmp(bstrFrom, bstrTo) == 0 ) )
	{
		return GetDAStatics()->DANumber(1.0, ppnumConvert);
	}
	
	HRESULT		hr = S_OK;

	UnitType fromUnits = GetUnitTypeFromString( bstrFrom );
	UnitType toUnits = GetUnitTypeFromString( bstrTo );
	double conversionFactor = 1.0;

	//check for units that we don't yet handle
	if( fromUnits == e_em || toUnits == e_em || 
		fromUnits == e_ex || toUnits == e_ex )
	{
		LMTRACE2( 1, 2, "Unsupported unit conversion from %S to %S\n", bstrFrom, bstrTo );
		return E_FAIL;
	}

	//if we are converting from percent
	if( fromUnits == e_percent )
	{
		//first convert to pixels
		conversionFactor *= dPixelPerPercent;
		//then convert from pixels to the target unit.
		fromUnits = e_px;
	}

	//if the from unit is pixels 
	if( fromUnits == e_px )
	{
		//we need to convert from pixels to inches
		conversionFactor /= ((double)GetPixelsPerInch( true ));
		//then convert from inches to the to unit
		fromUnits = e_in;
	}

	if( fromUnits != toUnits )
	{
		// if the to unit is not pixels 
		if( toUnits == e_px )		
		{
			//multiply the conversion factor by pixels per inch
			conversionFactor *= ((double)(s_unitConversion[fromUnits][e_in].lNum  *  GetPixelsPerInch(true) )) /  
								((double)(s_unitConversion[fromUnits][e_in].lDenom));
		}
		else if( toUnits == e_percent )
		{
			conversionFactor *= ((double)(s_unitConversion[fromUnits][e_in].lNum  *  GetPixelsPerInch(true) )) /  
								((double)(s_unitConversion[fromUnits][e_in].lDenom * dPixelPerPercent ));
		}
		else
		{
			//get the conversion value as a double
			conversionFactor *= ((double) s_unitConversion[fromUnits][toUnits].lNum) / 
								((double)s_unitConversion[fromUnits][toUnits].lDenom);
		}
	}
	
	hr = GetDAStatics()->DANumber( conversionFactor, ppnumConvert );

	return hr;
}

//*****************************************************************************

// REVIEW: this doesn't work if parent width or height is also being animated
HRESULT CActorBvr::GetPixelsPerPercentValue(double& dPixelPerPercentX, double& dPixelPerPercentY)
{
	HRESULT hr = S_OK;
	
	IHTMLElement		*pElement		= NULL;
	IHTMLElement 		*pOffsetParent	= NULL;
	long				lWidth, lHeight;
	
	hr = GetAnimatedElement( &pElement );
	CheckHR( hr, L"GetPixelsPerPercentValue failed", done );
	
	hr = pElement->get_offsetParent( &pOffsetParent );
	CheckHR( hr, L"GetPixelsPerPercentValue failed", done );

	hr = pOffsetParent->get_offsetWidth( &lWidth );
	CheckHR( hr, L"GetPixelsPerPercentValue failed", done );
	
	dPixelPerPercentX = lWidth/100.0;
	
	hr = pOffsetParent->get_offsetHeight( &lHeight );
	CheckHR( hr, L"GetPixelsPerPercentValue failed", done );
	
	dPixelPerPercentY = lHeight/100.0;
	
  done:
	ReleaseInterface(pElement);
	ReleaseInterface(pOffsetParent);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::ConvertTransformCenterUnits(IDAVector2 ** ppConvertedCenter)
{
	HRESULT	hr	= S_OK;

	// Get top, left, width, height tracks
	CBvrTrack 	*topTrack, *leftTrack, *widthTrack, *heightTrack;
	BSTR		bstrTopUnits, bstrLeftUnits, bstrWidthUnits, bstrHeightUnits;
	
	hr = GetTrack(L"style.top", e_Number, &topTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}
	hr = GetTrack(L"style.left", e_Number, &leftTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	hr = GetTrack(L"style.width", e_Number, &widthTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}
	hr = GetTrack(L"style.height", e_Number, &heightTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}
	
	bstrLeftUnits	= ((CNumberBvrTrack *) leftTrack)->GetUnits();
	bstrTopUnits	= ((CNumberBvrTrack *) topTrack)->GetUnits();
	bstrWidthUnits	= ((CNumberBvrTrack *) widthTrack)->GetUnits();
	bstrHeightUnits	= ((CNumberBvrTrack *) heightTrack)->GetUnits();

	double dPercentX = 1.0;
	double dPercentY = 1.0;
	IDANumber * pnumCenterX = NULL;
	IDANumber * pnumCenterY = NULL;
	IDANumber * pnumConvertX = NULL;
	IDANumber * pnumConvertY = NULL;
	IDANumber * pnumX = NULL;
	IDANumber * pnumY = NULL;
	
	// If any units are in percent, we get the pixel per percent value
	if ( ( bstrLeftUnits != NULL && wcsicmp(bstrLeftUnits, L"%") == 0 ) ||
		 ( bstrTopUnits != NULL && wcsicmp(bstrTopUnits, L"%") == 0 ) ||		 
		 ( bstrWidthUnits != NULL && wcsicmp(bstrWidthUnits, L"%") == 0 ) ||		 
		 ( bstrHeightUnits != NULL && wcsicmp(bstrHeightUnits, L"%") == 0 ) )
	{
		hr = GetPixelsPerPercentValue( dPercentX, dPercentY );
		CheckHR(hr, L"Transform center conversion failed", done);
	}
		 
		
	// Get center X & Y, which are in width & height coords

	hr = m_pTransformCenter->get_X(&pnumCenterX);
	CheckHR(hr, L"Transform center conversion failed", done);
		
	hr = m_pTransformCenter->get_Y(&pnumCenterY);
	CheckHR(hr, L"Transform center conversion failed", done);

	hr = GetUnitConversionBvr(bstrWidthUnits, bstrLeftUnits, &pnumConvertX, dPercentX);
	CheckHR(hr, L"Transform center conversion failed", done);
	
	hr = GetUnitConversionBvr(bstrHeightUnits, bstrTopUnits, &pnumConvertY, dPercentY);
	CheckHR(hr, L"Transform center conversion failed", done);

	hr = GetDAStatics()->Mul(pnumCenterX, pnumConvertX, &pnumX);
	CheckHR(hr, L"Transform center conversion failed", done);

	hr = GetDAStatics()->Mul(pnumCenterY, pnumConvertY, &pnumY);
	CheckHR(hr, L"Transform center conversion failed", done);

	hr = GetDAStatics()->Vector2Anim(pnumX, pnumY, ppConvertedCenter);
	CheckHR(hr, L"Transform center conversion failed", done);
	
  done:
	ReleaseInterface(pnumCenterX);
	ReleaseInterface(pnumCenterY);
	ReleaseInterface(pnumConvertX);
	ReleaseInterface(pnumConvertY);
	ReleaseInterface(pnumX);
	ReleaseInterface(pnumY);
	
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::TransformTrackIsDirty( DWORD *pdwState )
{
	HRESULT hr = S_FALSE;

	if( pdwState == NULL )
		return E_INVALIDARG;

	(*pdwState) = 0;
	
	
	CBvrTrack *ptrack = NULL;
	hr = FindTrack( L"translation", e_Translation, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= TRANSLATION_DIRTY;
		hr = S_OK; //true
	}

	hr = FindTrack( L"scale", e_Scale, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= SCALE_DIRTY;
		hr = S_OK; //true
	}

	hr = FindTrack( L"style.rotation", e_Number, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= ROTATION_DIRTY;
		hr = S_OK; //true
	}

	hr = FindTrack( L"style.top", e_Number, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= TOP_DIRTY;
		hr = S_OK; //true
	}

	hr = FindTrack( L"style.left", e_Number, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= LEFT_DIRTY;
		hr = S_OK; //true
	}

	hr = FindTrack( L"style.width", e_Number, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= WIDTH_DIRTY;
		hr = S_OK; //true
	}
	
	hr = FindTrack( L"style.height", e_Number, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= HEIGHT_DIRTY;
		hr = S_OK; //true
	}

end:
	return hr;
	
}

//*****************************************************************************

bool
CActorBvr::IsAnyTrackDirty()
{
	bool fTrackDirty = false ;
	
	for (CBvrTrack *ptrackCurrent = m_ptrackHead;
         ptrackCurrent != NULL;
         ptrackCurrent = ptrackCurrent->m_pNext)
    {
    	if( ptrackCurrent->IsDirty() )
    	{
    		fTrackDirty = true;
    		break;
    	}
    }

    return fTrackDirty;
}

//*****************************************************************************


HRESULT
CActorBvr::ImageTrackIsDirty()
{
	HRESULT hr = S_FALSE;

	CBvrTrack *ptrack = NULL;
	
	hr = FindTrack( L"image", e_Image, &ptrack );
	//ignore the hr. If it is E_FAIL then the track was not found
	//  which means it can't be dirty.
	if( ptrack != NULL && ptrack->IsDirty() )
		return S_OK;
		
	return S_FALSE;
}

//*****************************************************************************


HRESULT
CActorBvr::ApplyTransformTracks()
{
	HRESULT hr = S_OK;

	DiscardBvrCache();

	// Get top, left, width, height tracks
	CBvrTrack *topTrack, *leftTrack, *widthTrack, *heightTrack;
	bool	fLeftWasAnimated = false;
	bool	fTopWasAnimated = false;
	bool	fWidthWasAnimated = false;
	bool	fHeightWasAnimated = false;

	hr = GetTrack(L"style.top", e_Number, &topTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	m_ptrackTop = topTrack;

	fTopWasAnimated = m_ptrackTop->IsAnimated();

	//force the track to be rebuilt
	hr = topTrack->ForceRebuild();
	if( FAILED(hr) )
	{
		DPF_ERR("failed to force the track to rebuild" );
		return hr;
	}
	
	hr = GetTrack(L"style.left", e_Number, &leftTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	m_ptrackLeft = leftTrack;

	fLeftWasAnimated = m_ptrackLeft->IsAnimated();

	//force the track to be rebuilt
	hr = leftTrack->ForceRebuild();
	if( FAILED(hr) )
	{
		DPF_ERR("failed to force the track to rebuild" );
		return hr;
	}


	hr = GetTrack(L"style.width", e_Number, &widthTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	fWidthWasAnimated = widthTrack->IsAnimated();

	//force the track to be rebuilt
	hr = widthTrack->ForceRebuild();
	if( FAILED(hr) )
	{
		DPF_ERR("failed to force the track to rebuild" );
		return hr;
	}

	hr = GetTrack(L"style.height", e_Number, &heightTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	fHeightWasAnimated = heightTrack->IsAnimated();
	//force the track to be rebuilt
	hr = heightTrack->ForceRebuild();
	if( FAILED(hr) )
	{
		DPF_ERR("failed to force the track to rebuild" );
		return hr;
	}

	// Build the transform behaviors.
	// NOTE!!: These might be set to NULL if there are no attributes set and
	// no tracks.  Program accordingly.
    hr = GetTransformFinalBvr(L"scale", e_Scale, &m_pScale);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get the scale track final bvr");
        return hr;
    }

    hr = GetTransformFinalBvr(L"translation", e_Translation, &m_pTranslate);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get the translate track final bvr");
        DiscardBvrCache();
        return hr;
    }

	// Note: rotation is special.  It is done through the style.rotation track.
	hr = GetRotationFinalBvr(&m_pRotate);
	if (FAILED(hr))
	{
		DiscardBvrCache();
		return hr;
	}


	// Build the original (composed) leftTop and widthHeight

	// Get composed top and left
	IDANumber *compTop;
	IDANumber *compLeft;
	IDABehavior *temp;
	
	hr = topTrack->GetComposedBvr(&temp);
	if (FAILED(hr))
		return hr;
		
	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &compTop));
	ReleaseInterface(temp);
	if (FAILED(hr))
		return hr;
		
	hr = leftTrack->GetComposedBvr(&temp);
	if (FAILED(hr))
	{
		ReleaseInterface(compTop);
		return hr;
	}
	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &compLeft));
	ReleaseInterface(temp);
	if (FAILED(hr))
	{
		ReleaseInterface(compTop);
		return E_FAIL;
	}

	// Put them into a Point2
	hr = GetDAStatics()->Point2Anim(compLeft, compTop, &m_pOrigLeftTop);
	ReleaseInterface(compTop);
	ReleaseInterface(compLeft);
	if (FAILED(hr))
		return hr;
	
	// Get composed width and height
	IDANumber *compWidth;
	IDANumber *compHeight;

	hr = widthTrack->GetComposedBvr(&temp);
	if (FAILED(hr))
		return hr;

	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &compWidth));
	ReleaseInterface(temp);
	if (FAILED(hr))
		return hr;

	hr = heightTrack->GetComposedBvr(&temp);
	if (FAILED(hr))
	{
		ReleaseInterface(compWidth);
		return hr;
	}
	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &compHeight));
	ReleaseInterface(temp);
	if (FAILED(hr))
	{
		ReleaseInterface(compWidth);
		return E_FAIL;
	}

	// Put them into a Vector2
	hr = GetDAStatics()->Vector2Anim(compWidth, compHeight, &m_pOrigWidthHeight);
	ReleaseInterface(compWidth);
	ReleaseInterface(compHeight);
	if (FAILED(hr))
		return hr;

	if( m_pPixelWidth == NULL || m_pPixelHeight == NULL )
	{
		// Create the pixelWidth and pixelHeight behaviors
		hr = InitPixelWidthHeight();
		if (FAILED(hr))
			return hr;

		IDA2Statics *pStatics2 = NULL;
		hr = GetDAStatics()->QueryInterface(IID_TO_PPV(IDA2Statics, &pStatics2));
		if (FAILED(hr))
			return hr;

		if( m_pPixelWidth == NULL )
		{
			hr = pStatics2->ModifiableNumber(m_pixelWidth, &m_pPixelWidth);
			if (FAILED(hr))
			{
				ReleaseInterface(pStatics2);
				return hr;
			}
		}

		if( m_pPixelHeight == NULL )
		{
			hr = pStatics2->ModifiableNumber(m_pixelHeight, &m_pPixelHeight);
		
			if (FAILED(hr))
			{
				ReleaseInterface( pStatics2 );
				return hr;
			}
		}
		ReleaseInterface(pStatics2);
	}

	
	
	// Compute origBoundsMin and Max
	IDAVector2 *pWidthHeight = NULL;
	hr = GetDAStatics()->Vector2Anim(m_pPixelWidth, m_pPixelHeight, &pWidthHeight);
	if (FAILED(hr))
		return hr;

	IDAVector2 *pHalfWidthHeight = NULL;
	hr = pWidthHeight->Mul(.5, &pHalfWidthHeight);
	ReleaseInterface(pWidthHeight);
	if (FAILED(hr))
		return hr;

	IDANumber *pPixel = NULL;
	hr = GetDAStatics()->get_Pixel(&pPixel);
	if (FAILED(hr))
	{
		ReleaseInterface(pHalfWidthHeight);
		return hr;
	}

	IDAVector2 *pTemp = NULL;
	hr = pHalfWidthHeight->MulAnim(pPixel, &pTemp);
	ReleaseInterface(pHalfWidthHeight);
	ReleaseInterface(pPixel);
	if (FAILED(hr))
		return hr;
	pHalfWidthHeight = pTemp;
	pTemp = NULL;

	// Scale this if necessary
	if (m_pScale != NULL && CheckBitSet( m_dwCurrentState, PIXEL_SCALE_ON ) )
	{
		hr = pHalfWidthHeight->Transform(m_pScale, &pTemp);
		ReleaseInterface(pHalfWidthHeight);
		if (FAILED(hr))
			return hr;
		pHalfWidthHeight = pTemp;
		pTemp = NULL;
	}

	IDAPoint2 *pOrigin = NULL;
	hr = GetDAStatics()->get_Origin2(&pOrigin);
	if (FAILED(hr))
	{
		ReleaseInterface(pHalfWidthHeight);
		return hr;
	}

	hr = GetDAStatics()->SubPoint2Vector(pOrigin, pHalfWidthHeight, &m_pBoundsMin);
	if (FAILED(hr))
	{
		ReleaseInterface(pOrigin);
		ReleaseInterface(pHalfWidthHeight);
		return hr;
	}

	hr = GetDAStatics()->AddPoint2Vector(pOrigin, pHalfWidthHeight, &m_pBoundsMax);
	ReleaseInterface(pOrigin);
	ReleaseInterface(pHalfWidthHeight);
	if (FAILED(hr))
		return hr;

	// See if we need to do some scaling on width and height
	if (CheckBitNotSet( m_dwCurrentState, PIXEL_SCALE_ON ) && m_pScale != NULL)
	{
		// Transform widthHeight by scale
		IDAVector2 *vecScaled = NULL;
		hr = m_pOrigWidthHeight->Transform(m_pScale, &vecScaled);
		if (FAILED(hr))
			return hr;

		// Get scaled width into finalWidth
		IDANumber *finalWidth = NULL;
		hr = vecScaled->get_X(&finalWidth);
		if (FAILED(hr))
		{
			ReleaseInterface(vecScaled);
			return hr;
		}

		// Get scaled height into finalHeight
		IDANumber *finalHeight = NULL;
		hr = vecScaled->get_Y(&finalHeight);
		ReleaseInterface(vecScaled);
		if (FAILED(hr))
		{
			ReleaseInterface(finalWidth);
			return hr;
		}

		// Set finalWidth on the width track
		hr = widthTrack->SetFinalBvr(finalWidth);
		ReleaseInterface(finalWidth);
		if (FAILED(hr))
		{
			ReleaseInterface(finalHeight);
			DPF_ERR("Failed to set final width");
			return hr;
		}

		// Set finalHeight on the height track
		hr = heightTrack->SetFinalBvr(finalHeight);
		ReleaseInterface(finalHeight);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to set final height");
			return hr;
		}

		//the width and the height are now modified by the scale track
		// or its on bvr with the on bvrs of width and height
		CBvrTrack* pScaleTrack;
		hr = FindTrack( L"scale", e_Scale, &pScaleTrack );
		if( FAILED( hr ) )
		{
			DPF_ERR("Failed to get the scale track" );
			return hr;
		}

		IDABoolean *pdaboolScaleOn;
		if( pScaleTrack != NULL )
		{
			hr = pScaleTrack->GetTrackOn( &pdaboolScaleOn );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to get the on bvr from the scale track" );
				return hr;
			}
		}
		else //there is no scale track but there is a static scale
		{
			hr = GetDAStatics()->get_DATrue( &pdaboolScaleOn );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to get DATrue from DAStatics" );
				return hr;
			}
		}

		hr = widthTrack->OrWithOnBvr( pdaboolScaleOn );
		if( FAILED(hr))
		{
			ReleaseInterface( pdaboolScaleOn );
			DPF_ERR("Failed to or the on bvr for scale with the on bvr for width");
			return hr;
		}

		hr = heightTrack->OrWithOnBvr( pdaboolScaleOn );
		if( FAILED(hr))
		{
			ReleaseInterface( pdaboolScaleOn );
			DPF_ERR("Failed to or the on bvr for scale with the on bvr for height");
			return hr;
		}

		ReleaseInterface( pdaboolScaleOn );
	}
	else
	{
/*
		// Final widthHeight equals original widthHeight
		m_pFinalWidthHeight = m_pOrigWidthHeight;
		m_pFinalWidthHeight->AddRef();
*/
		// TODO (markhal): Should set this onto the track, and set a flag that it
		// shouldn't get applied

		if( fWidthWasAnimated )
			widthTrack->ApplyStatic();
		if( fHeightWasAnimated )
			heightTrack->ApplyStatic();
	}

	// Compute top and left if necessary
	if (m_pTranslate != NULL || (CheckBitNotSet( m_dwCurrentState, PIXEL_SCALE_ON) && m_pScale != NULL))
	{
		// First figure out a point that represents the animated top and left.
		// If there is a translation transform this is found by mapping (0, 0)
		// through the transform, since in creating that transform we already
		// figured all of this out.  If there is no translation we just
		// use m_pOrigLeftTop
		IDAPoint2 *pointTranslated = NULL;
		if (m_pTranslate != NULL)
		{
			IDAPoint2 *zero = NULL;
			hr = GetDAStatics()->get_Origin2(&zero);
			if (FAILED(hr))
				return hr;

			hr = zero->Transform(m_pTranslate, &pointTranslated);
			ReleaseInterface(zero);
			if (FAILED(hr))
				return hr;

			//at this point we know that a translation has changed the top
			// left, so or the onbvr for the translation track with the onbvrs
			// for top and left
			CBvrTrack *pTranslationTrack;
			hr = GetTrack(L"translation", e_Translation, &pTranslationTrack );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to get the translation track" );
				return hr;
			}

			IDABoolean *pdaboolTranslationOn;
			hr = pTranslationTrack->GetTrackOn( &pdaboolTranslationOn );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to get the on bvr for the translation track");
				return hr;
			}

			hr = leftTrack->OrWithOnBvr( pdaboolTranslationOn );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pdaboolTranslationOn );
				DPF_ERR("Failed to or the on bvr for translation with the on bvr for left" );
				return hr;
			}

			hr = topTrack->OrWithOnBvr( pdaboolTranslationOn );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pdaboolTranslationOn );
				DPF_ERR("Failed to or the on bvr for translation with the on bvr for top" );
				return hr;
			}

			ReleaseInterface( pdaboolTranslationOn );
		}
		else
		{
			pointTranslated = m_pOrigLeftTop;
			pointTranslated->AddRef();
		}

		// Adjust for scaling of transformCenter
		// NOTE: I am going to implement a version that keeps the original top/left
		// on the motion path.  I am not convinced that we want the transformCenter
		// to suddenly jump to the motion path (markhal)
		if (CheckBitNotSet( m_dwCurrentState, PIXEL_SCALE_ON) && m_pScale != NULL)
		{
			// What we want to do is add transformCenter - Scale * transformCenter to pointTranslated

			// Ensure transformCenter is computed
			hr = BuildTransformCenter();
			if( FAILED(hr) )
			{
				ReleaseInterface(pointTranslated);
				DPF_ERR("Could not build the transform center");
				return SetErrorInfo(hr);
			}

			IDAVector2 * pConvertedCenter = NULL;
			hr = ConvertTransformCenterUnits(&pConvertedCenter);
			// If we couldn't convert the transform center, just use the unconverted center
			if (FAILED(hr))
			{
				DPF_ERR("Could not convert the transform center");
				pConvertedCenter = m_pTransformCenter;
				pConvertedCenter->AddRef();
			}

			
			// Add it to pointTranslated
			IDAPoint2 *temp = NULL;
			hr = GetDAStatics()->AddPoint2Vector(pointTranslated, pConvertedCenter, &temp);
			ReleaseInterface( pointTranslated );
			if (FAILED(hr))
			{
				ReleaseInterface(pConvertedCenter);
				return hr;
			}
			pointTranslated = temp;
			temp = NULL;

			// Scale center
			IDAVector2 *scaledCenter = NULL;
			hr = pConvertedCenter->Transform(m_pScale, &scaledCenter);
			ReleaseInterface(pConvertedCenter);
			if (FAILED(hr))
			{
				ReleaseInterface(pointTranslated);
				return hr;
			}

			// Subtract it
			hr = GetDAStatics()->SubPoint2Vector(pointTranslated, scaledCenter, &temp);
			ReleaseInterface(scaledCenter);
			ReleaseInterface( pointTranslated );
			if (FAILED(hr))
			{
				return hr;
			}
			pointTranslated = temp;
			temp = NULL;

			//top and left are now modified by the scale transform so or the onbvr for
			// the scale track with the on bvr for the top and left tracks.
			
			CBvrTrack* pScaleTrack;
			hr = FindTrack( L"scale", e_Scale, &pScaleTrack );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to get the scale track" );
				return hr;
			}

			IDABoolean *pdaboolScaleOn;
			if( pScaleTrack != NULL )
			{
				hr = pScaleTrack->GetTrackOn( &pdaboolScaleOn );
				if( FAILED( hr ) )
				{
					DPF_ERR("Failed to get the on bvr from the scale track" );
					return hr;
				}
			}
			else //there is no scale track, but there is a static scale
			{
				//there is always a scale active( the static one )
				hr = GetDAStatics()->get_DATrue( &pdaboolScaleOn );
				if( FAILED( hr ) )
				{
					DPF_ERR("Failed to get DATrue from DAStatics");
					return hr;
				}
			}

			hr = leftTrack->OrWithOnBvr( pdaboolScaleOn );
			if( FAILED(hr))
			{
				ReleaseInterface( pdaboolScaleOn );
				DPF_ERR("Failed to or the on bvr for scale with the on bvr for width");
				return hr;
			}

			hr = topTrack->OrWithOnBvr( pdaboolScaleOn );
			if( FAILED(hr))
			{
				ReleaseInterface( pdaboolScaleOn );
				DPF_ERR("Failed to or the on bvr for scale with the on bvr for height");
				return hr;
			}

			ReleaseInterface( pdaboolScaleOn );
		}
		
		// Get translated top into finalTop
		IDANumber *finalTop = NULL;
		hr = pointTranslated->get_Y(&finalTop);
		if (FAILED(hr))
		{
			ReleaseInterface(pointTranslated);
			return hr;
		}

		// Get translated left into finalLeft
		IDANumber *finalLeft = NULL;
		hr = pointTranslated->get_X(&finalLeft);
		ReleaseInterface(pointTranslated);
		if (FAILED(hr))
		{
			ReleaseInterface(finalTop);
			return hr;
		}
/*
		// Put into m_pFinalLeftTop
		hr = GetDAStatics()->Point2Anim(finalLeft, finalTop, &m_pFinalLeftTop);
		if (FAILED(hr))
		{
			ReleaseInterface(finalLeft);
			ReleaseInterface(finalTop);
			return hr;
		}
*/
		// Set finalTop onto top track
		hr = topTrack->SetFinalBvr(finalTop);
		ReleaseInterface(finalTop);
		if (FAILED(hr))
		{
			ReleaseInterface(finalLeft);
			DPF_ERR("Failed to set final top");
			return hr;
		}

		// Set finalLeft onto left track
		hr = leftTrack->SetFinalBvr(finalLeft);
		ReleaseInterface(finalLeft);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to set final left");
			return hr;
		}
	}
	else
	{
/*
		// final leftTop equals orig leftTop
		m_pFinalLeftTop = m_pOrigLeftTop;
		m_pFinalLeftTop->AddRef();
*/
		// TODO (markhal): Should set this onto the track, and set a flag that it
		// shouldn't get applied

		if( fLeftWasAnimated )
			leftTrack->ApplyStatic();

		if( fTopWasAnimated )
			topTrack->ApplyStatic();
	}
/*
	// Compute final center
	hr = m_pFinalWidthHeight->Mul(.5, &pHalfWidthHeight);
	if (FAILED(hr))
		return hr;

	hr = GetDAStatics()->AddPoint2Vector(m_pFinalLeftTop, pHalfWidthHeight, &m_pFinalCenter);
	ReleaseInterface(pHalfWidthHeight);
	if (FAILED(hr))
		return hr;
*/
	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::ApplyImageTracks()
{
	HRESULT hr = S_OK;

	// Locate the image track
	CBvrTrack *pTrack = NULL;
	hr = FindTrack(L"image", e_Image, &pTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	ReleaseImageInfo();

	// We'll set this if we require a filter.
	// We need a filter if:
	// there are any effect filters applied to the image
	// and/or there is a rotation we are handling (i.e. not acting on VML)
	// and/or there is a scale we are handling (pixelScale set and not VML)
	bool requiresFilter = false;

	// We'll set this if we require a floating element
	// We need a floating element if:
	// There is a rotation we are handling
	// and/or there is a scale we are handling
	// and/or there is an expandoImage track
	bool requiresFloat = false;

	if( pTrack != NULL && pTrack->IsAnimated() )
	{

		if (pTrack != NULL && pTrack->ContainsFilter())
			requiresFilter = true;

		// If there is any rotation, m_pRotate will be set
		// TODO: Ignore this if we are on a VML shape
		if (m_pRotate != NULL)
		{
			requiresFilter = true;
			requiresFloat = true;
		}

		// If there is any scale, m_pScale will be set, and if we should
		// use it here, m_bPixelScale will be true
		if (m_pScale != NULL && CheckBitSet(m_dwCurrentState, PIXEL_SCALE_ON) )
		{
			requiresFilter = true;
			requiresFloat = true;
		}

		// If we are rendering images over the top of a VML shape then we
		// need to use a filter
		bool isVML;
		hr = IsAnimatedElementVML(&isVML);
		if (FAILED(hr))
			return E_FAIL;

		if (pTrack != NULL && pTrack->IsAnimated() && isVML)
		{
			requiresFilter = true;
		}

		// If we are rendering and have an animates property, then we need
		// to use a filter
		hr = CUtils::InsurePropertyVariantAsBSTR(&m_varAnimates);
		if ( pTrack != NULL && pTrack->IsAnimated() && SUCCEEDED(hr) && wcslen(V_BSTR(&m_varAnimates)) != 0)
		{
			requiresFilter = true;
		}

		if (pTrack == NULL && !requiresFilter && !requiresFloat)
		{
			// Nothing to do
			return S_OK;
		}

		//store away the final width and height in pixels so that we
		// can use them to prepare images for dxtransforms
		IDAPoint2 *pFinalPixelDimension = NULL;
		hr = GetDAStatics()->Point2Anim( m_pPixelWidth, m_pPixelHeight, &pFinalPixelDimension );
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Compute the final image behavior
		IDABehavior *pFinal = NULL;
		if (pTrack == NULL || requiresFilter)
		{
			// We need to pass the element image (from a filter) in as the static
			IDAImage *pElementImage = NULL;
			hr = GetElementImage(&pElementImage);
			if (FAILED(hr))
			{
				ReleaseInterface( pFinalPixelDimension );
				DPF_ERR("Failed to get element image");
				return hr;
			}

			// Apply pixelScale, if any.
			if (m_pScale != NULL && CheckBitSet( m_dwCurrentState, PIXEL_SCALE_ON) )
			{
				IDAImage *pImageScaled = NULL;
				hr = pElementImage->Transform(m_pScale, &pImageScaled);
				ReleaseInterface(pElementImage);
				if (FAILED(hr))
				{
					ReleaseInterface( pFinalPixelDimension );
					DPF_ERR("Failed to scale image");
					return hr;
				}

				//scale the final pixelWidth/Height by the pixel scale
				IDAPoint2 *pScaledDimension;
				hr = pFinalPixelDimension->Transform( m_pScale, &pScaledDimension );
				ReleaseInterface( pFinalPixelDimension );
				if( FAILED( hr ) )
				{
					DPF_ERR("Failed to scale the final element dimension" );
					return hr;
				}
				pFinalPixelDimension = pScaledDimension;
				pScaledDimension = NULL;


				pElementImage = pImageScaled;
			}

			if (pTrack != NULL)
			{


				if( pTrack->ContainsFilter() )
				{
					//we have to prepare the image for a filter if there is one in the image tracks
            
					IDAImage *pDXTReadyImage;
					hr = PrepareImageForDXTransform( pElementImage, &pDXTReadyImage );
					ReleaseInterface( pElementImage );
					if( FAILED( hr ) )
					{
						ReleaseInterface( pFinalPixelDimension );
						DPF_ERR("failed to prepare the image for a DXTransform");
						return hr;
					}
					pElementImage = pDXTReadyImage;
					pDXTReadyImage = NULL;
				}

            
				hr = pTrack->GetFinalBvr(pElementImage, &pFinal);
				ReleaseInterface(pElementImage);
			}
			else
			{
				pFinal = pElementImage;
				pElementImage = NULL;
			}
		}
		else //the track is != NULL && we do not require a filter
		{
			// Get image with no background
			hr = pTrack->GetFinalBvr(&pFinal);
		}
		if (FAILED(hr))
		{
			ReleaseInterface( pFinalPixelDimension );
			DPF_ERR("Could not get a final behavior from the image track");
			return hr;
		}
    
		// Convert the behavior to an image
		IDAImage *pImageFinal = NULL;
		hr = pFinal->QueryInterface(IID_TO_PPV(IDAImage, &pImageFinal));
		ReleaseInterface(pFinal);
		if (FAILED(hr))
		{
			ReleaseInterface( pFinalPixelDimension );
			DPF_ERR("Could not QI for a DA image from the final behavior");
			return hr;
		}

		bool highQuality = false;

		// Set image quality if scaling.
		if (m_pScale != NULL)
		{
			// Require highQuality
			highQuality = true;
		}

		// Crop it
		IDAImage *pCroppedImage = NULL;
		hr = pImageFinal->Crop(m_pBoundsMin, m_pBoundsMax, &pCroppedImage);
		ReleaseInterface(pImageFinal);
		if (FAILED(hr))
		{
			ReleaseInterface( pFinalPixelDimension );
			return hr;
		}
		

		pImageFinal = pCroppedImage;
		pCroppedImage = NULL;
    

		// Apply any rotation
		if (m_pRotate != NULL)
		{
			//we have to clip when rotating to make sure that 
			//vectors do not render outside the crop.

			IDAImage *pClippedImage = NULL;
			hr = ApplyClipToImage( pImageFinal, m_pBoundsMin, m_pBoundsMax, &pClippedImage );
			ReleaseInterface( pImageFinal );
			if (FAILED(hr))
			{
				ReleaseInterface( pFinalPixelDimension );
				DPF_ERR("Failed to rotate image");
				return hr;
			}

			IDAImage *pImageRotated = NULL;
			hr = pClippedImage->Transform(m_pRotate, &pImageRotated);
			ReleaseInterface(pClippedImage);
			if (FAILED(hr))
			{
				ReleaseInterface( pFinalPixelDimension );
				DPF_ERR("Failed to rotate image");
				return hr;
			}

			pImageFinal = pImageRotated;
			pImageRotated = NULL;

			highQuality = true;
		}
	/*
		if (highQuality)
		{
			// Set the quality flags
			IDA2Image *pImageFinal2 = NULL;
			hr = pImageFinal->QueryInterface(IID_TO_PPV(IDA2Image, &pImageFinal2));
			ReleaseInterface(pImageFinal);
			if (FAILED(hr))
				return hr;

			// Go wild, turn everything on.
			// TODO (markhal): Figure out what should be on
			hr = pImageFinal2->ImageQuality(    DAQUAL_AA_TEXT_ON |
												DAQUAL_AA_LINES_ON |
												DAQUAL_AA_SOLIDS_ON |
												DAQUAL_AA_CLIP_ON |
												DAQUAL_MSHTML_COLORS_ON |
												DAQUAL_QUALITY_TRANSFORMS_ON,
												&pImageFinal);
			ReleaseInterface(pImageFinal2);
			if (FAILED(hr))
				return hr;
		}
	*/

		if (requiresFilter && requiresFloat)
		{
			// Want to render on top of floating element using filtered bits from
			// original element

			hr = ApplyImageBvrToFloatElement(pImageFinal);
			ReleaseInterface(pImageFinal);
			if (FAILED(hr))
			{
				ReleaseInterface( pFinalPixelDimension );
				DPF_ERR("Failed to apply image to element");
				return hr;
			}

			if (m_pScale != NULL && CheckBitSet( m_dwCurrentState, PIXEL_SCALE_ON ) )
			{
				IDANumber *pFinalPixelWidth = NULL;
				IDANumber *pFinalPixelHeight = NULL;
				hr = pFinalPixelDimension->get_X( &pFinalPixelWidth );
				if( FAILED( hr ) )
				{
					ReleaseInterface( pFinalPixelDimension );
					DPF_ERR("Failed to get_x from the final pixel dimension" );
					return hr;
				}

				hr = pFinalPixelDimension->get_Y( &pFinalPixelHeight );
				ReleaseInterface( pFinalPixelDimension );
				if( FAILED( hr ) )
				{
					ReleaseInterface( pFinalPixelWidth );
					DPF_ERR("Failed to get_x from the final pixel dimension" );
					return hr;
				}

				hr = SetFinalElementDimension( pFinalPixelWidth, pFinalPixelHeight, true );
				ReleaseInterface( pFinalPixelWidth );
				ReleaseInterface( pFinalPixelHeight );
				if( FAILED(hr ) )
				{
					DPF_ERR("Failed to set the finalElement dimension from the float" );
					return hr;
				}
			}
			else
			{	
				ReleaseInterface( pFinalPixelDimension);

				hr = SetFinalElementDimension( m_pPixelWidth, m_pPixelHeight, false );
				if( FAILED( hr ) )
				{
					DPF_ERR("Failed to set the final element dimension from the original element" );
				}
			}
		}
		else if (requiresFilter)
		{
			ReleaseInterface( pFinalPixelDimension );

			// Want to render on top of original element using a filter
			// Attach to TIME element but disable rendering
			hr = AddImageToTIME(GetHTMLElement(), pImageFinal, false);
			ReleaseInterface(pImageFinal);
			if (FAILED(hr))
			{
				DPF_ERR("Failed to apply image to element");
				return hr;
			}

			// Set element on filter
			hr = SetElementOnFilter();
			if (FAILED(hr))
			{
				DPF_ERR("Failed to set element on filter");
				return hr;
			}

			hr = SetFinalElementDimension( m_pPixelWidth, m_pPixelHeight, false );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to set the final element dimension from the original element" );
			}
		}
		else if (requiresFloat)
		{
			ReleaseInterface( pFinalPixelDimension );
			// Want to render on top of float element but leave original element
			// rendering as normal with no filtering.
		}
		else
		{
			ReleaseInterface( pFinalPixelDimension );
			// Want to render on top of original element with no filtering required

			// Attach to TIME behavior and enable rendering
			hr = AddImageToTIME(GetHTMLElement(), pImageFinal, true);
			ReleaseInterface(pImageFinal);
			if (FAILED(hr))
			{
				DPF_ERR("Failed to apply image to element");
				return hr;
			}
			DASSERT( m_pdanumFinalImageWidth == NULL && m_pdanumFinalImageHeight == NULL );
		}

		ReleaseInterface( pFinalPixelDimension);
	}

	if( !requiresFilter && m_pElementFilter != NULL )
	{
		hr = RemoveElementFilter();
		if( FAILED( hr ) )
		{
			DPF_ERR("Failed to remove the element filter" );
			return hr;
		}

	}
	
    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::ApplyImageBvrToFloatElement(IDAImage *pbvrImage)
{
	if (m_pFloatManager == NULL)
		m_pFloatManager = new CFloatManager(this);

	if (m_pFloatManager == NULL)
		return E_FAIL;

	return m_pFloatManager->ApplyImageBvr(pbvrImage);
}

//*****************************************************************************

HRESULT
CActorBvr::SetElementOnFilter()
{
	IDispatch *pFilter;
	HRESULT hr = GetElementFilter(&pFilter);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to get filter");
		return hr;
	}

	hr = SetElementOnFilter(pFilter, GetHTMLElement());
	ReleaseInterface(pFilter);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to set element on filter");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::SetElementOnFilter(IDispatch *pFilter, IHTMLElement *pElement)
{
    HRESULT hr;
	DISPPARAMS		params;
	VARIANT 		varElement;
	VARIANT			varResult;
	
	VariantInit(&varElement);
	varElement.vt = VT_DISPATCH;
	varElement.pdispVal = pElement;   
	VariantInit(&varResult);

	params.rgvarg				= &varElement;
	params.rgdispidNamedArgs	= NULL;
	params.cArgs				= 1;
	params.cNamedArgs			= 0;
    hr = CallInvokeOnDispatch(pFilter,
                                 L"SetDAViewHandler", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);

	VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting time element");
		return SetErrorInfo(hr);
    }

	return S_OK;
}

//*****************************************************************************

HRESULT 
CActorBvr::GetAnimatedElementId(VARIANT *pvarId)
{
    HRESULT hr;

    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varAnimates);

    if ((SUCCEEDED(hr)) && (wcslen(m_varAnimates.bstrVal) > 0))
    {
        hr = VariantCopy(pvarId, &m_varAnimates);
    }
    else
    {
        // we need to get the id from the element to which we are attached
		IHTMLElement *pAnimatedElement = GetHTMLElement();
		if (pAnimatedElement == NULL )
		{
			DPF_ERR("Error obtaining animated element");
			return SetErrorInfo(hr);
		}

		hr = pAnimatedElement->getAttribute(L"id", 0, pvarId);

		if ( FAILED(hr) || pvarId->vt != VT_BSTR || pvarId->bstrVal == 0 || SysStringLen(pvarId->bstrVal) == 0)
		{
			// id is not defined on animated element yet, need to assign it a unique id
			IHTMLUniqueName *pUnique;

			hr = pAnimatedElement->QueryInterface(IID_IHTMLUniqueName, (void **)(&pUnique));

			if ( SUCCEEDED(hr) && pUnique != 0 )
			{
				BSTR uniqueID;
				hr = pUnique->get_uniqueID( &uniqueID );
				ReleaseInterface(pUnique);

				if (SUCCEEDED(hr))
				{
					hr = pAnimatedElement->put_id(uniqueID);

					if (SUCCEEDED(hr))
					{
						VariantClear(pvarId);
						V_VT(pvarId) = VT_BSTR;
						V_BSTR(pvarId) = uniqueID;
					}
					else
						SysFreeString(uniqueID);
				}
			}
		}
		
    }

    if (FAILED(hr))
    {
        DPF_ERR("Error getting Id of element to animate in GetAnimatedElementId");
        return SetErrorInfo(hr);
    }

    return S_OK;
} // GetAnimatedElementId

//*****************************************************************************

// TODO (markhal): This should probably cache the animated element
HRESULT
CActorBvr::GetAnimatedElement(IHTMLElement** ppElem)
{
	if( ppElem == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;

	//if animates is not set
	hr = CUtils::InsurePropertyVariantAsBSTR(&m_varAnimates);


    if ( FAILED(hr) || wcslen(V_BSTR(&m_varAnimates)) == 0)
	{
		//get the element to which we are attached.
		(*ppElem) = GetHTMLElement();
		(*ppElem)->AddRef();
		hr = S_OK;
	}
	else //else animates is set
	{
		//get the element referred to by animates by name
		IHTMLElement *pElement = GetHTMLElement();
		if( pElement != NULL )
		{
			IDispatch* pdispDocument;
			pElement->get_document( &pdispDocument );
			if( SUCCEEDED( hr ) )
			{
				IHTMLDocument2 *pDoc2;
				hr = pdispDocument->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDoc2));
				ReleaseInterface( pdispDocument );
				if( SUCCEEDED( hr ) )
				{
					IHTMLElementCollection *pcolElements;
					hr = pDoc2->get_all( &pcolElements );
					ReleaseInterface(pDoc2);
					if( SUCCEEDED( hr ) )
					{
						IDispatch* pdispElement;
						VARIANT index;
						VariantInit( &index );

						V_VT(&index) = VT_I4;
						V_I4(&index) = 0;

						hr = pcolElements->item( m_varAnimates, index, &pdispElement );
						ReleaseInterface( pcolElements );
						VariantClear(&index);
						if( SUCCEEDED( hr ) )
						{
							if (pdispElement == NULL)
							{
								// Couldn't find the element
								hr = E_FAIL;
							}
							else
							{
								hr = pdispElement->QueryInterface( IID_TO_PPV( IHTMLElement, ppElem ) );
								ReleaseInterface( pdispElement );
								if( FAILED( hr ) )
								{
									DPF_ERR("Failed to get IHTMLElement from dispatch returned by all.item()");
								}
							}
						}
						else //failed to get element pointed to by animates from the all collection
						{
							DPF_ERR("failed to get element pointed to by animates from the all collection");
						}

					}
					else //failed to get the all collection from IHTMLDocument2
					{
						DPF_ERR("failed to get the all collection from IHTMLDocument2");
					}
				}
				else //failed to get IHTMLDocument2 from the dispatch for the document
				{
					DPF_ERR("failed to get IHTMLDocument2 from the dispatch for the document");
				}
			}
			else//failed to get the document from the actor element
			{
				DPF_ERR("failed to get the document from the actor element");
			}
		}
		else//failed to get the html element for the actor
		{
			DPF_ERR("failed to get the html element for the actor");
		}
	}
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetRuntimeStyle(IHTMLStyle **ppStyle)
{
	HRESULT hr = S_OK;

	DASSERT(ppStyle != NULL);
	*ppStyle = NULL;

	if (m_pRuntimeStyle == NULL)
	{
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		IHTMLElement2 *pElement2 = NULL;
		hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;

		hr = pElement2->get_runtimeStyle(&m_pRuntimeStyle);
		ReleaseInterface(pElement2);
		if (FAILED(hr))
			return hr;
	}

	*ppStyle = m_pRuntimeStyle;
	m_pRuntimeStyle->AddRef();

	return S_OK;
}

//*****************************************************************************


HRESULT
CActorBvr::GetStyle(IHTMLStyle **ppStyle)
{
	HRESULT hr = S_OK;

	DASSERT(ppStyle != NULL);
	*ppStyle = NULL;

	if (m_pStyle == NULL)
	{
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		hr = pElement->get_style(&m_pStyle);
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;
	}

	*ppStyle = m_pStyle;
	m_pStyle->AddRef();

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::AddImageInfo( IDA2Image *pdaimg2Cropped, IDABehavior* pdabvrSwitchable )
{
	if( pdaimg2Cropped == NULL || pdabvrSwitchable == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	CImageInfo *pOldHead = m_pImageInfoListHead;

	IDA2Behavior *pdabvr2Switchable = NULL;
	hr = pdabvrSwitchable->QueryInterface( IID_TO_PPV( IDA2Behavior, &pdabvr2Switchable ) );
	CheckHR( hr, "Failed to get IDA2Behavior from switchable passed to AddImageInfo", cleanup );

	m_pImageInfoListHead = new CImageInfo( pdaimg2Cropped, pdabvr2Switchable );
	ReleaseInterface( pdabvr2Switchable );
	
	if( m_pImageInfoListHead == NULL )
	{
		m_pImageInfoListHead = pOldHead;
		return E_OUTOFMEMORY;
	}

	m_pImageInfoListHead->SetNext( pOldHead );

cleanup:

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::SetRenderResolution( double dX, double dY )
{
	HRESULT hr = S_OK;

	IDAImage *pdaimgNew = NULL;

	CImageInfo *pCurInfo = m_pImageInfoListHead;
	while( pCurInfo != NULL )
	{
		hr =  pCurInfo->GetCroppedNoRef()->RenderResolution( dX, dY, &pdaimgNew );
		CheckHR( hr, "Failed to set render resolution on an image", cleanup );
		
		hr = pCurInfo->GetSwitchableNoRef()->SwitchToEx( pdaimgNew, DAContinueTimeline );
		CheckHR( hr, "Failed to switch in the new image", cleanup );

		ReleaseInterface( pdaimgNew );

		pCurInfo = pCurInfo->GetNext();
	}
cleanup:
	ReleaseInterface( pdaimgNew );

	return hr;
}


//*****************************************************************************

void
CActorBvr::ReleaseImageInfo()
{
	CImageInfo *pCurInfo = m_pImageInfoListHead;
	CImageInfo *pNextInfo = NULL;
	while( pCurInfo != NULL )
	{
		pNextInfo = pCurInfo->GetNext();
		delete pCurInfo;
		pCurInfo = pNextInfo;
	}

	m_pImageInfoListHead = NULL;
}


//*****************************************************************************

HRESULT
CActorBvr::SetVMLAttribute(BSTR propertyName, VARIANT *pVal)
{
	HRESULT hr = S_OK;

	if (m_pVMLRuntimeStyle == NULL)
	{
		// Need to find VML RuntimeStyle
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		IDispatch *pDispatch = NULL;
		hr = pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDispatch));
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;

		BSTR attrName = ::SysAllocString(L"_vgRuntimeStyle");
		if (attrName == NULL)
		{
			ReleaseInterface(pDispatch);
			return E_FAIL;
		}

		hr = GetPropertyAsDispatch(pDispatch, attrName, &m_pVMLRuntimeStyle);
		ReleaseInterface(pDispatch);
		::SysFreeString(attrName);

		if (FAILED(hr))
		{
			m_pVMLRuntimeStyle = NULL;
			return hr;
		}
	}

	hr = SetPropertyOnDispatch(m_pVMLRuntimeStyle, propertyName, pVal);

	return hr;
}

//*****************************************************************************

void
CActorBvr::DiscardBvrCache(void)
{
    ReleaseInterface(m_pOrigLeftTop);
	ReleaseInterface(m_pOrigWidthHeight);
	ReleaseInterface(m_pBoundsMin);
	ReleaseInterface(m_pBoundsMax);
    ReleaseInterface(m_pTranslate);
    ReleaseInterface(m_pRotate);
    ReleaseInterface(m_pScale);
} // DiscardBvrCache

HRESULT
CActorBvr::AttachActorBehaviorToAnimatedElement()
{
	return S_OK;
};

HRESULT
CActorBvr::GetFinalElementDimension( IDANumber** ppdanumWidth, IDANumber** ppdanumHeight)
{
	if( ppdanumWidth == NULL || ppdanumHeight == NULL )
	{
		return E_INVALIDARG;
	}

	//one of the m_pdanumFinalElement* variables is set without the other being set.
	DASSERT( !((m_pdanumFinalElementWidth == NULL && m_pdanumFinalElementHeight != NULL) ||
			   (m_pdanumFinalElementWidth != NULL && m_pdanumFinalElementHeight == NULL)) );

	HRESULT hr = S_OK;
	//if no one has set the final width and height yet
	if( m_pdanumFinalElementWidth == NULL && m_pdanumFinalElementHeight == NULL )
	{
		//create switchers, we will switch in the final values when they are ready
		hr = GetDAStatics()->ModifiableNumber( 1.0, &m_pdanumFinalElementWidth );
		CheckHR( hr, "Failed to create a modifiable number for the width", cleanup );

		hr = GetDAStatics()->ModifiableNumber( 1.0, &m_pdanumFinalElementHeight );
		CheckHR( hr, "Failed to create a modifiable number for the height", cleanup );
	}
	(*ppdanumWidth) = m_pdanumFinalElementWidth;
	m_pdanumFinalElementWidth->AddRef();

	(*ppdanumHeight) = m_pdanumFinalElementHeight;
	m_pdanumFinalElementHeight->AddRef();

cleanup:

	return hr;
}


HRESULT
CActorBvr::SetFinalElementDimension( IDANumber* pdanumWidth, IDANumber* pdanumHeight, bool fHook )
{
	if( pdanumWidth == NULL || pdanumHeight == NULL )
		return E_INVALIDARG;

	//one of the m_pdanumFinalElement* variables is set without the other being set.
	DASSERT( !((m_pdanumFinalElementWidth == NULL && m_pdanumFinalElementHeight != NULL) ||
			   (m_pdanumFinalElementWidth != NULL && m_pdanumFinalElementHeight == NULL)) );

	HRESULT hr = S_OK;

	if( m_pdanumFinalElementWidth == NULL && m_pdanumFinalElementHeight == NULL )
	{
		IDABehavior *pdabvrModWidth = NULL;
		IDABehavior *pdabvrModHeight = NULL;
		
		//create a modifiable behavior to be the width and height
		hr = GetDAStatics()->ModifiableBehavior( pdanumWidth, &pdabvrModWidth );
		CheckHR( hr, "Failed to create a modifiableNumber", createCleanup );

		hr = pdabvrModWidth->QueryInterface( IID_TO_PPV( IDANumber, &m_pdanumFinalElementWidth) );
		CheckHR( hr, "QI for IDANumber failed", createCleanup );

		hr = GetDAStatics()->ModifiableBehavior( pdanumHeight, &pdabvrModHeight );
		CheckHR( hr, "Failed to create a modifiable behavior", createCleanup );

		hr = pdabvrModHeight->QueryInterface( IID_TO_PPV(IDANumber, &m_pdanumFinalElementHeight ) );
		CheckHR( hr, "QI for IDANumber Failed", createCleanup );
		
	createCleanup:
		ReleaseInterface( pdabvrModWidth );
		ReleaseInterface( pdabvrModHeight );
		if( FAILED( hr ) )
		{
			goto cleanup;
		}
	}
	else //final width and height were already set
	{
		IDA2Behavior *pda2bvrWidth = NULL;
		IDA2Behavior *pda2bvrHeight = NULL;

		hr = m_pdanumFinalElementWidth->QueryInterface( IID_TO_PPV( IDA2Behavior, &pda2bvrWidth ) );
		CheckHR( hr, "Failed QI for IDA2Behavior on the final width behavior", cleanup );

		hr = pda2bvrWidth->SwitchToEx( pdanumWidth, DAContinueTimeline );
		ReleaseInterface( pda2bvrWidth );
		CheckHR( hr, "Failed to switch in the final Element Width", cleanup );

		hr = m_pdanumFinalElementHeight->QueryInterface( IID_TO_PPV( IDA2Behavior, &pda2bvrHeight ) );
		CheckHR( hr, "Failed QI for IDA2Behavior on the final height behavior", cleanup );

		hr = pda2bvrHeight->SwitchToEx( pdanumHeight, DAContinueTimeline );
		ReleaseInterface( pda2bvrHeight );
		CheckHR( hr, "Failed to switch in the final Element Height", cleanup );
	}
	if( fHook && m_pFinalElementDimensionSampler == NULL )
	{
		m_pFinalElementDimensionSampler = new CFinalDimensionSampler( this );
		if( m_pFinalElementDimensionSampler == NULL )
		{
			hr = E_OUTOFMEMORY;
			goto cleanup;
		}

		hr = m_pFinalElementDimensionSampler->Attach(  m_pdanumFinalElementWidth, m_pdanumFinalElementHeight );
		CheckHR( hr, "Failed to attach to final dimensions", cleanup );
	}
cleanup:

	return hr;
}

//*****************************************************************************

HRESULT 
CActorBvr::PrepareImageForDXTransform( IDAImage *pOriginal,
								       IDAImage **ppResult)
{
    if( pOriginal == NULL || ppResult == NULL )
        return E_INVALIDARG;

	/*
    pOriginal->AddRef();
    (*ppResult) = pOriginal;
    return S_OK;
    */
    

    HRESULT hr;

	IDABehavior *pdabvrSwitchable = NULL;
	IDA2Image *pdaimg2Image = NULL;
	IDAImage *pdaimgFinal = NULL;
    IDAImage *pdaimgOverlaid = NULL;
    IDATransform2 *pdatfmPixel = NULL;
    IDAPoint2 *pdapt2MinMeter = NULL;
    IDAPoint2 *pdapt2MaxMeter = NULL;

	IDANumber *pdanumTwo = NULL;
	IDANumber *pdanumHalfPixelWidth = NULL;
	IDANumber *pdanumHalfPixelHeight = NULL;
	IDANumber *pdanumNegHalfPixelWidth = NULL;
	IDANumber *pdanumNegHalfPixelHeight = NULL;

	IDANumber *pdanumFinalPixelWidth = NULL;
	IDANumber *pdanumFinalPixelHeight = NULL;

    IDAImage *pdaimgDetectable;
    hr = GetDAStatics()->get_DetectableEmptyImage(&pdaimgDetectable);
    CheckHR( hr, "Failed to get the detectable empty image from statics", cleanup );
    
    hr = GetDAStatics()->Overlay( pOriginal, pdaimgDetectable, &pdaimgOverlaid );
    ReleaseInterface( pdaimgDetectable );
    CheckHR( hr, "Failed to overlay the original image on the detectableEmptyImage", cleanup );

    IDANumber *pdanumMetersPerPixel;
    hr = GetDAStatics()->get_Pixel( &pdanumMetersPerPixel );
    CheckHR( hr, "Failed to get pixel from statics", cleanup );
    
    hr = GetDAStatics()->Scale2Anim( pdanumMetersPerPixel, pdanumMetersPerPixel, &pdatfmPixel );
    ReleaseInterface( pdanumMetersPerPixel );
    CheckHR( hr, "Failed to create a scale2 for pixel", cleanup );

	hr = GetDAStatics()->DANumber( 2.0, &pdanumTwo );
	CheckHR( hr, "Failed to create a danumber for 2.0", cleanup );

	hr = GetFinalElementDimension( &pdanumFinalPixelWidth, &pdanumFinalPixelHeight );
	CheckHR( hr, "Failed to get the final element dimensions from the actor", cleanup );

	hr = GetDAStatics()->Div( pdanumFinalPixelWidth, pdanumTwo, &pdanumHalfPixelWidth );
	CheckHR( hr, "Failed to divide pixel width by two in da", cleanup );

	hr = GetDAStatics()->Div( pdanumFinalPixelHeight, pdanumTwo, &pdanumHalfPixelHeight );
	CheckHR( hr, "Failed to divide pixel height by two in DA", cleanup );

	hr = GetDAStatics()->Neg( pdanumHalfPixelWidth, &pdanumNegHalfPixelWidth );
	CheckHR( hr, "Failed to negate halfWidth", cleanup );

	hr = GetDAStatics()->Neg( pdanumHalfPixelHeight, &pdanumNegHalfPixelHeight );
	CheckHR( hr, "Failed to negate halfHeight", cleanup );

    IDAPoint2 *pdapt2Min;
    hr = GetDAStatics()->Point2Anim( pdanumNegHalfPixelWidth, pdanumNegHalfPixelHeight, &pdapt2Min );
    CheckHR( hr, "Failed to create the min point", cleanup );

    hr = pdapt2Min->Transform( pdatfmPixel, &pdapt2MinMeter );
    ReleaseInterface( pdapt2Min );
    CheckHR( hr, "Failed to transform the min point", cleanup );

    IDAPoint2 *pdapt2Max;
    hr = GetDAStatics()->Point2Anim( pdanumHalfPixelWidth, pdanumHalfPixelHeight, &pdapt2Max );
    CheckHR( hr, "Failed to create the max point", cleanup );

    hr = pdapt2Max->Transform( pdatfmPixel, &pdapt2MaxMeter );
    ReleaseInterface( pdapt2Max );
    CheckHR( hr, "Failed to transform the max point", cleanup );


	IDAImage *pdaimgCropped;
    hr = pdaimgOverlaid->Crop( pdapt2MinMeter, pdapt2MaxMeter, &pdaimgCropped );
    CheckHR( hr, "Failed to crop the overlaid image", cleanup );

    hr = pdaimgCropped->QueryInterface( IID_TO_PPV( IDA2Image, &pdaimg2Image ) );
    ReleaseInterface( pdaimgCropped );
    CheckHR( hr, "Failed to get IDA2Image off of the final image", cleanup );

    IDAImage *pdaimgNew;
    hr = pdaimg2Image->RenderResolution( m_pixelWidth, m_pixelHeight, &pdaimgNew );
    CheckHR( hr, "Failed to set the render resolution on the final image", cleanup );

	hr = GetDAStatics()->ModifiableBehavior( pdaimgNew, &pdabvrSwitchable );
	ReleaseInterface( pdaimgNew );
	CheckHR( hr, "Failed to create a modifiable behavior", cleanup );

	hr = pdabvrSwitchable->QueryInterface( IID_TO_PPV( IDAImage, &pdaimgFinal ) );
	CheckHR( hr, "QI for image on switchable created from image failed", cleanup );

	hr = AddImageInfo( pdaimg2Image, pdabvrSwitchable );
	CheckHR( hr, "Failed to add Image info to the actor", cleanup );

    (*ppResult) = pdaimgFinal;

cleanup:

    if( FAILED( hr ) )
    {
        *ppResult = NULL;
    }

	ReleaseInterface( pdaimg2Image );
	ReleaseInterface( pdabvrSwitchable );
    ReleaseInterface( pdaimgOverlaid );
    ReleaseInterface( pdatfmPixel );
    ReleaseInterface(pdapt2MinMeter);
    ReleaseInterface(pdapt2MaxMeter);

	ReleaseInterface( pdanumHalfPixelWidth );
	ReleaseInterface( pdanumHalfPixelHeight);
	ReleaseInterface( pdanumNegHalfPixelWidth );
	ReleaseInterface( pdanumNegHalfPixelHeight );
	ReleaseInterface( pdanumTwo );

	ReleaseInterface( pdanumFinalPixelWidth );
	ReleaseInterface( pdanumFinalPixelHeight );

    return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::ApplyClipToImage( IDAImage *pImageIn, IDAPoint2 *pMin, IDAPoint2 *pMax, IDAImage** ppImageOut )
{
	if( pImageIn == NULL || pMin == NULL || pMax == NULL || ppImageOut == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	//declare interface pointers
	IDANumber *pMinX = NULL;
	IDANumber *pMinY = NULL;
	IDANumber *pMaxX = NULL;
	IDANumber *pMaxY = NULL;

	IDAPoint2 *pTopLeft = NULL;
	IDAPoint2 *pBotRight = NULL;

	IDAPoint2 *pPoints[4];

	//get coordinates from the points
	hr = pMin->get_X( &pMinX );
	CheckHR( hr, "Failed to get the x coord from the min point", cleanup );

	hr = pMin->get_Y( &pMinY );
	CheckHR( hr, "Failed to get the y coord from the min point", cleanup );
	
	hr = pMax->get_X( &pMaxX );
	CheckHR( hr, "Failed to get the x coord from the max point", cleanup );

	hr = pMax->get_Y( &pMaxY );
	CheckHR( hr, "Failed to get the y coord from the max point", cleanup );

	//build points for top Left and bottom right
	hr = GetDAStatics()->Point2Anim( pMinX, pMaxY, &pTopLeft );
	CheckHR( hr, "Failed to create a point 2 for the Top left", cleanup );

	hr = GetDAStatics()->Point2Anim( pMaxX, pMinY, &pBotRight );
	CheckHR( hr, "Failed to create a point 2 for the bottom right", cleanup );

	//call clip polygon image on it
	pPoints[0] = pTopLeft;
	pPoints[1] = pMax;
	pPoints[2] = pBotRight;
	pPoints[3] = pMin;

	hr = pImageIn->ClipPolygonImageEx( 4, pPoints, ppImageOut );
	CheckHR( hr, "Failed to clip the image to a polygon", cleanup );

cleanup:
	//release interface pointers
	ReleaseInterface( pMinX );
	ReleaseInterface( pMinY );
	ReleaseInterface( pMaxX );
	ReleaseInterface( pMaxY );
	
	ReleaseInterface( pTopLeft );
	ReleaseInterface( pBotRight );

	return hr;
}

//*****************************************************************************

HRESULT 
CActorBvr::AddBehaviorToTIME(IDABehavior *pbvrAdd, long* plCookie)
{
    DASSERT(pbvrAdd != NULL);
	if( plCookie == NULL )
		return E_INVALIDARG;
	if( GetHTMLElement() == NULL )
		return E_FAIL;
	
    HRESULT hr;
	
	DISPPARAMS              params;
	VARIANT                 varBehavior;
	VARIANT                 varResult;
	
	VariantInit(&varBehavior);
	varBehavior.vt = VT_DISPATCH;
	varBehavior.pdispVal = pbvrAdd;
	
	VariantInit(&varResult);
	
	params.rgvarg                           = &varBehavior;
	params.rgdispidNamedArgs        = NULL;
	params.cArgs                            = 1;
	params.cNamedArgs                       = 0;
    hr = CallInvokeOnHTMLElement(GetHTMLElement(),
								 L"AddDABehavior", 
								 DISPATCH_METHOD,
								 &params,
								 &varResult);

	
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in AddBehaviorToTIME");
		VariantClear(&varResult);
		return hr;
    }

	if( V_VT( &varResult ) != VT_I4 )
	{
		//change the type.
		hr = VariantChangeTypeEx( &varResult, &varResult, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4 );
		if( FAILED( hr ) )
		{
			DPF_ERR( "Error changing the type of the value returned from addDABehavior to a long " );
			VariantClear( &varResult );
			return hr;
		}

	}

	(*plCookie) = V_I4( &varResult );

	VariantClear(&varResult);

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::RemoveBehaviorFromTIME( long cookie )
{
	if( GetHTMLElement() == NULL )
		return E_FAIL;

	
    HRESULT hr;
	
	DISPPARAMS              params;
	VARIANT                 varCookie;
	VARIANT                 varResult;
	
	VariantInit(&varCookie);
	V_VT( &varCookie ) = VT_I4;
	V_I4( &varCookie ) = cookie;
	
	VariantInit(&varResult);
	
	params.rgvarg                           = &varCookie;
	params.rgdispidNamedArgs				= NULL;
	params.cArgs                            = 1;
	params.cNamedArgs                       = 0;
    hr = CallInvokeOnHTMLElement(GetHTMLElement(),
								 L"removeDABehavior", 
								 DISPATCH_METHOD,
								 &params,
								 &varResult);

	
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in RemoveBehaviorFromTIME");
		VariantClear(&varResult);
		return hr;
    }

	VariantClear(&varResult);

    return S_OK;
}

//*****************************************************************************

bool
CActorBvr::IsAnimatingVML()
{
	return CheckBitSet( m_dwCurrentState, ELEM_IS_VML );
}

//*****************************************************************************

HRESULT
CActorBvr::GetCurrentState( DWORD *pdwState )
{
	HRESULT hr = S_OK;

	(*pdwState) = 0;

	bool valueSet = false;

	//check the state of pixel scale
	hr = CUtils::InsurePropertyVariantAsBool(&m_varPixelScale);
	if (SUCCEEDED(hr) && (V_BOOL(&m_varPixelScale) == VARIANT_TRUE))
	{
		LMTRACE2(1, 1000, "Pixel scale is on\n" );
		SetBit( (*pdwState), PIXEL_SCALE_ON );
	}


	//check the state of static rotation
	hr = IsStaticRotationSet( &valueSet );
	CheckHR( hr, "Failed to check to see if the static rotation is set", end );
	
	if( valueSet )
	{
		LMTRACE2( 1, 1000, "static rotation is set\n" );
		SetBit( (*pdwState), STATIC_ROTATION );
	}

	//check the state of static scale
	hr = IsStaticScaleSet( &valueSet );
	CheckHR( hr, "Failed to check if the static scale is set", end );
	if ( valueSet )
	{
		LMTRACE2( 1, 1000, "Static Scale is set\n");
		SetBit( (*pdwState), STATIC_SCALE );
	}

	//check whether or not the element is vml
	hr = IsAnimatedElementVML( &valueSet );
	CheckHR( hr, "Failed to check element for VMLness", end );
	if( valueSet )
	{
		LMTRACE2( 1, 2, "this is a VML Shape\n" );

		SetBit( (*pdwState), ELEM_IS_VML );
	}

end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::UpdateCurrentState()
{
	HRESULT hr = S_OK;
	
	DWORD dwOldState = m_dwCurrentState;

	hr = GetCurrentState( &m_dwCurrentState );

	//if the element is vml we may have failed to set is offscreen because
	//  the vgx behavior may not have been available yet.
	if( ( CheckBitSet( m_dwCurrentState, ELEM_IS_VML) && 
		  CheckBitNotSet( dwOldState, ELEM_IS_VML) 
		) ||
		m_fVisSimFailed 
	  )
	{
	    if( m_bEditMode && (m_simulVisHidden || m_simulDispNone ) )
		{
			VisSimSetOffscreen( NULL, false );
		}
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::IsStaticScaleSet( bool *pfIsSet )
{
	if( pfIsSet == NULL )
		return E_INVALIDARG;

	(*pfIsSet) = true;
	
	HRESULT hr = S_OK;

	int cReturnedValues;
	float scaleVal[3];


    hr = CUtils::GetVectorFromVariant(&m_varScale, 
                                      &cReturnedValues, 
                                      &(scaleVal[0]), 
                                      &(scaleVal[1]), 
                                      &(scaleVal[2]));

	if (FAILED(hr) || cReturnedValues != 2)
	{
		// This is OK, since it just means they didn't set an appropriate scale.
		(*pfIsSet) = false;
		hr = S_OK;
	}
	

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::IsStaticRotationSet( bool *pfIsSet )
{
	if( pfIsSet == NULL )
		return E_INVALIDARG;
		
	HRESULT hr = S_OK;

	IHTMLElement2 *pelem2 = NULL;
	IHTMLCurrentStyle *pcurstyle = NULL;
	VARIANT varRotation;

	(*pfIsSet) = false;

	::VariantInit( &varRotation );

	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IHTMLElement2, &pelem2 ) );
	CheckHR( hr, "QI for IHTMLElement2 on the element failed", end );

	hr = pelem2->get_currentStyle( &pcurstyle );
	CheckHR( hr, "Failed to get the current style from the element", end );
	CheckPtr( pcurstyle, hr, E_POINTER, "Got a null pointer for the current style", end );

	hr = pcurstyle->getAttribute( L"rotation", 0, &varRotation );
	if( SUCCEEDED( hr ) )
	{
		//make sure that this can be converted to a valid rotation value
		if( V_VT( &varRotation ) == VT_BSTR )
		{
			//strip off the units
			BSTR bstrVal = V_BSTR(&varRotation);
			OLECHAR* pUnits;

			hr = FindCSSUnits( bstrVal, &pUnits );
			if( SUCCEEDED(hr) && pUnits != NULL )
			{
				(*pUnits) = L'\0';
				BSTR bstrNewVal = SysAllocString(bstrVal);
				V_BSTR(&varRotation) = bstrNewVal;
				SysFreeString(bstrVal);
			}
			//else oh well no units.
		}

		//try to convert it to a double
		hr = ::VariantChangeTypeEx(&varRotation,
								 &varRotation,
								 LCID_SCRIPTING,
								 VARIANT_NOUSEROVERRIDE,
								 VT_R8);

		//if it got through this then it's a genuine rotation
		if( SUCCEEDED( hr ) )
		{
			(*pfIsSet) = true;
		}
		else
		{
			//this is okay, it just means there's no understandable rotation
			hr = S_OK;
		}
	}
	else 
	{
		//this is okay, it just means there's no rotation
		hr = S_OK;
	}
		

end:

	ReleaseInterface( pelem2 );
	ReleaseInterface( pcurstyle );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::EnsureBodyPropertyMonitorAttached()
{
	HRESULT hr = S_OK;

	if( m_pBodyPropertyMonitor != NULL )
	{
		if( !m_pBodyPropertyMonitor->IsAttached() )
		{
			hr = AttachBodyPropertyMonitor();
		}
		else
		{
			hr = S_OK;
		}
	}
	else
	{
		hr = AttachBodyPropertyMonitor();
	}


	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::AttachBodyPropertyMonitor()
{
	if( GetHTMLElement() == NULL )
		return E_POINTER;

	HRESULT				hr				= S_OK;

	IDispatch			*pdispDocument	= NULL;
	IHTMLDocument2		*pdoc2Document	= NULL;
	IHTMLElement		*pelemBody		= NULL;

	IHTMLElement		*pelemParent	= NULL;

	//if our parent is null we are not in a valid document, which will
	// cause bad things to happen when we make the later calls in this 
	// method.
	hr = GetHTMLElement()->get_parentElement( &pelemParent );
	CheckHR( hr, "Failed to get the parent Element", end);
	CheckPtr( pelemParent, hr, E_POINTER, "The parent is null", end );

	//get the document from the element to which we are attached.
	hr = GetHTMLElement()->get_document( &pdispDocument );
	CheckHR( hr, "Failed to get the document from the html element of the actor", end );
	CheckPtr( pdispDocument, hr, E_POINTER, "Got a null document from get_document", end );

	hr = pdispDocument->QueryInterface( IID_TO_PPV( IHTMLDocument2, &pdoc2Document ) );
	CheckHR( hr, "Failed to get the document2 interface from document dipatch", end );

	//get the body from the document that we are in
	hr = pdoc2Document->get_body( &pelemBody );
	CheckHR( hr, "Failed to get the body from the document", end );
	CheckPtr( pelemBody, hr, E_POINTER, "Got a null body from the document", end );

	if( m_pBodyPropertyMonitor == NULL )
	{
		//create one
		m_pBodyPropertyMonitor = new CElementPropertyMonitor();
		CheckPtr( m_pBodyPropertyMonitor, hr, E_OUTOFMEMORY, "Ran out of memory trying to allocate the body event monitor", createMonitorEnd );

		//keep it around as long as we need it.
		m_pBodyPropertyMonitor->AddRef();

		//set this actor as the local time listener.
		hr = m_pBodyPropertyMonitor->SetLocalTimeListener( static_cast<IElementLocalTimeListener*>(this) );
		CheckHR( hr, "Failed to set the local time listener on the body event monitor", createMonitorEnd );
	createMonitorEnd:
		if( FAILED( hr ) )
		{
			if( m_pBodyPropertyMonitor != NULL )
			{
				m_pBodyPropertyMonitor->Release();
				m_pBodyPropertyMonitor = NULL;
			}
			goto end;
		}
	}

	//attach the body event monitor to the body element
	hr = m_pBodyPropertyMonitor->Attach( pelemBody );
	CheckHR( hr, "Failed to attach the body event monitor to the body element", end );

end:
	ReleaseInterface( pdispDocument );
	ReleaseInterface( pdoc2Document );
	ReleaseInterface( pelemBody );
	ReleaseInterface( pelemParent );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::DetachBodyPropertyMonitor()
{
	HRESULT hr = S_OK;

	if( m_pBodyPropertyMonitor != NULL )
	{
		hr = m_pBodyPropertyMonitor->Detach();
		CheckHR( hr, "Failed to detach the event monitor from the body", end );
	}

end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::DestroyBodyPropertyMonitor()
{
	HRESULT hr = S_OK;

	if( m_pBodyPropertyMonitor != NULL )
	{
		hr = DetachBodyPropertyMonitor();
		CheckHR( hr, "Failed to detach the body event monitor", end );

		m_pBodyPropertyMonitor->Release();

		m_pBodyPropertyMonitor = NULL;
	}

end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::AnimatedElementOnResize()
{
	UpdatePixelDimensions();

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::OnWindowUnload()
{
	HRESULT hr = S_OK;

	m_fUnloading = true;

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::AttachEvents()
{
	IHTMLElement *pelemAnimated = NULL;
	IHTMLElement2*pelem2Animated = NULL;
	VARIANT_BOOL varboolSuccess;

	HRESULT hr = S_OK;

	hr = GetAnimatedElement( &pelemAnimated );
	CheckHR( hr, "Failed to get the animated element", end );

	hr = pelemAnimated->QueryInterface( IID_TO_PPV( IHTMLElement2, &pelem2Animated ) );
	CheckHR( hr, "Couldn't get IHTMLElement2 from an element", end );

	if( m_pOnResizeHandler == NULL )
	{
		//create one
		m_pOnResizeHandler = new COnResizeHandler( this );
		CheckPtr( m_pOnResizeHandler, hr, E_OUTOFMEMORY, "ran out of memory trying to create an onresize handler", end );
		
		//attach it
		hr = pelem2Animated->attachEvent( L"onresize", m_pOnResizeHandler, &varboolSuccess );
		CheckHR( hr, "Failed to attachEvent to onresize", end );

		if( varboolSuccess == VARIANT_FALSE )
		{
			DPF_ERR("Failed to attach to the onresize event" );
			//delete the handler.
			m_pOnResizeHandler->Release();

			m_pOnResizeHandler = NULL;
		}
	}

	if( m_pOnUnloadHandler == NULL )
	{
		IHTMLWindow2		*pwin2 		= NULL;
		IHTMLWindow3	 	*pwin3		= NULL;
		
		//create one
		m_pOnUnloadHandler = new COnUnloadHandler( this );
		CheckPtr( m_pOnUnloadHandler, hr, E_OUTOFMEMORY, "Ran out of memory trying to create an onunload handler", OnUnloadEnd );

		//attach it
		hr = GetParentWindow( &pwin2 );
		CheckHR( hr, "Failed to get the window", OnUnloadEnd );

		hr = pwin2->QueryInterface( IID_TO_PPV( IHTMLWindow3, &pwin3 ) );
		CheckHR( hr, "Failed to get IHTMLWindow3 from the window", OnUnloadEnd );

		hr = pwin3->attachEvent( L"onunload", m_pOnUnloadHandler, &varboolSuccess );
		CheckHR( hr, "Failed to attach to the onunload event on the window", OnUnloadEnd );

		if( varboolSuccess == VARIANT_FALSE )
		{
			DPF_ERR( "failed to attach to onunload " );

			//delete the hanlder
			m_pOnUnloadHandler->Release();

			m_pOnUnloadHandler = NULL;
		}

	OnUnloadEnd:
		ReleaseInterface( pwin2 );
		ReleaseInterface( pwin3 );

		if( FAILED( hr ) )
		{	
			goto end;
		}
		
	}

end:

	ReleaseInterface( pelemAnimated );
	ReleaseInterface( pelem2Animated );

	return hr;
}


//*****************************************************************************

HRESULT
CActorBvr::DetachEvents()
{
	HRESULT hr = S_OK;

	IHTMLElement *pelemAnimated = NULL;
	IHTMLElement2*pelem2Animated = NULL;

	hr = GetAnimatedElement( &pelemAnimated );
	CheckHR( hr, "Failed to get the animated element", end );

	hr = pelemAnimated->QueryInterface( IID_TO_PPV( IHTMLElement2, &pelem2Animated ) );
	CheckHR( hr, "Couldn't get IHTMLElement2 from an element", end );

	if( m_pOnResizeHandler != NULL )
	{
		hr = pelem2Animated->detachEvent( L"onresize", m_pOnResizeHandler );
		CheckHR( hr, "Failed to detach onresize", end );
	}

	
	if( m_pOnUnloadHandler != NULL )
	{
		IHTMLWindow2 *pwin2 = NULL;
		IHTMLWindow3 *pwin3 = NULL;
		
		hr = GetParentWindow( &pwin2 );
		CheckHR( hr, "failed to get the window", unloadEnd );

		hr = pwin2->QueryInterface( IID_TO_PPV( IHTMLWindow3, &pwin3 ) );
		CheckHR( hr, "Failed to get window3 from the window", unloadEnd );

		hr = pwin3->detachEvent( L"onunload", m_pOnUnloadHandler );
		CheckHR( hr, "Failed to detach from onunload", unloadEnd );
	unloadEnd:
		ReleaseInterface( pwin2 );
		ReleaseInterface( pwin3 );
		if( FAILED( hr ) )
			goto end;

	}


end:
	//we want to release the event handlers no matter what
	if( m_pOnResizeHandler != NULL )
	{
		m_pOnResizeHandler->Invalidate();
		m_pOnResizeHandler->Release();
		m_pOnResizeHandler = NULL;
	}

	if( m_pOnUnloadHandler != NULL )
	{
		m_pOnUnloadHandler->Invalidate();
		m_pOnUnloadHandler->Release();
		m_pOnUnloadHandler = NULL;
	}

	
	ReleaseInterface( pelemAnimated );
	ReleaseInterface( pelem2Animated );

	return hr;
}

//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetAttributeFromHTMLElement(IHTMLElement *pElement, 
                                           WCHAR *pwzAttributeName, 
                                           VARIANT *pvarReturn)
{
	return GetAttributeFromHTMLElement(pElement, pwzAttributeName, false, pvarReturn);
}
*/
//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetCurrAttribFromHTMLElement(IHTMLElement *pElement, 
                                           WCHAR *pwzAttributeName, 
                                           VARIANT *pvarReturn)
{
	return GetAttributeFromHTMLElement(pElement, pwzAttributeName, true, pvarReturn);
}
*/
//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetAttributeFromHTMLElement(WCHAR *pwzAttributeName, 
                                           VARIANT *pvarReturn)
{
    DASSERT(pwzAttributeName != NULL);
    DASSERT(pvarReturn != NULL);
    return GetAttributeFromHTMLElement(m_pHTMLElement, pwzAttributeName, false, pvarReturn);
}
*/
//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetCurrAttribFromHTMLElement(WCHAR *pwzAttributeName, 
                                           VARIANT *pvarReturn)
{
    DASSERT(pwzAttributeName != NULL);
    DASSERT(pvarReturn != NULL);
    return GetAttributeFromHTMLElement(m_pHTMLElement, pwzAttributeName, true, pvarReturn);
}
*/
//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetAttributeFromParentHTMLElement(WCHAR *pwzAttributeName, 
                                                 VARIANT *pvarReturn)
{
    DASSERT(pwzAttributeName != NULL);
    DASSERT(pvarReturn != NULL);
    DASSERT(m_pHTMLElement != NULL);

    HRESULT hr;


    IHTMLElement *pParentElement;
    hr = m_pHTMLElement->get_parentElement(&pParentElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining parent element from HTML element");
		return SetErrorInfo(hr);
    }
    // now extract our attributes from the parent HTMLElement
    hr = GetAttributeFromHTMLElement(pParentElement, pwzAttributeName, false, pvarReturn);
    ReleaseInterface(pParentElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error extracting attribute from HTML element");
		return hr;
    }
    return S_OK;
} // GetAttributeFromParentHTMLElement
*/
//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetCurrAttribFromParentHTMLElement(WCHAR *pwzAttributeName, 
                                                 VARIANT *pvarReturn)
{
    DASSERT(pwzAttributeName != NULL);
    DASSERT(pvarReturn != NULL);
    DASSERT(m_pHTMLElement != NULL);

    HRESULT hr;


    IHTMLElement *pParentElement;
    hr = m_pHTMLElement->get_parentElement(&pParentElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining parent element from HTML element");
		return SetErrorInfo(hr);
    }
    // now extract our attributes from the parent HTMLElement
    hr = GetAttributeFromHTMLElement(pParentElement, pwzAttributeName, true, pvarReturn);
    ReleaseInterface(pParentElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error extracting attribute from HTML element");
		return hr;
    }
    return S_OK;
} // GetAttributeFromParentHTMLElement
*/

//*****************************************************************************
/*
// TODO (markhal): Should this go away?  It should refer to actor not animated element
// TODO (markhal): Should add GetCurrAttrib version of whatever it ends up being called
HRESULT 
CBaseBehavior::GetAttributeFromAnimatedHTMLElement(WCHAR *pwzAttributeName, 
                                                   VARIANT *pvarReturn)
{
    DASSERT(pwzAttributeName != NULL);
    DASSERT(pvarReturn != NULL);
    DASSERT(m_pHTMLElement != NULL);

    HRESULT hr;

    IHTMLElement *pAnimatedElement;
    hr = GetElementToAnimate(&pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining element to animate");
        return SetErrorInfo(hr);
    }
    DASSERT(pAnimatedElement != NULL);
    // get the html attribute here
    hr = GetAttributeFromHTMLElement(pAnimatedElement, pwzAttributeName, pvarReturn);
    ReleaseInterface(pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error extracting attribute from HTML element");
		return hr;
    }
    return S_OK;

} // GetAttributeFromAnimatedHTMLElement
*/
//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\basebvr.cpp ===
//*****************************************************************************
//
// File: basebvr.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CBaseBehavior object 
//
// Modification List:
// Date         Author          Change
// 09/26/98     jeffort         Created this file
// 10/16/98 jeffort     Added animates property
// 10/16/98 jeffort     Renamed functions, implemented functions to animate
//                      properties
// 10/21/98 jeffort     added BuildTIMEInterpolatedNumber()
// 11/16/98 markhal             added ApplyImageToAnimationElement
// 11/17/98 kurtj       actor construction
// 11/19/98 markhal     Added GetCurrAttrib... methods and prefix hack
//*****************************************************************************

#include "headers.h"

#include "basebvr.h"
#include "dautil.h"
#include "attrib.h"
#include "datime.h"

#define WZ_ACTORDETECTIONMETHOD L"addBehaviorFragment"
#define WZ_ACTOR_URN L"#lmbehavior#actor"
#define WZ_TIMEDA_URN L"#time#da"
#define WZ_TIME_URN L"#time"
#define WZ_TIME_REGISTERED_URN L"TIME_BEHAVIOR_URN"

//*****************************************************************************


CBaseBehavior::CBaseBehavior() :
        m_pBehaviorSite(NULL),
    m_pDAStatics(NULL),
    m_fPropertiesDirty(false),
    m_pHTMLElement(NULL),
    m_fAcceptRebuildRequests( false ),
    m_pdanumZero( NULL ),
    m_pdanumOne( NULL ),
    m_pelemAnimatedParent( NULL )
{
    VariantInit(&m_varAnimates);
} // CBaseBehavior

//*****************************************************************************

CBaseBehavior::~CBaseBehavior()
{
    ReleaseInterface(m_pBehaviorSite);
        // TODO: Figure out why we cannot release this
    //ReleaseInterface(m_pHTMLElement);
    ReleaseInterface(m_pDAStatics);
    VariantClear(&m_varAnimates);

    ReleaseInterface( m_pdanumZero );
    ReleaseInterface( m_pdanumOne );

    ReleaseInterface( m_pelemAnimatedParent );
} // ~CBaseBehavior

//*****************************************************************************

HRESULT 
CBaseBehavior::FinalConstruct()
{
    return S_OK;
} // FinalConstruct

//*****************************************************************************

HRESULT
CBaseBehavior::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr;

    if (pSite == NULL)
    {
        DPF_ERR("Error in Init:  Invalid Site passed into behavior");
        return SetErrorInfo(E_INVALIDARG);
    }
    m_pBehaviorSite = pSite;
    m_pBehaviorSite->AddRef();

    IHTMLElement *pHTMLElement = NULL;
    hr = m_pBehaviorSite->GetElement(&m_pHTMLElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining an element from an IElementBehaviorSite in GetHTMLAttribute");
        ReleaseInterface(m_pBehaviorSite);
                return SetErrorInfo(hr);
    }
    
    hr = AttachActorBehaviorToAnimatedElement();
    if (FAILED(hr))
    {
        DPF_ERR("Error insuring actor behavior exists");
        ReleaseInterface(m_pBehaviorSite);
        ReleaseInterface(m_pHTMLElement);
        return hr;
    }

    if (GetBehaviorTypeAsURN() != NULL)
    {
        bool fBehaviorExists = false;       
        hr = CheckElementForBehaviorURN(m_pHTMLElement, GetBehaviorTypeAsURN(), &fBehaviorExists);
        if (FAILED(hr))
        {
            DPF_ERR("error detecting if behavior already exists");
            ReleaseInterface(m_pBehaviorSite);
            ReleaseInterface(m_pHTMLElement);
            return hr;
        }
        if (fBehaviorExists)
        {
            DPF_ERR("Error: can not attach behavior of same type to element");
            ReleaseInterface(m_pBehaviorSite);
            ReleaseInterface(m_pHTMLElement);
            // TODO: find better error code
            return SetErrorInfo(E_FAIL);
        }
        // we did not find a match, so set our urn on the behavior site
        IElementBehaviorSiteOM *pSiteOM;
        hr = m_pBehaviorSite->QueryInterface(IID_TO_PPV(IElementBehaviorSiteOM, &pSiteOM));
        if (FAILED(hr))
        {
            DPF_ERR("Error getting behavior IElementBehaviorSiteOM from m_pBehaviorSite");
            ReleaseInterface(m_pBehaviorSite);
            ReleaseInterface(m_pHTMLElement);
            return SetErrorInfo(hr);
        }
        hr = pSiteOM->RegisterUrn(GetBehaviorTypeAsURN());
        ReleaseInterface(pSiteOM);
        if (FAILED(hr))
        {
            DPF_ERR("Error calling RegisterUrn from IElementBehaviorSiteOM");
            ReleaseInterface(m_pBehaviorSite);
            ReleaseInterface(m_pHTMLElement);
            return SetErrorInfo(hr);
        }
    }

	//we need to register a name so that we can communicate with our behaviors if the dispatch on the element has
	// not stabalized yet.
	//BUGBUG: currently this registers the same name for all behaviors.  Since we are not expecting more than one of
	//  our behaviors per element, this should be okay.  If this does change then subclasses should implement GetBehaviorName
	//  with the proper behavior name.
    if( GetBehaviorName() != NULL )
    {
    	IElementBehaviorSiteOM *psiteOM = NULL;

    	hr = m_pBehaviorSite->QueryInterface( IID_TO_PPV( IElementBehaviorSiteOM, &psiteOM ) );
    	if( FAILED( hr ) )
    	{
    		DPF_ERR("Failed to get the behavior site om from the behavior site" );
    		return hr;
    	}

		BSTR bstrName = SysAllocString( GetBehaviorName() );
		if( bstrName == NULL )
		{
			ReleaseInterface( psiteOM );
			return E_OUTOFMEMORY;
		}
		
    	hr = psiteOM->RegisterName( bstrName );
    	ReleaseInterface( psiteOM );
    	SysFreeString( bstrName );
    	if( FAILED( hr ) )
    	{
    		DPF_ERR("Failed to register the behavior name" );
    		return hr;
    	}
    }
    // We need to keep a IDA2Statics interface 
    // We will eventually get this from TIME, which will simply have
    // one created for all objects, 
    hr = GetDAStaticsFromTime(&m_pDAStatics);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining DA statics from TIME utility object in Init");
        ReleaseInterface(m_pBehaviorSite);
        ReleaseInterface(m_pHTMLElement);
        return hr;
    }

    return S_OK;    
} // Init

//*****************************************************************************

HRESULT
CBaseBehavior::Notify(LONG dwNotify, VARIANT *pVar)
{
    HRESULT hr = S_OK;

        if (dwNotify == BEHAVIOREVENT_CONTENTREADY)
        {
            m_fAcceptRebuildRequests = true;
        }

        return S_OK;
} // Notify

//*****************************************************************************

HRESULT 
CBaseBehavior::Detach()
{

	CancelRebuildRequests();
	
    ReleaseInterface(m_pBehaviorSite);
    ReleaseInterface(m_pHTMLElement);

    ReleaseInterface( m_pdanumZero );
    ReleaseInterface( m_pdanumOne );

    ReleaseInterface( m_pelemAnimatedParent );
    return S_OK;
} // Detach

//*****************************************************************************

HRESULT 
CBaseBehavior::GetDAStaticsFromTime(IDA2Statics **ppReturn)
{
    DASSERT(ppReturn != NULL);
    DASSERT(m_pHTMLElement != NULL);
    *ppReturn = NULL;

    HRESULT hr;

    // TODO: Eventually this will use IDispatch to get a statics object
    // from TIME.  But this support is not implemented yet
    // So we will simply CoCreate one here
    IDAStatics *pDAStatics;

    hr = CoCreateInstance(CLSID_DAStatics,NULL, CLSCTX_INPROC_SERVER,
                            IID_IDAStatics, (void **)&pDAStatics);      
        if (FAILED(hr))
        {
        DPF_ERR("Error creating DA statics object in Init");
                return SetErrorInfo(hr);
        }
    hr = pDAStatics->QueryInterface(IID_TO_PPV(IDA2Statics, ppReturn));
    ReleaseInterface(pDAStatics);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing for IDA2Statics from DA statics object");
                return SetErrorInfo(hr);
    }

/*	
    hr = (*ppReturn)->put_ModifiableBehaviorFlags( DAContinueTimeline );
    if ( FAILED( hr ) )
    {
    	DPF_ERR("error setting the modifiable behavior flags on the element" );
    	return hr;
    }
*/
    
    DASSERT(*ppReturn != NULL);
    return S_OK;
} // GetDAStaticsFromTime

//*****************************************************************************

// TODO (markhal): This moves to actor when everything talks to the actor
HRESULT 
CBaseBehavior::AddImageToTIME(IHTMLElement *pElement, IDAImage *pbvrAdd, bool enable)
{
    DASSERT(pbvrAdd != NULL);
    DASSERT(pElement != NULL);

    HRESULT hr;
        DISPPARAMS              params;
        VARIANT                 varResult;
        VariantInit(&varResult);

        BSTR  bstr;
        bstr = ::SysAllocString(enable?L"replace":L"none");

        if (bstr == NULL)
        {
            DPF_ERR("Failed to alloc rendermode string");
            return E_OUTOFMEMORY;
        }
        
        VARIANT                 varValue;
        VariantInit(&varValue);
        V_VT(&varValue) = VT_BSTR;
        V_BSTR(&varValue) = bstr;

    DISPID mydispid = DISPID_PROPERTYPUT;
        params.rgvarg = &varValue;
        params.rgdispidNamedArgs = &mydispid;
        params.cArgs = 1;
        params.cNamedArgs = 1;
        hr = CallInvokeOnHTMLElement(pElement,
                                                                 L"renderMode",
                                                                 DISPATCH_PROPERTYPUT,
                                                                 &params,
                                                                 &varResult);
        VariantClear(&varResult);
        if (FAILED(hr))
        {
                DPF_ERR("Failed to put render status");
                return hr;
        }
        
        VARIANT                 varBehavior;
        VariantInit(&varBehavior);
        varBehavior.vt = VT_DISPATCH;
        varBehavior.pdispVal = pbvrAdd;
        params.rgvarg                           = &varBehavior;
        params.rgdispidNamedArgs        = &mydispid;
        params.cArgs                            = 1;
        params.cNamedArgs                       = 1;
    hr = CallInvokeOnHTMLElement(pElement,
                                 L"Image", 
                                 DISPATCH_PROPERTYPUT,
                                 &params,
                                 &varResult);
        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in AddBehaviorToTIME");
                return SetErrorInfo(hr);
    }

    return S_OK;
}

//*****************************************************************************

// TODO (markhal): This moves to actor when everything talks to the actor
HRESULT 
CBaseBehavior::AddBehaviorToTIME(IDABehavior *pbvrAdd)
{
    DASSERT(pbvrAdd != NULL);

    HRESULT hr;

        DISPPARAMS              params;
        VARIANT                 varBehavior;
        VARIANT                 varResult;
        
        VariantInit(&varBehavior);
        varBehavior.vt = VT_DISPATCH;
        varBehavior.pdispVal = pbvrAdd;

        VariantInit(&varResult);

        params.rgvarg                           = &varBehavior;
        params.rgdispidNamedArgs        = NULL;
        params.cArgs                            = 1;
        params.cNamedArgs                       = 0;
    hr = CallInvokeOnHTMLElement(m_pHTMLElement,
                                 L"AddDABehavior", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);

        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in AddBehaviorToTIME");
                return SetErrorInfo(hr);
    }
    return S_OK;
} // AddBehaviorToTIME

//*****************************************************************************

HRESULT 
CBaseBehavior::GetTIMEImageBehaviorFromElement(IHTMLElement *pElement,
                                               IDAImage **pbvrReturnImage)
{
    DASSERT(pElement != NULL);
    DASSERT(pbvrReturnImage != NULL);
    *pbvrReturnImage = NULL;


    HRESULT hr;
        DISPPARAMS              params;
        VARIANT                 varResult;
    VARIANT         rgvarInput[2];


        VariantInit(&varResult);
        VariantInit(&rgvarInput[0]);
        VariantInit(&rgvarInput[1]);

        params.rgvarg                           = rgvarInput;
        params.rgdispidNamedArgs        = NULL;
        params.cArgs                            = 2;
        params.cNamedArgs                       = 0;
        
    hr = CallInvokeOnHTMLElement(pElement,
                                 L"ElementImage", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in GetTIMEImageBehaviorFromElement");
                return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDAImage
    // TODO: coerce to IDips?
    DASSERT(varResult.vt = VT_DISP);
    hr = varResult.pdispVal->QueryInterface(IID_TO_PPV(IDAImage, pbvrReturnImage));
        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA number");
        return SetErrorInfo(hr);
    }

    return S_OK;
} // GetTIMEImageBehaviorFromElement

//*****************************************************************************

HRESULT 
CBaseBehavior::GetTIMEProgressNumber(IDANumber **ppbvrRet)
{
    DASSERT(ppbvrRet != NULL);
    *ppbvrRet = NULL;

    HRESULT hr;
    DISPPARAMS              params;
    VARIANT                 varResult;

    VariantInit(&varResult);

    params.rgvarg                           = NULL;
    params.rgdispidNamedArgs        		= NULL;
    params.cArgs                            = 0;
    params.cNamedArgs                       = 0;
/*
    IDispatch *pdispDABehavior				=NULL;

    hr = CUtils::FindTimeBehavior( m_pHTMLElement, &pdispDABehavior );
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to find the time da behavior" );
    }
        
    hr = CallInvokeOnDispatch(pdispDABehavior,
                                 L"ProgressBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);

	ReleaseInterface( pdispDABehavior );
*/
	hr = CallInvokeOnHTMLElement(m_pHTMLElement,
                                 L"ProgressBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in GetTIMEProgressNumber");
                return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDANumber
    // TODO: coerce to IDips?
    DASSERT(varResult.vt = VT_DISP);
    hr = varResult.pdispVal->QueryInterface(IID_TO_PPV(IDANumber, ppbvrRet));
    VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA number");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
} // GetTIMEProgressNumber

//*****************************************************************************

HRESULT 
CBaseBehavior::GetTIMETimelineBehavior(IDANumber **ppbvrRet)
{
    DASSERT(ppbvrRet != NULL);
    *ppbvrRet = NULL;

    HRESULT hr;
    DISPPARAMS              params;
    VARIANT                 varResult;

    VariantInit(&varResult);

    params.rgvarg                           = NULL;
    params.rgdispidNamedArgs        		= NULL;
    params.cArgs                            = 0;
    params.cNamedArgs                       = 0;
/*
    IDispatch *pdispDABehavior				=NULL;

    hr = CUtils::FindTimeBehavior( m_pHTMLElement, &pdispDABehavior );
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to find the time da behavior" );
    }
        
    hr = CallInvokeOnDispatch(pdispDABehavior,
    							 L"TimelineBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);
    ReleaseInterface( pdispDABehavior );
 */

 	hr = CallInvokeOnHTMLElement(m_pHTMLElement,
 								 L"TimelineBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);
    

    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in GetTIMETimelineNumber");
                return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDANumber
    // TODO: coerce to IDips?
    DASSERT(varResult.vt = VT_DISP);
    hr = varResult.pdispVal->QueryInterface(IID_TO_PPV(IDANumber, ppbvrRet));
        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA number");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
} // GetTIMETimelineNumber

//*****************************************************************************

HRESULT 
CBaseBehavior::GetTIMEBooleanBehavior(IDABoolean **ppbvrRet)
{
    DASSERT(ppbvrRet != NULL);
    *ppbvrRet = NULL;

    HRESULT hr;
    DISPPARAMS              params;
    VARIANT                 varResult;

    VariantInit(&varResult);

    params.rgvarg                           = NULL;
    params.rgdispidNamedArgs        		= NULL;
    params.cArgs                            = 0;
    params.cNamedArgs                       = 0;
/*
    IDispatch *pdispDABehavior				= NULL;

    hr = CUtils::FindTimeBehavior( m_pHTMLElement, &pdispDABehavior );
    if( FAILED( hr ) )
    {
    	DPF_ERR("could not find the time da behavior" );
    	return hr;
    }
        
    hr = CallInvokeOnDispatch(pdispDABehavior,
                                 L"OnOffBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);

	ReleaseInterface( pdispDABehavior );
*/

	hr = CallInvokeOnDispatch(m_pHTMLElement,
                                 L"OnOffBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);

	
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in GetTIMEBooleanBehavior");
        return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDANumber
    // TODO: coerce to IDips?
    DASSERT(varResult.vt == VT_DISP);
    hr = varResult.pdispVal->QueryInterface(IID_TO_PPV(IDABoolean, ppbvrRet));
        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA boolean in GetTIMEBooleanBehavior");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
} // GetTIMEBooleanBehavior

//*****************************************************************************

HRESULT 
CBaseBehavior::CallInvokeOnHTMLElement(IHTMLElement *pElement,
                                       LPWSTR lpProperty, 
                                       WORD wFlags,
                                       DISPPARAMS *pdispParms,
                                       VARIANT *pvarResult)
{
    DASSERT(lpProperty != NULL);
    DASSERT(pdispParms != NULL);
    DASSERT(pvarResult != NULL);

    DASSERT(pElement != NULL);

    HRESULT hr;
        IDispatch *pDisp = NULL;
        hr = pElement->QueryInterface(IID_IDispatch, (void **)(&pDisp));
        if (FAILED(hr))
        {
        DPF_ERR("Error QI'ing IHTMLElement for IDispatch failed in CallInvokeOnHTMLElement");
                return SetErrorInfo(hr);
        }

    DISPID dispid;   
    hr = pDisp->GetIDsOfNames(IID_NULL, 
                              &lpProperty, 
                              1,
                              LOCALE_SYSTEM_DEFAULT, 
                              &dispid);    

        if (FAILED(hr))
        {
        DPF_ERR("Error calling GetIDsOFNames in CallInvokeOnHTMLElement");
        LMTRACE(L"The Error was %x\n", hr );
                ReleaseInterface(pDisp);
                return hr;
        }

        EXCEPINFO               excepInfo;
        UINT                    nArgErr;
        
        hr = pDisp->Invoke(dispid,
                                           IID_NULL,
                                           LOCALE_USER_DEFAULT,
                                           wFlags,
                                           pdispParms,
                                           pvarResult,
                                           &excepInfo,
                                           &nArgErr );
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling Invoke on DA TIME behavior in CallInvokeOnHTMLElement");
        VariantClear(pvarResult);
                return hr;
    }

    return S_OK;
} // CallInvokeOnHTMLElement

//*****************************************************************************

// TODO (markhal): Shouldn't the above method call this?
HRESULT 
CBaseBehavior::CallInvokeOnDispatch(IDispatch *pDisp,
                                    LPWSTR lpProperty, 
                                    WORD wFlags,
                                    DISPPARAMS *pdispParms,
                                    VARIANT *pvarResult)
{
    DASSERT(lpProperty != NULL);
    DASSERT(pdispParms != NULL);
    DASSERT(pvarResult != NULL);
        DASSERT(pDispatch  != NULL);

        HRESULT hr = E_FAIL;

    DISPID dispid;   
    hr = pDisp->GetIDsOfNames(IID_NULL, 
                              &lpProperty, 
                              1,
                              LOCALE_SYSTEM_DEFAULT, 
                              &dispid);    

        if (FAILED(hr))
        {
        DPF_ERR("Error calling GetIDsOFNames in Dispatch");
                return hr;
        }

        EXCEPINFO               excepInfo;
        UINT                    nArgErr;
        
        hr = pDisp->Invoke(dispid,
                                           IID_NULL,
                                           LOCALE_USER_DEFAULT,
                                           wFlags,
                                           pdispParms,
                                           pvarResult,
                                           &excepInfo,
                                           &nArgErr );
    if (FAILED(hr))
    {
        DPF_ERR("Error calling Invoke on Dispatch");
        VariantClear(pvarResult);
                return hr;
    }

    return S_OK;
} // CallInvokeOnDispatch

//*****************************************************************************

// TODO (markhal): I think we're going to take animates out of all but the actor
HRESULT 
CBaseBehavior::SetAnimatesProperty(VARIANT varAnimates)
{
    HRESULT hr = VariantCopy(&m_varAnimates, &varAnimates);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in SetAnimatesProperty");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // SetAnimatesProperty

//*****************************************************************************

// TODO (markhal): I think we're going to take animates out of all but the actor
HRESULT 
CBaseBehavior::GetAnimatesProperty(VARIANT *pvarAnimates)
{
    HRESULT hr = VariantCopy(pvarAnimates, &m_varAnimates);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in GetAnimatesProperty");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // GetAnimatesProperty

//*****************************************************************************

// TODO (markhal): This should not be available to behaviors.  What should happen is
// that when buildBehaviorFragments is called we stash the actor IDispatch and calls such
// as this reference that as appropriate, and change names to reflect what's truly happening
HRESULT
CBaseBehavior::GetElementToAnimate(IHTMLElement **ppElementReturn)
{
    HRESULT hr;
    DASSERT(ppElementReturn != NULL);
    *ppElementReturn = NULL;

	IHTMLElement * pActorElement = NULL;
	
	hr = GetAnimatedParentElement(&pActorElement);
	if (FAILED(hr))
	{
		DPF_ERR("Error obtaining animated parent element from HTML element");
		return SetErrorInfo(hr);
	}

	VARIANT	varAnimates;
	VariantInit(&varAnimates);
	hr = pActorElement->getAttribute( BEHAVIOR_PROPERTY_ANIMATES, 0, &varAnimates );
	
    if (FAILED(hr))
    {
		*ppElementReturn = pActorElement;
		return S_OK;
	}
	
	hr = CUtils::InsurePropertyVariantAsBSTR(&varAnimates);
	if ((FAILED(hr)) || (wcslen(varAnimates.bstrVal) == 0))
	{
		*ppElementReturn = pActorElement;
		return S_OK;
	}
		
	ReleaseInterface(pActorElement);
		
	VARIANT varIndex;
	VariantInit(&varIndex);
	varIndex.vt = VT_I4;
	varIndex.intVal = 0;
    
	IDispatch *pDisp = NULL;
	hr = m_pHTMLElement->get_document(&pDisp);
	if (FAILED(hr))
	{
		DPF_ERR("Error obtaining document from HTML element");
		return SetErrorInfo(hr);
	}
	IHTMLDocument2 *pDocument;
	hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDocument));
	ReleaseInterface(pDisp);
	if (FAILED(hr))
	{
		DPF_ERR("Error getting a HTMLDocument from IDispatch");
		return SetErrorInfo(hr);
	}
	IHTMLElementCollection *pCollection;
	hr = pDocument->get_all(&pCollection);
	ReleaseInterface(pDocument);
	if (FAILED(hr))
	{
		DPF_ERR("Error obtaining document's all collection");
		return SetErrorInfo(hr);
	}
	DASSERT(pCollection != NULL);
	hr = pCollection->item(varAnimates, varIndex, &pDisp);
	ReleaseInterface(pCollection);
	if (FAILED(hr))
	{
		DPF_ERR("Error searching for item in collection");
		return SetErrorInfo(hr);
	}
	if (pDisp != NULL)
	{
		IHTMLElement *pAnimateElement = NULL;

		hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLElement, ppElementReturn));
		ReleaseInterface(pDisp);
		if (FAILED(hr))
		{
			DPF_ERR("Error obtaining HTMLElement from IDispatch");
			return SetErrorInfo(hr);
		}
	}
	else
	{
		// TODO we can not find the element we are animating????
		// TODO: get a better error string here
		DPF_ERR("Error: animate attribute does not point to valid element");
		return SetErrorInfo(E_FAIL);
	}

    return S_OK;
} // GetElementToAnimate

//*****************************************************************************

// TODO (markhal): I believe we can do without this
HRESULT
CBaseBehavior::GetAnimatedParentElement(IHTMLElement **ppElementReturn)
{

		if( m_pelemAnimatedParent != NULL )
		{
			(*ppElementReturn) = m_pelemAnimatedParent;
			(*ppElementReturn)->AddRef();
			return S_OK;
		}
		
        // Need to skip over actions and sequences and the like.
        // Currently this is pretty simplistic, since we're waiting for the actor code
        IHTMLElement *pCurrElement = m_pHTMLElement;
        pCurrElement->AddRef();

        while (pCurrElement != 0)
        {
                HRESULT hr = pCurrElement->get_parentElement(ppElementReturn);
                ReleaseInterface(pCurrElement);

                if (FAILED(hr))
                {
                        DPF_ERR("Error obtaining parent element");
                        return SetErrorInfo(hr);
                }
                if( (*ppElementReturn) == NULL )
                {
                	DPF_ERR("Got a null parent for the element" );
                	return E_FAIL;
                }

                BSTR bstrTagName;
                hr = (*ppElementReturn)->get_tagName(&bstrTagName);
                int compareResult = _wcsicmp(L"action", bstrTagName);
                SysFreeString(bstrTagName);

                if ( compareResult != 0)
                {
                        // Found a non-action
                        return S_OK;
                }

                pCurrElement = *ppElementReturn;
        }

        return E_FAIL;
}

//*****************************************************************************

// TODO (markhal): This belongs in actor only
HRESULT 
CBaseBehavior::GetIdOfAnimatedElement(VARIANT *pvarId)
{
    HRESULT hr;

    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varAnimates);
    if ((SUCCEEDED(hr)) && (wcslen(m_varAnimates.bstrVal) > 0))
    {
        hr = VariantCopy(pvarId, &m_varAnimates);
    }
    else
    {
        // we need to get the id from our animated parent
		IHTMLElement *pAnimatedElement;
		hr = GetElementToAnimate(&pAnimatedElement);
		if (FAILED(hr))
		{
			DPF_ERR("Error obtaining animated parent element from HTML element");
			return SetErrorInfo(hr);
		}

		hr = pAnimatedElement->getAttribute(L"id", 0, pvarId);

		if ( FAILED(hr) || pvarId->vt != VT_BSTR || pvarId->bstrVal == 0 || SysStringLen(pvarId->bstrVal) == 0)
		{
			// id is not defined on animated parent yet, need to assign it a unique id
			IHTMLUniqueName *pUnique;

			hr = pAnimatedElement->QueryInterface(IID_IHTMLUniqueName, (void **)(&pUnique));

			if ( SUCCEEDED(hr) && pUnique != 0 )
			{
				BSTR uniqueID;
				hr = pUnique->get_uniqueID( &uniqueID );
				ReleaseInterface(pUnique);

				if (SUCCEEDED(hr))
				{
					hr = pAnimatedElement->put_id(uniqueID);

					if (SUCCEEDED(hr))
					{
						VariantClear(pvarId);
						V_VT(pvarId) = VT_BSTR;
						V_BSTR(pvarId) = uniqueID;
					}
					else
						SysFreeString(uniqueID);
				}
			}
		}

		ReleaseInterface(pAnimatedElement);
                
    }

    if (FAILED(hr))
    {
        DPF_ERR("Error getting Id of element to animate in GetIdOfAnimatedElement");
        return SetErrorInfo(hr);
    }

    return S_OK;
} // GetIdOfAnimatedElement

//*****************************************************************************

// TODO (markhal): This goes away when all behaviors talk to the actor
HRESULT
CBaseBehavior::ApplyImageBehaviorToAnimationElement(IDAImage *pbvrImage)
{
        DASSERT(pbvrImage != NULL);

        HRESULT hr;

        IHTMLElement *pAnimatedElement;
        hr = GetElementToAnimate(&pAnimatedElement);
        if (FAILED(hr))
        {
        DPF_ERR("Error getting element to animate");
        return SetErrorInfo(hr);
        }

        hr = AddImageToTIME(pAnimatedElement, pbvrImage, true);
        ReleaseInterface(pAnimatedElement);

        if (FAILED(hr))
        {
        DPF_ERR("Error adding image to TIME");
        return SetErrorInfo(hr);
        }

        return S_OK;
}

//*****************************************************************************

// TODO (markhal): This goes away when all behaviors talk to actor
HRESULT
CBaseBehavior::ApplyColorBehaviorToAnimationElement(IDAColor *pbvrColor,
                                                    WCHAR *pwzProperty)
{
    DASSERT(pbvrColor != NULL);
    DASSERT(pwzProperty != NULL);

    HRESULT hr;

    VARIANT var;
    VariantInit(&var);
    hr = GetIdOfAnimatedElement(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting id of element to animate");
        return hr;
    }
    // change the type of this variant to a bstr
    VARIANT varBstr;
    VariantInit(&varBstr);
    hr = VariantChangeTypeEx(&varBstr, 
                           &var,
                           LCID_SCRIPTING,
                           VARIANT_NOUSEROVERRIDE,
                           VT_BSTR);
    VariantClear(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error changing variant type to bstr in ApplyColorBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
        CComBSTR sProp;
    sProp += varBstr.bstrVal;
    VariantClear(&varBstr);
        sProp += L".";
    sProp += pwzProperty;

    // set this property to be animated on the color
    IDA2Color *pbvrColor2;
    hr = pbvrColor->QueryInterface(IID_TO_PPV(IDA2Color, &pbvrColor2));
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing da color for IDA2Color in ApplyColorBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    IDA2Color *pbvrAnimatesProperty;

        hr = pbvrColor2->AnimateProperty(sProp, L"JScript", 0, 0.02, &pbvrAnimatesProperty);
    ReleaseInterface(pbvrColor2);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling AnimateProperty in ApplyColorBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    hr = AddBehaviorToTIME(pbvrAnimatesProperty);
    ReleaseInterface(pbvrAnimatesProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding a DA behavior to the TIME behavior");
        return hr;
    }
    return S_OK;
} // ApplyColorBehaviorToAnimationElement

//*****************************************************************************

// TODO (markhal): This goes away when all behaviors talk to actor
HRESULT
CBaseBehavior::ApplyNumberBehaviorToAnimationElement(IDANumber *pbvrNumber,
                                                     WCHAR *pwzProperty)
{
    DASSERT(pbvrNumber != NULL);
    DASSERT(pwzProperty != NULL);

    HRESULT hr;

    VARIANT var;
    VariantInit(&var);
    hr = GetIdOfAnimatedElement(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting id of element to animate");
        return hr;
    }
    // change the type of this variant to a bstr
    VARIANT varBstr;
    VariantInit(&varBstr);
    hr = VariantChangeTypeEx(&varBstr, 
                           &var,
                           LCID_SCRIPTING,
                           VARIANT_NOUSEROVERRIDE,
                           VT_BSTR);
    VariantClear(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error changing variant type to bstr in ApplyNumberBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
        CComBSTR sProp;
    sProp += varBstr.bstrVal;
    VariantClear(&varBstr);
        sProp += L".";
    sProp += pwzProperty;

    IDANumber *pbvrAnimatesProperty;
        hr = pbvrNumber->AnimateProperty(sProp, L"JScript", 0, 0.02, &pbvrAnimatesProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling AnimateProperty in ApplyNumberBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    hr = AddBehaviorToTIME(pbvrAnimatesProperty);
    ReleaseInterface(pbvrAnimatesProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding a DA behavior to the TIME behavior");
        return hr;
    }

    return S_OK;
} // ApplyNumberBehaviorToAnimationElement

//*****************************************************************************

// TODO (markhal): This goes away when all behaviors talk to actor
HRESULT
CBaseBehavior::ApplyStringBehaviorToAnimationElement(IDAString *pbvrString,
                                                     WCHAR *pwzProperty)
{
    DASSERT(pbvrString != NULL);
    DASSERT(pwzProperty != NULL);

    HRESULT hr;

    VARIANT var;
    VariantInit(&var);
    hr = GetIdOfAnimatedElement(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting id of element to animate");
        return hr;
    }
    // change the type of this variant to a bstr
    VARIANT varBstr;
    VariantInit(&varBstr);
    hr = VariantChangeTypeEx(&varBstr, 
                           &var,
                           LCID_SCRIPTING,
                           VARIANT_NOUSEROVERRIDE,
                           VT_BSTR);
    VariantClear(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error changing variant type to bstr in ApplyStringBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
        CComBSTR sProp;
    sProp += varBstr.bstrVal;
    VariantClear(&varBstr);
        sProp += L".";
    sProp += pwzProperty;

    IDAString *pbvrAnimatesString;
        hr = pbvrString->AnimateProperty(sProp, L"JScript", 0, 0.02, &pbvrAnimatesString);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling AnimateProperty in ApplyStringBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    hr = AddBehaviorToTIME(pbvrAnimatesString);
    ReleaseInterface(pbvrAnimatesString);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding a DA behavior to the TIME behavior");
        return hr;
    }

    return S_OK;
} // ApplyStringBehaviorToAnimationElement

//*****************************************************************************

// TODO (markhal): This goes away when all behaviors talk to actor
HRESULT 
CBaseBehavior::ApplyEffectBehaviorToAnimationElement(IUnknown *pbvrUnk, 
                                                     IDABehavior **ppbvrInputs,
                                                     long cInputs)
{
    DASSERT(pbvrUnk != NULL);

    HRESULT hr;

    IHTMLElement *pAnimatedElement;
    hr = GetElementToAnimate(&pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting element to animate");
        return hr;
    }
    // get the progress from our time element
    IDANumber *pbvrProgress;
    hr = GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting progress behavior from time");
        ReleaseInterface(pAnimatedElement);
        return SetErrorInfo(hr);
    }
    IDADXTransformResult *ptransResult;

    hr = m_pDAStatics->ApplyDXTransformEx(pbvrUnk,
                                          cInputs,
                                          ppbvrInputs,
                                          pbvrProgress,
                                          &ptransResult);
    ReleaseInterface(pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error applying transform to image");
        ReleaseInterface(pAnimatedElement);
        return SetErrorInfo(hr);
    }

    IDABehavior *pbvrOutput;
    hr = ptransResult->get_OutputBvr(&pbvrOutput);
    ReleaseInterface(ptransResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting output behavior from transfrom");
        ReleaseInterface(pAnimatedElement);
        return SetErrorInfo(hr);
    }
    IDAImage *pbvrFinalImage;
    
    hr = pbvrOutput->QueryInterface(IID_TO_PPV(IDAImage, &pbvrFinalImage));
    ReleaseInterface(pbvrOutput);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing transform output for DA image");
        return SetErrorInfo(hr);
    }

    hr = AddImageToTIME(pAnimatedElement, pbvrFinalImage, true);
    ReleaseInterface(pAnimatedElement);
    ReleaseInterface(pbvrFinalImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding image to TIME in ApplyEffectBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // ApplyEffectBehaviorToAnimationElement

//*****************************************************************************
// TODO (markhal): This goes away when all behaviors talk to actor
HRESULT
CBaseBehavior::ApplyRotationBehaviorToAnimationElement(IDANumber *pbvrNumber,
                                                     WCHAR *pwzProperty)
{
    // ultimately, this will be in the actor object, but lets get
    // it going for testing purposes

    DASSERT(pbvrNumber != NULL);
    DASSERT(pwzProperty != NULL);

    HRESULT hr;

    IHTMLElement *pAnimatedElement;


    IDATransform2 *pRotationTransform;
    hr = CDAUtils::BuildRotationTransform2(m_pDAStatics, pbvrNumber, &pRotationTransform);
    if (FAILED(hr))
    {
        DPF_ERR("Error building transform2 from rotation");
        return SetErrorInfo(hr);
    }

    hr = GetElementToAnimate(&pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting element to animate");
        ReleaseInterface(pRotationTransform);
        return hr;
    }
    IDAImage *pbvrOriginalImage;
    hr = GetTIMEImageBehaviorFromElement(pAnimatedElement,
                                         &pbvrOriginalImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting original image form HTML element");
        ReleaseInterface(pAnimatedElement);
        ReleaseInterface(pRotationTransform);
        return SetErrorInfo(hr);
    }

    // apply the transform to the image
    IDAImage *pbvrRotatedImage;
    hr = pbvrOriginalImage->Transform(pRotationTransform, &pbvrRotatedImage);
    ReleaseInterface(pRotationTransform);
    ReleaseInterface(pbvrOriginalImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error transforming image in ApplyRotationBehaviorToAnimationElement");
        ReleaseInterface(pAnimatedElement);
        return SetErrorInfo(hr);
    }
    hr = AddImageToTIME(pAnimatedElement, pbvrRotatedImage, true);
    ReleaseInterface(pAnimatedElement);
    ReleaseInterface(pbvrRotatedImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding image to TIME in ApplyRotationBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // ApplyRotationBehaviorToAnimationElement

//*****************************************************************************
// TODO (markhal): This won't be necessary when all behaviors talk to actor (no notion of original)
HRESULT
CBaseBehavior::BuildTIMEInterpolatedNumber(float flFrom,
                                           float flTo,
                                           float flOriginal,
                                           IDANumber **ppbvrReturn)
{
    HRESULT hr;

    IDANumber *pbvrProgress;
    hr = GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Unable to access progress value from TIME behavior");
        return hr;
    }
    IDANumber *pbvrInterpolatedValue;
    hr = CDAUtils::TIMEInterpolateNumbers(m_pDAStatics, 
                                          flFrom, 
                                          flTo, 
                                          pbvrProgress, 
                                          &pbvrInterpolatedValue);

    ReleaseInterface(pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error interpolating angle in BuildTIMEInterpolatedNumber");
        return hr;
    }

    IDANumber *pbvrOriginalValue;
    hr = CDAUtils::GetDANumber(m_pDAStatics,
                               flOriginal,
                               &pbvrOriginalValue);

    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number from static values");
        ReleaseInterface(pbvrInterpolatedValue);
        return SetErrorInfo(hr);
    }
    IDABoolean *pbvrBoolean;
    hr = GetTIMEBooleanBehavior(&pbvrBoolean);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting TIME boolean");
        ReleaseInterface(pbvrInterpolatedValue);
        ReleaseInterface(pbvrOriginalValue);
        return SetErrorInfo(hr);
    }
    IDABehavior *pbvrFinalBehavior;
    hr = SafeCond(GetDAStatics(),
                  pbvrBoolean, 
                  pbvrInterpolatedValue,
                  pbvrOriginalValue,
                  &pbvrFinalBehavior);
    ReleaseInterface(pbvrBoolean);
    ReleaseInterface(pbvrInterpolatedValue);
    ReleaseInterface(pbvrOriginalValue);
    if (FAILED(hr))
    {
        DPF_ERR("Error building DA conditional in BuildTIMEInterpolatedNumber");
        return SetErrorInfo(hr);
    }
    hr = pbvrFinalBehavior->QueryInterface(IID_TO_PPV(IDANumber, ppbvrReturn));
    ReleaseInterface(pbvrFinalBehavior);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing DA behavior for DA number in BuildTIMEInterpolatedNumber");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // BuildTIMEInterpolatedNumber

//*****************************************************************************

HRESULT
CBaseBehavior::BuildTIMEInterpolatedNumber(float flFrom,
                                           float flTo,
                                           IDANumber **ppbvrReturn)
{
    HRESULT hr;

    IDANumber *pbvrProgress;
    hr = GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Unable to access progress value from TIME behavior");
        return hr;
    }
    hr = CDAUtils::TIMEInterpolateNumbers(m_pDAStatics, 
                                          flFrom, 
                                          flTo, 
                                          pbvrProgress, 
                                          ppbvrReturn);

    ReleaseInterface(pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error interpolating angle in BuildTIMEInterpolatedNumber");
        return hr;
    }

    return S_OK;
} // BuildTIMEInterpolatedNumber

HRESULT
CBaseBehavior::BuildTIMEInterpolatedNumber(IDANumber *pFrom,
										   IDANumber *pTo,
										   IDANumber **ppResult)
{
    HRESULT hr;

	IDANumber *pDiff;
	hr = GetDAStatics()->Sub(pTo, pFrom, &pDiff);
	if (FAILED(hr))
		return hr;

    IDANumber *pProgress;
    hr = GetTIMEProgressNumber(&pProgress);
	if (FAILED(hr))
	{
		ReleaseInterface(pDiff);
		return hr;
	}

	IDANumber *pFraction;
	hr = GetDAStatics()->Mul(pProgress, pDiff, &pFraction);
	ReleaseInterface(pProgress);
	ReleaseInterface(pDiff);
	if (FAILED(hr))
		return hr;

	hr = GetDAStatics()->Add(pFrom, pFraction, ppResult);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

/**
* Asks the actor for an image representing the rendered element bits
*/
HRESULT 
CBaseBehavior::GetImageFromActor(IDispatch   *pActorDisp,
                                                                 IDAImage        **ppImage)
{
        // TODO (markhal): The call on the actor is now more generic - it will get
        // a behavior from any track.  At some point we might want to replace this method
        // with a more generic counterpart.  Currently I'll just make it work for image.
    DASSERT(ppImage != NULL);
    *ppImage = NULL;

    HRESULT hr;
        DISPPARAMS              params;
        VARIANT                 varResult;
    VARIANT         rgvarInput[3];
        VariantInit(&varResult);
        VariantInit(&rgvarInput[0]);
        VariantInit(&rgvarInput[1]);
        VariantInit(&rgvarInput[2]);

        params.rgvarg                           = rgvarInput;
        params.rgdispidNamedArgs        = NULL;
        params.cArgs                            = 3;
        params.cNamedArgs                       = 0;
        
    rgvarInput[2].vt = VT_BSTR;
    rgvarInput[2].bstrVal = ::SysAllocString(L"image");

    rgvarInput[1].vt = VT_UI4;
    rgvarInput[1].intVal = e_Intermediate;

    rgvarInput[0].vt = VT_UI4;
    rgvarInput[0].intVal = e_Image;

    hr = CallInvokeOnDispatch(   pActorDisp,
                                 L"getActorBehavior", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnDispatch");
                return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDAImage
    hr = VariantChangeType(&varResult, &varResult, 0, VT_UNKNOWN);
        if (FAILED(hr))
        {
                DPF_ERR("Failed to get an IUnknown");
                return SetErrorInfo(hr);
        }

    hr = V_UNKNOWN(&varResult)->QueryInterface(IID_TO_PPV(IDAImage, ppImage));
        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA Image");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
}

HRESULT 
CBaseBehavior::GetBvrFromActor(IDispatch       *pActorDisp,
							   WCHAR		   *pwzProperty,
							   ActorBvrFlags	eFlags,
							   ActorBvrType		eType,
							   IDABehavior    **ppResult)
{
    DASSERT(ppResult != NULL);
    *ppResult = NULL;

    HRESULT hr;
    DISPPARAMS              params;
    VARIANT                 varResult;
    VARIANT         rgvarInput[3];
    VariantInit(&varResult);
    VariantInit(&rgvarInput[0]);
    VariantInit(&rgvarInput[1]);
    VariantInit(&rgvarInput[2]);

    params.rgvarg                           = rgvarInput;
    params.rgdispidNamedArgs                = NULL;
    params.cArgs                            = 3;
    params.cNamedArgs                       = 0;
    
	BSTR prop = ::SysAllocString(pwzProperty);
    rgvarInput[2].vt = VT_BSTR;
    rgvarInput[2].bstrVal = prop;

    rgvarInput[1].vt = VT_UI4;
    rgvarInput[1].intVal = eFlags;

    rgvarInput[0].vt = VT_UI4;
    rgvarInput[0].intVal = eType;

    hr = CallInvokeOnDispatch(   pActorDisp,
                                 L"getActorBehavior", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);
	::SysFreeString(prop);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnDispatch");
                return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDABehavior
    hr = VariantChangeType(&varResult, &varResult, 0, VT_UNKNOWN);
    if (FAILED(hr))
    {
            DPF_ERR("Failed to get an IUnknown");
            return SetErrorInfo(hr);
    }

    hr = V_UNKNOWN(&varResult)->QueryInterface(IID_TO_PPV(IDABehavior, ppResult));
    VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA Behavior");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
}

//*****************************************************************************

/**
* Passes the given behavior/property/flags/type to the actor
*/
HRESULT 
CBaseBehavior::AttachBehaviorToActor(IDispatch   *pActorDisp,
                                                                         IDABehavior *pbvrAttach,
                                     BSTR        bstrProperty,
                                     ActorBvrFlags  eFlags,
                                     ActorBvrType   eType)
{

    HRESULT                     hr;
        DISPPARAMS              params;
        VARIANT                 varResult;
    VARIANT         rgvarInput[6];

    IDABoolean *pbvrBool;

    hr = GetTIMEBooleanBehavior(&pbvrBool);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining boolean from TIME");
        return hr;
    }

	IDANumber *pTimeline = NULL;
	hr = GetTIMETimelineBehavior(&pTimeline);
	if (FAILED(hr))
	{
		ReleaseInterface(pbvrBool);
		return hr;
	}


    VariantInit(&varResult);
    VariantInit(&rgvarInput[0]);
    VariantInit(&rgvarInput[1]);
    VariantInit(&rgvarInput[2]);
    VariantInit(&rgvarInput[3]);
    VariantInit(&rgvarInput[4]);
	VariantInit(&rgvarInput[5]);

    params.rgvarg                           = rgvarInput;
    params.rgdispidNamedArgs        = NULL;
    params.cArgs                            = 6;
    params.cNamedArgs                       = 0;
        
    rgvarInput[5].vt = VT_BSTR;
    rgvarInput[5].bstrVal = bstrProperty;

    rgvarInput[4].vt = VT_UNKNOWN;
    rgvarInput[4].punkVal = pbvrAttach;

    rgvarInput[3].vt = VT_UNKNOWN;
    rgvarInput[3].punkVal = pbvrBool;

	rgvarInput[2].vt = VT_UNKNOWN;
	rgvarInput[2].punkVal = pTimeline;

    rgvarInput[1].vt = VT_UI4;
    rgvarInput[1].intVal = eFlags;

    rgvarInput[0].vt = VT_UI4;
    rgvarInput[0].intVal = eType;

    hr = CallInvokeOnDispatch(   pActorDisp,
                                 L"addBehaviorFragment", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);
    ReleaseInterface(pbvrBool);
	ReleaseInterface(pTimeline);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling IDispatch into actor behavior");
        return hr;
    }
    return S_OK;
} // AttachBehaviorToActor

//*****************************************************************************

HRESULT 
CBaseBehavior::AttachBehaviorToActorEx(IDispatch   *pActorDisp,
                                       IDABehavior *pbvrAttach,
                                       BSTR        bstrProperty,
                                       ActorBvrFlags  eFlags,
                                       ActorBvrType   eType,
                                       IDispatch     *pdispBehaviorElement,
                                       long* pCookie)
{
    if( pCookie == NULL )
        return E_INVALIDARG;

    HRESULT                     hr;
    DISPPARAMS              params;
    VARIANT                 varResult;
    VARIANT         rgvarInput[7];

    IDABoolean *pbvrBool;

    hr = GetTIMEBooleanBehavior(&pbvrBool);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining boolean from TIME");
        return hr;
    }

	IDANumber *pTimeline = NULL;
	hr = GetTIMETimelineBehavior(&pTimeline);
	if (FAILED(hr))
	{
		ReleaseInterface(pbvrBool);
		return hr;
	}


    VariantInit(&varResult);
    VariantInit(&rgvarInput[0]);
    VariantInit(&rgvarInput[1]);
    VariantInit(&rgvarInput[2]);
    VariantInit(&rgvarInput[3]);
    VariantInit(&rgvarInput[4]);
	VariantInit(&rgvarInput[5]);
    VariantInit(&rgvarInput[6]);
    
    params.rgvarg                           = rgvarInput;
    params.rgdispidNamedArgs        		= NULL;
    params.cArgs                            = 7;
    params.cNamedArgs                       = 0;


    V_VT(&rgvarInput[6]) = VT_BSTR;
    V_BSTR(&rgvarInput[6]) = bstrProperty;

    V_VT(&rgvarInput[5]) = VT_UNKNOWN;
    V_UNKNOWN(&rgvarInput[5]) = pbvrAttach;

    V_VT(&rgvarInput[4]) = VT_UNKNOWN;
    V_UNKNOWN(&rgvarInput[4]) = pbvrBool;

	V_VT(&rgvarInput[3]) = VT_UNKNOWN;
	V_UNKNOWN(&rgvarInput[3]) = pTimeline;

    V_VT(&rgvarInput[2]) = VT_UI4;
    V_UI4(&rgvarInput[2]) = eFlags;

    V_VT(&rgvarInput[1]) = VT_UI4;
    V_UI4(&rgvarInput[1]) = eType;

    V_VT(&rgvarInput[0]) = VT_DISPATCH;
    V_DISPATCH(&rgvarInput[0]) = pdispBehaviorElement;

    hr = CallInvokeOnDispatch(   pActorDisp,
                                 L"addBehaviorFragmentEx", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);
    ReleaseInterface(pbvrBool);
	ReleaseInterface(pTimeline);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling IDispatch into actor behavior");
        return hr;
    }

    if( V_VT(&varResult) != VT_I4 )
    {
        hr = ::VariantChangeTypeEx( &varResult, &varResult, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4 );
        if( FAILED(hr) )
        {
               DPF_ERR("Failed to convert return value to I4");
               return hr;
        }
    }

    (*pCookie) = V_I4(&varResult);
    ::VariantClear( &varResult );

    return S_OK;
} // AttachBehaviorToActorEx

//*****************************************************************************

HRESULT
CBaseBehavior::RemoveBehaviorFromActor( IDispatch *pActorDisp, long cookie )
{
    HRESULT                     hr;
    DISPPARAMS              params;
    VARIANT                 varResult;
    VARIANT                 varInput;

    VariantInit( &varResult );
    VariantInit( &varInput );

    V_VT(&varInput) = VT_I4;
    V_I4(&varInput) = cookie;

    params.rgvarg                           = &varInput;
    params.rgdispidNamedArgs                = NULL;
    params.cArgs                            = 1;
    params.cNamedArgs                       = 0;

    hr = CallInvokeOnDispatch( pActorDisp,
                               L"removeBehaviorFragment",
                               DISPATCH_METHOD,
                               &params,
                               &varResult);
    if( FAILED( hr ) )
    {
        DPF_ERR("Failed to invoke removeBehaviorFragment on actor disp" );
        return hr;
    }

    VariantClear( &varResult );

    return hr;
}

//*****************************************************************************

HRESULT
CBaseBehavior::RemoveBehaviorFromActor( long cookie )
{
	HRESULT hr = S_OK;
	IHTMLElement* pelemActor = NULL;
	IDispatch* pdispActorElem = NULL;

	
	hr = GetAnimatedParentElement( &pelemActor );
	CheckHR( hr, "Failed to find animated parent element", end );

	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispActorElem ) );
	CheckHR( hr, "QI for IDispatch on the behavior element failed", end );

	hr = RemoveBehaviorFromActor( pelemActor, cookie );

end:
	ReleaseInterface( pelemActor );
	ReleaseInterface( pdispActorElem );
	
	return hr;
}

//*****************************************************************************

HRESULT 
CBaseBehavior::CheckElementForBehaviorURN(IHTMLElement *pElement, WCHAR *wzURN, bool *pfReturn)
{
    DASSERT(pElement != NULL);
    DASSERT(wzURN != NULL);
    DASSERT(pfReturn != NULL);

    *pfReturn = false;
    HRESULT hr;
    IHTMLElement2 *pElement2;
    hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
    if (SUCCEEDED(hr) && pElement2 != NULL)
    {
        // get a collection of urns from the element
        IDispatch *pDisp;
        hr = pElement2->get_behaviorUrns(&pDisp);
        ReleaseInterface(pElement2);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting behavior urns from element");
            return SetErrorInfo(hr);
        }
        IHTMLUrnCollection *pUrnCollection;
        hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLUrnCollection, &pUrnCollection));
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting behavior urns from dispatch");
            return SetErrorInfo(hr);
        }
        long cUrns;
        hr = pUrnCollection->get_length(&cUrns);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting behavior urns from dispatch");
            ReleaseInterface(pUrnCollection);
            return SetErrorInfo(hr);
        }
        for (long iUrns = 0; iUrns < cUrns; iUrns++)
        {
            // get the urn from the collection
            BSTR bstrUrn;
            hr = pUrnCollection->item(iUrns, &bstrUrn);
            if (FAILED(hr))
            {
                DPF_ERR("Error getting behavior urns from dispatch");
                ReleaseInterface(pUrnCollection);
                return SetErrorInfo(hr);
            }
            // now compare this urn with our behavior type
            if (bstrUrn != NULL && _wcsicmp(bstrUrn, wzURN) == 0)
            {
                // we have a match. . .get out of here 
                SysFreeString(bstrUrn);
                DPF_ERR("Error getting behavior urns from dispatch");
                ReleaseInterface(pUrnCollection);
                *pfReturn = true;
                return S_OK;

            }
            if (bstrUrn != NULL)
                SysFreeString(bstrUrn);
        }
        ReleaseInterface(pUrnCollection);
    }
    return S_OK;
} // CheckElementForBehaviorURN

//*****************************************************************************

HRESULT
CBaseBehavior::AttachEffectToActor(IDispatch *pActorDisp,
                                   IUnknown *pbvrUnk, 
                                   IDABehavior **ppbvrInputs,
                                   long cInputs,
                                   IDispatch *pdispThis,
                                   long	*pCookie)
{
    DASSERT(pbvrUnk != NULL);

    HRESULT hr;

    // get the progress from our time element
    IDANumber *pbvrProgress;
    hr = GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting progress behavior from time");
        return SetErrorInfo(hr);
    }

    IDADXTransformResult *ptransResult;

    hr = m_pDAStatics->ApplyDXTransformEx(pbvrUnk,
                                          cInputs,
                                          ppbvrInputs,
                                          pbvrProgress,
                                          &ptransResult);
    ReleaseInterface(pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error applying transform to image");
        return SetErrorInfo(hr);
    }

    IDABehavior *pbvrOutput;
    hr = ptransResult->get_OutputBvr(&pbvrOutput);
    ReleaseInterface(ptransResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting output behavior from transfrom");
        return SetErrorInfo(hr);
    }

    IDAImage *pbvrFinalImage;
    
    hr = pbvrOutput->QueryInterface(IID_TO_PPV(IDAImage, &pbvrFinalImage));
    ReleaseInterface(pbvrOutput);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing transform output for DA image");
        return SetErrorInfo(hr);
    }

    hr = AttachBehaviorToActorEx(pActorDisp, pbvrFinalImage, L"image", e_Filter, e_Image, pdispThis, pCookie);
    ReleaseInterface(pbvrFinalImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding image to Actor");
        return SetErrorInfo(hr);
    }
    return S_OK;
}

//*****************************************************************************

HRESULT 
CBaseBehavior::CheckElementForActor( IHTMLElement* pElement, bool *pfActorPresent)
{

    HRESULT hr;

    DASSERT(pfActorPresent != NULL);
    *pfActorPresent = false;

    // What's the best way to insure this exists???
    // For now we will simply check to see if the method
    // we need to add our behaviors to exists, and if not
    // we will return false.

    DASSERT(pElement != NULL);
    hr = CheckElementForBehaviorURN(pElement, DEFAULT_ACTOR_URN, pfActorPresent);
    if (FAILED(hr))
    {
        DPF_ERR("Error detecting if actor exists");
        return hr;
    }
    return S_OK;
} // CheckAnimatedElementForActor

//*****************************************************************************

HRESULT
CBaseBehavior::CheckElementForDA(IHTMLElement* pElement, bool *pfReturn)
{
    HRESULT hr;

    DASSERT(pfReturn != NULL);
    *pfReturn = false;

    // What's the best way to insure this exists???
    // For now we will simply check to see if the method
    // we need to add TIME behaviors exists, and if not
    // we will return false.
    DASSERT(pElement != NULL);

    IDispatch *pDisp = NULL;
    hr = pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDisp));
    if (FAILED(hr))
    {
    DPF_ERR("Error QI'ing IHTMLElement for IDispatch failed");
            return SetErrorInfo(hr);
    }

    DISPID dispid;
    LPWSTR methodName = L"AddDABehavior";
    hr = pDisp->GetIDsOfNames(IID_NULL, 
                              &methodName, 
                              1,
                              LOCALE_SYSTEM_DEFAULT, 
                              &dispid); 
    ReleaseInterface(pDisp);
	
	if (SUCCEEDED(hr))
		*pfReturn = true;

    return S_OK;
}

//*****************************************************************************

HRESULT
CBaseBehavior::AttachDABehaviorsToElement( IHTMLElement *pElement )
{
	if( pElement == NULL )
		return E_INVALIDARG;

	HRESULT hr;
    
    bool fTimeExist;
    bool fTimeDAExist;

    hr = CheckElementForBehaviorURN(pElement, WZ_TIME_REGISTERED_URN, &fTimeExist);
    if (FAILED(hr))
    {
        return hr;
    }

	// REVIEW: we'd like to check for the registered URN, but DA isn't doing this yet.
    hr = CheckElementForDA(pElement, &fTimeDAExist);
    if (FAILED(hr))
    {
        return hr;
    }
    
    if (!fTimeExist || !fTimeDAExist)
    {
        IHTMLElement2 *pElement2;
        hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing HTML element for IHTMLElement2");
            return SetErrorInfo(hr);
        }

        ITIMEFactory *pTimeFactory;
        hr = CoCreateInstance(CLSID_TIMEFactory, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_ITIMEFactory, 
                              (void**)&pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating time factory");
            ReleaseInterface(pElement2);
            return SetErrorInfo(hr);
        }

        // Before we add the TIME behavior, we check to see whether there is
        // a t:timeAction already set on the element
        bool timeActionSet = false;
        VARIANT var;
        VariantInit(&var);
        if (!fTimeExist)
        {
			DISPPARAMS					params;
			params.rgvarg				= NULL;
			params.rgdispidNamedArgs    = NULL;
			params.cArgs                = 0;
			params.cNamedArgs           = 0;
        
			hr = CallInvokeOnHTMLElement(pElement,
										 L"t:timeAction", 
										 DISPATCH_PROPERTYGET,
										 &params,
										 &var);

            if (FAILED(hr) || V_VT(&var) == VT_EMPTY || V_VT(&var) == VT_NULL ||
                (V_VT(&var) == VT_BSTR && V_BSTR(&var) == NULL))
            {
                timeActionSet = false;
            }
            else
                timeActionSet = true;

            VariantClear(&var);
        }
        
        // Risky, and unfun, we need to add a time DA element
        // to the HTML element, hard code this string above
        var.vt = VT_UNKNOWN;
        var.punkVal = pTimeFactory;
        long nCookie;

        // We need to add the da element first in case the element is
        // the body.  If not then the body will have a time element
        // when it should have a time body element
		hr = S_OK;

        if (!fTimeDAExist)
            hr = pElement2->addBehavior(WZ_TIMEDA_URN, &var, &nCookie);

        if (SUCCEEDED(hr) && !fTimeExist)
        {
            hr = pElement2->addBehavior(WZ_TIME_URN, &var, &nCookie);
        }
        
        ReleaseInterface(pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error adding time element to html");
            ReleaseInterface(pElement2);
            return SetErrorInfo(hr);
        }

        // If we added TIME, we need to set timeAction=none,
        // otherwise the element would appear and disappear since timeAction defaults
        // to visibility
        // Only do this if we didn't detect a timeAction attribute already
        if (!fTimeExist && !timeActionSet)
        {
            VARIANT varAction;
            VariantInit(&varAction);
            V_VT(&varAction) = VT_BSTR;
            V_BSTR(&varAction) = ::SysAllocString(L"none");

            BSTR attribName = ::SysAllocString(L"timeAction");

            hr = pElement->setAttribute(attribName, varAction);
            ::SysFreeString(attribName);
            VariantClear(&varAction);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to set timeAction attribute");
                return hr;
            }
        }

		ReleaseInterface( pElement2 );
    }

	return hr;
}

//*****************************************************************************

HRESULT
CBaseBehavior::RequestRebuild( )
{
	//if we are not accepting rebuild requests then just return.
	if( !m_fAcceptRebuildRequests )
		return S_OK;
		
	HRESULT hr = S_OK;

	IHTMLElement *pelemActor = NULL;
	IDispatch *pdispBehaviorElem = NULL;
	
	DISPPARAMS params;
	VARIANT varArgs[1];
	VARIANT varResult;

	::VariantInit( &(varArgs[0]) );
	::VariantInit( &varResult );

	hr = GetAnimatedParentElement( &pelemActor );
	CheckHR( hr, "Failed to find animated parent element", end );



	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispBehaviorElem ) );
	CheckHR( hr, "QI for IDispatch on the behavior element failed", end );
	
	//call requestRebuild( IDispatch *pdispBehaviorElem );
	V_VT( &(varArgs[0]) ) = VT_DISPATCH;
	V_DISPATCH( &(varArgs[0]) ) = pdispBehaviorElem; 

	params.cArgs = 1;
	params.cNamedArgs = 0;
	params.rgdispidNamedArgs = NULL;
	params.rgvarg = varArgs;

	hr = CallInvokeOnHTMLElement( pelemActor, 
								  L"requestRebuild",
								  DISPATCH_METHOD,
								  &params,
								  &varResult );
	CheckHR( hr, "Failed to call invoke on html element for reques rebuild", end );
										

end:
	ReleaseInterface( pelemActor );
	ReleaseInterface( pdispBehaviorElem );

	::VariantClear( &varResult );

	return hr;
}

//*****************************************************************************

HRESULT
CBaseBehavior::CancelRebuildRequests()
{
	HRESULT hr = S_OK;

	IHTMLElement *pelemActor = NULL;
	IDispatch *pdispBehaviorElem = NULL;
	
	DISPPARAMS params;
	VARIANT varArgs[1];
	VARIANT varResult;

	::VariantInit( &(varArgs[0]) );
	::VariantInit( &varResult );

	hr = GetAnimatedParentElement( &pelemActor );
	CheckHR( hr, "Failed to find animated parent element", end );

	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispBehaviorElem ) );
	CheckHR( hr, "QI for IDispatch on the behavior element failed", end );

	//call cancelRebuildRequests( IDispatch *pdispBehaviorElem );
	V_VT( &(varArgs[0]) ) = VT_DISPATCH;
	V_DISPATCH( &(varArgs[0]) ) = pdispBehaviorElem; 

	params.cArgs = 1;
	params.cNamedArgs = 0;
	params.rgdispidNamedArgs = NULL;
	params.rgvarg = varArgs;

	hr = CallInvokeOnHTMLElement( pelemActor, 
								  L"cancelRebuildRequests",
								  DISPATCH_METHOD,
								  &params,
								  &varResult );
	CheckHR( hr, "Failed to call invoke on html element for reques rebuild", end );
										

end:
	ReleaseInterface( pelemActor );
	ReleaseInterface( pdispBehaviorElem );

	::VariantClear( &varResult );

	return hr;
}

//*****************************************************************************


HRESULT 
CBaseBehavior::AttachActorBehaviorToAnimatedElement()
{

    HRESULT hr;
    
    bool fTimeExist;
    bool fTimeDAExist;
    
    IHTMLElement *pElement = NULL;
    hr = GetAnimatedParentElement(&pElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error retrieving element to animate");
        return hr;
    }

    hr = CheckElementForBehaviorURN(pElement, WZ_TIME_REGISTERED_URN, &fTimeExist);
    if (FAILED(hr))
    {
        ReleaseInterface(pElement);
        return hr;
    }

	// REVIEW: we'd like to check for the registered URN, but DA isn't doing this yet.
    hr = CheckElementForDA( pElement, &fTimeDAExist );
    if (FAILED(hr))
    {
        ReleaseInterface(pElement);
        return hr;
    }
    
    if ( !fTimeExist || !fTimeDAExist)
    {
        IHTMLElement2 *pElement2;
        hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing HTML element for IHTMLElement2");
            ReleaseInterface(pElement);
            return SetErrorInfo(hr);
        }

        ITIMEFactory *pTimeFactory;
        hr = CoCreateInstance(CLSID_TIMEFactory, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_ITIMEFactory, 
                              (void**)&pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating time factory");
            ReleaseInterface(pElement);
            ReleaseInterface(pElement2);
            return SetErrorInfo(hr);
        }

        // Before we add the TIME behavior, we check to see whether there is
        // a t:timeAction already set on the element
        bool timeActionSet = false;
        VARIANT var;
        VariantInit(&var);
        if (!fTimeExist)
        {
			DISPPARAMS					params;
			params.rgvarg				= NULL;
			params.rgdispidNamedArgs    = NULL;
			params.cArgs                = 0;
			params.cNamedArgs           = 0;
        
			hr = CallInvokeOnHTMLElement(pElement,
										 L"t:timeAction", 
										 DISPATCH_PROPERTYGET,
										 &params,
										 &var);

            if (FAILED(hr) || V_VT(&var) == VT_EMPTY || V_VT(&var) == VT_NULL ||
                (V_VT(&var) == VT_BSTR && V_BSTR(&var) == NULL))
            {
                timeActionSet = false;
            }
            else
                timeActionSet = true;

            VariantClear(&var);
        }
        
        // Risky, and unfun, we need to add a time DA element
        // to the HTML element, hard code this string above
        var.vt = VT_UNKNOWN;
        var.punkVal = pTimeFactory;
        long nCookie;

        // We need to add the da element first in case the element is
        // the body.  If not then the body will have a time element
        // when it should have a time body element
		hr = S_OK;

        if (!fTimeDAExist)
            hr = pElement2->addBehavior(WZ_TIMEDA_URN, &var, &nCookie);

        if (SUCCEEDED(hr) && !fTimeExist)
        {
            hr = pElement2->addBehavior(WZ_TIME_URN, &var, &nCookie);
        }
        
        ReleaseInterface(pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error adding time element to html");
            ReleaseInterface(pElement);
            ReleaseInterface(pElement2);
            return SetErrorInfo(hr);
        }

        // If we added TIME, we need to set timeAction=none,
        // otherwise the element would appear and disappear since timeAction defaults
        // to visibility
        // Only do this if we didn't detect a timeAction attribute already
        if (!fTimeExist && !timeActionSet)
        {
            VARIANT varAction;
            VariantInit(&varAction);
            V_VT(&varAction) = VT_BSTR;
            V_BSTR(&varAction) = ::SysAllocString(L"none");

            BSTR attribName = ::SysAllocString(L"timeAction");

            hr = pElement->setAttribute(attribName, varAction);
            ::SysFreeString(attribName);
            VariantClear(&varAction);
            if (FAILED(hr))
            {
				ReleaseInterface(pElement);
                DPF_ERR("Failed to set timeAction attribute");
                return hr;
            }
        }

		ReleaseInterface( pElement2 );
    }

    bool fActorExist;
    hr = CheckElementForActor(pElement, &fActorExist);
    if (FAILED(hr))
    {
        DPF_ERR("Error detecting actor");
        return hr;
    }

	ReleaseInterface( pElement );
    // if the actor does not exist, then we need to add it here
    if (!fActorExist)
    {
        // we need to create a factor, then call add behavior on the
        // HTML element that we are animating for both an actor
        // object and a DA TIME object
        IHTMLElement *pElement;
        hr = GetAnimatedParentElement(&pElement);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving element to animate");
            return hr;
        }
        IHTMLElement2 *pElement2;
        hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
        ReleaseInterface(pElement);
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing HTML element for IHTMLElement2");
            return SetErrorInfo(hr);
        }

        ICrBehaviorFactory *pBehaviorFactory = NULL;
        hr = CoCreateInstance(CLSID_CrBehaviorFactory, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_ICrBehaviorFactory, 
                              (void**)&pBehaviorFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating behavior factory in AttachActorBehaviorToAnimatedElement");
            ReleaseInterface(pElement2);
            return SetErrorInfo(hr);
        }
        VARIANT var;
        var.vt = VT_UNKNOWN;
        var.punkVal = pBehaviorFactory;

        long nCookie;
        hr = pElement2->addBehavior(WZ_ACTOR_URN, &var, &nCookie);
        ReleaseInterface(pBehaviorFactory);
        ReleaseInterface(pElement2);
        if (FAILED(hr))
        {
            DPF_ERR("Error calling AddBehavior on HTML element");
            return SetErrorInfo(hr);
        }

        // In the debug case insure that this worked
#ifdef DEBUG
		bool fDEBUGActorExists = false;
		IHTMLElement *pDEBUGElement=NULL;
        hr = GetAnimatedParentElement(&pDEBUGElement);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving element to animate in DEBUG CHECK");
            goto debugend;
        }

        hr = CheckElementForActor( pDEBUGElement, &fDEBUGActorExists);
		ReleaseInterface( pDEBUGElement );
        if (FAILED(hr))
        {
            DPF_ERR("Error detecting actor in DEBUG CHECK");
            goto debugend;
        }
        
debugend:

		DASSERT(fDEBUGActorExists);
#endif // DEBUG

    }
    return S_OK;

} // AttachActorBehaviorToAnimatedElement

//*****************************************************************************

HRESULT
CBaseBehavior::GetHTMLElementDispatch( IDispatch **ppdisp )
{
	if( ppdisp == NULL )
		return E_INVALIDARG;

	if( m_pHTMLElement != NULL )
	{
		return m_pHTMLElement->QueryInterface( IID_TO_PPV( IDispatch, ppdisp ) );
	}

	return E_FAIL;
}


//*****************************************************************************

HRESULT 
CBaseBehavior::ApplyRelative2DMoveBehavior(IDATransform2 *pbvrMove, float flOriginalX, float flOriginalY)
{

    HRESULT hr;

    IDAPoint2 *pbvrOrg;

    hr = GetDAStatics()->Point2(flOriginalX, flOriginalY, &pbvrOrg);
    if (FAILED(hr))
    {
        DPF_ERR("error creating DA unit vector");
        return SetErrorInfo(hr);
    }

    return Apply2DMoveBvrToPoint(pbvrMove, pbvrOrg, flOriginalX, flOriginalY);
} // ApplyRelative2DMoveBehavior

//*****************************************************************************

HRESULT 
CBaseBehavior::ApplyAbsolute2DMoveBehavior(IDATransform2 *pbvrMove, float flOriginalX, float flOriginalY)
{
    HRESULT hr;

    IDAPoint2 *pbvrOrg;

    hr = GetDAStatics()->Point2(0.0, 0.0, &pbvrOrg);
    if (FAILED(hr))
    {
        DPF_ERR("error creating DA unit vector");
        return SetErrorInfo(hr);
    }
    return Apply2DMoveBvrToPoint(pbvrMove, pbvrOrg, flOriginalX, flOriginalY);
} // ApplyAbsolute2DMoveBehavior

//*****************************************************************************

HRESULT
CBaseBehavior::Apply2DMoveBvrToPoint(IDATransform2 *pbvrMove, IDAPoint2 *pbvrOrg, float flOriginalX, float flOriginalY)
{
    HRESULT hr = S_OK;

    IDAPoint2 *pbvrTransformedPoint;
    hr = pbvrOrg->Transform(pbvrMove, &pbvrTransformedPoint);
    ReleaseInterface(pbvrOrg);
    if (FAILED(hr))
    {
        DPF_ERR("Error transforming unit vector");
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrTransformedPoint != NULL);
    IDANumber *pbvrPointComponent;
    hr = pbvrTransformedPoint->get_X(&pbvrPointComponent);
    if (FAILED(hr))
    {
        DPF_ERR("error extracting X value from point");
        ReleaseInterface(pbvrTransformedPoint);
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrPointComponent != NULL);

    // we need to conditional in the original position of the element
    IDABoolean *pbvrBool;
    hr = GetTIMEBooleanBehavior(&pbvrBool);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining TIME boolean value");
        ReleaseInterface(pbvrTransformedPoint);
        ReleaseInterface(pbvrPointComponent);
        return hr;
    }

    IDANumber *pbvrNumber;
    hr = CDAUtils::GetDANumber(GetDAStatics(), flOriginalX, &pbvrNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating da number");
        ReleaseInterface(pbvrTransformedPoint);
        ReleaseInterface(pbvrPointComponent);
        ReleaseInterface(pbvrBool);
        return SetErrorInfo(hr);
    }

    IDABehavior *pbvrResult;
    hr = GetDAStatics()->Cond(pbvrBool, pbvrPointComponent, pbvrNumber, &pbvrResult);
    ReleaseInterface(pbvrPointComponent);
    ReleaseInterface(pbvrBool);
    ReleaseInterface(pbvrNumber);

    if (FAILED(hr))
    {
        DPF_ERR("Error creating conditional for number");
        ReleaseInterface(pbvrTransformedPoint);
        return SetErrorInfo(hr);
    }
    hr = pbvrResult->QueryInterface(IID_TO_PPV(IDANumber, &pbvrPointComponent));
    ReleaseInterface(pbvrResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing result for DA number");
        ReleaseInterface(pbvrTransformedPoint);
        return SetErrorInfo(hr);
    }

    hr = ApplyNumberBehaviorToAnimationElement(pbvrPointComponent, L"style.left");
    ReleaseInterface(pbvrPointComponent);
    if (FAILED(hr))
    {
        DPF_ERR("error calling ApplyNumberBehaviorToAnimationElement");
        ReleaseInterface(pbvrTransformedPoint);
        return SetErrorInfo(hr);
    }    

    hr = pbvrTransformedPoint->get_Y(&pbvrPointComponent);
    ReleaseInterface(pbvrTransformedPoint);
    if (FAILED(hr))
    {
        DPF_ERR("error extracting Y value from point");
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrPointComponent != NULL);

    // we need to conditional in the original position of the element
    hr = GetTIMEBooleanBehavior(&pbvrBool);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining TIME boolean value");
        ReleaseInterface(pbvrPointComponent);
        return hr;
    }

    hr = CDAUtils::GetDANumber(GetDAStatics(), flOriginalY, &pbvrNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating da number");
        ReleaseInterface(pbvrPointComponent);
        ReleaseInterface(pbvrBool);
        return SetErrorInfo(hr);
    }

    hr = GetDAStatics()->Cond(pbvrBool, pbvrPointComponent, pbvrNumber, &pbvrResult);
    ReleaseInterface(pbvrPointComponent);
    ReleaseInterface(pbvrBool);
    ReleaseInterface(pbvrNumber);

    if (FAILED(hr))
    {
        DPF_ERR("Error creating conditional for number");
        return SetErrorInfo(hr);
    }
    hr = pbvrResult->QueryInterface(IID_TO_PPV(IDANumber, &pbvrPointComponent));
    ReleaseInterface(pbvrResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing result for DA number");
        return SetErrorInfo(hr);
    }


    hr = ApplyNumberBehaviorToAnimationElement(pbvrPointComponent, L"style.top");
    ReleaseInterface(pbvrPointComponent);
    if (FAILED(hr))
    {
        DPF_ERR("error calling ApplyNumberBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }    
    return S_OK;
} // Apply2DMoveBvrToPoint

//*****************************************************************************

ActorBvrFlags
CBaseBehavior::FlagFromTypeMode(bool relative, VARIANT *pVarType, VARIANT *pVarMode)
{
	return FlagFromTypeMode((relative ? e_RelativeAccum : e_Absolute), pVarType, pVarMode);
}

ActorBvrFlags
CBaseBehavior::FlagFromTypeMode(ActorBvrFlags flags, VARIANT *pVarType, VARIANT *pVarMode)
{
	// Must pass in e_Absolute, e_AbsoluteAccum, or e_RelativeAccum

	if( V_VT(pVarType) == VT_BSTR && V_BSTR(pVarType) != NULL && SysStringLen( V_BSTR(pVarType) ) != 0  )
	{
		// Use type (if set) to change to relative
		if( wcsicmp( V_BSTR(pVarType), BEHAVIOR_TYPE_ABSOLUTE ) == 0 )
		{
			if (flags == e_RelativeAccum)
				flags = e_Absolute;
		}
		else if ( wcsicmp( V_BSTR(pVarType), BEHAVIOR_TYPE_RELATIVE ) == 0 )
		{
			flags = e_RelativeAccum;
		}
	}

	if( V_VT(pVarMode) == VT_BSTR && V_BSTR(pVarMode) != NULL && SysStringLen( V_BSTR(pVarMode) ) != 0  )
	{
		// They've set the mode
		if (wcsicmp( V_BSTR(pVarMode), L"combine") == 0)
		{
			if (flags != e_AbsoluteAccum)
				return e_Relative;
		}
		else if (wcsicmp( V_BSTR(pVarMode), L"reset") == 0)
		{
			if (flags == e_AbsoluteAccum)
				return e_Absolute;
			else if (flags == e_RelativeAccum)
				return e_RelativeReset;
		}
		else if (wcsicmp( V_BSTR(pVarMode), L"accum") == 0)
		{
			if (flags == e_Absolute)
				return e_RelativeAccum;
			else if (flags == e_RelativeReset)
				return e_RelativeAccum;
		}
	}
	
	return flags;
}

//*****************************************************************************

	STDMETHODIMP 
CBaseBehavior::GetClassID(CLSID* pclsid)
{
        if (!pclsid)
                return E_POINTER;
        *pclsid = m_clsid;
        return S_OK;
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
CBaseBehavior::InitNew(void)
{
        return S_OK;
} // InitNew

//*****************************************************************************

//IPersistPropertyBag2 methods
STDMETHODIMP 
CBaseBehavior::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
        if (!pPropBag)
                return E_INVALIDARG;

    HRESULT hr;
    WCHAR **ppElmtPropNames;
    ULONG cProperties;

    hr = GetPropertyBagInfo(&cProperties, &ppElmtPropNames);
    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        DPF_ERR("Error calling GetPropertyBagInfo");
        return hr;
    }

    // Unfortunately Load takes an array of Variants and not
    // Variant pointers.  We therefor need to loop through
    // each one and get the correct property this way.
    for (ULONG iProperties = 0; iProperties < cProperties; iProperties++)
    {
        HRESULT hrres = S_OK;
        PROPBAG2 propbag;
        VARIANT var;
        VariantInit(&var);
        propbag.vt = VT_BSTR;
        propbag.pstrName = ppElmtPropNames[iProperties];
        hr = pPropBag->Read(1,
                            &propbag,
                            pErrorLog,
                            &var,
                            &hrres);
        if (SUCCEEDED(hr))
        {
            DASSERT(VariantFromIndex(iProperties) != NULL);
            hr = VariantCopy(VariantFromIndex(iProperties), &var);
            VariantClear(&var);
            if (FAILED(hr))
            {
                DPF_ERR("Error copying variant");
                return SetErrorInfo(hr);
            }
        }
    }
        return S_OK;
} // Load

//*****************************************************************************

STDMETHODIMP 
CBaseBehavior::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
        if (!pPropBag)
                return E_INVALIDARG;

    if (fClearDirty)
        m_fPropertiesDirty = false;
    // TODO:: Need to use fSaveAllProperties to only save values that have
    // changed
    HRESULT hr;
    WCHAR **ppElmtPropNames;
    ULONG cProperties;

    hr = GetPropertyBagInfo(&cProperties, &ppElmtPropNames);
    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        DPF_ERR("Error calling GetPropertyBagInfo");
        return hr;
    }

    for (ULONG iProperties = 0; iProperties < cProperties; iProperties++)
    {
        PROPBAG2 propbag;

        VARIANT var;
                VariantInit(&var);

        propbag.vt = VT_BSTR;
        propbag.pstrName = ppElmtPropNames[iProperties];
        DASSERT(VariantFromIndex(iProperties) != NULL);
        hr = VariantCopy(&var, VariantFromIndex(iProperties));
        if (FAILED(hr))
        {
            DPF_ERR("Error copying variant");
            return SetErrorInfo(hr);
        }
        if (var.vt != VT_EMPTY && var.vt != VT_NULL)
        {
            hr = pPropBag->Write(1,
                                 &propbag,
                                 &var);
            VariantClear(&var);
            if (FAILED(hr))
            {
                DPF_ERR("Error writing variant");
                return SetErrorInfo(hr);
            }
        }
    }
        return S_OK;
} // Save

//*****************************************************************************

HRESULT
CBaseBehavior::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    m_fPropertiesDirty = true;
    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        CComPtr<IEnumConnections> pEnum;
        hr = pICP->EnumConnections(&pEnum);
        ReleaseInterface(pICP);
        if (FAILED(hr))
        {
            DPF_ERR("Error finding connection enumerator");
            return SetErrorInfo(hr);
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify));
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                DPF_ERR("Error invalid object found in connection enumeration");
                return SetErrorInfo(hr);
            }
            hr = pNotify->OnChanged(dispid);
            ReleaseInterface(pNotify);
            if (FAILED(hr))
            {
                DPF_ERR("Error calling Notify sink's on change");
                return SetErrorInfo(hr);
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
    return S_OK;
} // NotifyPropertyChanged

//*****************************************************************************


HRESULT
CBaseBehavior::SafeCond( IDA2Statics *pstatics, 
				  		 IDABoolean *pdaboolCondition, 
				  		 IDABehavior *pdabvrIfTrue, 
				  		 IDABehavior *pdabvrIfFalse, 
				  		 IDABehavior **ppdabvrResult )
{
	if( pstatics == NULL || 
		pdaboolCondition == NULL || 
		pdabvrIfTrue == NULL || 
		pdabvrIfFalse == NULL ||
		ppdabvrResult == NULL )
		return E_INVALIDARG;
		
	HRESULT hr = S_OK;

	IDABehavior *pdabvrIndex = NULL;
	IDANumber	*pdanumIndex = NULL;
	IDAArray	*pdaarrArray = NULL;
	IDABehavior *rgpdabvr[2] = {NULL, NULL};

	if( m_pdanumZero == NULL )
	{
		hr = pstatics->DANumber( 0.0, &m_pdanumZero );
		CheckHR( hr, "Failed to create a danumber for 0", end );
	}

	if( m_pdanumOne == NULL )
	{
		hr = pstatics->DANumber( 1.0, &m_pdanumOne );
		CheckHR( hr, "Failed to create a danumber for 1", end );
	}

	//create an index that is 0 when pdaboolCondition is false, and 1 when it is true
	hr = pstatics->Cond( pdaboolCondition, m_pdanumZero, m_pdanumOne, &pdabvrIndex );
	CheckHR( hr, "Failed to create a conditional for the index", end);

	hr = pdabvrIndex->QueryInterface( IID_TO_PPV( IDANumber, &pdanumIndex ) );
	CheckHR( hr, "Failed QI for IDANumber on an idabehavior", end );
	
	//create an array behavior with the first element being ifTrue, and the second ifFalse
	rgpdabvr[0] = pdabvrIfTrue;
	rgpdabvr[1] = pdabvrIfFalse;
	hr = pstatics->DAArrayEx( 2, rgpdabvr, &pdaarrArray );
	CheckHR( hr, "Failed to create an array behavior", end );

	//index into the array
	hr = pdaarrArray->NthAnim( pdanumIndex, ppdabvrResult );
	CheckHR( hr, "Failed to nth an array behavior", end );
	//return the final behavior

end:
	ReleaseInterface( pdabvrIndex );
	ReleaseInterface( pdanumIndex );
	ReleaseInterface( pdaarrArray );

	return hr;
}

//*****************************************************************************
//Do Not call this from the actor.
HRESULT
CBaseBehavior::AddBehaviorToAnimatedElement( IDABehavior *pdabvr, long *plCookie )
{
	if( pdabvr == NULL || plCookie == NULL )
		return E_INVALIDARG;

	HRESULT hr;

	IHTMLElement			*pelemAnimated = NULL;

 	DISPPARAMS              params;
	VARIANT                 varBehavior;
	VARIANT                 varResult;

	//get the animated element
	hr = GetAnimatedParentElement( &pelemAnimated );
	CheckHR( hr, "Failed to get the animated element", end );
	
	
	VariantInit(&varBehavior);
	varBehavior.vt = VT_DISPATCH;
	varBehavior.pdispVal = pdabvr;

	VariantInit(&varResult);

	params.rgvarg					= &varBehavior;
	params.rgdispidNamedArgs		= NULL;
	params.cArgs					= 1;
	params.cNamedArgs				= 0;
    hr = CallInvokeOnHTMLElement(pelemAnimated,
                                 L"AddDABehavior", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);

	if( V_VT( &varResult ) != VT_I4 )
	{
		//change the type.
		hr = VariantChangeTypeEx( &varResult, &varResult, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4 );
		CheckHR( hr, "Failed to change the type of the return to long", end);
	}

	(*plCookie) = V_I4(&varResult);
end:

	VariantClear(&varResult);
	ReleaseInterface( pelemAnimated );

    return hr;
}

//*****************************************************************************
//Do not call this from the actor

HRESULT
CBaseBehavior::RemoveBehaviorFromAnimatedElement( long lCookie )
{
	if( GetHTMLElement() == NULL )
		return E_FAIL;
	
    HRESULT hr;

    IHTMLElement			*pelemAnimated = NULL;
	
	DISPPARAMS              params;
	VARIANT                 varCookie;
	VARIANT                 varResult;

	hr = GetAnimatedParentElement( &pelemAnimated );
	CheckHR( hr, "failed to get the animated element", end );
	
	VariantInit(&varCookie);
	V_VT( &varCookie ) = VT_I4;
	V_I4( &varCookie ) = lCookie;
	
	VariantInit(&varResult);
	
	params.rgvarg                           = &varCookie;
	params.rgdispidNamedArgs				= NULL;
	params.cArgs                            = 1;
	params.cNamedArgs                       = 0;
    hr = CallInvokeOnHTMLElement(pelemAnimated,
								 L"removeDABehavior", 
								 DISPATCH_METHOD,
								 &params,
								 &varResult);

	
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in RemoveBehaviorFromTIME");
		VariantClear(&varResult);
		return hr;
    }

end:

	ReleaseInterface( pelemAnimated );
	VariantClear(&varResult);

    return S_OK;
}


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\colorbvr.cpp ===
//*****************************************************************************
//
// File:    colorbvr.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CColorBvr object which implements
//			 the chromeffects Color DHTML behavior
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/16/98 jeffort     Added animates property
// 10/16/98 jeffort     Renamed functions
// 11/19/98 markhal     Converted to use actor
//*****************************************************************************

#include "headers.h"

#include "colorbvr.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CColorBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_FROM        0
#define VAR_TO          1
#define VAR_PROPERTY    2
#define VAR_DIRECTION   3

WCHAR * CColorBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_FROM,
                                     BEHAVIOR_PROPERTY_TO,
                                     BEHAVIOR_PROPERTY_PROPERTY,
                                     BEHAVIOR_PROPERTY_DIRECTION
                                    };

//*****************************************************************************

CColorBvr::CColorBvr() :
	m_pdispActor(NULL),
	m_lCookie(0)
{
    VariantInit(&m_varFrom);
    VariantInit(&m_varTo);
    VariantInit(&m_varDirection);
    VariantInit(&m_varProperty);
    m_clsid = CLSID_CrColorBvr;
} // CColorBvr

//*****************************************************************************

CColorBvr::~CColorBvr()
{
    VariantClear(&m_varFrom);
    VariantClear(&m_varTo);
    VariantClear(&m_varDirection);
    VariantClear(&m_varProperty);

    ReleaseInterface( m_pdispActor );
} // ~ColorBvr

//*****************************************************************************

HRESULT CColorBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in color behavior FinalConstruct initializing base classes");
        return hr;
    }

	// TODO (markhal): Why is this done here as well as in the GetAttributes method?
    m_varProperty.vt = VT_BSTR;
    m_varProperty.bstrVal = SysAllocString(DEFAULT_COLORBVR_PROPERTY);
    if (m_varProperty.bstrVal == NULL)
    {
        DPF_ERR("Error allocating default property string in CColorBvr::FinalConstruct");
        return SetErrorInfo(E_OUTOFMEMORY);
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CColorBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_COLOR_PROPS);
    switch (iIndex)
    {
    case VAR_FROM:
        return &m_varFrom;
        break;
    case VAR_TO:
        return &m_varTo;
        break;
    case VAR_PROPERTY:
        return &m_varProperty;
        break;
    case VAR_DIRECTION:
        return &m_varDirection;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CColorBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_COLOR_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CColorBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CColorBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		DPF_ERR("------>ColorBvr: Got Document Ready");
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;

} // Notify

//*****************************************************************************

STDMETHODIMP
CColorBvr::Detach()
{
	LMTRACE( L"Detaching color bvr <%p>\n", this );
	HRESULT hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR( "Failure in detach of superclass" );
	}

	hr = RemoveFragment();
	CheckHR( hr, "Failed to remove the behavior fragment from the actor", end );

	LMTRACE( L"Done Detaching Color bvr <%p>\n", this );
end:
	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CColorBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CColorBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CColorBvr::put_from(VARIANT varFrom)
{
    HRESULT hr = VariantCopy(&m_varFrom, &varFrom);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting from for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR( "Failed to rebuild" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRCOLORBVR_FROM);
} // put_from

//*****************************************************************************

STDMETHODIMP
CColorBvr::get_from(VARIANT *pRetFrom)
{
    if (pRetFrom == NULL)
    {
        DPF_ERR("Error in CColorBvr:get_from, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetFrom, &m_varFrom);
} // get_from

//*****************************************************************************

STDMETHODIMP 
CColorBvr::put_to(VARIANT varTo)
{
    HRESULT hr = VariantCopy(&m_varTo, &varTo);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting to for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR( "Failed to rebuild" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRCOLORBVR_TO);
} // put_to

//*****************************************************************************

STDMETHODIMP 
CColorBvr::get_to(VARIANT *pRetTo)
{
    if (pRetTo == NULL)
    {
        DPF_ERR("Error in CColorBvr:get_to, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTo, &m_varTo);
} // get_to

//*****************************************************************************

STDMETHODIMP 
CColorBvr::put_property(VARIANT varProperty)
{
    HRESULT hr = VariantCopy(&m_varProperty, &varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting property for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR( "Failed to rebuild" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRCOLORBVR_PROPERTY);
} // put_property

//*****************************************************************************

STDMETHODIMP 
CColorBvr::get_property(VARIANT *pRetProperty)
{
    if (pRetProperty == NULL)
    {
        DPF_ERR("Error in CColorBvr:get_property, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetProperty, &m_varProperty);
} // get_property

//*****************************************************************************

STDMETHODIMP
CColorBvr::put_direction(VARIANT varDirection)
{
    HRESULT hr = VariantCopy(&m_varDirection, &varDirection);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting direction for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR( "Failed to rebuild" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRCOLORBVR_DIRECTION);
} // put_direction

//*****************************************************************************

STDMETHODIMP
CColorBvr::get_direction(VARIANT *pRetDirection)
{
    if (pRetDirection == NULL)
    {
        DPF_ERR("Error in CColorBvr:get_direction, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetDirection, &m_varDirection);
} // get_direction

//*****************************************************************************

HRESULT 
CColorBvr::BuildAnimationAsDABehavior()
{
	// TODO (markhal): This method to go at some point
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CColorBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
    HRESULT hr;

	hr = RemoveFragment();
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to remove the previous behavior frag from the actor" );
		return hr;
	}
	
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error converting property variant to bstr");
        return SetErrorInfo(hr);
    }

	IDAColor *pbvrInterpolatedColor;

	ActorBvrFlags flags = e_AbsoluteAccum;

	// Check for to parameter only, since it uses a different code path
	hr = GetColorToBvr(pActorDisp, &pbvrInterpolatedColor);

	if (FAILED(hr))
	{
		flags = e_Absolute;

		// we need to build our animation in this function.  We do this
		// by first getting the from and to values, and converting these
		// to an interpolated DA number using the returned TIME value
		// for progress
		DWORD dwColorFrom = CUtils::GetColorFromVariant(&m_varFrom);
		DWORD dwColorTo = CUtils::GetColorFromVariant(&m_varTo);
		if (dwColorTo == PROPERTY_INVALIDCOLOR)
			//dwColorTo = DEFAULT_COLORBVR_TO;
			return S_OK;

		if (dwColorFrom == PROPERTY_INVALIDCOLOR)
			dwColorFrom = dwColorTo;

		float flFromH, flFromS, flFromL;
		float flToH, flToS, flToL;

		CUtils::GetHSLValue(dwColorFrom, &flFromH, &flFromS, &flFromL);
		CUtils::GetHSLValue(dwColorTo, &flToH, &flToS, &flToL);

		// We need to get the progree DA number from TIME
		// TODO: implement this, this is not hooked up in TIME yet
		// RSN
		IDANumber *pbvrProgress;

		hr = GetTIMEProgressNumber(&pbvrProgress);
		if (FAILED(hr))
		{
			DPF_ERR("Unable to access progress value from TIME behavior");
			return hr;
		}

		// create our interpolated color values
		IDANumber *pbvrInterpolatedH;
		IDANumber *pbvrInterpolatedS;
		IDANumber *pbvrInterpolatedL;

		hr = BuildHueNumber(flFromH, flToH, pbvrProgress, &pbvrInterpolatedH);
		if (FAILED(hr))
		{
			DPF_ERR("Error building Hue number bvr");
			ReleaseInterface(pbvrProgress);
			return hr;
		}

		hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromS, flToS, pbvrProgress, &pbvrInterpolatedS);
		if (FAILED(hr))
		{
			DPF_ERR("Error interpolating Saturation in BuildAnimationAsDABehavior");
			ReleaseInterface(pbvrProgress);
			ReleaseInterface(pbvrInterpolatedH);
			return hr;
		}
		hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromL, flToL, pbvrProgress, &pbvrInterpolatedL);
		if (FAILED(hr))
		{
			DPF_ERR("Error interpolating Lightness in BuildAnimationAsDABehavior");
			ReleaseInterface(pbvrProgress);
			ReleaseInterface(pbvrInterpolatedH);
			ReleaseInterface(pbvrInterpolatedS);
			return hr;
		}
		ReleaseInterface(pbvrProgress);

		hr = CDAUtils::BuildDAColorFromHSL(GetDAStatics(),
										   pbvrInterpolatedH,
										   pbvrInterpolatedS,
										   pbvrInterpolatedL,
										   &pbvrInterpolatedColor);
		ReleaseInterface(pbvrInterpolatedH);
		ReleaseInterface(pbvrInterpolatedS);
		ReleaseInterface(pbvrInterpolatedL);
		if (FAILED(hr))
		{
			DPF_ERR("Error building a DA color in BuildAnimationAsDABehavior");
			return hr;
		}
	}

	IDispatch *pdispThis  = NULL;

	hr  = GetHTMLElementDispatch( &pdispThis );
	if( FAILED( hr ) )
	{
		DPF_ERR( "Failed to get IDispatch from the element" );
		ReleaseInterface( pbvrInterpolatedColor );
		return hr;
	}
	
	// Attach color to behavior
	hr = AttachBehaviorToActorEx( pActorDisp,
								  pbvrInterpolatedColor,
								  V_BSTR(&m_varProperty),
								  flags,
								  e_Color,
								  pdispThis,
								  &m_lCookie);

	ReleaseInterface( pdispThis );
	ReleaseInterface(pbvrInterpolatedColor);

	if (FAILED(hr))
	{
		DPF_ERR("Failed to attach behavior to actor");
		return SetErrorInfo(hr);
	}

	m_pdispActor = pActorDisp;
	m_pdispActor->AddRef();

    return S_OK;
} // buildBehaviorFragments

//*****************************************************************************

HRESULT
CColorBvr::BuildHueNumber(float flFromH, float flToH, IDANumber *pbvrProgress, IDANumber **ppbvrInterpolatedH)
{
    HRESULT hr = S_OK;

    if (flFromH > 1.0f || flFromH < 0.0f || flToH > 1.0f || flToH < 0.0f)
        return E_INVALIDARG;

    *ppbvrInterpolatedH = NULL;

    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varDirection);
    if (SUCCEEDED(hr))
    {
        if (0 == wcsicmp(BEHAVIOR_DIRECTION_NOHUE, m_varDirection.bstrVal))
        {
            float flHueToUse = flToH;
            if (flHueToUse == 0.0f)
                flHueToUse = flFromH;
            // for no hue, we will simply create a DA Number for the "to" hue
            hr = CDAUtils::GetDANumber(GetDAStatics(),
                                       flHueToUse,
                                       ppbvrInterpolatedH);
            if (FAILED(hr))
            {
                DPF_ERR("Error crating final hue value in nohue case");
                return SetErrorInfo(hr);
            }

        }
        else if (0 == wcsicmp(BEHAVIOR_DIRECTION_CLOCKWISE, m_varDirection.bstrVal))
        {
            if (0.0f == flFromH)
                flFromH = 1.0f;
                
            if (flToH >= flFromH)
            {
                // Behavior from->0 and 1->To
                float flSweep = flFromH + (1.0f - flToH);

                CComPtr<IDANumber> pbvrCutPercentage;
                hr = CDAUtils::GetDANumber(GetDAStatics(), flFromH / flSweep, &pbvrCutPercentage);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrFirstPercent;
                hr = NormalizeProgressValue(GetDAStatics(), pbvrProgress, 0.0f, flFromH / flSweep, &pbvrFirstPercent);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrFirst;
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromH, 0.0f, pbvrFirstPercent, &pbvrFirst);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrSecondPercent;
                hr = NormalizeProgressValue(GetDAStatics(), pbvrProgress, flFromH / flSweep, 1.0f, &pbvrSecondPercent);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrSecond;
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), 1.0f, flToH, pbvrSecondPercent, &pbvrSecond);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDABoolean> pbvrBoolean;
                hr = GetDAStatics()->LTE(pbvrProgress, pbvrCutPercentage, &pbvrBoolean);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDABehavior> pbvrInterpolated;
                hr = SafeCond(GetDAStatics(), pbvrBoolean, pbvrFirst, pbvrSecond, &pbvrInterpolated);
                if (FAILED(hr))
                    return hr;

                hr = pbvrInterpolated->QueryInterface(IID_TO_PPV(IDANumber, ppbvrInterpolatedH));
                if (FAILED(hr))
                    return hr;
            }
            else
            {
                // behavior from->to
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromH, flToH, pbvrProgress, ppbvrInterpolatedH);
                if (FAILED(hr))
                {
                    DPF_ERR("Error interpolating Hue in BuildHueNumber");
                    return hr;
                }
            }
        }
        else
        {
            // counterclockwise
            if (0.0f == flToH)
                flToH = 1.0f;

            if (flToH <= flFromH)
            {
                // behavior from->1 and 0->To
                float flSweep = flToH + (1.0f - flFromH);

                CComPtr<IDANumber> pbvrCutPercentage;
                hr = CDAUtils::GetDANumber(GetDAStatics(), (1.0f - flFromH) / flSweep, &pbvrCutPercentage);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrFirstPercent;
                hr = NormalizeProgressValue(GetDAStatics(), pbvrProgress, 0.0f, (1.0f - flFromH) / flSweep, &pbvrFirstPercent);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrFirst;
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromH, 1.0f, pbvrFirstPercent, &pbvrFirst);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrSecondPercent;
                hr = NormalizeProgressValue(GetDAStatics(), pbvrProgress, (1.0f - flFromH) / flSweep, 1.0f, &pbvrSecondPercent);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrSecond;
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), 0.0f, flToH, pbvrSecondPercent, &pbvrSecond);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDABoolean> pbvrBoolean;
                hr = GetDAStatics()->LTE(pbvrProgress, pbvrCutPercentage, &pbvrBoolean);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDABehavior> pbvrInterpolated;
                hr = SafeCond(GetDAStatics(), pbvrBoolean, pbvrFirst, pbvrSecond, &pbvrInterpolated);
                if (FAILED(hr))
                    return hr;

                hr = pbvrInterpolated->QueryInterface(IID_TO_PPV(IDANumber, ppbvrInterpolatedH));
                if (FAILED(hr))
                    return hr;
            }
            else
            {
                // behavior from->to
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromH, flToH, pbvrProgress, ppbvrInterpolatedH);
                if (FAILED(hr))
                {
                    DPF_ERR("Error interpolating Hue in BuildHueNumber");
                    return hr;
                }
            }
        }
    }
    else
    {
        // just take the shortest path
        hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromH, flToH, pbvrProgress, ppbvrInterpolatedH);
        if (FAILED(hr))
        {
            DPF_ERR("Error interpolating Hue in BuildHueNumber");
            return hr;
        }
    }

    return S_OK;
} // BuildHueNumber

//*****************************************************************************

HRESULT
CColorBvr::NormalizeProgressValue(IDA2Statics *pDAStatics,
                                  IDANumber *pbvrProgress, 
                                  float flStartPercentage,
                                  float flEndPercentage,
                                  IDANumber **ppbvrReturn)
{

    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flEndPercentage >= 0.0f);
    DASSERT(flEndPercentage <= 1.0f);
    DASSERT(ppbvrReturn != NULL);
    *ppbvrReturn = NULL;
    
    HRESULT hr;

    if (flStartPercentage >= flEndPercentage)
    {
        DPF_ERR("Error, invalid percentage values");
        return E_INVALIDARG;
    }

    IDANumber *pbvrProgressRange;
    hr = CDAUtils::GetDANumber(pDAStatics, (flEndPercentage - flStartPercentage),
                               &pbvrProgressRange);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in CPathElement::NormalizeProgressValue");
        return hr;
    }
    DASSERT(pbvrProgressRange != NULL);

    IDANumber *pbvrStart;
    hr = CDAUtils::GetDANumber(pDAStatics, flStartPercentage, &pbvrStart);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in CPathElement::NormalizeProgressValue");
        ReleaseInterface(pbvrProgressRange);
        return hr;
    }
    DASSERT(pbvrStart != NULL);
    IDANumber *pbvrSub;
    hr = pDAStatics->Sub(pbvrProgress, pbvrStart, &pbvrSub);
    ReleaseInterface(pbvrStart);
    if (FAILED(hr))
    {
        DPF_ERR("Error subtracting DA number in CPathElement::NormalizeProgressValue");
        ReleaseInterface(pbvrProgressRange);
        return hr;
    }
    DASSERT(pbvrSub != NULL);
    hr = pDAStatics->Div(pbvrSub, pbvrProgressRange, ppbvrReturn);
    ReleaseInterface(pbvrSub);
    ReleaseInterface(pbvrProgressRange);
    if (FAILED(hr))
    {
        DPF_ERR("Error Dividing DA numbers in CPathElement::NormalizeProgressValue");
        return hr;
    }
    return S_OK;
} // NormalizeProgressValue

HRESULT
CColorBvr::GetColorToBvr(IDispatch *pActorDisp, IDAColor **ppResult)
{
	HRESULT hr = S_OK;

	// Only want to succeed if there is no from color and a valid to color
	DWORD dwColorFrom = CUtils::GetColorFromVariant(&m_varFrom);
	if (dwColorFrom != PROPERTY_INVALIDCOLOR)
		return E_FAIL;

	DWORD dwColorTo = CUtils::GetColorFromVariant(&m_varTo);
	if (dwColorTo == PROPERTY_INVALIDCOLOR)
		return E_FAIL;

	// Get from color from the actor
	IDABehavior *pFromBvr;
	hr = GetBvrFromActor(pActorDisp, V_BSTR(&m_varProperty), e_From, e_Color, &pFromBvr);
	if (FAILED(hr))
		return hr;

	IDAColor *pFrom = NULL;
	IDANumber *pFromH = NULL;
	IDANumber *pFromS = NULL;
	IDANumber *pFromL = NULL;
	IDANumber *pToH = NULL;
	IDANumber *pToS = NULL;
	IDANumber *pToL = NULL;
	IDANumber *pInterpH = NULL;
	IDANumber *pInterpS = NULL;
	IDANumber *pInterpL = NULL;

	hr = pFromBvr->QueryInterface(IID_TO_PPV(IDAColor, &pFrom));
	ReleaseInterface(pFromBvr);
	if (FAILED(hr))
		return hr;

	hr = pFrom->get_Hue(&pFromH);
	if (FAILED(hr))
		goto release;

	hr = pFrom->get_Saturation(&pFromS);
	if (FAILED(hr))
		goto release;

	hr = pFrom->get_Lightness(&pFromL);
	if (FAILED(hr))
		goto release;

	float flToH, flToS, flToL;

	CUtils::GetHSLValue(dwColorTo, &flToH, &flToS, &flToL);

	hr = GetDAStatics()->DANumber(flToH, &pToH);
	if (FAILED(hr))
		goto release;

	hr = GetDAStatics()->DANumber(flToS, &pToS);
	if (FAILED(hr))
		goto release;

	hr = GetDAStatics()->DANumber(flToL, &pToL);
	if (FAILED(hr))
		goto release;

	hr = BuildTIMEInterpolatedNumber(pFromH, pToH, &pInterpH);
	if (FAILED(hr))
		goto release;

	hr = BuildTIMEInterpolatedNumber(pFromS, pToS, &pInterpS);
	if (FAILED(hr))
		goto release;

	hr = BuildTIMEInterpolatedNumber(pFromL, pToL, &pInterpL);
	if (FAILED(hr))
		goto release;

	hr = GetDAStatics()->ColorHslAnim(pInterpH, pInterpS, pInterpL, ppResult);

release:
	ReleaseInterface(pFrom);
	ReleaseInterface(pFromH);
	ReleaseInterface(pFromS);
	ReleaseInterface(pFromL);
	ReleaseInterface(pToH);
	ReleaseInterface(pToS);
	ReleaseInterface(pToL);
	ReleaseInterface(pInterpH);
	ReleaseInterface(pInterpS);
	ReleaseInterface(pInterpL);

	return hr;
}

//*****************************************************************************

HRESULT
CColorBvr::RemoveFragment()
{
	HRESULT hr = S_OK;
	
	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		hr  = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		ReleaseInterface( m_pdispActor );
		m_lCookie = 0;
		CheckHR( hr, "Failed to remove a fragment from the actor", end );
	}

end:

	return hr;
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\dautil.h ===
#pragma once
#ifndef __DAUTIL_H_
#define __DAUTIL_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    dautils.h
//
// Author:	    jeffort
//
// Created:	    10/07/98
//
// Abstract:    Definition of DA utility class
// Modifications:
// 10/07/98 jeffort created file
// 10/21/98 jeffort added BuildScaleTransform3 and BuildScaleTransform2
//
//*****************************************************************************

class CDAUtils
{
public:
    static HRESULT TIMEInterpolateNumbers(IDA2Statics *pDAStatics,
                                          float flNum1, 
                                          float flNum2, 
                                          IDANumber *pnumProgress, 
                                          IDANumber **ppnumReturn);
    static HRESULT GetDANumber(IDA2Statics *pDAStatics, 
                               float flValue, 
                               IDANumber **ppnumReturn);
    static HRESULT GetDAString(IDA2Statics *pDAStatics, 
                               BSTR bstrValue, 
                               IDAString **ppbvrReturn);
    static HRESULT BuildDAColorFromHSL(IDA2Statics *pDAStatics,
                                       IDANumber *pnumH, 
                                       IDANumber *pnumS,
                                       IDANumber *pnumL, 
                                       IDAColor **ppbvrReturn);
    static HRESULT BuildDAColorFromStaticHSL(IDA2Statics *pDAStatics,
                                            float flH, 
                                            float flS, 
                                            float flL,
                                            IDAColor **ppbvrReturn);
    static HRESULT BuildDAColorFromRGB(IDA2Statics *pDAStatics,
                                            DWORD dwColor,
                                            IDAColor **ppbvrReturn);
    static HRESULT BuildConditional(IDA2Statics *pDAStatics,
                                    IDABoolean *pbvrConditional, 
                                    IDABehavior *pbvrWhileTrue,
                                    IDABehavior *pbvrWhileFalse,
                                    IDABehavior **ppbvrReturn);
    static HRESULT BuildSafeConditional( IDA2Statics *pDAStatics,
										 IDABoolean *pbvrCondition, 
                           				 IDABehavior *pbvrIfTrue,
                           				 IDABehavior *pbvrIfFalse,
                           				 IDABehavior **ppbvrResult);

    static HRESULT BuildRotationTransform2(IDA2Statics *pDAStatics,
                                           IDANumber *pRotationAngle,
                                           IDATransform2 **ppbvrReturn);
    static HRESULT BuildScaleTransform2(IDA2Statics *pDAStatics,
                                        IDANumber *pbvrScaleX,
                                        IDANumber *pbvrScaleY,
                                        IDATransform2 **ppbvrReturn);
    static HRESULT BuildScaleTransform3(IDA2Statics *pDAStatics,
                                        IDANumber *pbvrScaleX,
                                        IDANumber *pbvrScaleY,
                                        IDANumber *pbvrScaleZ,
                                        IDATransform3 **ppbvrReturn);
    static HRESULT BuildMoveTransform2(IDA2Statics *pDAStatics,
                                       IDANumber *pbvrMoveX,
                                       IDANumber *pbvrMoveY,
                                       IDATransform2 **ppbvrReturn);
    static HRESULT BuildMoveTransform3(IDA2Statics *pDAStatics,
                                       IDANumber *pbvrMoveX,
                                       IDANumber *pbvrMoveY,
                                       IDANumber *pbvrMoveZ,
                                       IDATransform3 **ppbvrReturn);
}; // CDAUtils

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__DAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\autobase.cpp ===
//*****************************************************************************
//
// FileName:	    autobase.cpp
//
// Created:	    10/08/97
//
// Author:	    ColinMc
// 
// Abstract:	    The base class for all automatable objects
//                  in Trident3D. Stuff that is common across
//                  all scriptable objects should be placed
//                  here
//
// Modifications:
// 10/08/97 ColinMc Created this file
// 10/07/98 jeffort added to crbvr project
//
//*****************************************************************************

#include "headers.h"

//*****************************************************************************

#include <autobase.h>

//*****************************************************************************

// Maximum error message size in character
static const int gc_cErrorBuffer = 1024;

//*****************************************************************************

CAutoBase::CAutoBase()
{
    // No-op currently
} // CAutoBase

//*****************************************************************************

CAutoBase::~CAutoBase()
{
    // No-op currently
} // ~CAutoBase

//*****************************************************************************
//
// Author:      ColinMc
// Created:     10/09/97
// Abstract:    Returns an IErrorInfo that can be used to
//              communicate error information to the client
//              uses the currently set error info for this
//              thread if one is set. Otherwise creates a
//              new one and returns it
//              
//*****************************************************************************

HRESULT CAutoBase::GetErrorInfo(IErrorInfo** pperrinfo)
{
    DASSERT(NULL != pperrinfo);
    ICreateErrorInfo* pcerrinfo = NULL;

    *pperrinfo = NULL;

    // Get the current error object for this thread. If there
    // is one we will reuse that object for this error
    // (discarding the unclaimed existing error). Note that
    // the GetErrorInfo() below clears the current error
    // state of the thread
    if (S_FALSE == ::GetErrorInfo(0UL, pperrinfo))
    {
	// If there is no current error object then try and
	// create one.
	HRESULT hr = ::CreateErrorInfo(&pcerrinfo);
	if (FAILED(hr))
	{
	    // The only reason creating the error info should
	    // fail is if there is insufficient memory in which
	    // case we will just rely on the HRESULT to carry
	    // the data.
	    DASSERT(E_OUTOFMEMORY == hr);
	    return hr;
	}

	// Get the IErrorInfo interface to pass back. This
	// should not fail!
	hr = pcerrinfo->QueryInterface(IID_IErrorInfo, (void**)pperrinfo);
	ReleaseInterface(pcerrinfo);
	if (FAILED(hr))
	{
	    DASSERT(SUCCEEDED(hr));
	    return hr;
	}
    }

    DASSERT(NULL != *pperrinfo);

    return S_OK;
} // GetErrorInfo

//*****************************************************************************
//
// Author:      ColinMc
// Created:     10/09/97
// Abstract:    Sets the thread's error object to hold
//              additional data about the error in question
//              NOTE: The return code of this function is
//              the hresult passed in and not a success or
//              failure return from the function itself.
//              This is so you can do a:
//              
//              return SetErrorInfo(hr, ...);
//
//              at the tail of your function
//              
//*****************************************************************************

HRESULT CAutoBase::SetErrorInfo(HRESULT   hr,
				UINT      nDescriptionID,
				LPGUID    pguidInterface,
				DWORD     dwHelpContext,
				LPOLESTR  szHelpFile,
				UINT      nProgID)
{
    TCHAR             szBuffer[gc_cErrorBuffer];
    OLECHAR           wzBuffer[gc_cErrorBuffer];
    IErrorInfo*       perrinfo  = NULL;
    ICreateErrorInfo* pcerrinfo = NULL;
    int               cch;

    // if hr is a SUCCCEEDED case, return
    // NOTE: SUCCEEDED is defined in winerror.h as:
    // #define SUCCEEDED(Status) ((HRESULT)(Status) >= 0)
    // Since we have a debug macro overiding SUCCEEDED, do what
    // the macro in winerror.h is doing.
    if (hr >= 0)
    {
        return hr;
    }

    //print out info on this
    DPF(0, "SetErrorInfo called HRESULT set to [%08X]", hr);
    // Get an IErrorInfo we can use to communicate the
    // error data back to the caller on this thread
    HRESULT hrtmp = GetErrorInfo(&perrinfo);
    if (FAILED(hrtmp))
    {
	// No error object - no extended error information.
	// NOTE: We return the original error and not the one
	// we got trying to allocate an error object
	DPF(0, "Coult not allocate error object - simply returning an HRESULT");
	return hr;
    }

    // Now we have an error object we need to set up the data.
    // To do this we need to get the ICreateErrorInfo
    // interface
    // Currently this is pretty basic.
    // TODO: (ColinMc) Add addition error information to the
    // error object
    hrtmp = perrinfo->QueryInterface(IID_ICreateErrorInfo, (void**)&pcerrinfo);
    if (FAILED(hrtmp))
    {
	// Ouch - the error object does not support
	// ICreateErrorInfo. I don't think this should happen.
	// Again, give the original error back rather than
	// the new one.
	DASSERT(SUCCEEDED(hrtmp));
	return hr;
    }

    // Set the error information. Note, we set it all even if we having
    // nothing to say to ensure we don't return bogus information from 
    // the previous error (as we are re-using the object).
    // If anything fails we just keep going on the assumption that
    // anything is better than nothing.
    DASSERT(NULL != pcerrinfo);
    if (0U != nDescriptionID)
    {
	cch = ::LoadString(GetErrorModuleHandle(), nDescriptionID, szBuffer, sizeof(szBuffer));
	DASSERT(0 != cch);
	::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szBuffer, cch + 1, wzBuffer, gc_cErrorBuffer);
	hrtmp = pcerrinfo->SetDescription(wzBuffer);
    }
    else
    {
	// No description
	hrtmp = pcerrinfo->SetDescription(NULL);
    }
    if (FAILED(hrtmp))
    {
	// Should only fail due insufficient memory
	DASSERT(E_OUTOFMEMORY == hrtmp);
	DPF(0, "Could not set the error description");
    }
    if (NULL != pguidInterface)
	hrtmp = pcerrinfo->SetGUID(*pguidInterface);
    else
	hrtmp = pcerrinfo->SetGUID(GUID_NULL);
    if (FAILED(hrtmp))
    {
	// Should only fail due insufficient memory
	DASSERT(E_OUTOFMEMORY == hrtmp);
	DPF(0, "Could not set the GUID");
    }
    hrtmp = pcerrinfo->SetHelpContext(dwHelpContext);
    if (FAILED(hrtmp))
    {
	// Should only fail due insufficient memory
	DASSERT(E_OUTOFMEMORY == hrtmp);
	DPF(0, "Could not set the help context");
    }
    hrtmp = pcerrinfo->SetHelpFile(szHelpFile);
    if (FAILED(hrtmp))
    {
	// Should only fail due insufficient memory
	DASSERT(E_OUTOFMEMORY == hrtmp);
	DPF(0, "Could not set the help file");
    }
    if (0U != nProgID)
    {
	cch = ::LoadString(GetErrorModuleHandle(), nProgID, szBuffer, sizeof(szBuffer));
	DASSERT(0 != cch);
	::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szBuffer, cch + 1, wzBuffer, gc_cErrorBuffer);
        hrtmp = pcerrinfo->SetSource(wzBuffer);
    }
    else
    {
	// No description
	hrtmp = pcerrinfo->SetSource(NULL);
    }
    if (FAILED(hrtmp))
    {
	// Should only fail due insufficient memory
	DASSERT(E_OUTOFMEMORY == hrtmp);
	DPF(0, "Could not set the source");
    }

    // Done with the creation interface
    ReleaseInterface(pcerrinfo);

    // Finally set the error as the thread's error object.
    // The client should pick this up if it needs more
    // error information
    // NOTE: This should not fail
    hrtmp = ::SetErrorInfo(0UL, perrinfo);
    DASSERT(S_OK == hrtmp);

    // NOTE: The return value of this function is error
    // code passed in and NOT a success or failure value
    // for the function itself.
    return hr;
} // SetErrorInfo

//*****************************************************************************

void CAutoBase::ClearErrorInfo()
{
    // Simply call GetErrorInfo() and release it
    IErrorInfo* perrinfo = NULL;

    // GetErrorInfo clears the current error object as a side
    // effect (which is the point of this function). Therefore
    // we simply discard the resulting error interface.
    HRESULT hr = ::GetErrorInfo(0UL, &perrinfo);
    if (S_OK == hr)
    {
	DASSERT(NULL != perrinfo);
	ReleaseInterface(perrinfo);
	perrinfo = NULL;
    }
} // ClearErrorInfo

//*****************************************************************************

HINSTANCE CAutoBase::GetErrorModuleHandle()
{
    extern CComModule _Module;

    // TODO: (ColinMc) This is a HACK. We need to move to
    // a better scheme for getting the module where the error
    // messages are stored but this will do for now.
    return _Module.GetModuleInstance();
} // GetErrorModuleHandle

//*****************************************************************************
//
// End of file
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\dispmethod.cpp ===
/******************************************************************************
*
*
*
*
*******************************************************************************/


#include "headers.h"

#include "dispmethod.h"

//*****************************************************************************

CDispatchMethod::CDispatchMethod( ) :
m_cRefs( 1 )
{
}

//*****************************************************************************

CDispatchMethod::~CDispatchMethod()
{
}

//*****************************************************************************
//IUnknown
//*****************************************************************************

STDMETHODIMP
CDispatchMethod::QueryInterface( REFIID riid, void** ppv)
{
    if( ppv == NULL )
        return E_POINTER;

	if( riid == IID_IUnknown )
	{
		(*ppv) = static_cast<IUnknown*>(this);
	}
    else if( riid == IID_IDispatch )
    {
        (*ppv) = static_cast<IDispatch*>(this);
    }   
    else
    {
        (*ppv) = NULL;
        return E_NOINTERFACE;
    }

    static_cast<IUnknown*>(*ppv)->AddRef();

    return S_OK;
}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CDispatchMethod::AddRef()
{
    m_cRefs++;
    return m_cRefs;
}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CDispatchMethod::Release()
{
    ULONG refs = --m_cRefs;

    if( refs == 0 )
        delete this;

    return refs;
}

//*****************************************************************************
//IDispatch
//*****************************************************************************

STDMETHODIMP
CDispatchMethod::GetTypeInfoCount( UINT *pctInfo )
{
    return E_NOTIMPL;
}

//*****************************************************************************

STDMETHODIMP
CDispatchMethod::GetTypeInfo( UINT iTypeInfo,
                              LCID lcid,
                              ITypeInfo** ppTypeInfo )
{
    return E_NOTIMPL;
}

//*****************************************************************************

STDMETHODIMP
CDispatchMethod::GetIDsOfNames( REFIID riid,
                                     LPOLESTR* rgszNames,
                                     UINT cNames,
                                     LCID lcid,
                                     DISPID* rgid )
{
    return E_NOTIMPL;
}

//*****************************************************************************


STDMETHODIMP
CDispatchMethod::Invoke( DISPID id,
                         REFIID riid,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS *pDispParams,
                         VARIANT *pvarResult,
                         EXCEPINFO *pExcepInfo,
                         UINT *puArgErr)
{
	return HandleEvent();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\dautil.cpp ===
//*****************************************************************************
//
// Microsoft Chrome
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    dautil.cpp
//
// Author:	    jeffort
//
// Created:	    10/07/98
//
// Abstract:    Implementation of DA utility class
//              This class provides functionality specific
//              to DA objects.  It must be a child
//              of a behavior, and relies on its parent to
//              obtain a ref counted pointer to the DA
//              statics.
// Modifications:
// 10/07/98 jeffort created file
// 10/21/98 jeffort added BuildScaleTransform3 and BuildScaleTransform2
//
//*****************************************************************************

#include "headers.h"

#include "dautil.h"
    
//*****************************************************************************
//
// Abstract: This function is called to create a DA number that is the
//           interpolated value from flNum1 to flNum2.  For TIME, this
//           is not a straight interpolate, but the progress number (pnumProgress)
//           is used for the interpolation.  The formula used is:
//           res = flNum1 + ((flNum2 - flNum1) * pnumProgress).
//           This is returned as a DA number.
//*****************************************************************************

HRESULT
CDAUtils::TIMEInterpolateNumbers(IDA2Statics *pDAStatics,
                                 float flNum1, 
                                 float flNum2, 
                                 IDANumber *pnumProgress, 
                                 IDANumber **ppnumReturn)
{
    DASSERT(pnumProgress != NULL);
    DASSERT(ppnumReturn != NULL);
    DASSERT(pDAStatics != NULL);
    *ppnumReturn = NULL;

    HRESULT hr;

    IDANumber *pnumNumber = NULL;
    IDANumber *pnumIncrement = NULL;
    hr = pDAStatics->DANumber((flNum2 - flNum1), &pnumNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in TIMEInterpolateNumbers");
        return hr;
    }
    hr = pDAStatics->Mul(pnumNumber, pnumProgress, &pnumIncrement);
    ReleaseInterface(pnumNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error mutiplyin DA numbers in TIMEInterpolateNumbers");
        return hr;
    }
    hr = pDAStatics->DANumber(flNum1, &pnumNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in TIMEInterpolateNumbers");
        ReleaseInterface(pnumIncrement);
        return hr;
    }    
    hr = pDAStatics->Add(pnumNumber, pnumIncrement, ppnumReturn);
    ReleaseInterface(pnumIncrement);
    ReleaseInterface(pnumNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding DA numbers in TIMEInterpolateNumbers");
        return hr;
    }
    return S_OK;
} // TIMEInterpolateNumbers

//*****************************************************************************

HRESULT 
CDAUtils::GetDANumber(IDA2Statics *pDAStatics, 
                      float flValue, 
                      IDANumber **ppnumReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(ppnumReturn != NULL);
    *ppnumReturn = NULL;

    HRESULT hr = pDAStatics->DANumber(flValue, ppnumReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number");
        return hr;
    }
    return S_OK;

} // GetDANumber

//*****************************************************************************

HRESULT
CDAUtils::GetDAString(IDA2Statics *pDAStatics, 
                      BSTR bstrValue, 
                      IDAString **ppbvrReturn)
{

    DASSERT(pDAStatics != NULL);
    DASSERT(bstrValue != NULL);
    DASSERT(ppbvrReturn != NULL);
    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->DAString(bstrValue, ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA string");
        return hr;
    }
    return S_OK;

} // GetDAString

//*****************************************************************************

HRESULT
CDAUtils::BuildDAColorFromHSL(IDA2Statics *pDAStatics, 
                              IDANumber *pnumH, 
                              IDANumber *pnumS,
                              IDANumber *pnumL, 
                              IDAColor **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pnumH != NULLL);
    DASSERT(pnumS != NULLL);
    DASSERT(pnumL != NULLL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->ColorHslAnim(pnumH, pnumS, pnumL, ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA color in BuildDAColorFromHSL");
        return hr;
    }
    return S_OK;
} // BuildDAColorFromHSL

//*****************************************************************************

HRESULT
CDAUtils::BuildDAColorFromStaticHSL(IDA2Statics *pDAStatics,
                                    float flH, 
                                    float flS, 
                                    float flL,
                                    IDAColor **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;
    HRESULT hr = pDAStatics->ColorHsl(flH, flS, flL, ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA color in BuildDAColorFromStaticHSL");
        return hr;
    }
    return S_OK;
} // BuildDAColorFromStaticHSL

HRESULT
CDAUtils::BuildDAColorFromRGB(IDA2Statics *pDAStatics,
                              DWORD dwColor,
                              IDAColor **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->ColorRgb255(LOBYTE(HIWORD(dwColor)), // red
                                         HIBYTE(LOWORD(dwColor)), // green 
                                         LOBYTE(LOWORD(dwColor)), // blue
                                         ppbvrReturn);    

    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA color in BuildDAColorFromRGB");
        return hr;
    }
    return S_OK;
} // BuildDAColorFromRGB


//*****************************************************************************

HRESULT
CDAUtils::BuildConditional(IDA2Statics *pDAStatics,
                           IDABoolean *pbvrConditional, 
                           IDABehavior *pbvrWhileTrue,
                           IDABehavior *pbvrWhileFalse,
                           IDABehavior **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->Cond(pbvrConditional,
                          pbvrWhileTrue,
                          pbvrWhileFalse,
                          ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Cond in BuildConditional");
        return hr;
    }
    return S_OK;
} // BuildConditional

//*****************************************************************************


HRESULT
CDAUtils::BuildSafeConditional( IDA2Statics *pstatics,
								IDABoolean *pdaboolCondition, 
                           		IDABehavior *pdabvrIfTrue,
                           		IDABehavior *pdabvrIfFalse,
                           		IDABehavior **ppdabvrResult)
{
	if( pstatics == NULL || 
		pdaboolCondition == NULL || 
		pdabvrIfTrue == NULL || 
		pdabvrIfFalse == NULL ||
		ppdabvrResult == NULL )
		return E_INVALIDARG;
		
	HRESULT hr = S_OK;

	IDABehavior *pdabvrIndex = NULL;
	IDANumber	*pdanumIndex = NULL;
	IDAArray	*pdaarrArray = NULL;
	IDANumber	*pdanumZero  = NULL;
	IDANumber	*pdanumOne	 = NULL;
	IDABehavior *rgpdabvr[2] = {NULL, NULL};

	hr = pstatics->DANumber( 0.0, &pdanumZero );
	CheckHR( hr, "Failed to create a danumber for 0", end );

	hr = pstatics->DANumber( 1.0, &pdanumOne );
	CheckHR( hr, "Failed to create a danumber for 1", end );

	//create an index that is 0 when pdaboolCondition is false, and 1 when it is true
	hr = pstatics->Cond( pdaboolCondition, pdanumZero, pdanumOne, &pdabvrIndex );
	CheckHR( hr, "Failed to create a conditional for the index", end);

	hr = pdabvrIndex->QueryInterface( IID_TO_PPV( IDANumber, &pdanumIndex ) );
	CheckHR( hr, "Failed QI for IDANumber on an idabehavior", end );
	
	//create an array behavior with the first element being ifTrue, and the second ifFalse
	rgpdabvr[0] = pdabvrIfTrue;
	rgpdabvr[1] = pdabvrIfFalse;
	hr = pstatics->DAArrayEx( 2, rgpdabvr, &pdaarrArray );
	CheckHR( hr, "Failed to create an array behavior", end );

	//index into the array
	hr = pdaarrArray->NthAnim( pdanumIndex, ppdabvrResult );
	CheckHR( hr, "Failed to nth an array behavior", end );
	//return the final behavior

end:
	ReleaseInterface( pdabvrIndex );
	ReleaseInterface( pdanumIndex );
	ReleaseInterface( pdaarrArray );
	ReleaseInterface( pdanumZero );
	ReleaseInterface( pdanumOne );

	return hr;

}

//*****************************************************************************

HRESULT
CDAUtils::BuildRotationTransform2(IDA2Statics *pDAStatics,
                                  IDANumber *pRotationAngle,
                                  IDATransform2 **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pRotationAngle != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;
    HRESULT hr = pDAStatics->Rotate2Anim(pRotationAngle, ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Rotate2Anim in BuildRotationTransform2");
        return hr;
    }
    return S_OK;
} // BuildRotationTransform2

//*****************************************************************************

HRESULT
CDAUtils::BuildScaleTransform2(IDA2Statics *pDAStatics,
                               IDANumber *pbvrScaleX,
                               IDANumber *pbvrScaleY,
                               IDATransform2 **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrScaleX != NULL);
    DASSERT(pbvrScaleY != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;
    HRESULT hr = pDAStatics->Scale2Anim(pbvrScaleX, 
                                        pbvrScaleY,
                                        ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Scale2Anim in BuildScaleTransform2");
        return hr;
    }
    return S_OK;
} // BuildScaleTransform2

//*****************************************************************************

HRESULT
CDAUtils::BuildScaleTransform3(IDA2Statics *pDAStatics,
                               IDANumber *pbvrScaleX,
                               IDANumber *pbvrScaleY,
                               IDANumber *pbvrScaleZ,
                               IDATransform3 **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrScaleX != NULL);
    DASSERT(pbvrScaleY != NULL);
    DASSERT(pbvrScaleZ != NULL);
    DASSERT(ppbvrReturn != NULLL);

    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->Scale3Anim(pbvrScaleX, 
                                        pbvrScaleY,
                                        pbvrScaleZ,
                                        ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Scale3Anim in BuildScaleTransform3");
        return hr;
    }
    return S_OK;
} // BuildScaleTransform3

//*****************************************************************************

HRESULT
CDAUtils::BuildMoveTransform2(IDA2Statics *pDAStatics,
                              IDANumber *pbvrMoveX,
                              IDANumber *pbvrMoveY,
                              IDATransform2 **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrScaleX != NULL);
    DASSERT(pbvrScaleY != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;
    HRESULT hr = pDAStatics->Translate2Anim(pbvrMoveX, 
                                            pbvrMoveY,
                                            ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Translate2Anim in BuildMoveTransform2");
        return hr;
    }
    return S_OK;
} // BuildMoveTransform2

//*****************************************************************************

HRESULT
CDAUtils::BuildMoveTransform3(IDA2Statics *pDAStatics,
                              IDANumber *pbvrMoveX,
                              IDANumber *pbvrMoveY,
                              IDANumber *pbvrMoveZ,
                              IDATransform3 **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrScaleX != NULL);
    DASSERT(pbvrScaleY != NULL);
    DASSERT(pbvrScaleZ != NULL);
    DASSERT(ppbvrReturn != NULLL);

    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->Translate3Anim(pbvrMoveX, 
                                            pbvrMoveY,
                                            pbvrMoveZ,
                                            ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Translate3Anim in BuildMoveTransform3");
        return hr;
    }
    return S_OK;
} // BuildMoveTransform3

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\effect.cpp ===
//*****************************************************************************
//
// File: effect.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CEffectBvr object which implements
//			 the chromeffects effect DHTML behavior
//
// Modification List:
// Date		Author		Change
// 11/13/98	jeffort		Created this file
//
//*****************************************************************************
#include "headers.h"

#include "effect.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CEffectBvr
#define SUPER CBaseBehavior

// this number is the number we use to distinguish transform dispid's
// from our own.  If our dispid value ever goes beyond this (sheesh!!!)
// then this number needs to be incremnted
#define EFFECT_BVR_DISPID_OFFSET 0x100
#define EFFECT_CLASSID_LENGTH 36
#define EFFECT_MAX_INPUTS 2
#define EFFECT_OUTPUT L"out"

//************************************************************
// Initialize the ATL CComTypeInfoHolder helper class. This mechanism takes
// care of the type library work for our custom IDispatchEx implementation.
// This code is patterned after the templatized IDispatchImpl class, but the
// template stuff is removed because we need to extend that functionality
// to understand IDispatchEx methods and to provide some custom handling
// within the IDispatch methods as well.
//
// -- note: this static initializer line looks similar to the normal
//    inheritance line for IDispatchImpl, for example:
//
//    public IDispatchImpl<ICrEffectBvr, &IID_ICrEffectBvr, &LIBID_LiquidMotion>
//
//   especially when you consider the default template parameters of:
//
//   WORD wMajor = 1, WORD wMinor = 0.  Look at atlcom.h and atlimpl.cpp for
//   more details on how this is done inside ATL.
//
//  IID_DXTC_DISPATCH is the name of the main interface that is implemented
//  On the parent object of the CDXTContainer class.  As an example, for
//  CComFilter, this class is ICrFilter3D.  This is the interface that
//  supports IDispatch on the parent object.
//
CComTypeInfoHolder CEffectBvr::s_tihTypeInfo =
        {&IID_ICrEffectBvr, &LIBID_LiquidMotion, 1, 0, NULL, 0};

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_TYPE 0
#define VAR_CLASSID 1
#define VAR_TRANSITION 2
#define VAR_PROGID 3
#define VAR_DIRECTION 4
#define VAR_IMAGE 5

WCHAR * CEffectBvr::m_rgPropNames[] = {
                                       BEHAVIOR_PROPERTY_TYPE,
                                       BEHAVIOR_PROPERTY_CLASSID,
                                       BEHAVIOR_PROPERTY_TRANSITION,
                                       BEHAVIOR_PROPERTY_PROGID,
                                       BEHAVIOR_PROPERTY_DIRECTION,
                                       BEHAVIOR_PROPERTY_IMAGE
                                      };

//*****************************************************************************

typedef struct _EFFECTVALUE_PAIR
{
    WCHAR *wzEffectClassid;
    WCHAR *wzEffectName;
} EFFECTVALUE_PAIR;

const EFFECTVALUE_PAIR
rgEffectNames[] =
{
    {L"{16b280c8-ee70-11d1-9066-00c04fd9189d}", L"basicimage"},
    {L"{421516C1-3CF8-11D2-952A-00C04FA34F05}", L"chroma"},
    {L"{9a43a844-0831-11d1-817f-0000f87557db}", L"compositor"},
    {L"{2bc0ef29-e6ba-11d1-81dd-0000f87557db}", L"convolution"},
    {L"{c3bdf740-0b58-11d2-a484-00c04f8efb69}", L"crbarn"},
    {L"{00c429c0-0ba9-11d2-a484-00c04f8efb69}", L"crblinds"},
    {L"{7312498d-e87a-11d1-81e0-0000f87557db}", L"crblur"},
    {L"{f515306d-0156-11d2-81ea-0000f87557db}", L"cremboss"},
    {L"{f515306e-0156-11d2-81ea-0000f87557db}", L"crengrave"},
    {L"{16b280c5-ee70-11d1-9066-00c04fd9189d}", L"crfade"},
    {L"{93073c40-0ba5-11d2-a484-00c04f8efb69}", L"crinset"},
    {L"{3f69f351-0379-11d2-a484-00c04f8efb69}", L"criris"},
    {L"{424b71af-0695-11d2-a484-00c04f8efb69}", L"crradialwipe"},
    {L"{810e402f-056b-11d2-a484-00c04f8efb69}", L"crslide"},
    {L"{aca97e00-0c7d-11d2-a484-00c04f8efb69}", L"crspiral"},
    {L"{7658f2a2-0a83-11d2-a484-00c04f8efb69}", L"crstretch"},
    {L"{5ae1dae0-1461-11d2-a484-00c04f8efb69}", L"crwheel"},
    {L"{e6e73d20-0c8a-11d2-a484-00c04f8efb69}", L"crzigzag"},
    {L"{ADC6CB86-424C-11D2-952A-00C04FA34F05}", L"dropshadow"},
    {L"{623e2882-fc0e-11d1-9a77-0000f8756a10}", L"gradient"},
    {L"{4ccea634-fbe0-11d1-906a-00c04fd9189d}", L"pixelate"},
    {L"{af279b30-86eb-11d1-81bf-0000f87557db}", L"wipe"}
}; // rgEffectNames

#define SIZE_OF_EFFECT_TABLE (sizeof(rgEffectNames) / sizeof(EFFECTVALUE_PAIR))

static int
CompareEventValuePairsByName(const void *pv1, const void *pv2)
{
    return _wcsicmp(((EFFECTVALUE_PAIR*)pv1)->wzEffectName,
                    ((EFFECTVALUE_PAIR*)pv2)->wzEffectName);
} // CompareEventValuePairsByName

//*****************************************************************************

CEffectBvr::CEffectBvr() :
    m_pTransform(NULL),
    m_pSp(NULL),
    m_pHTMLDoc(NULL),
    m_pdispActor(NULL),
    m_lCookie(0)
{
    VariantInit(&m_varType);
    VariantInit(&m_varTransition);
    VariantInit(&m_varClassId);
    VariantInit(&m_varProgId);
    VariantInit(&m_varDirection);
    VariantInit(&m_varImage);
    m_clsid = CLSID_CrEffectBvr;
} // CEffectBvr

//*****************************************************************************

CEffectBvr::~CEffectBvr()
{
    ReleaseInterface(m_pTransform);
    ReleaseInterface(m_pSp);
    ReleaseInterface(m_pHTMLDoc);
    VariantClear(&m_varTransition);
    VariantClear(&m_varClassId);
    VariantClear(&m_varProgId);
    VariantClear(&m_varDirection);
    VariantClear(&m_varImage);
} // ~EffectBvr

//*****************************************************************************

HRESULT CEffectBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in effect behavior FinalConstruct initializing base classes");
        return hr;
    }

    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CEffectBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_EFFECT_PROPS);
    switch (iIndex)
    {
    case VAR_TYPE:
        return &m_varType;
        break;
    case VAR_CLASSID:
        return &m_varClassId;
        break;
    case VAR_TRANSITION:
        return &m_varTransition;
        break;
    case VAR_PROGID:
        return &m_varProgId;
        break;
    case VAR_DIRECTION:
        return &m_varDirection;
        break;
    case VAR_IMAGE:
        return &m_varImage;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CEffectBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_EFFECT_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::Init(IElementBehaviorSite *pBehaviorSite)
{

	if (pBehaviorSite == NULL) return E_FAIL;
	
	IDispatch * pDispDoc = NULL;
	
	HRESULT hr = SUPER::Init(pBehaviorSite);
	if (FAILED(hr)) goto done;
	
	hr = pBehaviorSite->QueryInterface(IID_IServiceProvider, (LPVOID *) &m_pSp );
	if (FAILED(hr)) goto done;

	hr = GetDAStatics()->put_ClientSite( this );
	if (FAILED(hr)) goto done;


	hr = GetHTMLElement()->get_document( &pDispDoc );
	if (FAILED(hr)) goto done;

	hr = pDispDoc->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&m_pHTMLDoc);
	if (FAILED(hr)) goto done;
	
  done:
	ReleaseInterface(pDispDoc);
	return hr;
} // Init

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::Notify(LONG event, VARIANT *pVar)
{
		
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;

} // Notify

//*****************************************************************************

STDMETHODIMP
CEffectBvr::Detach()
{
	ReleaseInterface(m_pSp);
	ReleaseInterface(m_pHTMLDoc);

	
	if( GetDAStatics() != NULL )
		GetDAStatics()->put_ClientSite( NULL );
	
	HRESULT hr = SUPER::Detach();

	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		//remove our behavior fragment from the actor
		hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		if( FAILED( hr ) )
		{

			ReleaseInterface( m_pdispActor );
			DPF_ERR( "Failed to remove behavior fragment from actor" );
			return hr;
		}

		m_lCookie = 0;
	}
	ReleaseInterface( m_pdispActor );

	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting type for element");
        return SetErrorInfo(hr);
    }

	//TODO: some more stuff here to remap dispids on the new effect
	
    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in get_type: invalid pointer");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_transition(VARIANT varTransition)
{
    HRESULT hr;
    hr = VariantCopy(&m_varTransition, &varTransition);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_transition copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_TRANSITION);
} // put_transition

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_transition(VARIANT *pRetTransition)
{
    if (pRetTransition == NULL)
    {
        DPF_ERR("Error in put_transition, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTransition, &m_varTransition);
} // get_transition

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_classid(VARIANT varClassId)
{
    HRESULT hr;
    hr = VariantCopy(&m_varClassId, &varClassId);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_classid copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_CLASSID);
} // put_classid

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_classid(VARIANT *pRetClassId)
{
    if (pRetClassId == NULL)
    {
        DPF_ERR("Error in get_classid, invalid pointer");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetClassId, &m_varClassId);
} // get_classid

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_progid(VARIANT varProgId)
{
    HRESULT hr;
    hr = VariantCopy(&m_varProgId, &varProgId);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_progid copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_PROGID);
} // put_progid

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_progid(VARIANT *pRetProgId)
{
    if (pRetProgId == NULL)
    {
        DPF_ERR("Error in get_progid, invalid pointer");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetProgId, &m_varProgId);
} // get_progid

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_direction(VARIANT varDirection)
{
    HRESULT hr;
    hr = VariantCopy(&m_varDirection, &varDirection);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_direction copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_DIRECTION);
} // put_direction

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_direction(VARIANT *pRetDirection)
{
    if (pRetDirection == NULL)
    {
        DPF_ERR("Error in get_direction, invalid pointer");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetDirection, &m_varDirection);
} // get_direction

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_image(VARIANT varImage)
{
    HRESULT hr;
    hr = VariantCopy(&m_varImage, &varImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_image copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_IMAGE);
} // put_image

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_image(VARIANT *pRetImage)
{
    if (pRetImage == NULL)
    {
        DPF_ERR("Error in get_image, invalid pointer");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetImage, &m_varImage);
} // get_image

//*****************************************************************************

HRESULT 
CEffectBvr::GetClassIdFromType(WCHAR **pwzClassId)
{
    DASSERT(pwzClassId != NULL);
    *pwzClassId = NULL;
    HRESULT hr;
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error converting type variant to bstr");
        return SetErrorInfo(hr);
    }
    EFFECTVALUE_PAIR EffectValue;
    EffectValue.wzEffectName = m_varType.bstrVal;

    EFFECTVALUE_PAIR *pReturnedEffect = (EFFECTVALUE_PAIR *)bsearch(&EffectValue,
                                                                    rgEffectNames,
                                                                    SIZE_OF_EFFECT_TABLE,
                                                                    sizeof(EFFECTVALUE_PAIR),
                                                                    CompareEventValuePairsByName);
    if (pReturnedEffect == NULL)
    {
        DPF_ERR("Error invalid type passed into effect");
        return SetErrorInfo(E_INVALIDARG);
    }
    *pwzClassId = pReturnedEffect->wzEffectClassid;
    return S_OK;
} // GetClassIdFromType

//*****************************************************************************

HRESULT 
CEffectBvr::BuildTransform()
{
    HRESULT hr;
    WCHAR *wzClassId;
    CLSID clsidConverted = GUID_NULL;
    
    ReleaseInterface(m_pTransform);
    // If we can get a classid from the type that was set, use that, otherwise
    // use the classid
    hr = GetClassIdFromType(&wzClassId);
    if (SUCCEEDED(hr))
    {
        hr = CLSIDFromString(wzClassId, &clsidConverted);
        if (FAILED(hr))
        {
            DPF_ERR("Could not get a classid from the bstr using type");
            return SetErrorInfo(hr);
        }
    }
    else
    {
        // try and convert the progid to a string
        if (m_varProgId.vt == VT_BSTR && m_varProgId.bstrVal != NULL)
        {
            // try the conversion
            hr = CLSIDFromProgID(m_varProgId.bstrVal, &clsidConverted); 
        }
        if (FAILED(hr) && m_varClassId.vt == VT_BSTR && m_varClassId.bstrVal != NULL)
        {
            // we need to form the string into the format that CLSIDFromString takes
            // the 3 below is for '{', '}', and null termination
            WCHAR *wzTemp = m_varClassId.bstrVal;
            CUtils::SkipWhiteSpace(&wzTemp);
            WCHAR rgwcTempClsid[EFFECT_CLASSID_LENGTH + 3];
            rgwcTempClsid[0] = L'{';
            rgwcTempClsid[EFFECT_CLASSID_LENGTH + 1] = L'}';
            rgwcTempClsid[EFFECT_CLASSID_LENGTH + 2] = 0;
            wcsncpy(&(rgwcTempClsid[1]), wzTemp,  EFFECT_CLASSID_LENGTH);
            wzClassId = rgwcTempClsid;
            hr = CLSIDFromString(wzClassId, &clsidConverted);
            if (FAILED(hr))
            {
                DPF_ERR("Could not get a classid from the bstr");
                return SetErrorInfo(hr);
            }
        }
        if (FAILED(hr)) 
        {
            DPF_ERR("Error no classid found for effect");
            return SetErrorInfo(E_INVALIDARG);
        }
    }

    hr = CoCreateInstance(clsidConverted,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDXTransform,
                          (void **)&m_pTransform);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating transform");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // BuildTransform

//*****************************************************************************

HRESULT 
CEffectBvr::BuildAnimationAsDABehavior()
{
	// TODO (markhal): This will go away when all behaviors talk to actor
	return S_OK;
}

STDMETHODIMP
CEffectBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
    if (m_pTransform == NULL)
        // nothing for us to do, is this an error
        // or do we return S_OK;
        return S_OK;

    HRESULT hr;

    //if our behavior fragment is already on an actor
    if( m_pdispActor != NULL && m_lCookie != 0 )
    {
        hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
        if( FAILED( hr ) )
        {
        	DPF_ERR("Failed to remove the behavior fragment from the actor");
        	return hr;
        }
        
        m_lCookie = 0;

        ReleaseInterface( m_pdispActor );
    }    

    // we need to determine how many inputs the transform takes
    // If there are two inputs, then we examine the transition
    // attribute to determine if the original image (from time) is the first or
    // second.  If there is one input, then we use the original image as the input,
    // otherwise we use NULL as the input.

    // First test for two inputs
    ULONG   cGuidsNeeded = 0;
    int cInputs = 0;
    // We use less than here, since the inputs to
    // the below function is an index (ie if youc all with 0, it supports 1 input)
    // So when the number equals the max, we have finished searching
    while (cInputs < EFFECT_MAX_INPUTS )
    {
        hr = m_pTransform->GetInOutInfo(FALSE, cInputs, NULL, NULL, &cGuidsNeeded, NULL);
        if (FAILED(hr))
        {
            DPF_ERR("Error testing transform for number of inputs");
            return SetErrorInfo(hr);
        }
        else if (hr == S_OK)
        {
            cInputs++;
        }
        else
        {
            DASSERT(hr == S_FALSE);
            break;
        }
    }
/*
    IHTMLElement *pAnimatedElement;
    hr = GetAnimatedParentElement(&pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining element to animate for effect");
        return hr;
    }

    IDAImage *pbvrOriginalImage = NULL;
    IDAImage *pbvrEmptyImage = NULL;

    
    hr = GetTIMEImageBehaviorFromElement(pAnimatedElement,
                                         &pbvrOriginalImage);
    ReleaseInterface(pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting original image form HTML TIME element");
        return hr;
    }
*/
	IDAImage *pbvrOriginalImage = NULL;
	IDAImage *pbvrTransitionImage = NULL;

	hr = GetImageFromActor(pActorDisp, &pbvrOriginalImage);

	if (FAILED(hr))
	{
		DPF_ERR("Error getting original image from actor");
		return hr;
	}

    IDABehavior *rgInputs[EFFECT_MAX_INPUTS];
    IDABehavior **ppbvrInputs = rgInputs;

    // If we need two inputs, create an Empty Image
    if (cInputs > 1)
    {
        hr = CUtils::InsurePropertyVariantAsBSTR(&m_varImage);
        if (SUCCEEDED(hr))
        {
			IDAImage *pdaimgEmpty = NULL;
			IDAImportationResult *pImportationResult = NULL;

			hr = GetDAStatics()->get_EmptyImage(&pdaimgEmpty);
			if( FAILED( hr ) )
			{
				DPF_ERR("Error creating empty image");
				goto failed;
			}

            hr = GetDAStatics()->ImportImageAsync(V_BSTR(&m_varImage), pdaimgEmpty, &pImportationResult);
			if( FAILED( hr ) )
			{
				DPF_ERR("Error calling import image async");
				goto failed;
			}

			hr = pImportationResult->get_Image( &pbvrTransitionImage );
			if( FAILED( hr ) )
			{
				DPF_ERR("Error calling get_Image on the importation result");
				goto failed;
			}

failed:
			ReleaseInterface( pdaimgEmpty );
			ReleaseInterface( pImportationResult );
            if (FAILED(hr) || (pbvrTransitionImage == NULL))
            {
                hr = GetDAStatics()->get_EmptyImage(&pbvrTransitionImage);
            }
        }
        else
        {
            hr = GetDAStatics()->get_EmptyImage(&pbvrTransitionImage);
        }
        
        if (FAILED(hr))
        {
            DPF_ERR("Error creating empty image");
            ReleaseInterface(pbvrOriginalImage);
            return SetErrorInfo(hr);
        }
        // Assume for now the transition is the input
        hr = CUtils::InsurePropertyVariantAsBSTR(&m_varTransition);
        if (SUCCEEDED(hr) && (_wcsicmp(m_varTransition.bstrVal, EFFECT_OUTPUT) == 0))
        {
            rgInputs[0] = pbvrOriginalImage;
            rgInputs[1] = pbvrTransitionImage;

        }
        else
        {
            rgInputs[1] = pbvrOriginalImage;
            rgInputs[0] = pbvrTransitionImage;
        }
    }
    else if (cInputs == 1)
    {
        rgInputs[0] = pbvrOriginalImage;
    }
    else
    {
        ppbvrInputs = NULL;
    }
/*
    hr = ApplyEffectBehaviorToAnimationElement(m_pTransform,
                                               ppbvrInputs,
                                               cInputs);
*/

	IDispatch *pdispThis = NULL;
	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispThis ) );
	if( FAILED( hr ) )
	{
		ReleaseInterface( pbvrOriginalImage );
		ReleaseInterface( pbvrTransitionImage );

		DPF_ERR("QI for IDispatch on the element failed");
		return hr;
	}

	hr = AttachEffectToActor(pActorDisp,
							 m_pTransform,
							 ppbvrInputs,
							 cInputs,
							 pdispThis,
							 &m_lCookie);

    ReleaseInterface(pbvrOriginalImage);
    ReleaseInterface(pbvrTransitionImage);

   	ReleaseInterface( pdispThis );
   	
    if (FAILED(hr))
    {
        DPF_ERR("Error applying transform to actor");
        return hr;
    }

    m_pdispActor = pActorDisp;
    m_pdispActor->AddRef();
    
    return S_OK;
} // BuildAnimationAsDABehavior

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetTypeInfoCount(/*[out]*/UINT FAR* pctinfo)
{
    // Patterned after ATL's IDispatchImpl::GetTypeInfoCount()
    if (NULL != pctinfo)
    {
        *pctinfo = 1;
        return S_OK;
    }
    else
    {
        return SetErrorInfo(E_POINTER);
    }
} // GetTypeInfoCount

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetTypeInfo(/*[in]*/UINT itinfo, 
                            /*[in]*/LCID lcid, 
                            /*[out]*/ITypeInfo ** pptinfo)
{
   return s_tihTypeInfo.GetTypeInfo(itinfo, lcid, pptinfo);;
} // GetTypeInfo

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetIDsOfNames(/*[in]*/REFIID riid,
                                /*[in,size_is(cNames)]*/LPOLESTR * rgszNames,
                                /*[in]*/UINT cNames,
                                /*[in]*/LCID lcid,
                                /*[out,size_is(cNames)]*/DISPID FAR* rgdispid)
{
    // Further processing to resolve our "custom DISPID" property
    // names correctly is handled in GetDispID and not directly
    // supported if the caller calls GetIDsOfNames directly, because this
    // is an IDispatch interface, and thus those properties aren't really
    // visible to IDispatch.
    return s_tihTypeInfo.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
} // GetIDsOfNames

//*****************************************************************************

STDMETHODIMP CEffectBvr::Invoke(/*[in]*/DISPID dispidMember,
                        /*[in]*/REFIID riid,
                        /*[in]*/LCID lcid,
                        /*[in]*/WORD wFlags,
                        /*[in,out]*/DISPPARAMS * pdispparams,
                        /*[out]*/VARIANT * pvarResult,
                        /*[out]*/EXCEPINFO * pexcepinfo,
                        /*[out]*/UINT * puArgErr)
{
    HRESULT hr;
    hr = s_tihTypeInfo.Invoke(static_cast<IDispatch*>(static_cast<ICrEffectBvr*>(this)), 
                              dispidMember,
                              riid, 
                              lcid, 
                              wFlags, 
                              pdispparams,
                              pvarResult, 
                              pexcepinfo, 
                              puArgErr);
    if (SUCCEEDED(hr))
        return hr;
    else
        return SetErrorInfo(hr);
} // Invoke

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetDispID(/*[in]*/BSTR bstrName,
                            /*[in]*/DWORD grfdex,
                            /*[out]*/DISPID *pid)
{
    HRESULT hr;
    
    if (NULL == pid)
        return E_POINTER;
    *pid = DISPID_UNKNOWN;
    hr = DISP_E_UNKNOWNNAME;
    
    // Note: We handle the case where we get called with fdexNameEnsure,
    //   which means that we *MUST* allocate a new DISPID for this BSTR, by
    //   essentially saying "sorry."  The code will fall through and return
    //   DISP_E_UNKNOWNNAME, even though a full IDispatchEx implementation is
    //   not *supposed* to.  That flag is used to allocate a "slot" for an
    //   expando property, which this implementation currently doesn't support.

    // Note: We don't pay attention to the case sensitive flag options in
    //   grfdex, because we're not required to, and because we're wrapping
    //   an IDispatch which is case insensitive anyway.

    hr = GetIDsOfNames(IID_NULL, &bstrName, 1, LOCALE_USER_DEFAULT, pid);

    if (DISP_E_UNKNOWNNAME == hr)
    {
        // GetIDsOfNames should have set the DISPID to DISPID_UNKNOWN
        DASSERT(DISPID_UNKNOWN == *pid);
        if (m_pTransform == NULL)
        {
            DPF_ERR("GetDispID error: unknown name, no transform present");
            return SetErrorInfo(hr);
        }

        IDispatch *pDisp;
        hr = m_pTransform->QueryInterface(IID_TO_PPV(IDispatch, &pDisp));
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing transform for IDispatch");
            return SetErrorInfo(hr);
        }
        hr = pDisp->GetIDsOfNames(IID_NULL, &bstrName, 1, LOCALE_USER_DEFAULT, pid);
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            DPF_ERR("Error in GetDispID, name unkown");
            return SetErrorInfo(hr);
        }
        // otherwise we got back a dispid, add in our offset
        *pid += EFFECT_BVR_DISPID_OFFSET;
    }
    return S_OK;
} // GetDispID

//*****************************************************************************

STDMETHODIMP CEffectBvr::InvokeEx(/*[in]*/DISPID dispidMember,
                        /*[in]*/LCID lcid,
                        /*[in]*/WORD wFlags,
                        /*[in]*/DISPPARAMS * pdispparams,
                        /*[in,out,unique]*/VARIANT * pvarResult,
                        /*[in,out,unique]*/EXCEPINFO * pexcepinfo,
                        /*[in,unique]*/IServiceProvider *pSrvProvider)
{
    // Check for any flags that aren't valid for Invoke but might
    // be passed to InvokeEx (for example, DISPATCH_CONSTRUCT).  If we
    // get any of those, we don't know how to handle them, so we fail the
    // call.
    if (wFlags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET
                    | DISPATCH_PROPERTYPUT| DISPATCH_PROPERTYPUTREF))
    {
        DPF(0, "Failing InvokeEx() call for DISPATCH_ flag that cannot be passed along to IDispatch::Invoke()");
        return SetErrorInfo(E_FAIL);
    }

    HRESULT hr;
    if (dispidMember >= EFFECT_BVR_DISPID_OFFSET)
    {
		if (m_pTransform == NULL)
		{
			DPF_ERR("InvokeEx called when transform is NULL");
			return SetErrorInfo(DISP_E_MEMBERNOTFOUND);
		}

        // we need to relay this InvokeEx to the transform
        dispidMember -= EFFECT_BVR_DISPID_OFFSET;
        IDispatch *pDisp;
        hr = m_pTransform->QueryInterface(IID_TO_PPV(IDispatch, &pDisp));
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing transform for IDispatch");
            return SetErrorInfo(hr);
        }
        hr = pDisp->Invoke(dispidMember, 
                           IID_NULL,
                           lcid, 
                           wFlags, 
                           pdispparams, 
                           pvarResult,
                           pexcepinfo, 
                           NULL);
        ReleaseInterface(pDisp);
        dispidMember += EFFECT_BVR_DISPID_OFFSET;
        if (FAILED(hr))
        {
            DPF_ERR("Error in InvokeEx calling transform");
            return SetErrorInfo(hr);
        }    
    }
    else
    {
        hr = Invoke(dispidMember, 
                    IID_NULL,
                    lcid, 
                    wFlags, 
                    pdispparams, 
                    pvarResult,
                    pexcepinfo, 
                    NULL);
        if (FAILED(hr))
        {
            DPF_ERR("Error in InvokeEx, error calling internal Invoke");
            return hr;
        }
    }
    return S_OK;
} // InvokeEx

//*****************************************************************************

STDMETHODIMP CEffectBvr::DeleteMemberByName(/*[in]*/BSTR bstr,
                                    /*[in]*/DWORD grfdex)
{
   return SetErrorInfo(E_NOTIMPL);;
} // DeleteMemberByName

//*****************************************************************************

STDMETHODIMP CEffectBvr::DeleteMemberByDispID(/*[in]*/DISPID id)
{
   return SetErrorInfo(E_NOTIMPL);
} // DeleteMemberByDispID

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetMemberProperties(/*[in]*/DISPID id,
                                    /*[in]*/DWORD grfdexFetch,
                                    /*[out]*/DWORD *pgrfdex)
{
   return SetErrorInfo(E_NOTIMPL);
} // GetMemberProperties

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetMemberName(/*[in]*/DISPID id,
                              /*[out]*/BSTR *pbstrName)
{
   return E_NOTIMPL;
} // GetMemberName

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetNextDispID(/*[in]*/DWORD grfdex,
                                /*[in]*/DISPID id,
                                /*[out]*/DISPID *prgid)
{
   return E_NOTIMPL;
} // GetNextDispID

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::GetNameSpaceParent(/*[out]*/IUnknown **ppunk)
{
   return SetErrorInfo(E_NOTIMPL);
} // GetNameSpaceParent

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::GetClassID(CLSID* pclsid)
{
    return SUPER::GetClassID(pclsid);
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::InitNew(void)
{
    return SUPER::InitNew();
} // InitNew

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    HRESULT hr;
    hr = SUPER::Load(pPropBag, pErrorLog);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling load for effect");
        return hr;
    }
    // we now need to try and build the transform
    hr = BuildTransform();
    if (FAILED(hr))
    {
        DPF_ERR("Error buiding transform");
        return hr;
    }
    DASSERT(m_pTransform != NULL);
    // we will now try and QI the transform for a IPersistPropertyBag
    IPersistPropertyBag *pIPPB;
    hr = m_pTransform->QueryInterface(IID_TO_PPV(IPersistPropertyBag, &pIPPB));
    if (SUCCEEDED(hr) && pIPPB != NULL)
    {
        // try and get a IPropertyBag from the IPRopertyBag2
        IPropertyBag *pPB;
        hr = pPropBag->QueryInterface(IID_TO_PPV(IPropertyBag, &pPB));
        if (SUCCEEDED(hr) && pPB != NULL)
        {
            hr = pIPPB->Load(pPB, pErrorLog);
            ReleaseInterface(pPB);
        }
        ReleaseInterface(pIPPB);
    }
    return S_OK;
} // Load

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr;
    hr = SUPER::Save(pPropBag, fClearDirty, fSaveAllProperties);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling save on effect");
        return hr;
    }
    if (m_pTransform != NULL)
    {
        // we will now try and QI the transform for a IPersistPropertyBag
        IPersistPropertyBag *pIPPB;
        hr = m_pTransform->QueryInterface(IID_TO_PPV(IPersistPropertyBag, &pIPPB));
        if (SUCCEEDED(hr) && pIPPB != NULL)
        {
            // try and get a IPropertyBag from the IPRopertyBag2
            IPropertyBag *pPB;
            hr = pPropBag->QueryInterface(IID_TO_PPV(IPropertyBag, &pPB));
            if (SUCCEEDED(hr) && pPB != NULL)
            {
                hr = pIPPB->Save(pPB, fClearDirty, fSaveAllProperties);
                ReleaseInterface(pPB);
            }
            ReleaseInterface(pIPPB);
        }
    }
    return S_OK;
} // Save 

//*****************************************************************************

HRESULT 
CEffectBvr::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

//
// IServiceProvider interfaces
//
STDMETHODIMP
CEffectBvr::QueryService(REFGUID guidService,
						 REFIID riid,
						 void** ppv)
{
    if (InlineIsEqualGUID(guidService, SID_SHTMLWindow))
    {
        IHTMLWindow2 *pWnd;
        HRESULT     hr;
        hr = m_pHTMLDoc->get_parentWindow(&pWnd);

        if (SUCCEEDED(hr) && (pWnd != NULL))
        {
            hr = pWnd->QueryInterface(riid, ppv);
            ReleaseInterface(pWnd);
            if (SUCCEEDED(hr))
            {
                return S_OK;
            }
        }
    }

    // Just delegate to our service provider

    return m_pSp->QueryService(guidService,
                               riid,
                               ppv);
}

//*****************************************************************************

HRESULT 
CEffectBvr::GetTIMEProgressNumber(IDANumber **ppbvrRet)
{
    DASSERT(ppbvrRet != NULL);
    *ppbvrRet = NULL;
    HRESULT hr;

    IDANumber *pbvrProgress;
    hr = SUPER::GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error retireving progress value from TIME");
        return hr;
    }
    
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varDirection);
    if ( SUCCEEDED(hr) && (0 == wcsicmp(m_varDirection.bstrVal, L"backwards")) )
    {
        // pbvrProgress = 1 - pbvrProgress
        IDANumber *pbvrOne;
        
        hr = CDAUtils::GetDANumber(GetDAStatics(), 1.0f, &pbvrOne);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating DANumber from 1.0f");
            ReleaseInterface(pbvrProgress);
            return hr;
        }

        IDANumber *pbvrTemp;
        hr = GetDAStatics()->Sub(pbvrOne, pbvrProgress, &pbvrTemp);
        ReleaseInterface(pbvrOne);
        ReleaseInterface(pbvrProgress);
        pbvrProgress = pbvrTemp;
        pbvrTemp = NULL;
        if (FAILED(hr))
        {
            DPF_ERR("Error creating 1-progress expression");
            return hr;
        }
    }
    *ppbvrRet = pbvrProgress;
    return S_OK;
} // GetTIMEProgressNumber

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\eventmgr.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventMgr.cpp
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#include "headers.h"
#include "eventmgr.h"
#include "mshtmdid.h"
#include "eventsink.h"
#include "dispex.h"
#include "axadefs.h"
#include "utils.h"


#define ATTACH              TRUE
#define DETACH              FALSE
#define MAXNAMELENGTH       50

#define THR(_arg) (_arg)
#define IGNORE_HR(_arg) (_arg)

struct {
    TIME_EVENT event;
    wchar_t * wsz_name;
} g_EventNames[] =
{
    { TE_ONBEGIN,         L"onbegin"         },
    { TE_ONPAUSE,         L"onpause"         },
    { TE_ONRESUME,        L"onresume"        },
    { TE_ONEND,           L"onend"           },
    { TE_ONRESYNC,        L"onresync"        },
    { TE_ONREPEAT,        L"onrepeat"        },
    { TE_ONREVERSE,       L"onreverse"       },
    { TE_ONMEDIACOMPLETE, L"onmediacomplete" },
};

OLECHAR *g_szEventName = L"TE_EventName";
OLECHAR *g_szRepeatCount = L"Iteration";


///////////////////////////////////////////////////////////////
//  Name: CEventMgr
//  Parameters:
//    CTIMEElement  & elm
//                               This parameter must be passed
//                               to the constructor so that 
//                               we can get info from elm
//
//  Abstract:
//    Stash away the element so we can get the OM when we need it
///////////////////////////////////////////////////////////////
CEventMgr::CEventMgr(IEventManagerClient* client)
: m_client(client),
  m_dwWindowEventConPtCookie(0),
  m_dwDocumentEventConPtCookie(0),
  m_pElement(NULL),
  m_pWindow(NULL),
  m_pWndConPt(NULL),
  m_pDocConPt(NULL),
  m_refCount(0),
  m_pEventSink(NULL),
  m_lastKeyMod(0),
  m_lastKey(0),
  m_lastKeyCount(0),
  m_hwndCurWnd(0),
  m_lastX(0),
  m_lastY(0),
  m_lastButton(0),
  m_lastMouseMod(0),
  m_pBeginElement(NULL),
  m_pEndElement(NULL),
  m_lBeginEventCount(0),
  m_lEndEventCount(0),
  m_bAttached(FALSE),
  m_lRepeatCount(0)
{

    // Zero out the cookies
    memset(m_cookies, 0, sizeof(m_cookies));

}

///////////////////////////////////////////////////////////////
//  Name: ~CEventMgr
//
//  Abstract:
//    Cleanup
///////////////////////////////////////////////////////////////
CEventMgr::~CEventMgr()
{
	if( m_pEventSink != NULL )
	{
		m_pEventSink->Deinit();
		delete m_pEventSink;
	}
}



   
///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Initializes the object
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Init()
{
    HRESULT hr;
    CComPtr <IDispatch> pDisp;
    CComPtr <IHTMLDocument2> pDoc;

    m_pElement = m_client->GetElementToSink();
    m_pElement->AddRef();

    m_pEventSink = new CEventSink(m_client, this);
    m_pEventSink->Init();

    
    hr = THR(ConnectToContainerConnectionPoint());

    if (FAILED(hr))
    {
        goto done;
    }

    //get a pointer to the window
    hr = THR(m_pElement->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDoc->get_parentWindow(&m_pWindow));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Deinit
//  Parameters:  None
//
//  Abstract:
//    Cleans up the object
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Deinit()
{
    if (m_dwWindowEventConPtCookie != 0 && m_pWndConPt)
    {
        m_pWndConPt->Unadvise (m_dwWindowEventConPtCookie);
    }

    if (m_dwDocumentEventConPtCookie != 0 && m_pDocConPt)
    {
        m_pDocConPt->Unadvise (m_dwDocumentEventConPtCookie);
    }

    if (m_pEventSink)
    {
        m_pEventSink->Deinit();
        delete m_pEventSink;
        m_pEventSink = NULL;
    }

    m_dwWindowEventConPtCookie = 0;
    m_dwDocumentEventConPtCookie = 0;

    // Zero out the cookies
    memset(m_cookies, 0, sizeof(m_cookies));
    
    if (m_pElement)
    {
        m_pElement->Release();
        m_pElement = NULL;
    }

    //cleanup memory
    if (m_pBeginElement)
    {
        delete m_pBeginElement;
    }
    if (m_pEndElement)
    {
        delete m_pEndElement;
    }
	
	m_pDocConPt.Release();
	m_pWndConPt.Release();
	m_pWindow.Release();

    return S_OK;
}

///////////////////////////////////////////////////////////////

HRESULT CEventMgr::AddMouseEventListener( LPUNKNOWN pUnkListener )
{
	if ( pUnkListener == NULL ) return E_POINTER;
	
	ListUnknowns::iterator	it;

	if ( FindUnknown( m_listMouseEventListeners, pUnkListener, it ) )
		return S_FALSE;

	// REVIEW: weak ref. to the listeners
	m_listMouseEventListeners.push_back( pUnkListener );
	
	return S_OK;
}

///////////////////////////////////////////////////////////////

HRESULT CEventMgr::RemoveMouseEventListener( LPUNKNOWN pUnkListener )
{
	if ( pUnkListener == NULL ) return E_POINTER;
	
	ListUnknowns::iterator	it;

	if ( !FindUnknown( m_listMouseEventListeners, pUnkListener, it ) )
		return S_FALSE;

	m_listMouseEventListeners.erase( it );
	
	return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: Attach
// 
//  Parameters:
//    BSTR Event        The element and event to sink to.  This
//                      parameter is in the form "Element.Event"
//                      where element is "this" if an event from
//                      the current element is to be attached to.
//    BOOL bAttach      True to indicate Attach to this event, and
//                      false to indicate Detach from this event.
//
//  Abstract:
//    This is a generic routine that allows both attaching to
//    and detaching from Trident events.  This function decodes
//    the event name to find the correct element
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Attach(BSTR Event, BOOL bAttach, IHTMLElement2 *pEventElement[], long Count)
{
    VARIANT_BOOL bSuccess = FALSE;
    HRESULT hr = S_OK;
    BSTR *EventName = NULL;
    BSTR *ElementName = NULL;
    int i = 0;


    //pElement = m_bvr.GetElement();

    hr = THR(GetEventName(Event, &ElementName, &EventName, Count));
    if (FAILED(hr))
    {
        goto done;
    }

    for (i = 0; i < Count; i++)
    {
        //get the element to attach to
        if (_wcsicmp(ElementName[i], L"this") == 0)
        {
            hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void **)&(pEventElement[i])));
            if (FAILED(hr))
            {
                continue;
            }

            hr = THR(pEventElement[i]->attachEvent(EventName[i], (IDispatch *)this, &bSuccess));
            if (FAILED(hr))
            {
                continue;
            }

            pEventElement[i]->AddRef();
        }
        else
        {
            if (bAttach == ATTACH)
            {
                CComPtr <IHTMLElement2> pSrcEle;
                CComPtr <IHTMLDocument2> pDoc2;
                CComPtr <IHTMLElementCollection> pEleCol;
                CComPtr <IDispatch> pSrcDisp;
                CComPtr <IDispatch> pDocDisp;
                CComPtr <IDispatchEx> pDispEx;

                //get the document
                hr = THR(m_pElement->get_document(&pDocDisp));
                if (FAILED(hr))
                {
                    continue;
                }

                hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2));
                if (FAILED(hr))
                {
                    continue;
                }

                //get all elements in the document
                hr = THR(pDoc2->get_all(&pEleCol));
                if (FAILED(hr))
                {
                    continue;
                }

                //find the element with the correct name
                VARIANT vName;
                VARIANT vIndex;

                VariantInit(&vName);
                vName.vt = VT_BSTR;
                vName.bstrVal = SysAllocString(ElementName[i]);

                VariantInit(&vIndex);
                vIndex.vt = VT_I2;
                vIndex.iVal = 0;

                hr = THR(pEleCol->item(vName, vIndex, &pSrcDisp));
                if (FAILED(hr))
                {
                    SysFreeString(vName.bstrVal);
                    VariantClear(&vName);
                    VariantClear(&vIndex);
                    continue;
                }
                SysFreeString(vName.bstrVal);
                VariantClear(&vName);
                VariantClear(&vIndex);

                if (!pSrcDisp) //will be NULL if the vName is invalid element.
                {
                    pEventElement[i] = NULL;
                    continue;
                }

                hr = THR(pSrcDisp->QueryInterface(IID_IHTMLElement2, (void**)&pSrcEle));
                if (FAILED(hr))
                {
                    continue;
                }

                //cache the IHTMLElement2 pointer for use on detach
                pEventElement[i] = pSrcEle;
                pEventElement[i]->AddRef();

                hr = THR(pSrcDisp->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
                if (SUCCEEDED(hr))
                {
                    //determine if this is a valid event
                    DISPID temp;

                    hr = THR(pDispEx->GetDispID(EventName[i], fdexNameCaseSensitive, &temp));
                    if (SUCCEEDED(hr))
                    {
                        hr = THR(pSrcEle->attachEvent(EventName[i], (IDispatch *)this, &bSuccess));
                    }
                }
            }
            else
            {
                if (pEventElement[i])
                {
                    CComPtr <IDispatchEx> pDispEx;

                    hr = THR(pEventElement[i]->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
                    if (SUCCEEDED(hr))
                    {
                        //determine if this is a valid event
                        DISPID temp;
                        
                        hr = THR(pDispEx->GetDispID(EventName[i], fdexNameCaseSensitive, &temp));
                        if (SUCCEEDED(hr))
                        {
                            hr = THR(pEventElement[i]->detachEvent(EventName[i], (IDispatch *)this));
                        }

                    }
                    pEventElement[i]->Release();
                    pEventElement[i] = NULL;
                }
            }
        }
    }

  done:

    if (EventName)
    {
        for (i = 0; i < Count; i++)
        {
            SysFreeString(EventName[i]);
            SysFreeString(ElementName[i]);
        }
        delete[] EventName;
        delete[] ElementName;
    }
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: ConnectToContainerConnectionPoint
// 
//  Abstract:
//    Finds a connection point on the HTMLDocument interface
//    and passes this as an event handler.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::ConnectToContainerConnectionPoint()
{
    // Get a connection point to the container
    CComPtr<IConnectionPointContainer> pWndCPC;
    CComPtr<IConnectionPointContainer> pDocCPC; 
    CComPtr<IHTMLDocument> pDoc; 
    CComPtr<IDispatch> pDocDispatch;
    CComPtr<IDispatch> pScriptDispatch;

    HRESULT hr;

    hr = THR(m_pElement->get_document(&pDocDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //get the document and cache it.
    hr = THR(pDocDispatch->QueryInterface(IID_IHTMLDocument, (void**)&pDoc));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the documents events
    hr = THR(pDoc->QueryInterface(IID_IConnectionPointContainer, (void**)&pDocCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pDocCPC->FindConnectionPoint( DIID_HTMLDocumentEvents, &m_pDocConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    
    hr = THR(m_pDocConPt->Advise((IUnknown *)this, &m_dwDocumentEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the windows events
    hr = THR(pDoc->get_Script (&pScriptDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pScriptDispatch->QueryInterface(IID_IConnectionPointContainer, (void**)&pWndCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    } 

    hr = THR(pWndCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &m_pWndConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pWndConPt->Advise((IUnknown *)this, &m_dwWindowEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: QueryInterface
// 
//  Abstract:
//    This QI only handles the IDispatch for HTMLWindowEvents
//    and returns this as the interface.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch) || InlineIsEqualGUID(riid, DIID_HTMLWindowEvents))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

///////////////////////////////////////////////////////////////
//  Name: AddRef
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch  
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::AddRef(void)
{
    return ++m_refCount;
}

///////////////////////////////////////////////////////////////
//  Name: Release
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::Release(void)
{
    m_refCount--;
    if (m_refCount == 0)
    {
        //delete this;
    }

    return m_refCount;
}



///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//    This switches on the dispid looking for dispid's of events
//    that it should handle.  Note, this is called for all events
//    fired from the window, only the selected events are handled.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pVarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    // Listen for the two events we're interested in, and call back if necessary
    HRESULT hr = S_OK;

    switch (dispIdMember)
    {
        case 0: //this is the case for events that have been hooked using attachEvent
        {
            CComPtr <IHTMLEventObj> pEventObj;
            BSTR bstrEventName; 
            BSTR bstrElementName;
    
            hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
            if (FAILED(hr))
            {
                goto done;
            }
            THR(pEventObj->get_type(&bstrEventName));

            break;
        }
        
        case DISPID_EVPROP_ONPROPERTYCHANGE:
        case DISPID_EVMETH_ONPROPERTYCHANGE:
            break;


        case DISPID_EVPROP_ONMOUSEMOVE:
        case DISPID_EVMETH_ONMOUSEMOVE:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                CComPtr <IHTMLEventObj> pEventObj;
                long x, y, button;
                VARIANT_BOOL bMove, bUp, bShift, bAlt, bCtrl;

                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                bMove = TRUE;
                bUp = FALSE;
                hr = THR(pEventObj->get_x(&x));
                hr = THR(pEventObj->get_y(&y));
                hr = THR(pEventObj->get_shiftKey(&bShift));
                hr = THR(pEventObj->get_altKey(&bAlt));
                hr = THR(pEventObj->get_ctrlKey(&bCtrl));
                hr = THR(pEventObj->get_button(&button));
                MouseEvent(x, y, bMove, bUp, bShift, bAlt, bCtrl, button);
                
                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
            break;

        case DISPID_EVPROP_ONMOUSEUP:
        case DISPID_EVMETH_ONMOUSEUP:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                CComPtr <IHTMLEventObj> pEventObj;
                long x, y, button;
                VARIANT_BOOL bMove, bUp, bShift, bAlt, bCtrl;

                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                bMove = FALSE;
                bUp = TRUE;
                hr = THR(pEventObj->get_x(&x));
                hr = THR(pEventObj->get_y(&y));
                hr = THR(pEventObj->get_shiftKey(&bShift));
                hr = THR(pEventObj->get_altKey(&bAlt));
                hr = THR(pEventObj->get_ctrlKey(&bCtrl));
                hr = THR(pEventObj->get_button(&button));
                MouseEvent(x, y, bMove, bUp, bShift, bAlt, bCtrl, button);
                
                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
            break;

 
        case DISPID_EVPROP_ONMOUSEOUT:
        case DISPID_EVMETH_ONMOUSEOUT:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                CComPtr <IHTMLEventObj> pEventObj;
                
                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                MouseEvent(m_lastX, 
                           m_lastY, 
                           FALSE, 
                           TRUE, 
                           m_lastMouseMod & AXAEMOD_SHIFT_MASK, 
                           m_lastMouseMod & AXAEMOD_ALT_MASK, 
                           m_lastMouseMod & AXAEMOD_CTRL_MASK, 
                           m_lastButton);

                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
        
            break;

        case DISPID_EVPROP_ONLOAD:
        case DISPID_EVMETH_ONLOAD:
            m_bAttached = TRUE;
            //THR(AttachEvents());
            m_client->OnLoad();
            if (m_pEventSink)
            {
                IGNORE_HR(m_pEventSink->InitMouse());
            }
            break;

        case DISPID_EVPROP_ONUNLOAD:
        case DISPID_EVMETH_ONUNLOAD:
            m_client->OnUnload();    
            //THR(DetachEvents());
            break;

    }
  done:
    return S_OK;
}




///////////////////////////////////////////////////////////////
//  Name: GetEventCount
// 
//  Abstract:
//    Counts the number of events in an EventString where events
//    are separated by ';' or NULL terminated.
///////////////////////////////////////////////////////////////
long CEventMgr::GetEventCount(BSTR bstrEvent)
{
    long curCount = 0;
    OLECHAR *curChar;
    
    curChar = bstrEvent;

    while (*curChar != '\0')
    {
        curChar++;
        if ((*curChar == ';') || ((*curChar == '\0') && ((*curChar - 1) != ';')))
        {
            curCount++;
        }
    }

    return curCount;
}


///////////////////////////////////////////////////////////////
//  Name: GetEventName
// 
//  Abstract:
//    This gets the event names from a string that has the format
//    EventName()  It only handles strings like 
//    ElementName.EventName().  It can also handle the OR'ing of
//    event names using ";".  So Element1.Event1();Element2.Event2();...
//    can be handled.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::GetEventName(BSTR bstrEvent, BSTR **pElementName, BSTR **pEventName, long Count)
{
    BSTR bstrEventName;
    OLECHAR sTemp[MAXNAMELENGTH];
    OLECHAR *curChar;
    int i = 0, j = 0;
    HRESULT hr = S_OK;
    BSTR bstrTempEvent = NULL;
    BSTR bstrTempElement = NULL;

    BSTR *bstrEventList = NULL;
    BSTR *bstrElementList = NULL;

    bstrElementList = new BSTR [Count];
    if (bstrElementList == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    
    bstrEventList = new BSTR [Count];
    if (bstrEventList == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    
    ZeroMemory(pElementName, (sizeof (BSTR *) * Count));
    ZeroMemory(pEventName, (sizeof (BSTR *) * Count));

    curChar = bstrEvent;
    for (j = 0; j < Count; j++)
    {
        //get the element name
        ZeroMemory(sTemp, sizeof(OLECHAR) * MAXNAMELENGTH);
        
		i = 0;
        //step through the bstr looking for \0 or the '.' or ';'
        while (i < MAXNAMELENGTH - 1 && *curChar != '\0' && *curChar != '.' && *curChar != ';')
        {
            if (*curChar != ' ')  //need to strip out spaces.
            {
                sTemp[i] = *curChar;
            }
            i++;
            curChar++;
        }
        
        if (*curChar != '.')
        {
            hr = E_FAIL;
            goto done;
        }
		
        bstrTempElement = SysAllocString(sTemp);
        bstrElementList[j] = bstrTempElement; 

        //get the event name
        ZeroMemory(sTemp, sizeof(OLECHAR) * MAXNAMELENGTH);

        curChar++;
        i = 0;
        //step through the bstr looking for \0 or the ';'
        while (i < MAXNAMELENGTH - 1 && *curChar != ';' && *curChar != '\0')
        {
            if (*curChar != ' ')  //need to strip out spaces.
            {
                sTemp[i] = *curChar;
            }
            i++;
            curChar++;
        }
        
        if (i == MAXNAMELENGTH)
        {
            hr = E_FAIL;
            goto done;
        }
        bstrTempEvent = SysAllocString(sTemp);
        bstrEventList[j] = bstrTempEvent;

        //advance curChar to the next element or the end of the string
        if (j < Count - 1)
        {
            while (*curChar != ';' && *curChar != '\0')
            {
                curChar++;
            }
            if (*curChar == ';') 
            {
                curChar++;
            }
            if (*curChar == '\0')
            {
                goto done;
            }
        }
    }

  done:
    if (SUCCEEDED(hr))
    {
        *pElementName = bstrElementList;
        *pEventName = bstrEventList;
    }
    else //cleanup code
    {
        for (i = 0; i < j; i++)
        {
            if (bstrEventList)
            {
                SysFreeString(bstrEventList[i]);
            }
            if (bstrElementList)
            {
                SysFreeString(bstrElementList[i]);
            }
        }
        if (bstrElementList)
        {
            delete[] bstrElementList;
        }
        if (bstrEventList)
        {
            delete[] bstrEventList;
        }
    }
    return hr;   
}

///////////////////////////////////////////////////////////////
//  Name: MatchEvent
// 
//  Parameters:
//    BSTR bstrEvent            The cached event name in the format
//                              "Elementname.EventName".
//    IHTMLEventObj *pEventObj  A pointer to the event object that is
//                              passed into IDispatch::Invoke.
//
//  Abstract:
//    Determines if the event that was just hooked matches
//    the event specified in bstrEvent.
///////////////////////////////////////////////////////////////
bool CEventMgr::MatchEvent(BSTR bstrEvent, IHTMLEventObj *pEventObj, long Count)
{
    bool bMatch = FALSE;
    BSTR *bstrExpEventName = NULL; 
    BSTR *bstrExpElementName = NULL;
    BSTR bstrEventName = NULL;
    BSTR bstrElementName = NULL;
    HRESULT hr = S_OK;
    CComPtr <IHTMLEventObj2> pEventObj2;

    int i = 0;

    hr = THR(pEventObj->get_type(&bstrEventName));
    
    //hack to work around eventobject problems
    if (!bstrEventName)
    {
        hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
        if (FAILED(hr))
        {
            goto done;
        }
        VARIANT vTemp;
        VariantInit(&vTemp);
        pEventObj2->getAttribute(g_szEventName, 0, &vTemp);
        SysFreeString(bstrEventName );
        bstrEventName  = SysAllocString(vTemp.bstrVal);
        SysFreeString(vTemp.bstrVal);
        VariantClear(&vTemp);
    }

    hr = THR(GetEventName(bstrEvent, &bstrExpElementName, &bstrExpEventName, Count));
    if (FAILED(hr))
    {
        goto done;
    }
    
    for (i = 0; i < Count; i++)
    {
        //check that the event names match
        if (_wcsicmp(bstrExpEventName[i] + 2, bstrEventName) == 0 || _wcsicmp(bstrExpEventName[i], bstrEventName) == 0)
        {
            //check that the Element name matches
            CComPtr <IHTMLElement> pEle;

            hr = THR(pEventObj->get_srcElement(&pEle));
            if (FAILED(hr))
            {
                goto done;
            }
         
            //get the source element name
            THR(pEle->get_id(&bstrElementName));
        
            //handle the "this" string as an element name
            if (_wcsicmp(bstrExpElementName[i], L"this") == 0)
            {
                BSTR bstrName;
                hr = THR(m_pElement->get_id(&bstrName));
                if (FAILED(hr))
                {
                    SysFreeString(bstrName);
                    goto done;
                }

                if (_wcsicmp(bstrElementName, bstrName) == 0)
                {
                    bMatch = TRUE;          
                    SysFreeString(bstrName);
                    SysFreeString(bstrElementName);
                    goto done;
                }

            }
            else if (_wcsicmp(bstrExpElementName[i], bstrElementName) == 0)
            {
                bMatch = TRUE;          
                SysFreeString(bstrElementName);
                goto done;
            }
        }
        if (bstrElementName)
        {
            SysFreeString(bstrElementName);
        }
    }

  done:
    if (bstrExpEventName)
    {
        for (i = 0; i < Count; i++)
        {
            if (bstrExpEventName)
            {
                SysFreeString(bstrExpEventName[i]);
            }
            if (bstrExpElementName)
            {
                SysFreeString(bstrExpElementName[i]);
            }
        }
        if (bstrExpEventName)
        {
            delete[] bstrExpEventName;
        }
        if (bstrExpElementName)
        {
            delete[] bstrExpElementName;
        }
    }
    return bMatch;
}

///////////////////////////////////////////////////////////////
//  Name: ReadyStateChange
// 
//  Parameters:
//      BSTR ReadyState             a string containing the 
//                                  current ready state.  Possible
//                                  values are "complete" or
//                                  "interactive".  Only "complete"
//                                  is currently used.
//
//  Abstract:
//    This method is called from the EventSink class to 
//    notify the event manager that the readystatechange
//    event has occured.
///////////////////////////////////////////////////////////////
void CEventMgr::ReadyStateChange(BSTR ReadyState)
{   
    if ( _wcsicmp( ReadyState, L"complete" ) == 0 )
	{
		m_client->OnReadyStateChange( EVTREADYSTATE_COMPLETE );
	}
	else if ( _wcsicmp( ReadyState, L"interactive") == 0 )
    {
        m_client->OnReadyStateChange( EVTREADYSTATE_INTERACTIVE );
    }
}



///////////////////////////////////////////////////////////////
//  Name: PropertyChange
// 
//  Parameters:
//      BSTR PropertyName           The name of the property
//                                  that has changed.
//
//  Abstract:
//    This method is called from the EventSink class to 
//    notify the event manager that a propertychange event 
//    has occured.
///////////////////////////////////////////////////////////////
void CEventMgr::PropertyChange(BSTR PropertyName)
{
    //////////////////////////////////////
    //UNDONE:
    // do something to notify the element
    // that the a property has changed
    //
    // QUESTION: 
    // should this look for t:propertyname,
    // t_propertyname, or just propertyname?
    //////////////////////////////////////
}

///////////////////////////////////////////////////////////////
//  Name: MouseEvent
// 
//  Parameters:
//    long x                    The current x coordinate 
//    long y                    The current y coordinate
//    VARIANT_BOOL bMove        True if this is a mouse move event
//    VARIANT_BOOL bUp          True if this is a mouse up event
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
//    long button               Mousebutton that triggered the
//                              event. Possible values are:
//                                  1 for left
//                                  2 for right
//                                  4 for middle
// 
//  Abstract:
//    This method is called from the EventSink class to 
//    notify the event manager that a Mouse event
//    has occured on the element.
///////////////////////////////////////////////////////////////
void CEventMgr::MouseEvent(long x, 
                           long y, 
                           VARIANT_BOOL bMove,
                           VARIANT_BOOL bUp,
                           VARIANT_BOOL bShift, 
                           VARIANT_BOOL bAlt,
                           VARIANT_BOOL bCtrl,
                           long button)
{
	HRESULT		hr;
	hr = m_client->TranslateMouseCoords( x, y, &x, &y );
	if ( FAILED(hr) ) return;
	
	ListUnknowns::iterator it;

	OLECHAR		*rgNames[] = { L"mouseEvent" };
	DISPID		dispidMouseEvent;
	DISPPARAMS	params;
	VARIANTARG	rgvargs[8];
    int			cArgs = 8;
	VARIANT		varResult;
	EXCEPINFO	excepInfo;
	UINT		iArgErr;

	int			iArg = 0;

	rgvargs[iArg++] = CComVariant( button );
	rgvargs[iArg++] = CComVariant( bCtrl );
	rgvargs[iArg++] = CComVariant( bAlt );
	rgvargs[iArg++] = CComVariant( bShift );
	rgvargs[iArg++] = CComVariant( bUp );
	rgvargs[iArg++] = CComVariant( bMove );
	rgvargs[iArg++] = CComVariant( y );
	rgvargs[iArg++] = CComVariant( x );
	
	params.rgvarg				= rgvargs;
	params.cArgs				= cArgs;
	params.rgdispidNamedArgs	= NULL;
	params.cNamedArgs			= 0;
	
	for ( it = m_listMouseEventListeners.begin();
		  it != m_listMouseEventListeners.end();
		  it++ )
	{
		CComQIPtr<IDispatch, &IID_IDispatch> pDispListener( *it );

		hr = pDispListener->GetIDsOfNames( IID_NULL,
										   rgNames,
										   1,
										   LOCALE_SYSTEM_DEFAULT,
										   &dispidMouseEvent );
		if ( FAILED(hr) ) continue;

		hr = pDispListener->Invoke( dispidMouseEvent,
									IID_NULL,
									LOCALE_SYSTEM_DEFAULT,
									DISPATCH_METHOD,
									&params,
									&varResult,
									&excepInfo,
									&iArgErr );
	}
}
    

///////////////////////////////////////////////////////////////
//  Name: KeyEvent
// 
//  Parameters:
//    VARIANT_BOOL bLostFocus   True if there was a lost focus event
//    VARIANT_BOOL bUp          True if this is a KeyUp Event
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
//    long KeyCode              The unicode keycode for the key
// 
//  Abstract:
//    This method is called from the EventSink class to 
//    notify the event manager that a KeyBoard event
//    has occured on the element.
///////////////////////////////////////////////////////////////
void CEventMgr::KeyEvent(VARIANT_BOOL bLostFocus,
                         VARIANT_BOOL bUp,
                         VARIANT_BOOL bShift, 
                         VARIANT_BOOL bAlt,
                         VARIANT_BOOL bCtrl,
                         long KeyCode, 
                         long RepeatCount)
{
}  

///////////////////////////////////////////////////////////////
//  Name: GetModifiers
// 
//  Parameters:
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
// 
//  Abstract:
///////////////////////////////////////////////////////////////
BYTE CEventMgr::GetModifiers(VARIANT_BOOL bShift, VARIANT_BOOL bCtrl, VARIANT_BOOL bAlt)
{
    BYTE mod = AXAEMOD_NONE;

    if (bShift) mod |= AXAEMOD_SHIFT_MASK ;
    if (bCtrl) mod |= AXAEMOD_CTRL_MASK ;
    if (bAlt) mod |= AXAEMOD_ALT_MASK ;

    return mod;
}

bool CEventMgr::FindUnknown( const ListUnknowns& listUnknowns, LPUNKNOWN pUnk, ListUnknowns::iterator& itFound )
{
	ListUnknowns::iterator	it;
	for ( it = listUnknowns.begin(); it != listUnknowns.end(); it++ )
	{
		if ( *it == pUnk )
		{
			itFound = it;
			return true;
		}
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\elementprop.cpp ===
//*****************************************************************************
//
// Microsoft LMRT
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:        elementevent.cpp
//
// Author:          KurtJ
//
// Created:         2/14/99
//
// Abstract:        Sinks IHTMLElement events.
//
// Modifications:
// 1/14/98 KurtJ Created this file
//
//*****************************************************************************

#include "headers.h"

#include "elementprop.h"

#define LOCALTIME_NAME L"localTime"

CElementPropertyMonitor::CElementPropertyMonitor():
    m_pLocalTimeListener( NULL ),
    m_dwElementPropertyConPtCookie( 0 ),
    m_pconptElement( NULL ),
    m_pelemElement( NULL ),
    m_refCount( 0 ),
	m_dispidLocalTime( -1 ),
	m_pdispElement( NULL )
{
}

//*****************************************************************************

CElementPropertyMonitor::~CElementPropertyMonitor()
{
    if( m_pelemElement != NULL )
        Detach();
}

//*****************************************************************************
//IUnknown
//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::QueryInterface( REFIID riid, void** ppv)
{
    if( ppv == NULL )
        return E_POINTER;

    if( riid == IID_IPropertyNotifySink )
    {
        (*ppv) = static_cast<IPropertyNotifySink*>(this);
    }
	else if( riid == IID_IUnknown )
	{
		(*ppv) = static_cast<IUnknown*>(this);
	}
    else
    {
        (*ppv) = NULL;
        return E_NOINTERFACE;
    }

    static_cast<IUnknown*>(*ppv)->AddRef();

    return S_OK;
}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CElementPropertyMonitor::AddRef()
{
    m_refCount++;
    return m_refCount;
}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CElementPropertyMonitor::Release()
{
    ULONG refs = --m_refCount;

    if( refs == 0 )
        delete this;

    return refs;
}

//*****************************************************************************
//IPropertyNotifySink
//*****************************************************************************


STDMETHODIMP
CElementPropertyMonitor::OnChanged( DISPID dispid )
{
	//check to see if one of the properties we are watching has changed
	if( dispid == m_dispidLocalTime && m_pLocalTimeListener != NULL)
	{
		ProcessLocalTimeChange();
	}

	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::OnRequestEdit( DISPID dispid )
{
	return S_OK;
}


//*****************************************************************************
//IElementEventMonitor
//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::SetLocalTimeListener( IElementLocalTimeListener *pListener )
{
    m_pLocalTimeListener = pListener;

    return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::Attach( IHTMLElement* pelemToListen )
{
    if( pelemToListen == NULL )
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    if( m_pelemElement != NULL )
    {
        DetachFromElementConPt();
        ReleaseInterface( m_pelemElement );
		ReleaseInterface( m_pdispElement );
    }
    
    //hold on to the element
    m_pelemElement = pelemToListen;
    m_pelemElement->AddRef();

	//get IDispatch off of the element to which we are attaching
	hr = m_pelemElement->QueryInterface( IID_TO_PPV( IDispatch, &m_pdispElement ) );
	CheckHR( hr, "QI for IDispatch on element failed", end );

    //attach to the element
    hr = AttachToElementConPt( );
    CheckHR( hr, "Failed to connect to the element connection point", end );

	UpdateDISPIDCache();

end:
    if( FAILED( hr ) )
    {
        ReleaseInterface( m_pelemElement );
		ReleaseInterface( m_pdispElement );
    }

    return hr;
}

//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::Detach()
{
    HRESULT hr = S_OK;
    if( m_pelemElement != NULL )
    {
        hr = DetachFromElementConPt();
    }

	m_dispidLocalTime = -1;

    ReleaseInterface( m_pelemElement );
	ReleaseInterface( m_pdispElement );

    return hr;
}

//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::UpdateDISPIDCache()
{
	if( m_pdispElement == NULL )
	{
		m_dispidLocalTime = -1;
		return S_OK;
	}

	LPOLESTR name = LOCALTIME_NAME;

	HRESULT hr = S_OK;
	//find the dispid of local time on the element
	hr = m_pdispElement->GetIDsOfNames( IID_NULL,
										&name,
										1,
										LCID_SCRIPTING,
										&m_dispidLocalTime
									   );

	if( FAILED( hr ) )
	{
		m_dispidLocalTime = -1;
	}

	return S_OK;
}


//*****************************************************************************
//private methods
//*****************************************************************************


HRESULT
CElementPropertyMonitor::ProcessLocalTimeChange( )
{
	if( m_pdispElement == NULL || m_pLocalTimeListener == NULL )
	{
		return S_OK;
	}

	HRESULT hr = S_OK;

	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
	VARIANT varResult;

	::VariantInit( &varResult );


	//get the value of local time from the element

	hr = m_pdispElement->Invoke( m_dispidLocalTime, 
								 IID_NULL, 
								 LCID_SCRIPTING, 
								 DISPATCH_PROPERTYGET, 
								 &dispparamsNoArgs, 
								 &varResult, 
								 NULL, 
								 NULL );
	CheckHR( hr, "Failed to invoke the local time dispatch on the element", end );
	
	if( V_VT( &varResult ) != VT_R4 )
	{
		hr = ::VariantChangeTypeEx( &varResult, &varResult, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4 );
		CheckHR( hr, "Failed to change the type of local time to a double", end );
	}


	//call onLocalTimeChange on the listener
	m_pLocalTimeListener->OnLocalTimeChange( V_R4( &varResult ) );

end:
	::VariantClear( &varResult );

	return hr;
}

//*****************************************************************************

HRESULT
CElementPropertyMonitor::AttachToElementConPt()
{
    if( m_pelemElement == NULL )
        return E_FAIL;

    HRESULT hr = S_OK;

    IConnectionPointContainer   *pContainer = NULL;

    hr = m_pelemElement->QueryInterface( IID_TO_PPV( IConnectionPointContainer, &pContainer ) );
    CheckHR( hr, "QI for IConnectionPointContainer on IHTMLElement Failed", end );

    hr= pContainer->FindConnectionPoint( IID_IPropertyNotifySink, &m_pconptElement );
    CheckHR( hr, "Failed to find the connection point for element envents", end );

    hr = m_pconptElement->Advise( static_cast<IUnknown *>(this), &m_dwElementPropertyConPtCookie );
    CheckHR( hr, "Failed to connect to the element connection point", end );

end:
    ReleaseInterface( pContainer );

    return hr;

}

//*****************************************************************************

HRESULT
CElementPropertyMonitor::DetachFromElementConPt( )
{
    if( m_pconptElement == NULL || m_dwElementPropertyConPtCookie == 0 )
        return E_FAIL;

    HRESULT hr = S_OK;

    hr = m_pconptElement->Unadvise( m_dwElementPropertyConPtCookie );
    CheckHR( hr, "Failed to unadvise the connection point", end );

    ReleaseInterface( m_pconptElement );

end:

    return hr;
}

//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\headers.h ===
#pragma once
#ifndef CRBVR_HEADERS_HXX
#define CRBVR_HEADERS_HXX
//*****************************************************************************
//
// Microsoft Chrome
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    headers.h
//
// Author:	    jeffort
//
// Created:	    10/07/98
//
// Abstract:    default headers for this project
// Modifications:
// 10/07/98 jeffort created file
//
//*****************************************************************************

/* Standard */
#include <math.h>
//#ifdef DEBUGMEM
//#include "crtdbg.h"
//#endif
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#ifndef _NO_CRT
#include <ios.h>
#include <fstream.h>
#include <iostream.h>
#include <ostream.h>
#include <strstrea.h>
#include <istream.h>
#include <ctype.h>
#include <sys/types.h>
#endif
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// ATL - needs to be before windows.h

#define _ATL_NO_DEBUG_CRT 1

#ifdef _DEBUG
#undef _ASSERTE
#endif

#define _ASSERTE(expr) ((void)0)

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

/* Windows */
#include <windows.h>
#include <windowsx.h>

#include <mshtmhst.h>
#include <mshtml.h>
#include <mshtmdid.h>

#include <ddraw.h>
#include <danim.h>

// CrBvr utilities
#include "..\include\utils.h"
#include "..\include\defaults.h"

//#define CRSTANDALONE 1
#ifdef CRSTANDALONE
    #include <crbvr.h>
#else
    #include <lmrt.h>
#endif // CRSTANDALONE

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif // CRBVR_HEADERS_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\factory.cpp ===
//*****************************************************************************
//
// File: factory.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CCrBehaviorFactory object which implements
//			 the chromeffects factory for DHTML behaviors
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/21/98 jeffort     Changed FindBehavior from using class to using the tag
//                      to determine the behavior type being created
// 11/12/98 markhal     FindBehavior now accepts null arguments 
//
//*****************************************************************************
#include "headers.h"

#include "factory.h"
#include "colorbvr.h"
#include "rotate.h"
#include "scale.h"
#include "move.h"
#include "path.h"
#include "number.h"
#include "set.h"
#include "actorbvr.h"
#include "attrib.h"
#include "effect.h"
#include "action.h"

#include "datime.h"

#define WZ_TIMEDA_URN L"#time#da"

//*****************************************************************************

ECRBEHAVIORTYPE 
CCrBehaviorFactory::GetBehaviorTypeFromBstr(BSTR bstrBehaviorType)
{
    DASSERT(bstrBehaviorType != NULL);
    // If this list grows to be too long,
    // we should consider a binary search, but for eight behaviors, compare
    // is OK
	if (_wcsicmp(BEHAVIOR_TYPE_COLOR, bstrBehaviorType) == 0)
        return crbvrColor;
	else if (_wcsicmp(BEHAVIOR_TYPE_ROTATE, bstrBehaviorType) == 0)
        return crbvrRotate;
    else if (_wcsicmp(BEHAVIOR_TYPE_SCALE, bstrBehaviorType) == 0)
        return crbvrScale;
    else if (_wcsicmp(BEHAVIOR_TYPE_SET, bstrBehaviorType) == 0)
        return crbvrSet;
    else if (_wcsicmp(BEHAVIOR_TYPE_NUMBER, bstrBehaviorType) == 0)
        return crbvrNumber;
    else if (_wcsicmp(BEHAVIOR_TYPE_MOVE, bstrBehaviorType) == 0)
        return crbvrMove;
    else if (_wcsicmp(BEHAVIOR_TYPE_PATH, bstrBehaviorType) == 0)
        return crbvrPath;
    else if (_wcsicmp(BEHAVIOR_TYPE_ACTOR, bstrBehaviorType) == 0)
        return crbvrActor;
    else if (_wcsicmp(BEHAVIOR_TYPE_EFFECT, bstrBehaviorType) == 0)
        return crbvrEffect;
    else if ( _wcsicmp(BEHAVIOR_TYPE_ACTION, bstrBehaviorType) == 0)
        return crbvrAction;
    else if ( _wcsicmp(BEHAVIOR_TYPE_DA, bstrBehaviorType) == 0)
        return crbvrDA;
    // otherwise we do not know what the behavior type is, so return unkown
    else
        return crbvrUnknown;
} // GetBehaviorTypeFromBstr

//*****************************************************************************

STDMETHODIMP 
CCrBehaviorFactory::FindBehavior(LPOLESTR pchBehaviorName,
							     LPOLESTR pchBehaviorURL,
								 IUnknown *pUnkArg,
								 IElementBehavior **ppBehavior)
{
    HRESULT hr = E_FAIL;

    // (TIME bails if we are in 16 or less color mode. Need to the same
    // here because LM crashes if time is not around.)
    // If we are in 16 or less color mode on the Primary Device, bail.
    // Note: Multi-monitor API are currently unavailable in this build
    HWND hwndDesktop = NULL;
    hwndDesktop = GetDesktopWindow();
    if (NULL != hwndDesktop)
    {
        HDC hdcPrimaryDevice = NULL;
        hdcPrimaryDevice = GetDC(NULL);
        if (NULL != hdcPrimaryDevice)
        {
            int bpp = 32;
            bpp = GetDeviceCaps(hdcPrimaryDevice, BITSPIXEL);
            ReleaseDC(hwndDesktop, hdcPrimaryDevice);
            if (bpp <= 4)
            {
                // This prevents LM bvrs from being created
                return E_FAIL;
            }
        }
    }

	// check the paramters passed in to insure they are valid
	if (pUnkArg == NULL ||
		ppBehavior == NULL) 
	{
		DPF_ERR("Invalid Parameter passed into FindBehavior is NULL");
		return SetErrorInfo(E_INVALIDARG);
	}

    BSTR bstrTagName;
    if (pchBehaviorName == NULL || _wcsicmp(DEFAULT_BEHAVIOR_AS_TAG_URL, pchBehaviorName) == 0)
    {
        // we need to get the tag name from the HTMLElement that we are being
        // created from.  To do this we use the IUnknown to get a IElementBehaviorSite,
        // from this we get the HTMLElement, and get the tagname from this.
        IElementBehaviorSite *pBehaviorSite;
        hr = pUnkArg->QueryInterface(IID_TO_PPV(IElementBehaviorSite, &pBehaviorSite));
        if (FAILED(hr))
        {
            DPF_ERR("Unable to get an ElementBehaviorSite from IUnknown in FindBehavior");
            return SetErrorInfo(hr);
        }
        DASSERT(pBehaviorSite != NULL);
        IHTMLElement *pElement;
        hr = pBehaviorSite->GetElement(&pElement);
        ReleaseInterface(pBehaviorSite);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving HTMLElement from BehaviorSite in FindBehavior");
            return SetErrorInfo(hr);
        }
        DASSERT(pElement != NULL);
        hr = pElement->get_tagName(&bstrTagName);
        ReleaseInterface(pElement);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving tagname from HTML element in FindBehavior");
            return SetErrorInfo(hr);
        }
    }
    else
    {
        bstrTagName = pchBehaviorName;
    }


    DASSERT(bstrTagName != NULL);
    ECRBEHAVIORTYPE ecrBehaviorType = GetBehaviorTypeFromBstr(bstrTagName);

	//if we don't recognize the behavior name
    if (ecrBehaviorType == crbvrUnknown )
	{
		//if the behavior name came from the tag
		if(bstrTagName != pchBehaviorName )
		{
			if (bstrTagName != pchBehaviorName)
				SysFreeString(bstrTagName);

			//create an actor
			CComObject<CActorBvr> *pActor;
			hr = CComObject<CActorBvr>::CreateInstance(&pActor);
			if (FAILED(hr))
			{
				DPF_ERR("Error creating actor behavior in FindBehavior");
				return SetErrorInfo(hr);
			}
			// this will do the necessary AddRef to the object
			hr = pActor->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
			DASSERT(SUCCEEDED(hr));
			
			return hr;
		}
		else //else the behavior name did not come from the tag
		{
			if (bstrTagName != pchBehaviorName)
				SysFreeString(bstrTagName);

			DPF_ERR("Error: Unknown behavior type passed into FindBehavior");
			return SetErrorInfo(E_INVALIDARG);
		}
	}

	if (bstrTagName != pchBehaviorName)
        SysFreeString(bstrTagName);

    switch (ecrBehaviorType)
    {
    case crbvrColor:
        CComObject<CColorBvr> *pColor;
        hr = CComObject<CColorBvr>::CreateInstance(&pColor);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating color behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pColor->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;

    case crbvrRotate:
        CComObject<CRotateBvr> *pRotate;
        hr = CComObject<CRotateBvr>::CreateInstance(&pRotate);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating rotate behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pRotate->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;

    case crbvrScale:
        CComObject<CScaleBvr> *pScale;
        hr = CComObject<CScaleBvr>::CreateInstance(&pScale);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating scale behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pScale->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;

    case crbvrMove:
        CComObject<CMoveBvr> *pMove;
        hr = CComObject<CMoveBvr>::CreateInstance(&pMove);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating move behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pMove->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;

    case crbvrPath:
        CComObject<CPathBvr> *pPath;
        hr = CComObject<CPathBvr>::CreateInstance(&pPath);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating path behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pPath->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;

    case crbvrNumber:
        CComObject<CNumberBvr> *pNumber;
        hr = CComObject<CNumberBvr>::CreateInstance(&pNumber);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating number behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pNumber->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;
	
    case crbvrSet:
        CComObject<CSetBvr> *pSet;
        hr = CComObject<CSetBvr>::CreateInstance(&pSet);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating set behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pSet->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
		break;
	case crbvrActor:
		CComObject<CActorBvr> *pActor;
		hr = CComObject<CActorBvr>::CreateInstance(&pActor);
		if (FAILED(hr))
		{
			DPF_ERR("Error creating actor behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
		hr = pActor->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
		break;
	case crbvrEffect:
		CComObject<CEffectBvr> *pEffect;
		hr = CComObject<CEffectBvr>::CreateInstance(&pEffect);
		if (FAILED(hr))
		{
			DPF_ERR("Error creating effect behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
		hr = pEffect->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
		break;
	case crbvrAction:
		CComObject<CActionBvr> *pAction;
		hr = CComObject<CActionBvr>::CreateInstance(&pAction);
		if (FAILED(hr))
		{
			DPF_ERR("Error creating action behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
		hr = pAction->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
		break;
	case crbvrDA:
		ITIMEFactory *pTimeFactory;
		hr = CoCreateInstance(CLSID_TIMEFactory, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_ITIMEFactory, 
                              (void**)&pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating time factory in FindBehavior");
            return SetErrorInfo(hr);
        }
        IElementBehaviorFactory *pBehaviorFactory;
        hr = pTimeFactory->QueryInterface(IID_TO_PPV(IElementBehaviorFactory, &pBehaviorFactory)); 
        ReleaseInterface(pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error Querying for IElementBehaviorFactor in FindBehavior");
            return hr;
        }
        // QI pUnkArg for pBehaviorSite and pass to FindBehavior(...)
        // TODO: (dilipk) this QI goes away with the old FindBehavior Signature (#38656).
        IElementBehaviorSite *pBehaviorSite;
        hr = pUnkArg->QueryInterface(IID_TO_PPV(IElementBehaviorSite, &pBehaviorSite)); 
        if (FAILED(hr))
        {
            DPF_ERR("Error Querying for IElementBehaviorSite in FindBehavior");
            return hr;
        }
        hr = pBehaviorFactory->FindBehavior( pchBehaviorName,
                                             WZ_TIMEDA_URN,
                                             pBehaviorSite,
                                             ppBehavior);
        ReleaseInterface(pBehaviorSite);
        ReleaseInterface(pBehaviorFactory);
        break;
    default:
        // should never ever reach here
        DASSERT(false);
        hr = E_INVALIDARG;
	}
    return hr;

} // FindBehavior

//*****************************************************************************

STDMETHODIMP 
CCrBehaviorFactory::GetInterfaceSafetyOptions(REFIID riid, 
                                              DWORD *pdwSupportedOptions, 
                                              DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag2 )
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
} // GetInterfaceSafetyOptions

//*****************************************************************************

STDMETHODIMP 
CCrBehaviorFactory::SetInterfaceSafetyOptions(REFIID riid, 
                                              DWORD dwOptionSetMask, 
                                              DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2)
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
} // SetInterfaceSafetyOptions

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\eventsink.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventSink.cpp
//
// Abstract:  
//
///////////////////////////////////////////////////////////////


#include "headers.h"
#include "eventmgr.h"
#include "mshtmdid.h"
#include "eventsink.h"
#include "basebvr.h"

#define THR(_arg) _arg

struct {
    ELEMENT_EVENT event;
    wchar_t * wsz_name;
} g_ElementEventNames[] =
{
    { EE_ONPROPCHANGE,         L"onpropertychange" },
    //add non-input related events to hook here
    { EE_ONREADYSTATECHANGE,   L"onreadystatechange" },
    { EE_ONMOUSEMOVE,          L"onmousemove" },
    { EE_ONMOUSEDOWN,          L"onmousedown" },
    { EE_ONMOUSEUP,            L"onmouseup" },
    { EE_ONKEYDOWN,            L"onkeydown" }, 
    { EE_ONKEYUP,              L"onkeyup" },
    { EE_ONBLUR,               L"onblur" }
    //add input events here
};

///////////////////////////////////////////////////////////////
//  Name: CEventSink
//  Parameters:
//    CTIMEElement  & elm
//                               This parameter must be passed
//                               to the constructor so that 
//                               we can get info from elm
//    CEventMgr *    pEventMgr
//                               This parameter is passed so 
//                               the eventsync can notify then
//                               parent EventMgr when events
//                               have occured.
//  Abstract:
//    Stash away the element so we can get the OM when we need it
///////////////////////////////////////////////////////////////
CEventSink::CEventSink(IEventManagerClient* client, CEventMgr *pEventMgr)
: m_client(client),
  m_pElement(NULL),
  m_refCount(0),
  m_pEventMgr(NULL)
{
    m_pEventMgr = pEventMgr;
}

///////////////////////////////////////////////////////////////
//  Name: ~CEventSink
//
//  Abstract:
//    Cleanup
///////////////////////////////////////////////////////////////
CEventSink::~CEventSink()
{


}


///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Initializes the object
///////////////////////////////////////////////////////////////
HRESULT CEventSink::Init()
{
    HRESULT hr = S_OK;

    //m_pElement = m_bvr.GetElement();
	m_pElement = m_client->GetElementToSink();
	if( m_pElement != NULL )
	{
		m_pElement->AddRef();
    
		hr = THR(AttachEvents());
		if (FAILED(hr))
		{
			goto done;
		}
	}

  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Attaches to mouse and keyboard events
///////////////////////////////////////////////////////////////
HRESULT CEventSink::InitMouse()
{
    CComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    VARIANT_BOOL bSuccess;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    //attach to mouse events
	//TODO: This should ask the behavior if it wants to handle mouse events
	// TODO: register for mouse events only if we have some listeners
    if (true)
    {
        for (i = EE_ONREADYSTATECHANGE + 1; i < EE_MAX; i++)
        {
            hr = THR(pElement2->attachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this, &bSuccess)) ;
            if (FAILED(hr))
            {
                goto done;
            }
        }   
    }
    
  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Deinit
//  Parameters:  None
//
//  Abstract:
//    Cleans up the object
///////////////////////////////////////////////////////////////
HRESULT CEventSink::Deinit()
{
    HRESULT hr = S_OK;

    hr = THR(DetachEvents());

    if (m_pElement)
    {
        m_pElement->Release();
        m_pElement = NULL;
    }

    if (m_dwElementEventConPtCookie != 0 && m_pElementConPt)
    {
        m_pElementConPt->Unadvise(m_dwElementEventConPtCookie);
    }

    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: AddRef
// 
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventSink::AddRef(void)
{
    return ++m_refCount;
}

///////////////////////////////////////////////////////////////
//  Name: Release
// 
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventSink::Release(void)
{
    m_refCount--;
    if (m_refCount == 0)
    {
        //delete this;
    }

    return m_refCount;
}



///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSink::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//     dispIdMember is always 0 so this Invoke switches on the
//     name of the event that causes the callback.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSink::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pvarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    // Listen for the two events we're interested in, and call back if necessary
    HRESULT hr = S_OK;
    CComPtr <IHTMLEventObj> pEventObj;
    BSTR bstrEventName;

    //get the event object from the IDispatch passed in
    hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }
    
    //get the event name
    hr = THR(pEventObj->get_type(&bstrEventName));
    if (FAILED(hr))
    {
        goto done;
    }

    //handle the MouseMove event
    if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONMOUSEMOVE].wsz_name + 2) == 0)
    {
        NotifyMouseMove(pEventObj);
    }
    //handle the MouseDown event
    else if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONMOUSEDOWN].wsz_name + 2) == 0)
    {
        NotifyMouseDown(pEventObj);
    }
    //handle the MouseUp event
    else if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONMOUSEUP].wsz_name + 2) == 0)
    {
        NotifyMouseUp(pEventObj);
    }
    //handle the KeyDown event
    else if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONKEYDOWN].wsz_name + 2) == 0)
    {
        NotifyKeyDown(pEventObj);
    }
    //handle the KeyUp event
    else if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONKEYUP].wsz_name + 2) == 0)
    {
        NotifyKeyUp(pEventObj);
    }
    //handle the Blur event
    else if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONBLUR].wsz_name + 2) == 0)
    {
        m_pEventMgr->KeyEvent(TRUE, TRUE, FALSE, FALSE, FALSE, 0, 0);
    }
    //handle the PropertyChange event
    else if (_wcsicmp(bstrEventName, g_ElementEventNames[EE_ONPROPCHANGE].wsz_name + 2) == 0)
    {
        NotifyPropertyChange(pEventObj);
    }
    //handle the OnReadyStateChange event
    else if (_wcsicmp(bstrEventName, g_ElementEventNames[EE_ONREADYSTATECHANGE].wsz_name + 2) == 0)
    {
        NotifyReadyState(pEventObj);
    }
    
    //return TRUE
    VARIANT vReturnVal;
    VariantInit(&vReturnVal);
    vReturnVal.vt = VT_BOOL;
    vReturnVal.boolVal = VARIANT_TRUE;
    pEventObj->put_returnValue(vReturnVal);
	
    SysFreeString(bstrEventName);

  done:
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: QueryInterface
// 
//  Abstract:
//    This QI only handles the IDispatch for HTMLElementEvents
//    and returns this as the interface.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSink::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////
//  Name: AttachEvents
// 
//  Abstract:
//    Hooks all the trident events that we are interested in.
//    automatically hooks non-mouse events.  Only hooks the mouse
//    events if they are relevant to the behavior.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::AttachEvents()
{
    CComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    VARIANT_BOOL bSuccess;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    //register for events that all sync's need.
    for (i = 0; i <= EE_ONREADYSTATECHANGE; i++)
    {
        hr = THR(pElement2->attachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this, &bSuccess)) ;
        if (FAILED(hr))
        {
            goto done;
        }
    }

  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: DetachEvents
// 
//  Abstract:
//    Detaches from all events to allow clean shutdown.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::DetachEvents()
{
    CComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    
    //detach from events that all sync's need.
    for (i = 0; i <= EE_ONREADYSTATECHANGE; i++)
    {
        //attach to the onreadystatechangeevent
        hr = THR(pElement2->detachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this)) ;
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    //detach from mouse events
	//TODO: should ask the behavior if it wants mouse events here.
	//TODO: detach only if we attached
    if (true)
    {
        for (i = EE_ONREADYSTATECHANGE + 1; i < EE_MAX; i++)
        {
            //attach to the onreadystatechangeevent
            hr = THR(pElement2->detachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this));
            if (FAILED(hr))
            {
                goto done;
            }
        }   
    }

  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: NotifyReadyState
// 
//  Parameters
//    IHTMLEventObj *pEventObj    A pointer to the event object
//                                that was passed to IDispatch::Invoke.
//
//  Abstract:
//    Determines the ready state that caused the ReadyStateChange
//    event and calls the EventManager to handle the new ready
//    state.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyReadyState(IHTMLEventObj *pEventObj)
{
    HRESULT hr = S_OK;
    CComPtr <IHTMLElement> pElement;
    CComPtr <IHTMLElement2> pElement2;
    CComPtr <IHTMLEventObj2> pEventObj2;
    VARIANT vReadyState;
    
    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pEventObj2->get_srcElement(&pElement));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElement->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }
    
    VariantInit(&vReadyState);
    hr = THR(pElement2->get_readyState(&vReadyState));
    if (FAILED(hr))
    {
        goto done;
    }

    //if this is not a valid ready state, get the parent element's readystate.
    if (vReadyState.vt != VT_BSTR)
    {
        CComPtr <IHTMLElement> pParentEle;
        CComPtr <IHTMLElement2> pParentEle2;

        hr = THR(pElement->get_parentElement(&pParentEle));
        if (FAILED (hr))
        {
            goto done;
        }

        hr = THR(pParentEle->QueryInterface(IID_IHTMLElement2, (void **)&pParentEle2));
        if (FAILED (hr))
        {
            goto done;
        }

        VariantClear(&vReadyState);
        hr = THR(pParentEle2->get_readyState(&vReadyState));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    m_pEventMgr->ReadyStateChange(vReadyState.bstrVal);
    VariantClear(&vReadyState);

  done:
    return hr;
}



///////////////////////////////////////////////////////////////
//  Name: NotifyPropertyChange
// 
//  Parameters
//    IHTMLEventObj *pEventObj    A pointer to the event object
//                                that was passed to IDispatch::Invoke.
//
//  Abstract:
//    Determines the ready state that caused the PropertyChange
//    event and calls the EventManager to handle the property
//    change.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyPropertyChange(IHTMLEventObj *pEventObj)
{
    HRESULT hr = S_OK;

    CComPtr <IHTMLEventObj2> pEventObj2;
    CComPtr <IHTMLElement> pElement;
    BSTR bstrPropertyName;

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }
    
    //get the property name
    hr = THR(pEventObj2->get_propertyName(&bstrPropertyName));
    if (FAILED(hr))
    {
        goto done;
    }

    m_pEventMgr->PropertyChange(bstrPropertyName);
    SysFreeString(bstrPropertyName);
  
  done:
    return hr;

}


///////////////////////////////////////////////////////////////
//  Name: NotifyMouseMove
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse move event from the event object
//    and notifies the event manager ofthe event.  
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyMouseMove(IHTMLEventObj *pEventObj)
{
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long lButton;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_clientX(&x));
    hr = THR(pEventObj->get_clientY(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_button(&lButton));

    m_pEventMgr->MouseEvent(x, 
                            y, 
                            TRUE,
                            FALSE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            lButton);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyMouseUp
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse up event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyMouseUp(IHTMLEventObj *pEventObj)
{
    
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long Button;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_clientX(&x));
    hr = THR(pEventObj->get_clientY(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_button(&Button));
    
    m_pEventMgr->MouseEvent(x, 
                            y, 
                            FALSE,
                            TRUE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            Button);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyMouseDown
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse down event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyMouseDown(IHTMLEventObj *pEventObj)
{
    
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long Button;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_clientX(&x));
    hr = THR(pEventObj->get_clientY(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_button(&Button));

    m_pEventMgr->MouseEvent(x, 
                            y, 
                            FALSE,
                            FALSE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            Button);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyKeyDown
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a key down event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyKeyDown(IHTMLEventObj *pEventObj)
{
    CComPtr <IHTMLEventObj2> pEventObj2;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long KeyCode;
    long RepeatCount = 0;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_keyCode(&KeyCode));
    
    //determine if this is a repeat keypress.
    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (SUCCEEDED(hr))
    {
        VARIANT_BOOL bRepeat;
        hr = THR(pEventObj2->get_repeat(&bRepeat));
        if (SUCCEEDED(hr) && bRepeat)
        {
            RepeatCount = 1;
        }
    }
    
    m_pEventMgr->KeyEvent(FALSE,
                          FALSE,
                          bShiftKeyPressed,
                          bAltKeyPressed,
                          bCtrlKeyPressed,
                          KeyCode,
                          RepeatCount);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyKeyUp
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a key up event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyKeyUp(IHTMLEventObj *pEventObj)
{
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long KeyCode;

    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_keyCode(&KeyCode));
    
    m_pEventMgr->KeyEvent(FALSE,
                          TRUE,
                          bShiftKeyPressed,
                          bAltKeyPressed,
                          bCtrlKeyPressed,
                          KeyCode,
                          0);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\path.cpp ===
//*****************************************************************************
//
// File:    path.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CPathBvr object which implements
//			 the chromeffects Path DHTML behavior
//
// Modification List:
// Date		Author		Change
// 10/23/98	jeffort		Created this file
//*****************************************************************************

#include "headers.h"

#include "path.h"
#include <math.h>
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CPathBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_V           0

WCHAR * CPathBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_V,
                                    };

//*****************************************************************************

CPathBvr::CPathBvr() :
    m_pPathManager(NULL)
{
    VariantInit(&m_varPath);
    m_clsid = CLSID_CrPathBvr;
} // CPathBvr

//*****************************************************************************

CPathBvr::~CPathBvr()
{
    if (NULL != m_pPathManager)
    {
        delete m_pPathManager;
        m_pPathManager = NULL;
    }

    VariantClear(&m_varPath);
} // ~PathBvr

//*****************************************************************************

HRESULT CPathBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in path behavior FinalConstruct initializing base classes");
        return hr;
    }
    m_pPathManager = new CPathManager;
    if (m_pPathManager == NULL)
    {
        DPF_ERR("Error creating member: subpath in CPathBvr FinalConstruct");
        return SetErrorInfo(E_OUTOFMEMORY);
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CPathBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_MOVE_PROPS);
    switch (iIndex)
    {
    case VAR_V:
        return &m_varPath;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CPathBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_PATH_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CPathBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CPathBvr::Notify(LONG event, VARIANT *pVar)
{
	return SUPER::Notify(event, pVar);
} // Notify

//*****************************************************************************

STDMETHODIMP
CPathBvr::Detach()
{
	return SUPER::Detach();
} // Detach 

//*****************************************************************************

STDMETHODIMP
CPathBvr::put_v(VARIANT varPath)
{
    HRESULT hr = VariantCopy(&m_varPath, &varPath);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_v copying variant");
        return SetErrorInfo(hr);
    }
    return NotifyPropertyChanged(DISPID_ICRPATHBVR_V);
} // put_v

//*****************************************************************************

STDMETHODIMP
CPathBvr::get_v(VARIANT *pRetPath)
{
    if (pRetPath == NULL)
    {
        DPF_ERR("Error in path:get_v, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetPath, &m_varPath);
} // get_v

//*****************************************************************************

STDMETHODIMP
CPathBvr::GetDATransform(IDispatch *pDispProgress, 
                         VARIANT *pRetTrans)
{
    IDATransform2 *pbvrTransform;
    HRESULT hr;

    VariantInit(pRetTrans);
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varPath);
    if (FAILED(hr))
    {
        DPF_ERR("Error in path: property does not contain bstr for path");
        return SetErrorInfo(hr);
    }


    hr = m_pPathManager->Initialize(m_varPath.bstrVal);
    if (FAILED(hr))
    {
        DPF_ERR("Error initializing path object");
        return SetErrorInfo(hr);
    }

    IDANumber *pbvrProgress;
    hr = pDispProgress->QueryInterface(IID_TO_PPV(IDANumber, &pbvrProgress));
    if (FAILED(hr))
    {
        DPF_ERR("Error getting progress behavior from IDispatch");
        return hr;
    }
    hr = m_pPathManager->BuildTransform(GetDAStatics(),
                                        pbvrProgress,
                                        0.0f,
                                        1.0f,
                                        &pbvrTransform);
    ReleaseInterface(pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error building transform for path");
        return SetErrorInfo(hr);
    }


    hr = pbvrTransform->QueryInterface(IID_TO_PPV(IDispatch, &(pRetTrans->pdispVal)));
    ReleaseInterface(pbvrTransform);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing for IDispatch");
        return SetErrorInfo(hr);
    }
    pRetTrans->vt = VT_DISPATCH;
    return S_OK;
} // get_DATransform

//*****************************************************************************

HRESULT 
CPathBvr::BuildAnimationAsDABehavior()
{

    return S_OK;
} // BuildAnimationAsDABehavior

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\move.cpp ===
//*****************************************************************************
//
// File:            move.cpp
// Author:          jeff ort
// Date Created:    Sept 26, 1998
//
// Abstract: Implementation of CMoveBvr object which implements
//			 the chromeffects move DHTML behavior
//
// Modification List:
// Date		Author		Change
// 10/20/98	jeffort		Created this file
// 10/21/98 jeffort     Reworked code, use values as percentage
// 10/30/98 markhal     Check for BSTR variant type in Build2DTransform
//*****************************************************************************

#include "headers.h"

#include "move.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CMoveBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_FROM        0
#define VAR_TO          1
#define VAR_BY          2
#define VAR_V           3
#define VAR_TYPE        4
#define VAR_MODE		5
#define VAR_DIRECTION   6
WCHAR * CMoveBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_FROM,
                                     BEHAVIOR_PROPERTY_TO,
                                     BEHAVIOR_PROPERTY_BY,
                                     BEHAVIOR_PROPERTY_V,
                                     BEHAVIOR_PROPERTY_TYPE,
									 BEHAVIOR_PROPERTY_MODE,
                                     BEHAVIOR_PROPERTY_DIRECTION
                                    };

//*****************************************************************************

CMoveBvr::CMoveBvr() :
    m_DefaultType(e_RelativeAccum),
    m_pPathManager(NULL),
    m_pdispActor(NULL),
    m_lCookie(0),
    m_pSampler( NULL ),
    m_lSampledCookie( 0 )
{
    VariantInit(&m_varFrom);
    VariantInit(&m_varTo);
    VariantInit(&m_varBy);
    VariantInit(&m_varPath);
    VariantInit(&m_varType);
	VariantInit(&m_varMode);
    VariantInit(&m_varDirection);
    m_clsid = CLSID_CrMoveBvr;

    VariantInit( &m_varCurrentX );
    V_VT(&m_varCurrentX) = VT_R8;
    V_R8(&m_varCurrentX) = 0.0;
    
    VariantInit( &m_varCurrentY );
    V_VT(&m_varCurrentY) = VT_R8;
    V_R8(&m_varCurrentY) = 0.0;
    
} // CMoveBvr

//*****************************************************************************

CMoveBvr::~CMoveBvr()
{
    VariantClear(&m_varFrom);
    VariantClear(&m_varTo);
    VariantClear(&m_varBy);
    VariantClear(&m_varType);  
	VariantClear(&m_varMode);
    VariantClear(&m_varDirection);

    VariantClear( &m_varCurrentX );
    VariantClear( &m_varCurrentY );
    
    if (m_pPathManager != NULL)
        delete m_pPathManager;
    ReleaseInterface( m_pdispActor );
    m_lCookie = 0;

    if( m_pSampler != NULL )
    {
    	RemoveBehaviorFromAnimatedElement( m_lSampledCookie );
    	m_pSampler->Invalidate();
    	m_pSampler = NULL;
    }
} // ~MoveBvr

//*****************************************************************************

HRESULT CMoveBvr::FinalConstruct()
{

    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in move behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CMoveBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_MOVE_PROPS);
    switch (iIndex)
    {
    case VAR_FROM:
        return &m_varFrom;
        break;
    case VAR_TO:
        return &m_varTo;
        break;
    case VAR_BY:
        return &m_varBy;
        break;
    case VAR_V:
        return &m_varPath;
        break;
    case VAR_DIRECTION:
        return &m_varDirection;
        break;
	case VAR_TYPE:
		return &m_varType;
		break;
	case VAR_MODE:
		return &m_varMode;
		break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CMoveBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_MOVE_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;
} // Notify

//*****************************************************************************

STDMETHODIMP
CMoveBvr::Detach()
{

	if( m_pSampler != NULL )
    {
    	RemoveBehaviorFromAnimatedElement( m_lSampledCookie );
    	m_pSampler->Invalidate();
    	m_pSampler = NULL;
    }

	HRESULT hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to detach superclass" );
	}

	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		//remove our behavior fragment from the actor
		hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		CheckHR( hr, "Failed to remove the behavior fragment from the actor", end );

		m_lCookie = 0;
	}

	ReleaseInterface( m_pdispActor );
end:

	return hr;
	
} // Detach 

//*****************************************************************************

STDMETHODIMP
CMoveBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CMoveBvr::put_from(VARIANT varFrom)
{
    HRESULT hr = VariantCopy(&m_varFrom, &varFrom);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting from for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_FROM);
} // put_from

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_from(VARIANT *pRetFrom)
{
    if (pRetFrom == NULL)
    {
        DPF_ERR("Error in move:get_from, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetFrom, &m_varFrom);
} // get_from

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::put_to(VARIANT varTo)
{
    HRESULT hr = VariantCopy(&m_varTo, &varTo);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_to copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_TO);
} // put_to

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::get_to(VARIANT *pRetTo)
{
    if (pRetTo == NULL)
    {
        DPF_ERR("Error in move:get_to, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTo, &m_varTo);
} // get_to

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::put_by(VARIANT varBy)
{
    HRESULT hr = VariantCopy(&m_varBy, &varBy);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_by copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_BY);
} // put_by

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::get_by(VARIANT *pRetBy)
{
    if (pRetBy == NULL)
    {
        DPF_ERR("Error in move:get_by, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetBy, &m_varBy);
} // get_by

//*****************************************************************************

STDMETHODIMP
CMoveBvr::put_v(VARIANT varPath)
{
    HRESULT hr = VariantCopy(&m_varPath, &varPath);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_v copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_V);
} // put_v

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_v(VARIANT *pRetPath)
{
    if (pRetPath == NULL)
    {
        DPF_ERR("Error in move:get_v, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetPath, &m_varPath);
} // get_v

//*****************************************************************************

STDMETHODIMP
CMoveBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_type copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }

    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in move:get_type, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::put_mode(VARIANT varMode)
{
    HRESULT hr = VariantCopy(&m_varMode, &varMode);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting mode for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_MODE);
} // put_mode

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::get_mode(VARIANT *pRetMode)
{
    if (pRetMode == NULL)
    {
        DPF_ERR("Error in get_mode, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetMode, &m_varMode);
} // get_mode

//*****************************************************************************

STDMETHODIMP
CMoveBvr::put_direction(VARIANT varDirection)
{
    HRESULT hr = VariantCopy(&m_varDirection, &varDirection);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_direction copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_DIRECTION);
} // put_direction

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_direction(VARIANT *pRetDirection)
{
    if (pRetDirection == NULL)
    {
        DPF_ERR("Error in move:get_direction, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetDirection, &m_varDirection);
} // get_direction

//*****************************************************************************

HRESULT
CMoveBvr::PositionSampled( void *thisPtr,
 			  	 			long id,
				 			double startTime,
				 			double globalNow,
				 			double localNow,
				 			IDABehavior * sampleVal,
				 			IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	reinterpret_cast<CMoveBvr*>(thisPtr)->UpdatePosition( sampleVal );
	
	return S_OK;
}


//*****************************************************************************

HRESULT	
CMoveBvr::UpdatePosition( IDABehavior *sampleVal )
{
	if( sampleVal == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IDAPoint2 *pbvrPoint = NULL;
	IDANumber *pbvrValue = NULL;
	double dValue = 0.0;
	
	//get  IDApoint2 from the sample behavior
	hr = sampleVal->QueryInterface( IID_TO_PPV( IDAPoint2, &pbvrPoint ) );
	CheckHR( hr, "Failed to get point2 from the sampled val", end );
	
	//get the x
	hr = pbvrPoint->get_X( &pbvrValue );
	CheckHR( hr, "Failed to get x from the point2", end ); 
	//extract it
	hr = pbvrValue->Extract( &dValue );
	CheckHR( hr, "Failed to extract the y value", end );
	//put the new value in our local variant
	V_R8(&m_varCurrentX) = dValue;

	ReleaseInterface( pbvrValue );
	
	//get the y
	hr = pbvrPoint->get_Y( &pbvrValue );
	CheckHR( hr, "Failed to get the y bvr from the point", end );
	//extract it
	hr = pbvrValue->Extract( &dValue );
	CheckHR( hr, "Failed to extract the value for y ", end );
	//put the new value in our local variant
	V_R8( &m_varCurrentY ) = dValue;

end:

	ReleaseInterface(pbvrPoint);
	ReleaseInterface(pbvrValue);

	return S_OK;
}


//*****************************************************************************


STDMETHODIMP
CMoveBvr::buildBehaviorFragments(IDispatch *pActorDisp)
{
	HRESULT hr;

	//if our behavior fragment is already on an actor
    if( m_pdispActor != NULL && m_lCookie != 0 )
    {
        hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
        if( FAILED( hr ) )
        {
        	DPF_ERR("Failed to remove the behavior fragment from the actor");
        	return hr;
        }
        
        m_lCookie = 0;

        ReleaseInterface( m_pdispActor );
    }

    //release the sampler if we have one
    if( m_pSampler != NULL )
	{
    	//remove the sampled behavior from time
    	RemoveBehaviorFromAnimatedElement( m_lSampledCookie );
    	//invalidate the sampler
    	m_pSampler->Invalidate();
    	m_pSampler = NULL;
    }
    
    // TODO: we need to possibly build a 3D transform
    // at some later time.  For now, we will just handle the 2D
    // move case
    IDATransform2 *pbvrTransform;
    hr = Build2DTransform(pActorDisp, &pbvrTransform);
	if( SUCCEEDED( hr ) )
	{
		BSTR bstrPropertyName = SysAllocString( L"translation" );
			
		ActorBvrFlags flags;
/*
		if( V_VT(&m_varType) == VT_BSTR && V_BSTR(&m_varType) != NULL && SysStringLen( V_BSTR(&m_varType) ) != 0  )
		{
			//type is set we should use it to determine whether or not we are absolute or relative
			
			if( wcsicmp( V_BSTR(&m_varType), BEHAVIOR_TYPE_ABSOLUTE ) == 0 )
				flags = e_Absolute;
			else
				flags = e_Relative;
		}
		else //type is not set
		{

			//default to what we have set
			flags = m_DefaultType;
		}
*/

		IDAPoint2* pOrigin = NULL;
		IDAPoint2* pTransformed = NULL;
		IDABehavior *pbvrHooked = NULL;
		//push a point2 through the transform
		hr = GetDAStatics()->get_Origin2( &pOrigin );
		if(FAILED( hr ) )
		{
			DPF_ERR("");
			ReleaseInterface( pbvrTransform );
			return hr;
		}

		hr = pOrigin->Transform( pbvrTransform, &pTransformed );
		ReleaseInterface( pOrigin );
		if( FAILED( hr ) )
		{
			DPF_ERR("");
			ReleaseInterface( pbvrTransform );
			return hr;
		}

		//hook the result
		m_pSampler = new CSampler( PositionSampled, reinterpret_cast<void*>(this) );
		if( m_pSampler == NULL )
		{
			DPF_ERR("");
			ReleaseInterface( pbvrTransform );
			ReleaseInterface( pTransformed );
			return E_OUTOFMEMORY;
		}

		hr = m_pSampler->Attach( pTransformed, &pbvrHooked );
		ReleaseInterface( pTransformed );
		if( FAILED( hr ) )
		{
			DPF_ERR("");
			ReleaseInterface( pbvrTransform );
			return hr;
		}

		//add the resulting behavior to time as a bvr to run
		hr = AddBehaviorToAnimatedElement( pbvrHooked, &m_lSampledCookie );
		ReleaseInterface( pbvrHooked );
		if(FAILED( hr ) )
		{
			DPF_ERR("");
			ReleaseInterface( pbvrTransform );
			return hr;
		}

		flags = FlagFromTypeMode(m_DefaultType, &m_varType, &m_varMode);

		IDispatch *pdispThis = NULL;
		hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispThis ) );
		if( FAILED( hr ) )
		{
			DPF_ERR("QI for Idispatch on the element failed");
			SysFreeString( bstrPropertyName );
			ReleaseInterface(pbvrTransform);
			return hr;
		}

		
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pbvrTransform, 
									  bstrPropertyName, 
									  flags, 
									  e_Translation, 
									  pdispThis, 
									  &m_lCookie ); 

		ReleaseInterface( pdispThis );
		
		SysFreeString( bstrPropertyName );
		ReleaseInterface(pbvrTransform);
		if (FAILED(hr))
		{
			DPF_ERR("Error applying move behavior to object");
			return hr;
		}

		//save the actor away so we can remove the behavior later
		m_pdispActor = pActorDisp;
		m_pdispActor->AddRef();
	}
	else //error building move transform
    {
        DPF_ERR("error building move transform");
    }

    return hr;
}

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_currentX( VARIANT *pRetCurrent )
{
	if( pRetCurrent == NULL )
		return E_INVALIDARG;

	return VariantCopy( pRetCurrent, &m_varCurrentX );
}

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_currentY( VARIANT *pRetCurrent )
{
	if( pRetCurrent == NULL )
		return E_INVALIDARG;
		
	return VariantCopy( pRetCurrent, &m_varCurrentY );
}

//*****************************************************************************

// These are used to index array values below

#define XVAL 0
#define YVAL 1
#define ZVAL 2

//*****************************************************************************

HRESULT 
CMoveBvr::Build2DTransform(IDispatch *pActorDisp, IDATransform2 **ppbvrTransform)
{
    HRESULT hr;

    DASSERT(ppbvrTransform != NULL);
    *ppbvrTransform = NULL;

    IDANumber *pbvrMoveX;
    IDANumber *pbvrMoveY;

    IDispatch *pDisp;
    hr = GetHTMLElement()->get_children(&pDisp);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting child collection");
        return SetErrorInfo(hr);
    }

    IHTMLElementCollection *pCollection;
    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLElementCollection, &pCollection));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing IDispatch for collection");
        return SetErrorInfo(hr);
    }

    // get the length of the collection
    long cChildren;
    hr = pCollection->get_length(&cChildren);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting number of children from collection");
        ReleaseInterface(pCollection);
        return SetErrorInfo(hr);
    }
    // now cycle through looking for the correct get property on each child
    for (long i = 0; i < cChildren; i++)
    {
        VARIANT varIndex;
        VariantInit(&varIndex);
        varIndex.vt = VT_I4;
        varIndex.intVal = 0;            

        VARIANT varName;
        VariantInit(&varName);
        varIndex.vt = VT_I4;
        varIndex.intVal = i;    
     
        IDispatch *pDisp;

        hr = pCollection->item(varName, varIndex, &pDisp);
        if (FAILED(hr))
        {
            DPF_ERR("Error obtaining item from collection");
            ReleaseInterface(pCollection);
            return SetErrorInfo(hr);
        }

        IHTMLElement *pChildElement;
        hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLElement, &pChildElement));
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing child Dispatch for HTML Element");
            ReleaseInterface(pCollection);
            return SetErrorInfo(hr);
        }

        // now invoke the child for the get_DATransform method
        HRESULT hr;
	    DISPPARAMS		params;
	    VARIANT			varResult;

        VARIANT         rgvarInputParms[1];

        IDANumber *pbvrProgress;
        hr = GetTIMEProgressNumber(&pbvrProgress);
        if (FAILED(hr))
        {
            DPF_ERR("Error retireving progress value from TIME");
            ReleaseInterface(pCollection);
            return hr;
        }
        
		VariantInit( &rgvarInputParms[0] );

        rgvarInputParms[0].vt = VT_DISPATCH;
        rgvarInputParms[0].pdispVal = pbvrProgress;

	    VariantInit(&varResult);

	    params.rgvarg				= rgvarInputParms;
	    params.rgdispidNamedArgs	= NULL;
	    params.cArgs				= 1;
	    params.cNamedArgs			= 0;
	    
        hr = CallInvokeOnHTMLElement(pChildElement,
                                     L"GetDATransform", 
                                     DISPATCH_METHOD,
                                     &params,
                                     &varResult);
        ReleaseInterface(pChildElement);
        ReleaseInterface(pbvrProgress);
        // we want to watch for failure, but an acceptable failure
        // is when the property is not supported
        if (FAILED(hr) && hr != DISP_E_UNKNOWNNAME)
        {
            DPF_ERR("Error calling Invoke on child element");
            ReleaseInterface(pCollection);
            return hr;
        }
        else if ((SUCCEEDED(hr)) && (varResult.vt == VT_DISPATCH))
        {
            // try and QI for an IDATransfrom2 here
            hr = varResult.pdispVal->QueryInterface(IID_TO_PPV(IDATransform2,
                                                               ppbvrTransform));
            VariantClear(&varResult);
            if (SUCCEEDED(hr))
            {
                // we found what we are looking for, get out of here
                break;
            }
        }
        else
        {
            VariantClear(&varResult);
        }
    }

	ReleaseInterface( pCollection );
    // We need to check to see if a path property was set and to
    // see if it has a path transform.  If it does not, then
    // we need to examine all our children to see if a path
    // behavior exists and if it has a valid transform.  If there
    // is not, then we will attempt to use our vector attributes.
    if (*ppbvrTransform == NULL && m_varPath.vt == VT_BSTR && m_varPath.bstrVal != NULL)
    {
        if (m_pPathManager == NULL)
        {
            m_pPathManager = new CPathManager;
            if (m_pPathManager == NULL)
            {
                DPF_ERR("Error creating path manger for move behavior");
                return SetErrorInfo(E_OUTOFMEMORY);
            }
        }
        hr = m_pPathManager->Initialize(m_varPath.bstrVal);
        if (FAILED(hr))
        {
            DPF_ERR("Error intitializing path object");
            return SetErrorInfo(hr);
        }
        IDANumber *pbvrProgress;
        hr = GetTIMEProgressNumber(&pbvrProgress);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting progress behavior from animation object");
            return hr;
        }
        hr = m_pPathManager->BuildTransform(GetDAStatics(),
                                            pbvrProgress,
                                            0.0f,
                                            1.0f,
                                            ppbvrTransform);
        ReleaseInterface(pbvrProgress);
    }


    // if we still have not found a transform, try and build one from our
    // own paramters
    if (*ppbvrTransform == NULL)
    {
		hr = GetMoveToTransform(pActorDisp, ppbvrTransform);
		if (FAILED(hr))
		{
			float rgflFrom[2];
			float rgflTo[2];

			hr = GetMove2DVectorValues(rgflFrom, rgflTo);
			if (FAILED(hr))
			{
				DPF_ERR("Error extracting values from vecotors in CMoveBvr::BuildAnimationAsDABehavior");
				return hr;
			}
			hr = BuildTIMEInterpolatedNumber(rgflFrom[XVAL],
											 rgflTo[XVAL],
											 &pbvrMoveX);
			if (FAILED(hr))
			{
				DPF_ERR("Error building interpolated X value for move behavior");
				return hr;
			}

			hr = BuildTIMEInterpolatedNumber(rgflFrom[YVAL],
											 rgflTo[YVAL],
											 &pbvrMoveY);
			if (FAILED(hr))
			{
				DPF_ERR("Error building interpolated X value for move behavior");
				ReleaseInterface(pbvrMoveX);
				return hr;
			}

			hr = CDAUtils::BuildMoveTransform2(GetDAStatics(),
											   pbvrMoveX,
											   pbvrMoveY,
											   ppbvrTransform);
			ReleaseInterface(pbvrMoveX);
			ReleaseInterface(pbvrMoveY);
			if (FAILED(hr))
			{
				DPF_ERR("Error building move transform2");
				return SetErrorInfo(hr);
			}
		}
    }
    return S_OK;
} // Build2DTransform

//*****************************************************************************

HRESULT 
CMoveBvr::GetMove2DVectorValues(float  rgflFrom[2],
                                float  rgflTo[2])
{

    int cReturnedFromValues;
    HRESULT hr;
    float flDummyVal;

    hr = CUtils::GetVectorFromVariant(&m_varFrom, 
                                      &cReturnedFromValues, 
                                      &(rgflFrom[XVAL]), 
                                      &(rgflFrom[YVAL]),
                                      &flDummyVal);

    if (FAILED(hr) || cReturnedFromValues < MIN_NUM_MOVE_VALUES)
    {
        // If we did not get the minimum number of move params
        // here, then we will use all 0's
        rgflFrom[XVAL] = 0.0f;
        rgflFrom[YVAL] = 0.0f;
    }

    int cReturnedToValues;
    hr = CUtils::GetVectorFromVariant(&m_varTo, 
                                      &cReturnedToValues, 
                                      &(rgflTo[XVAL]), 
                                      &(rgflTo[YVAL]), 
                                      &flDummyVal);
    if (FAILED(hr) || cReturnedToValues < MIN_NUM_MOVE_VALUES)
    {
        // there was no valid to attribute specified, try for a by attribute
        hr = CUtils::GetVectorFromVariant(&m_varBy, 
                                          &cReturnedToValues, 
                                          &(rgflTo[XVAL]), 
                                          &(rgflTo[YVAL]), 
                                          &flDummyVal);
        if (FAILED(hr) || cReturnedToValues < MIN_NUM_MOVE_VALUES)
        {
            DPF_ERR("Error converting to and by variant to float in CMoveBvr::BuildAnimationAsDABehavior");
            return SetErrorInfo(hr);
        }
        rgflTo[XVAL] += rgflFrom[XVAL];
        rgflTo[YVAL] += rgflFrom[YVAL];
        m_DefaultType = e_RelativeAccum;
    }
    else
    {
        // they specified a TO vector, we will therefor default to
        // absolute movement if no type is specified
        m_DefaultType = e_Absolute;
    }
    return S_OK;
} // GetMove2DVectorValues

HRESULT 
CMoveBvr::GetMoveToTransform(IDispatch *pActorDisp, IDATransform2 **ppResult)
{

    HRESULT hr;
    int cReturnedValues;
    float x, y, z;

    hr = CUtils::GetVectorFromVariant(&m_varFrom, 
                                      &cReturnedValues, 
                                      &x, 
                                      &y,
                                      &z);

	if (SUCCEEDED(hr))
		return E_FAIL;

    hr = CUtils::GetVectorFromVariant(&m_varTo, 
                                      &cReturnedValues, 
                                      &x, 
                                      &y, 
                                      &z);

    if (FAILED(hr) || cReturnedValues < MIN_NUM_MOVE_VALUES)
    {
		return E_FAIL;
	}

	IDABehavior *pFromBvr;
	hr = GetBvrFromActor(pActorDisp, L"translation", e_From, e_Translation, &pFromBvr);
	if (FAILED(hr))
		return hr;

	IDATransform2 *pFromTrans;
	hr = pFromBvr->QueryInterface(IID_TO_PPV(IDATransform2, &pFromTrans));
	ReleaseInterface(pFromBvr);
	if (FAILED(hr))
		return hr;

	// Translate the origin and extract x and y
	IDAPoint2 *pOrigin;
	hr = GetDAStatics()->get_Origin2(&pOrigin);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromTrans);
		return hr;
	}

	IDAPoint2 *pFrom;
	hr = pOrigin->Transform(pFromTrans, &pFrom);
	ReleaseInterface(pOrigin);
	ReleaseInterface(pFromTrans);
	if (FAILED(hr))
		return hr;

	IDANumber *pFromX;
	hr = pFrom->get_X(&pFromX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFrom);
		return hr;
	}

	IDANumber *pFromY;
	hr = pFrom->get_Y(&pFromY);
	ReleaseInterface(pFrom);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		return hr;
	}

	IDANumber *pToX;
	hr = GetDAStatics()->DANumber(x, &pToX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		ReleaseInterface(pFromY);
		return hr;
	}

	IDANumber *pToY;
	hr = GetDAStatics()->DANumber(y, &pToY);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		ReleaseInterface(pFromY);
		ReleaseInterface(pToX);
		return hr;
	}

	IDANumber *pX;
	hr = BuildTIMEInterpolatedNumber(pFromX, pToX, &pX);
	ReleaseInterface(pFromX);
	ReleaseInterface(pToX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromY);
		ReleaseInterface(pToY);
		return hr;
	}

	IDANumber *pY;
	hr = BuildTIMEInterpolatedNumber(pFromY, pToY, &pY);
	ReleaseInterface(pFromY);
	ReleaseInterface(pToY);
	if (FAILED(hr))
	{
		ReleaseInterface(pX);
		return hr;
	}

	hr = GetDAStatics()->Translate2Anim(pX, pY, ppResult);
	ReleaseInterface(pX);
	ReleaseInterface(pY);
	if (FAILED(hr))
		return hr;

	m_DefaultType = e_AbsoluteAccum;

	return S_OK;
} // GetMove2DVectorValues


//*****************************************************************************

HRESULT 
CMoveBvr::BuildAnimationAsDABehavior()
{
	return S_OK;
} // BuildAnimationAsDABehavior

//*****************************************************************************

HRESULT 
CMoveBvr::GetTIMEProgressNumber(IDANumber **ppbvrRet)
{
    DASSERT(ppbvrRet != NULL);
    *ppbvrRet = NULL;
    HRESULT hr;

    IDANumber *pbvrProgress;
    hr = SUPER::GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error retireving progress value from TIME");
        return hr;
    }
    
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varDirection);
    if ( SUCCEEDED(hr) && (0 == wcsicmp(m_varDirection.bstrVal, L"backwards")) )
    {
        // pbvrProgress = 1 - pbvrProgress
        IDANumber *pbvrOne;
        
        hr = CDAUtils::GetDANumber(GetDAStatics(), 1.0f, &pbvrOne);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating DANumber from 1.0f");
            ReleaseInterface(pbvrProgress);
            return hr;
        }

        IDANumber *pbvrTemp;
        hr = GetDAStatics()->Sub(pbvrOne, pbvrProgress, &pbvrTemp);
        ReleaseInterface(pbvrOne);
        ReleaseInterface(pbvrProgress);
        pbvrProgress = pbvrTemp;
        pbvrTemp = NULL;
        if (FAILED(hr))
        {
            DPF_ERR("Error creating 1-progress expression");
            return hr;
        }
    }
    *ppbvrRet = pbvrProgress;
    return S_OK;
} // GetTIMEProgressNumber

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\number.cpp ===
//*****************************************************************************
//
// File:    numberbvr.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CNumberBvr object which implements
//			 the chromeffects Number DHTML behavior
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/16/98 jeffort     Added animates property
// 10/16/98 jeffort     Renamed functions
// 11/16/98 jeffort     implemented expression attribute
// 11/17/98 kurtj       moved to actor construction
//*****************************************************************************

#include "headers.h"

#include "number.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CNumberBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_FROM        0
#define VAR_TO          1
#define VAR_BY          2
#define VAR_TYPE		3
#define VAR_MODE		4
#define VAR_PROPERTY    5
WCHAR * CNumberBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_FROM,
                                     BEHAVIOR_PROPERTY_TO,
                                     BEHAVIOR_PROPERTY_BY,
									 BEHAVIOR_PROPERTY_TYPE,
									 BEHAVIOR_PROPERTY_MODE,
                                     BEHAVIOR_PROPERTY_PROPERTY
                                    };

//*****************************************************************************

CNumberBvr::CNumberBvr() :
	m_pdispActor( NULL ),
	m_lCookie( 0 )
{
    VariantInit(&m_varFrom);
    VariantInit(&m_varTo);
    VariantInit(&m_varBy);
	VariantInit(&m_varType);
	VariantInit(&m_varMode);
    VariantInit(&m_varExpression);
    VariantInit(&m_varBeginProperty);
    VariantInit(&m_varProperty);
    m_clsid = CLSID_CrNumberBvr;
} // CNumberBvr

//*****************************************************************************

CNumberBvr::~CNumberBvr()
{
    VariantClear(&m_varFrom);
    VariantClear(&m_varTo);
    VariantClear(&m_varBy);
	VariantClear(&m_varType);
	VariantClear(&m_varMode);
    VariantClear(&m_varExpression);
    VariantClear(&m_varBeginProperty);
    VariantClear(&m_varProperty);

    ReleaseInterface( m_pdispActor );
} // ~NumberBvr

//*****************************************************************************

HRESULT CNumberBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in number behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CNumberBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_MOVE_PROPS);
    switch (iIndex)
    {
    case VAR_FROM:
        return &m_varFrom;
        break;
    case VAR_TO:
        return &m_varTo;
        break;
    case VAR_BY:
        return &m_varBy;
        break;
	case VAR_TYPE:
		return &m_varType;
		break;
	case VAR_MODE:
		return &m_varMode;
		break;
    case VAR_PROPERTY:
        return &m_varProperty;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CNumberBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_NUMBER_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;
} // Notify

//*****************************************************************************

STDMETHODIMP
CNumberBvr::Detach()
{
	HRESULT hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR( "Failure in detach of superclass" );
	}

	hr = RemoveFragment();
	CheckHR( hr, "Failed to remove the behavior fragment from the actor", end );

end:
	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CNumberBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CNumberBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CNumberBvr::put_from(VARIANT varFrom)
{
    HRESULT hr = VariantCopy(&m_varFrom, &varFrom);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting from for CNumberBvr");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_FROM);
} // put_from

//*****************************************************************************

STDMETHODIMP
CNumberBvr::get_from(VARIANT *pRetFrom)
{
    if (pRetFrom == NULL)
    {
        DPF_ERR("Error in number:get_from, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetFrom, &m_varFrom);
} // get_from

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_to(VARIANT varTo)
{
    HRESULT hr = VariantCopy(&m_varTo, &varTo);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting to for CNumberBvr");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_TO);
} // put_to

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_to(VARIANT *pRetTo)
{
    if (pRetTo == NULL)
    {
        DPF_ERR("Error in number:get_to, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTo, &m_varTo);
} // get_to

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_expression(VARIANT varExpression)
{
    HRESULT hr = VariantCopy(&m_varExpression, &varExpression);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting expression for CNumberBvr");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_EXPRESSION);
} // put_expression

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_expression(VARIANT *pRetExpression)
{
    if (pRetExpression == NULL)
    {
        DPF_ERR("Error in number:get_expression, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetExpression, &m_varExpression);
} // get_expression

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_by(VARIANT varBy)
{
    HRESULT hr = VariantCopy(&m_varBy, &varBy);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting by for CNumberBvr");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_BY);
} // put_by

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_by(VARIANT *pRetBy)
{
    if (pRetBy == NULL)
    {
        DPF_ERR("Error in number:get_by, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetBy, &m_varBy);
} // get_by

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting type for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in get_type, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_mode(VARIANT varMode)
{
    HRESULT hr = VariantCopy(&m_varMode, &varMode);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting mode for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_MODE);
} // put_mode

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_mode(VARIANT *pRetMode)
{
    if (pRetMode == NULL)
    {
        DPF_ERR("Error in get_mode, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetMode, &m_varMode);
} // get_mode

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_property(VARIANT varProperty)
{
    HRESULT hr = VariantCopy(&m_varProperty, &varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting property for CNumberBvr");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_PROPERTY);
} // put_property

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_property(VARIANT *pRetProperty)
{
    if (pRetProperty == NULL)
    {
        DPF_ERR("Error in number:get_property, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetProperty, &m_varProperty);
} // get_property

//*****************************************************************************

STDMETHODIMP
CNumberBvr::get_beginProperty(VARIANT *pRetBeginProperty)
{
    if (pRetBeginProperty == NULL)
    {
        DPF_ERR("Error in number:get_beginProperty, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetBeginProperty, &m_varBeginProperty);
} // get_beginProperty

//*****************************************************************************

STDMETHODIMP
CNumberBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
	HRESULT hr;

	hr = RemoveFragment();
	if( FAILED( hr ) )
	{
		DPF_ERR( "could not remove the old fragment from the actor" );
		return hr;
	}
	
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error, property attribute for number behavior not set");
        return SetErrorInfo(E_INVALIDARG);
    }

	ActorBvrFlags flags = e_Absolute;
    IDANumber *pbvrFinalElementNumber = NULL;
#ifndef EXPRESSION_BUG_FIXED
    if (false)
    {
#else
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varExpression);
    if (SUCCEEDED(hr))
    {
        // we need to build a DA behavior for the number and hook it so
        // we can update it at tick time
        float flValue;
        hr = EvaluateScriptExpression(m_varExpression.bstrVal, flValue);
        if (FAILED(hr))
        {
            DPF_ERR("Error evaulating expression for first sample");
            return hr;
        }
        IDANumber *pbvrNum;
        hr = CDAUtils::GetDANumber(GetDAStatics(), flValue, &pbvrNum);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating DA number");
            return SetErrorInfo(hr);
        }
        IDABehavior *pbvrHooked;
        hr = pbvrNum->Hook(this, &pbvrHooked);
        ReleaseInterface(pbvrNum);
        if (FAILED(hr))
        {
            DPF_ERR("Error hooking behavior");
            return SetErrorInfo(hr);
        }
        hr = pbvrHooked->QueryInterface(IID_TO_PPV(IDANumber, &pbvrFinalElementNumber));
        ReleaseInterface(pbvrHooked);
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing behavior for IDANumber");
            return SetErrorInfo(hr);
        }
#endif // EXPRESSION_BUG_FIXED
    }
    else
    {

		float flFrom, flTo;

		hr = CUtils::InsurePropertyVariantAsFloat(&m_varFrom);
		if (FAILED(hr))
		{
			// There was no from, there could be a by attribute
			hr = CUtils::InsurePropertyVariantAsFloat(&m_varBy);
			if (FAILED(hr))
			{
				hr = CUtils::InsurePropertyVariantAsFloat(&m_varTo);

				if (FAILED(hr))
				{
					// Nothing we can do
					return hr;
				}

				// We have a to but no from.  This means we need to get the
				// to value from the actor
				IDABehavior *pFromBvr;
				hr = GetBvrFromActor(pActorDisp, V_BSTR(&m_varProperty), e_From, e_Number, &pFromBvr);
				if (FAILED(hr))
					return hr;

				IDANumber *pFrom;
				hr = pFromBvr->QueryInterface(IID_TO_PPV(IDANumber, &pFrom));
				ReleaseInterface(pFromBvr);
				if (FAILED(hr))
					return hr;

				IDANumber *pTo;
				hr = GetDAStatics()->DANumber(m_varTo.fltVal, &pTo);
				if (FAILED(hr))
				{
					ReleaseInterface(pFrom);
					return hr;
				}

				hr = BuildTIMEInterpolatedNumber(pFrom, pTo, &pbvrFinalElementNumber);
				ReleaseInterface(pFrom);
				ReleaseInterface(pTo);
				if (FAILED(hr))
					return hr;

				flags = e_AbsoluteAccum;
			}
			else
			{
				// Create a relative number from 0 to by
				flFrom = 0;
				flTo = m_varBy.fltVal;
				flags = e_RelativeAccum;
			}
		}
		else
		{
			// We got a valid from value
			flFrom = m_varFrom.fltVal;
			flags = e_Absolute;

			hr = CUtils::InsurePropertyVariantAsFloat(&m_varTo);
			if (FAILED(hr))
			{
				// there was no valid to attribute specified, try for a by attribute
				hr = CUtils::InsurePropertyVariantAsFloat(&m_varBy);
				if (FAILED(hr))
				{
					DPF_ERR("Inappropriate set of attributes");
					return SetErrorInfo(hr);
				}
				flTo = flFrom + m_varBy.fltVal;
			}
			else
			{
				flTo = m_varTo.fltVal;
			}
		}

		if (pbvrFinalElementNumber == NULL)
		{
			// We need to build a number behavior from from and to
			hr = BuildTIMEInterpolatedNumber(flFrom,
											 flTo,
											 &pbvrFinalElementNumber);
			if (FAILED(hr))
			{
				DPF_ERR("Error building interpolated number");
				return hr;
			}
		}
	}

    DASSERT(pbvrFinalElementNumber != NULL);

	IDispatch *pdispThis = NULL;
	hr = GetHTMLElementDispatch( &pdispThis );
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to get the dispatch from the element" );
		ReleaseInterface( pbvrFinalElementNumber );
		return hr;
	}
	
	hr = AttachBehaviorToActorEx( pActorDisp, 
								  pbvrFinalElementNumber, 
								  V_BSTR(&m_varProperty), 
								  FlagFromTypeMode(flags, &m_varType, &m_varMode), 
								  e_Number,
								  pdispThis,
								  &m_lCookie);

	ReleaseInterface( pdispThis );
    ReleaseInterface(pbvrFinalElementNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error applying number behavior to object");
        return hr;
    }

    m_pdispActor = pActorDisp;
    m_pdispActor->AddRef();

    return S_OK;
}

//*****************************************************************************

HRESULT 
CNumberBvr::EvaluateScriptExpression(WCHAR *wzScript, float &flReturn)
{

    HRESULT hr;
    IHTMLElement *pElement;

    pElement = GetHTMLElement();
    DASSERT(pElement != NULL);

    IDispatch *pDisp;
    hr = pElement->get_document(&pDisp);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting docuemnt form HTML element");
        return SetErrorInfo(hr);
    }

    IHTMLDocument2 *pDoc;
    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDoc));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        DPF_ERR("error QI'ng for Document2");
        return SetErrorInfo(hr);
    }


    IDispatch *pscriptEng = NULL;
    hr = pDoc->get_Script( &pscriptEng );
    ReleaseInterface(pDoc);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtianing script object from document");
        return SetErrorInfo(hr);
    }

    OLECHAR *rgNames[] = {L"eval"};
    DISPID   dispidEval = 0u;
    hr = pscriptEng->GetIDsOfNames(IID_NULL,
                                   rgNames,
                                   1,
                                   LOCALE_SYSTEM_DEFAULT,
                                   &dispidEval);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling GetIDsOfNames on scripting object");
        ReleaseInterface(pscriptEng);
        return SetErrorInfo(hr);
    }

    DISPPARAMS      dispParams = {0};
    VARIANTARG      rgvargs[1];
    VARIANT         varResult = {0};
    EXCEPINFO       xinfo = {0};                        
    unsigned int    idxParamErr = 0u;

    VariantInit( &rgvargs[0] );
    rgvargs[0].vt = VT_BSTR;
    rgvargs[0].bstrVal = wzScript;
    dispParams.rgvarg = rgvargs;
    dispParams.cArgs  = 1;                        

    VariantInit(&varResult);
    hr = pscriptEng->Invoke(dispidEval,
                            IID_NULL,
                            LOCALE_SYSTEM_DEFAULT,
                            DISPATCH_METHOD,
                            &dispParams,
                            &varResult,
                            &xinfo,
                            &idxParamErr);
    ReleaseInterface(pscriptEng);
    if (FAILED(hr))
    {
        DPF_ERR("Error callin ginvoke on scripting engine");
        return SetErrorInfo(hr);
    }
    hr = CUtils::InsurePropertyVariantAsFloat(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error expression does not evaluate to a float");
        return SetErrorInfo(hr);
    }
    flReturn = varResult.fltVal;
    return S_OK;
} // EvaluateScriptExpression

//*****************************************************************************

HRESULT 
CNumberBvr::BuildAnimationAsDABehavior()
{
//depricated
	return S_OK;
} // BuildAnimationAsDABehavior

//*****************************************************************************

HRESULT 
CNumberBvr::Notify(LONG id,
                   VARIANT_BOOL startingPerformance,
                   double startTime,
                   double gTime,
                   double lTime,
                   IDABehavior *sampleVal,
                   IDABehavior *curRunningBvr,
                   IDABehavior **ppBvr)
{
    HRESULT hr;
    float flValue;
    // If we get here, then the behavior must have been set up
    // for handling an expression, therefor, the expression
    // must be valid.  Assert this here
    DASSERT(m_varExpression.vt == VT_BSTR);
    DASSERT(m_varExpression.bstrVal != NULL);

    hr = EvaluateScriptExpression(m_varExpression.bstrVal, flValue);
    if (FAILED(hr))
    {
        DPF_ERR("Error evaulating expression for first sample");
        return hr;
    }
    IDANumber *pbvrNum;
    hr = CDAUtils::GetDANumber(GetDAStatics(), flValue, &pbvrNum);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number");
        return SetErrorInfo(hr);
    }
    *ppBvr = pbvrNum;
    return S_OK;

} // Notify

//*****************************************************************************

HRESULT
CNumberBvr::RemoveFragment()
{
	HRESULT hr = S_OK;
	
	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		hr  = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		ReleaseInterface( m_pdispActor );
		m_lCookie = 0;
		CheckHR( hr, "Failed to remove a fragment from the actor", end );
	}

end:

	return hr;
}


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\pathline.cpp ===
//*****************************************************************************
//
// File:    pathline.cpp
// Author:  jeff wall
// Date Created: 11/09/98
//
// Abstract: Implementation of CPathLineSegment object
//
// Modification List:
// Date		Author		Change
// 11/09/98	jeffwall Created this file from path.cpp
//
//
//*****************************************************************************

#include "headers.h"

#include "pathline.h"
#include "dautil.h"


//*****************************************************************************

CPathLineSegment::CPathLineSegment() :
    m_flStartX(0.0f),
    m_flStartY(0.0f),
    m_flEndX(0.0f),
    m_flEndY(0.0f)
{

} //CPathLineSegment

//*****************************************************************************

CPathLineSegment::~CPathLineSegment()
{

} // ~CPathLineSegment

//*****************************************************************************

float 
CPathLineSegment::Distance()
{
    // our distance is simple the distance formula
    return (float) sqrt( ((m_flEndX - m_flStartX) * (m_flEndX - m_flStartX)) +
                 ((m_flEndY - m_flStartY) * (m_flEndY - m_flStartY)));
} // Distance

//*****************************************************************************
void
CPathLineSegment::SetValues(float flStartX, 
                            float flStartY, 
                            float flEndX, 
                            float flEndY)
{
    m_flStartX = flStartX;
    m_flStartY = flStartY;
    m_flEndX = flEndX;
    m_flEndY = flEndY;

}; // SetValues

//*****************************************************************************

HRESULT 
CPathLineSegment::BuildTransform(IDA2Statics *pDAStatics,
                                 IDANumber *pbvrProgress, 
                                 float flStartPercentage,
                                 float flEndPercentage,
                                 IDATransform2 **ppbvrResult)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flEndPercentage >= 0.0f);
    DASSERT(flEndPercentage <= 1.0f);
    DASSERT(ppbvrResult != NULL);
    *ppbvrResult = NULL;

    HRESULT hr;

    // we need to build two DA numbers representing the
    // X and Y portions of the transform.  Each number is in
    // the format of:
    // X = startX + ((endX - startX) * norm-prog)
    // where:
    // norm-prog = progress - startpercentage / endpercentage - startpercentage

    // First build our normalized progress value

    IDANumber *pbvrNormalizedProgress;
    hr = NormalizeProgressValue(pDAStatics,
                                pbvrProgress,
                                flStartPercentage,
                                flEndPercentage,
                                &pbvrNormalizedProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error normalizing progress");
        return hr;
    }

    DASSERT(pbvrNormalizedProgress != NULL);
    IDANumber *pbvrX;
    IDANumber *pbvrY;

    hr = CDAUtils::TIMEInterpolateNumbers(pDAStatics, 
                                          m_flStartX, 
                                          m_flEndX, 
                                          pbvrNormalizedProgress, 
                                          &pbvrX);
    if (FAILED(hr))
    {
        DPF_ERR("Error interpolating DA number in CPathLineSegment::BuildTransform");
        ReleaseInterface(pbvrNormalizedProgress);
        return hr;
    }
    hr = CDAUtils::TIMEInterpolateNumbers(pDAStatics, 
                                          m_flStartY, 
                                          m_flEndY, 
                                          pbvrNormalizedProgress, 
                                          &pbvrY);
    ReleaseInterface(pbvrNormalizedProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error interpolating DA number in CPathLineSegment::BuildTransform");
        ReleaseInterface(pbvrX);
        return hr;
    }

    hr = CDAUtils::BuildMoveTransform2(pDAStatics,
                                       pbvrX,
                                       pbvrY,
                                       ppbvrResult);
    ReleaseInterface(pbvrX);
    ReleaseInterface(pbvrY);
    if (FAILED(hr))
    {
        DPF_ERR("Error building move transform2 in CPathLineSegment::BuildTransform");
        return hr;
    }    
    return S_OK;

} // BuildTransform



//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\pbagimp.cpp ===
//*****************************************************************************
//
// File: pbagimp.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of IPersistPropertyBag2 interface
//           for all objects to call to base class.
//
// Modification List:
// Date		Author		Change
// 11/21/98	jeffort		Created this file
//
//*****************************************************************************

STDMETHODIMP 
THIS::GetClassID(CLSID* pclsid)
{
    return SUPER::GetClassID(pclsid);
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
THIS::InitNew(void)
{
    return SUPER::InitNew();
} // InitNew

//*****************************************************************************

STDMETHODIMP 
THIS::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    return SUPER::Load(pPropBag, pErrorLog);
} // Load

//*****************************************************************************

STDMETHODIMP 
THIS::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return SUPER::Save(pPropBag, fClearDirty, fSaveAllProperties);

} // Save 

//*****************************************************************************

HRESULT 
THIS::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\pcurve.cpp ===
//*****************************************************************************
//
// File:    pathcurv.cpp
// Author:  jeff wall
// Date Created: 11/09/98
//
// Abstract: Implementation of CPathCurve object
//
// Modification List:
// Date		Author		Change
// 11/09/98	jeffwall Created this file from path.cpp
//
//
//*****************************************************************************

#include "headers.h"

#include "pcurve.h"
#include "pathline.h"
#include "dautil.h"

static const float LINETO   = 2.0f;
static const float BEZIERTO = 4.0f;
static const float MOVETO   = 6.0f;

//*****************************************************************************

CPathCurve::CPathCurve() :
    m_flStartX(0.0f),
    m_flStartY(0.0f),
    m_flControl1X(0.0f),
    m_flControl1Y(0.0f),
    m_flControl2X(0.0f),
    m_flControl2Y(0.0f),
    m_flEndX(0.0f),
    m_flEndY(0.0f),
    m_flDistance(0.0f),
    m_pListHead(NULL),
    m_pListTail(NULL),
    m_segCount(0)
{

} //CPathLineSegment

//*****************************************************************************

CPathCurve::~CPathCurve()
{
    CPathElement *pElement = m_pListHead;
    while(NULL != pElement)
    {
        CPathElement *pTemp = pElement->m_pNext;
        delete pElement;
        pElement = pTemp;
    }
    m_pListHead = NULL;
    m_pListTail = NULL;
} // ~CPathLineSegment

//*****************************************************************************

#define TOLERANCE 0.001f

static float
DistanceBetweenTwoPoints(float flX1, float flY1, float flX2, float flY2)
{
    return (float) sqrt( ((flX2 - flX1) * (flX2 - flX1)) +
                 ((flY2 - flY1) * (flY2 - flY1)));
}

//*****************************************************************************

static void SplitBezierComponents(float *pflXComponents,
                           float *pflYComponents,
                           float *pflLeftXComponents,
                           float *pflLeftYComponents,
                           float *pflRightXComponents,
                           float *pflRightYComponents)
{

    float VXTemp[4][4];
    float VYTemp[4][4];
    int i, j;


    for (j=0; j <= 3; j++)
    {
        VXTemp[0][j] = pflXComponents[j];
        VYTemp[0][j] = pflYComponents[j];
    }

    for (i = 1; i <= 3; i++)
    {
        for (j = 0; (j+i) <= 3; j++)
        {
            VXTemp[i][j] = (0.5f * VXTemp[i-1][j]) +
                           (0.5f * VXTemp[i-1][j+1]);

            VYTemp[i][j] = (0.5f * VYTemp[i-1][j]) +
                           (0.5f * VYTemp[i-1][j+1]);
        }
    }

    for (j = 0; j <=3; j++)
    {
        pflLeftXComponents[j] = VXTemp[j][0];
        pflLeftYComponents[j] = VYTemp[j][0];
        pflRightXComponents[j] = VXTemp[3-j][j];
        pflRightYComponents[j] = VYTemp[3-j][j];
    }
       
}

//*****************************************************************************

HRESULT
CPathCurve::createCurveSegments(float *pflXComponents,
                                 float *pflYComponents,
                                 float *pflLength,
                                 float flTolerance)                                 
{
    HRESULT hr = S_OK;
    float flBezLength = 0.0f;
    float flChordLength = 0.0f;

    for (int i = 0; i <= 2; i++)
        flBezLength += DistanceBetweenTwoPoints(pflXComponents[i],
                                                pflYComponents[i],
                                                pflXComponents[i+1],
                                                pflYComponents[i+1]);
    flChordLength = DistanceBetweenTwoPoints(pflXComponents[0],
                                             pflYComponents[0],
                                             pflXComponents[3],
                                             pflYComponents[3]);
    if ((flBezLength - flChordLength) > flTolerance)
    {
        float rgflLeftXComponents[4];
        float rgflLeftYComponents[4];
        float rgflRightXComponents[4];
        float rgflRightYComponents[4];
        SplitBezierComponents(pflXComponents, pflYComponents,
                              rgflLeftXComponents, rgflLeftYComponents,
                              rgflRightXComponents, rgflRightYComponents);
        hr = createCurveSegments(rgflLeftXComponents, rgflLeftYComponents,
                      pflLength, flTolerance);
        if (FAILED(hr))
        {
            return hr;
        }

        hr = createCurveSegments(rgflRightXComponents, rgflRightYComponents,
                      pflLength, flTolerance);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    else
    {
        *pflLength += flBezLength;
        CPathLineSegment * pSegment = new CPathLineSegment;
        if (NULL == pSegment)
            return E_OUTOFMEMORY;

        if (NULL == m_pListHead)
            m_pListHead = pSegment;
        else
            m_pListTail->m_pNext = pSegment;
        m_pListTail = pSegment;
        m_segCount++;
        pSegment->SetValues(pflXComponents[0], pflYComponents[0], pflXComponents[3], pflYComponents[3]);
        
    }
    return S_OK;
}

//*****************************************************************************

float 
CPathCurve::Distance()
{
    return m_flDistance;
} // Distance

//*****************************************************************************
HRESULT 
CPathCurve::SetValues(float flStartX, 
                      float flStartY, 
                      float flControl1X,
                      float flControl1Y,
                      float flControl2X,
                      float flControl2Y,
                      float flEndX, 
                      float flEndY)
{
    m_flStartX = flStartX;
    m_flStartY = flStartY;
    m_flControl1X = flControl1X;
    m_flControl1Y = flControl1Y;
    m_flControl2X = flControl2X;
    m_flControl2Y = flControl2Y;
    m_flEndX = flEndX;
    m_flEndY = flEndY;

    float rgflXComponents[4] = {m_flStartX,
                                m_flControl1X,
                                m_flControl2X,
                                m_flEndX};
    float rgflYComponents[4] = {m_flStartY,
                                m_flControl1Y,
                                m_flControl2Y,
                                m_flEndY};
    return createCurveSegments(rgflXComponents, rgflYComponents, &m_flDistance, TOLERANCE);
}; // SetValues

//*****************************************************************************

HRESULT 
CPathCurve::BuildTransform(IDA2Statics *pDAStatics,
                           IDANumber *pbvrProgress, 
                           float flStartPercentage,
                           float flEndPercentage,
                           IDATransform2 **ppbvrResult)
{
    HRESULT hr = E_FAIL;
    DASSERT(ppbvrResult != NULL);
    *ppbvrResult = NULL;
    int ptcount  = 0;
    int i        = 0;
#ifdef _DEBUG
    int numSegs  = 0;
#endif
    
    CComPtr<IDAPath2>	ppCompletePath;
    CComPtr<IDANumber>	pbvrNormalizedProgress;
    CPathElement        *pSegment = m_pListHead;

    SAFEARRAY * saPoints = SafeArrayCreateVector(VT_R8, 0, (m_segCount+1)* 2);
    SAFEARRAY * saCodes  = SafeArrayCreateVector(VT_R8, 0, (m_segCount+1));

    if (!saPoints || !saCodes)
    {
        goto done;
    }

    VARIANT varPoints;
    VARIANT varCodes;
	
    double *pdblPoints;
    double *pdblCodes;

    VariantInit(&varPoints);
    VariantInit(&varCodes);

    V_ARRAY(&varPoints) = saPoints;
    varPoints.vt = VT_ARRAY | VT_R8;

    V_ARRAY(&varCodes) = saCodes;
    varCodes.vt  = VT_ARRAY | VT_R8;

    pdblPoints = (double *)saPoints->pvData;
    pdblCodes  = (double *)saCodes->pvData;

    // Need to move to the starting point
    pdblCodes[0] = MOVETO;
    for(i=1;i < (m_segCount+1);i++)
        pdblCodes[i]  = LINETO;
   
    while (NULL != pSegment)
    {
       	CPathLineSegment *pLineSegment = reinterpret_cast<CPathLineSegment*>(pSegment);
        if(ptcount == 0)
        {
            // Need to set the starting point
            pdblPoints[ptcount++] = pLineSegment->m_flStartX;
            pdblPoints[ptcount++] = pLineSegment->m_flStartY;
        }

        pdblPoints[ptcount++] = pLineSegment->m_flEndX;
        pdblPoints[ptcount++] = pLineSegment->m_flEndY;
		
        pSegment = pSegment->m_pNext;
#ifdef _DEBUG
        numSegs++;
#endif
    }

#ifdef _DEBUG
	LMTRACE( "created a transform for a path with %d segments\n", numSegs);
#endif
  
    hr = pDAStatics->PolydrawPath(varPoints,varCodes ,&ppCompletePath);
    if(FAILED(hr))
    {
        DPF_ERR("Error creating path");
        goto done;
    }

    hr = NormalizeProgressValue(pDAStatics,
                                pbvrProgress,
                                flStartPercentage,
                                flEndPercentage,
                                &pbvrNormalizedProgress);
    
    if (FAILED(hr))
    {
        DPF_ERR("Error normalizing progress");
        goto done;
    }
    
    hr = pDAStatics->FollowPathEval(ppCompletePath, pbvrNormalizedProgress, ppbvrResult);

done:
    if (saPoints)
    {
        SafeArrayDestroy(saPoints);
    }

    if (saCodes)
    {
        SafeArrayDestroy(saCodes);
    }

    return hr;
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\pelement.cpp ===
//*****************************************************************************
//
// File:    pathelmt.cpp
// Author:  jeff wall
// Date Created: 11/09/98
//
// Abstract: Implementation of CPathElement object which implements
//
// Modification List:
// Date		Author		Change
// 11/09/98	jeffwall Created this file from path.cpp
//
//
//*****************************************************************************

#include "headers.h"

#include "pelement.h"
#include "dautil.h"

//*****************************************************************************

CPathElement::CPathElement() :
    m_pNext(NULL)
{
} // CPathElement 

//*****************************************************************************

CPathElement::~CPathElement() 
{
} // ~CPathElement 

//*****************************************************************************
HRESULT
CPathElement::NormalizeProgressValue(IDA2Statics *pDAStatics,
                                     IDANumber *pbvrProgress, 
                                     float flStartPercentage,
                                     float flEndPercentage,
                                     IDANumber **ppbvrReturn)
{

    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flEndPercentage >= 0.0f);
    DASSERT(flEndPercentage <= 1.0f);
    DASSERT(ppbvrReturn != NULL);
    *ppbvrReturn = NULL;
    
    HRESULT hr;

    if (flStartPercentage >= flEndPercentage)
    {
        DPF_ERR("Error, invalid percentage values");
        return E_INVALIDARG;
    }

    IDANumber *pbvrProgressRange;
    hr = CDAUtils::GetDANumber(pDAStatics, (flEndPercentage - flStartPercentage),
                               &pbvrProgressRange);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in CPathElement::NormalizeProgressValue");
        return hr;
    }
    DASSERT(pbvrProgressRange != NULL);

    IDANumber *pbvrStart;
    hr = CDAUtils::GetDANumber(pDAStatics, flStartPercentage, &pbvrStart);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in CPathElement::NormalizeProgressValue");
        ReleaseInterface(pbvrProgressRange);
        return hr;
    }
    DASSERT(pbvrStart != NULL);
    IDANumber *pbvrSub;
    hr = pDAStatics->Sub(pbvrProgress, pbvrStart, &pbvrSub);
    ReleaseInterface(pbvrStart);
    if (FAILED(hr))
    {
        DPF_ERR("Error subtracting DA number in CPathElement::NormalizeProgressValue");
        ReleaseInterface(pbvrProgressRange);
        return hr;
    }
    DASSERT(pbvrSub != NULL);
    hr = pDAStatics->Div(pbvrSub, pbvrProgressRange, ppbvrReturn);
    ReleaseInterface(pbvrSub);
    ReleaseInterface(pbvrProgressRange);
    if (FAILED(hr))
    {
        DPF_ERR("Error Dividing DA numbers in CPathElement::NormalizeProgressValue");
        return hr;
    }
    return S_OK;
} // NormalizeProgressValue


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\pellipse.cpp ===
//*****************************************************************************
//
// File:    pathange.cpp
// Author:  jeff wall
// Date Created: 11/09/98
//
// Abstract: Implementation of CPathEllipse object
//
// Modification List:
// Date		Author		Change
// 11/09/98	jeffwall Created this file
//
//
//*****************************************************************************

#include "headers.h"

#include "pellipse.h"
#include "dautil.h"

//*****************************************************************************

CPathEllipse::CPathEllipse() :
    m_flHeight(0.0f),
    m_flWidth(0.0f),
    m_flStartAngle(0.0f),
    m_flSweep(0.0f),
    m_flCenterX(0.0f),
    m_flCenterY(0.0f),
    m_flDistance(0.0f)
{

} //CPathAngleElpise

//*****************************************************************************

CPathEllipse::~CPathEllipse()
{

} // ~CPathEllipse

//*****************************************************************************

float 
CPathEllipse::Distance()
{
    return m_flDistance;
}

float 
CPathEllipse::internalDistance()
{
    // Distance is curcumference of the ellipse, * (sweep / 360)
    // 
    // Perimeter == pi * (a + b) [ 1 + 1/4 * ((a - b)/(a + b))^2 + 1/64 * ((a - b)/(a + b))^4 + 1/256 * ((a - b)/(a + b))^6 + ...]
    // or 
    // Perimeter ~= pi * (a + b)/4 [ 3 * ( 1 + lamda ) + 1/(1-lamda) ] where lamda = [ (a-b)/(2 * (a+b) ) ]^2

    float flA = m_flWidth / 2.0f;
    float flB = m_flHeight / 2.0f;

    float flLamda = (float)pow( ( flA - flB ) / ( 2.0f * ( flA + flB) ), 2.0f );
    
    const float pi = 3.14159f;
    float flCircum = (pi * (flB + flA) / 4.0f ) * ( 3.0f * (1.0f + flLamda) + 1.0f / (1.0f - flLamda) );

    float flLength = flCircum * (m_flSweep / ( 2 * pi) );

    return flLength;
} // Distance

//*****************************************************************************
void
CPathEllipse::SetValues(float flCenterX, 
                      float flCenterY, 
                      float flWidth,
                      float flHeight,
                      float flStartAngle,
                      float flSweep,
                      float *flStartX,
                      float *flStartY,
                      float *flEndX,
                      float *flEndY)
{
    m_flCenterX = flCenterX;
    m_flCenterY = flCenterY;
    m_flWidth = flWidth;
    m_flHeight = flHeight;
    m_flStartAngle = flStartAngle;
    m_flSweep = flSweep;

    m_flDistance = (float) fabs(internalDistance());

    
    *flStartX = flCenterX + (m_flWidth / 2.0f) * (float) cos(flStartAngle);
    *flStartY = flCenterY + (m_flHeight / 2.0f) * (float) sin(flStartAngle);
    
    *flEndX = flCenterX + (m_flWidth / 2.0f) * (float) cos(flStartAngle + flSweep);
    *flEndY = flCenterY + (m_flHeight / 2.0f) * (float) sin(flStartAngle + flSweep);
}; // SetValues

//*****************************************************************************

HRESULT 
CPathEllipse::BuildTransform(IDA2Statics *pDAStatics,
                           IDANumber *pbvrProgress, 
                           float flStartPercentage,
                           float flEndPercentage,
                           IDATransform2 **ppbvrResult)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flEndPercentage >= 0.0f);
    DASSERT(flEndPercentage <= 1.0f);
    DASSERT(ppbvrResult != NULL);
    *ppbvrResult = NULL;

    HRESULT hr = S_OK;

    IDANumber *pbvrNormalizedProgress = NULL;
    IDANumber *pbvrX = NULL;
    IDANumber *pbvrY = NULL;
    IDANumber *pbvrStartAngle = NULL;
    IDANumber *pbvrSweep = NULL;
    IDANumber *pbvrPartialSweep = NULL;
    IDANumber *pbvrTheta = NULL;
    IDANumber *pbvrCos = NULL;
    IDANumber *pbvrA = NULL;
    IDANumber *pbvrMulX = NULL;
    IDANumber *pbvrCenterX = NULL;
    IDANumber *pbvrSin = NULL;
    IDANumber *pbvrB = NULL;
    IDANumber *pbvrMulY = NULL;
    IDANumber *pbvrCenterY = NULL;

    hr = NormalizeProgressValue(pDAStatics,
                                pbvrProgress,
                                flStartPercentage,
                                flEndPercentage,
                                &pbvrNormalizedProgress);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    DASSERT(pbvrNormalizedProgress != NULL);
    
    
    hr = CDAUtils::GetDANumber(pDAStatics, m_flStartAngle, &pbvrStartAngle);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = CDAUtils::GetDANumber(pDAStatics, -1.0f * m_flSweep, &pbvrSweep);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Mul(pbvrNormalizedProgress, pbvrSweep, &pbvrPartialSweep);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Add(pbvrPartialSweep, pbvrStartAngle, &pbvrTheta);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    
    // Calculate X bvr
    hr = pDAStatics->Cos(pbvrTheta, &pbvrCos);
    if (FAILED(hr))
    {
        goto cleanup;
    }
        
    hr = CDAUtils::GetDANumber(pDAStatics, m_flWidth / 2.0f, &pbvrA);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Mul(pbvrA, pbvrCos, &pbvrMulX);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = CDAUtils::GetDANumber(pDAStatics, m_flCenterX, &pbvrCenterX);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Add(pbvrMulX, pbvrCenterX, &pbvrX);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    // calculate Y bvr
    hr = pDAStatics->Sin(pbvrTheta, &pbvrSin);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = CDAUtils::GetDANumber(pDAStatics, m_flHeight / 2.0f, &pbvrB);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Mul(pbvrB, pbvrSin, &pbvrMulY);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = CDAUtils::GetDANumber(pDAStatics, m_flCenterY, &pbvrCenterY);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Add(pbvrMulY, pbvrCenterY, &pbvrY);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = CDAUtils::BuildMoveTransform2(pDAStatics,
        pbvrX,
        pbvrY,
        ppbvrResult);
    if (FAILED(hr))
    {
        goto cleanup;
    }

cleanup:
    ReleaseInterface(pbvrNormalizedProgress);
    ReleaseInterface(pbvrX);
    ReleaseInterface(pbvrY);
    ReleaseInterface(pbvrStartAngle);
    ReleaseInterface(pbvrSweep);
    ReleaseInterface(pbvrPartialSweep);
    ReleaseInterface(pbvrTheta);
    ReleaseInterface(pbvrCos);
    ReleaseInterface(pbvrA);
    ReleaseInterface(pbvrMulX);
    ReleaseInterface(pbvrCenterX);
    ReleaseInterface(pbvrSin);
    ReleaseInterface(pbvrB);
    ReleaseInterface(pbvrMulY);
    ReleaseInterface(pbvrCenterY);

    return hr;
} // BuildTransform



//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\sampler.cpp ===
//*****************************************************************************
//
// File:            sampler.cpp
// Author:          kurtj
// Date Created:    11/10/98
//
// Abstract: Implementation of an object that abstracts away sampling of a behavior
//
//*****************************************************************************

#include "headers.h"

#include "sampler.h"
#include "..\chrome\include\utils.h"


//*****************************************************************************

CSampler::CSampler( ILMSample* target ) : m_target(target),
										  m_callback(NULL),
										  m_thisPtr(NULL),
                                          m_cRefs(1)
{
}

//*****************************************************************************

CSampler::CSampler( SampleCallback callback, void *thisPtr ) : m_target(NULL),
												m_callback(callback),
												m_thisPtr(thisPtr),
												m_cRefs(1)
{
}

//*****************************************************************************

CSampler::~CSampler()
{
}

//*****************************************************************************
// IUnknown Interface
//*****************************************************************************

STDMETHODIMP
CSampler::QueryInterface( REFIID riid, void** ppv )
{
    if( ppv == NULL )
        return E_POINTER;

    if( riid == IID_IDABvrHook )
    {
        (*ppv) = static_cast<IDABvrHook*>(this);
    }
    else
    {
        (*ppv) = NULL;
        return E_NOINTERFACE;
    }

    static_cast<IUnknown*>(*ppv)->AddRef();

    return S_OK;

}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CSampler::AddRef()
{
    m_cRefs++;
    return m_cRefs;
}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CSampler::Release()
{
    ULONG refs = --m_cRefs;

    if( refs == 0 )
        delete this;

    return refs;
}

//*****************************************************************************

STDMETHODIMP
CSampler::Invalidate()
{
    m_target = NULL;
	m_callback = NULL;
	m_thisPtr = NULL;
    static_cast<IUnknown*>(this)->Release();
    return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CSampler::Attach( IDABehavior* bvrToHook, IDABehavior** result )
{
    if( bvrToHook == NULL || result == NULL )
        return E_POINTER;
    
    HRESULT hr = S_OK;

    hr = bvrToHook->Hook( static_cast<IDABvrHook*>(this), result );
    if( FAILED( hr ) )
    {
        DPF_ERR( "CSampler: could not hook behavior" );
    }

    return hr;
}

//*****************************************************************************
//IDABvrHook Interface
//*****************************************************************************

STDMETHODIMP     
CSampler::Notify( LONG id,
                  VARIANT_BOOL startingPerformance,
                  double startTime,
                  double gTime,
                  double lTime,
                  IDABehavior * sampleVal,
                  IDABehavior * curRunningBvr,
                  IDABehavior ** ppBvr)
{
	//continue with the current behavior
	(*ppBvr) = NULL;

    if( (m_target != NULL) && !startingPerformance )
    {
        m_target->Sample( startTime, gTime, lTime );
    }

	if ( m_callback != NULL && !startingPerformance)
	{
		(*m_callback)(m_thisPtr, id, startTime, gTime, lTime, sampleVal, ppBvr);
	}
    
    return S_OK;
}

//*****************************************************************************
// End of file
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\pmanager.cpp ===
//*****************************************************************************
//
// File:    pathcurv.cpp
// Author:  jeff wall
// Date Created: 11/09/98
//
// Abstract: Implementation of CPathManager object
//
// Modification List:
// Date		Author		Change
// 11/09/98	jeffwall Created this file from path.cpp
//
//
//*****************************************************************************

#include "headers.h"

#include "pmanager.h"
#include "dautil.h"

#include "pathline.h"
#include "pcurve.h"
#include "pellipse.h"

const float pi = 3.14159f;

//*****************************************************************************

CPathManager::CPathManager() :
    m_pPathHead(NULL),
    m_pPathTail(NULL),
    m_flEndX(0.0f),
    m_flEndY(0.0f),
    m_flStartX(0.0f),
    m_flStartY(0.0f)
{
}; // CPathManager

//*****************************************************************************

CPathManager::~CPathManager()
{
	DeletePathList();
    
} // ~CPathManager


void
CPathManager::DeletePathList()
{
	CPathElement *pDeleteList = m_pPathHead;
    while (pDeleteList != NULL)
    {
        CPathElement *pNext = pDeleteList->m_pNext;
        delete pDeleteList;
        pDeleteList = pNext;
    }
    m_pPathHead = NULL;
    m_pPathTail = NULL;

}

//*****************************************************************************

HRESULT
CPathManager::Initialize(BSTR bstrPath)
{
	DeletePathList();
	
    m_flEndX = 0.0f;
    m_flEndY = 0.0f;
    m_flStartX = 0.0f;
    m_flStartY = 0.0f;

    BSTR bstrParsePath = bstrPath;
    HRESULT hr;
    hr = S_OK;
    while (hr == S_OK)
    {
        CUtils::SkipWhiteSpace(&bstrParsePath);
        hr = ParseForPathElements(&bstrParsePath);
        if (FAILED(hr))
        {
            DPF_ERR("Error parsing for path elements");
            return hr;
        }
    }
    return S_OK;
} // Initialize

//*****************************************************************************

HRESULT 
CPathManager::ParseForPathElements(BSTR *pbstrPath)
{
    HRESULT hr;

    // we need to parse through for objects we know
    switch (**pbstrPath)
    {
    case (L'e'):
        m_flStartX = 0.0f;
        m_flStartY = 0.0f;
        m_flEndX = 0.0f;
        m_flEndY = 0.0f;
        break;

    case (L'm'):
        {
        // for the move to, we should have two floats which resets
        // the start X and Y and we reset our current end values to these
        // skip past the char
        (*pbstrPath)++;
        float flX;
        float flY;
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flX);
        if (hr != S_OK)
        {
            DPF_ERR("Error in path string: float value expected");
            return E_INVALIDARG;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flY);
        if (hr != S_OK)
        {
            DPF_ERR("Error in path string: float value expected");
            return E_INVALIDARG;
        }
        m_flStartX = flX;
        m_flStartY = flY;
        m_flEndX = flX;
        m_flEndY = flY;
        }
        break;

    case (L't'):
        {
        (*pbstrPath)++;
        float flX;
        float flY;
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flX);
        if (hr != S_OK)
        {
            DPF_ERR("Error in path string: float value expected");
            return E_INVALIDARG;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flY);
        if (hr != S_OK)
        {
            DPF_ERR("Error in path string: float value expected");
            return E_INVALIDARG;
        }
        m_flStartX += flX;
        m_flStartY += flY;
        m_flEndX += flX;
        m_flEndY += flY;
        }
        break;
    case (L'l'):
    case (L'r'):
        hr = ParseLineElement(pbstrPath);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating line element");
            return hr;
        }
        hr = S_OK;
        break;

    case (L'c'):
    case (L'v'):
        hr = ParseCurveElement(pbstrPath);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating curve element");
            return hr;
        }
        hr = S_OK;
        break;
    case (L'x'):
        // Skip Past the 'x' tag
        (*pbstrPath)++;
        CPathLineSegment *pLineSegment;
        pLineSegment = new CPathLineSegment;
        if (pLineSegment == NULL)
        {
            DPF_ERR("Error creating line segment object");
            return E_OUTOFMEMORY;
        }
        pLineSegment->SetValues(m_flEndX, m_flEndY, m_flStartX, m_flStartY);
        // and add this line segment to our list
        AddPathObjectToList(pLineSegment);
        m_flEndX = m_flStartX;
        m_flEndY = m_flStartY;
        hr = S_OK;

        break;
    case (L'a'):
    case (L'w'):
        wchar_t wcNext;
        (*pbstrPath)++;
        wcNext = (**pbstrPath);
        (*pbstrPath)--;
        switch(wcNext)
        {
        case (L'l'):
        case (L'e'):
            hr = ParseEllipseElement(pbstrPath);
            if (FAILED(hr))
            {
                DPF_ERR("Error creating ellipse element");
                return hr;
            }
            hr = S_OK;
            break;
        case (L't'):
        case (L'r'):
        case (L'a'):
            hr = ParseArcElement(pbstrPath);
            if (FAILED(hr))
            {
                DPF_ERR("Error creating arc element");
                return hr;
            }
            hr = S_OK;
            break;
        default:
            hr = S_FALSE;
            break;
        }
        break;
    case (L'q'):        
        (*pbstrPath)++;
        wcNext = (**pbstrPath);
        (*pbstrPath)--;
        switch(wcNext)
        {
        case (L'x'):
        case (L'y'):
            hr = ParseEllipseQuadrant(pbstrPath);
            if (FAILED(hr))
            {
                DPF_ERR("Error createing EllipseQuadrant");
                return hr;
            }
            hr = S_OK;
            break;
        case (L'b'):
            break;
        }
        break;
    default:
        hr = S_FALSE;
        break;
    }

    return hr;
} // ParseForPathElements

//*****************************************************************************

void 
CPathManager::AddPathObjectToList(CPathElement *pObject)
{
    DASSERT(pObject != NULL);
    if (m_pPathTail != NULL)
        m_pPathTail->m_pNext = pObject;
    else
        m_pPathHead = pObject;
     m_pPathTail = pObject;
     pObject->m_pNext = NULL;

} // AddPathObjectToList

//*****************************************************************************

HRESULT 
CPathManager::RecursiveBuildAllPathTransforms(IDA2Statics *pDAStatics,
                                          IDANumber *pbvrProgress,
                                          CPathElement *pPathObj,
                                          float flStartPercentage,
                                          float flTotalPercentage,
                                          float flTotalDistance,
                                          IDATransform2 **ppbvrResult)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(pPathObj != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flTotalPercentage >= 0.0f);
    DASSERT(flTotalPercentage <= 1.0f);
    DASSERT(ppbvrResult != NULL);
    *ppbvrResult = NULL;

    HRESULT hr;
    // first we build the transform for the current path element
    IDATransform2 *pbvrTransform;
    float flDistance = pPathObj->Distance();
    float flEndPercentage = flStartPercentage + (flTotalPercentage * (flDistance / flTotalDistance));
    hr = pPathObj->BuildTransform(pDAStatics,
                        pbvrProgress,
                        flStartPercentage,
                        flEndPercentage,
                        &pbvrTransform);
    if (pPathObj->m_pNext == NULL)
    {
        // we can simply return the built transform
        *ppbvrResult = pbvrTransform;
    }
    else
    {
        // we need to build a conditional by recursing in and getting
        // the next transform for the next object
        IDATransform2 *pbvrTransformNext;
        hr = RecursiveBuildAllPathTransforms(pDAStatics,
                                             pbvrProgress,
                                             pPathObj->m_pNext,
                                             flEndPercentage,
                                             flTotalPercentage,
                                             flTotalDistance,
                                             &pbvrTransformNext);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating next transform");
            ReleaseInterface(pbvrTransform);
            return hr;
        }
        // now build the conditional for this
        IDANumber *pbvrEndProgress;
        hr = CDAUtils::GetDANumber(pDAStatics, flEndPercentage, &pbvrEndProgress);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting DA number");
            ReleaseInterface(pbvrTransform);
            ReleaseInterface(pbvrTransformNext);
            return hr;
        }
        IDABoolean *pbvrBoolean;
        hr = pDAStatics->LTE(pbvrProgress, pbvrEndProgress, &pbvrBoolean);
        ReleaseInterface(pbvrEndProgress);
        if (FAILED(hr))
        {
            DPF_ERR("Error building boolean");
            ReleaseInterface(pbvrTransform);
            ReleaseInterface(pbvrTransformNext);
            return hr;
        }
        IDABehavior *pbvrReturn;
        hr = pDAStatics->Cond(pbvrBoolean, 
                              pbvrTransform, 
                              pbvrTransformNext, 
                              &pbvrReturn);
        ReleaseInterface(pbvrBoolean);
        ReleaseInterface(pbvrTransform);
        ReleaseInterface(pbvrTransformNext);
        if (FAILED(hr))
        {
            DPF_ERR("Error in calling DA Cond");
            return hr;
        }
        hr = pbvrReturn->QueryInterface(IID_TO_PPV(IDATransform2, ppbvrResult));
        ReleaseInterface(pbvrReturn);
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing behavior for IDATranform2");
            return hr;
        }
    }
    return S_OK;
} // RecursiveBuildAllPathTransforms

//*****************************************************************************

HRESULT 
CPathManager::BuildTransform(IDA2Statics *pDAStatics,
                         IDANumber *pbvrProgress, 
                         float flStartPercentage,
                         float flEndPercentage,
                         IDATransform2 **ppbvrResult)
{

    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flEndPercentage >= 0.0f);
    DASSERT(flEndPercentage <= 1.0f);
    DASSERT(ppbvrResult != NULL);
    *ppbvrResult = NULL;



    HRESULT hr;

    // What we need to do is count the number of path objects
    // we have pointers to and use this to calculate the start
    // and end percentage of progress that each Path element
    // uses based on distance.  We then can get a transform
    // from each object and build a conditional using progress as below

    int cNumPathElements = 0;
    float flTotalDistance = 0.0f;
    CPathElement *pbvrList = m_pPathHead;
    while (pbvrList != NULL)
    {
        cNumPathElements++;
        flTotalDistance += pbvrList->Distance();
        pbvrList = pbvrList->m_pNext;
    }
    if (cNumPathElements == 0)
    {
        DPF_ERR("Error invalid path containing no elements");
        return E_INVALIDARG;
    }
    else if (cNumPathElements == 1)
    {
        // in the case of a single path element, we can simply
        // get its transform and return
        hr = m_pPathHead->BuildTransform(pDAStatics,
                                           pbvrProgress,
                                           flStartPercentage,
                                           flEndPercentage,
                                           ppbvrResult);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting transform for single path element");
            return hr;
        }
    }
    else
    {
        hr = RecursiveBuildAllPathTransforms(pDAStatics,
                                             pbvrProgress,
                                             m_pPathHead,
                                             flStartPercentage,
                                             flEndPercentage - flStartPercentage,
                                             flTotalDistance,
                                             ppbvrResult);
        if (FAILED(hr))
        {
            DPF_ERR("Error recursively building transform");
            return hr;
        }
    }
    return S_OK;
} // BuildTransform

//*****************************************************************************

HRESULT 
CPathManager::ParseLineElement(BSTR *pbstrPath)
{
    HRESULT hr = S_OK;
    bool fRelativeLines = false;

    DASSERT(**pbstrPath == L'l' || **pbstrPath == L'r');
    if (**pbstrPath == L'r')
        fRelativeLines = true;
    // Skip Past the 'l' or 'r' tag
    (*pbstrPath)++;
    while (hr == S_OK && **pbstrPath != L'\0')
    {
        CUtils::SkipWhiteSpace(pbstrPath);
        float flX, flY;
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flX);
        if (FAILED(hr))
        {
            DPF_ERR("Error parsing line: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flY);
        // this check is for more than just failed, we need to
        // insure that a y value came if an x value was set
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing line: float value expected");
            return hr;
        }
        if (fRelativeLines)
        {
            flX += m_flEndX;
            flY += m_flEndY;
        }

        // create a new line segment
        CPathLineSegment *pLineSegment = new CPathLineSegment;
        if (pLineSegment == NULL)
        {
            DPF_ERR("Error creating line segment object");
            return E_OUTOFMEMORY;
        }
        pLineSegment->SetValues(m_flEndX, m_flEndY, flX, flY);
        // and add this line segment to our list
        AddPathObjectToList(pLineSegment);
        m_flEndX = flX;
        m_flEndY = flY;
    }
    return S_OK;
} // ParseLineElement

//*****************************************************************************

HRESULT 
CPathManager::ParseCurveElement(BSTR *pbstrPath)
{
    HRESULT hr = S_OK;
    bool fRelativeCurve = false;

    DASSERT(**pbstrPath == L'c' || **pbstrPath == L'v');
    if (**pbstrPath == L'v')
        fRelativeCurve = true;
    // Skip Past the 'v' or 'c' tag
    (*pbstrPath)++;
    while (hr == S_OK && **pbstrPath != L'\0')
    {
        CUtils::SkipWhiteSpace(pbstrPath);
        float flControl1X, flControl1Y;
        float flControl2X, flControl2Y;
        float flEndX, flEndY;
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flControl1X);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flControl1Y);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flControl2X);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flControl2Y);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndX);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndY);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        if (fRelativeCurve)
        {
            flControl1X += m_flEndX;
            flControl1Y += m_flEndY;
            flControl2X += m_flEndX;
            flControl2Y += m_flEndY;
            flEndX += m_flEndX;
            flEndY += m_flEndY;
        }

        // create a new line segment
        CPathCurve *pCurve = new CPathCurve;
        if (pCurve == NULL)
        {
            DPF_ERR("Error creating curve object");
            return E_OUTOFMEMORY;
        }
        // and add this curve to our list
        AddPathObjectToList(pCurve);

        hr = pCurve->SetValues(m_flEndX, m_flEndY, 
                          flControl1X, flControl1Y,
                          flControl2X, flControl2Y,
                          flEndX, flEndY);
        if (FAILED(hr))
        {
            DPF_ERR("Error Parsing curve: error setting values");
            return hr;
        }

        m_flEndX = flEndX;
        m_flEndY = flEndY;
    }
    return S_OK;
} // ParseCurveElement

//*****************************************************************************

HRESULT 
CPathManager::ParseEllipseElement(BSTR *pbstrPath)
{
    HRESULT hr = S_OK;

    DASSERT(L'a' == **pbstrPath );

    // Skip Past the 'a' tag
    (*pbstrPath)++;
    
    DASSERT(L'l' == **pbstrPath || L'e' == **pbstrPath);
    
    bool fLineTo = false;
    if (L'e' == **pbstrPath)
    {
        // need to create a line seqment to here starting position
        fLineTo = true;
    }

    // skip path 'l' or 'e' tag
    (*pbstrPath)++;

    // Begin parsing the float values.

    CUtils::SkipWhiteSpace(pbstrPath);
    
    float flCenterX, flCenterY;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flCenterX);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flCenterY);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    float flWidth, flHeight;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flWidth);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    if (flWidth < 0.0f)
    {
        return E_INVALIDARG;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flHeight);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    if (flHeight < 0.0f)
    {
        return E_INVALIDARG;
    }
    
    float flStartAngle, flSweep;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flStartAngle);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flSweep);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    float flStartX, flStartY;

    float flEndX, flEndY;
    
    CPathEllipse *pEllipse;
    pEllipse = new CPathEllipse;
    if (NULL == pEllipse)
    {
        DPF_ERR("Error creating ellipse object");
        return E_OUTOFMEMORY;
    }

    pEllipse->SetValues(flCenterX, flCenterY, flWidth, flHeight, flStartAngle, flSweep, &flStartX, &flStartY, &flEndX, &flEndY);
   
    if (fLineTo)
    {
        // create a new line segment
        CPathLineSegment *pLineSegment = new CPathLineSegment;
        if (pLineSegment == NULL)
        {
            DPF_ERR("Error creating line segment object");
            return E_OUTOFMEMORY;
        }
        pLineSegment->SetValues(m_flEndX, m_flEndY, flStartX, flStartY);
        
        // and add this line segment to our list
        AddPathObjectToList(pLineSegment);
    }
    
    AddPathObjectToList(pEllipse);
    
    m_flEndX = flEndX;
    m_flEndY = flEndY;
    
    
    return S_OK;
} // ParseEllipseElement

//*****************************************************************************

HRESULT 
CPathManager::ParseArcElement(BSTR *pbstrPath)
{
    HRESULT hr = S_OK;

    DASSERT(L'a' == **pbstrPath || L'w' == **pbstrPath);
    bool fCCW = true;
    if (L'w' == **pbstrPath)
    {
        fCCW = false;
    }

    // Skip Past the 'a' tag
    (*pbstrPath)++;
    
    DASSERT(L't' == **pbstrPath || L'r' == **pbstrPath || L'a' == **pbvrPath);
    
    bool fLineTo = false;
    if (L't' == **pbstrPath || L'a' == **pbstrPath)
    {
        // need to create a line seqment to here starting position
        fLineTo = true;
    }

    // skip path 'l' or 'e' tag
    (*pbstrPath)++;

    // Begin parsing the float values.

    CUtils::SkipWhiteSpace(pbstrPath);
    
    float flLeft, flTop;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flLeft);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flTop);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    float flRight, flBottom;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flRight);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }

    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flBottom);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }

    float flStartX, flStartY;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flStartX);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flStartY);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }

    float flEndX, flEndY;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndX);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndY);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    CPathEllipse *pEllipse;
    pEllipse = new CPathEllipse;
    if (NULL == pEllipse)
    {
        DPF_ERR("Error creating ellipse object");
        return E_OUTOFMEMORY;
    }

    float flCenterX;
    flCenterX = (flLeft + flRight) / 2.0f;
    float flCenterY;
    flCenterY = (flTop + flBottom) / 2.0f;
    float flWidth;
    flWidth = (flRight - flLeft);
    float flHeight;
    flHeight = (flBottom - flTop);

    float flDeltaY, flDeltaX;
    flDeltaY = flStartY - flCenterY;
    flDeltaX = flStartX - flCenterX;

    float flStartAngle;
    GetAngle(flDeltaX, flDeltaY, &flStartAngle);
    DASSERT( flStartAngle >= 0.0f && flStartAngle < ( 2 * pi ) );

    flDeltaY = flEndY - flCenterY;
    flDeltaX = flEndX - flCenterX;

    float flEndAngle;
    GetAngle(flDeltaX, flDeltaY, &flEndAngle);
    DASSERT( flEndAngle >= 0.0f && flEndAngle < ( 2 * pi ) );

    float flSweep;
    if (fCCW)
    {
        if (flEndAngle > flStartAngle)
            // we are crossing over 0 radians
            flSweep = flStartAngle + (2 * pi) - flEndAngle;
        else
            flSweep = flStartAngle - flEndAngle;
    }
    else
    {
        if (flEndAngle > flStartAngle)
            flSweep = -1.0f * (flEndAngle - flStartAngle);
        else
            // crossing over 0 radians
            flSweep = -1.0f * (flEndAngle + (2 * pi) - flStartAngle);
    }
    pEllipse->SetValues(flCenterX, flCenterY, flWidth, flHeight, flStartAngle, flSweep, &flStartX, &flStartY, &flEndX, &flEndY);
   
    if (fLineTo)
    {
        // create a new line segment
        CPathLineSegment *pLineSegment = new CPathLineSegment;
        if (pLineSegment == NULL)
        {
            DPF_ERR("Error creating line segment object");
            return E_OUTOFMEMORY;
        }
        pLineSegment->SetValues(m_flEndX, m_flEndY, flStartX, flStartY);
        
        // and add this line segment to our list
        AddPathObjectToList(pLineSegment);
    }
    
    AddPathObjectToList(pEllipse);
    
    m_flEndX = flEndX;
    m_flEndY = flEndY;
    
    
    return S_OK;
} // ParseEllipseElement

//*****************************************************************************
HRESULT 
CPathManager::ParseEllipseQuadrant(BSTR *pbstrPath)
{
    HRESULT hr = S_OK;

    DASSERT(L'q' == **pbstrPath );

    // Skip Past the 'a' tag
    (*pbstrPath)++;
    
    DASSERT(L'x' == **pbstrPath || L'y' == **pbstrPath);

    bool fQuadrantX = true;
    if (L'y' == **pbstrPath)
    {
        fQuadrantX = false;
    }

    // skip path 'x' or 'y' tag
    (*pbstrPath)++;

    // Begin parsing the float values.

    CUtils::SkipWhiteSpace(pbstrPath);

    float flEndX, flEndY;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndX);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndY);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    CPathEllipse *pEllipse;
    pEllipse = new CPathEllipse;
    if (NULL == pEllipse)
    {
        DPF_ERR("Error creating ellipse object");
        return E_OUTOFMEMORY;
    }

    AddPathObjectToList(pEllipse);
    
    float flCenterX, flCenterY, flStartAngle, flSweep;
    
    if(fQuadrantX)
    {
        flCenterX = m_flEndX;
        flCenterY = flEndY;

        if ((flEndY - m_flEndY) > 0.0f)
        {
            // Positive deltaY
            flStartAngle = 3.0f * pi / 2.0f;
            if ((flEndX - m_flEndX) > 0.0f)
            {
                // Positive deltaX -- same as deltaY
                flSweep = pi / -2.0f;
            }
            else
            {
                // Negative deltaX -- different from deltaY
                flSweep = pi / 2.0f;
            }
        }
        else
        {
            // Negative deltaY
            flStartAngle = pi / 2.0f;
            if ((flEndX - m_flEndX) > 0.0f)
            {
                // positive deltaX -- different from deltaY
                flSweep = pi / 2.0f;
            }
            else
            {
                // negative deltaX -- same as deltaY
                flSweep = pi / -2.0f;
            }
            
        }
    } // if (fQuadrantX)
    else  // fQuadrantY
    {
        flCenterX = flEndX;
        flCenterY = m_flEndY;

        if ((flEndX - m_flEndX) > 0.0f)
        {
            // Positive deltaX
            flStartAngle = pi;
            if ((flEndY - m_flEndY) > 0.0f)
            {
                // positve deltaY -- same as deltaX
                flSweep = pi / 2.0f;
            }
            else
            {
                // negative deltaY -- different from deltaX
                flSweep = pi / -2.0f;
            }
        }
        else
        {
            // Negative deltaX
            flStartAngle = 0.0f;
            if ((flEndY - m_flEndY) > 0.0f)
            {
                // positve deltaY -- different from deltaX
                flSweep = pi / -2.0f;
            }
            else
            {
                // negative deltaY -- same as deltaX
                flSweep = pi / 2.0f;
            }
        }
    } // if (fQuadrantY)

    float flWidth = 2.0f * (float)fabs(m_flEndX - flEndX);
    float flHeight = 2.0f * (float)fabs(m_flEndY - flEndY);

    float flJunk;
    pEllipse->SetValues(flCenterX, flCenterY, flWidth, flHeight, flStartAngle, flSweep, &flJunk, &flJunk, &flJunk, &flJunk);
   
    m_flEndX = flEndX;
    m_flEndY = flEndY;
        
    return S_OK;
} // ParseEllipseQuadrant

//*****************************************************************************

float
CPathManager::Distance()
{
    float flTotalDistance = 0.0f;
    CPathElement *pList = m_pPathHead;
    while (pList != NULL)
    {
        flTotalDistance += pList->Distance();
        pList = pList->m_pNext;
    }
    return flTotalDistance;
} // Distance

//*****************************************************************************
// calculate the angle of the point(DeltaX, DeltaY), in radians: 0 <= ret < 2pi
//
void CPathManager::GetAngle(float flDeltaX, float flDeltaY, float *flAngle)
{
    const float EPSILON = 1e-5f;

    if (fabs(flDeltaX) < EPSILON)
    {
        // Point is on Y axis
        if (flDeltaY > 0.0f)
        {
            *flAngle = pi / 2.0f;
        }
        else
        {
            *flAngle = 3.0f * pi / 2.0f;
        }
        return;
    }
    if (fabs(flDeltaY) < EPSILON)
    {
        // Point is on X axis
        if (flDeltaX > 0.0f)
        {
            *flAngle = 0.0f;
        }
        else
        {
            *flAngle = pi;
        }
        return;
    }

    *flAngle = (float) atan( flDeltaY / flDeltaX );

    if (flDeltaY > 0.0f && flDeltaX > 0.0f)
    {
        //Quadrant I
        DASSERT(flAngle > 0.0f);
        return;
    }
    else if (flDeltaY > 0.0f && flDeltaX < 0.0f)
    {
        //Quadrant II
        DASSERT(flAngle < 0.0f);
        *flAngle += pi;
        return;
    }
    else if (flDeltaY < 0.0f && flDeltaX < 0.0f)
    {
        //Quadrant III
        DASSERT(flAngle > 0.0f);
        *flAngle += pi;
        return;
    }
    else if (flDeltaY < 0.0f && flDeltaX > 0.0f)
    {
        //Quadrant IV
        DASSERT(flAngle < 0.0f);
        *flAngle += 2 * pi;
        return;
    }
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\rotate.cpp ===
//*****************************************************************************
//
// File: rotate.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CRotateBvr object which implements
//			 the chromeffects rotate DHTML behavior
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/16/98 jeffort     Added animates property
// 10/16/98 jeffort     Renamed functions, implemented building DA behavior
// 10/21/98 jeffort     changed code to use base class to build DA Number
//
//*****************************************************************************

#include "headers.h"

#include "rotate.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CRotateBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_FROM        0
#define VAR_TO          1
#define VAR_BY          2
#define VAR_TYPE		3
#define VAR_MODE		4

WCHAR * CRotateBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_FROM,
                                     BEHAVIOR_PROPERTY_TO,
                                     BEHAVIOR_PROPERTY_BY,
									 BEHAVIOR_PROPERTY_TYPE,
									 BEHAVIOR_PROPERTY_MODE
                                    };

//*****************************************************************************

CRotateBvr::CRotateBvr():
	m_pdispActor( NULL ),
	m_lCookie( 0 )
{
    VariantInit(&m_varFrom);
    VariantInit(&m_varTo);
    VariantInit(&m_varBy);
	VariantInit(&m_varType);
	VariantInit(&m_varMode);
    m_clsid = CLSID_CrRotateBvr;
} // CRotateBvr

//*****************************************************************************

CRotateBvr::~CRotateBvr()
{
    VariantClear(&m_varFrom);
    VariantClear(&m_varTo);
    VariantClear(&m_varBy);
	VariantClear(&m_varType);
	VariantClear(&m_varMode);

	ReleaseInterface( m_pdispActor );
} // ~RotateBvr

//*****************************************************************************

HRESULT CRotateBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in rotate behavior FinalConstruct initializing base classes");
        return hr;
    }

    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CRotateBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_ROTATE_PROPS);
    switch (iIndex)
    {
    case VAR_FROM:
        return &m_varFrom;
        break;
    case VAR_TO:
        return &m_varTo;
        break;
    case VAR_BY:
        return &m_varBy;
        break;
	case VAR_TYPE:
		return &m_varType;
		break;
	case VAR_MODE:
		return &m_varMode;
		break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CRotateBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_ROTATE_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	LMTRACE( L"Init for RotateBvr <%p>\n", this );
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;
} // Notify

//*****************************************************************************

STDMETHODIMP
CRotateBvr::Detach()
{
	HRESULT hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR( "Failed in superclass detach" );
	}

	hr = RemoveFragment();
	CheckHR( hr, "Failed to remove the fragment from the actor ", end );

end:
	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CRotateBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CRotateBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CRotateBvr::put_from(VARIANT varFrom)
{
    HRESULT hr = VariantCopy(&m_varFrom, &varFrom);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting from for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRROTATEBVR_FROM);
} // put_from

//*****************************************************************************

STDMETHODIMP
CRotateBvr::get_from(VARIANT *pRetFrom)
{
    if (pRetFrom == NULL)
    {
        DPF_ERR("Error in CRotateBvr:get_from, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetFrom, &m_varFrom);
} // get_from

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::put_to(VARIANT varTo)
{
    HRESULT hr = VariantCopy(&m_varTo, &varTo);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting to for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRROTATEBVR_TO);
} // put_to

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::get_to(VARIANT *pRetTo)
{
    if (pRetTo == NULL)
    {
        DPF_ERR("Error in CRotateBvr:get_to, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTo, &m_varTo);
} // get_to

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::put_by(VARIANT varBy)
{
    HRESULT hr = VariantCopy(&m_varBy, &varBy);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting to for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRROTATEBVR_BY);
} // put_by

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::get_by(VARIANT *pRetBy)
{
    if (pRetBy == NULL)
    {
        DPF_ERR("Error in CRotateBvr:get_by, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetBy, &m_varBy);
} // get_by

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting type for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRROTATEBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in get_type, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::put_mode(VARIANT varMode)
{
    HRESULT hr = VariantCopy(&m_varMode, &varMode);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting mode for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRROTATEBVR_MODE);
} // put_mode

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::get_mode(VARIANT *pRetMode)
{
    if (pRetMode == NULL)
    {
        DPF_ERR("Error in get_mode, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetMode, &m_varMode);
} // get_mode

//*****************************************************************************

HRESULT 
CRotateBvr::BuildAnimationAsDABehavior()
{
	// TODO (markhal): This goes away soon
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CRotateBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{

	LMTRACE( L"buildBehaviorFragments for Rotate <%p>\n", this );
    HRESULT hr;

    hr = RemoveFragment();
    if( FAILED( hr ) )
    {
    	DPF_ERR( "Failed to remove fragment" );
    	return hr;
    }
    
    float flFrom, flTo;
	ActorBvrFlags flags = e_Absolute;
    IDANumber *pbvrInterpolatedAngle = NULL;

    hr = CUtils::InsurePropertyVariantAsFloat(&m_varFrom);
    if (FAILED(hr))
    {
		// There was no from, there could be a by attribute
		hr = CUtils::InsurePropertyVariantAsFloat(&m_varBy);
		if (FAILED(hr))
		{
			hr = CUtils::InsurePropertyVariantAsFloat(&m_varTo);

			if (FAILED(hr))
			{
				// Nothing we can do
				return hr;
			}

			// We have a to but no from.  This means we need to get the
			// to value from the actor
			IDABehavior *pFromBvr;
			hr = GetBvrFromActor(pActorDisp, L"style.rotation", e_From, e_Number, &pFromBvr);
			if (FAILED(hr))
				return hr;

			IDANumber *pFrom;
			hr = pFromBvr->QueryInterface(IID_TO_PPV(IDANumber, &pFrom));
			ReleaseInterface(pFromBvr);
			if (FAILED(hr))
				return hr;

			IDANumber *pTo;
			hr = GetDAStatics()->DANumber(m_varTo.fltVal, &pTo);
			if (FAILED(hr))
			{
				ReleaseInterface(pFrom);
				return hr;
			}

			hr = BuildTIMEInterpolatedNumber(pFrom, pTo, &pbvrInterpolatedAngle);
			ReleaseInterface(pFrom);
			ReleaseInterface(pTo);
			if (FAILED(hr))
				return hr;

			flags = e_AbsoluteAccum;
		}
		else
		{
			// Create a relative rotation from 0 to by
			flFrom = 0;
			flTo = m_varBy.fltVal;
			flags = e_RelativeAccum;
		}
	}
	else
	{
		// We got a valid from value
		flFrom = m_varFrom.fltVal;
		flags = e_Absolute;

		hr = CUtils::InsurePropertyVariantAsFloat(&m_varTo);
		if (FAILED(hr))
		{
			// there was no valid to attribute specified, try for a by attribute
			hr = CUtils::InsurePropertyVariantAsFloat(&m_varBy);
			if (FAILED(hr))
			{
				DPF_ERR("Inappropriate set of attributes");
				return SetErrorInfo(hr);
			}
			flTo = flFrom + m_varBy.fltVal;
		}
		else
		{
			flTo = m_varTo.fltVal;
		}
	}

	if (pbvrInterpolatedAngle == NULL)
	{
		// We need to build a rotate behavior from from and to
		hr = BuildTIMEInterpolatedNumber(flFrom,
										 flTo,
										 &pbvrInterpolatedAngle);
		if (FAILED(hr))
		{
			DPF_ERR("Error building interpolated angle");
			return hr;
		}
	}

/* Don't do this any more.  Just animate the style.rotation attribute
	// Convert to Radians
	IDANumber *pAngleRadians = NULL;
	hr = GetDAStatics()->ToRadians(pbvrInterpolatedAngle, &pAngleRadians);
	ReleaseInterface(pbvrInterpolatedAngle);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to convert to radians");
		return hr;
	}

	// Turn the rotation into an IDATransform2
	IDATransform2 *pTransform = NULL;
	hr = GetDAStatics()->Rotate2Anim(pAngleRadians, &pTransform);
	ReleaseInterface(pAngleRadians);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to created rotation transform");
		return hr;
	}

	// Send transform to actor
	hr = AttachBehaviorToActor( pActorDisp, pTransform, L"rotation", (relative?e_Relative:e_Absolute) , e_Rotation );
    if (FAILED(hr))
    {
        DPF_ERR("Error attaching rotation behavior to actor");
        return hr;
    }
*/
	IDispatch *pdispThis = NULL;
	hr = GetHTMLElementDispatch( &pdispThis );
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to get the dispatch of the element" );
		return hr;
	}

	// Send rotation to actor
	hr = AttachBehaviorToActorEx( pActorDisp, 
								  pbvrInterpolatedAngle, 
								  L"style.rotation", 
								  FlagFromTypeMode(flags, &m_varType, &m_varMode), 
								  e_Number,
								  pdispThis,
								  &m_lCookie);

	ReleaseInterface( pdispThis );
	
    if (FAILED(hr))
    {
        DPF_ERR("Error attaching rotation behavior to actor");
        return hr;
    }

    m_pdispActor = pActorDisp;
    m_pdispActor->AddRef();

    return S_OK;
}


//*****************************************************************************

HRESULT
CRotateBvr::RemoveFragment()
{
	HRESULT hr = S_OK;
	
	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		hr  = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		ReleaseInterface( m_pdispActor );
		m_lCookie = 0;
		CheckHR( hr, "Failed to remove a fragment from the actor", end );
	}

end:

	return hr;
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\scale.cpp ===
//*****************************************************************************
//
// File: scale.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CScaleBvr object which implements
//			 the chromeffects scale DHTML behavior
//
// Modification List:
// Date		Author		Change
// 10/20/98	jeffort		Created this file
// 10/21/98 jeffort     Reworked code, use values as percentage
//*****************************************************************************

#include "headers.h"

#include "scale.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CScaleBvr
#define SUPER CBaseBehavior

#define SCALE_NORMALIZATION_VALUE   100.0f

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_FROM        0
#define VAR_TO          1
#define VAR_BY          2
#define VAR_TYPE		3
#define VAR_MODE		4

WCHAR * CScaleBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_FROM,
                                     BEHAVIOR_PROPERTY_TO,
                                     BEHAVIOR_PROPERTY_BY,
									 BEHAVIOR_PROPERTY_TYPE,
									 BEHAVIOR_PROPERTY_MODE
                                    };

//*****************************************************************************

CScaleBvr::CScaleBvr() :
	m_pdispActor( NULL ),
	m_lCookie( 0 )
{
    VariantInit(&m_varFrom);
    VariantInit(&m_varTo);
    VariantInit(&m_varBy);
	VariantInit(&m_varType);
	VariantInit(&m_varMode);
    m_clsid = CLSID_CrScaleBvr;
} // CScaleBvr

//*****************************************************************************

CScaleBvr::~CScaleBvr()
{
    VariantClear(&m_varFrom);
    VariantClear(&m_varTo);
    VariantClear(&m_varBy);
	VariantClear(&m_varType);
	VariantClear(&m_varMode);

	ReleaseInterface( m_pdispActor );
} // ~ScaleBvr

//*****************************************************************************

HRESULT CScaleBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in scale behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CScaleBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_SCALE_PROPS);
    switch (iIndex)
    {
    case VAR_FROM:
        return &m_varFrom;
        break;
    case VAR_TO:
        return &m_varTo;
        break;
    case VAR_BY:
        return &m_varBy;
        break;
	case VAR_TYPE:
		return &m_varType;
		break;
	case VAR_MODE:
		return &m_varMode;
		break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CScaleBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_SCALE_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;

} // Notify

//*****************************************************************************

STDMETHODIMP
CScaleBvr::Detach()
{
	LMTRACE( "Begin detach of CScaleBvr <%p>\n", this );
	HRESULT hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to in super class detach " );
	}

	if( m_pdispActor != NULL && m_lCookie != NULL )
	{
		hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		ReleaseInterface( m_pdispActor );
		CheckHR( hr, "Failed to remove the behavior from the actor", end );
		m_lCookie = 0;
	}

	LMTRACE( "End detach of CScaleBvr <%p>\n", this );

end:
	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CScaleBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CScaleBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CScaleBvr::put_from(VARIANT varFrom)
{
    HRESULT hr = VariantCopy(&m_varFrom, &varFrom);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting from for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRSCALEBVR_FROM);
} // put_from

//*****************************************************************************

STDMETHODIMP
CScaleBvr::get_from(VARIANT *pRetFrom)
{
    if (pRetFrom == NULL)
    {
        DPF_ERR("Error in CScaleBvr:get_from, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetFrom, &m_varFrom);
} // get_from

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::put_to(VARIANT varTo)
{
    HRESULT hr = VariantCopy(&m_varTo, &varTo);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting to for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRSCALEBVR_TO);
} // put_to

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::get_to(VARIANT *pRetTo)
{
    if (pRetTo == NULL)
    {
        DPF_ERR("Error in CScaleBvr:get_to, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTo, &m_varTo);
} // get_to

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::put_by(VARIANT varBy)
{
    HRESULT hr = VariantCopy(&m_varBy, &varBy);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting by for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRSCALEBVR_BY);
} // put_by

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::get_by(VARIANT *pRetBy)
{
    if (pRetBy == NULL)
    {
        DPF_ERR("Error in CScaleBvr:get_by, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetBy, &m_varBy);
} // get_by

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting type for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRSCALEBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in get_type, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::put_mode(VARIANT varMode)
{
    HRESULT hr = VariantCopy(&m_varMode, &varMode);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting mode for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRSCALEBVR_MODE);
} // put_mode

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::get_mode(VARIANT *pRetMode)
{
    if (pRetMode == NULL)
    {
        DPF_ERR("Error in get_mode, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetMode, &m_varMode);
} // get_mode

//*****************************************************************************

STDMETHODIMP
CScaleBvr::buildBehaviorFragments(IDispatch* pActorDisp)
{
    HRESULT hr;

    if( m_pdispActor != NULL && m_lCookie != 0 )
    {
    	//remove the old behavior from time.
    	hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
    	if( FAILED( hr ) )
    	{
    		DPF_ERR("failed to remove the behavior from the actor");
    		return hr;
    	}
    	m_lCookie = 0;
    	ReleaseInterface( m_pdispActor );
    }

	IDATransform2 *pTransform;
	hr = GetScaleToTransform(pActorDisp, &pTransform);
	if (SUCCEEDED(hr))
	{
		//get the dispatch off of the element to which we are attached.
		IDispatch *pdispThis = NULL;
		hr = GetHTMLElementDispatch( &pdispThis );				
		if( FAILED( hr ) )
		{
			DPF_ERR("QI for IDispatch on element failed" );
			ReleaseInterface( pTransform );
			return hr;
		}
	
		BSTR bstrPropertyName = SysAllocString( L"scale" );
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pTransform, 
									  bstrPropertyName, 
									  FlagFromTypeMode(e_AbsoluteAccum, &m_varType, &m_varMode), 
									  e_Scale,
									  pdispThis,
									  &m_lCookie);

		ReleaseInterface( pdispThis );
		ReleaseInterface( pTransform );
		::SysFreeString( bstrPropertyName );

		return hr;
	}

    float rgflFrom[3];
    float rgflTo[3];
    int iNumValues;
	bool relative;

    hr = GetScaleVectorValues(rgflFrom, rgflTo, &iNumValues, &relative);
	if(SUCCEEDED( hr ) )
	{
		if (iNumValues >= NUM_VECTOR_VALUES_2D)
		{
			IDATransform2 *pbvrTransform;
			hr = Build2DTransform(rgflFrom, rgflTo, &pbvrTransform);
			if( SUCCEEDED(hr) )
			{

				//get the dispatch off of the element to which we are attached.
				IDispatch *pdispThis = NULL;
				hr = GetHTMLElementDispatch( &pdispThis );				
				if( FAILED( hr ) )
				{
					DPF_ERR("QI for IDispatch on element failed" );
					ReleaseInterface( pbvrTransform );
					return hr;
				}
				
				BSTR bstrPropertyName = SysAllocString( L"scale" );

				hr = AttachBehaviorToActorEx( pActorDisp, 
											  pbvrTransform, 
											  bstrPropertyName, 
											  FlagFromTypeMode(relative, &m_varType, &m_varMode), 
											  e_Scale,
											  pdispThis,
											  &m_lCookie);

				ReleaseInterface( pdispThis );
				ReleaseInterface( pbvrTransform );
				::SysFreeString( bstrPropertyName );
				if( FAILED( hr ) )
				{
					DPF_ERR("Failed to attach scale behavior to actor");
				}
			}
			else //error building scale transform
			{
				DPF_ERR("error building scale transform");
				return hr;
			}
		}
	}
	else //Error extracting values from vecotors in CScaleBvr::BuildAnimationAsDABehavior
    {
        DPF_ERR("Error extracting values from vecotors in CScaleBvr::BuildAnimationAsDABehavior");
        return hr;
    }

    m_pdispActor = pActorDisp;
    m_pdispActor->AddRef();

    return S_OK;
} // buildBehaviorFragments

//*****************************************************************************

/*
HRESULT 
CScaleBvr::Apply2DScaleBehaviorToAnimationElement(IDATransform2 *pbvrScale)
{
    HRESULT hr;

    // This is a complete hack for now until the actor object is in place
    // We will simply push a unit vector in through the transform,
    // extracto out the X and Y values and apply each component
    // to width and height

    // we first need to get the original height and width
    long lHeight = DEFAULT_SCALE_HEIGHT;
    long lWidth = DEFAULT_SCALE_WIDTH;

    IHTMLElement *pElement;
    hr = GetElementToAnimate(&pElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting animated element");
        return hr;
    }
    IHTMLStyle *pStyle;
    hr = pElement->get_style(&pStyle);
    ReleaseInterface(pElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting style object from HTML element");
        return SetErrorInfo(hr);
    }
    
    hr = pStyle->get_pixelHeight(&lHeight);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting height from style object");
        ReleaseInterface(pStyle);
        return SetErrorInfo(hr);
    }
    hr = pStyle->get_pixelWidth(&lWidth);
    ReleaseInterface(pStyle);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting width from style object");
        return SetErrorInfo(hr);
    }

    // TODO What do we do when these attributes are not set????
    if (lHeight == 0)
        lHeight = DEFAULT_SCALE_HEIGHT;
    if (lWidth == 0)
        lWidth = DEFAULT_SCALE_WIDTH;


    IDAVector2 *pbvrUnitVector;

    hr = GetDAStatics()->Vector2(1.0, 1.0, &pbvrUnitVector);
    if (FAILED(hr))
    {
        DPF_ERR("error creating DA unit vector");
        return SetErrorInfo(hr);
    }

    IDAVector2 *pbvrTransformedVector;
    hr = pbvrUnitVector->Transform(pbvrScale, &pbvrTransformedVector);
    ReleaseInterface(pbvrUnitVector);
    if (FAILED(hr))
    {
        DPF_ERR("Error transforming unit vector");
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrTransformedVector != NULL);
    IDANumber *pbvrVectorComponent;
    hr = pbvrTransformedVector->get_X(&pbvrVectorComponent);
    if (FAILED(hr))
    {
        DPF_ERR("error extracting X value from vector");
        ReleaseInterface(pbvrTransformedVector);
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrVectorComponent != NULL);
    // we need to multiply this value with width to get the proper
    // value to animate the property with
    IDANumber *pbvrMultiplier;
    hr = CDAUtils::GetDANumber(GetDAStatics(),
                               static_cast<float>(lWidth),
                               &pbvrMultiplier);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting DA number for width");
        ReleaseInterface(pbvrTransformedVector);
        ReleaseInterface(pbvrVectorComponent);
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrMultiplier != NULL);

    IDANumber *pbvrResult;
    hr = GetDAStatics()->Mul(pbvrVectorComponent, pbvrMultiplier, &pbvrResult);
    ReleaseInterface(pbvrVectorComponent);
    ReleaseInterface(pbvrMultiplier);
    if (FAILED(hr))
    {
        DPF_ERR("Error multiplying DA numbers for width");
        ReleaseInterface(pbvrTransformedVector);
        return SetErrorInfo(hr);
    } 
    DASSERT(pbvrResult != NULL);
    hr = ApplyNumberBehaviorToAnimationElement(pbvrResult, L"style.width");
    ReleaseInterface(pbvrResult);
    if (FAILED(hr))
    {
        DPF_ERR("error calling ApplyNumberBehaviorToAnimationElement");
        ReleaseInterface(pbvrTransformedVector);
        return SetErrorInfo(hr);
    }    





    hr = pbvrTransformedVector->get_Y(&pbvrVectorComponent);
    ReleaseInterface(pbvrTransformedVector);
    if (FAILED(hr))
    {
        DPF_ERR("error extracting Y value from vector");
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrVectorComponent != NULL);
    hr = CDAUtils::GetDANumber(GetDAStatics(),
                               static_cast<float>(lHeight),
                               &pbvrMultiplier);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting DA number for height");
        ReleaseInterface(pbvrVectorComponent);
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrMultiplier != NULL);
    hr = GetDAStatics()->Mul(pbvrVectorComponent, pbvrMultiplier, &pbvrResult);
    ReleaseInterface(pbvrVectorComponent);
    ReleaseInterface(pbvrMultiplier);
    if (FAILED(hr))
    {
        DPF_ERR("Error multiplying DA numbers for height");
        return SetErrorInfo(hr);
    } 
    DASSERT(pbvrResult != NULL);


    hr = ApplyNumberBehaviorToAnimationElement(pbvrResult, L"style.height");
    ReleaseInterface(pbvrResult);
    if (FAILED(hr))
    {
        DPF_ERR("error calling ApplyNumberBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }    
    return S_OK;
} // Apply2DScaleBehaviorToAnimationElement
*/
//*****************************************************************************

// These are used to index array values below

#define XVAL 0
#define YVAL 1
#define ZVAL 2

//*****************************************************************************

HRESULT 
CScaleBvr::Build2DTransform(float  rgflFrom[2],
                            float  rgflTo[2],
                            IDATransform2 **ppbvrTransform)
{
    HRESULT hr;

    IDANumber *pbvrScaleX;
    IDANumber *pbvrScaleY;

    hr = BuildTIMEInterpolatedNumber(rgflFrom[XVAL],
                                     rgflTo[XVAL],
                                     &pbvrScaleX);
    if (FAILED(hr))
    {
        DPF_ERR("Error building interpolated X value for scale behavior");
        return hr;
    }

    hr = BuildTIMEInterpolatedNumber(rgflFrom[YVAL],
                                     rgflTo[YVAL],
                                     &pbvrScaleY);
    if (FAILED(hr))
    {
        DPF_ERR("Error building interpolated X value for scale behavior");
        ReleaseInterface(pbvrScaleX);
        return hr;
    }

    hr = CDAUtils::BuildScaleTransform2(GetDAStatics(),
                                        pbvrScaleX,
                                        pbvrScaleY,
                                        ppbvrTransform);
    ReleaseInterface(pbvrScaleX);
    ReleaseInterface(pbvrScaleY);
    if (FAILED(hr))
    {
        DPF_ERR("Error building scale transform2");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // Build2DTransform

//*****************************************************************************
/*
HRESULT 
CScaleBvr::Build3DTransform(float  rgflFrom[3],
                            float  rgflTo[3],
                            IDATransform3 **ppbvrTransform)
{
    HRESULT hr;

    IDANumber *pbvrScaleX;
    IDANumber *pbvrScaleY;
    IDANumber *pbvrScaleZ;

    // TODO: get these values from HTML
    float flOriginalX = 1.0f;
    float flOriginalY = 1.0f;
    float flOriginalZ = 1.0f;


    hr = BuildTIMEInterpolatedNumber(rgflFrom[XVAL],
                                     rgflTo[XVAL],
                                     flOriginalX,
                                     &pbvrScaleX);
    if (FAILED(hr))
    {
        DPF_ERR("Error building interpolated X value for scale behavior");
        return hr;
    }

    hr = BuildTIMEInterpolatedNumber(rgflFrom[YVAL],
                                     rgflTo[YVAL],
                                     flOriginalY,
                                     &pbvrScaleY);
    if (FAILED(hr))
    {
        DPF_ERR("Error building interpolated Y value for scale behavior");
        ReleaseInterface(pbvrScaleX);
        return hr;
    }
    hr = BuildTIMEInterpolatedNumber(rgflFrom[ZVAL],
                                     rgflTo[ZVAL],
                                     flOriginalZ,
                                     &pbvrScaleZ);
    if (FAILED(hr))
    {
        DPF_ERR("Error building interpolated Z value for scale behavior");
        ReleaseInterface(pbvrScaleX);
        ReleaseInterface(pbvrScaleY);
        return hr;
    }
    hr = CDAUtils::BuildScaleTransform3(GetDAStatics(),
                                        pbvrScaleX,
                                        pbvrScaleY,
                                        pbvrScaleZ,
                                        ppbvrTransform);
    ReleaseInterface(pbvrScaleX);
    ReleaseInterface(pbvrScaleY);
    ReleaseInterface(pbvrScaleZ);
    if (FAILED(hr))
    {
        DPF_ERR("Error building scale transform2");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // Build3DTransform
*/
//*****************************************************************************

HRESULT 
CScaleBvr::GetScaleVectorValues(float  rgflFrom[3],
                                float  rgflTo[3],
                                int    *piNumValues,
								bool   *prelative)
{

    int cReturnedFromValues;
	int cReturnedToValues;
    HRESULT hr;

    hr = CUtils::GetVectorFromVariant(&m_varFrom, 
                                      &cReturnedFromValues, 
                                      &(rgflFrom[XVAL]), 
                                      &(rgflFrom[YVAL]), 
                                      &(rgflFrom[ZVAL]));
    if (FAILED(hr) || cReturnedFromValues < MIN_NUM_SCALE_VALUES)
    {
        // there was no valid from attribute specified.
        // try the by attribute
		hr = CUtils::GetVectorFromVariant(&m_varBy, 
										  &cReturnedToValues, 
										  &(rgflTo[XVAL]), 
										  &(rgflTo[YVAL]), 
										  &(rgflTo[ZVAL]));
		if (FAILED(hr))
		{
			DPF_ERR("Error converting to and by variant to float in CScaleBvr::BuildAnimationAsDABehavior");
			return SetErrorInfo(hr);
		}

		// Got a by.  Must be relative and from must be 0
		*prelative = true;

		rgflFrom[0] = 1;
		rgflFrom[1] = 1;
		rgflFrom[2] = 1;

		rgflTo[XVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflTo[YVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflTo[ZVAL] /= SCALE_NORMALIZATION_VALUE;
    }
	else
	{
		// there was a valid from attribute, try to or by
		hr = CUtils::GetVectorFromVariant(&m_varTo, 
										  &cReturnedToValues, 
										  &(rgflTo[XVAL]), 
										  &(rgflTo[YVAL]), 
										  &(rgflTo[ZVAL]));
		bool fHasBy = false;
		if (FAILED(hr))
		{
			// there was no valid to attribute specified, try for a by attribute
			hr = CUtils::GetVectorFromVariant(&m_varBy, 
											  &cReturnedToValues, 
											  &(rgflTo[XVAL]), 
											  &(rgflTo[YVAL]), 
											  &(rgflTo[ZVAL]));
			if (FAILED(hr))
			{
				DPF_ERR("Error converting to and by variant to float in CScaleBvr::BuildAnimationAsDABehavior");
				return SetErrorInfo(hr);
			}
        
			fHasBy = true;
		}

		if (cReturnedToValues < MIN_NUM_SCALE_VALUES)
		{
			DPF_ERR("Error in to/by vector for scale, not enough params");
			return SetErrorInfo(E_INVALIDARG);
		}

		rgflFrom[XVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflFrom[YVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflFrom[ZVAL] /= SCALE_NORMALIZATION_VALUE;

		rgflTo[XVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflTo[YVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflTo[ZVAL] /= SCALE_NORMALIZATION_VALUE;

		if (true == fHasBy)
		{
			// this scale has a "by", TO = FROM + TO
			rgflTo[XVAL] += rgflFrom[XVAL];
			rgflTo[YVAL] += rgflFrom[YVAL];
			if (cReturnedToValues == NUM_VECTOR_VALUES_3D)
				rgflTo[ZVAL] += rgflFrom[ZVAL];
		}

		// This is an absolute scale
		*prelative = false;
	}

    *piNumValues = cReturnedToValues;
    return S_OK;
} // GetScaleVectorValues

HRESULT 
CScaleBvr::GetScaleToTransform(IDispatch *pActorDisp, IDATransform2 **ppResult)
{

    HRESULT hr;
    int cReturnedValues;
    float x, y, z;

    hr = CUtils::GetVectorFromVariant(&m_varFrom, 
                                      &cReturnedValues, 
                                      &x, 
                                      &y,
                                      &z);

	if (SUCCEEDED(hr))
		return E_FAIL;

    hr = CUtils::GetVectorFromVariant(&m_varTo, 
                                      &cReturnedValues, 
                                      &x, 
                                      &y, 
                                      &z);

    if (FAILED(hr) || cReturnedValues != 2)
    {
		return E_FAIL;
	}

	IDABehavior *pFromBvr;
	hr = GetBvrFromActor(pActorDisp, L"scale", e_From, e_Scale, &pFromBvr);
	if (FAILED(hr))
		return hr;

	IDATransform2 *pFromTrans;
	hr = pFromBvr->QueryInterface(IID_TO_PPV(IDATransform2, &pFromTrans));
	ReleaseInterface(pFromBvr);
	if (FAILED(hr))
		return hr;

	// Transform the point 1,1 and extract x and y
	IDAPoint2 *pOrigin;
	hr = GetDAStatics()->Point2(1, 1, &pOrigin);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromTrans);
		return hr;
	}

	IDAPoint2 *pFrom;
	hr = pOrigin->Transform(pFromTrans, &pFrom);
	ReleaseInterface(pOrigin);
	ReleaseInterface(pFromTrans);
	if (FAILED(hr))
		return hr;

	IDANumber *pFromX;
	hr = pFrom->get_X(&pFromX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFrom);
		return hr;
	}

	IDANumber *pFromY;
	hr = pFrom->get_Y(&pFromY);
	ReleaseInterface(pFrom);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		return hr;
	}

	IDANumber *pToX;
	hr = GetDAStatics()->DANumber(x/SCALE_NORMALIZATION_VALUE, &pToX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		ReleaseInterface(pFromY);
		return hr;
	}

	IDANumber *pToY;
	hr = GetDAStatics()->DANumber(y/SCALE_NORMALIZATION_VALUE, &pToY);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		ReleaseInterface(pFromY);
		ReleaseInterface(pToX);
		return hr;
	}

	IDANumber *pX;
	hr = BuildTIMEInterpolatedNumber(pFromX, pToX, &pX);
	ReleaseInterface(pFromX);
	ReleaseInterface(pToX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromY);
		ReleaseInterface(pToY);
		return hr;
	}

	IDANumber *pY;
	hr = BuildTIMEInterpolatedNumber(pFromY, pToY, &pY);
	ReleaseInterface(pFromY);
	ReleaseInterface(pToY);
	if (FAILED(hr))
	{
		ReleaseInterface(pX);
		return hr;
	}

	hr = GetDAStatics()->Scale2Anim(pX, pY, ppResult);
	ReleaseInterface(pX);
	ReleaseInterface(pY);
	if (FAILED(hr))
		return hr;

	return S_OK;
} 

//*****************************************************************************

HRESULT 
CScaleBvr::BuildAnimationAsDABehavior()
{
	return S_OK;
} // BuildAnimationAsDABehavior


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\control\engine.cpp ===
#include "Engine.h"
#include <evcode.h>
#include <hlink.h>
#include <oleidl.h>
#include <oleauto.h>
#include <mshtml.h>
#include <uuids.h>
#include <control.h>
#include <lmrtrend.h>

#define MIN(a, b)	(((a) <= (b)) ? (a) : (b))
#define MAX(a, b)	(((a) > (b)) ? (a) : (b))

const IID IID_ILMRTRenderer = {0x3c89d120,0x6f65,0x11d1,{0xa5,0x20,0x0,0x0,0x0,0x0,0x0,0x0}};

static inline void WideToAnsi(LPOLESTR wide, char *ansi) {
    if (wide) {
        WideCharToMultiByte(CP_ACP, 0,
                            wide, -1,
                            ansi,
                            INTERNET_MAX_URL_LENGTH - 1,
                            NULL, NULL);
    } else {
        ansi[0] = '\0';
    }
}

static inline void AnsiToWide( char *ansi, LPWSTR wide )
{
	if( ansi != NULL )
	{
		MultiByteToWideChar( CP_ACP, 0,
							 ansi,
							 -1,
							 wide,
							 INTERNET_MAX_URL_LENGTH -1 );
	}
	else
	{
		wide[0] = L'\0';
	}
}

CLMEngineWrapper::CLMEngineWrapper(): m_pWrapped(NULL), m_bValid(false)
{
}

CLMEngineWrapper::~CLMEngineWrapper()
{
	m_pWrapped = NULL;
}


STDMETHODIMP CLMEngineWrapper::GetWrapped( IUnknown **ppWrapped )
{
	if( ppWrapped == NULL )
		return E_POINTER;

	if( !m_bValid )
	{
		(*ppWrapped) = NULL;
		return E_FAIL;
	}
	
	if( m_pWrapped == NULL )
		return E_FAIL;
	
	(*ppWrapped) = m_pWrapped;
	m_pWrapped->AddRef();
	
	return S_OK;
}

STDMETHODIMP CLMEngineWrapper::SetWrapped( IUnknown *pWrapped )
{
	if( m_pWrapped != NULL )
		return E_FAIL;
	if( pWrapped == NULL )
		return E_POINTER;
	//we do not add ref here because this is a weak ref
	m_pWrapped = pWrapped;
	m_bValid = true;
	
	return S_OK;
}

STDMETHODIMP CLMEngineWrapper::Invalidate()
{
	m_bValid = false;
	return S_OK;
}

/**
* Constructor
*/
CLMEngine::CLMEngine()
{

	CComObject<CLMEngineWrapper> *pWrapper;
	CComObject<CLMEngineWrapper>::CreateInstance( &pWrapper );
	m_pWrapper = NULL;
	pWrapper->QueryInterface( IID_ILMEngineWrapper, (void**)&m_pWrapper );
	m_pWrapper->SetWrapped( GetUnknown() );

	longStackSize = INITIAL_SIZE;
	longTop = longStack = new LONG[longStackSize];

	doubleStackSize = INITIAL_SIZE;
	doubleTop = doubleStack = new double[doubleStackSize];

	stringStackSize = INITIAL_SIZE;
	stringTop = stringStack = new BSTR[stringStackSize];

	comStackSize = INITIAL_SIZE;
	comTop = comStack = new IUnknown*[comStackSize];

	comArrayStackSize = INITIAL_SIZE;
	comArrayTop = comArrayStack = new IUnknown**[comArrayStackSize];
	comArrayLenTop = comArrayLenStack = new long[comArrayStackSize];

	comStoreSize = INITIAL_SIZE;
	comStore = new IUnknown*[comStoreSize];
	// Make sure it is initialized, so that we can release it later on
	for (int i=0; i<comStoreSize; i++)
		comStore[i] = 0;

	for (int j=0; j<MAX_VAR_ARGS; j++)
		varArgs[j].vt = VT_EMPTY;
	varArgReturn.vt = VT_EMPTY;
	nextVarArg = 0;

	doubleArray = 0;

	m_pReader = NULL;

	HRESULT hr = CoCreateInstance(
		CLSID_DAStatics,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IDAStatics,
		(void **) &staticStatics);

	m_pImage = NULL;
	m_pSound = NULL;

	m_exportTable = new CLMExportTable(staticStatics);

	codeStream = 0;
	notifier = 0;
	m_pClientSite = 0;
	m_PrevRead = 0;
	m_AsyncDelay = DEFAULT_ASYNC_DELAY;
	m_AsyncBlkSize = DEFAULT_ASYNC_BLKSIZE;
	m_Timer = NULL;
	m_workerHwnd = NULL;
	m_hDoneEvent = NULL;
	m_bAbort = FALSE;
	m_bMoreToParse = FALSE;

	m_pStartEvent = NULL;
	m_pStopEvent = NULL;
        m_bstrMediaCacheDir = 0;

	m_pMediaPosition = NULL;

	m_pMediaEventSink = NULL;

	m_pParentEngine = NULL;

	m_bEnableAutoAntialias = false;

	m_bAutoCodecDownloadEnabled = FALSE;

	createMsgWindow();

	InitializeCriticalSection(&m_CriticalSection);
}

/**
* Destructor
*/
CLMEngine::~CLMEngine()
{
	if( m_pWrapper != NULL )
	{
		m_pWrapper->Invalidate();
		m_pWrapper->Release();
	}

	if (codeStream)
		delete codeStream;

	if (m_pImage)
		m_pImage->Release();

	if (m_pSound)
		m_pSound->Release();

	if (staticStatics)
		staticStatics->Release();

	if (notifier) {
		// Clear out the engine in case DA still has a ref to the notifier
		notifier->ClearEngine();
		notifier->Release();
	}

	if (longStack)
		delete[] longStack;

	if (doubleStack)
		delete[] doubleStack;

	if (doubleArray)
		delete[] doubleArray;

	if (stringStack)
		delete[] stringStack;

	if (comStack)
		delete[] comStack;

	if (comArrayStack)
		delete[] comArrayStack;

	if (comArrayLenStack)
		delete[] comArrayLenStack;

	if (comStore)
		delete[] comStore;

	if (m_Timer)
		timeKillEvent(m_Timer);

	if (m_exportTable)
		delete m_exportTable;

	if (m_workerHwnd) {
		DestroyWindow (m_workerHwnd);
		UnregisterClass(WORKERHWND_CLASS, hInst);
	}

	if (m_hDoneEvent)
		CloseHandle(m_hDoneEvent);

	if( m_pStartEvent != NULL )
		m_pStartEvent->Release();

	if( m_pStopEvent != NULL )
		m_pStopEvent->Release();

	if( m_pMediaPosition != NULL )
		m_pMediaPosition->Release();

	if( m_pMediaEventSink != NULL )
		m_pMediaEventSink->Release();

	DeleteCriticalSection(&m_CriticalSection);

        SysFreeString(m_bstrMediaCacheDir);
}

/**
* Tell the engine what reader constructed it.
* The engine will call back to the reader to get info now and again
*/
STDMETHODIMP CLMEngine::put_Reader(ILMReader *reader)
{
	CComQIPtr<ILMReader2, &IID_ILMReader2> pLMReader( reader );
	if( pLMReader == NULL )
	{
		m_pReader = NULL;
		return E_NOINTERFACE;
	}

	m_pReader = pLMReader;
	return S_OK;
}

/**
* Tell the engine what the client site is
*/
STDMETHODIMP CLMEngine::put_ClientSite(IOleClientSite *clientSite)
{
	// Must set client site so that relative URL's can work
	// TODO: Check that clientSite is non-null and this call succeeds
    if (!clientSite) {
        return E_POINTER;
    }

	m_pClientSite = clientSite;
	staticStatics->put_ClientSite(clientSite);

	return S_OK;
}

/**
* Execute the instructions in the passed stream synchronously
*/
STDMETHODIMP CLMEngine::runFromStream(LPSTREAM pStream)
{
#if 0
	char cbuf[100];
	sprintf(cbuf, "CLMEngine::run(0x%X)", pStream);
	MessageBox(NULL, cbuf, "CLMEngine", MB_OK);
#endif
	codeStream = new SyncStream(pStream);

	HRESULT hr;

	if (!SUCCEEDED(hr = validateHeader()))
		return hr;

	hr = execute();

	releaseAll();

	return hr;
}

/**
* Set this engine up to read instructions from the passed byte array.
* Used to set up UntilNotifiers where the entire set of instructions is
* known in a single block
*/
STDMETHODIMP CLMEngine::initFromBytes(BYTE *array, ULONG size)
{
	codeStream = new ByteArrayStream(array, size);

	return S_OK;
}

/**
* Get the base URL of document in the client site
*/
STDMETHODIMP_(char*) CLMEngine::GetURLOfClientSite(void)
{
	char	*_clientSiteURL = NULL;
	
	// Fail gracefully if we don't have a client site, since not
	// all uses will.
	if (m_pClientSite) {
		
		// However, if we do have a client site, we should be able
		// to get these other elements.  If we don't, assert.
		// (TODO: what's going to happen in IE3?)
		CComPtr<IOleContainer>			pRoot;
		CComPtr<IHTMLDocument2>			pDoc2;
		if (FAILED(m_pClientSite->GetContainer(&pRoot)) ||
			FAILED(pRoot->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc2)))
			return NULL;

		CComPtr<IHTMLElementCollection>	pElementCollection;
		if (FAILED(pDoc2->get_all(&pElementCollection)))
			return NULL;

		CComVariant baseName;
		baseName.vt = VT_BSTR;
		baseName.bstrVal = SysAllocString(L"BASE");

		CComPtr<IDispatch>				pDispatch;
		if (FAILED(pElementCollection->tags(baseName, &pDispatch)))
			return NULL;

                pElementCollection.Release();

		if (FAILED(pDispatch->QueryInterface(IID_IHTMLElementCollection, (void **)&pElementCollection)))
			return NULL;

                pDispatch.Release();

		CComVariant	index;
		index.vt = VT_I2;
		index.iVal = 0;
		BSTR tempBstr = NULL;
		if (FAILED(pElementCollection->item(index, index, &pDispatch)))
		{
			if (FAILED(pDoc2->get_URL(&tempBstr)))
				return NULL;
		}
		else
		{
			// There seems to be a bug wherein item() doesn't fail but sets pDispatch to NULL
			if (pDispatch.p == NULL)
			{
				if (FAILED(pDoc2->get_URL(&tempBstr)))
					return NULL;
			}
			else
			{
				CComPtr<IHTMLBaseElement>		pBaseElement;
				if (FAILED(pDispatch->QueryInterface(IID_IHTMLBaseElement, (void **)&pBaseElement)))
					return NULL;
				
				if (FAILED(pBaseElement->get_href(&tempBstr)))
					return NULL;
			}
		}

		long len = lstrlenW(tempBstr);
		_clientSiteURL = new char[(len + 1) * 2 * sizeof(char)] ;
		
		if (_clientSiteURL) {
			// Need to pass in len + 1 to get the terminator
			AtlW2AHelper(_clientSiteURL,tempBstr,len + 1);
		}
		
		SysFreeString(tempBstr);
	}

	return _clientSiteURL;
}

/**
* Initialize the engine to read asynchronously
*/
STDMETHODIMP CLMEngine::initAsync()
{
	CComPtr<IDAImage>	splashImage;
	CComPtr<IDASound>	splashSound;
	
	// Create a splash screen in a modifiable image behavior
	staticStatics->get_EmptyImage(&splashImage);
	staticStatics->ModifiableBehavior(splashImage, (IDABehavior **)&m_pImage);
	
	// Create a splash sound in a modifiable sound behavior
	staticStatics->get_Silence(&splashSound);
	staticStatics->ModifiableBehavior(splashSound, (IDABehavior **)&m_pSound);
	
	m_bHeaderRead = FALSE;
	m_bPending = TRUE;

	HRESULT hr = InitTimer();
	if (!SUCCEEDED(hr))
		return hr;

	m_PrevRead = 0;

	m_hDoneEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);

	return S_OK;
}


HRESULT FindInterfaceOnGraph(IFilterGraph *pGraph, REFIID riid, void **ppInterface)
{
    *ppInterface= NULL;

    IEnumFilters *pEnum;
    HRESULT hr = pGraph->EnumFilters(&pEnum);
    if(SUCCEEDED(hr))
    {
        hr = E_NOINTERFACE;
        IBaseFilter *pFilter;
    
        // find the first filter in the graph that supports riid interface
        while(!*ppInterface && pEnum->Next(1, &pFilter, NULL) == S_OK)
        {
            hr = pFilter->QueryInterface(riid, ppInterface);
            pFilter->Release();
        }

        pEnum->Release();
    }
    return hr;
}

IPin *GetPin(IBaseFilter *pf)
{
    IPin *pip = 0;
    
    IEnumPins *pep;
    HRESULT hr = pf->EnumPins(&pep);
    if(SUCCEEDED(hr))
    {
        pep->Next(1, &pip, 0);
        pep->Release();
    }

    return pip;
}

HRESULT UseDsound(IGraphBuilder *pGB)
{
    HRESULT hr = S_OK;
    
    IBasicAudio *pba;
    if(FindInterfaceOnGraph(pGB, IID_IBasicAudio, (void **)&pba) == S_OK)
    {
        IBaseFilter *pfwo;
                
        hr = pba->QueryInterface(IID_IBaseFilter, (void **)&pfwo);
        if(SUCCEEDED(hr))
        {
            CLSID clsfil;
            hr= pfwo->GetClassID(&clsfil);
            if(clsfil != CLSID_DSoundRender)
            {
                IPin *pip = GetPin(pfwo);
                if(pip)
                {
                    IPin *pop;
                    if(pip->ConnectedTo(&pop) == S_OK)
                    {
                        if(pGB->RemoveFilter(pfwo) == S_OK)
                        {
                            IBaseFilter *pfds;
                            hr = CoCreateInstance(CLSID_DSoundRender, 0, CLSCTX_INPROC, IID_IBaseFilter, (void **)&pfds);
                            if(SUCCEEDED(hr))
                            {
                                hr = pGB->AddFilter(pfds, L"ds");
                                if(SUCCEEDED(hr))
                                {
                                    IPin *pipds = GetPin(pfds);
                                    if(pipds) {
                                        hr = pGB->Connect(pop, pipds);
                                        pipds->Release();
                                    }
                                    else {
                                        hr = E_UNEXPECTED;
                                    }
                                }
                                pfds->Release();
                            }
                        }
                        pop->Release();
                    }

                    pip->Release();
                }
            }
                    
            pfwo->Release();
        }

        pba->Release();
    }

    return hr;
}


/**
* Read from a URL.  Checks Async flag to see whether the file should
* be read synchronously or asynchronously
*/
STDMETHODIMP CLMEngine::runFromURL(BSTR url)
{
	VARIANT_BOOL	bAsync;
	HRESULT			hr = S_OK;
	IStream			*pStream;

    if( m_pReader == NULL )
        return E_FAIL;

	// Get the proper URL
	char *clientURL = GetURLOfClientSite();
	URLCombineAndCanonicalizeOLESTR canonURL(clientURL, url);
	free(clientURL);

	// Are we reading async?
	m_pReader->get_Async(&bAsync);

	// If url points to a .avi or .asf file, then stream it in
	wchar_t  *suffix = wcsrchr(url, '.');

	if (suffix != NULL && (!wcsicmp(suffix, L".asf") || !wcsicmp(suffix, L".avi")))
	{
            _ASSERTE(m_pmc == 0);
            
            // Need to stream the file
            // Create a filter graph instantiated from the URL
            if (!SUCCEEDED(hr = CoCreateInstance(CLSID_FilterGraph,
                                                 NULL,
                                                 CLSCTX_INPROC,
                                                 IID_IMediaControl,
                                                 (void **)&m_pmc)))
            {
                return hr;
            }

            CComPtr<IGraphBuilder> pGB;
            if (!SUCCEEDED(hr = m_pmc->QueryInterface(IID_IGraphBuilder, (void **)&pGB)))
                return hr;

            hr = UseDsound(pGB);
            if(FAILED(hr)) {
                return hr;
            }

			if( m_bAutoCodecDownloadEnabled == TRUE )
			{
				CComQIPtr<IObjectWithSite, &IID_IObjectWithSite> siteTarget(m_pmc);
				if( siteTarget != NULL )
					siteTarget->SetSite(m_pReader);
			}

#ifdef DEBUG
            m_fDbgInRenderFile = true;
#endif
            

			
            // RenderFile can dispatch messages and call back into us
			if (!SUCCEEDED(hr = pGB->RenderFile(canonURL.GetURLWide(), NULL))) {
                // !!! map quartz errors to standard errors
                return hr;
            }

#ifdef DEBUG
            m_fDbgInRenderFile = false;
#endif

            if(m_pmc == 0) {
                return E_ABORT;
            }


            // Locate the LMRT Renderer filter. 
            CComPtr<ILMRTRenderer> pLMFilter;
            if (!SUCCEEDED(hr = FindInterfaceOnGraph(pGB, IID_ILMRTRenderer, (void **)&pLMFilter))) {
                // probably the file doesn't have a .XT stream
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            // Initialize for async reads from memory blocks
            if (!SUCCEEDED(hr = initAsync()))
                return hr;

            // Set the engine on it. This creates a circular reference
            // count as long as we hold the filter (through m_pmc). So
            // we have to make sure the filter (and the graph) are
            // released before our destructor.
            
            pLMFilter->SetLMEngine(this);

            if (!SUCCEEDED(hr = m_pmc->Run())) {
                return hr;
            }

            //long evCode;
            //hr = pME->WaitForCompletion(INFINITE, &evCode);

	} else if (bAsync) {
		// Initialize for async reads
		hr = initAsync();
		if (!SUCCEEDED(hr))
			return hr;

		// Get BindStatusCallback interface
		m_pIbsc = 0;
		hr = GetUnknown()->QueryInterface(IID_IBindStatusCallback, (void**)&m_pIbsc);
		if (!SUCCEEDED(hr))
			return hr;

		// Open the URL stream to read asynchronously
		// OnDataAvailable will be called when data is available
		hr = URLOpenStream(GetUnknown(), canonURL.GetURL(), 0, m_pIbsc);

	} else {
		// Open the URL stream to read synchronously
		hr = URLOpenBlockingStream(GetUnknown(), canonURL.GetURL(), &pStream, 0, 0);
		if (!SUCCEEDED(hr))
			return hr;

		// Call runFromStream to execute the instructions
		hr = runFromStream(pStream);

		// Cleanup
		pStream->Release();
		pStream = NULL;
	}

	return hr;
}

/**
* Returns the Image set in this Engine
*/
STDMETHODIMP CLMEngine::get_Image(IDAImage **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

	if (m_pImage)
		m_pImage->AddRef();

	*pVal = (IDAImage *)m_pImage;

	return S_OK;
}

/**
* Returns the Sound set in this Engine
*/
STDMETHODIMP CLMEngine::get_Sound(IDASound **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

	if (m_pSound)
		m_pSound->AddRef();

	*pVal = (IDASound *)m_pSound;

	return S_OK;
}

/**
* Return the named Behavior.  If the named Behavior is not available yet,
* then we return a switchable behavior with initial value of pDefaultBvr
*/
STDMETHODIMP CLMEngine::GetBehavior(BSTR tag, IDABehavior *pDefaultBvr, IDABehavior **ppVal)
{
	if (!ppVal)
		return E_POINTER;

	return m_exportTable->GetBehavior(tag, pDefaultBvr, ppVal);
}

/**
* Initialize this engine as an UntilNotifier, passing in a byte array containing the
* instructions and a count of bytes.  Returns an UntilNotifier for use in DA
*/
STDMETHODIMP CLMEngine::initNotify(BYTE *bytes, ULONG count, IDAUntilNotifier **pNotifier)
{
	// Initialize this engine from the given byte array
	HRESULT hr = initFromBytes(bytes, count);
	if (!SUCCEEDED(hr))
		return hr;

	// Create a new notifier object
	notifier = new CLMNotifier(this);

	// Test for null
	if (notifier == 0)
		return E_UNEXPECTED;

	// Increment reference count for return
	notifier->AddRef();

	// Put it in the return value
	*pNotifier = notifier;

	return S_OK;
}

/**
* Read and returns a long from the current codeStream.  The long is compressed 1-4 bytes
*/
STDMETHODIMP CLMEngine::readLong(LPLONG pLong)
{
	if (!pLong)
		return E_POINTER;

	BYTE	byte;

	HRESULT status = codeStream->readByte(&byte);
	if (!SUCCEEDED(status))
		return status;

	LONG result = (long)byte;

	switch (result & 0xc0) {
	case 0x40:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3F) << 8) + byte;
		break;

	case 0x80:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3f) << 16) + ((LONG)byte << 8);
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += byte;
		break;

	case 0xc0:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3f) << 24) + ((LONG)byte << 16);
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += (LONG)byte << 8;
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += byte;
		break;
	}

#if 0
	char cbuf[100];
	sprintf(cbuf, "readLong::%ld", result);
	MessageBox(NULL, cbuf, "CLMEngine", MB_OK);
#endif

	*pLong = result;
	return status;
}

/**
* Read and return a signed long from the current code stream.  The long is
* compressed 1-4 bytes
*/
LONG CLMEngine::readSignedLong(LPLONG pLong)
{
	if (!pLong)
		return E_POINTER;

	BYTE	byte;
	HRESULT status = codeStream->readByte(&byte);
	LONG result = (LONG)byte;

	switch (result & 0xc0) {
	case 0x00:
		result -= 0x20;
		break;

	case 0x40:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3f) << 8) + byte;
		result -= 0x2000;
		break;

	case 0x80:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3f) << 16) + ((LONG)byte << 8);
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += (LONG)byte;
		result -= 0x200000;
		break;

	case 0xc0:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3f) << 24) + ((LONG)byte << 16);
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += (LONG)byte << 8;
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += byte;
		result -= 0x20000000;
		break;
	}

#if 0
	char cbuf[100];
	sprintf(cbuf, "readSignedLong::%ld", result);
	MessageBox(NULL, cbuf, "CLMEngine", MB_OK);
#endif

	*pLong = result;
	return status;
}

/**
* Read a float from the code stream
*/
STDMETHODIMP CLMEngine::readFloat(PFLOAT pFloat)
{
	if (!pFloat)
		return E_POINTER;

	// Float follows in 4 bytes, low byte first
	// CAUTION: Assumes byte order and format of float
	// in binary stream matches the C format
	return codeStream->readBytes((LPBYTE)pFloat, 4L, NULL);
}

/**
* Read a double from the code stream
*/
STDMETHODIMP CLMEngine::readDouble(double *pDouble)
{
	if (!pDouble)
		return E_POINTER;

	// Double follows in 8 bytes, low byte first
	// CAUTION: Assumes byte order and format of double
	// in binary stream matches the C format
	return codeStream->readBytes((LPBYTE)pDouble, 8L, NULL);
}

/**
*  Set the appTriggered event that will be triggered when the
*  filter graph is started.  The argument is expected to be an
*  AppTriggeredEvent in the media graph of the DAControl to which
*  this engine or its parent is attached.
*/

STDMETHODIMP CLMEngine::SetStartEvent( IDAEvent *pNewStartEvent, BOOL bOverwrite )
{
	if( m_pStartEvent != NULL )
	{
		//if we are told to overwrite the event.
		if( bOverwrite == TRUE )
			m_pStartEvent->Release();
		else //do not reset the start event.
			return S_OK;
	}
	m_pStartEvent = pNewStartEvent;
	m_pStartEvent->AddRef();

	return S_OK;
}

/**
*  Set the appTriggered event that will be triggered when the
*  filter graph is stopped.  The argument is expected to be an
*  AppTriggeredEvent in the media graph of the DAControl to which
*  this engine or its parent is attached
*/
STDMETHODIMP CLMEngine::SetStopEvent( IDAEvent *pNewStopEvent, BOOL bOverwrite )
{
	if( m_pStopEvent != NULL )
	{
		//if we are told to overwrite the event
		if( bOverwrite == TRUE )
			m_pStopEvent->Release();
		else //do not reset the stop event
			return S_OK;
	}
	m_pStopEvent = pNewStopEvent;
	m_pStopEvent->AddRef();
	
	return S_OK;
}

/**
*  Sets the parent of this engine.  This should only be called
*  on an engine that runs a notifier.
*/
STDMETHODIMP CLMEngine::setParentEngine( ILMEngine2 *parentEngine)
{
	m_pParentEngine = parentEngine;
	return S_OK;
}

/**
*  Clear the pointer to the parent engine.
*/
STDMETHODIMP CLMEngine::clearParentEngine()
{
	m_pParentEngine = NULL;
	return S_OK;
}

/**
*  If this engine or it's parent is running in a filter graph, 
*  then the time in that filter graph is returned. Otherwise,
*  -1 is returned.  All values are returned through the pGraphTime 
*  argument.
*/
STDMETHODIMP CLMEngine::getCurrentGraphTime( double *pGraphTime )
{

	if( pGraphTime == NULL )
		return E_POINTER;
	//get the IMediaPosition on the filter graph
	IMediaPosition *pMediaPosition = NULL;
	HRESULT hr =  getIMediaPosition( &pMediaPosition );
	//if we got the IMediaPosition
	if( SUCCEEDED( hr ) )
	{
		REFTIME currentTime;
		//get the current time from the fiter graph
		pMediaPosition->get_CurrentPosition( &currentTime );
		//set the return value
		(*pGraphTime) = currentTime;
		pMediaPosition->Release();
	} else { //we failed to get the IMediaPosition for some reason
		(*pGraphTime) = -1.0;
		return hr;
	}

	return S_OK;
}

STDMETHODIMP CLMEngine::getIMediaPosition( IMediaPosition **ppMediaPosition )
{
	if( ppMediaPosition == NULL )
		return E_POINTER;

	if( m_pMediaPosition != NULL )
	{
		(*ppMediaPosition) = m_pMediaPosition;
		(*ppMediaPosition)->AddRef();
		return S_OK;
	}

	//get the viewer control from the reader.
	HRESULT hr;
	IDAViewerControl *viewerControl = NULL;

	if( m_pReader == NULL )
		return E_POINTER;

	hr = m_pReader->get_ViewerControl( &viewerControl );
	//if we got the viewer control
	if( SUCCEEDED( hr ) )
	{
		//if the viewer control is not null
		if( viewerControl != NULL )
		{
			//see if the DAControl supports IBaseFilter ( we are streaming )
			IBaseFilter* pBaseFilter = NULL;
			hr = viewerControl->QueryInterface( IID_IBaseFilter, (void**)&pBaseFilter );
			viewerControl->Release();
			//if the DAControl supports IBaseFilter
			if( SUCCEEDED( hr ) )
			{
				FILTER_INFO filterInfo;
				hr = pBaseFilter->QueryFilterInfo( &filterInfo );
				//if we got the filterInfo
				if( SUCCEEDED( hr ) )
				{
					//get the MediaControl Interface
					IMediaControl* pMediaControl = NULL;
					hr = filterInfo.pGraph->QueryInterface( IID_IMediaControl, (void **)&pMediaControl ); 
					filterInfo.pGraph->Release();
					//if we got the mediaControl interface
					if( SUCCEEDED( hr ) )
					{
						//Query the control for IMediaPosition
						IMediaPosition *pMediaPosition;
						hr = pMediaControl->QueryInterface( IID_IMediaPosition, (void **)&pMediaPosition );
						//if we got IMediaPosition from the control
						if( SUCCEEDED( hr ) )
						{
							//cache it for later use.
							m_pMediaPosition = pMediaPosition;
							//This creates a circular reference, but we know the filter graph
							// will not go away until we get a ReleaseFilterGraph call
							//m_pMediaPosition->AddRef();
							//set the return value
							(*ppMediaPosition) = m_pMediaPosition;

							//free up interfaces we don't need anymore.
							pBaseFilter->Release();
							pMediaControl->Release();

							return S_OK;
						} else { //we failed to get IMediaPosition from the control
							//free up interfaces we've queried
							pMediaControl->Release();
							pBaseFilter->Release();
						}
					} else { //we failed to get IMediaControl from the filter graph
						//free up interfaces we've queried
						pBaseFilter->Release();
					}
				} else {//we failed to get the filter info from IBaseFilter
					//free up interfaces we've queried
					pBaseFilter->Release();
				}
			}//we failed to get IBaseFilter from the control
		} else {//the ViewerControl was null, perhaps we are running standalone
			//if the pointer to the filter graph is set
			if( m_pmc != NULL )
			{
				//query the control for IMediaPosition
				IMediaPosition *pMediaPosition;
				hr = m_pmc->QueryInterface( IID_IMediaPosition, (void **)&pMediaPosition );
				//if the control supports IMediaPosition
				if( SUCCEEDED( hr ) )
				{
					//cache it for later use
					m_pMediaPosition = pMediaPosition;
					//This creates a circular reference, but we know the filter graph
					// will not go away until we get a ReleaseFilterGraph call
					//m_pMediaPosition->AddRef();
					//set the return value
					(*ppMediaPosition) = m_pMediaPosition;
					//return success
					return S_OK;
				}//we failed to get IMediaPosition from the control
			} else {//the pointer to the filter graph was null
				hr = E_FAIL;
			}
		}
	}
	//else an error occurred
	//set the media position to null
	(*ppMediaPosition) = NULL;
	//return the error code
	return hr;
}

STDMETHODIMP CLMEngine::getIMediaEventSink( IMediaEventSink** ppMediaEventSink )
{
	if( ppMediaEventSink == NULL )
		return E_POINTER;

	if( m_pMediaEventSink != NULL )
	{
		m_pMediaEventSink->AddRef();
		(*ppMediaEventSink) = m_pMediaEventSink;
		return S_OK;
	}

	HRESULT hr;
	if( m_pReader != NULL )
	{
		//if we are not inside the Media player this call should fail in which case we will return
		// failure
		IDAViewerControl *pViewerControl = NULL;
		hr = m_pReader->get_ViewerControl( &pViewerControl );
		//if the viewercontrol is set and valid
		if( SUCCEEDED( hr ) && pViewerControl != NULL )
		{
			//see if the viewer control is aggregated by lmrtrend ( as in the streaming case)
			IBaseFilter* pBaseFilter;
			hr = pViewerControl->QueryInterface( IID_IBaseFilter, (void**)&pBaseFilter );
			pViewerControl->Release();
			//if the viewercontrol has been aggregated by lmrtrend
			if( SUCCEEDED( hr ) )
			{
				//find the filter info
				FILTER_INFO pFilterInfo;
				hr = pBaseFilter->QueryFilterInfo( &pFilterInfo );
				pBaseFilter->Release();
				//if we successfully got the filterInfo
				if( SUCCEEDED( hr ) )
				{
					//get the MediaEventSink from the filterInfo
					//CComQIPtr<IMediaEventSink, &IID_IMediaEventSink> pMediaEventSink( pFilterInfo.pGraph );
					IMediaEventSink *pMediaEventSink;
					pFilterInfo.pGraph->QueryInterface( IID_IMediaEventSink, (void**)&pMediaEventSink );
					pFilterInfo.pGraph->Release();
					if( pMediaEventSink != NULL )
					{
						(*ppMediaEventSink) = pMediaEventSink;
						m_pMediaEventSink = pMediaEventSink;

						return S_OK;
					}
				}
			}
		}
	}
	return E_NOINTERFACE;
}

double CLMEngine::parseDoubleFromVersionString( BSTR version )
{
	double versionNum = 0.0;
	HRESULT stringLen = SysStringLen( version );
	for( int curChar = 0; curChar < stringLen; curChar++ )
	{
		if( version[curChar] != L'.' && version[curChar] >= L'0' && version[curChar] <= L'9' )
		{
			//pVersionString[ curChar - numPeriodsFound ] = pVersionString[ curChar ];
			versionNum = versionNum*10 + (int)(version[curChar] - L'0');
		}
	}

	return versionNum;
}

double CLMEngine::getDAVersionAsDouble()
{	
	//get the Version string from the DA Control
	BSTR pVersionString;
	HRESULT hr;
	hr = staticStatics->get_VersionString( &pVersionString );
	if( SUCCEEDED( hr ) )
	{
		//create a double from the version string
		double versionNum = parseDoubleFromVersionString( pVersionString );

		//free up resources
		SysFreeString( pVersionString );

		return versionNum;
	}
	return -1.0;
}

double CLMEngine::getLMRTVersionAsDouble()
{	
	//get the Version string from the Reader
	BSTR pVersionString;
	HRESULT hr;
	
	if( m_pReader == NULL )
		return -1.0;

	hr = m_pReader->get_VersionString( &pVersionString );
	if( SUCCEEDED( hr ) )
	{
		//create a double from the version string
		double versionNum = parseDoubleFromVersionString( pVersionString );

		//free up resources
		SysFreeString( pVersionString );

		return versionNum;
	}
	return -1.0;
}


// Override IObjectSafetyImpl

STDMETHODIMP CLMEngine::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}

STDMETHODIMP CLMEngine::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag  || riid == IID_IPersistStreamInit)
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
}

/**********************************************************************************
* Asynchronous loading methods
***********************************************************************************/

/**
* Set the asynchronous block size
*/
STDMETHODIMP CLMEngine::SetAsyncBlkSize(LONG blkSize)
{
	if (blkSize > 0L)
		m_AsyncBlkSize = (ULONG)blkSize;
	return S_OK;
}

/**
* Set the asynchronous delay
*/
STDMETHODIMP CLMEngine::SetAsyncDelay(LONG delay)
{
	if (delay > 0L)
		m_AsyncDelay = (ULONG)delay;
	return S_OK;
}

/**
* Called from TimerCallback when the timer goes off.  Posts a message to indicate
* that the timer went off, so that execution of the instructions does not happen
* in the timer callback.
*/
STDMETHODIMP CLMEngine::TimerCallbackHandler()
{
	if (!PostMessage(m_workerHwnd, WM_LMENGINE_TIMER_CALLBACK, (WPARAM)this, 0))
		return E_FAIL;
	else
		return S_OK;
}

/**
* Called when the timer goes off.  Redirects call to TimerCallbackHandler in
* the appropriate engine.
*/
void CALLBACK
CLMEngine::TimerCallback(UINT wTimerID,
                         UINT msg,
                         DWORD_PTR dwordUser,
                         DWORD_PTR unused1,
                         DWORD_PTR unused2)
{
    // Just call the right timer method.
    CLMEngine *pEngine = (CLMEngine *)(dwordUser);
    pEngine->TimerCallbackHandler();
}

/**
* Initialize timer
*/
STDMETHODIMP CLMEngine::InitTimer()
{
	TIMECAPS tc;
	if (timeGetDevCaps(&tc, sizeof(TIMECAPS)) != TIMERR_NOERROR) {
		return E_FAIL;
	}
	
	// Ensure in the min -> max range
	m_millisToUse = MIN(MAX(m_AsyncDelay, tc.wPeriodMin), tc.wPeriodMax);

	return S_OK;
}

/**
* Starts the timer
*/
STDMETHODIMP CLMEngine::StartTimer()
{
	
	m_Timer = timeSetEvent(m_millisToUse,
		EVENT_RESOLUTION,
		CLMEngine::TimerCallback,
		(DWORD_PTR) this,
		TIME_ONESHOT);
	if (m_Timer)
		return S_OK;
	else
		return E_FAIL;
}

/**
* Called by the message handling routine when it gets a message that more
* data is available from an asynchronous data stream.
* Adds the ByteArrayStream containing the data to the list of 
* ByteArrayStreams in the AsyncStream and calls execute
*/
STDMETHODIMP CLMEngine::NewDataHandler(CLMEngineInstrData *data)
{
    EnterCriticalSection(&m_CriticalSection);

    // TODO: I would be more comfortable if the code to add the
    // ByteArrayStream to the AsyncStream went in OnDataAvailable.
    // But the critical section stuff might be preventing the change
    // to the data structure being made during an execute in a different
    // thread?  If not, we could do away with this whole method.

    HRESULT hr = S_OK;

    if (m_bAbort) {
        hr = E_ABORT;
    }
    else 
    {
        if (data && data->byteArrayStream)
        {
            // There's a ByteArrayStream to add to the AsyncStream
            if (!codeStream)
            {
                // No AsyncStream yet.  Create one
                if (!(codeStream = new AsyncStream(data->byteArrayStream, m_AsyncBlkSize)))
                {
                    delete data->byteArrayStream;
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                // Code stream exists.  Add the ByteArrayStream to it
                ((AsyncStream *)codeStream)->AddByteArrayStream(data->byteArrayStream);
            }

            // TODO: This only works if the entire header is in the first block
            if (SUCCEEDED(hr) && !m_bHeaderRead)
            {
                // Try to read in the header
                hr = validateHeader();
                if (SUCCEEDED(hr))
                {
                    m_bHeaderRead = TRUE;
                }
                else
                {
                    delete codeStream;
                    codeStream = NULL;
                }
            }
        }

        if(SUCCEEDED(hr))
        {
            // Even if there is no data we want to do this so that
            // we can switch from pending to not pending and
            // finish up nicely.
            m_bPending = data ? data->pending : false;

            if(codeStream) {
                ((AsyncStream *)codeStream)->SetPending(m_bPending);
                hr = ExecuteFromAsync();
            }                    
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    delete data;

    return hr;
}

/**
* Called by external components delivering instructions asynchronously to this engine
* through a stream or a chunk of memory.
* Queues a message so that the execution of the instructions happens in a different thread.
* The message causes the method NewDataHandler to be called.
*/
STDMETHODIMP CLMEngine::OnDataAvailable (DWORD grfBSCF, 
									     DWORD dwSize,
										 FORMATETC *pfmtetc, 
										 STGMEDIUM * pstgmed)
{
	HRESULT hr;
	ByteArrayStream *byteArrayStream = 0;

	if (m_bAbort)
		return E_ABORT;

	BYTE *pBuf = 0;			// To be filled in with the instruction bytes

	if (pstgmed->tymed == TYMED_ISTREAM)
	{
		// The data is being passed in a stream
		// Read it out into pBuf
		if (!pstgmed->pstm)
			return E_POINTER;

		// In the case of a stream we need to take into account the
		// fact that we have already read some bytes
		dwSize -= m_PrevRead;

		if (!(pBuf = new BYTE[dwSize]))
			return E_OUTOFMEMORY;

		if (!SUCCEEDED(hr = pstgmed->pstm->Read((void*)pBuf, dwSize, NULL)))
			return hr;

		m_PrevRead += dwSize;

	}
	else if (pstgmed->tymed == TYMED_HGLOBAL)
	{
		// TODO: Test this!!!!!!!
		// The data is being passed through a memory chunk
		if (!pstgmed->hGlobal)
			return E_POINTER;

		// Lock the chunk
		LPVOID block = GlobalLock(pstgmed->hGlobal);

		if (!block)
			return E_FAIL;

		// Allocate new buf and copy into it
		if (!(pBuf = new BYTE[dwSize]))
			return E_OUTOFMEMORY;

		CopyMemory(pBuf, block, dwSize);

		// Unlock the chunk
		GlobalUnlock(pstgmed->hGlobal);
	}

	if (!pBuf)
	{
		// Failed to read any data
		return E_FAIL;
	}

	// Create a ByteArrayStream from the instructions to be used in NewDataAvailable
	if (!(byteArrayStream = new ByteArrayStream(pBuf, dwSize)))
	{
		delete pBuf;
		return E_OUTOFMEMORY;
	}

	// Put the information in a new CLMEngineInstrData
	CLMEngineInstrData *data = new CLMEngineInstrData();
	if (data == 0)
	{
		delete byteArrayStream;
		return E_OUTOFMEMORY;
	}

	data->byteArrayStream = byteArrayStream;

	// Work out whether there is more data pending
	if ((grfBSCF & BSCF_LASTDATANOTIFICATION) == BSCF_LASTDATANOTIFICATION)
		data->pending = FALSE;
	else 
		data->pending = TRUE;

		
	// Post a message to say that we have more data available
	if (!PostMessage (m_workerHwnd, WM_LMENGINE_DATA, (WPARAM)this, (LPARAM)data))
	{
		delete byteArrayStream;
		delete data;
		return E_ABORT;
	}

	return S_OK;
}

/**
* Called by external components delivering instructions asynchronously to this engine
* through a chunk of memory (could use OnDataAvailable with global mem handles, but
* this is more straightforward if the caller doesn't have a handle to the mem).
* Queues a message so that the execution of the instructions happens in a different thread.
* The message causes the method NewDataHandler to be called.
*/
STDMETHODIMP CLMEngine::OnMemDataAvailable (BOOLEAN lastBlock, 
									        DWORD blockSize,
										    BYTE *block)
{
	// It's OK to call this with a null block if only to inform us
	// that data has finished
	if (lastBlock && block == 0)
	{
		// Post a message with empty data so that we can finish up nicely
		if (!PostMessage (m_workerHwnd, WM_LMENGINE_DATA, (WPARAM)this, 0))
			return E_ABORT;
		return S_OK;
	}

	if (block == 0)
		return E_POINTER;

	if (m_bAbort)
		return E_ABORT;

	// Allocate new buffer and copy data into it
	BYTE *pBuf;				
	if (!(pBuf = new BYTE[blockSize]))
		return E_OUTOFMEMORY;

	// TODO: What's a way to do this without a loop and without the CRT?
	DWORD count = blockSize;
	BYTE *p = pBuf;
	while (count--)
		*p++ = *block++;

	// Create a ByteArrayStream from the instructions to be used in NewDataAvailable
	ByteArrayStream *byteArrayStream;
	if (!(byteArrayStream = new ByteArrayStream(pBuf, blockSize)))
	{
		delete pBuf;
		return E_OUTOFMEMORY;
	}

	// Put the information in a new CLMEngineInstrData
	CLMEngineInstrData *data = new CLMEngineInstrData();
	if (data == 0)
	{
		delete byteArrayStream;
		return E_OUTOFMEMORY;
	}

	data->byteArrayStream = byteArrayStream;
	data->pending = !lastBlock;

	// Post a message to say that we have more data available
	if (!PostMessage (m_workerHwnd, WM_LMENGINE_DATA, (WPARAM)this, (LPARAM)data))
	{
		delete byteArrayStream;
		delete data;
		return E_ABORT;
	}

	return S_OK;
}

STDMETHODIMP CLMEngine::OnStartBinding(DWORD dwReserved, IBinding *pBinding)
{
	m_spBinding = pBinding;
	return S_OK;
}

STDMETHODIMP CLMEngine::OnStopBinding(HRESULT hrStatus, LPCWSTR szStatusText)
{
	if (hrStatus != S_OK) 
		AbortExecution();

	m_spBinding.Release();
	return S_OK;
}
 
STDMETHODIMP CLMEngine::GetBindInfo(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
{
	ATLTRACE(_T("CBindStatusCallback::GetBindInfo\n"));
	*pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE |
		BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;
	pbindInfo->cbSize = sizeof(BINDINFO);
	pbindInfo->szExtraInfo = NULL;
	memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
	pbindInfo->grfBindInfoF = 0;
	pbindInfo->dwBindVerb = BINDVERB_GET;
	pbindInfo->szCustomVerb = NULL;
	return S_OK;
}

/**
* Release all the handles that this engine has on the Filter Graph.
*/
STDMETHODIMP CLMEngine::releaseFilterGraph()
{
	if( m_pMediaPosition != NULL )
		m_pMediaPosition = NULL;
	if( m_pMediaEventSink != NULL )
		m_pMediaEventSink = NULL;

	return S_OK;
}

/**
* Release all hanldels on the filter graph held by all engines
* that share the same reader with this engine.
*/
STDMETHODIMP CLMEngine::releaseAllFilterGraph()
{
	if( m_pReader != NULL )
		m_pReader->releaseFilterGraph();
	return S_OK;
}

HRESULT CLMEngine::Start(LONGLONG rtNow)
{
	if( m_pStartEvent != NULL )
	{
		IDANumber *pData;
		HRESULT hr = staticStatics->DANumber( 0.0f, &pData );
		if( SUCCEEDED( hr ) )
		{
			hr = staticStatics->TriggerEvent( m_pStartEvent, pData );
			pData->Release();
			// do something if we fail ? do we care if no one has set up the stop event?
		}
	}
    return S_OK;
}

HRESULT CLMEngine::Stop()
{
	if( m_pStopEvent != NULL )
	{
		IDANumber *pData;
		HRESULT hr = staticStatics->DANumber( 0.0f, &pData );
		if( SUCCEEDED( hr ) )
		{
			hr = staticStatics->TriggerEvent( m_pStopEvent, pData );
			pData->Release();
			// do something if we fail ? do we care if no one has set up the stop event?
		}
	}
    return S_OK;
}

HRESULT CLMEngine::SetMediaCacheDir(WCHAR *wsz)
{
    SysFreeString(m_bstrMediaCacheDir);
    m_bstrMediaCacheDir = SysAllocString(wsz);
    return m_bstrMediaCacheDir ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CLMEngine::disableAutoAntialias()
{
	m_bEnableAutoAntialias = false;
	return S_OK;
}

STDMETHODIMP CLMEngine::ensureBlockSize( ULONG blockSize )
{
	if( blockSize > m_AsyncBlkSize )
	{
		m_AsyncBlkSize = blockSize;
		if( codeStream != NULL )
			codeStream->ensureBlockSize( blockSize );
	}
	return S_OK;
}


/**
* Called by the message thread or NewDataHandler to execute
* some instructions from the AsyncStream
*/
STDMETHODIMP CLMEngine::ExecuteFromAsync()
{
	EnterCriticalSection(&m_CriticalSection);

	if (m_bAbort == TRUE)
		return E_FAIL;

    if(codeStream != NULL) {
	    ((AsyncStream *)codeStream)->ResetBlockRead();
    }
	else 
	{
		LeaveCriticalSection(&m_CriticalSection);
		return S_OK;
	}

	m_Timer = NULL;

	HRESULT hr = execute();
	
	if (!((hr == S_OK) || (hr == E_PENDING))) 
		AbortExecution();
	
	if (hr == E_PENDING && ((AsyncStream *)codeStream)->hasBufferedData())
	{
		m_bMoreToParse = TRUE;
		StartTimer();
	}
	else if (m_bPending == FALSE && hr != E_PENDING)
	{
		// We're done, failed or not.
		SetEvent(m_hDoneEvent);
		releaseAll();
		m_pIbsc = NULL;
		delete codeStream;
		codeStream = NULL;
	}

/*	
	if (m_bPending == FALSE) {
		// Last OnDataAvailable
		if (hr == E_PENDING) {
			m_bMoreToParse = TRUE;
			// More data to parse
			StartTimer();
		} else {
			// We're done, failed or not.
			SetEvent(m_hDoneEvent);
			releaseAll();
			m_pIbsc = NULL;
			delete codeStream;
			codeStream = NULL;
		}
	} 
*/

	LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

/************************************************************************************
*
*************************************************************************************/

/**
* Find and return the named element on the page in the client site
*/
STDMETHODIMP CLMEngine::getElementOnPage(BSTR tag, IUnknown **pVal)
{
	CComVariant						vName, vIndex;
    CComPtr<IHTMLDocument2>			pHTMLDoc;
	CComPtr<IHTMLElementCollection>	pElemCollection;
	CComPtr<IDispatch>				pDispatch;
	IOleContainer *pContainer;
	IOleClientSite *pClientSite;
	IOleObject *pOleObj;
	HRESULT hr = E_FAIL;

	if (!pVal) {
        return E_POINTER;
    }

	if ( m_pClientSite == NULL || FAILED(m_pClientSite->GetContainer(&pContainer)))
	{
		//we may be embedded in the MediaPlayer check the DA Control
		if( m_pReader != NULL )
		{
			IDAViewerControl *pViewer;
			hr = m_pReader->get_ViewerControl( &pViewer );
			if( SUCCEEDED( hr ) && pViewer != NULL )
			{
				hr = pViewer->QueryInterface( IID_IOleObject, (void**) &pOleObj );
				pViewer->Release();
				
				if( SUCCEEDED( hr ) )
				{
					hr = pOleObj->GetClientSite( &pClientSite );
					pOleObj->Release();
					if( SUCCEEDED( hr ) )
					{
						hr = pClientSite->GetContainer( &pContainer );
						pClientSite->Release();
						if( FAILED( hr ) ) 
							return hr;
					}
					else
						return hr;
				}
				else
					return hr;
			}
			else
				return E_FAIL;
		}
		else
			return E_FAIL;
	}
	//search for the nearest host that supports IHTMLDocument2
	pHTMLDoc = NULL;
	while( pHTMLDoc == NULL )
	{
		if( FAILED( pContainer->QueryInterface( IID_IHTMLDocument2, (void **)&pHTMLDoc ) ) )
		{
			//look for a parent
			hr = pContainer->QueryInterface( IID_IOleObject, (void**)&pOleObj );
			pContainer->Release();
			if( SUCCEEDED( hr ) )
			{
				hr = pOleObj->GetClientSite( &pClientSite );
				pOleObj->Release();
				if( SUCCEEDED( hr ) )
				{
					hr = pClientSite->GetContainer( &pContainer );
					pClientSite->Release();
					if( FAILED( hr ) )
						return hr;
				}
				else
					return hr;
			}
			else
				return hr;
		}
		else  //we succeeded in finding IHTMLDocument2
		{
			//release the contaier
			pContainer->Release();
		}
	}


	//if (FAILED(pRoot->QueryInterface(IID_IHTMLDocument2, (void **)&pHTMLDoc)))
	//	return E_FAIL;

	if (FAILED(pHTMLDoc->get_all(&pElemCollection)))
		return E_FAIL;

	vIndex.vt = VT_EMPTY;
	vName.vt = VT_BSTR;
	vName.bstrVal = tag;

	if (FAILED(pElemCollection->item(vName, vIndex, &pDispatch)))
		return E_FAIL;

	// There's a Trident bug (43078) that has the item()
	// method called above returning S_OK even if it
	// doesn't find the item.  Therefore, check for this
	// case explicitly. 
	if (pDispatch.p == NULL)
		return E_FAIL;

	hr = pDispatch->QueryInterface(IID_IUnknown, (void **)pVal);
	return hr;
}

/**
* Get the named DAViewerControl on the page contained in the client site
*/
STDMETHODIMP CLMEngine::getDAViewerOnPage(BSTR tag, IDAViewerControl **pViewer)
{
	CComPtr<IUnknown>			pObj;

	if (!pViewer || m_pReader == NULL)
        return E_POINTER;

	HRESULT hr;

	// First check to see whether the reader has one
	if (!SUCCEEDED(hr = m_pReader->get_ViewerControl(pViewer)))
		return hr;

	if (*pViewer != 0)
		return S_OK;
	
	hr = getElementOnPage(tag, &pObj);
	if (pObj)
	{
		hr = pObj->QueryInterface(IID_IDAViewerControl, (void **)pViewer);
		if (!SUCCEEDED(hr))
			return hr;
	} 

	return hr;
}



/**
* Request a navigation to the named URL
*/
STDMETHODIMP CLMEngine::navigate(BSTR url, BSTR location, BSTR frame, int newWindowFlag)
{


	/*
	CComPtr<IDAViewerControl> viewerControl = NULL;
	hr = m_pReader->get_ViewerControl( &viewerControl );

	CComPtr< IOleContainer> pContainer;
	if( SUCCEEDED(hr) && viewerControl != NULL )
	{
		CComQIPtr<IOleObject, IID_IOleObject> pOleObject(viewerControl);
		CComPtr<IOleClientSite> pClientSite;

		hr = pOleObject->GetClientSite( &pClientSite );
		if( SUCCEEDED( hr ) )
		{
			pOleObject->Q
			if( pContainer != NULL )
			{
			}
		}
	}
	*/

/*	
	if( viewerControl != NULL )
	{
		return HlinkSimpleNavigateToString(
											url,
											location,
											frame,
											viewerControl,
											_pbc,
											NULL,
											newWindowFlag == 0 ? HLNF_INTERNALJUMP : HLNF_OPENINNEWWINDOW,
											0);
	}
*/
	HRESULT hr;
	
	IMediaEventSink *pMediaEventSink = NULL;

	hr = getIMediaEventSink( &pMediaEventSink );
	if( SUCCEEDED( hr ) )
	{
		
		if ( url != NULL && location != NULL && frame != NULL )
		{
			//allocate enough space for the final URL string which is the
			// length of the URL + the length of the location + the length of the target frame
			// + 3 WCHARs for the "&&" and the terminating "\0"
			WCHAR *szURLBuf = new WCHAR[ SysStringLen( url ) + 
				SysStringLen( location ) + 
				SysStringLen( frame ) + 3 ];
			if( szURLBuf != NULL )
			{
				BSTR szType = SysAllocString( L"URL" );
				BSTR szURL = NULL;

				szURLBuf[0] = L'\0';
				
				wcscpy( szURLBuf, url );
				wcscat( szURLBuf, location );
				
				if( frame[0] != L'' )
				{
					wcscat( szURLBuf, L"&&" );
					wcscat( szURLBuf, frame );
				}
				
				szURL = SysAllocString( szURLBuf );
				delete[] szURLBuf;

				if( szURL != NULL && szType != NULL )
				{
					pMediaEventSink->Notify( EC_OLE_EVENT, (LONG_PTR) szType, (LONG_PTR) szURL );

					SysFreeString( szURL );
					SysFreeString( szType );

					hr = S_OK;
				} else {
					if( szType != NULL )
						SysFreeString( szURL );
					hr = E_FAIL;
				}

			} else //we failed to allocate szURLBuf
				hr = E_FAIL;

		} else //one of the strings passed in was null
			hr = E_POINTER;
		
		pMediaEventSink->Release();
		
		return hr;
	} else {//we could not get IMediaEventSink, perhaps we are not in the MediaPlayer
	
		//if we have a reader and a client site then we can navigate
		if (m_pReader != NULL && m_pClientSite != NULL)	
		{
			CComPtr<IBindCtx> _pbc;
			HRESULT hr = CreateBindCtx(0, &_pbc);
			if (FAILED(hr))
				return hr;
			return HlinkSimpleNavigateToString(
				url,
				location,
				frame,
				m_pReader,
				_pbc,
				NULL,
				newWindowFlag == 0 ? HLNF_INTERNALJUMP : HLNF_OPENINNEWWINDOW,
				0);
		} else {
			return E_POINTER;
		}
	}

	return hr;
}

/**
* Call a piece of script on the page
*/
STDMETHODIMP CLMEngine::callScriptOnPage(BSTR scriptSourceToInvoke,
										 BSTR scriptLanguage)
{    
	
	HRESULT hr;
	IMediaEventSink *pMediaEventSink = NULL;

	hr = getIMediaEventSink( &pMediaEventSink );
	if( SUCCEEDED( hr ) )
	{
		if( scriptSourceToInvoke != NULL && scriptLanguage != NULL )
		{
			BSTR szType = NULL;

			WCHAR *szTypeBuf = new WCHAR[ SysStringLen( scriptLanguage ) + LMRT_EVENT_PREFIX_LENGTH + 1 ];
			if( szTypeBuf != NULL )
			{
				szTypeBuf[0] = L'\0';
				wcscpy( szTypeBuf, LMRT_EVENT_PREFIX );
				wcscat( szTypeBuf, scriptLanguage );

				szType = SysAllocString( szTypeBuf );

				delete[] szTypeBuf;
			} else
				hr = E_FAIL;

			if( szType != NULL )
			{
				hr = pMediaEventSink->Notify( EC_OLE_EVENT, (LONG_PTR) szType, (LONG_PTR) scriptSourceToInvoke );

				SysFreeString( szType );
				pMediaEventSink->Release();

				return S_OK;
			} else
				hr = E_FAIL;
		}
		else
			hr = E_POINTER;
		pMediaEventSink->Release();
		return hr;
		
	} else { //we are not in a filter graph
		//try to do a callscript through the container
		CComPtr<IOleContainer> pRoot;
		CComPtr<IHTMLDocument> pHTMLDoc;
		CComPtr<IDispatch> pDispatch;
		CComPtr<IHTMLWindow2> pHTMLWindow2;
		CComVariant	retV;
		
		if (!m_pClientSite ||
			FAILED(m_pClientSite->GetContainer(&pRoot)) ||
			FAILED(pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
			FAILED(pHTMLDoc->get_Script(&pDispatch)) ||
			FAILED(pDispatch->QueryInterface(IID_IHTMLWindow2, (void **)&pHTMLWindow2)))
			return E_FAIL;
		
		return pHTMLWindow2->execScript(scriptSourceToInvoke,
			scriptLanguage,
			&retV);
	}
}

/**
* Set the status line
*/
STDMETHODIMP CLMEngine::SetStatusText(BSTR s)
{    
    CComPtr<IOleContainer> pRoot;
    CComPtr<IHTMLDocument> pHTMLDoc;
    CComPtr<IDispatch> pDispatch;
    CComPtr<IHTMLWindow2> pHTMLWindow2;
    
	if (m_pClientSite == NULL ||
		FAILED(m_pClientSite->GetContainer(&pRoot)) ||
        FAILED(pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
        FAILED(pHTMLDoc->get_Script(&pDispatch)) ||
        FAILED(pDispatch->QueryInterface(IID_IHTMLWindow2, (void **)&pHTMLWindow2)))
        return E_FAIL;

    return pHTMLWindow2->put_status(s);
}

/**
* Create a COM object given either the ProgID or the CLSID as a string
*/
STDMETHODIMP CLMEngine::createObject(BSTR str, IUnknown **ppObj)
{
	// This routine creates a COM object
	//
	// str is either the string representation of a CLSID, or a ProgID
	// We attempt to parse it as a ProgID first.

	CLSID				clsid;

	if (!ppObj)
		return E_POINTER;

	HRESULT hr = CLSIDFromString(str, &clsid);
	if (!SUCCEEDED(hr))
		return hr;

	return ::CoCreateInstance(clsid,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IUnknown, (void **)ppObj);
}

/**
* Invoke a method on a COM object through IDispatch
*/
STDMETHODIMP CLMEngine::invokeDispMethod(IUnknown *pIUnknown, BSTR method, WORD wFlags, unsigned int nArgs, VARIANTARG *pV, VARIANT *pRetV)
{
	DISPID				dispid;
	CComPtr<IDispatch>	pIDispatch;

	HRESULT hr = pIUnknown->QueryInterface(IID_IDispatch, (void **)&pIDispatch);
	if (!SUCCEEDED(hr))
		return hr;

	hr = pIDispatch->GetIDsOfNames(IID_NULL,
									&method,
									1,
									GetUserDefaultLCID(),
									&dispid);
	if (!SUCCEEDED(hr)) 
		return hr;

	/*
	 * wFlags are the same as wFlags in IDispatch::Invoke
	 *
	 * #define DISPATCH_METHOD         0x1
	 * #define DISPATCH_PROPERTYGET    0x2
	 * #define DISPATCH_PROPERTYPUT    0x4
	 * #define DISPATCH_PROPERTYPUTREF 0x8
	 */

	DISPPARAMS	params;
	params.cArgs = nArgs;
	params.rgvarg = pV;
	params.cNamedArgs = 0;
	params.rgdispidNamedArgs = NULL;

	return pIDispatch->Invoke(dispid,
							IID_NULL,
							GetUserDefaultLCID(),
							wFlags,
							&params,
							pRetV,
							NULL,
							NULL);

}

STDMETHODIMP CLMEngine::initVariantArg(BSTR arg, VARTYPE type, VARIANT *pV)
{
	VARIANT strVar;

	if (!arg || !pV)
		return E_POINTER;

	VariantInit(pV);

    strVar.vt = VT_BSTR;
	strVar.bstrVal = arg;

	return VariantChangeType(pV, &strVar, 0, type);
}

STDMETHODIMP CLMEngine::initVariantArgFromString(BSTR arg, VARIANT *pV)
{
	if (!arg || !pV)
		return E_POINTER;

    pV->vt = VT_BSTR;
	pV->bstrVal = arg;

	return S_OK;
}

STDMETHODIMP CLMEngine::initVariantArgFromLong(long lVal, int type, VARIANT *pV)
{
	if (!pV)
		return E_POINTER;

    pV->vt = VT_I4;
	pV->lVal = lVal;

	return S_OK;
}

STDMETHODIMP CLMEngine::initVariantArgFromDouble(double dbl, int type, VARIANT *pV)
{
	if (!pV)
		return E_POINTER;

    pV->vt = VT_R8;
	pV->dblVal = dbl;

	return S_OK;
}

STDMETHODIMP CLMEngine::initVariantArgFromIUnknown(IUnknown *pI, int type, VARIANT *pV)
{
	if (!pI || !pV)
		return E_POINTER;

    pV->vt = VT_UNKNOWN;
	pV->punkVal = pI;

	return S_OK;
}

STDMETHODIMP CLMEngine::initVariantArgFromIDispatch(IDispatch *pI, int type, VARIANT *pV)
{
	if (!pI || !pV)
		return E_POINTER;

    pV->vt = VT_DISPATCH;
	pV->punkVal = pI;

	return S_OK;
}

STDMETHODIMP CLMEngine::getIDispatchOnHost( IDispatch **ppHostDisp )
{
	if( ppHostDisp == NULL )
		return E_POINTER;

	HRESULT hr = E_FAIL;

	if( m_pReader != NULL )
	{
		IDAViewerControl *pViewer;
		hr = m_pReader->get_ViewerControl( &pViewer );
		if( SUCCEEDED( hr ) && pViewer != NULL )
		{
			IOleObject *pOleObj;
			hr = pViewer->QueryInterface( IID_IOleObject, (void**) &pOleObj );
			pViewer->Release();
			
			if( SUCCEEDED( hr ) )
			{
				IOleClientSite *pClientSite;
				hr = pOleObj->GetClientSite( &pClientSite );
				pOleObj->Release();

				if( SUCCEEDED( hr ) )
				{
					IOleContainer *pContainer;
					hr = pClientSite->GetContainer( &pContainer );
					pClientSite->Release();
					if( SUCCEEDED( hr ) )
					{
						IDispatch *pDispatch;
						hr = pContainer->QueryInterface( IID_IDispatch, (void**)&pDispatch );
						pContainer->Release();
						if( SUCCEEDED( hr ) )
						{
							pDispatch->Release();
						}
					}
				}
			}
			
		}
	}
	return hr;

}

/***************************************
 * SyncStream
 ***************************************/

SyncStream::SyncStream(LPSTREAM pStream)
{
	m_pStream = pStream;
}

SyncStream::~SyncStream()
{
}

STDMETHODIMP SyncStream::Commit()
{
	return m_pStream->Commit(STGC_DEFAULT);
}

STDMETHODIMP SyncStream::Revert()
{
	return m_pStream->Revert();
}

STDMETHODIMP SyncStream::readByte(LPBYTE pByte)
{
	if (!pByte)
		return E_POINTER;

	HRESULT hr = NULL;
	ULONG	nRead;
	hr = m_pStream->Read((void*)pByte, 1L, &nRead);

#if 0
	char cbuf[100];
	sprintf(cbuf, "readByte::%d bytes read, buf = %d, 0x%X", nRead, buf, buf);
	MessageBox(NULL, cbuf, "CLMEngine", MB_OK);
#endif

	if (hr == S_FALSE || (hr == S_OK && nRead != 1))
		hr = E_FAIL;

	return hr;
}


STDMETHODIMP SyncStream::readBytes(LPBYTE pByte, ULONG count, ULONG *pNumRead)
{
	if (!pByte)
		return E_POINTER;

	ULONG	nRead;
	HRESULT hr = m_pStream->Read((void *)pByte, count, &nRead);

	if (hr == S_FALSE || (hr == S_OK && nRead != count))
		hr = E_FAIL;

	if (pNumRead)
		*pNumRead = nRead;

	return hr;
}

/***************************************
 * AsyncStream
 ***************************************/
AsyncStream::AsyncStream(ByteArrayStream *pBAStream, ULONG blkSize)
{
	pBAStreamQueue = new ByteArrayStreamQueue;
	pBAStreamQueueTail = new ByteArrayStreamQueue;
	pBAStreamQueueHead = pBAStreamQueueTail;
	pBAStreamQueue->next = pBAStreamQueueTail;
	pBAStreamQueueTail->pBAStream = pBAStream;
	pBAStreamQueueTail->next = NULL;
	m_bPendingData = FALSE;
	m_nRead = 0;
	m_BlkSize = blkSize;
}

AsyncStream::~AsyncStream()
{
	ByteArrayStreamQueue	*pBAStreamQNext;
	
	if (pBAStreamQueue != NULL) {
		pBAStreamQNext = pBAStreamQueue->next;
		delete pBAStreamQueue;
		
		while (pBAStreamQNext != NULL) {
			pBAStreamQueue = pBAStreamQNext;
			pBAStreamQNext = pBAStreamQNext->next;
			delete pBAStreamQueue->pBAStream;
			delete pBAStreamQueue;
		}
	}
}

STDMETHODIMP AsyncStream::Commit()
{
	ByteArrayStreamQueue *tmpQ = pBAStreamQueue->next;
	ByteArrayStreamQueue *nextQ;

	if (tmpQ != pBAStreamQueueHead) {
		while ((tmpQ != pBAStreamQueueHead) && (tmpQ != NULL)) {
			nextQ = tmpQ->next;
			delete tmpQ->pBAStream;
			delete tmpQ;
			tmpQ = nextQ;
		}
		pBAStreamQueue->next = pBAStreamQueueHead;
	}

	pBAStreamQueueHead->pBAStream->Commit();

	return S_OK;
}

STDMETHODIMP AsyncStream::Revert()
{
	HRESULT hr = E_FAIL;

	pBAStreamQueueHead = pBAStreamQueue->next;

	ByteArrayStreamQueue	*tmpQ = pBAStreamQueueHead;

	while (tmpQ) {
		hr = tmpQ->pBAStream->Revert();
		if (!SUCCEEDED(hr))
			break;
		tmpQ = tmpQ->next;
	}
	return hr;
}


STDMETHODIMP AsyncStream::readByte(LPBYTE pByte)
{
	HRESULT hr = E_FAIL;
	
	if (!pBAStreamQueueHead) {
		if (m_bPendingData)
			hr = E_PENDING;
		else
			hr = E_FAIL;
	} else {
		if (m_nRead >= m_BlkSize) 
			hr = E_PENDING;
		else {
			if (pBAStreamQueueHead->pBAStream)
				hr = pBAStreamQueueHead->pBAStream->readByte(pByte);
			if (hr == E_FAIL) {
				// No more data in this stream, try moving on to the next one.
				if (pBAStreamQueueHead != pBAStreamQueueTail) {
					pBAStreamQueueHead = pBAStreamQueueHead->next;
					hr = readByte(pByte);
				} else {
					// We've run out of streams
					if (m_bPendingData)
						hr = E_PENDING;
					else
						hr = E_FAIL;
				}
			} else
				m_nRead++;
		}
	}
	return hr;
}

bool AsyncStream::hasBufferedData()
{
	if (pBAStreamQueueHead == 0)
		return false;

	if (pBAStreamQueueHead->pBAStream != 0 && pBAStreamQueueHead->pBAStream->hasBufferedData() )
		return true;

	if (pBAStreamQueueHead == pBAStreamQueueTail)
		return false;

	return true;
}


STDMETHODIMP AsyncStream::readBytes(LPBYTE pByte, ULONG count, ULONG *pNumRead)
{
	ULONG	nRead;
	HRESULT	hr = E_FAIL;

	if (!pBAStreamQueueHead) {
		if (m_bPendingData)
			hr = E_PENDING;
		else
			hr = E_FAIL;
	} else {
		if (m_nRead >= m_BlkSize)
			hr = E_PENDING;
		else {
			if (pBAStreamQueueHead->pBAStream)
				hr = pBAStreamQueueHead->pBAStream->readBytes(pByte, count, &nRead);
			m_nRead += nRead;
			if (hr == E_FAIL) {
				// No more data in this stream, try moving on to the next one.
				if (pBAStreamQueueHead != pBAStreamQueueTail) {
					pByte += nRead;
					pBAStreamQueueHead = pBAStreamQueueHead->next;

					ULONG	_nRead;
					hr = readBytes(pByte, count - nRead, &_nRead);
					nRead += _nRead;
				} else {
					// We've run out of streams
					if (m_bPendingData)
						hr = E_PENDING;
					else
						hr = E_FAIL;
				}
			} 
		}
	}

	if (pNumRead)
		*pNumRead = nRead;

	return hr;
}

STDMETHODIMP AsyncStream::ensureBlockSize( ULONG blockSize )
{
	//if the size that we are ensuring is greater than the 
	// current block size
	if( blockSize > m_BlkSize )
		//grow the current block size.
		m_BlkSize = blockSize;
	return S_OK;

}

STDMETHODIMP AsyncStream::SetPending(BOOL bFlag)
{
	m_bPendingData = bFlag;
	return S_OK;
}

STDMETHODIMP AsyncStream::ResetBlockRead()
{
	m_nRead = 0;
	return S_OK;
}

STDMETHODIMP AsyncStream::AddByteArrayStream(ByteArrayStream *pNewBAStream)
{
	pBAStreamQueueTail->next = new ByteArrayStreamQueue;
	if (!pBAStreamQueueTail->next)
		return E_OUTOFMEMORY;
	pBAStreamQueueTail = pBAStreamQueueTail->next;
	pBAStreamQueueTail->pBAStream = pNewBAStream;
	pBAStreamQueueTail->next = NULL;
	return S_OK;
}


/***************************************
 * ByteArrayStream
 ***************************************/

STDMETHODIMP ByteArrayStream::Commit()
{
	mark = next;
	return S_OK;
}

STDMETHODIMP ByteArrayStream::Revert()
{
	next = mark;
	remaining = size - (ULONG)(next - array);
	return S_OK;
}

ByteArrayStream::ByteArrayStream(BYTE *array, ULONG size)
{
	this->array = array;

	if (this->array) {
		this->size = size;
		this->remaining = size;

		BYTE *from = array;
		BYTE *to = this->array;

		while (size--)
			*to++ = *from++;
	} else {
		this->size = 0;
		this->remaining = 0;
	}

	this->next = this->array;
	Commit();
}

ByteArrayStream::~ByteArrayStream()
{
	if (array)
		delete[] array;
}

bool ByteArrayStream::hasBufferedData()
{
	if (remaining > 0)
		return true;
	else
		return false;
}

STDMETHODIMP ByteArrayStream::readByte(LPBYTE pByte)
{
	if (!pByte)
		return E_POINTER;

	HRESULT status;

	if (remaining) {
		remaining--;
		*pByte = *next++;
		status = S_OK;
	} else
		status = E_FAIL;

	return status;
}

STDMETHODIMP ByteArrayStream::readBytes(LPBYTE pByte, ULONG count, ULONG *pNumRead)
{
	HRESULT status;

	if (!pByte)
		return E_POINTER;

	if (remaining >= count) {
		if (pNumRead)
			*pNumRead = count;
		remaining -= count;

		while (count--)
			*pByte++ = *next++;

		status = S_OK;
	} else {
		if (pNumRead)
			*pNumRead = remaining;
		while (remaining--)
			*pByte++ = *next++;
		status = E_FAIL;
	}

	return status;
}

void ByteArrayStream::reset()
{
	next = array;
	remaining = size;
	mark = next;
}

/***************************************
 * CLMNotifier
 ***************************************/

STDMETHODIMP_(ULONG) CLMNotifier::AddRef() { return InterlockedIncrement(&_cRefs); }
	
STDMETHODIMP_(ULONG) CLMNotifier::Release() 
{
	ULONG refCount = InterlockedDecrement(&_cRefs);
	if (!refCount) {
		delete this;
		return refCount;
	}
	return _cRefs;
}

STDMETHODIMP CLMNotifier::QueryInterface(REFIID riid, void **ppv) 
{
	if (!ppv)
		return E_POINTER;
	
	*ppv = NULL;
	if (riid == IID_IUnknown) {
		*ppv = (void *)(IUnknown *)this;
	} else if (riid == IID_IDABvrHook) {
		*ppv = (void *)(IDAUntilNotifier *)this;
	}
	
	if (*ppv) {
		((IUnknown *)*ppv)->AddRef();
		return S_OK;
	}
	
	return E_NOINTERFACE;
}

STDMETHODIMP CLMNotifier::GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }
STDMETHODIMP CLMNotifier::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) { return E_NOTIMPL; }
STDMETHODIMP CLMNotifier::GetIDsOfNames(
						   REFIID riid, LPOLESTR *rgszNames, UINT cNames,
						   LCID lcid, DISPID *rgdispid) { return E_NOTIMPL; }
STDMETHODIMP CLMNotifier::Invoke(
					DISPID dispidMember, REFIID riid, LCID lcid,
					WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
					EXCEPINFO *pexcepinfo, UINT *puArgErr) { return E_NOTIMPL; }

STDMETHODIMP CLMNotifier::ClearEngine() { m_pEngine = NULL; return S_OK; }

CLMNotifier::CLMNotifier(CLMEngine *pEngine)
{
	m_pEngine = pEngine;
	//((IUnknown *)m_pEngine)->AddRef();
	
	_cRefs = 1;
}

CLMNotifier::~CLMNotifier()
{
	//((IUnknown *)m_pEngine)->Release();
}

STDMETHODIMP CLMNotifier::Notify(IDABehavior *eventData,
					IDABehavior *curRunningBvr,
					IDAView *curView,
					IDABehavior **ppBvr)
{
	if (!m_pEngine)
		return E_UNEXPECTED;

	return m_pEngine->Notify(eventData, curRunningBvr, curView, ppBvr);
}

/***************************************
 * CLMExportTable
 ***************************************/
CLMExportTable::CLMExportTable(IDAStatics *statics)
{

	m_nBvrs = 0;
	m_exportList = new CLMExportList;
	m_exportList->tag = NULL;
	m_exportList->pBvr = NULL;
	m_exportList->next = NULL;
	m_tail = m_exportList;
	m_pStatics = statics;
}

CLMExportTable::~CLMExportTable()
{
	CLMExportList	*next, *head;

	if (!m_exportList)
		return;

	head = m_exportList;
	m_exportList = m_exportList->next;
	free(head);
	while (m_exportList != NULL) {
		if (m_exportList->pBvr != NULL) 
			m_exportList->pBvr->Release();
		if (m_exportList->tag)
			free(m_exportList->tag);
		next = m_exportList->next;
		delete m_exportList;
		m_exportList = next;
	} 
}

STDMETHODIMP CLMExportTable::AddBehavior(BSTR tag, IDABehavior *pBvr)
{
	// First, let's look to see if the Script outpaced us and already put a 
	// switchable behavior here...
	CLMExportList	*pList = m_exportList->next;
	while (pList != NULL) {
		if (!lstrcmpW(tag, pList->tag)) {
			break;
		}
		pList = pList->next;
	}

	if (pList != NULL) {
		// Already exists!  Script must have been here first.  We'll just switch it in then.
		return pList->pBvr->SwitchTo(pBvr);
	}

	long len = lstrlenW(tag);
	m_tail->next = new CLMExportList;
	if (!m_tail->next)
		return E_OUTOFMEMORY;
	m_tail->next->tag = (OLECHAR *)new char[(len + 1) * 2 * sizeof(char)] ;
	if (!m_tail->next->tag) {
		delete m_tail->next;
		m_tail->next = NULL;
		return E_OUTOFMEMORY;
	}
	m_tail = m_tail->next;
	lstrcpyW(m_tail->tag, tag);
	m_tail->pBvr = pBvr;
	pBvr->AddRef();
	m_tail->next = NULL;
	return S_OK;
}

STDMETHODIMP CLMExportTable::GetBehavior(BSTR tag, IDABehavior *pDefaultBvr, IDABehavior **ppBvr)
{
	CLMExportList	*pList = m_exportList->next;

	if (!ppBvr)
		return E_POINTER;

	while (pList != NULL) {
		if (!lstrcmpW(tag, pList->tag)) {
			*ppBvr = pList->pBvr;
			pList->pBvr->AddRef();
			break;
		}
		pList = pList->next;
	}

	if (pList == NULL) {
		// Didn't find it yet, we'll switch on it later
		IDABehavior *pINewBvr;
		m_pStatics->ModifiableBehavior(pDefaultBvr, (IDABehavior **)&pINewBvr);
		AddBehavior(tag, pINewBvr);
		*ppBvr = pINewBvr;
	} 
	return S_OK;
}


URLRelToAbsConverter::URLRelToAbsConverter(LPSTR baseURL, LPSTR relURL) {
	DWORD len = INTERNET_MAX_URL_LENGTH;
		  
	if (!InternetCombineUrlA (baseURL, relURL, _url, &len, ICU_NO_ENCODE)) {
		// If we cannot determine if the path is absolute then assume
		// it is absolute
		lstrcpy (_url, relURL) ;
	}
}

LPSTR URLRelToAbsConverter::GetAbsoluteURL () { 
	return _url; 
}

URLCombineAndCanonicalizeOLESTR::URLCombineAndCanonicalizeOLESTR(char * base, LPOLESTR path) {

	WideToAnsi(path, _url);
            
	// Need to combine (takes care of canonicalization
	// internally)
	URLRelToAbsConverter absolutified(base, _url);
	char *resultURL = absolutified.GetAbsoluteURL();
	
	lstrcpy(_url, resultURL);

	AnsiToWide( _url, _urlWide );
}

LPSTR URLCombineAndCanonicalizeOLESTR::GetURL() { 
	return _url; 
}

LPWSTR URLCombineAndCanonicalizeOLESTR::GetURLWide() 
{
	return _urlWide;
}

STDMETHODIMP CLMEngine::createMsgWindow()
{
	WNDCLASS wndclass;
	
	memset(&wndclass, 0, sizeof(WNDCLASS));
	wndclass.style          = 0;
	wndclass.lpfnWndProc    = WorkerWndProc;
	wndclass.hInstance      = hInst;
	wndclass.hCursor        = NULL;
	wndclass.hbrBackground  = NULL;
	wndclass.lpszClassName  = WORKERHWND_CLASS;
	
	RegisterClass(&wndclass) ;
    
    m_workerHwnd = ::CreateWindow (WORKERHWND_CLASS,
                                   "LMEngine Worker Private Window",
                                   0,0,0,0,0,NULL,NULL,hInst,NULL);
	if (m_workerHwnd)
		return S_OK;
	else
		return E_FAIL;
}

LRESULT CALLBACK
CLMEngine::WorkerWndProc(HWND hwnd,
                     UINT msg,
                     WPARAM wParam,
                     LPARAM lParam)
{
    BOOL    fDefault = FALSE;
	LRESULT	lResult = E_FAIL;
    
    switch (msg) {
	  case WM_LMENGINE_DATA:
		  {
			  // OnDataAvailable has been called
			  CLMEngine *pEngine = (CLMEngine *)(wParam);

              // the last "we're done" message releases the daviewer
              // control (ReleaseAll()) which releases us. and
              // lmrtrend has already released us, so we need to bump
              // up our ref count.
              ((ILMEngine *)pEngine)->AddRef();
			  pEngine->NewDataHandler((CLMEngineInstrData *)lParam);


              // may be final release
              ((ILMEngine *)pEngine)->Release();

			  lResult = NO_ERROR;
		  }
		  break;

	  case WM_LMENGINE_TIMER_CALLBACK:
		  {
			  // The timer fired.  Lets process some more data
			  CLMEngine *pEngine = (CLMEngine *)(wParam);
              ((ILMEngine *)pEngine)->AddRef();
			  pEngine->ExecuteFromAsync();
              ((ILMEngine *)pEngine)->Release();
			  lResult = NO_ERROR;
		  }
		  break;

	  case WM_LMENGINE_SCRIPT_CALLBACK:
		  {
			  // Do a script callback
			  CLMEngine *pEngine = (CLMEngine *)wParam;
			  CLMEngineScriptData *scriptData = (CLMEngineScriptData *)lParam;
			  pEngine->callScriptOnPage(scriptData->scriptSourceToInvoke, scriptData->scriptLanguage);

			  // Trigger event indicating that the script has actually been called
			  if (scriptData->event)
				  pEngine->staticStatics->TriggerEvent(scriptData->event, scriptData->eventData);

			  // Clear everything
			  SysFreeString(scriptData->scriptSourceToInvoke);
			  SysFreeString(scriptData->scriptLanguage);
			  if (scriptData->event)
				  scriptData->event->Release();
			  if (scriptData->eventData)
				  scriptData->eventData->Release();
			  free(scriptData);
			  lResult = NO_ERROR;
		  }
		  break;

      default:
		  lResult = DefWindowProc(hwnd, msg, wParam, lParam);
		  break ;
    }

    return lResult;
}

STDMETHODIMP CLMEngine::AbortExecution()
{
	EnterCriticalSection(&m_CriticalSection);

        if(m_pmc)
        {
            m_pmc->Stop();

            {
                // make RenderFile fail if it called us.
                CComQIPtr<IGraphBuilder, &IID_IGraphBuilder> pgb(m_pmc);
                if(pgb)
                {
                    HRESULT hrTmp = pgb->Abort();
                    _ASSERTE(hrTmp == S_OK);
                }
            }

            long l = m_pmc.p->Release();
            m_pmc.p = 0;

            // that should have removed our last reference on the
            // graph and thus released the LM filter. If not, we have
            // a circular reference that won't go away. 
            _ASSERTE(l == 0 || m_fDbgInRenderFile);

        }
        
	if (m_bAbort == FALSE) {
		if (m_Timer)
			timeKillEvent(m_Timer);
		m_Timer = NULL;
		m_bAbort = TRUE;
		releaseAll();
		m_pIbsc = NULL;
		if (codeStream)
			delete codeStream;
		codeStream = NULL;
	}
	LeaveCriticalSection(&m_CriticalSection);

	return S_OK;
}

STDMETHODIMP_(BSTR) CLMEngine::ExpandImportPath(BSTR path)
{
	bool	doExpand = true;
	BSTR	expandedBSTR;

	/* Only do the expansion if the path is not absolute already;
	 * special case 'lmrt:'
         */

        if(m_bstrMediaCacheDir && wcsncmp(path, L"lmrt:", 5) == 0)
        {
            // waste!!!
            int cch = wcslen(path) + 1; 
            WCHAR *wsz = (WCHAR *)_alloca((cch + wcslen(m_bstrMediaCacheDir) + 20) * sizeof(WCHAR));
            wcscpy(wsz, L"file://");
            wcscat(wsz, m_bstrMediaCacheDir);
            wcscat(wsz, L"/");
            wcscat(wsz, path + 5);
            expandedBSTR = SysAllocString(wsz);
        }
        else
        {
            wchar_t  *wstr = wcschr(path, ':');
            if (wstr != NULL &&  (wcsncmp(wstr, L"://", 3) == 0))
            {
		// Just copy the original
		expandedBSTR = SysAllocStringLen(path, ::SysStringLen(path));
            }
            else
            {
		// Use the client site's url as the base, and create an absolute path from that.
		char *clientURL = GetURLOfClientSite();
		URLCombineAndCanonicalizeOLESTR canonURL(clientURL, path);
		free(clientURL);

		// Convert the result from ansi to wide
		char *url = canonURL.GetURL();
		int len = (lstrlenA(url)+1);
		LPWSTR absURL = ATLA2WHELPER((LPWSTR) alloca(len*2), url, len);

		// Create a bstr out of the result
		expandedBSTR = SysAllocString(absURL);
            }
        }

	return expandedBSTR;
}

STDMETHODIMP CLMEngine::getExecuteFromUnknown( IUnknown *pUnk, ILMEngineExecute **ppExecute )
{
	if( pUnk == NULL )
		return E_POINTER;
	if( ppExecute == NULL )
		return E_POINTER;
	HRESULT hr;

	ILMEngineWrapper *pWrapper;
	hr = pUnk->QueryInterface( IID_ILMEngineWrapper, (void**)&pWrapper );
	if( SUCCEEDED( hr ) )
	{
		IUnknown *pWrapped;
		hr = pWrapper->GetWrapped( &pWrapped );
		pWrapper->Release();
		if( SUCCEEDED( hr ) )
		{
			ILMEngineExecute *pExecute;
			hr = pWrapped->QueryInterface( IID_ILMEngineExecute, (void**)&pExecute );
			pWrapped->Release();
			if( SUCCEEDED( hr ) )
			{
				(*ppExecute) = pExecute;
				return S_OK;
			}
		}
	}
	else //perhaps this was not wrapped
	{
		ILMEngineExecute *pExecute;
		hr = pUnk->QueryInterface( IID_ILMEngineExecute, (void**)&pExecute );
		if( SUCCEEDED( hr ) )
		{
			(*ppExecute) = pExecute;
			return S_OK;
		}
	}
	return hr;
}

STDMETHODIMP CLMEngine::getEngine2FromUnknown( IUnknown *pUnk, ILMEngine2 **ppEngine )
{
	if( pUnk == NULL )
		return E_POINTER;
	if( ppEngine == NULL )
		return E_POINTER;
	HRESULT hr;

	ILMEngineWrapper *pWrapper;
	hr = pUnk->QueryInterface( IID_ILMEngineWrapper, (void**)&pWrapper );
	if( SUCCEEDED( hr ) )
	{
		IUnknown *pWrapped;
		hr = pWrapper->GetWrapped( &pWrapped );
		pWrapper->Release();
		if( SUCCEEDED( hr ) )
		{
			ILMEngine2 *pEngine;
			hr = pWrapped->QueryInterface( IID_ILMEngine2, (void**)&pEngine );
			pWrapped->Release();
			if( SUCCEEDED( hr ) )
			{
				(*ppEngine) = pEngine;
				return S_OK;
			}
		}
	}
	else //perhaps this was not wrapped
	{
		ILMEngine2 *pEngine;
		hr = pUnk->QueryInterface( IID_ILMEngine2, (void**)&pEngine );
		if( SUCCEEDED( hr ) )
		{
			(*ppEngine) = pEngine;
			return S_OK;
		}
	}
	return hr;
}

/**
* ILMCodecDownload
**/
STDMETHODIMP CLMEngine::setAutoCodecDownloadEnabled(BOOL bEnabled )
{
	m_bAutoCodecDownloadEnabled = bEnabled;
	return S_OK;
}

/**
*  ILMEngineExecute 
*/
STDMETHODIMP CLMEngine::ExportBehavior(BSTR key, IDABehavior *toExport)
{
	IUnknown *pUnk;
	m_exportTable->AddBehavior( key, toExport );
	return S_OK;
}

STDMETHODIMP CLMEngine::SetImage(IDAImage *pImage)
{
	if ( m_pImage != NULL )
		m_pImage->SwitchTo( pImage );
	else {
		m_pImage = pImage;
		m_pImage->AddRef();
	}
	return S_OK;
}

STDMETHODIMP CLMEngine::SetSound(IDASound *pSound)
{
	if (m_pSound != NULL)
		m_pSound->SwitchTo( pSound );
	else {
		m_pSound = pSound;
		m_pSound->AddRef();
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\util.cpp ===
//*****************************************************************************
//
// File:    util.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of utility functions
//
// Modification List:
// Date		Author		Change
// 10/16/98	jeffort		Created this file
//*****************************************************************************

#include <headers.h>
#include "utils.h"

//*****************************************************************************

#ifdef DEBUG
#define ASSERT_BANNER_STRING "************************************************************"

void debugAssert(LPCSTR szFile, INT nLine, LPCSTR szCondition)
{
    char szBuffer[MAX_PATH];

    //
    // Build the debug stream message.
    //
    wsprintfA(szBuffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition);

    //
    // Issue the message
    //
    DPF_ERR(ASSERT_BANNER_STRING);
    DPF_ERR(szBuffer);
    DPF_ERR(ASSERT_BANNER_STRING);

#ifdef _X86_
    _asm {int 3};
#else
    DebugBreak();
#endif // _X86_
}

#endif // DEBUG 


//*****************************************************************************

HRESULT CUtils::InsurePropertyVariantAsBool(VARIANT *varValue)
{
    // If the variant is empty or null, then return
    if (varValue->vt == VT_NULL || varValue->vt == VT_EMPTY)
    {
        return E_INVALIDARG;
    }
    // if the type currently is not a BOOL then coerce it to one
    if (varValue->vt != VT_BOOL)
    {
        VARIANT var;
        VariantInit(&var);
        HRESULT hr = VariantChangeTypeEx(&var, 
                                       varValue,
                                       LCID_SCRIPTING,
                                       VARIANT_NOUSEROVERRIDE,
                                       VT_BOOL);
        if (FAILED(hr))
        {
            DPF_ERR("Error changing variant type to bool");
            return hr;
        }
        hr = VariantCopy(varValue, &var);
        VariantClear(&var);
        if (FAILED(hr))
        {
            DPF_ERR("Error copying variant");
            return hr;
        }
    }
    return S_OK;
}

//*****************************************************************************


HRESULT CUtils::InsurePropertyVariantAsBSTR(VARIANT *varValue)
{
    // If the variant is empty or null, then the code below will
    // convert it to the empty string, but we will consider this to be
    // invalid, and only want to convert objects of substance
    if (varValue->vt == VT_NULL || varValue->vt == VT_EMPTY)
    {
        return E_INVALIDARG;
    }
    // if the type currently is not a BSTR then coerce it to one
    if (varValue->vt != VT_BSTR)
    {
        VARIANT var;
        VariantInit(&var);
        HRESULT hr = VariantChangeTypeEx(&var, 
                                       varValue,
                                       LCID_SCRIPTING,
                                       VARIANT_NOUSEROVERRIDE,
                                       VT_BSTR);
        if (FAILED(hr))
        {
            DPF_ERR("Error changing variant type to bstr in GetPropertyAsBSTR");
            return hr;
        }
        hr = VariantCopy(varValue, &var);
        VariantClear(&var);
        if (FAILED(hr))
        {
            DPF_ERR("Error copying variant in GetPropertyAsBSTR");
            return hr;
        }
    }
    return S_OK;
} // PropertyVariantInsureBSTR


//*****************************************************************************

typedef struct _COLORVALUE_PAIR
{
    const WCHAR *wzName;
    DWORD        dwValue;
} COLORVALUE_PAIR;

const COLORVALUE_PAIR
rgColorNames[] =
{
    { (L"aliceblue"),             0x01f0f8ff },
    { (L"antiquewhite"),          0x02faebd7 },
    { (L"aqua"),                  0x0300ffff },
    { (L"aquamarine"),            0x047fffd4 },
    { (L"azure"),                 0x05f0ffff },
    { (L"beige"),                 0x06f5f5dc },
    { (L"bisque"),                0x07ffe4c4 },
    { (L"black"),                 0x08000000 },
    { (L"blanchedalmond"),        0x09ffebcd },
    { (L"blue"),                  0x0a0000ff },
    { (L"blueviolet"),            0x0b8a2be2 },
    { (L"brown"),                 0x0ca52a2a },
    { (L"burlywood"),             0x0ddeb887 },
    { (L"cadetblue"),             0x0e5f9ea0 },
    { (L"chartreuse"),            0x0f7fff00 },
    { (L"chocolate"),             0x10d2691e },
    { (L"coral"),                 0x11ff7f50 },
    { (L"cornflowerblue"),        0x126495ed },
    { (L"cornsilk"),              0x13fff8dc },
    { (L"crimson"),               0x14dc143c },
    { (L"cyan"),                  0x1500ffff },
    { (L"darkblue"),              0x1600008b },
    { (L"darkcyan"),              0x17008b8b },
    { (L"darkgoldenrod"),         0x18b8860b },
    { (L"darkgray"),              0x19a9a9a9 },
    { (L"darkgreen"),             0x1a006400 },
    { (L"darkkhaki"),             0x1bbdb76b },
    { (L"darkmagenta"),           0x1c8b008b },
    { (L"darkolivegreen"),        0x1d556b2f },
    { (L"darkorange"),            0x1eff8c00 },
    { (L"darkorchid"),            0x1f9932cc },
    { (L"darkred"),               0x208b0000 },
    { (L"darksalmon"),            0x21e9967a },
    { (L"darkseagreen"),          0x228fbc8f },
    { (L"darkslateblue"),         0x23483d8b },
    { (L"darkslategray"),         0x242f4f4f },
    { (L"darkturquoise"),         0x2500ced1 },
    { (L"darkviolet"),            0x269400d3 },
    { (L"deeppink"),              0x27ff1493 },
    { (L"deepskyblue"),           0x2800bfff },
    { (L"dimgray"),               0x29696969 },
    { (L"dodgerblue"),            0x2a1e90ff },
    { (L"firebrick"),             0x2bb22222 },
    { (L"floralwhite"),           0x2cfffaf0 },
    { (L"forestgreen"),           0x2d228b22 },
    { (L"fuchsia"),               0x2eff00ff },
    { (L"gainsboro"),             0x2fdcdcdc },
    { (L"ghostwhite"),            0x30f8f8ff },
    { (L"gold"),                  0x31ffd700 },
    { (L"goldenrod"),             0x32daa520 },
    { (L"gray"),                  0x33808080 },
    { (L"green"),                 0x34008000 },
    { (L"greenyellow"),           0x35adff2f },
    { (L"honeydew"),              0x36f0fff0 },
    { (L"hotpink"),               0x37ff69b4 },
    { (L"indianred"),             0x38cd5c5c },
    { (L"indigo"),                0x394b0082 },
    { (L"ivory"),                 0x3afffff0 },
    { (L"khaki"),                 0x3bf0e68c },
    { (L"lavender"),              0x3ce6e6fa },
    { (L"lavenderblush"),         0x3dfff0f5 },
    { (L"lawngreen"),             0x3e7cfc00 },
    { (L"lemonchiffon"),          0x3ffffacd },
    { (L"lightblue"),             0x40add8e6 },
    { (L"lightcoral"),            0x41f08080 },
    { (L"lightcyan"),             0x42e0ffff },
    { (L"lightgoldenrodyellow"),  0x43fafad2 },
    { (L"lightgreen"),            0x4490ee90 },
    { (L"lightgrey"),             0x45d3d3d3 },
    { (L"lightpink"),             0x46ffb6c1 },
    { (L"lightsalmon"),           0x47ffa07a },
    { (L"lightseagreen"),         0x4820b2aa },
    { (L"lightskyblue"),          0x4987cefa },
    { (L"lightslategray"),        0x4a778899 },
    { (L"lightsteelblue"),        0x4bb0c4de },
    { (L"lightyellow"),           0x4cffffe0 },
    { (L"lime"),                  0x4d00ff00 },
    { (L"limegreen"),             0x4e32cd32 },
    { (L"linen"),                 0x4ffaf0e6 },
    { (L"magenta"),               0x50ff00ff },
    { (L"maroon"),                0x51800000 },
    { (L"mediumaquamarine"),      0x5266cdaa },
    { (L"mediumblue"),            0x530000cd },
    { (L"mediumorchid"),          0x54ba55d3 },
    { (L"mediumpurple"),          0x559370db },
    { (L"mediumseagreen"),        0x563cb371 },
    { (L"mediumslateblue"),       0x577b68ee },
    { (L"mediumspringgreen"),     0x5800fa9a },
    { (L"mediumturquoise"),       0x5948d1cc },
    { (L"mediumvioletred"),       0x5ac71585 },
    { (L"midnightblue"),          0x5b191970 },
    { (L"mintcream"),             0x5cf5fffa },
    { (L"mistyrose"),             0x5dffe4e1 },
    { (L"moccasin"),              0x5effe4b5 },
    { (L"navajowhite"),           0x5fffdead },
    { (L"navy"),                  0x60000080 },
    { (L"oldlace"),               0x61fdf5e6 },
    { (L"olive"),                 0x62808000 },
    { (L"olivedrab"),             0x636b8e23 },
    { (L"orange"),                0x64ffa500 },
    { (L"orangered"),             0x65ff4500 },
    { (L"orchid"),                0x66da70d6 },
    { (L"palegoldenrod"),         0x67eee8aa },
    { (L"palegreen"),             0x6898fb98 },
    { (L"paleturquoise"),         0x69afeeee },
    { (L"palevioletred"),         0x6adb7093 },
    { (L"papayawhip"),            0x6bffefd5 },
    { (L"peachpuff"),             0x6cffdab9 },
    { (L"peru"),                  0x6dcd853f },
    { (L"pink"),                  0x6effc0cb },
    { (L"plum"),                  0x6fdda0dd },
    { (L"powderblue"),            0x70b0e0e6 },
    { (L"purple"),                0x71800080 },
    { (L"red"),                   0x72ff0000 },
    { (L"rosybrown"),             0x73bc8f8f },
    { (L"royalblue"),             0x744169e1 },
    { (L"saddlebrown"),           0x758b4513 },
    { (L"salmon"),                0x76fa8072 },
    { (L"sandybrown"),            0x77f4a460 },
    { (L"seagreen"),              0x782e8b57 },
    { (L"seashell"),              0x79fff5ee },
    { (L"sienna"),                0x7aa0522d },
    { (L"silver"),                0x7bc0c0c0 },
    { (L"skyblue"),               0x7c87ceeb },
    { (L"slateblue"),             0x7d6a5acd },
    { (L"slategray"),             0x7e708090 },
    { (L"snow"),                  0x7ffffafa },
    { (L"springgreen"),           0x8000ff7f },
    { (L"steelblue"),             0x814682b4 },
    { (L"tan"),                   0x82d2b48c },
    { (L"teal"),                  0x83008080 },
    { (L"thistle"),               0x84d8bfd8 },
    { (L"tomato"),                0x85ff6347 },
    { (L"turquoise"),             0x8640e0d0 },
    { (L"violet"),                0x87ee82ee },
    { (L"wheat"),                 0x88f5deb3 },
    { (L"white"),                 0x89ffffff },
    { (L"whitesmoke"),            0x8af5f5f5 },
    { (L"yellow"),                0x8bffff00 },
    { (L"yellowgreen"),           0x8c9acd32 }

}; // rgColorNames[]

#define SIZE_OF_COLOR_TABLE (sizeof(rgColorNames) / sizeof(COLORVALUE_PAIR))
#define PROPERTY_INVALIDCOLOR 0x99999999

//*****************************************************************************

static int
CompareColorValuePairsByName(const void *pv1, const void *pv2)
{
    return _wcsicmp(((COLORVALUE_PAIR*)pv1)->wzName,
                    ((COLORVALUE_PAIR*)pv2)->wzName);
} // CompareColorValuePairsByName

//*****************************************************************************

HRESULT CUtils::InsurePropertyVariantAsFloat(VARIANT *varFloat)
{
    // If the variant is empty or null, then the code below will
    // convert it to the float 0, but we will consider this to be
    // invalid, and only want to convert objects of substance
    if (varFloat->vt == VT_NULL || varFloat->vt == VT_EMPTY)
    {
        return E_INVALIDARG;
    }
    if (varFloat->vt != VT_R4)
    {
        VARIANT var;
        VariantInit(&var);
        HRESULT hr = VariantChangeTypeEx(&var, 
                                       varFloat,
                                       LCID_SCRIPTING,
                                       VARIANT_NOUSEROVERRIDE,
                                       VT_R4);
        if (FAILED(hr))
        {
            DPF_ERR("Error changing variant type to float in GetFloatFromVariant");
            return hr;
        }
        hr = VariantCopy(varFloat, &var);
        VariantClear(&var);
        if (FAILED(hr))
        {
            DPF_ERR("Error copying variant in GetFloatFromVariant");
            return hr;
        }
    }
    return S_OK;
} // GetFloatFromVariant

//*****************************************************************************

DWORD CUtils::GetColorFromVariant(VARIANT *varColor)
{


    DWORD dwRet;
    
    if (0 == lstrlenW(varColor->bstrVal))
        return PROPERTY_INVALIDCOLOR;

    // first check if this string is possibly a color by name
    // by checking the first character for '#'
    if (varColor->bstrVal[0] != L'#')
    {
        // check if it is a string named color
        COLORVALUE_PAIR ColorName;
        ColorName.wzName = varColor->bstrVal;

        COLORVALUE_PAIR * pColorPair = (COLORVALUE_PAIR*)bsearch(&ColorName,
                                              rgColorNames,
                                              SIZE_OF_COLOR_TABLE,
                                              sizeof(COLORVALUE_PAIR),
                                              CompareColorValuePairsByName);
        if (NULL == pColorPair)
            return PROPERTY_INVALIDCOLOR;
        else
            return pColorPair->dwValue;
    }
    if (lstrlenW(varColor->bstrVal) != 7)
        return PROPERTY_INVALIDCOLOR;
    dwRet = 0;
    for (int i = 1; i < 7; i++)
    {
        // shift dwRet by 4
        dwRet <<= 4;
        // and add in the value of this string
        switch (varColor->bstrVal[i])
        {
        case '0':
            dwRet +=  0;
            break;
        case '1':
            dwRet +=  1;
            break;
        case '2':
            dwRet +=  2;
            break;
        case '3':
            dwRet +=  3;
            break;
        case '4':
            dwRet +=  4;
            break;
        case '5':
            dwRet +=  5;
            break;
        case '6':
            dwRet +=  6;
            break;
        case '7':
            dwRet +=  7;
            break;
        case '8':
            dwRet +=  8;
            break;
        case '9':
            dwRet +=  9;
            break;
        case 'a':
        case 'A':
            dwRet += 10;
            break;
        case 'b':
        case 'B':
            dwRet += 11;
            break;
        case 'c':
        case 'C':
            dwRet += 12;
            break;
        case 'd':
        case 'D':
            dwRet += 13;
            break;
        case 'e':
        case 'E':
            dwRet += 14;
            break;
        case 'f':
        case 'F':
            dwRet += 15;
            break;
        default:
            return PROPERTY_INVALIDCOLOR;
        }
    }
    return dwRet;
} // GetColorFromVariant

//*****************************************************************************
// The reason this function exists is to work around a compiler bug
// where the compare in the function below was failing when it should
// have been working.  This would fail if the floating point value
// was on the stack and not stored in a variable.  This forces it to be
// in a variable correctly.
//*****************************************************************************
bool 
CUtils::CompareForEqualFloat(float flComp1, float flComp2)
{
    return (flComp1 == flComp2);
} // CompareForEqual

//*****************************************************************************

void CUtils::GetHSLValue(DWORD dwInputColor, 
						 float *pflHue, 
						 float *pflSaturation, 
						 float *pflLightness)
{

	float flRed, flGreen, flBlue;

	flRed = ((float)((dwInputColor & 0x00FF0000) >> 16)) / 255.0f;
	flGreen = ((float)((dwInputColor & 0x0000FF00) >> 8)) / 255.0f;
	flBlue =  ((float)(dwInputColor & 0x000000FF)) / 255.0f;

    float flMin, flMax;

    if (flRed > flGreen && flRed > flBlue)
    {
        flMax = flRed;
        if (flGreen < flBlue)
            flMin = flGreen;
        else
            flMin = flBlue;
    }
    else if (flGreen > flBlue)
    {
        flMax = flGreen;
        if (flRed < flBlue)
            flMin = flRed;
        else
            flMin = flBlue;
    }
    else
    {
        flMax = flBlue;
        if (flGreen < flRed)
            flMin = flGreen;
        else
            flMin = flRed;
    }

    *pflLightness = (flMax + flMin) / 2;

    if ( CompareForEqualFloat(flMin, flMax) )
    {
        *pflSaturation = 0;
        *pflHue = 0;
    }
    else
    {
        if (*pflLightness <= 0.5f)
            *pflSaturation = (flMax - flMin) / (flMax + flMin);
        else
            *pflSaturation = (flMax - flMin) / (2 - flMax - flMin);

        if (CompareForEqualFloat(flRed, flMax))
        {
            if ( CompareForEqualFloat( flBlue, flMin ) )
                *pflHue = 1 + (flGreen - flRed) / (flMax - flMin);
            else
                *pflHue = 5 + (flRed - flBlue) / (flMax - flMin);
        }
        else if (CompareForEqualFloat(flGreen, flMax))
        {
            if ( CompareForEqualFloat( flRed, flMin ) )
                *pflHue = 3 + (flBlue - flGreen) / (flMax - flMin);
            else
                *pflHue = 1 + (flGreen - flRed) / (flMax - flMin);
        }
        else
        {
            if ( CompareForEqualFloat( flGreen, flMin ) )
                *pflHue = 5 + (flRed - flBlue) / (flMax - flMin);
            else
                *pflHue = 3 + (flBlue - flGreen) / (flMax - flMin);
        }

        *pflHue /= 6;
    }
} // GetHSLValue

//*****************************************************************************

HRESULT 
CUtils::GetVectorFromVariant(VARIANT *varVector,
                             int *piFloatsReturned, 
                             float *pflX, 
                             float *pflY, 
                             float *pflZ)
{

    DASSERT(varVector != NULL);
    DASSERT(piFloatsReturned != NULL);
    *piFloatsReturned = 0;

    HRESULT hr;
    hr = InsurePropertyVariantAsBSTR(varVector);
    if (FAILED(hr))
    {
        DPF_ERR("Error in parsing vector, variant is not a string");
        return hr;
    }
    LPWSTR pwzVector = varVector->bstrVal;
    DASSERT(pwzVector != NULL);
    
    if (pflX != NULL)
    {
        hr = ParseFloatValueFromString(&pwzVector, pflX);
        if (FAILED(hr))
        {
            DPF_ERR("error parsing X value from bstr in GetVectorFromVariant");
            return hr;
        }
        if (hr == S_OK)
            (*piFloatsReturned)++;
    }
    if (pflY != NULL && hr == S_OK)
    {
        hr = ParseFloatValueFromString(&pwzVector, pflY);
        if (FAILED(hr))
        {
            DPF_ERR("error parsing Y value from bstr in GetVectorFromVariant");
            return hr;
        }
        if (hr == S_OK)
            (*piFloatsReturned)++;
    }
    if (pflZ != NULL && hr == S_OK)
    {
        hr = ParseFloatValueFromString(&pwzVector, pflZ);
        if (FAILED(hr))
        {
            DPF_ERR("error parsing Z value from bstr in GetVectorFromVariant");
            return hr;
        }
        if (hr == S_OK)
            (*piFloatsReturned)++;
    }
    return S_OK;
} // GetVectorFromVariant

//*****************************************************************************

HRESULT CUtils::ParseFloatValueFromString(LPWSTR *ppwzFloatString, float *pflRet)
{
    DASSERT(ppwzFloatString);
    DASSERT(pflRet);

    SkipWhiteSpace(ppwzFloatString);

    // the following will look for the first null
    // char or first white space char, or first ',' 
    LPWSTR pwzDelimiter = *ppwzFloatString;
    while (*pwzDelimiter != L'\0' && !iswspace(*pwzDelimiter) && *pwzDelimiter != L',')
        pwzDelimiter++;
    // we need to save the character and replace it with 0
    WCHAR wcSave = *pwzDelimiter;
    *pwzDelimiter = L'\0';
    // we will scan for a float and the character following it
    // Getting the character following this insures there are no
    // non-digit characters other than our delimiter or whitespace
    WCHAR wcCheckNextChar = L'\0';
    int ret = swscanf(*ppwzFloatString, L"%f%C", pflRet, &wcCheckNextChar);
    *pwzDelimiter = wcSave;
    if (!iswspace(wcCheckNextChar) && wcCheckNextChar != L'\0')
    {
        DPF_ERR("Error in string, invalid chars");
        return E_INVALIDARG;
    }
    if (ret != 1)
    {
        return S_FALSE;
    }
    *ppwzFloatString = pwzDelimiter;
    return S_OK;

} // ParseFloatValueFromString

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\chrome\src\set.cpp ===
//*****************************************************************************
//
// File:    setbvr.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CSetBvr object which implements
//			 the chromeffects Set DHTML behavior
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/16/98 jeffort     Added animates property
// 10/16/98 jeffort     Renamed functions
// 11/20/98 markhal     Converted to use actor
//*****************************************************************************

#include "headers.h"

#include "set.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CSetBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_VALUE        0
#define VAR_PROPERTY     1
#define VAR_TYPE         2

WCHAR * CSetBvr::m_rgPropNames[] = {
                                   BEHAVIOR_PROPERTY_VALUE,
                                   BEHAVIOR_PROPERTY_PROPERTY,
                                   BEHAVIOR_PROPERTY_TYPE
                                   };

//*****************************************************************************

CSetBvr::CSetBvr() 
{
    VariantInit(&m_varValue);
    VariantInit(&m_varProperty);
    VariantInit(&m_varType);
    m_clsid = CLSID_CrSetBvr;
    m_lCookie = 0;
    m_pdispActor = NULL;
} // CSetBvr

//*****************************************************************************

CSetBvr::~CSetBvr()
{
    VariantClear(&m_varValue);
    VariantClear(&m_varProperty);
    VariantClear(&m_varType);

	ReleaseInterface( m_pdispActor );
} // ~SetBvr

//*****************************************************************************

HRESULT CSetBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in set behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CSetBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_SET_PROPS);
    switch (iIndex)
    {
    case VAR_VALUE:
        return &m_varValue;
        break;
    case VAR_PROPERTY:
        return &m_varProperty;
        break;
    case VAR_TYPE:
        return &m_varType;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CSetBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_SET_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CSetBvr::Init(IElementBehaviorSite *pBehaviorSite)
{

	HRESULT hr = SUPER::Init(pBehaviorSite);
	CheckHR( hr, "Init of base class failed", end );

end:

	return hr;
} // Init

//*****************************************************************************

STDMETHODIMP 
CSetBvr::Notify(LONG event, VARIANT *pVar)
{	
	
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;
} // Notify

//*****************************************************************************

STDMETHODIMP
CSetBvr::Detach()
{
    //we have to remove our behavior from the actor

    LMTRACE( L"Detaching Set Behavior <%p>\n", this );

    HRESULT hr = S_OK;
    
    hr = SUPER::Detach();
    CheckHR( hr, "Failed in super.detach for set", end );

	//we have a behavior in the actor.  Remove it.
    if( m_pdispActor != NULL && m_lCookie != 0 )
    {
    	hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
    	CheckHR( hr, "Failed to remove the behavior from the actor", end );

    	m_lCookie = 0;
    }

    ReleaseInterface( m_pdispActor );

    LMTRACE( L"End Detach set <%p>\n", this );

end:
    return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CSetBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CSetBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CSetBvr::put_value(VARIANT varValue)
{
    HRESULT hr = VariantCopy(&m_varValue, &varValue);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting value for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    return NotifyPropertyChanged(DISPID_ICRSETBVR_VALUE);
} // put_value

//*****************************************************************************

STDMETHODIMP
CSetBvr::get_value(VARIANT *pRetValue)
{
    if (pRetValue == NULL)
    {
        DPF_ERR("Error in CSetBvr:get_value, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetValue, &m_varValue);
} // get_value

//*****************************************************************************

STDMETHODIMP 
CSetBvr::put_property(VARIANT varProperty)
{
    HRESULT hr = VariantCopy(&m_varProperty, &varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting property for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    return NotifyPropertyChanged(DISPID_ICRSETBVR_PROPERTY);
} // put_property

//*****************************************************************************

STDMETHODIMP 
CSetBvr::get_property(VARIANT *pRetProperty)
{
    if (pRetProperty == NULL)
    {
        DPF_ERR("Error in CSetBvr:get_property, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetProperty, &m_varProperty);
} // get_property

//*****************************************************************************

STDMETHODIMP 
CSetBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting Type for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    return NotifyPropertyChanged(DISPID_ICRSETBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP 
CSetBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in CSetBvr:get_type, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

HRESULT 
CSetBvr::BuildAnimationAsDABehavior()
{
	// TODO (markhal): This will go away when all behaviors have been converted
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CSetBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
    HRESULT hr;

    //make sure that any behaviors we have added to the actor have been removed
    if( m_lCookie != 0 )
    {
        //detach the behavior from the actor
        hr = RemoveBehaviorFromActor( m_lCookie );
        if( FAILED( hr ) )
        {
            DPF_ERR("Failed to remove the previous behavior was removed from the actor");
            return hr;
        }
        m_lCookie = 0;
    }

    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error, property attribute for set behavior not set");
        return SetErrorInfo(E_INVALIDARG);
    }

    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varValue);
    if (FAILED(hr))
    {
        DPF_ERR("Error, value attribute for set behavior not set");
        return SetErrorInfo(E_INVALIDARG);
    }

    IDABehavior *pbvrBehavior = NULL;
    ActorBvrType eType = e_String;

    if (VT_EMPTY != m_varType.vt && SUCCEEDED(CUtils::InsurePropertyVariantAsBSTR(&m_varType) ) )
    {
        if (0 == _wcsicmp(V_BSTR(&m_varType), BEHAVIOR_TYPE_COLOR))
        {
            IDAColor *pbvrColor;
            hr = ExtractColor(m_varValue, &pbvrColor);
            if (FAILED(hr))
                return hr;

            eType = e_Color;
            pbvrBehavior = pbvrColor;           
        }
        else if (0 == _wcsicmp(V_BSTR(&m_varType), BEHAVIOR_TYPE_NUMBER))
        {
            IDANumber *pbvrNumber;
            hr = ExtractNumber(m_varValue, &pbvrNumber);
            if (FAILED(hr))
                return hr;

            eType = e_Number;
            pbvrBehavior = pbvrNumber;            
        }        
    }
    else
    {
        IDAColor *pbvrColor;
        IDANumber *pbvrNumber;
        // try for a color
        if (SUCCEEDED(ExtractColor(m_varValue, &pbvrColor)))
        {
            eType = e_Color;
            pbvrBehavior = pbvrColor;
        }
        // try for a number
        else if (SUCCEEDED(ExtractNumber(m_varValue, &pbvrNumber)))
        {
            eType = e_Number;
            pbvrBehavior = pbvrNumber;
        }
    }

    if (NULL == pbvrBehavior)
    {
        // build the string we need
        IDAString *pbvrString = NULL;
        
        hr = CDAUtils::GetDAString(GetDAStatics(), 
                                   m_varValue.bstrVal, 
                                   &pbvrString);
        if (FAILED(hr))
        {
            DPF_ERR("Error building DA string for value property");
            return SetErrorInfo(hr);
        }
        eType = e_String;
        pbvrBehavior = pbvrString;
    }

    IDispatch *pdispElem = NULL;

    hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispElem ) );
    if( FAILED(hr) )
    {
        DPF_ERR("Failed to QI the behavior element for IDispatch" );
        return hr;
    }

	hr = AttachBehaviorToActorEx( pActorDisp,
								  pbvrBehavior,
								  V_BSTR(&m_varProperty),
								  e_Absolute,
								  eType,
                                  pdispElem,
                                  &m_lCookie);

	ReleaseInterface(pbvrBehavior);

	ReleaseInterface( pdispElem );

	if (FAILED(hr))
	{
		DPF_ERR("Failed to attach behavior to actor");
		return SetErrorInfo(hr);
	}

	//stash the actor so we can remove our behaviors
	// later.
	m_pdispActor = pActorDisp;
	m_pdispActor->AddRef();

	
    return S_OK;
} //buildBehaviorFragments

//*****************************************************************************

HRESULT
CSetBvr::ExtractColor(VARIANT varValue, IDAColor **ppbvrColor)
{
    HRESULT hr;

    *ppbvrColor = NULL;
    DWORD dwColor = CUtils::GetColorFromVariant(&m_varValue);
    if (PROPERTY_INVALIDCOLOR == dwColor)
    {
        DPF_ERR("CSetBvr::ExtractColor exiting, GetColorFromVariant failed!");
        return E_INVALIDARG;
    }

    hr = CDAUtils::BuildDAColorFromRGB(GetDAStatics(), dwColor, ppbvrColor);
    if (FAILED(hr))
    {
        DPF_ERR("CSetBvr::ExtractColor exiting, BuildDAColorFromStaticHSL failed!");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
}

//*****************************************************************************

HRESULT
CSetBvr::ExtractNumber(VARIANT varValue, IDANumber **ppbvrNumber)
{
    HRESULT hr;
    *ppbvrNumber = NULL;

    int cChars = SysStringLen(V_BSTR(&varValue));
    if (cChars == 0)
        return E_INVALIDARG;
    
    WCHAR * pchEnd = NULL;
    double dValue = wcstod(V_BSTR(&varValue), &pchEnd);
    if (pchEnd != (V_BSTR(&varValue) + cChars))
    {
        DPF_ERR("CSetBvr::ExtractNumber exiting, wcstod found non-float characters!");
        return E_INVALIDARG;
    }
    
    hr = CDAUtils::GetDANumber(GetDAStatics(), (float) dValue, ppbvrNumber);
    if (FAILED(hr))
    {
        DPF_ERR("CSetBvr::ExtractNumber exiting, GetDANumber failed!");
        return SetErrorInfo(hr);
    }

    return S_OK;
}


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\control\engine.h ===
#ifndef __ENGINE_H_
#define __ENGINE_H_

#include "resource.h"       // main symbols

#include "..\behaviors\headers.h"
#include "wtypes.h"
#include "danim.h"
#include "lmrt.h"
#include <wininet.h>
#include <docobj.h>
//#include <ocidl.h>
#include <control.h>
#include <strmif.h>


extern HINSTANCE hInst;

// The initial size for the stacks and temporary store
const static int INITIAL_SIZE = 100;

// The number of VAR_ARGS
const static int MAX_VAR_ARGS = 10;

// Engine status constants, based on HRESULT codes

// Engine should continue processing next instruction
static long STATUS_CONTINUE = S_OK;

// Engine found an unimplemented instruction
static long STATUS_UNIMPLEMENTED = 0xE0000001;

// Engine found an unsupported instruction
static long STATUS_UNSUPPORTED = 0xE0000002;

// Engine found an unknown instruction
static long STATUS_UNKNOWN = 0xE0000003;

// Engine encountered an error
static long STATUS_ERROR = 0xE0000004;

// Engine finished running the command stream
static long STATUS_FINISHED = 0x20000003;

static long STATUS_NODATA = 0xE0000005;

static long DEFAULT_ASYNC_BLKSIZE = 10000;

static ULONG EVENT_RESOLUTION = 25;

static ULONG DEFAULT_ASYNC_DELAY = 50;

static WCHAR* LMRT_EVENT_PREFIX = L"LMRT";
static ULONG LMRT_EVENT_PREFIX_LENGTH = 4;

class CLMReader;

class CLMNotifier;

class CLMExportTable;

class ByteArrayStream;

#define WORKERHWND_CLASS "LMEngineWorkerPrivateHwndClass"

#define WM_LMENGINE_TIMER_CALLBACK	(WM_USER + 1000)
#define WM_LMENGINE_DATA			(WM_USER + 2000)
#define WM_LMENGINE_SCRIPT_CALLBACK	(WM_USER + 3000)

class CLMEngineInstrData
{
public:
	BOOLEAN			pending;
	ByteArrayStream	*byteArrayStream;
};

class CLMEngineScriptData
{
public:
	BSTR scriptSourceToInvoke;
	BSTR scriptLanguage;
	IDAEvent	*event;
	IDABehavior	*eventData;
};

class ATL_NO_VTABLE CLMEngineWrapper:
	public CComObjectRootEx<CComMultiThreadModel>,
	public ILMEngineWrapper
{
public:
	CLMEngineWrapper();
	~CLMEngineWrapper();

BEGIN_COM_MAP(CLMEngineWrapper)
	COM_INTERFACE_ENTRY(ILMEngineWrapper)
END_COM_MAP()

	STDMETHOD(GetWrapped)(IUnknown **ppWrapped);
	STDMETHOD(SetWrapped)(IUnknown *pWrapped);
	STDMETHOD(Invalidate)();

private:
	IUnknown *m_pWrapped;
	bool m_bValid;
};


// Provides an abstraction of a stream of instruction codes
// Subclasses will implement synchronous, asynchronous, and callback specifics
class CodeStream
{
public:
	// Mark the stream for potential rewind
	STDMETHOD (Commit)() = 0;
	
	// Revert the stream to the last commit
	STDMETHOD (Revert)() = 0;

	// Reads a byte from the instruction stream.  Returns -1 on EOF,
	// which is why it returns a short, not a BYTE
	STDMETHOD(readByte)(BYTE *pByte) = 0;

	// Reads count BYTES into the given buffer.  Returns -1 if reaches EOF
	// before being done
	STDMETHOD(readBytes)(BYTE *pByte, ULONG count, ULONG *pNumRead) = 0;
	
	//ensure that the blocksize used by this code stream is at least blockSize
	STDMETHOD(ensureBlockSize)(ULONG blockSize) = 0;

	virtual ~CodeStream() {};
};

class ATL_NO_VTABLE CLMEngine : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CLMEngine, &CLSID_LMEngine>,
	public IDispatchImpl<ILMEngine2, &IID_ILMEngine2, &LIBID_LiquidMotion>,
    public IObjectSafetyImpl<CLMEngine>,
	public IBindStatusCallbackImpl<CLMEngine>,
	public ILMCodecDownload,
	public ILMEngineExecute
{
public:
	CLMEngine();
	~CLMEngine();

DECLARE_REGISTRY(CLSID_LMEngine,
                 "LiquidMotion" ".LMEngine.1",
                 "LiquidMotion" ".LMEngine",
                 0,
                 THREADFLAGS_BOTH);

BEGIN_COM_MAP(CLMEngine)
	COM_INTERFACE_ENTRY(ILMEngine2)
    COM_INTERFACE_ENTRY(ILMEngine)
    COM_INTERFACE_ENTRY(IDispatch)
//    COM_INTERFACE_ENTRY_IID(__uuidof(ILMStartStop), ILMStartStop)
    COM_INTERFACE_ENTRY(ILMCodecDownload)
	COM_INTERFACE_ENTRY(ILMEngineExecute)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IBindStatusCallback)
END_COM_MAP()

	STDMETHOD(runFromStream)(/*[in]*/ LPSTREAM pStream);
	STDMETHOD(runFromURL)(/*[in]*/ BSTR url);
	STDMETHOD(initFromBytes)(BYTE *array, ULONG size);
	STDMETHOD(initAsync)();
	STDMETHOD(put_ClientSite)(/*[in]*/ IOleClientSite *clientSite);
    STDMETHOD(get_Image)(/*[out, retval]*/ IDAImage **pVal);
    STDMETHOD(get_Sound)(/*[out, retval]*/ IDASound **pVal);
	STDMETHOD(put_Reader)(/*[in]*/ ILMReader *reader);
	STDMETHOD(SetStatusText)(BSTR text);
	STDMETHOD(Notify)(IDABehavior *eventData,
					  IDABehavior *curRunningBvr,
					  IDAView *curView,
					  IDABehavior **ppBvr);
	STDMETHOD(GetBehavior)(/*[in, string]*/ BSTR tag,
						   /*[in]*/ IDABehavior *pIDefaultBvr,
						   /*[out, retval]*/ IDABehavior **pVal);
	STDMETHOD(ExecuteFromAsync)();
	STDMETHOD(SetAsyncBlkSize)(LONG blkSize);
	STDMETHOD(SetAsyncDelay)(LONG delay);

	static void CALLBACK TimerCallback(
						     UINT wTimerID,
                             UINT msg,
                             DWORD_PTR dwordUser,
                             DWORD_PTR unused1,
                             DWORD_PTR unused2);
	static LRESULT  CALLBACK WorkerWndProc(HWND hwnd,
										   UINT msg,
										   WPARAM wParam,
										   LPARAM lParam);

// IObjectSafetyImpl
	STDMETHOD(SetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid,
							/* [in] */ DWORD dwOptionSetMask,
							/* [in] */ DWORD dwEnabledOptions);
	STDMETHOD(GetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid, 
							/* [out] */DWORD *pdwSupportedOptions, 
							/* [out] */DWORD *pdwEnabledOptions);

// IBindStatusCallbackImpl
	STDMETHOD(OnDataAvailable)(
		/* [in] */ DWORD grfBSCF, 
		/* [in] */ DWORD dwSize,
		/* [in] */ FORMATETC *pfmtetc, 
		/* [in] */ STGMEDIUM * pstgmed);

	STDMETHOD(OnMemDataAvailable)(BOOLEAN lastBlock, 
								  DWORD blockSize,
							      BYTE *block);

	STDMETHOD(OnStopBinding)(/* [in] */HRESULT hrStatus, /*[in, string]*/ LPCWSTR szStatusText);
	STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding);
	STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo);

	STDMETHOD(releaseFilterGraph)();
	STDMETHOD(releaseAllFilterGraph)();

    STDMETHODIMP Start(LONGLONG rtNow);
    STDMETHODIMP Stop();
    STDMETHODIMP SetMediaCacheDir(WCHAR *wszM); 

	STDMETHOD(disableAutoAntialias)();

	STDMETHOD(ensureBlockSize)(ULONG blockSize);
    
	STDMETHOD(getExecuteFromUnknown)( IUnknown *pUnk, ILMEngineExecute **ppExecute );
	STDMETHOD(getEngine2FromUnknown)( IUnknown *pUnk, ILMEngine2 **ppEngine2 );
	STDMETHOD(getIDispatchOnHost)( IDispatch **ppHostDisp );

	/**
	*  ILMCodecDownload
	*/
	STDMETHOD(setAutoCodecDownloadEnabled)(BOOL bEnabled);

	/**
	*  ILMEngineExecute
	*/
	STDMETHOD (ExportBehavior)(BSTR key, IDABehavior *toExport);
	STDMETHOD (SetImage)(IDAImage *pImage);
	STDMETHOD (SetSound)(IDASound *pSound);

protected:

	ILMEngineWrapper *m_pWrapper;
	// The image that will be set by Engine.setImage and
	// returned after executing the instruction stream
	IDAImage *m_pImage;

	// The sound that will be set by Engine.setSound and
	// returned after executing the instruction stream
	IDASound *m_pSound;

	// The IDAStatics object used to make Statics calls
	IDAStatics *staticStatics;

	// The LMReader control 
	ILMReader2 *m_pReader;

	// Export behavior table
	CLMExportTable	*m_exportTable;

	// A CodeStream from which the instructions are being read
	CodeStream *codeStream;

	// Called to validate the header
	HRESULT validateHeader();

	// Called to execute instructions from the current
	// instruction stream
	HRESULT execute();
	
	// Reads a LONG from the instruction stream.  Does NOT return -1 on EOF
	STDMETHOD(readLong)(LPLONG pLong);

	// Reads a SIGNED LONG from the instruction stream.  Does NOT return -1 on EOF
	STDMETHOD(readSignedLong)(LPLONG pLong);

	// Reads a float from the instruction stream
	STDMETHOD(readFloat)(PFLOAT pFloat);

	// Reads a double from the instruction stream
	STDMETHOD(readDouble)(double *pDouble);

	// Stack of LONGS
	LONG *longStack;
	LONG *longTop;
	LONG longStackSize;

	// Stack of doubles
	double *doubleStack;
	double *doubleTop;
	int doubleStackSize;

	// Array of doubles
	double *doubleArray;
	long doubleArrayLen;
	long doubleArrayCap;

	// Stack of strings
	BSTR *stringStack;
	BSTR *stringTop;
	int stringStackSize;

	// Stack of COM objects
	IUnknown **comStack;
	IUnknown **comTop;
	int comStackSize;

	// Stack of arrays of COM objects
	IUnknown ***comArrayStack;
	IUnknown ***comArrayTop;
	// Stack of array lengths
	LONG *comArrayLenStack;
	LONG *comArrayLenTop;
	int comArrayStackSize;

	// Array of temporary COM objects, accessed through the
	// copy to temp and copy from temp instructions.  Stores
	// reused COM values.  Other values cannot be reused.
	IUnknown **comStore;
	int comStoreSize;

	// Array for var args
	VARIANTARG varArgs[MAX_VAR_ARGS];
	VARIANTARG varArgReturn;
	int nextVarArg;

	// Release var args
	HRESULT releaseVarArgs();

	//The appTriggeredEvent that will be triggered when we get a stop()
	IDAEvent *m_pStopEvent;

	//The appTriggeredEvent that will be triggered when we get a start()
	IDAEvent *m_pStartEvent;

	STDMETHOD(SetStartEvent)(IDAEvent *pNewStartEvent, BOOL bOverwrite);
	STDMETHOD(SetStopEvent)(IDAEvent *pNewStopEvent, BOOL bOverwrite);

	//The pointer the parent of this engine. Only set if this engine is
	//  running a notifier.
	ILMEngine2 *m_pParentEngine;

	STDMETHOD(setParentEngine)(ILMEngine2 *parent);
	STDMETHOD(clearParentEngine)();

	//gets the current time from the filter graph that is driving this engine,
	// or the parent engine if this engine is running a notifier.
	// returns -1 if this engine is not streaming
	STDMETHOD(getCurrentGraphTime)(double *pGraphTime);

	//A pointer to the IMediaPosition on the current filter graph, if there
	// is one.
	IMediaPosition* m_pMediaPosition;

	//A pointer to the IMediaEventSink on the current filter graph, if there
	// is one
	IMediaEventSink* m_pMediaEventSink;

	//get the Pointer to the IMediaPosition on the current FilterGraph.
	STDMETHOD(getIMediaPosition)(IMediaPosition **ppMediaPosition);

	//get the Pointer to the IMediaEventSink on the current FilterGraph.
	STDMETHOD(getIMediaEventSink)(IMediaEventSink **ppMediaEventSink);

	double parseDoubleFromVersionString( BSTR version );
	double getDAVersionAsDouble();
	double getLMRTVersionAsDouble();

	bool m_bEnableAutoAntialias;

	BOOL m_bAutoCodecDownloadEnabled;

	// Flag indicating whether or not header has been read
	BOOL	m_bHeaderRead;

	ULONG	m_PrevRead;

	CComPtr<IBindStatusCallback>	m_pIbsc;
	CComPtr<IBinding>				m_spBinding;

    CComPtr<IMediaControl> m_pmc; // activemovie graph
#ifdef DEBUG
    bool m_fDbgInRenderFile;
#endif

	DWORD	m_millisToUse;
	BOOL	m_bPending;
	ULONG	m_AsyncBlkSize;
	ULONG	m_AsyncDelay;
	MMRESULT m_Timer;

	BOOL	m_bAbort;
	BOOL	m_bMoreToParse;
	HANDLE	m_hDoneEvent;

	// Releases all refs to any remaining COM objects
	void releaseAll();

	// Free a COM array, with zero test
	void freeCOMArray(IUnknown **array, LONG length);

	// Free a COM object, with zero test
	inline void freeCOM(IUnknown *com) {
		if (com != 0)
			com->Release();
	}

	// Ensure that the doubleArray has requested capacity
	HRESULT ensureDoubleArrayCap(long cap);

	STDMETHOD(initNotify)(BYTE *bytes, ULONG count, IDAUntilNotifier **pNotifier);

	// The current notifier
	CLMNotifier *notifier;

        BSTR m_bstrMediaCacheDir;
	IOleClientSite *m_pClientSite;
	
	HWND	m_workerHwnd;

	CRITICAL_SECTION m_CriticalSection;

	STDMETHOD(navigate)(/* [in] */BSTR url, 
						/* [in] */BSTR location,
						/* [in] */BSTR frame, 
						/* [in] */int newWindowFlag);
	STDMETHOD(getDAViewerOnPage)(BSTR tag, IDAViewerControl **pVal);
	STDMETHOD(getElementOnPage)(BSTR tag, IUnknown **pVal);
	STDMETHOD(callScriptOnPage)(/*[in, string]*/BSTR scriptSourceToInvoke,
								/*[in, string]*/BSTR scriptLanguage);
	STDMETHOD(createObject)(BSTR str, IUnknown **ppObj);
	STDMETHOD(invokeDispMethod)(IUnknown *pIUnknown, BSTR method, WORD wFlags, 
					  unsigned int nArgs, VARIANTARG *pV, VARIANT *pRetV);
	STDMETHOD(initVariantArg)(BSTR arg, VARTYPE type, VARIANT *pV);
	STDMETHOD(initVariantArgFromString)(BSTR arg, VARIANT *pV);
	STDMETHOD(initVariantArgFromLong)(long lVal, int type, VARIANT *pV);
	STDMETHOD(initVariantArgFromDouble)(double dbl, int type, VARIANT *pV);
	STDMETHOD(initVariantArgFromIUnknown)(IUnknown *pI, int type, VARIANT *pV);
	STDMETHOD(initVariantArgFromIDispatch)(IDispatch *pI, int type, VARIANT *pV);
	STDMETHOD_(char *, GetURLOfClientSite)(void);
	STDMETHOD(StartTimer)();
	STDMETHOD(InitTimer)();
	STDMETHOD(createMsgWindow)();
	STDMETHOD(TimerCallbackHandler)();
	STDMETHOD(NewDataHandler)(CLMEngineInstrData *d);
	STDMETHOD(AbortExecution)();
	STDMETHOD_(BSTR, ExpandImportPath)(BSTR path);
};

// A CodeStream that reads out of a synchronous stream
class SyncStream : public CodeStream
{
public:
	// Constructs a SyncStream that reads from the given LPSTREAM
	SyncStream(LPSTREAM pStream);

	SyncStream::~SyncStream(void);	// Destructor

	STDMETHOD (Commit)();
	STDMETHOD (Revert)();
	STDMETHOD (readByte)(LPBYTE pByte);
	STDMETHOD (readBytes)(LPBYTE pByte, ULONG count, ULONG *pNumRead);
	STDMETHODIMP ensureBlockSize(ULONG blockSize) 
		{ return S_OK; }

protected:
	// Stream that the instructions are being read from
	LPSTREAM m_pStream;
};

// A CodeStream that reads out of an array of bytes
class ByteArrayStream : public CodeStream
{
public:
	// Constructs a ByteArrayStream that reads from the given array of the given size
	// The array is copied into a local array
	ByteArrayStream(LPBYTE array, ULONG size);
	
	~ByteArrayStream(void);

	STDMETHOD (Commit)();
	STDMETHOD (Revert)();
	bool hasBufferedData();
	STDMETHOD (readByte)(LPBYTE pByte);
	STDMETHOD (readBytes)(LPBYTE pByte, ULONG count, ULONG *pNumRead);
	STDMETHODIMP ensureBlockSize(ULONG blockSize)
		{return S_OK;}
	
	// Reset the stream to start reading at the beginning
	void reset();
	
protected:
	// Array that the bytes are being read from
	BYTE *array;
	
	// The size of the array
	ULONG size;
	
	// Pointer to next byte
	BYTE *next;
	
	// Remaining count
	ULONG remaining;

	// Mark for potential rewind
	BYTE *mark;
};

class ByteArrayStreamQueue
{
public:
	ByteArrayStream			*pBAStream;
	ByteArrayStreamQueue	*next;
};

// A CodeStream that reads out of a list of ByteArrayStreams to handle asynchronous reading from
// a stream with the ability to do mark & revert
class AsyncStream : public CodeStream
{
public:
	// Constructs an AsyncStream that reads from the given LPSTREAM
	AsyncStream(ByteArrayStream *pBAStream, ULONG blkSize);
	
	~AsyncStream(void); // Destructor
	
	STDMETHOD (Commit)();
	STDMETHOD (Revert)();
	bool hasBufferedData();
	STDMETHOD (readByte)(LPBYTE pByte);		
	STDMETHOD (readBytes)(LPBYTE pByte, ULONG count, ULONG *pNumRead);
	STDMETHOD(ensureBlockSize)(ULONG blockSize);
	STDMETHOD (SetPending)(BOOL bFlag);
	STDMETHOD (AddByteArrayStream)(ByteArrayStream *pNewBAStream);
	STDMETHOD (ResetBlockRead)();

protected:
	// Queue of ByteArrayStreams for handling mark & revert
	ByteArrayStreamQueue	*pBAStreamQueue;
	ByteArrayStreamQueue	*pBAStreamQueueTail;
	ByteArrayStreamQueue	*pBAStreamQueueHead;

	BOOL	m_bPendingData;
	ULONG	m_nRead;
	ULONG	m_BlkSize;
};

class CLMNotifier : public IDAUntilNotifier
{
protected:
	long				_cRefs;
	CLMEngine*			m_pEngine;		

public:

	CLMNotifier(CLMEngine *pEngine);
	~CLMNotifier();

	STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)();
	

	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
	STDMETHOD(GetIDsOfNames)(
		REFIID riid, LPOLESTR *rgszNames, UINT cNames,
		LCID lcid, DISPID *rgdispid);
	STDMETHOD(Invoke)(
		DISPID dispidMember, REFIID riid, LCID lcid,
		WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
		EXCEPINFO *pexcepinfo, UINT *puArgErr);
	STDMETHOD(ClearEngine)();
	STDMETHOD(Notify)(IDABehavior *eventData,
						IDABehavior *curRunningBvr,
						IDAView *curView,
						IDABehavior **ppBvr);
};

struct CLMExportList
{
	BSTR			tag;
	IDABehavior		*pBvr;
	CLMExportList	*next;
};

class CLMExportTable
{
protected:
	int				m_nBvrs;
	CLMExportList	*m_exportList;
	CLMExportList	*m_tail;
	IDAStatics		*m_pStatics;

public:
	CLMExportTable(IDAStatics *pStatics);
	~CLMExportTable();

	STDMETHOD (AddBehavior)(BSTR tag, IDABehavior *pBvr);
	STDMETHOD (GetBehavior)(BSTR tag, IDABehavior *pIDefaultBvr, IDABehavior **ppBvr);
};

class URLRelToAbsConverter
{
  public:
	URLRelToAbsConverter(LPSTR baseURL, LPSTR relURL);
	LPSTR GetAbsoluteURL ();
  protected:
    char _url[INTERNET_MAX_URL_LENGTH] ;
} ;

class URLCombineAndCanonicalizeOLESTR
{
  public:
    URLCombineAndCanonicalizeOLESTR(char * base, LPOLESTR path);
    LPSTR GetURL ();
	LPWSTR GetURLWide ();
  protected:
    char _url[INTERNET_MAX_URL_LENGTH] ;
	WCHAR _urlWide[INTERNET_MAX_URL_LENGTH];
} ;


#endif // __ENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\dll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include <..\behaviors\headers.h>
#include "control\lmctrl.h"
#include "..\behaviors\lmfactory.h"
//#include "..\behaviors\avoidfollow.h"
#include "..\behaviors\autoeffect.h"
//#include "..\behaviors\jump.h"
#include "..\chrome\include\resource.h"
#include "..\chrome\src\headers.h"
#include "..\chrome\include\action.h"
#include "..\chrome\include\factory.h"
#include "..\chrome\include\colorbvr.h"
#include "..\chrome\include\rotate.h"
#include "..\chrome\include\scale.h"
#include "..\chrome\include\move.h"
#include "..\chrome\include\path.h"
#include "..\chrome\include\number.h"
#include "..\chrome\include\set.h"
#include "..\chrome\include\actorbvr.h"
#include "..\chrome\include\effect.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_LMReader, CLMReader)
    OBJECT_ENTRY(CLSID_LMEngine, CLMEngine)
    OBJECT_ENTRY(CLSID_LMBehaviorFactory, CLMBehaviorFactory)
//    OBJECT_ENTRY(CLSID_LMAvoidFollowBvr, CAvoidFollowBvr) // punted for V1
    OBJECT_ENTRY(CLSID_LMAutoEffectBvr, CAutoEffectBvr)
//    OBJECT_ENTRY(CLSID_LMJumpBvr, CJumpBvr) //punted for V 1
    OBJECT_ENTRY(CLSID_CrBehaviorFactory, CCrBehaviorFactory)
    OBJECT_ENTRY(CLSID_CrColorBvr, CColorBvr)
    OBJECT_ENTRY(CLSID_CrRotateBvr, CRotateBvr)
    OBJECT_ENTRY(CLSID_CrScaleBvr, CScaleBvr)
    OBJECT_ENTRY(CLSID_CrMoveBvr, CMoveBvr)
    OBJECT_ENTRY(CLSID_CrPathBvr, CPathBvr)
    OBJECT_ENTRY(CLSID_CrNumberBvr, CNumberBvr)
    OBJECT_ENTRY(CLSID_CrSetBvr, CSetBvr)
    OBJECT_ENTRY(CLSID_CrActorBvr, CActorBvr)
    OBJECT_ENTRY(CLSID_CrEffectBvr, CEffectBvr)
	OBJECT_ENTRY(CLSID_CrActionBvr, CActionBvr)
END_OBJECT_MAP()

HINSTANCE  hInst;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        hInst = hInstance;
        DisableThreadLibraryCalls(hInstance);
        _Module.Init(ObjectMap, hInstance);
    }        
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
//#ifdef DEBUGMEM
//		_CrtDumpMemoryLeaks();
//#endif
	
    }
    
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\control\lmctrl.cpp ===
// lmctrl.cpp : Implementation of CLMReader
#include "..\behaviors\headers.h"
#include "lmctrl.h"

#include <winuser.h>
#include <hlink.h>
#include <mshtml.h>
#include <uuids.h> //for dshow uuids
#include <mmreg.h> //for WAVE_FORMAT_MPEGLAYER3

/////////////////////////////////////////////////////////////////////////////
// LMReader

/**
* Constructor
*/

CLMReader::CLMReader()
{
	m_bNoExports = VARIANT_TRUE;
	m_bAsync = VARIANT_FALSE;
	m_Src = NULL;
	m_pEngine = NULL;
	m_AsyncBlkSize = -1;
	m_AsyncDelay = -1;
	engineList = NULL;
    m_bWindowOnly  = 0;
	m_pViewerControl = 0;
	m_clsidDownloaded = GUID_NULL;
	m_bAutoCodecDownloadEnabled = FALSE;
}

/**
* Destructor.
* Releases all the engines created by this reader.
*/
CLMReader::~CLMReader()
{/*
	int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
	tmpFlag |= (_CRTDBG_ALLOC_MEM_DF | _CRTDBG_CHECK_ALWAYS_DF | _CRTDBG_CHECK_CRT_DF);
	_CrtSetDbgFlag(tmpFlag);
	*/

	if (engineList) {
		LMEngineList *item = engineList->next;
		LMEngineList *next;
		
		delete engineList;
		while (item != NULL) {
			next = item->next;
			item->engine->Release();
			delete item;
			item = next;
		}
	}

	// Release the viewer control
	if (m_pViewerControl)
		m_pViewerControl->Release();

	/*
#ifdef DEBUGMEM
	_CrtDumpMemoryLeaks();
#endif
	*/

}

/**
*  Returns true if this reader is running in the standAlone streaming player, and
*  false otherwise.
*/
bool CLMReader::isStandaloneStreaming()
{
	return ( m_pViewerControl != NULL );
}

/**
* Returns the Image from the last Engine created (not counting UntilNotifier engines)
*/   
STDMETHODIMP CLMReader::get_Image(IDAImage **pVal)
{
	if (m_pEngine != NULL)
		return m_pEngine->get_Image(pVal);
	else
		return E_FAIL;
}

/**
* Returns the Sound from the last Engine created (not counting UntilNotifier engines)
*/
STDMETHODIMP CLMReader::get_Sound(IDASound **pVal)
{
	if (m_pEngine != NULL)
		return m_pEngine->get_Sound(pVal);
	else
		return E_FAIL;
}

/**
* Returns the last Engine created (not counting UntilNotifier engines)
*/
STDMETHODIMP CLMReader::get_Engine(ILMEngine **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
	
	if (m_pEngine)
		m_pEngine->AddRef();
	*pVal = (ILMEngine *)m_pEngine;
    return S_OK;
}

/**
* Creates an Engine that is set up to be fed instructions asynchronously.
* Instructions are fed to the Engine through the OnDataAvailable mechanism
*/
STDMETHODIMP CLMReader::createAsyncEngine(/*[out, retval]*/ ILMEngine **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

	HRESULT hr = createEngine(&m_pEngine);

	if (SUCCEEDED(hr)) {
		if (!SUCCEEDED(hr = m_pEngine->SetAsyncBlkSize(m_AsyncBlkSize))) 
			return hr;

		if (!SUCCEEDED(hr = m_pEngine->SetAsyncDelay(m_AsyncDelay)))
			return hr;

		hr = m_pEngine->initAsync();

		CComQIPtr<ILMCodecDownload, &IID_ILMCodecDownload> codecDl(m_pEngine);
		if( codecDl != NULL )
		{
			codecDl->setAutoCodecDownloadEnabled( m_bAutoCodecDownloadEnabled );
		}
	
		if (SUCCEEDED(hr)) {
			m_pEngine->AddRef();
			*pVal = (ILMEngine *)m_pEngine;
		}

	}

	return hr;
}

/**
* Creates an Engine and adds it to the list of Engines for release in the destructor.
* Returns the Engine and does not set m_pEngine.
*/
STDMETHODIMP CLMReader::createEngine(/*[out, retval]*/ ILMEngine **pVal )
{
	if (!pVal) {
		return E_POINTER;
	}

	ILMEngine *pEngine;

	HRESULT hr = CoCreateInstance(
		CLSID_LMEngine,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_ILMEngine,
		(void **) &pEngine);

	// Add new engine to list of engines
	if (!engineList) {
		engineList = new LMEngineList;
		if (!engineList) {
			pEngine->Release();
			return E_OUTOFMEMORY;
		}
		engineListTail = engineList;
	}

	if (!(engineListTail->next = new LMEngineList)) {
		pEngine->Release();
		return E_OUTOFMEMORY;
	}
	engineListTail = engineListTail->next;
	engineListTail->next = NULL;
	engineListTail->engine = pEngine;

	if (SUCCEEDED(hr)) {	
		pEngine->put_Reader(this);	

		pEngine->put_ClientSite(m_spClientSite);
		*pVal = pEngine;

		CComQIPtr<ILMCodecDownload, &IID_ILMCodecDownload> codecDL(pEngine);
		if( codecDL != NULL )
		{
			codecDL->setAutoCodecDownloadEnabled( m_bAutoCodecDownloadEnabled );
		}
	}

	return hr;
}

/**
* Executes the instructions contained in the file referenced by the given URL.
* Creates and returns an engine to do the execution.
* Parameters blkSize and delay are used in asynchronous reads.
*/
STDMETHODIMP CLMReader::_execute(BSTR url, LONG blkSize, LONG delay, ILMEngine **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

	HRESULT hr;
	
	hr = createEngine(&m_pEngine);

	if (SUCCEEDED(hr)) {
		if (!SUCCEEDED(hr = m_pEngine->SetAsyncBlkSize(blkSize))) 
			return hr;

		if (!SUCCEEDED(hr = m_pEngine->SetAsyncDelay(delay)))
			return hr;

		hr = m_pEngine->runFromURL(url);
	
		if (SUCCEEDED(hr)) {
			m_pEngine->AddRef();
			*pVal = (ILMEngine *)m_pEngine;
		}
	}

	return hr;
}

/**
* Executes the instructions contained in the file referenced by the URL.
* Returns the Engine created to do the execution.
*/
STDMETHODIMP CLMReader::execute(/*[in, string]*/ BSTR url, /*[out, retval]*/ILMEngine **pVal)//Pointer to the URL from which the object should be loaded 
{
	return _execute(url, m_AsyncBlkSize, m_AsyncDelay, pVal);
}

// Property handling

/**
* Gets the value of the NoExports flag
*/
STDMETHODIMP CLMReader::get_NoExports(VARIANT_BOOL *pbNoExports)
{
	if (!pbNoExports)
		return E_POINTER;

	*pbNoExports = m_bNoExports;
	return S_OK;
}

/**
* Puts the value of the NoExports flag
*/
STDMETHODIMP CLMReader::put_NoExports(VARIANT_BOOL bNoExports)
{
	m_bNoExports = bNoExports;
	return S_OK;
}

/**
* Gets the value of the Async flag
*/
STDMETHODIMP CLMReader::get_Async(VARIANT_BOOL *pbAsync)
{
	if (!pbAsync)
		return E_POINTER;

	*pbAsync = m_bAsync;
	return S_OK;
}

/**
* Puts the value of the Async flag
*/
STDMETHODIMP CLMReader::put_Async(VARIANT_BOOL bAsync)
{
	m_bAsync = bAsync;
	return S_OK;
}

/**
* Gets the string passed as the SRC parameter to the control
*/
STDMETHODIMP CLMReader::get_Src(BSTR *pBstr)
{
	if (!pBstr)
		return E_POINTER;

	*pBstr = m_Src;
	return S_OK;
}

/**
* Puts an external ViewerControl created in cases like the standalone player
*/
STDMETHODIMP CLMReader::put_ViewerControl(IDAViewerControl *viewerControl)
{
	if (!viewerControl)
		return E_POINTER;

	// Release any current viewer control
	if (m_pViewerControl)
		m_pViewerControl->Release();

	m_pViewerControl = viewerControl;

	// Grab a ref
	if (m_pViewerControl)
		m_pViewerControl->AddRef();

	return S_OK;
}

/**
* gets the version string for lmrt
*/
STDMETHODIMP CLMReader::get_VersionString( BSTR *versionString )
{
	if( versionString == NULL )
		return E_POINTER;

	char *charVersion = VERSION;
	(*versionString) = A2BSTR(charVersion);

	return (*versionString != NULL)?(S_OK):(E_OUTOFMEMORY);
}

/**
* Tells this reader and all of its engines to release their handles
* on the filter graph if they have any
**/
STDMETHODIMP CLMReader::releaseFilterGraph()
{
	if (engineList) {
		LMEngineList *item = engineList->next;
		ILMEngine2 *engine2;

		while (item != NULL) 
		{
			if( SUCCEEDED( item->engine->QueryInterface( IID_ILMEngine2, (void**) &engine2) ) )
			{
				engine2->releaseFilterGraph();
				engine2->Release();
			}

			item = item->next;
		}
	}
	return S_OK;
}
/**
* Gets the external ViewerControl
*/
STDMETHODIMP CLMReader::get_ViewerControl(IDAViewerControl **viewerControl)
{
	if (!viewerControl)
		return E_POINTER;

	*viewerControl = m_pViewerControl;

	if (m_pViewerControl)
		m_pViewerControl->AddRef();

	return S_OK;
}

/**
* Override IPersistStreamInitImpl
* Implements instantiation of control from stream
*/
STDMETHODIMP CLMReader::Load( LPSTREAM pStm)//Pointer to the stream from which the object should be loaded 
{
	HRESULT hr = createEngine(&m_pEngine);
	if (SUCCEEDED(hr))
		hr = m_pEngine->runFromStream(pStm);
	return hr;
}

/**
* Override IPersistPropertyBagImpl
* Implements instantiation of control using parameters
*/
STDMETHODIMP CLMReader::Load(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog)
{
    VARIANT v;

	VariantInit(&v);
	v.vt = VT_BOOL;
    v.boolVal = TRUE;
	if (SUCCEEDED(pPropertyBag->Read(L"NOEXPORTS", &v, pErrorLog))) 
		m_bNoExports = v.boolVal;
	VariantClear(&v);

	VariantInit(&v);
	v.vt = VT_BOOL;
	v.boolVal = VARIANT_TRUE;
	if (SUCCEEDED(pPropertyBag->Read(L"ASYNC", &v, pErrorLog)))
		m_bAsync = v.boolVal;
	VariantClear(&v);

	VariantInit(&v);
	v.vt = VT_I4;
	v.lVal = 0L;
	if (SUCCEEDED(pPropertyBag->Read(L"ASYNC_READ_BLOCK_SIZE", &v, pErrorLog)))
		m_AsyncBlkSize = v.lVal;
	VariantClear(&v);

	VariantInit(&v);
	v.vt = VT_I4;
	v.lVal = 0L;
	if (SUCCEEDED(pPropertyBag->Read(L"ASYNC_DELAY_MILLIS", &v, pErrorLog)))
		m_AsyncDelay = v.lVal;
	VariantClear(&v);

	VariantInit(&v);
	v.vt = VT_BSTR;
	v.bstrVal = NULL;
	if (SUCCEEDED(pPropertyBag->Read(L"SRC", &v, pErrorLog)))
		m_Src = v.bstrVal;

	VariantInit(&v);
	v.vt = VT_BOOL;
	v.boolVal = VARIANT_FALSE;
	if(SUCCEEDED(pPropertyBag->Read(L"ENABLE_CODEC_DOWNLOAD", &v, pErrorLog)))
		m_bAutoCodecDownloadEnabled = (v.boolVal==VARIANT_TRUE) ? TRUE : FALSE;

	HRESULT hr = S_OK;

	if (m_Src != NULL) {
		ILMEngine *pEngine;
		hr = _execute(m_Src, m_AsyncBlkSize, m_AsyncDelay, &pEngine);

		if (SUCCEEDED(hr))
			// We don't need the engine here so just release it.
			pEngine->Release();
	}

	VariantClear(&v);

	return hr;
}


// Override IObjectSafetyImpl

STDMETHODIMP CLMReader::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}

STDMETHODIMP CLMReader::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag  || riid == IID_IPersistStreamInit)
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP CLMReader::InPlaceDeactivate()
{
    // This replaces the implementation in ATL's atlctl.h, and just
    // adds our shutdown code at the beginning.

	if (m_pEngine)
		m_pEngine->AbortExecution();

    // ... continue by calling the "original" deactivate.
    return IOleInPlaceObject_InPlaceDeactivate();
}

/*
 * IOleCommandTarget methods.
 */
STDMETHODIMP CLMReader::QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds,
									OLECMD prgCmds[], OLECMDTEXT* pCmdText )
{
    if ( pguidCmdGroup != NULL )
	{
		// It's a nonstandard group!!
        return OLECMDERR_E_UNKNOWNGROUP;
	}

    MSOCMD*     pCmd;
    INT         c;
    HRESULT     hr = S_OK;

    // Command text is NOT SUPPORTED.
    if ( pCmdText && ( pCmdText->cmdtextf != OLECMDTEXTF_NONE ) )
	{
        pCmdText->cwActual = 0;
	}

    // Loop through each command in the ary, setting the status of each.
    for ( pCmd = prgCmds, c = cCmds; --c >= 0; pCmd++ )
    {
        // By default command status is NOT SUPPORTED.
		if (pCmd->cmdID == OLECMDID_STOP)
			pCmd->cmdf = OLECMDF_SUPPORTED;
		else
			pCmd->cmdf = 0;
	}

    return (hr);
}
        
STDMETHODIMP CLMReader::Exec(const GUID* pguidCmdGroup, DWORD nCmdID,
							 DWORD nCmdexecopt, VARIANTARG* pvaIn, VARIANTARG* pvaOut)
{
    HRESULT hr = S_OK;
	
    if ( pguidCmdGroup == NULL ) {		
        switch (nCmdID)
        {
		case OLECMDID_STOP:
			if (m_pEngine)
				m_pEngine->AbortExecution();
			break;
			
		default:
			hr = OLECMDERR_E_NOTSUPPORTED;
			break;
        }
    } else 
        hr = OLECMDERR_E_UNKNOWNGROUP;
	
    return (hr);
}

/**************************
** IAMFilterGraphCallback Methods
**********************/

//========================================================================
//
// GetAMediaType
//
// Enumerate the media types of *ppin.  If they all have the same majortype
// then set MajorType to that, else set it to CLSID_NULL.  If they all have
// the same subtype then set SubType to that, else set it to CLSID_NULL.
// If something goes wrong, set both to CLSID_NULL and return the error.
//========================================================================
HRESULT GetAMediaType( IPin * ppin, CLSID & MajorType, CLSID & SubType)
{

    HRESULT hr;
    IEnumMediaTypes *pEnumMediaTypes;

    /* Set defaults */
    MajorType = CLSID_NULL;
    SubType = CLSID_NULL;

    hr = ppin->EnumMediaTypes(&pEnumMediaTypes);

    if (FAILED(hr)) 
	{
		return hr;    // Dumb or broken filters don't get connected.
    }

    _ASSERTE (pEnumMediaTypes!=NULL);

    /* Put the first major type and sub type we see into the structure.
       Thereafter if we see a different major type or subtype then set
       the major type or sub type to CLSID_NULL, meaning "dunno".
       If we get so that both are dunno, then we might as well return (NYI).
    */

    BOOL bFirst = TRUE;

    for ( ; ; ) 
	{

		AM_MEDIA_TYPE *pMediaType = NULL;
		ULONG ulMediaCount = 0;

		/* Retrieve the next media type
		   Need to delete it when we've done.
		*/
		hr = pEnumMediaTypes->Next(1, &pMediaType, &ulMediaCount);
		_ASSERTE(SUCCEEDED(hr));
		if (FAILED(hr)) 
		{
			MajorType = CLSID_NULL;
			SubType = CLSID_NULL;
			pEnumMediaTypes->Release();
			return NOERROR;    // we can still plough on
		}

		if (ulMediaCount==0) 
		{
			pEnumMediaTypes->Release();
			return NOERROR;       // normal return
		}

		if (bFirst) 
		{
			MajorType = pMediaType[0].majortype;
			SubType = pMediaType[0].subtype;
			bFirst = FALSE;
		} else {
			if (SubType != pMediaType[0].subtype) 
			{
				SubType = CLSID_NULL;
			}
			if (MajorType != pMediaType[0].majortype) 
			{
				MajorType = CLSID_NULL;
			}
		}
	
		if (pMediaType->cbFormat != 0) 
		{
			CoTaskMemFree(pMediaType->pbFormat);
		}
		CoTaskMemFree(pMediaType);

		// stop if we have a type
		if (SubType != CLSID_NULL) 
		{
			pEnumMediaTypes->Release();
			return NOERROR;
		}
    }

    // NOTREACHED
    
} // GetAMediaType

// {6B6D0800-9ADA-11d0-A520-00A0D10129C0}
EXTERN_GUID(CLSID_NetShowSource, 
0x6b6d0800, 0x9ada, 0x11d0, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);

EXTERN_GUID(CLSID_SourceStub, 
0x6b6d0803, 0x9ada, 0x11d0, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);


/**
*  Called when the filtergraph is unable to render in the browser case.
*  This code attempts to download the codec for the pin that failed
*  to render.
**/
HRESULT CLMReader::UnableToRender( IPin *pPin )
{
	CLSID clsidWanted;
    HRESULT hr = E_NOINTERFACE;
	
    DWORD dwVerLS = 0, dwVerMS = 0;
	
	CLSID clsidMajor;
    // else get the media type exposed by this stream....
    if (FAILED(hr)) 
	{
		ATLTRACE(_T("No IComponentDownload, trying first media type\n"));
		// get the first media type from this pin....
		hr = GetAMediaType(pPin, clsidMajor, clsidWanted);
		
		if (FAILED(hr)) 
		{
			ATLTRACE(_T("Couldn't get a media type to try\n"));
			return hr;
		}
    }
	
	//Don't need to look for ourselves here

    if (clsidMajor == CLSID_NetShowSource) 
	{
		ATLTRACE(_T("auto-downloading known major type\n"));
		clsidWanted = clsidMajor;
	} else if (clsidMajor != MEDIATYPE_Video &&
			   clsidMajor != MEDIATYPE_Audio &&
			   clsidMajor != CLSID_SourceStub) 
	{
		ATLTRACE(_T("For now, we only support audio & video auto-download\n"));
		return E_FAIL;
	}

	
	if (clsidWanted == MEDIASUBTYPE_MPEG1AudioPayload) 
	{
			ATLTRACE(_T("Hack: we know we don't want to download MPEG-1 audio, try layer 3\n"));
			clsidWanted.Data1 = WAVE_FORMAT_MPEGLAYER3;
	}
	
			
	if (clsidWanted == CLSID_NULL) 
	{
		ATLTRACE(_T("Couldn't guess a CLSID to try to download\n"));
		return E_FAIL;
	}
			
	// !!! perhaps keep track of last codec we tried to download and
	// don't try again immediately, to prevent ugly looping?
	if (clsidWanted == m_clsidDownloaded) 
	{
		ATLTRACE(_T("Already thought we downloaded this codec!\n"));
				
		// fire an ERRORABORTEX here that we downloaded a codec, but it didn't do
		// any good?
		//BSTR bstrError = FormatBSTR(IDS_ERR_BROKEN_CODEC, NULL);
				
		//if (bstrError) 
		//{
			// !!! hack, should we really NotifyEvent through the graph?
		//	ProcessEvent(EC_ERRORABORTEX, VFW_E_INVALIDMEDIATYPE, (LONG) bstrError, FALSE);
		//	}
				
		return E_FAIL;
	}
			
	WCHAR guidstr[50];
	StringFromGUID2(clsidWanted, guidstr, 50);
			
	TCHAR szKeyName[60];
			
	wsprintf(szKeyName, "CLSID\\%ls", guidstr);
	CRegKey crk;
			
	LONG    lr;
	lr = crk.Open(HKEY_CLASSES_ROOT, szKeyName);
	if(ERROR_SUCCESS == lr)
	{
		crk.QueryValue(dwVerMS, _T("VerMS"));
		crk.QueryValue(dwVerLS, _T("VerLS"));
		
		// ask for a version just past what we have already....
		++dwVerLS;
		
				
		crk.Close();
	}
			
	//SetStatusMessage(NULL, IDS_DOWNLOADINGCODEC);
			
#ifdef DEBUG
			ATLTRACE(_T("Trying to download GUID %ls\n"), guidstr);
#endif
			
			
	//  This API is our friend....
	//  STDAPI CoGetClassObjectFromURL( REFCLSID rCLASSID,
	//        LPCWSTR szCODE, DWORD dwFileVersionMS, 
	//        DWORD dwFileVersionLS, LPCWSTR szTYPE,
	//        LPBINDCTX pBindCtx, DWORD dwClsContext,
	//        LPVOID pvReserved, REFIID riid, LPVOID * ppv);
	
	// issue: is this CLASSID just the same as the minor type?
			
	CComObject<CDownloadCallback> * pCallback;
	hr = CComObject<CDownloadCallback>::CreateInstance(&pCallback);

	pCallback->m_pLMR = this;
			
	if (FAILED(hr))
		return hr;
						
	IBindStatusCallback *pBSCallback;
	hr = pCallback->QueryInterface(IID_IBindStatusCallback, (void **) &pBSCallback);
		_ASSERTE(hr == S_OK);
			
	// which of these should we use?  Depends whether a BindCtx is passed in...
	// STDAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb,                       
	//                            IEnumFORMATETC *pEFetc, IBindCtx **ppBC);                   
	// STDAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum,   
	//                            IBindCtx **ppBC, DWORD reserved);                                                     
			
	IBindCtx *pBindCtx = NULL; // !!!!
			
	hr = CreateAsyncBindCtx(0, pBSCallback, NULL, &pBindCtx);
			
	if (FAILED(hr)) 
	{
		ATLTRACE(_T("CreateAsyncBindCtx failed hr = %x\n"), hr);
		return hr;
	}
			
	IBaseFilter *pFilter = NULL;
			
	hr = CoGetClassObjectFromURL(clsidWanted, NULL, dwVerMS, dwVerLS, NULL,
				pBindCtx, CLSCTX_INPROC, NULL, IID_IBaseFilter,
				(void **) &pFilter);
			
	ATLTRACE(_T("CoGetClassObjectFromURL returned %x\n"), hr);
			
	if (hr == S_ASYNCHRONOUS) 
	{
		ATLTRACE(_T("Oh dear, it's asynchronous, what now?\n"));
				
		// !!! wait here until it finishes?
		for (;;) 
		{
			HANDLE ev = pCallback->m_evFinished;
					
			DWORD dwResult = MsgWaitForMultipleObjects(
				1,
				&ev,
				FALSE,
				INFINITE,
				QS_ALLINPUT);
			if (dwResult == WAIT_OBJECT_0)
				break;
					
			_ASSERTE(dwResult == WAIT_OBJECT_0 + 1);
			//  Eat messages and go round again
			MSG Message;
			while (PeekMessage(&Message,NULL,0,0,PM_REMOVE)) 
			{
				TranslateMessage(&Message);
				DispatchMessage(&Message);
			}
		}
				
		ATLTRACE(_T("Finished waiting.... m_pUnk is %x, hr = %lx\n"),
		pCallback->m_pUnk, pCallback->m_hrBinding);
				
		hr = pCallback->m_hrBinding;
				
		if (SUCCEEDED(hr)) 
		{
			hr = pCallback->m_pUnk->QueryInterface(IID_IBaseFilter, (void **) &pFilter);
		}
	}
			
	pBSCallback->Release();
	pBindCtx->Release();
			
	if (SUCCEEDED(hr)) 
	{
		pFilter->Release();     // graph will re-instantiate the filter, we hope
	} else {
		// oh well, we didn't get one.
	}
			
	if (REGDB_E_CLASSNOTREG == hr) 
	{
		ATLTRACE(_T("Hack: treating ClassNotReg as success, and hoping...."));
		hr = S_OK;
	}
			
	if (SUCCEEDED(hr)) 
	{
		m_clsidDownloaded = clsidWanted; // avoid infinite loop
	} else {
		// fire an ERRORABORTEX here that we downloaded a codec, but it didn't do
		// any good?
		/*
		BSTR bstrError = NULL;
		
		if( FACILITY_CERT == HRESULT_FACILITY( hr ) )
		{
			//bstrError = FormatBSTR( IDS_ERR_CODEC_NOT_TRUSTED, NULL );
		} else {
			//bstrError = FormatBSTR(IDS_ERR_NO_CODEC, NULL);
		}
				
		if (bstrError) {
			// !!! hack, should we really NotifyEvent through the graph?
			//ProcessEvent(EC_ERRORABORTEX, VFW_E_INVALIDMEDIATYPE, (LONG) bstrError, FALSE);
		}
		*/
	}
			
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
CDownloadCallback::CDownloadCallback()
    : m_pLMR(NULL),
	  m_hrBinding(S_ASYNCHRONOUS),
      m_pUnk(NULL),
      m_ulProgress(0), m_ulProgressMax(0)
{
    m_evFinished = CreateEvent(NULL, FALSE, FALSE, NULL);
}


STDMETHODIMP CDownloadCallback::Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword)
{
    ATLTRACE(_T("Callback Authenticate\n"));
    m_pLMR->getHwnd(phwnd); // !!! is this right?
    *pszUsername = NULL;
    *pszPassword = NULL;
    return S_OK;
}

    // IWindowForBindingUI methods
STDMETHODIMP
CDownloadCallback:: GetWindow(REFGUID rguidReason, HWND *phwnd)
{

	m_pLMR->getHwnd( phwnd );

#ifdef DEBUG
    WCHAR achguid[50];
    StringFromGUID2(rguidReason, achguid, 50);
    
    ATLTRACE(_T("Callback GetWindow: (%ls) returned %x\n"), achguid, *phwnd );
#endif
    
    return S_OK;
}

STDMETHODIMP
CDownloadCallback::OnCodeInstallProblem(ULONG ulStatusCode, LPCWSTR szDestination,
					   LPCWSTR szSource, DWORD dwReserved)
{
    ATLTRACE(_T("Callback: OnCodeInstallProblem: %d    %ls -> %ls\n"),
		ulStatusCode, szDestination, szSource );

    return S_OK;   // !!!!!!!@!!!!!!!!!!!
}


/////////////////////////////////////////////////////////////////////////////
// 
CDownloadCallback::~CDownloadCallback()
{
    if (m_pUnk)
		m_pUnk->Release();

    //_ASSERTE(m_pDXMP->m_pDownloadBinding == NULL);

    if (m_evFinished)
		CloseHandle(m_evFinished);
}

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP CDownloadCallback::QueryService(REFGUID guidService, REFIID riid, void ** ppvObject)
{
#ifdef DEBUG

    // Dump requested stuff here....
    WCHAR achguid[50], achiid[50];
    StringFromGUID2(guidService, achguid, 50);
    StringFromGUID2(riid, achiid, 50);
    ATLTRACE(_T("Callback QS: (%ls, %ls)\n"), achguid, achiid);

#endif

    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnStartBinding(DWORD grfBSCOption, IBinding* pbinding)
{
    ATLTRACE(_T("OnStartBinding, pbinding=%x\n"), pbinding);

    return S_OK;

}  // CDownloadCallback::OnStartBinding

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::GetPriority(LONG* pnPriority)
{
    ATLTRACE(_T("GetPriority\n"));

    return E_NOTIMPL;
}  // CDownloadCallback::GetPriority

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnLowResource(DWORD dwReserved)
{
    ATLTRACE(_T("OnLowResource %d\n"), dwReserved);

    return E_NOTIMPL;
}  // CDownloadCallback::OnLowResource

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
		       ULONG ulStatusCode, LPCWSTR szStatusText)
{

    return(NOERROR);
}  // CDownloadCallback::OnProgress

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
{
	return S_OK;

}  // CDownloadCallback::OnStopBinding

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    ATLTRACE(_T("GetBindInfo\n"));

    // !!! are these the right flags?

    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_NEEDFILE;
    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    pbindInfo->grfBindInfoF = 0;
    pbindInfo->dwBindVerb = BINDVERB_GET;
    pbindInfo->szCustomVerb = NULL;
    return S_OK;
}  // CDownloadCallback::GetBindInfo

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC* pfmtetc, STGMEDIUM* pstgmed)
{
    ATLTRACE(_T("OnDataAvailable, dwSize = %x\n"), dwSize);

    // !!! do we care?

    return S_OK;
}  // CDownloadCallback::OnDataAvailable

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    ATLTRACE(_T("OnObjectAvailable\n"));

    // should only be used in BindToObject case, which we don't use?
    m_pUnk = punk;
    if (punk)
	punk->AddRef();

    return S_OK;
}  // CDownloadCallback::OnObjectAvailable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\control\execute.cpp ===
#include "Engine.h"

//#define COM_DEBUG

#ifdef COM_DEBUG
int _com_count = 0;
#define Assert(x, s) if (!(x)) MessageBox(NULL, s, "execute", MB_OK)
#endif

//#define instrTrace(s) { OutputDebugString(s); OutputDebugString("\n"); }
//#define instrTrace(s) MessageBox(NULL, s, "execute", MB_OK);
#define instrTrace(s)

// Returns address of top of LONG stack, postincrements pointer
#define PUSH_LONG_ADDR			(longTop++)

// Pushes the given LONG onto the LONG stack
#define PUSH_LONG(x)			(*longTop++ = (x))

// Returns value at top of LONG stack and pops it
#define POP_LONG				(*--longTop)

// Returns value of LONG at top-i
#define USE_LONG(i)				(*(longTop-i))

// Uses the value of LONG at top-i to create a VARIANT_BOOL
#define USE_LONG_AS_BOOL(i)		((short)-(*(longTop-i)))

// Pops i LONGS from top of int stack
#define FREE_LONG(i)			(longTop-=i)

// Address of returned int, which is actually a long
#define RET_LONG_ADDR			(&longTmp1)

// The value of the returned int, which is actually a long
#define RET_LONG				(longTmp1)

// Returns address of top of double stack, postincrements pointer
#define PUSH_DOUBLE_ADDR		(doubleTop++)

// Pushes the given double onto the double stack
#define PUSH_DOUBLE(x)			(*doubleTop++ = (x))

// Returns value at top of double stack and pops it
#define POP_DOUBLE				(*--doubleTop)

// Returns value of double at top-i
#define USE_DOUBLE(i)			(*(doubleTop-i))

// Pops i doubles from top of double stack
#define FREE_DOUBLE(i)			(doubleTop-=i)

// Pushes the given string onto the string stack
#define PUSH_STRING(x)			(*stringTop++ = (x))

// Returns value of the string at top-i
#define USE_STRING(i)			(*(stringTop-i))

// Pops and frees the string at the top of the string stack
#define FREE_STRING				(SysFreeString(*(--stringTop)))

// Pops without freeing a string
#define POP_STRING_NO_FREE		(*--stringTop)

// Pushes the given COM object onto the COM object stack
#define PUSH_COM(x)				(*(comTop++) = (x))

// Returns address of top of COM stack, postincrements pointer
#ifdef COM_DEBUG
#define PUSH_COM_ADDR			(_com_count++, comTop++)
#else
#define PUSH_COM_ADDR			(comTop++)
#endif

// Returns the value of the COM object at top-i
#define USE_COM(i)				(*(comTop-i))

// Pops and frees the COM object at the top of the COM object stack
#ifdef COM_DEBUG
#define FREE_COM				{	\
	_com_count--;					\
	(*--comTop)->Release();			\
	*comTop = NULL;					\
}
#else
#define FREE_COM				{	\
	((*--comTop)->Release());		\
	*comTop = NULL;					\
}
#endif

// Pops and frees the COM object, but tests whether it is null
#define FREE_COM_TEST			(freeCOM(*--comTop))

// Pops without freeing the COM object
#define POP_COM_NO_FREE			(*--comTop)

// Returns the address to the variable used to store returned COM objects
#ifdef COM_DEBUG
#define RET_COM_ADDR			(_com_count++, &comTmp)
#else
#define RET_COM_ADDR			(&comTmp)
#endif

// Returns retCom
#define RET_COM					(comTmp)

// Pushes a COM array ontot the COM array stack
#define PUSH_COM_ARRAY(x)		(*(comArrayTop++) = (x))

// Returns the value of the COM array object at top-i
#define USE_COM_ARRAY(i)		(*(comArrayTop-i))

// Pops and frees the COM array at the top of the COM array stack
// Also pops the associated com array length
#ifdef COM_DEBUG
#define FREE_COM_ARRAY		(freeCOMArray(*(--comArrayTop), *(--comArrayLenTop)), _com_count -= *(comArrayLenTop))
#else
#define FREE_COM_ARRAY		(freeCOMArray(*(--comArrayTop), *(--comArrayLenTop)))
#endif

// Push the given length onto the array length stack
#define PUSH_COM_ARRAY_LENGTH(x)	(*(comArrayLenTop++) = (x))

// Return the value of array length at top-i
#define USE_COM_ARRAY_LENGTH(i)		(*(comArrayLenTop-i))

// Method call with zero or more args
#define METHOD_CALL_0(obj, name) (status = (obj)->name())
#define METHOD_CALL_1(obj, name, a1) (status = (obj)->name((a1)))
#define METHOD_CALL_2(obj, name, a1, a2) (status = (obj)->name((a1), (a2)))
#define METHOD_CALL_3(obj, name, a1, a2, a3) (status = (obj)->name((a1), (a2), (a3)))
#define METHOD_CALL_4(obj, name, a1, a2, a3, a4) (status = (obj)->name((a1), (a2), (a3), (a4)))
#define METHOD_CALL_5(obj, name, a1, a2, a3, a4, a5) (status = (obj)->name((a1), (a2), (a3), (a4), (a5)))
#define METHOD_CALL_6(obj, name, a1, a2, a3, a4, a5, a6) (status = (obj)->name((a1), (a2), (a3), (a4), (a5), (a6)))
#define METHOD_CALL_7(obj, name, a1, a2, a3, a4, a5, a6, a7) (status = (obj)->name((a1), (a2), (a3), (a4), (a5), (a6), (a7)))
#define METHOD_CALL_8(obj, name, a1, a2, a3, a4, a5, a6, a7, a8) (status = (obj)->name((a1), (a2), (a3), (a4), (a5), (a6), (a7), (a8)))
#define METHOD_CALL_9(obj, name, a1, a2, a3, a4, a5, a6, a7, a8, a9) (status = (obj)->name((a1), (a2), (a3), (a4), (a5), (a6), (a7), (a8), (a9)))

#define IMPORT_METHOD_CALL_0(obj, name) (METHOD_CALL_0((obj), name))
#define IMPORT_METHOD_CALL_1(obj, name, a1) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_1((obj), name, _absPath); SysFreeString(_absPath) }
#define IMPORT_METHOD_CALL_2(obj, name, a1, a2) { BSTR _absPath = ExpandImportPath(a1);	METHOD_CALL_2((obj), name, _absPath, (a2));	SysFreeString(_absPath); } 
#define IMPORT_METHOD_CALL_3(obj, name, a1, a2, a3) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_3((obj), name, _absPath, (a2), (a3)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_4(obj, name, a1, a2, a3, a4) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_4((obj), name, _absPath, (a2), (a3), (a4)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_5(obj, name, a1, a2, a3, a4, a5) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_5((obj), name, _absPath, (a2), (a3), (a4), (a5)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_6(obj, name, a1, a2, a3, a4, a5, a6) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_6((obj), name, _absPath, (a2), (a3), (a4), (a5), (a6)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_7(obj, name, a1, a2, a3, a4, a5, a6, a7) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_7((obj), name, _absPath, (a2), (a3), (a4), (a5), (a6), (a7)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_8(obj, name, a1, a2, a3, a4, a5, a6, a7, a8) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_8((obj), name, _absPath, (a2), (a3), (a4), (a5), (a6), (a7), (a8)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_9(obj, name, a1, a2, a3, a4, a5, a6, a7, a8, a9) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_9((obj), name, _absPath, (a2), (a3), (a4), (a5), (a6), (a7), (a8), (a9)); SysFreeString(_absPath); }


// Create COM instance
#ifdef COM_DEBUG
#define COM_CREATE(c, i, dest) {	\
  (status = CoCreateInstance(c, NULL, CLSCTX_INPROC_SERVER, i, (void **) dest));	\
  _com_count++;	\
}
#else
#define COM_CREATE(c, i, dest)			(status = CoCreateInstance(c, NULL, CLSCTX_INPROC_SERVER, i, (void **) dest))
#endif

long CLMEngine::execute()
{
	BYTE command;

	HRESULT status = S_OK;

	ULONG	nRead;

	// Temp variables are available for personal use within
	// each case statement

	// Temporary LONG variables
	LONG longTmp1;
	LONG longTmp2;

	// Temporary BYTE variables
	BYTE byteTmp1;
	BYTE byteTmp2;

	// Temporary float variables
	float floatTmp1;

	// Temporary double variables
	double doubleTmp1;
	double doubleTmp2;
	double doubleTmp3;

	// Temporary BSTR variables
	BSTR bstrTmp1;
	BSTR bstrTmp2;

	// Temporary COM variables
	IUnknown *comTmp;

	// Temporary COM array variables
	IUnknown **comArrayTmp1;
	IUnknown **comArrayTmp2;

	// Temporary BOOLEAN variables
	VARIANT_BOOL tmpBool1;

	// Instruction version used to generate the following code
	int instructionVersion = 57;
		
	VARIANT_BOOL bNoExports;
	m_pReader->get_NoExports(&bNoExports);

	while (status == S_OK) {

		EnterCriticalSection(&m_CriticalSection);

		if (m_bAbort == TRUE) {
			status = E_ABORT;
			break;
		}

		// stream should be positioned at beginning of next command
		// or eof

		// Mark the stream in case we get interrupted mid command
		codeStream->Commit();

		// Get first byte of command
		status = codeStream->readByte(&command);

		// Failure means EOF
		if (status == E_FAIL) {
			status = S_OK;
			break;
		}

		if (status != S_OK)
			break;

		// Switch on the sort of command.  If it is a double byte
		// command then flow is given to a second switch

		// BEGIN AUTOGENERATED
		
		// Code must adhere to the following format:
		// case x:
		//    // Execute: "instruction_name"
		//    lines_of_code
		//    break;
		// where instruction_name is listed in Instructions.txt
		
		// Switch for 0
		switch(command)
		{
		case 0:
			// Execute: "unsupported"
			// USER GENERATED
			instrTrace("unsupported");
			status = E_INVALIDARG;
			break;
			
		case 1:
			// Execute: "check version"
				// USER GENERATED
				status = readLong(&longTmp1);
				if (SUCCEEDED(status) && (longTmp1 != instructionVersion))
					status = E_FAIL;
			break;
			
		case 2:
			// Execute: "push double"
			// USER GENERATED
			instrTrace("push double");
			if (SUCCEEDED(status = readDouble(&doubleTmp1)))
				PUSH_DOUBLE(doubleTmp1);
			break;
			
		case 3:
			// Execute: "push float as double"
			// USER GENERATED
			instrTrace("push float as double");
			if (SUCCEEDED(status = readFloat(&floatTmp1)))
				PUSH_DOUBLE((double)floatTmp1);
			break;
			
		case 4:
			// Execute: "push long as double"
			// USER GENERATED
			instrTrace("push long as double");
			if (SUCCEEDED(status = readLong(&longTmp1)))
				PUSH_DOUBLE((double)longTmp1);
			break;
			
		case 5:
			// Execute: "pop double"
			// USER GENERATED
			instrTrace("pop double");
			POP_DOUBLE;
			break;
			
		case 6:
			// Execute: "push string"
			// USER GENERATED
			instrTrace("push string");
			// Length follows as long
			// Characters follow after
			// Format of BSTR is 4 byte length, followed by Unicode chars
			// terminated by a 0
			if (SUCCEEDED(status = readLong(&longTmp1))) {
				bstrTmp2 = bstrTmp1 = SysAllocStringLen(0, longTmp1);
				if (bstrTmp2 != 0) {
					while (longTmp1-- && SUCCEEDED(status)) {
						if (SUCCEEDED(status = codeStream->readByte(&byteTmp1)))
							*bstrTmp2++ = byteTmp1;
					}
			
					if (SUCCEEDED(status)) {
						*bstrTmp2++ = 0;
						PUSH_STRING(bstrTmp1);
					} else 
						SysFreeString(bstrTmp1);
				} else
					status = STATUS_ERROR;
			}
			break;
			
		case 7:
			// Execute: "push unicode string"
			// USER GENERATED
				{
				instrTrace("push unicode string");
				// Length follows as long
				// Characters follow after in Unicode format
				// Format of BSTR is 4 byte length, followed by Unicode chars
				// terminated by a 0
				if (SUCCEEDED(status = readLong(&longTmp1))) {
					bstrTmp2 = bstrTmp1 = SysAllocStringLen(0, longTmp1);
					if (bstrTmp2 != 0) {
						OLECHAR tmpChar;
						while (longTmp1-- && SUCCEEDED(status)) {
							if (SUCCEEDED(status = codeStream->readByte(&byteTmp1))) {
								tmpChar = byteTmp1;
								if (SUCCEEDED(status = codeStream->readByte(&byteTmp1))) {
									tmpChar += ((OLECHAR)byteTmp1 << 8);
									*bstrTmp2++ = tmpChar;
								}
							}
						}
						
						if (SUCCEEDED(status)) {
							*bstrTmp2++ = 0; 
							PUSH_STRING(bstrTmp1);
						} else
							SysFreeString(bstrTmp1);
					} else
						status = STATUS_ERROR;
				}
				}
			break;
			
		case 8:
			// Execute: "pop string"
			// USER GENERATED
			instrTrace("pop string");
			FREE_STRING;
			break;
			
		case 9:
			// Execute: "push int"
			// USER GENERATED
			instrTrace("push int");
			if (SUCCEEDED(status = readSignedLong(&longTmp1)))
				PUSH_LONG(longTmp1);
			break;
			
		case 10:
			// Execute: "pop int"
			// USER GENERATED
			instrTrace("pop int");
			POP_LONG;
			break;
			
		case 11:
			// Execute: "push null com"
			// USER GENERATED
			instrTrace("push null com");
			PUSH_COM(0);
			break;
			
		case 12:
			// Execute: "push com from temp"
			// USER GENERATED
			instrTrace("push com from temp");
			// Get index of temp to copy from
			if (SUCCEEDED(status = readLong(&longTmp1))) {
				if (longTmp1 < comStoreSize &&
					(comTmp = comStore[longTmp1]) != 0) {
					
					// Inc reference count
					comTmp->AddRef();
					// Push it
					PUSH_COM(comTmp);
				} else
					status = E_INVALIDARG;
			}
			break;
			
		case 13:
			// Execute: "push com from temp release"
			// USER GENERATED
			instrTrace("push com from temp release");
			// Get index of temp to copy from
			if (SUCCEEDED(status = readLong(&longTmp1))) {
				if (longTmp1 < comStoreSize) {
					// Push it
					PUSH_COM(comStore[longTmp1]);
					// Set it to null so we don't try to release it on cleanup
					comStore[longTmp1] = 0;
				} else
					status = E_INVALIDARG;
			}
			break;
			
		case 14:
			// Execute: "copy com to temp"
			// USER GENERATED
			instrTrace("copy com to temp");
			// Get index of temp to copy comTop to
			if (SUCCEEDED(status = readLong(&longTmp1))) {
				if (longTmp1 < comStoreSize &&
					(comTmp = USE_COM(1)) != 0) {
					
					// Inc reference count
					comTmp->AddRef();
					// Stash it
					comStore[longTmp1] = comTmp;
				} else
					status = E_INVALIDARG;
			}
			break;
			
		case 15:
			// Execute: "pop com to temp"
			// USER GENERATED
			instrTrace("pop com to temp");
			// Get index of temp to copy comTop to
			if (SUCCEEDED(status = readLong(&longTmp1))) {				
				if (longTmp1 < comStoreSize) {
					// Stash it
					comStore[longTmp1] = POP_COM_NO_FREE;
				} else
					status = E_INVALIDARG;
			}
			break;
			
		case 16:
			// Execute: "pop com"
			// USER GENERATED
			FREE_COM_TEST;
			break;
			
		case 17:
			// Execute: "push array from coms"
			// USER GENERATED
			instrTrace("push array from coms");
			// Following long is length of array
			if (SUCCEEDED(status = readLong(&longTmp1))) {
				longTmp2 = longTmp1;
				// Create array of that size
				comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
				if (comArrayTmp1 != 0) {
					// POP_COM_NO_FREE COM's from stack into array
					while (longTmp2--)
						*comArrayTmp2++ = POP_COM_NO_FREE;
					// Push array onto comArray stack
					PUSH_COM_ARRAY(comArrayTmp1);
					// Push length onto array length stack
					PUSH_COM_ARRAY_LENGTH(longTmp1);
				} else
					status = E_OUTOFMEMORY;
			}
			break;
			
		case 18:
			// Execute: "pop array"
			// USER GENERATED
			FREE_COM_ARRAY;
			break;
			
		case 19:
			// Execute: "push null array"
			// USER GENERATED
			PUSH_COM_ARRAY(0);
			PUSH_COM_ARRAY_LENGTH(0);
			break;
			
		case 20:
			// Execute: "push Point3Bvr Bbox3Bvr.getMin()"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Bbox3Bvr.getMin()");
			METHOD_CALL_1(
				(IDABbox3*)USE_COM(1),
				get_Min,
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 21:
			// Execute: "push Point3Bvr Bbox3Bvr.getMax()"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Bbox3Bvr.getMax()");
			METHOD_CALL_1(
				(IDABbox3*)USE_COM(1),
				get_Max,
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 22:
			// Execute: "push Point2Bvr Bbox2Bvr.getMin()"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Bbox2Bvr.getMin()");
			METHOD_CALL_1(
				(IDABbox2*)USE_COM(1),
				get_Min,
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 23:
			// Execute: "push Point2Bvr Bbox2Bvr.getMax()"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Bbox2Bvr.getMax()");
			METHOD_CALL_1(
				(IDABbox2*)USE_COM(1),
				get_Max,
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 24:
			// Execute: "push NumberBvr Vector3Bvr.getZ()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector3Bvr.getZ()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				get_Z,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 25:
			// Execute: "push Vector3Bvr Vector3Bvr.normalize()"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.normalize()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				Normalize,
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 26:
			// Execute: "push NumberBvr Vector3Bvr.getX()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector3Bvr.getX()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				get_X,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 27:
			// Execute: "push NumberBvr Vector3Bvr.lengthSquared()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector3Bvr.lengthSquared()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				get_LengthSquared,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 28:
			// Execute: "push NumberBvr Vector3Bvr.getY()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector3Bvr.getY()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				get_Y,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 29:
			// Execute: "push Vector3Bvr Vector3Bvr.transform(Transform3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.transform(Transform3Bvr)");
			METHOD_CALL_2(
				(IDAVector3*)USE_COM(1),
				Transform,
				(IDATransform3*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 30:
			// Execute: "push Vector3Bvr Vector3Bvr.mul(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.mul(NumberBvr)");
			METHOD_CALL_2(
				(IDAVector3*)USE_COM(1),
				MulAnim,
				(IDANumber*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 31:
			// Execute: "push Vector3Bvr Vector3Bvr.mul(double)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.mul(double)");
			METHOD_CALL_2(
				(IDAVector3*)USE_COM(1),
				Mul,
				USE_DOUBLE(1),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 32:
			// Execute: "push NumberBvr Vector3Bvr.length()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector3Bvr.length()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				get_Length,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 33:
			// Execute: "push Vector3Bvr Vector3Bvr.div(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.div(NumberBvr)");
			METHOD_CALL_2(
				(IDAVector3*)USE_COM(1),
				DivAnim,
				(IDANumber*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 34:
			// Execute: "push Vector3Bvr Vector3Bvr.div(double)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.div(double)");
			METHOD_CALL_2(
				(IDAVector3*)USE_COM(1),
				Div,
				USE_DOUBLE(1),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 35:
			// Execute: "push Vector2Bvr Vector2Bvr.normalize()"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.normalize()");
			METHOD_CALL_1(
				(IDAVector2*)USE_COM(1),
				Normalize,
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 36:
			// Execute: "push NumberBvr Vector2Bvr.getX()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector2Bvr.getX()");
			METHOD_CALL_1(
				(IDAVector2*)USE_COM(1),
				get_X,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 37:
			// Execute: "push NumberBvr Vector2Bvr.lengthSquared()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector2Bvr.lengthSquared()");
			METHOD_CALL_1(
				(IDAVector2*)USE_COM(1),
				get_LengthSquared,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 38:
			// Execute: "push NumberBvr Vector2Bvr.getY()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector2Bvr.getY()");
			METHOD_CALL_1(
				(IDAVector2*)USE_COM(1),
				get_Y,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 39:
			// Execute: "push Vector2Bvr Vector2Bvr.transform(Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.transform(Transform2Bvr)");
			METHOD_CALL_2(
				(IDAVector2*)USE_COM(1),
				Transform,
				(IDATransform2*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 40:
			// Execute: "push NumberBvr Vector2Bvr.length()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector2Bvr.length()");
			METHOD_CALL_1(
				(IDAVector2*)USE_COM(1),
				get_Length,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 41:
			// Execute: "push Vector2Bvr Vector2Bvr.mul(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.mul(NumberBvr)");
			METHOD_CALL_2(
				(IDAVector2*)USE_COM(1),
				MulAnim,
				(IDANumber*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 42:
			// Execute: "push Vector2Bvr Vector2Bvr.mul(double)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.mul(double)");
			METHOD_CALL_2(
				(IDAVector2*)USE_COM(1),
				Mul,
				USE_DOUBLE(1),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 43:
			// Execute: "push Vector2Bvr Vector2Bvr.div(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.div(NumberBvr)");
			METHOD_CALL_2(
				(IDAVector2*)USE_COM(1),
				DivAnim,
				(IDANumber*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 44:
			// Execute: "push Vector2Bvr Vector2Bvr.div(double)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.div(double)");
			METHOD_CALL_2(
				(IDAVector2*)USE_COM(1),
				Div,
				USE_DOUBLE(1),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 45:
			// Execute: "push NumberBvr Point3Bvr.getZ()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Point3Bvr.getZ()");
			METHOD_CALL_1(
				(IDAPoint3*)USE_COM(1),
				get_Z,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 46:
			// Execute: "push NumberBvr Point3Bvr.getX()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Point3Bvr.getX()");
			METHOD_CALL_1(
				(IDAPoint3*)USE_COM(1),
				get_X,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 47:
			// Execute: "push NumberBvr Point3Bvr.getY()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Point3Bvr.getY()");
			METHOD_CALL_1(
				(IDAPoint3*)USE_COM(1),
				get_Y,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 48:
			// Execute: "push Point3Bvr Point3Bvr.transform(Transform3Bvr)"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Point3Bvr.transform(Transform3Bvr)");
			METHOD_CALL_2(
				(IDAPoint3*)USE_COM(1),
				Transform,
				(IDATransform3*)USE_COM(2),
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 49:
			// Execute: "push NumberBvr Point2Bvr.getX()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Point2Bvr.getX()");
			METHOD_CALL_1(
				(IDAPoint2*)USE_COM(1),
				get_X,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 50:
			// Execute: "push NumberBvr Point2Bvr.getY()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Point2Bvr.getY()");
			METHOD_CALL_1(
				(IDAPoint2*)USE_COM(1),
				get_Y,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 51:
			// Execute: "push Point2Bvr Point2Bvr.transform(Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Point2Bvr.transform(Transform2Bvr)");
			METHOD_CALL_2(
				(IDAPoint2*)USE_COM(1),
				Transform,
				(IDATransform2*)USE_COM(2),
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 52:
			// Execute: "push Path2Bvr Path2Bvr.close()"
			// AUTOGENERATED
			instrTrace("push Path2Bvr Path2Bvr.close()");
			METHOD_CALL_1(
				(IDAPath2*)USE_COM(1),
				Close,
				(IDAPath2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 53:
			// Execute: "push ImageBvr Path2Bvr.draw(LineStyleBvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr Path2Bvr.draw(LineStyleBvr)");
			METHOD_CALL_2(
				(IDAPath2*)USE_COM(1),
				Draw,
				(IDALineStyle*)USE_COM(2),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 54:
			// Execute: "push ImageBvr Path2Bvr.fill(LineStyleBvr, ImageBvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr Path2Bvr.fill(LineStyleBvr, ImageBvr)");
			METHOD_CALL_3(
				(IDAPath2*)USE_COM(1),
				Fill,
				(IDALineStyle*)USE_COM(2),
				(IDAImage*)USE_COM(3),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 55:
			// Execute: "push Path2Bvr Path2Bvr.transform(Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push Path2Bvr Path2Bvr.transform(Transform2Bvr)");
			METHOD_CALL_2(
				(IDAPath2*)USE_COM(1),
				Transform,
				(IDATransform2*)USE_COM(2),
				(IDAPath2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 56:
			// Execute: "push Bbox2Bvr Path2Bvr.boundingBox(LineStyleBvr)"
			// AUTOGENERATED
			instrTrace("push Bbox2Bvr Path2Bvr.boundingBox(LineStyleBvr)");
			METHOD_CALL_2(
				(IDAPath2*)USE_COM(1),
				BoundingBox,
				(IDALineStyle*)USE_COM(2),
				(IDABbox2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 57:
			// Execute: "push MatteBvr MatteBvr.transform(Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push MatteBvr MatteBvr.transform(Transform2Bvr)");
			METHOD_CALL_2(
				(IDAMatte*)USE_COM(1),
				Transform,
				(IDATransform2*)USE_COM(2),
				(IDAMatte**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 58:
			// Execute: "push ImageBvr ImageBvr.clipPolygon(Point2Bvr[])"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.clipPolygon(Point2Bvr[])");
			METHOD_CALL_3(
				(IDAImage*)USE_COM(1),
				ClipPolygonImageEx,
				USE_COM_ARRAY_LENGTH(1),
				(IDAPoint2**)USE_COM_ARRAY(1),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM_ARRAY;
			PUSH_COM(RET_COM);
			break;
			
		case 59:
			// Execute: "push ImageBvr ImageBvr.crop(Point2Bvr, Point2Bvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.crop(Point2Bvr, Point2Bvr)");
			METHOD_CALL_3(
				(IDAImage*)USE_COM(1),
				Crop,
				(IDAPoint2*)USE_COM(2),
				(IDAPoint2*)USE_COM(3),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 60:
			// Execute: "push ImageBvr ImageBvr.opacity(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.opacity(NumberBvr)");
			METHOD_CALL_2(
				(IDAImage*)USE_COM(1),
				OpacityAnim,
				(IDANumber*)USE_COM(2),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 61:
			// Execute: "push ImageBvr ImageBvr.opacity(double)"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.opacity(double)");
			METHOD_CALL_2(
				(IDAImage*)USE_COM(1),
				Opacity,
				USE_DOUBLE(1),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 62:
			// Execute: "push ImageBvr ImageBvr.transform(Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.transform(Transform2Bvr)");
			METHOD_CALL_2(
				(IDAImage*)USE_COM(1),
				Transform,
				(IDATransform2*)USE_COM(2),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 63:
			// Execute: "push Bbox2Bvr ImageBvr.boundingBox()"
			// AUTOGENERATED
			instrTrace("push Bbox2Bvr ImageBvr.boundingBox()");
			METHOD_CALL_1(
				(IDAImage*)USE_COM(1),
				get_BoundingBox,
				(IDABbox2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 64:
			// Execute: "push ImageBvr ImageBvr.mapToUnitSquare()"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.mapToUnitSquare()");
			METHOD_CALL_1(
				(IDAImage*)USE_COM(1),
				MapToUnitSquare,
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 65:
			// Execute: "push ImageBvr ImageBvr.undetectable()"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.undetectable()");
			METHOD_CALL_1(
				(IDAImage*)USE_COM(1),
				Undetectable,
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 66:
			// Execute: "push GeometryBvr GeometryBvr.lightColor(ColorBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.lightColor(ColorBvr)");
			METHOD_CALL_2(
				(IDAGeometry*)USE_COM(1),
				LightColor,
				(IDAColor*)USE_COM(2),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 67:
			// Execute: "push GeometryBvr GeometryBvr.lightAttenuation(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.lightAttenuation(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				(IDAGeometry*)USE_COM(1),
				LightAttenuationAnim,
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDANumber*)USE_COM(4),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 68:
			// Execute: "push GeometryBvr GeometryBvr.opacity(double)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.opacity(double)");
			METHOD_CALL_2(
				(IDAGeometry*)USE_COM(1),
				Opacity,
				USE_DOUBLE(1),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 69:
			// Execute: "push GeometryBvr GeometryBvr.opacity(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.opacity(NumberBvr)");
			METHOD_CALL_2(
				(IDAGeometry*)USE_COM(1),
				OpacityAnim,
				(IDANumber*)USE_COM(2),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 70:
			// Execute: "push GeometryBvr GeometryBvr.lightAttenuation(double, double, double)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.lightAttenuation(double, double, double)");
			METHOD_CALL_4(
				(IDAGeometry*)USE_COM(1),
				LightAttenuation,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 71:
			// Execute: "push GeometryBvr GeometryBvr.diffuseColor(ColorBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.diffuseColor(ColorBvr)");
			METHOD_CALL_2(
				(IDAGeometry*)USE_COM(1),
				DiffuseColor,
				(IDAColor*)USE_COM(2),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 72:
			// Execute: "push GeometryBvr GeometryBvr.texture(ImageBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.texture(ImageBvr)");
			METHOD_CALL_2(
				(IDAGeometry*)USE_COM(1),
				Texture,
				(IDAImage*)USE_COM(2),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 73:
			// Execute: "push Statics.mousePosition"
			// AUTOGENERATED
			instrTrace("push Statics.mousePosition");
			METHOD_CALL_1(
				staticStatics,
				get_MousePosition,
				(IDAPoint2**)PUSH_COM_ADDR
			);
			break;
			
		case 74:
			// Execute: "push Statics.leftButtonState"
			// AUTOGENERATED
			instrTrace("push Statics.leftButtonState");
			METHOD_CALL_1(
				staticStatics,
				get_LeftButtonState,
				(IDABoolean**)PUSH_COM_ADDR
			);
			break;
			
		case 75:
			// Execute: "push Statics.rightButtonState"
			// AUTOGENERATED
			instrTrace("push Statics.rightButtonState");
			METHOD_CALL_1(
				staticStatics,
				get_RightButtonState,
				(IDABoolean**)PUSH_COM_ADDR
			);
			break;
			
		case 76:
			// Execute: "push Statics.trueBvr"
			// AUTOGENERATED
			instrTrace("push Statics.trueBvr");
			METHOD_CALL_1(
				staticStatics,
				get_DATrue,
				(IDABoolean**)PUSH_COM_ADDR
			);
			break;
			
		case 77:
			// Execute: "push Statics.falseBvr"
			// AUTOGENERATED
			instrTrace("push Statics.falseBvr");
			METHOD_CALL_1(
				staticStatics,
				get_DAFalse,
				(IDABoolean**)PUSH_COM_ADDR
			);
			break;
			
		case 78:
			// Execute: "push Statics.localTime"
			// AUTOGENERATED
			instrTrace("push Statics.localTime");
			METHOD_CALL_1(
				staticStatics,
				get_LocalTime,
				(IDANumber**)PUSH_COM_ADDR
			);
			break;
			
		case 79:
			// Execute: "push Statics.globalTime"
			// AUTOGENERATED
			instrTrace("push Statics.globalTime");
			METHOD_CALL_1(
				staticStatics,
				get_GlobalTime,
				(IDANumber**)PUSH_COM_ADDR
			);
			break;
			
		case 80:
			// Execute: "push Statics.pixel"
			// AUTOGENERATED
			instrTrace("push Statics.pixel");
			METHOD_CALL_1(
				staticStatics,
				get_Pixel,
				(IDANumber**)PUSH_COM_ADDR
			);
			break;
			
		case 81:
			// Execute: "push Statics.red"
			// AUTOGENERATED
			instrTrace("push Statics.red");
			METHOD_CALL_1(
				staticStatics,
				get_Red,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 82:
			// Execute: "push Statics.green"
			// AUTOGENERATED
			instrTrace("push Statics.green");
			METHOD_CALL_1(
				staticStatics,
				get_Green,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 83:
			// Execute: "push Statics.blue"
			// AUTOGENERATED
			instrTrace("push Statics.blue");
			METHOD_CALL_1(
				staticStatics,
				get_Blue,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 84:
			// Execute: "push Statics.cyan"
			// AUTOGENERATED
			instrTrace("push Statics.cyan");
			METHOD_CALL_1(
				staticStatics,
				get_Cyan,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 85:
			// Execute: "push Statics.magenta"
			// AUTOGENERATED
			instrTrace("push Statics.magenta");
			METHOD_CALL_1(
				staticStatics,
				get_Magenta,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 86:
			// Execute: "push Statics.yellow"
			// AUTOGENERATED
			instrTrace("push Statics.yellow");
			METHOD_CALL_1(
				staticStatics,
				get_Yellow,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 87:
			// Execute: "push Statics.black"
			// AUTOGENERATED
			instrTrace("push Statics.black");
			METHOD_CALL_1(
				staticStatics,
				get_Black,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 88:
			// Execute: "push Statics.white"
			// AUTOGENERATED
			instrTrace("push Statics.white");
			METHOD_CALL_1(
				staticStatics,
				get_White,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 89:
			// Execute: "push Statics.leftButtonDown"
			// AUTOGENERATED
			instrTrace("push Statics.leftButtonDown");
			METHOD_CALL_1(
				staticStatics,
				get_LeftButtonDown,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 90:
			// Execute: "push Statics.leftButtonUp"
			// AUTOGENERATED
			instrTrace("push Statics.leftButtonUp");
			METHOD_CALL_1(
				staticStatics,
				get_LeftButtonUp,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 91:
			// Execute: "push Statics.rightButtonDown"
			// AUTOGENERATED
			instrTrace("push Statics.rightButtonDown");
			METHOD_CALL_1(
				staticStatics,
				get_RightButtonDown,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 92:
			// Execute: "push Statics.rightButtonUp"
			// AUTOGENERATED
			instrTrace("push Statics.rightButtonUp");
			METHOD_CALL_1(
				staticStatics,
				get_RightButtonUp,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 93:
			// Execute: "push Statics.always"
			// AUTOGENERATED
			instrTrace("push Statics.always");
			METHOD_CALL_1(
				staticStatics,
				get_Always,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 94:
			// Execute: "push Statics.never"
			// AUTOGENERATED
			instrTrace("push Statics.never");
			METHOD_CALL_1(
				staticStatics,
				get_Never,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 95:
			// Execute: "push Statics.emptyGeometry"
			// AUTOGENERATED
			instrTrace("push Statics.emptyGeometry");
			METHOD_CALL_1(
				staticStatics,
				get_EmptyGeometry,
				(IDAGeometry**)PUSH_COM_ADDR
			);
			break;
			
		case 96:
			// Execute: "push Statics.emptyImage"
			// AUTOGENERATED
			instrTrace("push Statics.emptyImage");
			METHOD_CALL_1(
				staticStatics,
				get_EmptyImage,
				(IDAImage**)PUSH_COM_ADDR
			);
			break;
			
		case 97:
			// Execute: "push Statics.detectableEmptyImage"
			// AUTOGENERATED
			instrTrace("push Statics.detectableEmptyImage");
			METHOD_CALL_1(
				staticStatics,
				get_DetectableEmptyImage,
				(IDAImage**)PUSH_COM_ADDR
			);
			break;
			
		case 98:
			// Execute: "push Statics.ambientLight"
			// AUTOGENERATED
			instrTrace("push Statics.ambientLight");
			METHOD_CALL_1(
				staticStatics,
				get_AmbientLight,
				(IDAGeometry**)PUSH_COM_ADDR
			);
			break;
			
		case 99:
			// Execute: "push Statics.directionalLight"
			// AUTOGENERATED
			instrTrace("push Statics.directionalLight");
			METHOD_CALL_1(
				staticStatics,
				get_DirectionalLight,
				(IDAGeometry**)PUSH_COM_ADDR
			);
			break;
			
		case 100:
			// Execute: "push Statics.pointLight"
			// AUTOGENERATED
			instrTrace("push Statics.pointLight");
			METHOD_CALL_1(
				staticStatics,
				get_PointLight,
				(IDAGeometry**)PUSH_COM_ADDR
			);
			break;
			
		case 101:
			// Execute: "push Statics.defaultLineStyle"
			// AUTOGENERATED
			instrTrace("push Statics.defaultLineStyle");
			METHOD_CALL_1(
				staticStatics,
				get_DefaultLineStyle,
				(IDALineStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 102:
			// Execute: "push Statics.emptyLineStyle"
			// AUTOGENERATED
			instrTrace("push Statics.emptyLineStyle");
			METHOD_CALL_1(
				staticStatics,
				get_EmptyLineStyle,
				(IDALineStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 103:
			// Execute: "push Statics.joinStyleBevel"
			// AUTOGENERATED
			instrTrace("push Statics.joinStyleBevel");
			METHOD_CALL_1(
				staticStatics,
				get_JoinStyleBevel,
				(IDAJoinStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 104:
			// Execute: "push Statics.joinStyleRound"
			// AUTOGENERATED
			instrTrace("push Statics.joinStyleRound");
			METHOD_CALL_1(
				staticStatics,
				get_JoinStyleRound,
				(IDAJoinStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 105:
			// Execute: "push Statics.joinStyleMiter"
			// AUTOGENERATED
			instrTrace("push Statics.joinStyleMiter");
			METHOD_CALL_1(
				staticStatics,
				get_JoinStyleMiter,
				(IDAJoinStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 106:
			// Execute: "push Statics.endStyleFlat"
			// AUTOGENERATED
			instrTrace("push Statics.endStyleFlat");
			METHOD_CALL_1(
				staticStatics,
				get_EndStyleFlat,
				(IDAEndStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 107:
			// Execute: "push Statics.endStyleSquare"
			// AUTOGENERATED
			instrTrace("push Statics.endStyleSquare");
			METHOD_CALL_1(
				staticStatics,
				get_EndStyleSquare,
				(IDAEndStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 108:
			// Execute: "push Statics.endStyleRound"
			// AUTOGENERATED
			instrTrace("push Statics.endStyleRound");
			METHOD_CALL_1(
				staticStatics,
				get_EndStyleRound,
				(IDAEndStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 109:
			// Execute: "push Statics.dashStyleSolid"
			// AUTOGENERATED
			instrTrace("push Statics.dashStyleSolid");
			METHOD_CALL_1(
				staticStatics,
				get_DashStyleSolid,
				(IDADashStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 110:
			// Execute: "push Statics.dashStyleDashed"
			// AUTOGENERATED
			instrTrace("push Statics.dashStyleDashed");
			METHOD_CALL_1(
				staticStatics,
				get_DashStyleDashed,
				(IDADashStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 111:
			// Execute: "push Statics.defaultMicrophone"
			// AUTOGENERATED
			instrTrace("push Statics.defaultMicrophone");
			METHOD_CALL_1(
				staticStatics,
				get_DefaultMicrophone,
				(IDAMicrophone**)PUSH_COM_ADDR
			);
			break;
			
		case 112:
			// Execute: "push Statics.opaqueMatte"
			// AUTOGENERATED
			instrTrace("push Statics.opaqueMatte");
			METHOD_CALL_1(
				staticStatics,
				get_OpaqueMatte,
				(IDAMatte**)PUSH_COM_ADDR
			);
			break;
			
		case 113:
			// Execute: "push Statics.clearMatte"
			// AUTOGENERATED
			instrTrace("push Statics.clearMatte");
			METHOD_CALL_1(
				staticStatics,
				get_ClearMatte,
				(IDAMatte**)PUSH_COM_ADDR
			);
			break;
			
		case 114:
			// Execute: "push Statics.emptyMontage"
			// AUTOGENERATED
			instrTrace("push Statics.emptyMontage");
			METHOD_CALL_1(
				staticStatics,
				get_EmptyMontage,
				(IDAMontage**)PUSH_COM_ADDR
			);
			break;
			
		case 115:
			// Execute: "push Statics.silence"
			// AUTOGENERATED
			instrTrace("push Statics.silence");
			METHOD_CALL_1(
				staticStatics,
				get_Silence,
				(IDASound**)PUSH_COM_ADDR
			);
			break;
			
		case 116:
			// Execute: "push Statics.sinSynth"
			// AUTOGENERATED
			instrTrace("push Statics.sinSynth");
			METHOD_CALL_1(
				staticStatics,
				get_SinSynth,
				(IDASound**)PUSH_COM_ADDR
			);
			break;
			
		case 117:
			// Execute: "push Statics.defaultFont"
			// AUTOGENERATED
			instrTrace("push Statics.defaultFont");
			METHOD_CALL_1(
				staticStatics,
				get_DefaultFont,
				(IDAFontStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 118:
			// Execute: "push Statics.xVector2"
			// AUTOGENERATED
			instrTrace("push Statics.xVector2");
			METHOD_CALL_1(
				staticStatics,
				get_XVector2,
				(IDAVector2**)PUSH_COM_ADDR
			);
			break;
			
		case 119:
			// Execute: "push Statics.yVector2"
			// AUTOGENERATED
			instrTrace("push Statics.yVector2");
			METHOD_CALL_1(
				staticStatics,
				get_YVector2,
				(IDAVector2**)PUSH_COM_ADDR
			);
			break;
			
		case 120:
			// Execute: "push Statics.zeroVector2"
			// AUTOGENERATED
			instrTrace("push Statics.zeroVector2");
			METHOD_CALL_1(
				staticStatics,
				get_ZeroVector2,
				(IDAVector2**)PUSH_COM_ADDR
			);
			break;
			
		case 121:
			// Execute: "push Statics.origin2"
			// AUTOGENERATED
			instrTrace("push Statics.origin2");
			METHOD_CALL_1(
				staticStatics,
				get_Origin2,
				(IDAPoint2**)PUSH_COM_ADDR
			);
			break;
			
		case 122:
			// Execute: "push Statics.xVector3"
			// AUTOGENERATED
			instrTrace("push Statics.xVector3");
			METHOD_CALL_1(
				staticStatics,
				get_XVector3,
				(IDAVector3**)PUSH_COM_ADDR
			);
			break;
			
		case 123:
			// Execute: "push Statics.yVector3"
			// AUTOGENERATED
			instrTrace("push Statics.yVector3");
			METHOD_CALL_1(
				staticStatics,
				get_YVector3,
				(IDAVector3**)PUSH_COM_ADDR
			);
			break;
			
		case 124:
			// Execute: "push Statics.zVector3"
			// AUTOGENERATED
			instrTrace("push Statics.zVector3");
			METHOD_CALL_1(
				staticStatics,
				get_ZVector3,
				(IDAVector3**)PUSH_COM_ADDR
			);
			break;
			
		case 125:
			// Execute: "push Statics.zeroVector3"
			// AUTOGENERATED
			instrTrace("push Statics.zeroVector3");
			METHOD_CALL_1(
				staticStatics,
				get_ZeroVector3,
				(IDAVector3**)PUSH_COM_ADDR
			);
			break;
			
		case 126:
			// Execute: "push Statics.origin3"
			// AUTOGENERATED
			instrTrace("push Statics.origin3");
			METHOD_CALL_1(
				staticStatics,
				get_Origin3,
				(IDAPoint3**)PUSH_COM_ADDR
			);
			break;
			
		case 127:
			// Execute: "push Statics.identityTransform3"
			// AUTOGENERATED
			instrTrace("push Statics.identityTransform3");
			METHOD_CALL_1(
				staticStatics,
				get_IdentityTransform3,
				(IDATransform3**)PUSH_COM_ADDR
			);
			break;
			
		case 128:
			// Execute: "push Statics.identityTransform2"
			// AUTOGENERATED
			instrTrace("push Statics.identityTransform2");
			METHOD_CALL_1(
				staticStatics,
				get_IdentityTransform2,
				(IDATransform2**)PUSH_COM_ADDR
			);
			break;
			
		case 129:
			// Execute: "push NumberBvr Statics.distance(Point2Bvr, Point2Bvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.distance(Point2Bvr, Point2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				DistancePoint2,
				(IDAPoint2*)USE_COM(1),
				(IDAPoint2*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 130:
			// Execute: "push NumberBvr Statics.distance(Point3Bvr, Point3Bvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.distance(Point3Bvr, Point3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				DistancePoint3,
				(IDAPoint3*)USE_COM(1),
				(IDAPoint3*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 131:
			// Execute: "push ImageBvr Statics.solidColorImage(ColorBvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr Statics.solidColorImage(ColorBvr)");
			METHOD_CALL_2(
				staticStatics,
				SolidColorImage,
				(IDAColor*)USE_COM(1),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 132:
			// Execute: "push SoundBvr Statics.mix(SoundBvr, SoundBvr)"
			// AUTOGENERATED
			instrTrace("push SoundBvr Statics.mix(SoundBvr, SoundBvr)");
			METHOD_CALL_3(
				staticStatics,
				Mix,
				(IDASound*)USE_COM(1),
				(IDASound*)USE_COM(2),
				(IDASound**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 133:
			// Execute: "push Behavior Statics.untilEx(Behavior, DXMEvent)"
			// AUTOGENERATED
			instrTrace("push Behavior Statics.untilEx(Behavior, DXMEvent)");
			METHOD_CALL_3(
				staticStatics,
				UntilEx,
				(IDABehavior*)USE_COM(1),
				(IDAEvent*)USE_COM(2),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 134:
			// Execute: "push ColorBvr Statics.colorRgb(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push ColorBvr Statics.colorRgb(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				ColorRgbAnim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDAColor**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 135:
			// Execute: "push ColorBvr Statics.colorRgb(double, double, double)"
			// AUTOGENERATED
			instrTrace("push ColorBvr Statics.colorRgb(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				ColorRgb,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDAColor**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 136:
			// Execute: "push Transform3Bvr Statics.compose(Transform3Bvr, Transform3Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.compose(Transform3Bvr, Transform3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				Compose3,
				(IDATransform3*)USE_COM(1),
				(IDATransform3*)USE_COM(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 137:
			// Execute: "push Transform2Bvr Statics.compose(Transform2Bvr, Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.compose(Transform2Bvr, Transform2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				Compose2,
				(IDATransform2*)USE_COM(1),
				(IDATransform2*)USE_COM(2),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 138:
			// Execute: "push NumberBvr Statics.floor(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.floor(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Floor,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 139:
			// Execute: "push Transform2Bvr Statics.scale2(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.scale2(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Scale2UniformAnim,
				(IDANumber*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 140:
			// Execute: "push Transform2Bvr Statics.scale2(double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.scale2(double)");
			METHOD_CALL_2(
				staticStatics,
				Scale2Uniform,
				USE_DOUBLE(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 141:
			// Execute: "push NumberBvr Statics.ceiling(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.ceiling(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Ceiling,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 142:
			// Execute: "push NumberBvr Statics.ln(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.ln(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Ln,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 143:
			// Execute: "push ImageBvr Statics.overlay(ImageBvr, ImageBvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr Statics.overlay(ImageBvr, ImageBvr)");
			METHOD_CALL_3(
				staticStatics,
				Overlay,
				(IDAImage*)USE_COM(1),
				(IDAImage*)USE_COM(2),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 144:
			// Execute: "push BooleanBvr Statics.gte(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.gte(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				GTE,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 145:
			// Execute: "push NumberBvr Statics.radiansToDegrees(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.radiansToDegrees(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				ToRadians,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 146:
			// Execute: "push Transform3Bvr Statics.scale3(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.scale3(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Scale3UniformAnim,
				(IDANumber*)USE_COM(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 147:
			// Execute: "push Transform3Bvr Statics.scale3(double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.scale3(double)");
			METHOD_CALL_2(
				staticStatics,
				Scale3Uniform,
				USE_DOUBLE(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 148:
			// Execute: "push NumberBvr Statics.toBvr(double)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.toBvr(double)");
			METHOD_CALL_2(
				staticStatics,
				DANumber,
				USE_DOUBLE(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 149:
			// Execute: "push DXMEvent Statics.keyUp(int)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.keyUp(int)");
			METHOD_CALL_2(
				staticStatics,
				KeyUp,
				USE_LONG(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_LONG(1);
			PUSH_COM(RET_COM);
			break;
			
		case 150:
			// Execute: "push BooleanBvr Statics.toBvr(boolean)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.toBvr(boolean)");
			METHOD_CALL_2(
				staticStatics,
				DABoolean,
				USE_LONG_AS_BOOL(1),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_LONG(1);
			PUSH_COM(RET_COM);
			break;
			
		case 151:
			// Execute: "push BooleanBvr Statics.or(BooleanBvr, BooleanBvr)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.or(BooleanBvr, BooleanBvr)");
			METHOD_CALL_3(
				staticStatics,
				Or,
				(IDABoolean*)USE_COM(1),
				(IDABoolean*)USE_COM(2),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 152:
			// Execute: "push NumberBvr Statics.mul(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.mul(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Mul,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 153:
			// Execute: "push BooleanBvr Statics.not(BooleanBvr)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.not(BooleanBvr)");
			METHOD_CALL_2(
				staticStatics,
				Not,
				(IDABoolean*)USE_COM(1),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 154:
			// Execute: "push Vector3Bvr Statics.cross(Vector3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.cross(Vector3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				CrossVector3,
				(IDAVector3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 155:
			// Execute: "push NumberBvr Statics.dot(Vector2Bvr, Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.dot(Vector2Bvr, Vector2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				DotVector2,
				(IDAVector2*)USE_COM(1),
				(IDAVector2*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 156:
			// Execute: "push NumberBvr Statics.dot(Vector3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.dot(Vector3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				DotVector3,
				(IDAVector3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 157:
			// Execute: "push BooleanBvr Statics.and(BooleanBvr, BooleanBvr)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.and(BooleanBvr, BooleanBvr)");
			METHOD_CALL_3(
				staticStatics,
				And,
				(IDABoolean*)USE_COM(1),
				(IDABoolean*)USE_COM(2),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 158:
			// Execute: "push NumberBvr Statics.add(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.add(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Add,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 159:
			// Execute: "push Vector2Bvr Statics.add(Vector2Bvr, Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.add(Vector2Bvr, Vector2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				AddVector2,
				(IDAVector2*)USE_COM(1),
				(IDAVector2*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 160:
			// Execute: "push Point2Bvr Statics.add(Point2Bvr, Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Statics.add(Point2Bvr, Vector2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				AddPoint2Vector,
				(IDAPoint2*)USE_COM(1),
				(IDAVector2*)USE_COM(2),
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 161:
			// Execute: "push Vector3Bvr Statics.add(Vector3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.add(Vector3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				AddVector3,
				(IDAVector3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 162:
			// Execute: "push Point3Bvr Statics.add(Point3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Statics.add(Point3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				AddPoint3Vector,
				(IDAPoint3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 163:
			// Execute: "push NumberBvr Statics.sqrt(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.sqrt(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Sqrt,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 164:
			// Execute: "push Behavior Statics.sequence(Behavior, Behavior)"
			// AUTOGENERATED
			instrTrace("push Behavior Statics.sequence(Behavior, Behavior)");
			METHOD_CALL_3(
				staticStatics,
				Sequence,
				(IDABehavior*)USE_COM(1),
				(IDABehavior*)USE_COM(2),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 165:
			// Execute: "push Transform3Bvr Statics.xShear(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.xShear(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				XShear3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 166:
			// Execute: "push Transform3Bvr Statics.xShear(double, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.xShear(double, double)");
			METHOD_CALL_3(
				staticStatics,
				XShear3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 167:
			// Execute: "push Transform3Bvr Statics.zShear(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.zShear(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				ZShear3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 168:
			// Execute: "push Transform3Bvr Statics.zShear(double, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.zShear(double, double)");
			METHOD_CALL_3(
				staticStatics,
				ZShear3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 169:
			// Execute: "push Transform2Bvr Statics.xShear(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.xShear(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				XShear2Anim,
				(IDANumber*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 170:
			// Execute: "push NumberBvr Statics.degreesToRadians(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.degreesToRadians(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				ToRadians,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 171:
			// Execute: "push Transform2Bvr Statics.xShear(double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.xShear(double)");
			METHOD_CALL_2(
				staticStatics,
				XShear2,
				USE_DOUBLE(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 172:
			// Execute: "push NumberBvr Statics.div(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.div(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Div,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 173:
			// Execute: "push DXMEvent Statics.keyDown(int)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.keyDown(int)");
			METHOD_CALL_2(
				staticStatics,
				KeyDown,
				USE_LONG(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_LONG(1);
			PUSH_COM(RET_COM);
			break;
			
		case 174:
			// Execute: "push Vector2Bvr Statics.vector2(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.vector2(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Vector2Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 175:
			// Execute: "push Vector2Bvr Statics.vector2(double, double)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.vector2(double, double)");
			METHOD_CALL_3(
				staticStatics,
				Vector2,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 176:
			// Execute: "push DXMEvent Statics.notEvent(DXMEvent)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.notEvent(DXMEvent)");
			METHOD_CALL_2(
				staticStatics,
				NotEvent,
				(IDAEvent*)USE_COM(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 177:
			// Execute: "push Vector3Bvr Statics.vector3(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.vector3(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				Vector3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 178:
			// Execute: "push Vector3Bvr Statics.vector3(double, double, double)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.vector3(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				Vector3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 179:
			// Execute: "push ColorBvr Statics.colorHsl(double, double, double)"
			// AUTOGENERATED
			instrTrace("push ColorBvr Statics.colorHsl(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				ColorHsl,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDAColor**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 180:
			// Execute: "push ColorBvr Statics.colorHsl(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push ColorBvr Statics.colorHsl(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				ColorHslAnim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDAColor**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 181:
			// Execute: "push Path2Bvr Statics.line(Point2Bvr, Point2Bvr)"
			// AUTOGENERATED
			instrTrace("push Path2Bvr Statics.line(Point2Bvr, Point2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				Line,
				(IDAPoint2*)USE_COM(1),
				(IDAPoint2*)USE_COM(2),
				(IDAPath2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 182:
			// Execute: "push Point2Bvr Statics.point2(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Statics.point2(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Point2Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 183:
			// Execute: "push Point2Bvr Statics.point2(double, double)"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Statics.point2(double, double)");
			METHOD_CALL_3(
				staticStatics,
				Point2,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 184:
			// Execute: "push DXMEvent Statics.timer(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.timer(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				TimerAnim,
				(IDANumber*)USE_COM(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 185:
			// Execute: "push DXMEvent Statics.timer(double)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.timer(double)");
			METHOD_CALL_2(
				staticStatics,
				Timer,
				USE_DOUBLE(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 186:
			// Execute: "push Point3Bvr Statics.point3(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Statics.point3(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				Point3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 187:
			// Execute: "push Point3Bvr Statics.point3(double, double, double)"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Statics.point3(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				Point3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 188:
			// Execute: "push NumberBvr Statics.cos(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.cos(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Cos,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 189:
			// Execute: "push BooleanBvr Statics.lt(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.lt(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				LT,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 190:
			// Execute: "push NumberBvr Statics.neg(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.neg(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Neg,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 191:
			// Execute: "push Vector2Bvr Statics.neg(Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.neg(Vector2Bvr)");
			METHOD_CALL_2(
				staticStatics,
				NegVector2,
				(IDAVector2*)USE_COM(1),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 192:
			// Execute: "push Vector3Bvr Statics.neg(Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.neg(Vector3Bvr)");
			METHOD_CALL_2(
				staticStatics,
				NegVector3,
				(IDAVector3*)USE_COM(1),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 193:
			// Execute: "push Transform3Bvr Statics.translate(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.translate(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				Translate3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 194:
			// Execute: "push Transform3Bvr Statics.translate(double, double, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.translate(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				Translate3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 195:
			// Execute: "push Transform3Bvr Statics.translate(Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.translate(Vector3Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Translate3Vector,
				(IDAVector3*)USE_COM(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 196:
			// Execute: "push Transform3Bvr Statics.translate(Point3Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.translate(Point3Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Translate3Point,
				(IDAPoint3*)USE_COM(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 197:
			// Execute: "push Transform3Bvr Statics.rotate(Vector3Bvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.rotate(Vector3Bvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Rotate3Anim,
				(IDAVector3*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 198:
			// Execute: "push Transform3Bvr Statics.rotate(Vector3Bvr, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.rotate(Vector3Bvr, double)");
			METHOD_CALL_3(
				staticStatics,
				Rotate3,
				(IDAVector3*)USE_COM(1),
				USE_DOUBLE(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 199:
			// Execute: "push Transform2Bvr Statics.translate(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.translate(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Translate2Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 200:
			// Execute: "push Transform2Bvr Statics.translate(double, double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.translate(double, double)");
			METHOD_CALL_3(
				staticStatics,
				Translate2,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 201:
			// Execute: "push Transform2Bvr Statics.translate(Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.translate(Vector2Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Translate2Vector,
				(IDAVector2*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 202:
			// Execute: "push Transform2Bvr Statics.translate(Point2Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.translate(Point2Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Translate2Point,
				(IDAPoint2*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 203:
			// Execute: "push Transform2Bvr Statics.rotate(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.rotate(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Rotate2Anim,
				(IDANumber*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 204:
			// Execute: "push Transform2Bvr Statics.rotate(double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.rotate(double)");
			METHOD_CALL_2(
				staticStatics,
				Rotate2,
				USE_DOUBLE(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 205:
			// Execute: "push NumberBvr Statics.sub(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.sub(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Sub,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 206:
			// Execute: "push Behavior Statics.until(Behavior, DXMEvent, Behavior)"
			// AUTOGENERATED
			instrTrace("push Behavior Statics.until(Behavior, DXMEvent, Behavior)");
			METHOD_CALL_4(
				staticStatics,
				Until,
				(IDABehavior*)USE_COM(1),
				(IDAEvent*)USE_COM(2),
				(IDABehavior*)USE_COM(3),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 207:
			// Execute: "push Vector2Bvr Statics.sub(Vector2Bvr, Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.sub(Vector2Bvr, Vector2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubVector2,
				(IDAVector2*)USE_COM(1),
				(IDAVector2*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 208:
			// Execute: "push Point2Bvr Statics.sub(Point2Bvr, Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Statics.sub(Point2Bvr, Vector2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubPoint2Vector,
				(IDAPoint2*)USE_COM(1),
				(IDAVector2*)USE_COM(2),
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 209:
			// Execute: "push Vector2Bvr Statics.sub(Point2Bvr, Point2Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.sub(Point2Bvr, Point2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubPoint2,
				(IDAPoint2*)USE_COM(1),
				(IDAPoint2*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 210:
			// Execute: "push Vector3Bvr Statics.sub(Vector3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.sub(Vector3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubVector3,
				(IDAVector3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 211:
			// Execute: "push Point3Bvr Statics.sub(Point3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Statics.sub(Point3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubPoint3Vector,
				(IDAPoint3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 212:
			// Execute: "push Vector3Bvr Statics.sub(Point3Bvr, Point3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.sub(Point3Bvr, Point3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubPoint3,
				(IDAPoint3*)USE_COM(1),
				(IDAPoint3*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 213:
			// Execute: "push GeometryBvr Statics.union(GeometryBvr, GeometryBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr Statics.union(GeometryBvr, GeometryBvr)");
			METHOD_CALL_3(
				staticStatics,
				UnionGeometry,
				(IDAGeometry*)USE_COM(1),
				(IDAGeometry*)USE_COM(2),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 214:
			// Execute: "push MatteBvr Statics.union(MatteBvr, MatteBvr)"
			// AUTOGENERATED
			instrTrace("push MatteBvr Statics.union(MatteBvr, MatteBvr)");
			METHOD_CALL_3(
				staticStatics,
				UnionMatte,
				(IDAMatte*)USE_COM(1),
				(IDAMatte*)USE_COM(2),
				(IDAMatte**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 215:
			// Execute: "push MontageBvr Statics.union(MontageBvr, MontageBvr)"
			// AUTOGENERATED
			instrTrace("push MontageBvr Statics.union(MontageBvr, MontageBvr)");
			METHOD_CALL_3(
				staticStatics,
				UnionMontage,
				(IDAMontage*)USE_COM(1),
				(IDAMontage*)USE_COM(2),
				(IDAMontage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 216:
			// Execute: "push NumberBvr Statics.abs(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.abs(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Abs,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 217:
			// Execute: "push DXMEvent Statics.thenEvent(DXMEvent, DXMEvent)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.thenEvent(DXMEvent, DXMEvent)");
			METHOD_CALL_3(
				staticStatics,
				ThenEvent,
				(IDAEvent*)USE_COM(1),
				(IDAEvent*)USE_COM(2),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 218:
			// Execute: "push NumberBvr Statics.round(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.round(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Round,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 219:
			// Execute: "push DXMEvent Statics.andEvent(DXMEvent, DXMEvent)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.andEvent(DXMEvent, DXMEvent)");
			METHOD_CALL_3(
				staticStatics,
				AndEvent,
				(IDAEvent*)USE_COM(1),
				(IDAEvent*)USE_COM(2),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 220:
			// Execute: "push DXMEvent Statics.orEvent(DXMEvent, DXMEvent)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.orEvent(DXMEvent, DXMEvent)");
			METHOD_CALL_3(
				staticStatics,
				OrEvent,
				(IDAEvent*)USE_COM(1),
				(IDAEvent*)USE_COM(2),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 221:
			// Execute: "push DXMEvent Statics.predicate(BooleanBvr)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.predicate(BooleanBvr)");
			METHOD_CALL_2(
				staticStatics,
				Predicate,
				(IDABoolean*)USE_COM(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 222:
			// Execute: "push NumberBvr Statics.mod(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.mod(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Mod,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 223:
			// Execute: "push ColorBvr Statics.colorRgb255(short, short, short)"
			// AUTOGENERATED
			instrTrace("push ColorBvr Statics.colorRgb255(short, short, short)");
			METHOD_CALL_4(
				staticStatics,
				ColorRgb255,
				(short)USE_LONG(1),
				(short)USE_LONG(2),
				(short)USE_LONG(3),
				(IDAColor**)RET_COM_ADDR
			);
			FREE_LONG(3);
			PUSH_COM(RET_COM);
			break;
			
		case 224:
			// Execute: "push Transform3Bvr Statics.scale(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.scale(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				Scale3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 225:
			// Execute: "push Transform3Bvr Statics.scale(double, double, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.scale(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				Scale3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 226:
			// Execute: "push Transform3Bvr Statics.scale(Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.scale(Vector3Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Scale3Vector,
				(IDAVector3*)USE_COM(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 227:
			// Execute: "push Transform2Bvr Statics.scale(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.scale(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Scale2Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 228:
			// Execute: "push Transform2Bvr Statics.scale(double, double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.scale(double, double)");
			METHOD_CALL_3(
				staticStatics,
				Scale2,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 229:
			// Execute: "push Transform2Bvr Statics.scale(Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.scale(Vector2Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Scale2Vector,
				(IDAVector2*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 230:
			// Execute: "push ImageBvr PickableImage.getImageBvr()"
			// AUTOGENERATED
			instrTrace("push ImageBvr PickableImage.getImageBvr()");
			METHOD_CALL_1(
				(IDAPickableResult*)USE_COM(1),
				get_Image,
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 231:
			// Execute: "push DXMEvent PickableImage.getPickEvent()"
			// AUTOGENERATED
			instrTrace("push DXMEvent PickableImage.getPickEvent()");
			METHOD_CALL_1(
				(IDAPickableResult*)USE_COM(1),
				get_PickEvent,
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 232:
			// Execute: "push DXMEvent PickableGeometry.getPickEvent()"
			// AUTOGENERATED
			instrTrace("push DXMEvent PickableGeometry.getPickEvent()");
			METHOD_CALL_1(
				(IDAPickableResult*)USE_COM(1),
				get_PickEvent,
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 233:
			// Execute: "push GeometryBvr PickableGeometry.getGeometryBvr()"
			// AUTOGENERATED
			instrTrace("push GeometryBvr PickableGeometry.getGeometryBvr()");
			METHOD_CALL_1(
				(IDAPickableResult*)USE_COM(1),
				get_Geometry,
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 234:
			// Execute: "push PickableGeometry GeometryBvr.pickableOccluded()"
			// AUTOGENERATED
			instrTrace("push PickableGeometry GeometryBvr.pickableOccluded()");
			METHOD_CALL_1(
				(IDAGeometry*)USE_COM(1),
				PickableOccluded,
				(IDAPickableResult**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 235:
			// Execute: "push PickableGeometry GeometryBvr.pickable()"
			// AUTOGENERATED
			instrTrace("push PickableGeometry GeometryBvr.pickable()");
			METHOD_CALL_1(
				(IDAGeometry*)USE_COM(1),
				Pickable,
				(IDAPickableResult**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 236:
			// Execute: "push PickableImage ImageBvr.pickableOccluded()"
			// AUTOGENERATED
			instrTrace("push PickableImage ImageBvr.pickableOccluded()");
			METHOD_CALL_1(
				(IDAImage*)USE_COM(1),
				PickableOccluded,
				(IDAPickableResult**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 237:
			// Execute: "push PickableImage ImageBvr.pickable()"
			// AUTOGENERATED
			instrTrace("push PickableImage ImageBvr.pickable()");
			METHOD_CALL_1(
				(IDAImage*)USE_COM(1),
				Pickable,
				(IDAPickableResult**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 238:
			// Execute: "push NumberBvr Statics.sin(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.sin(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Sin,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 239:
			// Execute: "push Transform3Bvr Statics.yShear(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.yShear(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				YShear3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 240:
			// Execute: "push Transform3Bvr Statics.yShear(double, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.yShear(double, double)");
			METHOD_CALL_3(
				staticStatics,
				YShear3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 241:
			// Execute: "push Transform2Bvr Statics.yShear(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.yShear(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				YShear2Anim,
				(IDANumber*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 242:
			// Execute: "push Transform2Bvr Statics.yShear(double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.yShear(double)");
			METHOD_CALL_2(
				staticStatics,
				YShear2,
				USE_DOUBLE(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 243:
			// Execute: "push MatteBvr Statics.fillMatte(Path2Bvr)"
			// AUTOGENERATED
			instrTrace("push MatteBvr Statics.fillMatte(Path2Bvr)");
			METHOD_CALL_2(
				staticStatics,
				FillMatte,
				(IDAPath2*)USE_COM(1),
				(IDAMatte**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 244:
			// Execute: "push Behavior Behavior.duration(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Behavior Behavior.duration(NumberBvr)");
			METHOD_CALL_2(
				(IDABehavior*)USE_COM(1),
				DurationAnim,
				(IDANumber*)USE_COM(2),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 245:
			// Execute: "push Behavior Behavior.duration(double)"
			// AUTOGENERATED
			instrTrace("push Behavior Behavior.duration(double)");
			METHOD_CALL_2(
				(IDABehavior*)USE_COM(1),
				Duration,
				USE_DOUBLE(1),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 246:
			// Execute: "push Behavior Behavior.substituteTime(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Behavior Behavior.substituteTime(NumberBvr)");
			METHOD_CALL_2(
				(IDABehavior*)USE_COM(1),
				SubstituteTime,
				(IDANumber*)USE_COM(2),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 247:
			// Execute: "call Behavior.init(Behavior)"
			// AUTOGENERATED
			instrTrace("call Behavior.init(Behavior)");
			METHOD_CALL_1(
				(IDABehavior*)USE_COM(1),
				Init,
				(IDABehavior*)USE_COM(2)
			);
			FREE_COM;
			FREE_COM;
			break;
			
		case 248:
			// Execute: "push Behavior ArrayBvr.nth(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Behavior ArrayBvr.nth(NumberBvr)");
			METHOD_CALL_2(
				(IDAArray*)USE_COM(1),
				NthAnim,
				(IDANumber*)USE_COM(2),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 249:
			// Execute: "push NumberBvr ArrayBvr.lengt