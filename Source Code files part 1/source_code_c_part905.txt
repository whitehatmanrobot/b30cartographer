pyright (c) Microsoft Inc. 1991
 ****************************************************************************/


#include "precomp.h"
#pragma hdrstop


// Max number of pointl's allowed on stack before explicit memory allocation.

#define MAX_STACK_POINTL	128

// Convert array of POINTSs to POINTLs.

#define POINTS_TO_POINTL(pptl, ppts, cpt)			\
    {								\
	DWORD i;						\
	for (i = 0; i < (cpt); i++)				\
	{							\
	    (pptl)[i].x = (LONG) (ppts)[i].x;			\
	    (pptl)[i].y = (LONG) (ppts)[i].y;			\
	}							\
    }


/**************************************************************************
 * Handler - NotImplemented
 *
 * The following 32-bit records have no equivalent 16-bit metafile records:
 *      SETBRUSHORGEX
 *
 *************************************************************************/
BOOL bHandleNotImplemented(PVOID pVoid, PLOCALDC pLocalDC)
{
PENHMETARECORD pemr ;
INT            iType ;

        NOTUSED(pLocalDC) ;

        pemr = (PENHMETARECORD) pVoid ;
        iType = pemr->iType ;

        if (iType != EMR_SETBRUSHORGEX
         && iType != EMR_SETCOLORADJUSTMENT
         && iType != EMR_SETMITERLIMIT
         && iType != EMR_SETICMMODE
         && iType != EMR_CREATECOLORSPACE
         && iType != EMR_SETCOLORSPACE
         && iType != EMR_DELETECOLORSPACE
         && iType != EMR_GLSRECORD
         && iType != EMR_GLSBOUNDEDRECORD
         && iType != EMR_PIXELFORMAT)
        {
            PUTS1("MF3216: bHandleNotImplemented - record not supported: %d\n", iType) ;
        }
        return(TRUE) ;
}


/**************************************************************************
 * Handler - GdiComment
 *************************************************************************/
BOOL bHandleGdiComment(PVOID pVoid, PLOCALDC pLocalDC)
{
	return(DoGdiComment(pLocalDC, (PEMR) pVoid));
}


/**************************************************************************
 * Handler - SetPaletteEntries
 *************************************************************************/
BOOL bHandleSetPaletteEntries(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	 b ;
PEMRSETPALETTEENTRIES pMfSetPaletteEntries ;
DWORD    ihPal, iStart, cEntries ;
PPALETTEENTRY   pPalEntry ;

	pMfSetPaletteEntries = (PEMRSETPALETTEENTRIES) pVoid ;

	// Now do the translation.

	ihPal     = pMfSetPaletteEntries->ihPal ;
        iStart    = pMfSetPaletteEntries->iStart ;
        cEntries  = pMfSetPaletteEntries->cEntries ;
        pPalEntry = pMfSetPaletteEntries->aPalEntries ;

	b = DoSetPaletteEntries(pLocalDC, ihPal, iStart, cEntries, pPalEntry) ;

        return (b) ;
}


/**************************************************************************
 * Handler - CreatePalette
 *************************************************************************/
BOOL bHandleCreatePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	b ;
PEMRCREATEPALETTE pMfCreatePalette ;
LPLOGPALETTE     lpLogPal ;
DWORD   ihPal ;

	pMfCreatePalette = (PEMRCREATEPALETTE) pVoid ;

	// Now do the translation.

	ihPal    = pMfCreatePalette->ihPal ;
        lpLogPal = &pMfCreatePalette->lgpl ;

	b = DoCreatePalette(pLocalDC, ihPal, lpLogPal) ;

        return (b) ;
}


/**************************************************************************
 * Handler - RealizePalette
 *************************************************************************/
BOOL bHandleRealizePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	 b ;

	NOTUSED(pVoid);

	// Now do the translation.

	b = DoRealizePalette(pLocalDC) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ResizePalette
 *************************************************************************/
BOOL bHandleResizePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	 b ;
PEMRRESIZEPALETTE pMfResizePalette ;
DWORD    ihPal, cEntries ;

	pMfResizePalette = (PEMRRESIZEPALETTE) pVoid ;

	// Now do the translation.

	ihPal    = pMfResizePalette->ihPal ;
        cEntries = pMfResizePalette->cEntries ;

	b = DoResizePalette(pLocalDC, ihPal, cEntries) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SelectPalette
 *************************************************************************/
BOOL bHandleSelectPalette(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	 b ;
PEMRSELECTPALETTE pMfSelectPalette ;
DWORD    ihPal ;

	pMfSelectPalette = (PEMRSELECTPALETTE) pVoid ;

	// Now do the translation.

	ihPal = pMfSelectPalette->ihPal ;

	b = DoSelectPalette(pLocalDC, ihPal) ;

        return (b) ;
}

/**************************************************************************
 * Handler - OffsetClipRgn
 *************************************************************************/
BOOL bHandleOffsetClipRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMROFFSETCLIPRGN pMfOffsetClipRgn ;
INT	     x, y ;

	pMfOffsetClipRgn = (PEMROFFSETCLIPRGN) pVoid ;

	// Now do the translation.

	x = pMfOffsetClipRgn->ptlOffset.x ;
	y = pMfOffsetClipRgn->ptlOffset.y ;

	b = DoOffsetClipRgn(pLocalDC, x, y) ;

        return (b) ;
}

/**************************************************************************
 * Handler - ExtSelectClipRgn
 *************************************************************************/
BOOL bHandleExtSelectClipRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMREXTSELECTCLIPRGN pMfExtSelectClipRgn ;
INT	     cbRgnData, iMode ;
LPRGNDATA    pRgnData ;

	pMfExtSelectClipRgn = (PEMREXTSELECTCLIPRGN) pVoid ;

	// Now do the translation.

	cbRgnData = pMfExtSelectClipRgn->cbRgnData ;
        pRgnData = (LPRGNDATA) pMfExtSelectClipRgn->RgnData;
        iMode    = pMfExtSelectClipRgn->iMode ;

	b = DoExtSelectClipRgn(pLocalDC, cbRgnData, pRgnData, iMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetMetaRgn
 *************************************************************************/
BOOL bHandleSetMetaRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoSetMetaRgn(pLocalDC) ;

        return(b) ;
}


/**************************************************************************
 * Handler - PaintRgn
 *************************************************************************/
BOOL bHandlePaintRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRPAINTRGN pMfPaintRgn ;
INT	     cbRgnData;
LPRGNDATA    pRgnData ;

	pMfPaintRgn = (PEMRPAINTRGN) pVoid ;

	// Now do the translation.

	cbRgnData  = pMfPaintRgn->cbRgnData ;
        pRgnData   = (LPRGNDATA) pMfPaintRgn->RgnData;

	b = DoDrawRgn(pLocalDC, 0, 0, 0, cbRgnData, pRgnData, EMR_PAINTRGN);

        return (b) ;
}

/**************************************************************************
 * Handler - InvertRgn
 *************************************************************************/
BOOL bHandleInvertRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRINVERTRGN pMfInvertRgn ;
INT	     cbRgnData;
LPRGNDATA    pRgnData ;

	pMfInvertRgn = (PEMRINVERTRGN) pVoid ;

	// Now do the translation.

	cbRgnData  = pMfInvertRgn->cbRgnData ;
        pRgnData   = (LPRGNDATA) pMfInvertRgn->RgnData;

	b = DoDrawRgn(pLocalDC, 0, 0, 0, cbRgnData, pRgnData, EMR_INVERTRGN);

        return (b) ;
}


/**************************************************************************
 * Handler - FrameRgn
 *************************************************************************/
BOOL bHandleFrameRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRFRAMERGN pMfFrameRgn ;
INT	    ihBrush,
	    cbRgnData,
	    nWidth,
	    nHeight ;
LPRGNDATA   pRgnData ;

	pMfFrameRgn = (PEMRFRAMERGN) pVoid ;

	// Now do the translation.

	ihBrush	   = pMfFrameRgn->ihBrush ;
	nWidth	   = pMfFrameRgn->szlStroke.cx ;
	nHeight	   = pMfFrameRgn->szlStroke.cy ;
	cbRgnData  = pMfFrameRgn->cbRgnData ;
        pRgnData   = (LPRGNDATA) pMfFrameRgn->RgnData;

	b = DoDrawRgn(pLocalDC, ihBrush, nWidth, nHeight, cbRgnData, pRgnData, EMR_FRAMERGN);

        return (b) ;
}

/**************************************************************************
 * Handler - FillRgn
 *************************************************************************/
BOOL bHandleFillRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRFILLRGN pMfFillRgn ;
INT	   ihBrush,
	   cbRgnData;
LPRGNDATA  pRgnData ;


        // Set up the pointer the Doer uses to reference the
        // the Win32 drawing order.  Also setup the drawing order specific
        // pointer.

	pMfFillRgn = (PEMRFILLRGN) pVoid ;

	// Now do the translation.

	ihBrush	   = pMfFillRgn->ihBrush ;
	cbRgnData  = pMfFillRgn->cbRgnData ;
        pRgnData   = (LPRGNDATA) pMfFillRgn->RgnData;

	b = DoDrawRgn(pLocalDC, ihBrush, 0, 0, cbRgnData, pRgnData, EMR_FILLRGN);

        return (b) ;
}


/**************************************************************************
 * Handler - IntersectClipRect
 *************************************************************************/
BOOL bHandleIntersectClipRect(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRINTERSECTCLIPRECT pMfIntersectClipRect ;
INT xLeft, yTop, xRight, yBottom ;


	pMfIntersectClipRect = (PEMRINTERSECTCLIPRECT) pVoid ;

	// Now do the translation.
	xLeft	= pMfIntersectClipRect->rclClip.left ;
	yTop	= pMfIntersectClipRect->rclClip.top ;
	xRight	= pMfIntersectClipRect->rclClip.right ;
	yBottom = pMfIntersectClipRect->rclClip.bottom ;

	b = DoClipRect(pLocalDC, xLeft, yTop, xRight, yBottom, EMR_INTERSECTCLIPRECT) ;

        return (b) ;

}

/**************************************************************************
 * Handler - ExcludeClipRect
 *************************************************************************/
BOOL bHandleExcludeClipRect(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMREXCLUDECLIPRECT pMfExcludeClipRect ;
INT xLeft, yTop, xRight, yBottom ;


	pMfExcludeClipRect = (PEMREXCLUDECLIPRECT) pVoid ;

	// Now do the translation.
	xLeft	= pMfExcludeClipRect->rclClip.left ;
	yTop	= pMfExcludeClipRect->rclClip.top ;
	xRight	= pMfExcludeClipRect->rclClip.right ;
	yBottom = pMfExcludeClipRect->rclClip.bottom ;

	b = DoClipRect(pLocalDC, xLeft, yTop, xRight, yBottom, EMR_EXCLUDECLIPRECT) ;

        return (b) ;

}


/**************************************************************************
 * Handler - SetPixel
 *************************************************************************/
BOOL bHandleSetPixel(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRSETPIXELV pMfSetPixel ;
INT	    x, y ;
COLORREF    crColor ;

	pMfSetPixel = (PEMRSETPIXELV) pVoid ;

        // Now do the translation.

	x	= (INT) pMfSetPixel->ptlPixel.x ;
	y	= (INT) pMfSetPixel->ptlPixel.y ;
	crColor = pMfSetPixel->crColor ;

	b = DoSetPixel(pLocalDC, x, y, crColor) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ExtFloodFill
 *************************************************************************/
BOOL bHandleExtFloodFill(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	        b ;
PEMREXTFLOODFILL pMfExtFloodFill ;
INT	        x, y ;
COLORREF        crColor ;
DWORD           iMode ;

	pMfExtFloodFill = (PEMREXTFLOODFILL) pVoid ;

        // Now do the translation.

	x	= (INT) pMfExtFloodFill->ptlStart.x ;
	y	= (INT) pMfExtFloodFill->ptlStart.y ;
	crColor = pMfExtFloodFill->crColor ;
	iMode   = pMfExtFloodFill->iMode ;

	b = DoExtFloodFill(pLocalDC, x, y, crColor, iMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ModifyWorldTransform
 *************************************************************************/
BOOL bHandleModifyWorldTransform(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRMODIFYWORLDTRANSFORM pMfModifyWorldTransform ;
PXFORM  pxform ;
DWORD   iMode ;


        pMfModifyWorldTransform = (PEMRMODIFYWORLDTRANSFORM) pVoid ;

        // get a pointer to the xform matrix

        pxform = &pMfModifyWorldTransform->xform ;
        iMode  = pMfModifyWorldTransform->iMode ;

        // Now do the translation.

        b = DoModifyWorldTransform(pLocalDC, pxform, iMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetWorldTransform
 *************************************************************************/
BOOL bHandleSetWorldTransform(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSETWORLDTRANSFORM pMfSetWorldTransform ;
PXFORM  pxform ;


        pMfSetWorldTransform = (PEMRSETWORLDTRANSFORM) pVoid ;

        // get a pointer to the xform matrix

        pxform = &pMfSetWorldTransform->xform ;

        // Now do the translation.

        b = DoSetWorldTransform(pLocalDC, pxform) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyBezierTo
 *************************************************************************/
BOOL bHandlePolyBezierTo(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYBEZIERTO pMfPolyBezierTo ;
DWORD   nCount ;
PPOINTL pptl ;

        pMfPolyBezierTo = (PEMRPOLYBEZIERTO) pVoid ;

        // Copy the BezierTo count and the polyBezierTo verticies to
        // the record.

        nCount = pMfPolyBezierTo->cptl ;
        pptl   = pMfPolyBezierTo->aptl ;

        // Now do the translation.

        b = DoPolyBezierTo(pLocalDC, (LPPOINT) pptl, nCount) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyDraw
 *************************************************************************/
BOOL bHandlePolyDraw(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYDRAW pMfPolyDraw ;
DWORD   nCount ;
PPOINTL pptl ;
PBYTE   pb ;

        pMfPolyDraw = (PEMRPOLYDRAW) pVoid ;

        // Copy the Draw count and the polyDraw verticies to
        // the record.

        nCount = pMfPolyDraw->cptl ;
        pptl   = pMfPolyDraw->aptl ;
        pb     = (PBYTE) &pMfPolyDraw->aptl[nCount];

        // Now do the translation.

        b = DoPolyDraw(pLocalDC, (LPPOINT) pptl, pb, nCount) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyBezier
 *************************************************************************/
BOOL bHandlePolyBezier(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYBEZIER pMfPolyBezier ;
DWORD   nCount ;
PPOINTL pptl ;

        pMfPolyBezier = (PEMRPOLYBEZIER) pVoid ;

        // Copy the Bezier count and the polyBezier verticies to
        // the record.

        nCount = pMfPolyBezier->cptl ;
        pptl   = pMfPolyBezier->aptl ;

        // Now do the translation.

        b = DoPolyBezier(pLocalDC, (LPPOINT) pptl, nCount) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Begin Path
 *************************************************************************/
BOOL bHandleBeginPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoBeginPath(pLocalDC) ;

        return (b) ;
}

/**************************************************************************
 * Handler - End Path
 *************************************************************************/
BOOL bHandleEndPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoEndPath(pLocalDC) ;

        return (b) ;
}

/**************************************************************************
 * Handler - Flatten Path
 *************************************************************************/
BOOL bHandleFlattenPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoFlattenPath(pLocalDC) ;

        return (b) ;
}

/**************************************************************************
 * Handler - CloseFigure
 *************************************************************************/
BOOL bHandleCloseFigure(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoCloseFigure(pLocalDC) ;

        return (b) ;
}

/**************************************************************************
 * Handler - Abort Path
 *************************************************************************/
BOOL bHandleAbortPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoAbortPath(pLocalDC) ;

        return (b) ;
}

/**************************************************************************
 * Handler - Stroke Path
 *************************************************************************/
BOOL bHandleStrokePath(PVOID pVoid, PLOCALDC pLocalDC)
{
        NOTUSED(pVoid) ;

        return(DoRenderPath(pLocalDC, EMR_STROKEPATH));
}

/**************************************************************************
 * Handler - Fill Path
 *************************************************************************/
BOOL bHandleFillPath(PVOID pVoid, PLOCALDC pLocalDC)
{
        NOTUSED(pVoid) ;

        return(DoRenderPath(pLocalDC, EMR_FILLPATH));
}

/**************************************************************************
 * Handler - Stroke and Fill Path
 *************************************************************************/
BOOL bHandleStrokeAndFillPath(PVOID pVoid, PLOCALDC pLocalDC)
{
        NOTUSED(pVoid) ;

        return(DoRenderPath(pLocalDC, EMR_STROKEANDFILLPATH));
}

/**************************************************************************
 * Handler - Widen Path
 *************************************************************************/
BOOL bHandleWidenPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoWidenPath(pLocalDC) ;

        return(b) ;
}

/**************************************************************************
 * Handler - Select Clip Path
 *************************************************************************/
BOOL bHandleSelectClipPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSELECTCLIPPATH   pMfSelectClipPath ;
INT     iMode ;

        pMfSelectClipPath = (PEMRSELECTCLIPPATH) pVoid ;

        iMode = (INT) pMfSelectClipPath->iMode ;

        b = DoSelectClipPath(pLocalDC, iMode) ;

        return(b) ;
}

/**************************************************************************
 * Handler - StretchDIBits
 *************************************************************************/
BOOL bHandleStretchDIBits(PVOID pVoid, PLOCALDC pLocalDC)
{
PEMRSTRETCHDIBITS pMfStretchDIBits ;

BOOL    b ;
LONG    xDest ;
LONG    yDest ;
LONG    xSrc ;
LONG    ySrc ;
LONG    cxSrc ;
LONG    cySrc ;
DWORD   offBmiSrc ;
DWORD   cbBmiSrc ;
DWORD   offBitsSrc ;
DWORD   cbBitsSrc ;
DWORD   iUsageSrc ;
DWORD   dwRop ;
LONG    cxDest ;
LONG    cyDest ;

LPBITMAPINFO    lpBitmapInfo ;
LPBYTE          lpBits ;

        pMfStretchDIBits = (PEMRSTRETCHDIBITS) pVoid ;

        xDest      = pMfStretchDIBits->xDest ;
        yDest      = pMfStretchDIBits->yDest ;
        xSrc       = pMfStretchDIBits->xSrc ;
        ySrc       = pMfStretchDIBits->ySrc ;
        cxSrc      = pMfStretchDIBits->cxSrc ;
        cySrc      = pMfStretchDIBits->cySrc ;
        offBmiSrc  = pMfStretchDIBits->offBmiSrc ;
        cbBmiSrc   = pMfStretchDIBits->cbBmiSrc ;
        offBitsSrc = pMfStretchDIBits->offBitsSrc ;
        cbBitsSrc  = pMfStretchDIBits->cbBitsSrc ;
        iUsageSrc  = pMfStretchDIBits->iUsageSrc ;
        dwRop      = pMfStretchDIBits->dwRop ;
        cxDest     = pMfStretchDIBits->cxDest ;
        cyDest     = pMfStretchDIBits->cyDest ;

       
        if (!IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfStretchDIBits,
                                        offBmiSrc,
                                        cbBmiSrc)  ||
            !IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfStretchDIBits,
                                        offBitsSrc,
                                        cbBitsSrc))
        {
            EMFVALFAIL(("MF3216: bHandleStrectchDIBits failed\n"));
            return(FALSE);
        }

        lpBitmapInfo = (LPBITMAPINFO) ((PBYTE) pMfStretchDIBits + offBmiSrc) ;
        lpBits = (PBYTE) pMfStretchDIBits + offBitsSrc ;

        b = DoStretchDIBits(pLocalDC,
                            xDest,
                            yDest,
                            cxDest,
                            cyDest,
                            dwRop,
                            xSrc,
                            ySrc,
                            cxSrc,
                            cySrc,
                            iUsageSrc,
                            lpBitmapInfo,
                            cbBmiSrc,
                            lpBits,
                            cbBitsSrc ) ;
        return(b) ;
}

/**************************************************************************
 * Handler - SetDIBitsToDevice
 *************************************************************************/
BOOL bHandleSetDIBitsToDevice(PVOID pVoid, PLOCALDC pLocalDC)
{
PEMRSETDIBITSTODEVICE pMfSetDIBitsToDevice ;

BOOL    b ;
LONG    xDest ;
LONG    yDest ;
LONG    xSrc ;
LONG    ySrc ;
LONG    cxSrc ;
LONG    cySrc ;
DWORD   offBmiSrc ;
DWORD   cbBmiSrc ;
DWORD   offBitsSrc ;
DWORD   cbBitsSrc ;
DWORD   iUsageSrc ;
DWORD   iStartScan ;
DWORD   cScans ;

LPBITMAPINFO    lpBitmapInfo ;
LPBYTE          lpBits ;

        pMfSetDIBitsToDevice = (PEMRSETDIBITSTODEVICE) pVoid ;

        xDest       = pMfSetDIBitsToDevice->xDest ;
        yDest       = pMfSetDIBitsToDevice->yDest ;
        xSrc        = pMfSetDIBitsToDevice->xSrc ;
        ySrc        = pMfSetDIBitsToDevice->ySrc ;
        cxSrc       = pMfSetDIBitsToDevice->cxSrc ;
        cySrc       = pMfSetDIBitsToDevice->cySrc ;
        offBmiSrc   = pMfSetDIBitsToDevice->offBmiSrc ;
        cbBmiSrc    = pMfSetDIBitsToDevice->cbBmiSrc ;
        offBitsSrc  = pMfSetDIBitsToDevice->offBitsSrc ;
        cbBitsSrc   = pMfSetDIBitsToDevice->cbBitsSrc ;
        iUsageSrc   = pMfSetDIBitsToDevice->iUsageSrc ;
        iStartScan  = pMfSetDIBitsToDevice->iStartScan ;
        cScans      = pMfSetDIBitsToDevice->cScans ;

        if (!IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfSetDIBitsToDevice,
                                        offBmiSrc,
                                        cbBmiSrc)  ||
            !IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfSetDIBitsToDevice,
                                        offBitsSrc,
                                        cbBitsSrc))
        {
            EMFVALFAIL(("MF3216: bHandleSetDIBitsToDevice failed\n"));
            return(FALSE);
        }

        lpBitmapInfo = (LPBITMAPINFO) ((PBYTE) pMfSetDIBitsToDevice + offBmiSrc) ;
        lpBits = (PBYTE) pMfSetDIBitsToDevice + offBitsSrc ;

        b = DoSetDIBitsToDevice(pLocalDC,
                                xDest,
                                yDest,
                                xSrc,
                                ySrc,
                                cxSrc,
                                cySrc,
				iUsageSrc,
                                iStartScan,
                                cScans,
                                lpBitmapInfo,
                                cbBmiSrc,
                                lpBits,
				cbBitsSrc ) ;

        return(b) ;
}


/**************************************************************************
 * Handler - BitBlt
 *************************************************************************/
BOOL bHandleBitBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRBITBLT  pMfBitBlt ;
LONG        xDest ;
LONG        yDest ;
LONG        cxDest ;
LONG        cyDest ;
DWORD       dwRop ;
LONG        xSrc ;
LONG        ySrc ;
PXFORM      pxformSrc ;
COLORREF    crBkColorSrc ;
DWORD       iUsageSrc ;
DWORD       offBmiSrc ;
DWORD       cbBmiSrc ;
DWORD       offBitsSrc ;
DWORD       cbBitsSrc ;
PBITMAPINFO pbmi ;
LPBYTE      lpBits ;

        pMfBitBlt = (PEMRBITBLT) pVoid ;

        xDest        = pMfBitBlt->xDest ;
        yDest        = pMfBitBlt->yDest ;
        cxDest       = pMfBitBlt->cxDest ;
        cyDest       = pMfBitBlt->cyDest ;
        dwRop        = pMfBitBlt->dwRop ;
        xSrc         = pMfBitBlt->xSrc ;
        ySrc         = pMfBitBlt->ySrc ;
        pxformSrc    =&(pMfBitBlt->xformSrc) ;
        crBkColorSrc = pMfBitBlt->crBkColorSrc ;		// not used

        iUsageSrc    = pMfBitBlt->iUsageSrc ;
        offBmiSrc    = pMfBitBlt->offBmiSrc ;
        cbBmiSrc     = pMfBitBlt->cbBmiSrc ;
        offBitsSrc   = pMfBitBlt->offBitsSrc ;
        cbBitsSrc    = pMfBitBlt->cbBitsSrc ;

        if (!IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfBitBlt,
                                        offBmiSrc,
                                        cbBmiSrc)  ||
            !IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfBitBlt,
                                        offBitsSrc,
                                        cbBitsSrc))
        {
            EMFVALFAIL(("MF3216: bHandleBitBlt failed\n"));
            return(FALSE);
        }

        lpBits = (PBYTE) pMfBitBlt + offBitsSrc ;
        pbmi   = (PBITMAPINFO) ((PBYTE) pMfBitBlt + offBmiSrc) ;

	b = DoStretchBlt(pLocalDC,
			xDest,
			yDest,
			cxDest,
			cyDest,
			dwRop,
			xSrc,
			ySrc,
			cxDest,
			cyDest,
			pxformSrc,
			iUsageSrc,
			pbmi,
			cbBmiSrc,
			lpBits,
			cbBitsSrc);

        return(b) ;
}


/**************************************************************************
 * Handler - StretchBlt
 *************************************************************************/
BOOL bHandleStretchBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRSTRETCHBLT   pMfStretchBlt ;
LONG        xDest ;
LONG        yDest ;
LONG        cxDest ;
LONG        cyDest ;
DWORD       dwRop ;
LONG        xSrc ;
LONG        ySrc ;
LONG        cxSrc ;
LONG        cySrc ;
PXFORM      pxformSrc ;
COLORREF    crBkColorSrc ;
DWORD       iUsageSrc ;
DWORD       offBmiSrc ;
DWORD       cbBmiSrc ;
DWORD       offBitsSrc ;
DWORD       cbBitsSrc ;
PBITMAPINFO pbmi ;
LPBYTE      lpBits ;

        pMfStretchBlt = (PEMRSTRETCHBLT) pVoid ;

        xDest          = pMfStretchBlt->xDest ;
        yDest          = pMfStretchBlt->yDest ;
        cxDest         = pMfStretchBlt->cxDest ;
        cyDest         = pMfStretchBlt->cyDest ;
        dwRop          = pMfStretchBlt->dwRop ;
        xSrc           = pMfStretchBlt->xSrc ;
        ySrc           = pMfStretchBlt->ySrc ;
        pxformSrc      =&(pMfStretchBlt->xformSrc) ;
        crBkColorSrc   = pMfStretchBlt->crBkColorSrc ;	// not used

        iUsageSrc      = pMfStretchBlt->iUsageSrc ;
        offBmiSrc      = pMfStretchBlt->offBmiSrc ;
        cbBmiSrc       = pMfStretchBlt->cbBmiSrc ;
        offBitsSrc     = pMfStretchBlt->offBitsSrc ;
        cbBitsSrc      = pMfStretchBlt->cbBitsSrc ;

        if (!IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfStretchBlt,
                                        offBmiSrc,
                                        cbBmiSrc)  ||
            !IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfStretchBlt,
                                        offBitsSrc,
                                        cbBitsSrc))
        {
            EMFVALFAIL(("MF3216: bHandleStretchBlt failed\n"));
            return(FALSE);
        }

        lpBits = (PBYTE) pMfStretchBlt + offBitsSrc ;
        pbmi   = (PBITMAPINFO) ((PBYTE) pMfStretchBlt + offBmiSrc) ;

        cxSrc          = pMfStretchBlt->cxSrc ;
        cySrc          = pMfStretchBlt->cySrc ;

	b = DoStretchBlt(pLocalDC,
			xDest,
			yDest,
			cxDest,
			cyDest,
			dwRop,
			xSrc,
			ySrc,
			cxSrc,
			cySrc,
			pxformSrc,
			iUsageSrc,
			pbmi,
			cbBmiSrc,
			lpBits,
			cbBitsSrc);

        return(b) ;
}


/**************************************************************************
 * Handler - MaskBlt
 *************************************************************************/
BOOL bHandleMaskBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRMASKBLT  pMfMaskBlt ;
LONG        xDest ;
LONG        yDest ;
LONG        cxDest ;
LONG        cyDest ;
DWORD       dwRop ;
LONG        xSrc ;
LONG        ySrc ;
PXFORM      pxformSrc ;
COLORREF    crBkColorSrc ;
DWORD       iUsageSrc ;
DWORD       offBmiSrc ;
DWORD       cbBmiSrc ;
DWORD       offBitsSrc ;
DWORD       cbBitsSrc ;
PBITMAPINFO pbmi ;
LPBYTE      lpBits ;
LONG        xMask ;
LONG        yMask ;
DWORD       iUsageMask ;
DWORD       offBmiMask ;
DWORD       cbBmiMask ;
DWORD       offBitsMask ;
DWORD       cbBitsMask ;
PBITMAPINFO pbmiMask ;
LPBYTE      lpMaskBits ;

        pMfMaskBlt   = (PEMRMASKBLT) pVoid ;

        xDest        = pMfMaskBlt->xDest ;
        yDest        = pMfMaskBlt->yDest ;
        cxDest       = pMfMaskBlt->cxDest ;
        cyDest       = pMfMaskBlt->cyDest ;
        dwRop        = pMfMaskBlt->dwRop ;
        xSrc         = pMfMaskBlt->xSrc ;
        ySrc         = pMfMaskBlt->ySrc ;
        pxformSrc    =&(pMfMaskBlt->xformSrc) ;
        crBkColorSrc = pMfMaskBlt->crBkColorSrc ;		// not used

        iUsageSrc    = pMfMaskBlt->iUsageSrc ;
        offBmiSrc    = pMfMaskBlt->offBmiSrc ;
        cbBmiSrc     = pMfMaskBlt->cbBmiSrc ;
        offBitsSrc   = pMfMaskBlt->offBitsSrc ;
        cbBitsSrc    = pMfMaskBlt->cbBitsSrc ;

        if (!IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfMaskBlt,
                                        offBmiSrc,
                                        cbBmiSrc)  ||
            !IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfMaskBlt,
                                        offBitsSrc,
                                        cbBitsSrc))
        {
            EMFVALFAIL(("MF3216: bHandleMaskBlt failed\n"));
            return(FALSE);
        }

        lpBits = (PBYTE) pMfMaskBlt + offBitsSrc ;
        pbmi   = (PBITMAPINFO) ((PBYTE) pMfMaskBlt + offBmiSrc) ;

        xMask        = pMfMaskBlt->xMask ;
        yMask        = pMfMaskBlt->yMask ;
        iUsageMask   = pMfMaskBlt->iUsageMask ;
        offBmiMask   = pMfMaskBlt->offBmiMask ;
        cbBmiMask    = pMfMaskBlt->cbBmiMask ;
        offBitsMask  = pMfMaskBlt->offBitsMask ;
        cbBitsMask   = pMfMaskBlt->cbBitsMask ;

        if (!IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfMaskBlt,
                                        offBmiMask,
                                        cbBmiMask)  ||
            !IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfMaskBlt,
                                        offBitsMask,
                                        cbBitsMask))
        {
            EMFVALFAIL(("MF3216: bHandleMaskBlt failed\n"));
            return(FALSE);
        }

        lpMaskBits = (PBYTE) pMfMaskBlt + offBitsMask ;
        pbmiMask   = (PBITMAPINFO) ((PBYTE) pMfMaskBlt + offBmiMask) ;

	b = DoMaskBlt(pLocalDC,
			xDest,
			yDest,
			cxDest,
			cyDest,
			dwRop,
			xSrc,
			ySrc,
			pxformSrc,
			iUsageSrc,
			pbmi,
			cbBmiSrc,
			lpBits,
			cbBitsSrc,
			xMask,
			yMask,
			iUsageMask,
			pbmiMask,
			cbBmiMask,
			lpMaskBits,
			cbBitsMask);

        return(b) ;
}


/**************************************************************************
 * Handler - PlgBlt
 *************************************************************************/
BOOL bHandlePlgBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRPLGBLT   pMfPlgBlt ;
PPOINTL     pptlDest ;
LONG        xSrc ;
LONG        ySrc ;
LONG        cxSrc ;
LONG        cySrc ;
PXFORM      pxformSrc ;
COLORREF    crBkColorSrc ;
DWORD       iUsageSrc ;
DWORD       offBmiSrc ;
DWORD       cbBmiSrc ;
DWORD       offBitsSrc ;
DWORD       cbBitsSrc ;
PBITMAPINFO pbmi ;
LPBYTE      lpBits ;
LONG        xMask ;
LONG        yMask ;
DWORD       iUsageMask ;
DWORD       offBmiMask ;
DWORD       cbBmiMask ;
DWORD       offBitsMask ;
DWORD       cbBitsMask ;
PBITMAPINFO pbmiMask ;
LPBYTE      lpMaskBits ;

        pMfPlgBlt    = (PEMRPLGBLT) pVoid ;

        pptlDest     = pMfPlgBlt->aptlDest ;
        xSrc         = pMfPlgBlt->xSrc ;
        ySrc         = pMfPlgBlt->ySrc ;
        cxSrc        = pMfPlgBlt->cxSrc ;
        cySrc        = pMfPlgBlt->cySrc ;
        pxformSrc    =&(pMfPlgBlt->xformSrc) ;
        crBkColorSrc = pMfPlgBlt->crBkColorSrc ;		// not used

        iUsageSrc    = pMfPlgBlt->iUsageSrc ;
        offBmiSrc    = pMfPlgBlt->offBmiSrc ;
        cbBmiSrc     = pMfPlgBlt->cbBmiSrc ;
        offBitsSrc   = pMfPlgBlt->offBitsSrc ;
        cbBitsSrc    = pMfPlgBlt->cbBitsSrc ;

        if (!IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfPlgBlt,
                                        offBmiSrc,
                                        cbBmiSrc)  ||
            !IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfPlgBlt,
                                        offBitsSrc,
                                        cbBitsSrc))
        {
            EMFVALFAIL(("MF3216: bHandlePlgBlt failed\n"));
            return(FALSE);
        }

        lpBits = (PBYTE) pMfPlgBlt + offBitsSrc ;
        pbmi   = (PBITMAPINFO) ((PBYTE) pMfPlgBlt + offBmiSrc) ;

        xMask        = pMfPlgBlt->xMask ;
        yMask        = pMfPlgBlt->yMask ;
        iUsageMask   = pMfPlgBlt->iUsageMask ;
        offBmiMask   = pMfPlgBlt->offBmiMask ;
        cbBmiMask    = pMfPlgBlt->cbBmiMask ;
        offBitsMask  = pMfPlgBlt->offBitsMask ;
        cbBitsMask   = pMfPlgBlt->cbBitsMask ;

        if (!IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfPlgBlt,
                                        offBmiMask,
                                        cbBmiMask)  ||
            !IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfPlgBlt,
                                        offBitsMask,
                                        cbBitsMask))
        {
            EMFVALFAIL(("MF3216: bHandlePlgBlt failed\n"));
            return(FALSE);
        }

        lpMaskBits = (PBYTE) pMfPlgBlt + offBitsMask ;
        pbmiMask   = (PBITMAPINFO) ((PBYTE) pMfPlgBlt + offBmiMask) ;

	b = DoPlgBlt(pLocalDC,
                        pptlDest,
			xSrc,
			ySrc,
			cxSrc,
			cySrc,
			pxformSrc,
			iUsageSrc,
			pbmi,
			cbBmiSrc,
			lpBits,
			cbBitsSrc,
			xMask,
			yMask,
			iUsageMask,
			pbmiMask,
			cbBmiMask,
			lpMaskBits,
			cbBitsMask);

        return(b) ;
}


/**************************************************************************
 * Handler - Save DC
 *************************************************************************/
BOOL bHandleSaveDC(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;

        NOTUSED(pVoid) ;

        b = DoSaveDC(pLocalDC) ;

        return(b) ;
}


/**************************************************************************
 * Handler - Restore DC
 *************************************************************************/
BOOL bHandleRestoreDC(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL            b ;
PEMRRESTOREDC   pMfRestoreDc ;
INT             nSavedDC ;

        pMfRestoreDc = (PEMRRESTOREDC) pVoid ;

        nSavedDC = (INT) pMfRestoreDc->iRelative ;

        b = DoRestoreDC(pLocalDC, nSavedDC) ;

        return(b) ;
}


/**************************************************************************
 * Handler - End of File
 *************************************************************************/
BOOL bHandleEOF(PVOID pVoid, PLOCALDC pLocalDC)
{

    NOTUSED(pVoid) ;

    DoEOF(pLocalDC) ;

    return (TRUE) ;
}

/**************************************************************************
 * Handler - Header
 *************************************************************************/
BOOL bHandleHeader(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PENHMETAHEADER pemfheader ;

	pemfheader = (PENHMETAHEADER) pVoid ;

	b = DoHeader(pLocalDC, pemfheader) ;

        return (b) ;
}

/**************************************************************************
 * Handler - ScaleWindowExtEx
 *************************************************************************/
BOOL bHandleScaleWindowExt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSCALEWINDOWEXTEX pMfScaleWindowExt ;
INT     Xnum,
        Xdenom,
        Ynum,
        Ydenom ;


        pMfScaleWindowExt = (PEMRSCALEWINDOWEXTEX) pVoid ;

        // Scale the MapMode Mode

        Xnum   = (INT) pMfScaleWindowExt->xNum ;
        Xdenom = (INT) pMfScaleWindowExt->xDenom ;
        Ynum   = (INT) pMfScaleWindowExt->yNum ;
        Ydenom = (INT) pMfScaleWindowExt->yDenom ;

        // Do the translation.

        b = DoScaleWindowExt(pLocalDC, Xnum, Xdenom, Ynum, Ydenom) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ScaleViewportExtEx
 *************************************************************************/
BOOL bHandleScaleViewportExt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSCALEVIEWPORTEXTEX pMfScaleViewportExt ;
INT     Xnum,
        Xdenom,
        Ynum,
        Ydenom ;


        pMfScaleViewportExt = (PEMRSCALEVIEWPORTEXTEX) pVoid ;

        // Scale the MapMode Mode

        Xnum   = (INT) pMfScaleViewportExt->xNum ;
        Xdenom = (INT) pMfScaleViewportExt->xDenom ;
        Ynum   = (INT) pMfScaleViewportExt->yNum ;
        Ydenom = (INT) pMfScaleViewportExt->yDenom ;

        // Do the translation.

        b = DoScaleViewportExt(pLocalDC, Xnum, Xdenom, Ynum, Ydenom) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetViewportExtEx
 *************************************************************************/
BOOL bHandleSetViewportExt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSETVIEWPORTEXTEX pMfSetViewportExt ;
LONG    x, y ;

        pMfSetViewportExt = (PEMRSETVIEWPORTEXTEX) pVoid ;

        // Set the MapMode Mode

        x = pMfSetViewportExt->szlExtent.cx ;
        y = pMfSetViewportExt->szlExtent.cy ;

        // Do the translation.

        b = DoSetViewportExt(pLocalDC, (INT) x, (INT) y) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetViewportOrgEx
 *************************************************************************/
BOOL bHandleSetViewportOrg(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSETVIEWPORTORGEX pMfSetViewportOrg ;
LONG    x, y ;

        pMfSetViewportOrg = (PEMRSETVIEWPORTORGEX) pVoid ;

        // Set the MapMode Mode

        x = pMfSetViewportOrg->ptlOrigin.x ;
        y = pMfSetViewportOrg->ptlOrigin.y ;

        // Do the translation.

        b = DoSetViewportOrg(pLocalDC, (INT) x, (INT) y) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetWindowExtEx
 *************************************************************************/
BOOL bHandleSetWindowExt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSETWINDOWEXTEX pMfSetWindowExt ;
LONG    x, y ;

        pMfSetWindowExt = (PEMRSETWINDOWEXTEX) pVoid ;

        // Set the MapMode Mode

        x = pMfSetWindowExt->szlExtent.cx ;
        y = pMfSetWindowExt->szlExtent.cy ;

        // Do the translation.

        b = DoSetWindowExt(pLocalDC, (INT) x, (INT) y) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetWindowOrgEx
 *************************************************************************/
BOOL bHandleSetWindowOrg(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSETWINDOWORGEX pMfSetWindowOrg ;
LONG    x, y ;

        pMfSetWindowOrg = (PEMRSETWINDOWORGEX) pVoid ;

        // Set the MapMode Mode

        x = pMfSetWindowOrg->ptlOrigin.x ;
        y = pMfSetWindowOrg->ptlOrigin.y ;

        // Do the translation.

        b = DoSetWindowOrg(pLocalDC, (INT) x, (INT) y) ;

        return (b) ;
}

/**************************************************************************
 * Handler - SetMapMode
 *************************************************************************/
BOOL bHandleSetMapMode(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   iMapMode ;
PEMRSETMAPMODE pMfSetMapMode ;

        pMfSetMapMode = (PEMRSETMAPMODE) pVoid ;

        // Set the MapMode Mode

        iMapMode = pMfSetMapMode->iMode ;

        // Do the translation.

        b = DoSetMapMode(pLocalDC, iMapMode) ;

        return (b) ;

}

/**************************************************************************
 * Handler - SetArcDirection
 *************************************************************************/
BOOL bHandleSetArcDirection(PVOID pVoid, PLOCALDC pLocalDC)
{
PEMRSETARCDIRECTION pMfSetArcDirection ;
INT             iArcDirection ;
BOOL            b ;


        pMfSetArcDirection = (PEMRSETARCDIRECTION) pVoid ;

        iArcDirection = (INT) pMfSetArcDirection->iArcDirection ;

        b = DoSetArcDirection(pLocalDC, iArcDirection) ;

        return (b) ;
}


/**************************************************************************
 * Handler - AngleArc
 *************************************************************************/
BOOL bHandleAngleArc(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRANGLEARC  pMfAngleArc ;
int     x, y;
DWORD   nRadius ;
FLOAT   eStartAngle,
        eSweepAngle ;

        pMfAngleArc = (PEMRANGLEARC) pVoid ;

        // Set the Arc center

        x  = (int) pMfAngleArc->ptlCenter.x ;
        y  = (int) pMfAngleArc->ptlCenter.y ;

        // Get the radius of the Arc

        nRadius = (INT) pMfAngleArc->nRadius ;

        // Set the start & sweep angles

        eStartAngle = pMfAngleArc->eStartAngle ;
        eSweepAngle = pMfAngleArc->eSweepAngle ;

        b = DoAngleArc(pLocalDC, x, y, nRadius, eStartAngle, eSweepAngle) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ArcTo
 *************************************************************************/
BOOL bHandleArcTo(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRARCTO  pMfArcTo ;
INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

        pMfArcTo = (PEMRARCTO) pVoid ;

        // Set up the ellipse box, this will be the same as the bounding
        // rectangle.

        x1 = (INT) pMfArcTo->rclBox.left ;
        y1 = (INT) pMfArcTo->rclBox.top ;
        x2 = (INT) pMfArcTo->rclBox.right ;
        y2 = (INT) pMfArcTo->rclBox.bottom ;

        // Set the start point.

        x3 = (INT) pMfArcTo->ptlStart.x ;
        y3 = (INT) pMfArcTo->ptlStart.y ;

        // Set the end point.

        x4 = (INT) pMfArcTo->ptlEnd.x ;
        y4 = (INT) pMfArcTo->ptlEnd.y ;

        b = DoArcTo(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Arc
 *************************************************************************/
BOOL bHandleArc(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRARC  pMfArc ;
INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

        pMfArc = (PEMRARC) pVoid ;

        // Set up the ellipse box, this will be the same as the bounding
        // rectangle.

        x1 = (INT) pMfArc->rclBox.left ;
        y1 = (INT) pMfArc->rclBox.top ;
        x2 = (INT) pMfArc->rclBox.right ;
        y2 = (INT) pMfArc->rclBox.bottom ;

        // Set the start point.

        x3 = (INT) pMfArc->ptlStart.x ;
        y3 = (INT) pMfArc->ptlStart.y ;

        // Set the end point.

        x4 = (INT) pMfArc->ptlEnd.x ;
        y4 = (INT) pMfArc->ptlEnd.y ;

        b = DoArc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Ellipse
 *************************************************************************/
BOOL bHandleEllipse(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
INT     x1, y1, x2, y2 ;
PEMRELLIPSE  pMfEllipse ;

        pMfEllipse = (PEMRELLIPSE) pVoid ;

        // Set up the ellipse box, this will be the same as the bounding
        // rectangle.

        x1 = (INT) pMfEllipse->rclBox.left ;
        y1 = (INT) pMfEllipse->rclBox.top ;
        x2 = (INT) pMfEllipse->rclBox.right ;
        y2 = (INT) pMfEllipse->rclBox.bottom ;

        // Do the Ellipse translation.

        b = DoEllipse(pLocalDC, x1, y1, x2, y2) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SelectObject
 *************************************************************************/
BOOL bHandleSelectObject(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSELECTOBJECT pMfSelectObject ;
INT     ihObject ;

        pMfSelectObject = (PEMRSELECTOBJECT) pVoid ;

        // Get the Object (it's really a Long)

        ihObject = (INT) pMfSelectObject->ihObject ;

        // Do the translation

        b = DoSelectObject(pLocalDC, ihObject) ;

        return (b) ;
}


/**************************************************************************
 * Handler - DeleteObject
 *************************************************************************/
BOOL bHandleDeleteObject(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRDELETEOBJECT pMfDeleteObject ;
INT     ihObject ;


        pMfDeleteObject = (PEMRDELETEOBJECT) pVoid ;
        ihObject = (INT) pMfDeleteObject->ihObject ;
        b = DoDeleteObject(pLocalDC, ihObject) ;

        return(b) ;
}


/**************************************************************************
 * Handler - CreateBrushIndirect
 *************************************************************************/
BOOL bHandleCreateBrushIndirect(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRCREATEBRUSHINDIRECT  pMfCreateBrushIndirect ;
LOGBRUSH LogBrush ;
INT     ihBrush ;

        pMfCreateBrushIndirect = (PEMRCREATEBRUSHINDIRECT) pVoid ;

        // Get the Brush parameters.

        LogBrush.lbStyle = pMfCreateBrushIndirect->lb.lbStyle;
        LogBrush.lbColor = pMfCreateBrushIndirect->lb.lbColor;
        LogBrush.lbHatch = (ULONG_PTR)pMfCreateBrushIndirect->lb.lbHatch;

        ihBrush   = pMfCreateBrushIndirect->ihBrush ;

        // Do the translation.

        b = DoCreateBrushIndirect(pLocalDC, ihBrush, &LogBrush) ;

        return (b) ;
}

/**************************************************************************
 * Handler - CreateMonoBrush
 *************************************************************************/
BOOL bHandleCreateMonoBrush(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRCREATEMONOBRUSH  pMfCreateMonoBrush ;
DWORD   ihBrush ;
DWORD   iUsage ;
DWORD   offBmi ;
DWORD   cbBmi ;
DWORD   offBits ;
DWORD   cbBits ;

PBITMAPINFO pBmi ;
PBYTE       pBits ;

        pMfCreateMonoBrush = (PEMRCREATEMONOBRUSH) pVoid ;

        ihBrush     =    pMfCreateMonoBrush->ihBrush ;
        iUsage      =    pMfCreateMonoBrush->iUsage ;
        offBmi      =    pMfCreateMonoBrush->offBmi ;
        cbBmi       =    pMfCreateMonoBrush->cbBmi ;
        offBits     =    pMfCreateMonoBrush->offBits ;
        cbBits      =    pMfCreateMonoBrush->cbBits ;

        pBmi        = (PBITMAPINFO) ((PBYTE) pVoid + offBmi) ;
        pBits       = (PBYTE) pVoid + offBits ;

        b = DoCreateMonoBrush(pLocalDC, ihBrush,
                                    pBmi, cbBmi,
                                    pBits, cbBits,
                                    iUsage) ;
        return (b) ;
}

/**************************************************************************
 * Handler - CreateDIBPatternBrush
 *************************************************************************/
BOOL bHandleCreateDIBPatternBrush(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRCREATEDIBPATTERNBRUSHPT  pMfCreateDIBPatternBrush ;
DWORD   ihBrush ;
DWORD   iUsage ;
DWORD   offBmi ;
DWORD   cbBmi ;
DWORD   offBits ;
DWORD   cbBits ;

PBITMAPINFO pBmi ;
PBYTE       pBits ;

        pMfCreateDIBPatternBrush = (PEMRCREATEDIBPATTERNBRUSHPT) pVoid ;

        ihBrush     =    pMfCreateDIBPatternBrush->ihBrush ;
        iUsage      =    pMfCreateDIBPatternBrush->iUsage ;
        offBmi      =    pMfCreateDIBPatternBrush->offBmi ;
        cbBmi       =    pMfCreateDIBPatternBrush->cbBmi ;
        offBits     =    pMfCreateDIBPatternBrush->offBits ;
        cbBits      =    pMfCreateDIBPatternBrush->cbBits ;

        if (!IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfCreateDIBPatternBrush,
                                        offBmi,
                                        cbBmi) ||
            !IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfCreateDIBPatternBrush,
                                        offBits,
                                        cbBits))
        {
            EMFVALFAIL(("MF3216: bHandleCreateDIBPatternBrush failed\n"));
            return(FALSE);
        }

        pBmi        = (PBITMAPINFO) ((PBYTE) pVoid + offBmi) ;
        pBits       = (PBYTE) pVoid + offBits ;

        b = DoCreateDIBPatternBrush(pLocalDC, ihBrush,
                                    pBmi, cbBmi,
                                    pBits, cbBits,
                                    iUsage) ;
        return (b) ;
}


/**************************************************************************
 * Handler - CreatePen
 *************************************************************************/
BOOL bHandleCreatePen(PVOID pVoid, PLOCALDC pLocalDC)
{
PEMRCREATEPEN pMfCreatePen ;
INT          ihPen ;
PLOGPEN      pLogPen ;
BOOL         b ;

        pMfCreatePen = (PEMRCREATEPEN) pVoid ;

        ihPen   = pMfCreatePen->ihPen ;
        pLogPen = &pMfCreatePen->lopn ;

        b = DoCreatePen(pLocalDC, ihPen, pLogPen) ;

        return(b) ;
}


/**************************************************************************
 * Handler - ExtCreatePen
 *************************************************************************/
BOOL bHandleExtCreatePen(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMREXTCREATEPEN     pMfExtCreatePen ;
PEXTLOGPEN          pExtLogPen ;
INT                 ihPen ;

        pMfExtCreatePen = (PEMREXTCREATEPEN) pVoid ;

        pExtLogPen = &pMfExtCreatePen->elp ;
        ihPen      = pMfExtCreatePen->ihPen ;

        b = DoExtCreatePen(pLocalDC, ihPen, pExtLogPen) ;

        return (b) ;
}


/**************************************************************************
 * Handler - MoveToEx
 *************************************************************************/
BOOL bHandleMoveTo(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRMOVETOEX pMfMoveTo ;
INT     x, y ;

        pMfMoveTo = (PEMRMOVETOEX) pVoid ;

        // Get the position.

        x = (INT) pMfMoveTo->ptl.x ;
        y = (INT) pMfMoveTo->ptl.y ;

        // Do the translation.

        b = DoMoveTo(pLocalDC, x, y) ;

        return (b) ;
}


/**************************************************************************
 * Handler - LineTo
 *************************************************************************/
BOOL bHandleLineTo(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRLINETO   pMfLineTo ;
INT     x, y ;

        pMfLineTo = (PEMRLINETO) pVoid ;

        // Get the new point.

        x = (INT) pMfLineTo->ptl.x ;
        y = (INT) pMfLineTo->ptl.y ;

        // Do the translation.

        b = DoLineTo(pLocalDC, x, y) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Chord
 *************************************************************************/
BOOL bHandleChord(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRCHORD  pMfChord ;
INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

        pMfChord = (PEMRCHORD) pVoid ;

        // Set the rectangle

        x1 = (INT) pMfChord->rclBox.left   ;
        y1 = (INT) pMfChord->rclBox.top    ;
        x2 = (INT) pMfChord->rclBox.right  ;
        y2 = (INT) pMfChord->rclBox.bottom ;

        // Set the start point.

        x3 = (INT) pMfChord->ptlStart.x ;
        y3 = (INT) pMfChord->ptlStart.y ;

        // Set the end point.

        x4 = (INT) pMfChord->ptlEnd.x ;
        y4 = (INT) pMfChord->ptlEnd.y ;

        // Do the translation

        b = DoChord(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Pie
 *************************************************************************/
BOOL bHandlePie(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPIE  pMfPie ;
INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

        pMfPie = (PEMRPIE) pVoid ;

        // Set up the ellipse box

        x1 = (INT) pMfPie->rclBox.left   ;
        y1 = (INT) pMfPie->rclBox.top    ;
        x2 = (INT) pMfPie->rclBox.right  ;
        y2 = (INT) pMfPie->rclBox.bottom ;

        // Set the start point.

        x3 = (INT) pMfPie->ptlStart.x ;
        y3 = (INT) pMfPie->ptlStart.y ;

        // Set the end point.

        x4 = (INT) pMfPie->ptlEnd.x ;
        y4 = (INT) pMfPie->ptlEnd.y ;

        // Do the Pie translation.

        b = DoPie(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Polyline
 *************************************************************************/
BOOL bHandlePolyline(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYLINE pMfPolyline ;
INT     nCount ;
PPOINTL pptl ;

        pMfPolyline = (PEMRPOLYLINE) pVoid ;

        // Copy the line count and the polyline verticies to
        // the record.

        nCount = (INT) pMfPolyline->cptl ;
        pptl = pMfPolyline->aptl ;

        // Now do the translation.

        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYLINE) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolylineTo
 *************************************************************************/
BOOL bHandlePolylineTo (PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYLINETO pMfPolylineTo ;
INT     nCount ;
PPOINTL pptl ;

        pMfPolylineTo = (PEMRPOLYLINETO) pVoid ;

        // Copy the line count and the polyline verticies to
        // the record.

        nCount = (INT) pMfPolylineTo->cptl ;
        pptl = pMfPolylineTo->aptl ;

        // Now do the translation.

        b = DoPolylineTo(pLocalDC, pptl, nCount) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyBezier16,Polygon16,Polyline16,PolyBezierTo16,PolylineTo16
 *           PolyDraw16
 *************************************************************************/
BOOL bHandlePoly16 (PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b = FALSE;
PEMRPOLYLINE16 pMfPoly16 ;	// common structure for the poly16 records
PEMRPOLYDRAW16 pMfPolyDraw16 ;
POINTL      aptl[MAX_STACK_POINTL];
PPOINTL     pptl ;
INT         nCount ;
PBYTE       pb ;

// PolyDraw16 contains the structure of Poly16 followed by the byte array.

        pMfPoly16 = (PEMRPOLYLINE16) pVoid ;

        nCount = (INT) pMfPoly16->cpts ;

	if (nCount <= MAX_STACK_POINTL)
	    pptl = aptl;
	else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, nCount * sizeof(POINTL))))
	    return(b);

	POINTS_TO_POINTL(pptl, pMfPoly16->apts, (DWORD) nCount);

        // Now do the translation.

	switch (pMfPoly16->emr.iType)
	{
	    case EMR_POLYBEZIER16:
	        b = DoPolyBezier(pLocalDC, (LPPOINT) pptl, nCount) ;
	        break;

	    case EMR_POLYGON16:
	        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYGON) ;
	        break;

	    case EMR_POLYLINE16:
	        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYLINE) ;
	        break;

	    case EMR_POLYBEZIERTO16:
	        b = DoPolyBezierTo(pLocalDC, (LPPOINT) pptl, nCount) ;
	        break;

	    case EMR_POLYLINETO16:
	        b = DoPolylineTo(pLocalDC, pptl, nCount) ;
	        break;

	    case EMR_POLYDRAW16:
                pMfPolyDraw16 = (PEMRPOLYDRAW16) pVoid ;
                pb = (PBYTE) &pMfPolyDraw16->apts[nCount];
	        b = DoPolyDraw(pLocalDC, (LPPOINT) pptl, pb, nCount);
	        break;

	    default:
	        ASSERTGDI(FALSE, "Bad record type");
	        break;
	}

	if (nCount > MAX_STACK_POINTL)
	    if (LocalFree(pptl))
		ASSERTGDI(FALSE, "bHandlePoly16: LocalFree failed");

        return (b) ;
}


/**************************************************************************
 * Handler - PolyPolyline
 *************************************************************************/
BOOL bHandlePolyPolyline(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYPOLYLINE pMfPolyPolyline ;
PDWORD  pPolyCount ;
PPOINTL pptl ;
INT     nPolys ;

        pMfPolyPolyline = (PEMRPOLYPOLYLINE) pVoid ;

        // Copy the  Polycount count, the polycount array
        // and the polyline verticies to
        // the record.

        nPolys = (INT) pMfPolyPolyline->nPolys ;
        pPolyCount = pMfPolyPolyline->aPolyCounts ;
        pptl = (PPOINTL) &pMfPolyPolyline->aPolyCounts[nPolys] ;

        // Now do the translation.

        b = DoPolyPolyline(pLocalDC, pptl, pPolyCount, nPolys) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyPolyline16,PolyPolygon16
 *************************************************************************/
BOOL bHandlePolyPoly16 (PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b = FALSE;
PEMRPOLYPOLYLINE16 pMfPolyPoly16 ;	// common structure for polypoly16 records
PDWORD  pPolyCount ;
POINTL  aptl[MAX_STACK_POINTL];
PPOINTL pptl ;
INT     nCount;
DWORD	cpts ;

        pMfPolyPoly16 = (PEMRPOLYPOLYLINE16) pVoid ;

        nCount = (INT) pMfPolyPoly16->nPolys ;
	cpts   = pMfPolyPoly16->cpts;
        pPolyCount = pMfPolyPoly16->aPolyCounts ;

	if (cpts <= MAX_STACK_POINTL)
	    pptl = aptl;
	else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, cpts * sizeof(POINTL))))
	    return(b);

	POINTS_TO_POINTL(pptl, (PPOINTS) &pMfPolyPoly16->aPolyCounts[nCount], cpts);

        // Now do the translation.

	switch (pMfPolyPoly16->emr.iType)
	{
	case EMR_POLYPOLYLINE16:
	    b = DoPolyPolyline(pLocalDC, pptl, pPolyCount, nCount) ;
	    break;
	case EMR_POLYPOLYGON16:
	    b = DoPolyPolygon(pLocalDC, pptl, pPolyCount, cpts, nCount) ;
	    break;
	default:
	    ASSERTGDI(FALSE, "Bad record type");
	    break;
	}

	if (cpts > MAX_STACK_POINTL)
	    if (LocalFree(pptl))
		ASSERTGDI(FALSE, "bHandlePolyPoly16: LocalFree failed");

        return (b) ;
}


/**************************************************************************
 * Handler - Polygon
 *************************************************************************/
BOOL bHandlePolygon (PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYGON pMfPolygon ;
PPOINTL pptl ;
INT     nCount ;

        pMfPolygon = (PEMRPOLYGON) pVoid ;

        // Copy the line count and the Polygon verticies to
        // the record.

        nCount = (INT) pMfPolygon->cptl ;
        pptl = pMfPolygon->aptl ;

        // Now do the translation.

        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYGON) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyPolygon
 *************************************************************************/
BOOL bHandlePolyPolygon(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYPOLYGON pMfPolyPolygon ;
PDWORD  pPolyCount ;
PPOINTL pptl ;
DWORD	cptl ;
INT     nPolys ;

        pMfPolyPolygon = (PEMRPOLYPOLYGON) pVoid ;

        // Copy the  Polycount count, the polycount array
        // and the polygon verticies to
        // the record.

        nPolys = (INT) pMfPolyPolygon->nPolys ;
        pPolyCount = pMfPolyPolygon->aPolyCounts ;
        pptl = (PPOINTL) &pMfPolyPolygon->aPolyCounts[nPolys] ;
	cptl = pMfPolyPolygon->cptl ;

        // Now do the translation.

        b = DoPolyPolygon(pLocalDC, pptl, pPolyCount, cptl, nPolys) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Rectangle
 *************************************************************************/
BOOL bHandleRectangle(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRRECTANGLE  pMfRectangle ;
INT     x1, y1, x2, y2 ;

        pMfRectangle = (PEMRRECTANGLE) pVoid ;

        // Set up the Rectangle box, this will be the same as the bounding
        // rectangle.

        x1 = (INT) pMfRectangle->rclBox.left   ;
        y1 = (INT) pMfRectangle->rclBox.top    ;
        x2 = (INT) pMfRectangle->rclBox.right  ;
        y2 = (INT) pMfRectangle->rclBox.bottom ;

        // Do the Rectangle translation.

        b = DoRectangle(pLocalDC, x1, y1, x2, y2) ;

        return (b) ;
}


/**************************************************************************
 * Handler - RoundRect
 *************************************************************************/
BOOL bHandleRoundRect (PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRROUNDRECT  pMfRoundRect ;
INT     x1, y1, x2, y2, x3, y3 ;

        pMfRoundRect = (PEMRROUNDRECT) pVoid ;

        // Set up the RoundRect box, this will be the same as the bounding
        // RoundRect.

        x1 = (INT) pMfRoundRect->rclBox.left   ;
        y1 = (INT) pMfRoundRect->rclBox.top    ;
        x2 = (INT) pMfRoundRect->rclBox.right  ;
        y2 = (INT) pMfRoundRect->rclBox.bottom ;
        x3 = (INT) pMfRoundRect->szlCorner.cx ;
        y3 = (INT) pMfRoundRect->szlCorner.cy ;

        // Do the RoundRect translation.

        b = DoRoundRect(pLocalDC, x1, y1, x2, y2, x3, y3) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ExtTextOut for both ANSI and UNICODE characters.
 **************************************************************************/
BOOL bHandleExtTextOut(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMREXTTEXTOUTA  pMfExtTextOut ;	// same for both ansi and unicode
INT     x, y, nCount ;
DWORD   flOptions ;
PRECTL  pRectl ;
PLONG   pDx ;
PWCH    pwchar ;
DWORD   iGraphicsMode;

        pMfExtTextOut = (PEMREXTTEXTOUTA) pVoid ;

	ASSERTGDI(pMfExtTextOut->emr.iType == EMR_EXTTEXTOUTA
	       || pMfExtTextOut->emr.iType == EMR_EXTTEXTOUTW,
		  "MF3216: bHandleExtTextOut: bad record type");

        if (!IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfExtTextOut,
                                        pMfExtTextOut->emrtext.offString,
                                        0)  ||
            !IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                        pMfExtTextOut,
                                        pMfExtTextOut->emrtext.offDx,
                                        0))
        {
            EMFVALFAIL(("MF3216: bHandleExtTextOut failed\n"));
            return(FALSE);
        }
        // Copy over the start position for the string.

        x = (INT) pMfExtTextOut->emrtext.ptlReference.x ;
        y = (INT) pMfExtTextOut->emrtext.ptlReference.y ;

        // Now copy over the Options flag, character count,
        // the clip/opaque rectangle, and the Ansi/Unicode string.

        flOptions = pMfExtTextOut->emrtext.fOptions  ;
        nCount    = (INT) pMfExtTextOut->emrtext.nChars ;
        pRectl    = &pMfExtTextOut->emrtext.rcl ;
        pwchar    = (PWCH) ((PBYTE) pMfExtTextOut + pMfExtTextOut->emrtext.offString);
        iGraphicsMode = pMfExtTextOut->iGraphicsMode;

        // Set up the spacing vector

        pDx = (PLONG) ((PBYTE) pMfExtTextOut + pMfExtTextOut->emrtext.offDx);

        // Now do the conversion.

        b = DoExtTextOut(pLocalDC, x, y, flOptions,
                         pRectl, pwchar, nCount, pDx, iGraphicsMode,
			 pMfExtTextOut->emr.iType);

        return (b) ;
}


/**************************************************************************
 * Handler - PolyTextOut for both ANSI and UNICODE characters.
 **************************************************************************/
BOOL bHandlePolyTextOut(PVOID pVoid, PLOCALDC pLocalDC)
{
PEMRPOLYTEXTOUTA pMfPolyTextOut;	// same for both ansi and unicode
PWCH    pwchar;
LONG    i;
DWORD   iType;
LONG    cStrings;
PEMRTEXT pemrtext;
PLONG   pDx ;
DWORD   iGraphicsMode;

        pMfPolyTextOut = (PEMRPOLYTEXTOUTA) pVoid ;

	ASSERTGDI(pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTA
	       || pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTW,
		  "MF3216: bHandlePolyTextOut: bad record type");

	iType  = pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTA
		 ? EMR_EXTTEXTOUTA
		 : EMR_EXTTEXTOUTW;
	cStrings = pMfPolyTextOut->cStrings;
        iGraphicsMode = pMfPolyTextOut->iGraphicsMode;

	// Convert to ExtTextOut

	for (i = 0; i < cStrings; i++)
	{
	    pemrtext = &pMfPolyTextOut->aemrtext[i];
            if (!IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                            pMfPolyTextOut,
                                            pemrtext->offString,
                                            0)  ||
                !IsValidEnhMetaRecordOffExt(pLocalDC->pht,
                                            pMfPolyTextOut,
                                            pemrtext->offDx,
                                            0))
            {
                EMFVALFAIL(("MF3216: bHandlePolyTextOut failed\n"));
                return(FALSE);
            }
	    pwchar = (PWCH) ((PBYTE) pMfPolyTextOut + pemrtext->offString);
	    pDx    = (PLONG) ((PBYTE) pMfPolyTextOut + pemrtext->offDx);

	    if (!DoExtTextOut(pLocalDC, pemrtext->ptlReference.x, pemrtext->ptlReference.y,
			pemrtext->fOptions, &pemrtext->rcl,
			pwchar, pemrtext->nChars, pDx, iGraphicsMode, iType))
		return(FALSE);
	}

	return(TRUE);
}


/**************************************************************************
 * Handler - ExtCreateFont
 *************************************************************************/
BOOL bHandleExtCreateFont(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b;
PEMREXTCREATEFONTINDIRECTW pMfExtCreateFontW;
PLOGFONTW plfw;
INT       ihFont;

        pMfExtCreateFontW = (PEMREXTCREATEFONTINDIRECTW) pVoid ;

        // Get the font parameters.

        ihFont = (INT) pMfExtCreateFontW->ihFont ;
        plfw  = &pMfExtCreateFontW->elfw.elfLogFont;

        // Do the translation.

        b = DoExtCreateFont(pLocalDC, ihFont, plfw);

        return (b) ;
}


/**************************************************************************
 * Handler - SetBkColor
 *************************************************************************/
BOOL bHandleSetBkColor(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRSETBKCOLOR pMfSetBkColor ;

        pMfSetBkColor = (PEMRSETBKCOLOR) pVoid ;

        // Do the translation.

        b = DoSetBkColor(pLocalDC, pMfSetBkColor->crColor) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetBkMode
 *************************************************************************/
BOOL bHandleSetBkMode(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   iBkMode ;
PEMRSETBKMODE pMfSetBkMode ;

        pMfSetBkMode = (PEMRSETBKMODE) pVoid ;

        // Set the Background Mode variable

        iBkMode = pMfSetBkMode->iMode ;

        // Do the translation.

        b = DoSetBkMode(pLocalDC, iBkMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetMapperFlags
 *************************************************************************/
BOOL bHandleSetMapperFlags(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   f ;
PEMRSETMAPPERFLAGS pMfSetMapperFlags ;

        pMfSetMapperFlags = (PEMRSETMAPPERFLAGS) pVoid ;

        f = pMfSetMapperFlags->dwFlags ;

        // Do the translation.

        b = DoSetMapperFlags(pLocalDC, f) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetPolyFillMode
 *************************************************************************/
BOOL bHandleSetPolyFillMode(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
INT     iPolyFillMode ;
PEMRSETPOLYFILLMODE pMfSetPolyFillMode ;

        pMfSetPolyFillMode = (PEMRSETPOLYFILLMODE) pVoid ;

        // Set the PolyFill Mode

        iPolyFillMode = (INT) pMfSetPolyFillMode->iMode ;

        // Do the translation.

        b = DoSetPolyFillMode(pLocalDC, iPolyFillMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetRop2
 *************************************************************************/
BOOL bHandleSetRop2(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   iDrawMode ;
PEMRSETROP2 pMfSetROP2 ;

        pMfSetROP2 = (PEMRSETROP2) pVoid ;

        // Set the Draw Mode

        iDrawMode = pMfSetROP2->iMode ;

        // Do the translation.

        b = DoSetRop2(pLocalDC, iDrawMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetStretchBltMode
 *************************************************************************/
BOOL bHandleSetStretchBltMode(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   iStretchMode ;
PEMRSETSTRETCHBLTMODE pMfSetStretchBltMode ;

        pMfSetStretchBltMode = (PEMRSETSTRETCHBLTMODE) pVoid ;

        // Set the StretchBlt Mode

        iStretchMode = pMfSetStretchBltMode->iMode ;

        // Do the translation.

        b = DoSetStretchBltMode(pLocalDC, iStretchMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetTextAlign
 *************************************************************************/
BOOL bHandleSetTextAlign(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   fMode ;
PEMRSETTEXTALIGN pMfSetTextAlign ;

        pMfSetTextAlign = (PEMRSETTEXTALIGN) pVoid ;

        // Set the TextAlign Mode

        fMode = pMfSetTextAlign->iMode ;

        // Do the translation.

        b = DoSetTextAlign(pLocalDC, fMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetTextColor
 *************************************************************************/
BOOL bHandleSetTextColor(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRSETTEXTCOLOR pMfSetTextColor ;

        pMfSetTextColor = (PEMRSETTEXTCOLOR) pVoid ;

        // Do the translation.

        b = DoSetTextColor(pLocalDC, pMfSetTextColor->crColor) ;

        return (b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\mf3216.h ===
/*****************************************************************************
 *
 *  MF3216.h - The include file for MF3216.  This will contain all
 *             the miscellaneous includes.
 *
 *  Author: Jeffrey Newman (c-jeffn)
 *
 *  Creation Date: 31-Jan-1992
 *
 ****************************************************************************/


#ifndef _MF3216_
#define _MF3216_

#include    <windows.h>

typedef struct _w16objhndlslotstatus {
    INT     use ;
    HANDLE  w32Handle ;
} W16OBJHNDLSLOTSTATUS ;

typedef W16OBJHNDLSLOTSTATUS *PW16OBJHNDLSLOTSTATUS ;


typedef struct _localDC {
    UINT    nSize ;                     // Size of this Local DC structure.
    DWORD   flags ;                     // Boolean controls.
    PBYTE   pMf32Bits ;                 // ptr to W32 metafile bits.
    UINT    cMf32Bits ;                 // count of W32 metafile size.
    PBYTE   pMf16Bits ;                 // ptr to user supplied out buffer
    UINT    cMf16Dest ;                 // length of user supplied buffer
    HDC     hdcHelper ;                 // Our helper DC.
    HDC     hdcRef ;                    // Reference DC.
    INT     iMapMode ;                  // User requested map mode.
    INT     cxPlayDevMM,
            cyPlayDevMM,
            cxPlayDevPels,
            cyPlayDevPels ;
    XFORM   xformRWorldToRDev,          // aka Metafile-World to Metafile-Device
            xformRDevToRWorld,          // aka Metafile-Device to Metafile-World
            xformRDevToPDev,            // aka Metafile-Device to Reference-Device
            xformPDevToPPage,           // aka Reference-Device to Reference-Logical
            xformPPageToPDev,           // aka Reference-Logical to Reference-Device
            xformRDevToPPage,           // aka Metafile-Device to Reference-Logical
            xformRWorldToPPage ;
    POINT   ptCP ;                      // Current position
    PBYTE   pbEnd ;                     // End of W32 metafile bits.
    METAHEADER  mf16Header ;            // The W16 metafile header.
    PINT    piW32ToW16ObjectMap ;
    UINT    cW16ObjHndlSlotStatus ;     // used in slot search
    UINT    cW32ToW16ObjectMap ;        // used in Normalize handle.
    PW16OBJHNDLSLOTSTATUS   pW16ObjHndlSlotStatus ;
    COLORREF crTextColor ;              // current text color - used by
                                        // ExtCreatePen.
    COLORREF crBkColor ;                // Current background color
    INT     iArcDirection ;             // Current arc direction in W32 metafile
    LONG    lhpn32;			// Currently selected pen.  Used in path and text
    LONG    lhbr32;			// Currently selected brush.  Used in text
    DWORD   ihpal32;			// Currently selected (i32) palette.
    DWORD   ihpal16;			// Currently selected (i16) palette.
    UINT    iLevel;			// Current DC save level.
    struct _localDC *pLocalDCSaved;     // Point to the saved DCs

// The following fields are not restored by RestoreDC!

    UINT    ulBytesEmitted ;            // Total bytes emitted so far.
    UINT    ulMaxRecord ;               // Max W16 record size.
    INT     nObjectHighWaterMark;       // Max slot index used so far.
    PBYTE   pbCurrent;                  // Current record in W32 metafile bits.
    DWORD   cW32hPal;			// Size of private W32 palette table.
    HPALETTE *pW32hPal;			// Private W32 palette table.
    PVOID    pht;                       // Points to Win32 MF handle table.
                                        // Used in validation of Win32 records.
} LOCALDC ;

typedef LOCALDC *PLOCALDC ;

// Routines in apientry.c

BOOL bHandleWin32Comment(PLOCALDC pLocalDC);

// Routines in misc.c

BOOL bValidateMetaFileCP(PLOCALDC pLocalDC, LONG x, LONG y);

// Following are the bit definitions for the flags.

#define SIZE_ONLY               0x00000001
#define INCLUDE_W32MF_COMMENT   0x00000002
#define STRANGE_XFORM           0x00000004
#define RECORDING_PATH          0x00000008
#define ERR_BUFFER_OVERFLOW   0x80000000


// This define sets the size of each Win32 metafile comment record.
// The reason we do not just use a 64K record is due to a caution given
// to use about large escape records in Win3.0 by the GBU (MS Palo Alto).

#define MAX_WIN32_COMMENT_REC_SIZE  0x2000


// Function(s) used in parser.c

extern BOOL  bParseWin32Metafile(PBYTE pMetafileBits, PLOCALDC pLocalDC) ;

// Function definitions for preamble.

extern BOOL bUpdateMf16Header(PLOCALDC pLocalDC) ;

// Function definitions for the emitter.

extern BOOL bEmit(PLOCALDC pLocalDC, PVOID pBuffer, DWORD nCount) ;
extern VOID vUpdateMaxRecord(PLOCALDC pLocalDC, PMETARECORD pmr);

// Defines used in objects.c

#define OPEN_AVAILABLE_SLOT         1
#define REALIZED_BRUSH              2
#define REALIZED_PEN                3
#define REALIZED_BITMAP             4
#define REALIZED_PALETTE            5
#define REALIZED_REGION             6
#define REALIZED_FONT               7
#define REALIZED_OBJECT             8  // used by multiformats record
#define REALIZED_DUMMY              9  // used by multiformats record

#define UNMAPPED                    -1

// Routines in objects.c

extern BOOL bInitHandleTableManager(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;
extern INT  iGetW16ObjectHandleSlot(PLOCALDC pLocalDC, INT iIntendedUse) ;
extern INT  iValidateHandle(PLOCALDC pLocalDC, INT ihW32) ;
extern INT  iAllocateW16Handle(PLOCALDC pLocalDC, INT ihW32, INT iIntendedUse) ;
extern BOOL bDeleteW16Object(PLOCALDC pLocalDC, INT ihW16) ;
extern INT  iNormalizeHandle(PLOCALDC pLocalDC, INT ihW32) ;

// Routines in text.c

VOID vUnicodeToAnsi(PCHAR pAnsi, PWCH pUnicode, DWORD cch) ;

// Routines in regions.c

BOOL bNoDCRgn(PLOCALDC pLocalDC, INT iType);
BOOL bDumpDCClipping(PLOCALDC pLocalDC);

// Defines used in bNoDCRgn().

#define DCRGN_CLIP     1
#define DCRGN_META     2

// Defines used in xforms.c

#define     CX_MAG  1
#define     CY_MAG  2

typedef struct
{
    FLOAT x;
    FLOAT y;
} POINTFL;
typedef POINTFL *PPOINTFL;

// Function definitions from xform

extern BOOL bInitXformMatrices(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;

extern BOOL bXformRWorldToPPage(PLOCALDC pLocalDC, PPOINTL aptl, DWORD nCount) ;
extern BOOL bXformRWorldToRDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformPDevToPPage(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformPPageToPDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformRDevToRWorld(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;

extern INT  iMagnitudeXform (PLOCALDC pLocalDC, INT value, INT iType) ;

extern XFORM xformIdentity ;
extern BOOL  bRotationTest(PXFORM pxform) ;
extern INT   iMagXformWorkhorse (INT value, PXFORM pxform, INT iType) ;
extern BOOL  bXformWorkhorse(PPOINTL aptl, DWORD nCount, PXFORM pXform) ;
extern VOID  vXformWorkhorseFloat(PPOINTFL aptfl, UINT nCount, PXFORM pXform);
extern BOOL  bCoordinateOverflowTest(PLONG pCoordinates, INT nCount) ;


// Defines used in Conics

#define SWAP(x,y,t)        {t = x; x = y; y = t;}

#define ePI ((FLOAT)(((FLOAT) 22.0 / (FLOAT) 7.0 )))

// Exported support functions and defines for Conics & rectangles.

extern BOOL bConicCommon (PLOCALDC pLocalDC, INT x1, INT y1, INT x2, INT y2,
                                             INT x3, INT y3, INT x4, INT y4,
                                             DWORD mrType) ;

extern BOOL bRenderCurveWithPath
(
    PLOCALDC pLocalDC,
    LPPOINT  pptl,
    PBYTE    pb,
    DWORD    cptl,
    INT      x1,
    INT      y1,
    INT      x2,
    INT      y2,
    INT      x3,
    INT      y3,
    INT      x4,
    INT      y4,
    DWORD    nRadius,
    FLOAT    eStartAngle,
    FLOAT    eSweepAngle,
    DWORD    mrType
);

// Exported functions from lines.c

extern VOID vCompressPoints(PVOID pBuff, LONG nCount) ;


// Defines (macros) used in bitmaps.

// Check if a source is needed in a 3-way bitblt operation.
// This works on both rop and rop3.  We assume that a rop contains zero
// in the high byte.
//
// This is tested by comparing the rop result bits with source (column A
// below) vs. those without source (column B).  If the two cases are
// identical, then the effect of the rop does not depend on the source
// and we don't need a source device.  Recall the rop construction from
// input (pattern, source, target --> result):
//
//	P S T | R   A B 	mask for A = 0CCh
//	------+-------- 	mask for B =  33h
//	0 0 0 | x   0 x
//	0 0 1 | x   0 x
//	0 1 0 | x   x 0
//	0 1 1 | x   x 0
//	1 0 0 | x   0 x
//	1 0 1 | x   0 x
//	1 1 0 | x   x 0
//	1 1 1 | x   x 0

#define ISSOURCEINROP3(rop3)	\
	(((rop3) & 0xCCCC0000) != (((rop3) << 2) & 0xCCCC0000))


#define CJSCAN(width,planes,bits) ((((width)*(planes)*(bits)+31) & ~31) / 8)

#define MAX4(a, b, c, d)    max(max(max(a,b),c),d)
#define MIN4(a, b, c, d)    min(min(min(a,b),c),d)

#include "debug.h"

#endif  //_MF3216_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\lines.c ===
/*****************************************************************************
 *
 * lines - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  PolylineTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolylineTo
(
PLOCALDC pLocalDC,
PPOINTL pptl,
DWORD   cptl
)
{
BOOL    b ;

    // Handle path.

        if (pLocalDC->flags & RECORDING_PATH)
        return(PolylineTo(pLocalDC->hdcHelper, (LPPOINT) pptl, (DWORD) cptl));

    // Handle the trivial case.

    if (cptl == 0)
        return(TRUE);

        // This can be done by using a LineTo, PolyLine, & MoveTo.

        if (!DoLineTo(pLocalDC, pptl[0].x, pptl[0].y))
        return(FALSE);

    // If there is only one point, we are done.

    if (cptl == 1)
        return(TRUE);

        if (!DoPoly(pLocalDC, pptl, cptl, EMR_POLYLINE))
        return(FALSE);

        b = DoMoveTo(pLocalDC, pptl[cptl-1].x, pptl[cptl-1].y) ;
        return (b) ;
}


/***************************************************************************
 *  PolyPolyline  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyPolyline
(
PLOCALDC pLocalDC,
PPOINTL pptl,                       // -> to PolyPolyline points.
PDWORD  pcptl,                      // -> to PolyCounts
DWORD   ccptl                       // # of PolyCounts.
)
{
BOOL    b ;
UINT    i,
        iStart,
        nCount ;

    b = TRUE;       // just in case if there is no poly

        // Let polyline do the work.

        iStart = 0 ;
        for (i = 0 ; i < ccptl ; i++)
        {
            nCount = pcptl[i] ;
            b = DoPoly(pLocalDC, &pptl[iStart], nCount, EMR_POLYLINE) ;
            if (b == FALSE)
                break ;
            iStart += nCount ;
        }

        return(b) ;
}


/***************************************************************************
 *  LineTo  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  See DoMoveTo() in misc.c for notes on the current position.
 **************************************************************************/
BOOL WINAPI DoLineTo
(
PLOCALDC  pLocalDC,
LONG    x,
LONG    y
)
{
BOOL    b ;
POINT   pt ;
POINT   ptCP;

        // Whether we are recording for a path or acutally emitting
        // a drawing order we must pass the drawing order to the helper DC
        // so the helper can maintain the current positon.
        // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        return(LineTo(pLocalDC->hdcHelper, (INT) x, (INT) y));

    // Update the current position in the converted metafile if
    // it is different from that of the helper DC.  See notes
    // in DoMoveTo().

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        return(FALSE);

    // Make sure that the converted metafile has the same CP as the
    // helper DC.

    if (!bValidateMetaFileCP(pLocalDC, ptCP.x, ptCP.y))
        return(FALSE);

    // Update the helper DC.

    if (!LineTo(pLocalDC->hdcHelper, (INT) x, (INT) y))
        return(FALSE);

        // Compute the new current position.

        pt.x = x ;
        pt.y = y ;
    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &pt, 1L))
        return(FALSE);

        // Update the mf16 current position to what it will be when this call
        // is finished.

        pLocalDC->ptCP = pt ;

        // Call the Win16 routine to emit the line to the metafile.

        b = bEmitWin16LineTo(pLocalDC, LOWORD(pt.x), LOWORD(pt.y)) ;
        return(b) ;
}

/***************************************************************************
 *  Polyline/Polygon  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPoly
(
PLOCALDC pLocalDC,
PPOINTL  pptl,
DWORD    cptl,
INT      mrType
)
{
BOOL    b ;
PPOINTL pptlBuff ;

        // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
        switch(mrType)
        {
        case EMR_POLYLINE:
        b = Polyline(pLocalDC->hdcHelper, (LPPOINT) pptl, (INT) cptl) ;
        break;
        case EMR_POLYGON:
        b = Polygon(pLocalDC->hdcHelper, (LPPOINT) pptl, (INT) cptl) ;
        break;
        }
            return(b) ;
        }

        // The Win16 poly record is limited to 64K points.
        // Need to check this limit.

        if (cptl > (DWORD) (WORD) MAXWORD)
    {
        b = FALSE;
            PUTS("MF3216: DoPoly, Too many point in poly array\n") ;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY) ;
            goto exit1 ;
    }

        // Allocate a buffer to do the transformation in.
        // Then copy the points to this buffer.

        pptlBuff = (PPOINTL) LocalAlloc(LMEM_FIXED, cptl * sizeof(POINTL)) ;
        if (!pptlBuff)
        {
        b = FALSE;
            PUTS("MF3216: DoPoly, LocalAlloc failed\n") ;
            goto exit1 ;
        }

        RtlCopyMemory(pptlBuff, pptl, cptl * sizeof(POINTL)) ;

        // Do the transformations.

    b = bXformRWorldToPPage(pLocalDC, pptlBuff, cptl) ;
        if (b == FALSE)
            goto exit2 ;

        // Compress the POINTLs to POINTSs

        vCompressPoints(pptlBuff, cptl) ;

        // Call the Win16 routine to emit the poly to the metafile.

    b = bEmitWin16Poly(pLocalDC, (LPPOINTS) pptlBuff, (SHORT) cptl,
        (WORD) (mrType == EMR_POLYLINE ? META_POLYLINE : META_POLYGON)) ;

        // Free the memory used as the transform buffer.
exit2:
        if (LocalFree(pptlBuff))
        ASSERTGDI(FALSE, "MF3216: DoPoly, LocalFree failed");
exit1:
        return(b) ;
}


/***************************************************************************
 * vCompressPoints - Utility routine to compress the POINTLs to POINTSs.
 **************************************************************************/
VOID vCompressPoints(PVOID pBuff, LONG nCount)
{
PPOINTL pPointl ;
PPOINTS pPoints ;
INT     i ;

        pPointl = (PPOINTL) pBuff ;
        pPoints = (PPOINTS) pBuff ;

        for (i = 0 ; i < nCount ; i++)
        {
            pPoints[i].x = LOWORD(pPointl[i].x) ;
            pPoints[i].y = LOWORD(pPointl[i].y) ;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\misc.c ===
/*****************************************************************************
 *
 * misc - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


BOOL WINAPI GetTransform(HDC hdc,DWORD iXform,LPXFORM pxform);

BOOL WINAPI DoGdiCommentMultiFormats
(
 PLOCALDC pLocalDC,
 PEMRGDICOMMENT_MULTIFORMATS pemr
);

/***************************************************************************
 *  ExtFloodFill  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtFloodFill
(
 PLOCALDC    pLocalDC,
 int         x,
 int         y,
 COLORREF    crColor,
 DWORD       iMode
)
{
POINTL	ptl ;
BOOL	b ;

	ptl.x = (LONG) x ;
	ptl.y = (LONG) y ;

	b = bXformRWorldToPPage(pLocalDC, &ptl, 1) ;
        if (b == FALSE)
            goto exit1 ;

	b = bEmitWin16ExtFloodFill(pLocalDC, LOWORD(ptl.x), LOWORD(ptl.y), crColor, LOWORD(iMode)) ;
exit1:
	return(b) ;

}

/***************************************************************************
 *  MoveToEx  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  NOTE ON CURRENT POSITION
 *  ------------------------
 *  There are only three Win16 functions that use and update the
 *  current position (CP).  They are:
 *
 *      MoveTo
 *      LineTo
 *      (Ext)TextOut with TA_UPDATECP text alignment option
 *
 *  In Win32, CP is used in many more functions and has two
 *  interpretations based on the state of the current path.
 *  As a result, it is easier and more robust to rely on the
 *  helper DC to keep track of the CP than doing it in the
 *  converter.  To do this, we need to do the following:
 *
 *  1. The converter will update the CP in the helper DC in all
 *     records that modify the CP.
 *
 *  2. The converter will keep track of the CP in the converted
 *     metafile at all time.
 *
 *  3. In LineTo and (Ext)TextOut, the metafile CP is compared to
 *     that of the helper DC.  If they are different, a MoveTo record
 *     is emitted.  This is done in bValidateMetaFileCP().
 *
 *  4. The converter should emit a MoveTo record the first time the
 *     CP is used in the converted metafile.
 *
 *  - HockL  July 2, 1992
 **************************************************************************/
BOOL WINAPI DoMoveTo
(
PLOCALDC  pLocalDC,
LONG    x,
LONG    y
)
{
BOOL    b ;
POINTL  ptl ;

        // Whether we are recording for a path or acutally emitting
        // a drawing order we must pass the drawing order to the helper DC
        // so the helper can maintain the current positon.
        // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        b = MoveToEx(pLocalDC->hdcHelper, (INT) x, (INT) y, (LPPOINT) &ptl) ;
        if (pLocalDC->flags & RECORDING_PATH)
            return(b) ;

	// Update the CP in the converted metafile.

        b = bValidateMetaFileCP(pLocalDC, x, y) ;
        return(b) ;
}


/***************************************************************************
 *  bValidateMetaFiloeCP  - Update the current position in the converted
 *                          metafile.
 *
 *  x and y are assumed to be in the record time world coordinates.
 *
 **************************************************************************/
BOOL bValidateMetaFileCP(PLOCALDC pLocalDC, LONG x, LONG y)
{
BOOL    b ;
POINT   pt ;

        // Compute the new current position in the play time page coord.

        pt.x = x ;
        pt.y = y ;
	if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &pt, 1L))
	    return(FALSE);

	// No need to emit the record if the converted metafile has
	// the same CP.

        if (pLocalDC->ptCP.x == pt.x && pLocalDC->ptCP.y == pt.y)
	    return(TRUE);

        // Call the Win16 routine to emit the move to the metafile.

        b = bEmitWin16MoveTo(pLocalDC, LOWORD(pt.x), LOWORD(pt.y)) ;

        // Update the mf16 current position.

        pLocalDC->ptCP = pt ;

        return(b) ;
}

/***************************************************************************
 *  SaveDC  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSaveDC
(
PLOCALDC pLocalDC
)
{
BOOL    b;
PLOCALDC pLocalDCNew;

    b = FALSE;

// Save the helper DC's state first

    if (!SaveDC(pLocalDC->hdcHelper))
    {
        RIP("MF3216: DoSaveDC, SaveDC failed\n");
        return(b);
    }

// Allocate some memory for the LocalDC.

    pLocalDCNew = (PLOCALDC) LocalAlloc(LMEM_FIXED, sizeof(LOCALDC));
    if (pLocalDCNew == (PLOCALDC) NULL)
    {
        RIP("MF3216: DoSaveDC, LocalAlloc failed\n");
        return(b);
    }

// Copy the data from the current LocalDC to the new one just allocated.

    *pLocalDCNew = *pLocalDC;

// Link in the new level.

    pLocalDC->pLocalDCSaved = pLocalDCNew;
    pLocalDC->iLevel++;

// Emit Win16 drawing order.

    b = bEmitWin16SaveDC(pLocalDC);

    return(b);
}

/***************************************************************************
 *  RestoreDC  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoRestoreDC
(
PLOCALDC pLocalDC,
int nSavedDC
)
{
BOOL     b;
INT      iLevel;
PLOCALDC pLocalDCNext;
PLOCALDC pLocalDCTmp;

    b = FALSE;

// First check to make sure this is a relative save level.

    if (nSavedDC > 0)
        return(b);

// Restore the helper DC's state first
// If we can restore the helper DC, we know that it is a balanced restore.
// Otherwise, we return an error.

    if (!RestoreDC(pLocalDC->hdcHelper, nSavedDC))
        return(b);

// Compute an absolute level.

    iLevel = pLocalDC->iLevel + nSavedDC;

// The helper DC should have caught bogus levels.

    ASSERTGDI((iLevel >= 0) && ((UINT) iLevel < pLocalDC->iLevel),
	"MF3216: DoRestoreDC, Bogus RestoreDC");

// Restore down to the level we want.

    pLocalDCNext = pLocalDC->pLocalDCSaved;
    while ((UINT) iLevel < pLocalDCNext->iLevel)
    {
	pLocalDCTmp = pLocalDCNext;
	pLocalDCNext = pLocalDCNext->pLocalDCSaved;
        if (LocalFree(pLocalDCTmp))
	    ASSERTGDI(FALSE, "MF3216: DoRestoreDC, LocalFree failed");
    }

// Restore the state of our local DC to that level.

    // keep some of the attributes in the current DC

    pLocalDCNext->ulBytesEmitted        = pLocalDC->ulBytesEmitted;
    pLocalDCNext->ulMaxRecord           = pLocalDC->ulMaxRecord;
    pLocalDCNext->nObjectHighWaterMark  = pLocalDC->nObjectHighWaterMark;
    pLocalDCNext->pbCurrent             = pLocalDC->pbCurrent;
    pLocalDCNext->cW16ObjHndlSlotStatus = pLocalDC->cW16ObjHndlSlotStatus;
    pLocalDCNext->pW16ObjHndlSlotStatus = pLocalDC->pW16ObjHndlSlotStatus;

    // now restore the other attributes

    *pLocalDC = *pLocalDCNext;

// Free the local copy of the DC.

    if (LocalFree(pLocalDCNext))
	ASSERTGDI(FALSE, "MF3216: DoRestoreDC, LocalFree failed");

// Emit the record to the Win16 metafile.

    b = bEmitWin16RestoreDC(pLocalDC, LOWORD(nSavedDC)) ;

    return (b) ;
}

/***************************************************************************
 *  SetRop2  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetRop2
(
PLOCALDC  pLocalDC,
DWORD   rop
)
{
BOOL    b ;

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetROP2(pLocalDC, LOWORD(rop)) ;

        return(b) ;
}

/***************************************************************************
 *  SetBkMode  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetBkMode
(
PLOCALDC  pLocalDC,
DWORD   iBkMode
)
{
BOOL    b ;

	// Do it to the helper DC.  It needs this in a path bracket
	// if a text string is drawn.

	SetBkMode(pLocalDC->hdcHelper, (int) iBkMode);

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetBkMode(pLocalDC, LOWORD(iBkMode)) ;

        return(b) ;
}

/***************************************************************************
 *  SetBkColor  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoSetBkColor
(
PLOCALDC    pLocalDC,
COLORREF    crColor
)
{
BOOL    b ;

        pLocalDC->crBkColor = crColor;	// used by brushes

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetBkColor(pLocalDC, crColor) ;

        return(b) ;
}

/***************************************************************************
 *  GdiComment  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoGdiComment
(
 PLOCALDC   pLocalDC,
 PEMR       pemr
)
{
    BOOL    b;
    PEMRGDICOMMENT_PUBLIC pemrComment = (PEMRGDICOMMENT_PUBLIC) pemr;

// If it's not a public comment, just return TRUE.

    if (pemrComment->emr.nSize < sizeof(EMRGDICOMMENT_PUBLIC)
     || pemrComment->ident != GDICOMMENT_IDENTIFIER)
	return(TRUE);

// Handle public comments.
// A public comment consists of a public comment identifier,
// a comment type, plus any accompanying data.

    switch (pemrComment->iComment)
    {
    case GDICOMMENT_MULTIFORMATS:
	b = DoGdiCommentMultiFormats(pLocalDC, (PEMRGDICOMMENT_MULTIFORMATS) pemr);
	break;
    case GDICOMMENT_BEGINGROUP:
    case GDICOMMENT_ENDGROUP:
    case GDICOMMENT_WINDOWS_METAFILE:
    default:
	b = TRUE;
	break;
    }

    return(b) ;
}

BOOL WINAPI DoGdiCommentMultiFormats
(
 PLOCALDC pLocalDC,
 PEMRGDICOMMENT_MULTIFORMATS pemrcmf
)
{
    DWORD  i;
    DWORD  cSizeOld;
    int    iBase;
    XFORM  xformNew, xformScale;
    POINTL aptlFrame[4];
    RECTL  rclFrame;
    UINT   cbwmfNew;
    SIZEL  szlDeviceNew, szlMillimetersNew;
    BOOL   bRet      = FALSE;
    PBYTE  pbwmfNew  = (PBYTE) NULL;
    HDC    hdcemfNew = (HDC) 0;
    HENHMETAFILE   hemf    = (HENHMETAFILE) 0;
    HENHMETAFILE   hemfNew = (HENHMETAFILE) 0;
    PENHMETAHEADER pemfh;
    WIN16LOGBRUSH  Win16LogBrush;
    PMETARECORD    pmr;
#if DBG
    int    iSWO = 0;
    int    iSWE = 0;
#endif

// We will convert the enhanced metafile format only.
// Find the enhanced metafile data.

    for (i = 0; i < pemrcmf->nFormats; i++)
    {
	if (pemrcmf->aemrformat[i].dSignature == ENHMETA_SIGNATURE
	 && pemrcmf->aemrformat[i].nVersion   <= META_FORMAT_ENHANCED)
	    break;
    }

// If we cannot find a recognized format, return failure.

    if (i >= pemrcmf->nFormats)
    {
        PUTS("MF3216: DoGdiCommentMultiFormats - no recognized format found\n");
	goto dgcmf_exit;
    }

// Get the embedded enhanced metafile.

    hemf = SetEnhMetaFileBits((UINT) pemrcmf->aemrformat[i].cbData,
	    &((PBYTE) &pemrcmf->ident)[pemrcmf->aemrformat[i].offData]);
    if (!hemf)
	goto dgcmf_exit;

// Now the fun begins - we have to convert the enhanced metafile to
// Windows metafile.
// Since the multiformats record takes a logical rectangle, we have to
// set up a proper transform for the enhanced metafile.  We do it by
// creating a new enhanced metafile and playing the embedded metafile
// into the new metafile with the proper transform setup.
// In addition, the new metafile may have a different resolution than the
// metafile.  We need to take this into account when setting up
// the transform.

    // Get the world to device transform for the logical rectangle.

    if (!GetTransform(pLocalDC->hdcHelper, XFORM_WORLD_TO_DEVICE, &xformNew))
	goto dgcmf_exit;

    // Compute the device scales.

    szlDeviceNew.cx      = GetDeviceCaps(pLocalDC->hdcRef, HORZRES);
    szlDeviceNew.cy      = GetDeviceCaps(pLocalDC->hdcRef, VERTRES);
    szlMillimetersNew.cx = GetDeviceCaps(pLocalDC->hdcRef, HORZSIZE);
    szlMillimetersNew.cy = GetDeviceCaps(pLocalDC->hdcRef, VERTSIZE);
    pemfh = (PENHMETAHEADER) pLocalDC->pMf32Bits;

    xformScale.eM11 = ((FLOAT) szlDeviceNew.cx / (FLOAT) szlMillimetersNew.cx)
		    / ((FLOAT) pemfh->szlDevice.cx / (FLOAT) pemfh->szlMillimeters.cx);
    xformScale.eM12 = 0.0f;
    xformScale.eM21 = 0.0f;
    xformScale.eM22 = ((FLOAT) szlDeviceNew.cy / (FLOAT) szlMillimetersNew.cy)
		    / ((FLOAT) pemfh->szlDevice.cy / (FLOAT) pemfh->szlMillimeters.cy);
    xformScale.eDx  = 0.0f;
    xformScale.eDy  = 0.0f;

    // Compute the resulting transform to apply to the new metafile.

    if (!CombineTransform(&xformNew, &xformNew, &xformScale))
	goto dgcmf_exit;

// Create the new enhanced metafile.

    // Compute the new metafile frame.

    aptlFrame[0].x = pemrcmf->rclOutput.left;
    aptlFrame[0].y = pemrcmf->rclOutput.top;
    aptlFrame[1].x = pemrcmf->rclOutput.right;
    aptlFrame[1].y = pemrcmf->rclOutput.top;
    aptlFrame[2].x = pemrcmf->rclOutput.right;
    aptlFrame[2].y = pemrcmf->rclOutput.bottom;
    aptlFrame[3].x = pemrcmf->rclOutput.left;
    aptlFrame[3].y = pemrcmf->rclOutput.bottom;
    if (!bXformWorkhorse(aptlFrame, 4, &xformNew))
	goto dgcmf_exit;
    rclFrame.left   = MulDiv(100 * MIN4(aptlFrame[0].x, aptlFrame[1].x,
					aptlFrame[2].x, aptlFrame[3].x),
			     szlMillimetersNew.cx,
			     szlDeviceNew.cx);
    rclFrame.right  = MulDiv(100 * MAX4(aptlFrame[0].x, aptlFrame[1].x,
					aptlFrame[2].x, aptlFrame[3].x),
			     szlMillimetersNew.cx,
			     szlDeviceNew.cx);
    rclFrame.top    = MulDiv(100 * MIN4(aptlFrame[0].y, aptlFrame[1].y,
					aptlFrame[2].y, aptlFrame[3].y),
			     szlMillimetersNew.cy,
			     szlDeviceNew.cy);
    rclFrame.bottom = MulDiv(100 * MAX4(aptlFrame[0].y, aptlFrame[1].y,
					aptlFrame[2].y, aptlFrame[3].y),
			     szlMillimetersNew.cy,
			     szlDeviceNew.cy);

    hdcemfNew = CreateEnhMetaFile(pLocalDC->hdcRef, (LPCSTR) NULL,
		    (CONST RECT *) &rclFrame, (LPCSTR) NULL);
    if (!hdcemfNew)
	goto dgcmf_exit;

    if (!SetGraphicsMode(hdcemfNew, GM_ADVANCED))
	goto dgcmf_exit;

// Set up the transform in the new metafile.

    if (!SetWorldTransform(hdcemfNew, &xformNew))
	goto dgcmf_exit;

// Play the embedded metafile into the new metafile.
// This call ensures balanced level etc.

    (void) PlayEnhMetaFile(hdcemfNew, hemf, (LPRECT) &pemrcmf->rclOutput);

// Close the new metafile.

    hemfNew = CloseEnhMetaFile(hdcemfNew);
    hdcemfNew = (HDC) 0;		// used by clean up code below

// Convert the new enhanced metafile to windows metafile.

    if (!(cbwmfNew = GetWinMetaFileBits(hemfNew, 0, (LPBYTE) NULL,
			MM_ANISOTROPIC, pLocalDC->hdcRef)))
	goto dgcmf_exit;

    if (!(pbwmfNew = (PBYTE) LocalAlloc(LMEM_FIXED, cbwmfNew)))
	goto dgcmf_exit;

    if (cbwmfNew != GetWinMetaFileBits(hemfNew, cbwmfNew, pbwmfNew,
			MM_ANISOTROPIC, pLocalDC->hdcRef))
	goto dgcmf_exit;

// We now have the converted windows metafile.  We need to include it into
// our current data stream.  There are a few things to be aware of:
//
// 1. Expand the object handle slot table.  The converted metafile may
//    contain some undeleted objects.  These objects are likely
//    the "stock" objects in the converter.  As a result, we need to
//    expand the slot table by the number of object handles in the
//    converted metafile.
// 2. The object index must be changed to the current object index.
//    We are going to do this by the lazy method, i.e. we will elevate
//    the current object index base to one higher than the current max
//    object index in the current data stream.  This is because Windows uses
//    some an insane scheme for object index and this is the cheapest
//    method.  We elevate the object index base by filling up the empty
//    indexes with dummy objects that are freed when we are done.
// 3. Remove the now useless comments.
// 4. Skip header and eof.
// 5. Set up the transform to place the embedded metafile into the data
//    stream.  We know that the metafile bits returned by the converter
//    contains only a SetWindowOrg and a SetWindowExt record.
//    By implementation, we can simply remove both the SetWindowOrg and
//    SetWindowExt records from the data stream.  The window origin and
//    extents have been set up when we begin converting this enhanced
//    metafile.

    // Expand the object handle slot table.

    if (((PMETAHEADER) pbwmfNew)->mtNoObjects)
    {
        PW16OBJHNDLSLOTSTATUS pW16ObjHndlSlotStatusTmp;
	cSizeOld = (DWORD) pLocalDC->cW16ObjHndlSlotStatus;
        if (cSizeOld + ((PMETAHEADER)pbwmfNew)->mtNoObjects > (UINT) (WORD) MAXWORD)
	    goto dgcmf_exit;		// w16 handle index is only 16-bit

	pLocalDC->cW16ObjHndlSlotStatus += ((PMETAHEADER)pbwmfNew)->mtNoObjects;
	i = pLocalDC->cW16ObjHndlSlotStatus * sizeof(W16OBJHNDLSLOTSTATUS);
	pW16ObjHndlSlotStatusTmp = (PW16OBJHNDLSLOTSTATUS)
	    LocalReAlloc(pLocalDC->pW16ObjHndlSlotStatus, i, LMEM_MOVEABLE);
	if (pW16ObjHndlSlotStatusTmp == NULL)
        {
            pLocalDC->cW16ObjHndlSlotStatus -= ((PMETAHEADER)pbwmfNew)->mtNoObjects;
	    goto dgcmf_exit;
        }
        pLocalDC->pW16ObjHndlSlotStatus = pW16ObjHndlSlotStatusTmp;
        for (i = cSizeOld; i < pLocalDC->cW16ObjHndlSlotStatus; i++)
        {
            pLocalDC->pW16ObjHndlSlotStatus[i].use       = OPEN_AVAILABLE_SLOT;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;
        }
    }

    // Find the new base for the object index.

    for (iBase = pLocalDC->cW16ObjHndlSlotStatus - 1; iBase >= 0; iBase--)
    {
	if (pLocalDC->pW16ObjHndlSlotStatus[iBase].use != OPEN_AVAILABLE_SLOT)
	    break;
    }
    iBase++;

    // Fill up the object index table with dummy objects.

    Win16LogBrush.lbStyle = BS_SOLID;
    Win16LogBrush.lbColor = 0;
    Win16LogBrush.lbHatch = 0;

    for (i = 0; i < (DWORD) iBase; i++)
    {
	if (pLocalDC->pW16ObjHndlSlotStatus[i].use == OPEN_AVAILABLE_SLOT)
	{
	    if (!bEmitWin16CreateBrushIndirect(pLocalDC, &Win16LogBrush))
		goto dgcmf_exit;
	    pLocalDC->pW16ObjHndlSlotStatus[i].use = REALIZED_DUMMY;
	}
    }

    // Update the high water mark.

    if (iBase + ((PMETAHEADER) pbwmfNew)->mtNoObjects - 1 > pLocalDC->nObjectHighWaterMark)
	pLocalDC->nObjectHighWaterMark = iBase + ((PMETAHEADER) pbwmfNew)->mtNoObjects - 1;

    // Save DC states.

    if (!bEmitWin16SaveDC(pLocalDC))
	goto dgcmf_exit;

    // Enumerate the records and fix them up as necessary.

    for (pmr = (PMETARECORD) (pbwmfNew + sizeof(METAHEADER));
	 pmr->rdFunction != 0;
	 pmr = (PMETARECORD) ((PWORD) pmr + pmr->rdSize))
    {
	switch (pmr->rdFunction)
	{
	case META_SETWINDOWORG:
	    ASSERTGDI(++iSWO <= 1,
		"MF3216: DoGdiCommentMultiFormats - unexpected SWO record\n");
	    break;
	case META_SETWINDOWEXT:
	    ASSERTGDI(++iSWE <= 1,
		"MF3216: DoGdiCommentMultiFormats - unexpected SWE record\n");
	    break;

	case META_ESCAPE:
	    if (!IS_META_ESCAPE_ENHANCED_METAFILE((PMETA_ESCAPE_ENHANCED_METAFILE) pmr))
		goto default_alt;
	    break;

	case META_RESTOREDC:
	    ASSERTGDI((int)(SHORT)pmr->rdParm[0] < 0,
		"MF3216: DoGdiCommentMultiFormats - bogus RestoreDC record\n");
	    goto default_alt;

	case META_SELECTCLIPREGION:
	    if (pmr->rdParm[0] != 0)	// allow for default clipping!
	    {
		pmr->rdParm[0] += (WORD)iBase;
		pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = REALIZED_OBJECT;
	    }
	    goto default_alt;

	case META_FRAMEREGION:
	case META_FILLREGION:
	    pmr->rdParm[1] += (WORD)iBase;
	    pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[1]].use = REALIZED_OBJECT;
	    // fall through
	case META_PAINTREGION:
	case META_INVERTREGION:
	case META_DELETEOBJECT:
	case META_SELECTPALETTE:
	case META_SELECTOBJECT:
	    pmr->rdParm[0] += (WORD)iBase;
	    if (pmr->rdFunction != META_DELETEOBJECT)
		pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = REALIZED_OBJECT;
	    else
		pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = OPEN_AVAILABLE_SLOT;
	    // fall through
	default:
	default_alt:
            if (!bEmit(pLocalDC, (PVOID) pmr, pmr->rdSize * sizeof(WORD)))
		goto dgcmf_exit;
	    vUpdateMaxRecord(pLocalDC, pmr);
	    break;
	}
    }

    // Restore DC states.

    if (!bEmitWin16RestoreDC(pLocalDC, (WORD) -1))
	goto dgcmf_exit;

    // Remove the dummy objects from the handle table.

    for (i = 0; i < (DWORD) iBase; i++)
    {
	if (pLocalDC->pW16ObjHndlSlotStatus[i].use == REALIZED_DUMMY)
	{
	    if (!bEmitWin16DeleteObject(pLocalDC, (WORD) i))
		goto dgcmf_exit;
	    pLocalDC->pW16ObjHndlSlotStatus[i].use = OPEN_AVAILABLE_SLOT;
	}
    }

    // Shrink the object handle slot table.

    if (((PMETAHEADER) pbwmfNew)->mtNoObjects)
    {
	DWORD cUndel = 0;		// number of objects not deleted
	DWORD iUndelMax = iBase - 1;	// the max undeleted object index

        for (i = iBase; i < pLocalDC->cW16ObjHndlSlotStatus; i++)
        {
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use != OPEN_AVAILABLE_SLOT)
	    {
		cUndel++;
		iUndelMax = i;
	    }
        }

	pLocalDC->cW16ObjHndlSlotStatus = max(cSizeOld + cUndel, iUndelMax + 1);
    }

// Everything is golden.

    bRet = TRUE;

dgcmf_exit:

    if (pbwmfNew)
	if (LocalFree(pbwmfNew))
	    ASSERTGDI(FALSE, "MF3216: DoGdiCommentMultiFormats - LocalFree failed\n");

    if (hemf)
	DeleteEnhMetaFile(hemf);

    if (hdcemfNew)
	hemfNew = CloseEnhMetaFile(hdcemfNew);	// hemfNew will be deleted next

    if (hemfNew)
	DeleteEnhMetaFile(hemfNew);

    return(bRet);
}

/***************************************************************************
 *  EOF  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoEOF
(
PLOCALDC  pLocalDC
)
{
BOOL    b ;

        b = bEmitWin16EOF(pLocalDC) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\handlers.h ===
/****************************************************************************
 *  Handlers.h - Definitions for handlers.
 *
 *  DATE:   11-Dec-1991
 *  Author: Jeffrey Newman (c-jeffn)
 *
 *  Copyright (c) Microsoft Inc. 1991
 ****************************************************************************/

//  Following is a typedef for the Drawing Order Handler

typedef BOOL DOFN (PVOID, PLOCALDC) ;
typedef DOFN *PDOFN ;

DOFN bHandleHeader;
DOFN bHandleSetArcDirection;
DOFN bHandleArc;
DOFN bHandleArcTo;
DOFN bHandleAngleArc;
DOFN bHandleEllipse;
DOFN bHandleSelectObject;
DOFN bHandleDeleteObject;
DOFN bHandleCreateBrushIndirect;
DOFN bHandleCreateDIBPatternBrush;
DOFN bHandleCreateMonoBrush;
DOFN bHandleCreatePen;
DOFN bHandleExtCreatePen;
DOFN bHandleMoveTo;
DOFN bHandleLineTo;
DOFN bHandleChord;
DOFN bHandlePie;
DOFN bHandlePolyline;
DOFN bHandlePolylineTo ;
DOFN bHandlePolyPolyline;
DOFN bHandlePolygon ;
DOFN bHandlePolyPolygon;
DOFN bHandleRectangle;
DOFN bHandleRoundRect ;
DOFN bHandlePoly16 ;
DOFN bHandlePolyPoly16 ;

DOFN bHandleExtTextOut;
DOFN bHandlePolyTextOut;
DOFN bHandleExtCreateFont;
DOFN bHandleSetBkColor;
DOFN bHandleSetBkMode;
DOFN bHandleSetMapperFlags;
DOFN bHandleSetPolyFillMode;
DOFN bHandleSetRop2;
DOFN bHandleSetStretchBltMode;
DOFN bHandleSetTextAlign;
DOFN bHandleSetTextColor;

DOFN bHandleSelectPalette;
DOFN bHandleCreatePalette;
DOFN bHandleSetPaletteEntries;
DOFN bHandleResizePalette;
DOFN bHandleRealizePalette;

DOFN bHandleSetMapMode;

DOFN bHandleSetWindowOrg;
DOFN bHandleSetWindowExt;

DOFN bHandleSetViewportOrg;
DOFN bHandleSetViewportExt;

DOFN bHandleScaleViewportExt;
DOFN bHandleScaleWindowExt;

DOFN bHandleEOF;

DOFN bHandleSaveDC;
DOFN bHandleRestoreDC;

DOFN bHandleBitBlt;
DOFN bHandleStretchBlt;
DOFN bHandleMaskBlt;
DOFN bHandlePlgBlt;
DOFN bHandleSetDIBitsToDevice;
DOFN bHandleStretchDIBits;


DOFN bHandleBeginPath;
DOFN bHandleEndPath;
DOFN bHandleFlattenPath;
DOFN bHandleStrokePath;
DOFN bHandleFillPath;
DOFN bHandleStrokeAndFillPath;
DOFN bHandleWidenPath;
DOFN bHandleSelectClipPath;
DOFN bHandleCloseFigure;
DOFN bHandleAbortPath;

DOFN bHandlePolyBezier;
DOFN bHandlePolyBezierTo;
DOFN bHandlePolyDraw;

DOFN bHandleSetWorldTransform;
DOFN bHandleModifyWorldTransform;

DOFN bHandleSetPixel;

DOFN bHandleFillRgn;
DOFN bHandleFrameRgn;
DOFN bHandleInvertRgn;
DOFN bHandlePaintRgn;
DOFN bHandleExtSelectClipRgn;
DOFN bHandleOffsetClipRgn;

DOFN bHandleExcludeClipRect;
DOFN bHandleIntersectClipRect;
DOFN bHandleSetMetaRgn;

DOFN bHandleGdiComment;

DOFN bHandleExtFloodFill;
DOFN bHandleNotImplemented;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\parser.c ===
/*****************************************************************************
 *
 * parser.cxx - Parser for the Win32 to Win16 metafile converter.
 *
 * Date: 8/13/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/


#include "precomp.h"
#pragma hdrstop

#define EMR_LAST_MF3216_SUPPORTED 97

BOOL bGetNextRecord(PLOCALDC pLocalDC, PENHMETARECORD *pemr) ;

// Call table for the translation entry points.

PDOFN pdofnDrawingOrders[] = {
        (PDOFN) NULL,
        bHandleHeader,                  // EMR_HEADER                       1
        bHandlePolyBezier,              // EMR_POLYBEZIER                   2
        bHandlePolygon,                 // EMR_POLYGON                      3
        bHandlePolyline,                // EMR_POLYLINE                     4
        bHandlePolyBezierTo,            // EMR_POLYBEZIERTO                 5
        bHandlePolylineTo,              // EMR_POLYLINETO                   6
        bHandlePolyPolyline,            // EMR_POLYPOLYLINE                 7
        bHandlePolyPolygon,             // EMR_POLYPOLYGON                  8
        bHandleSetWindowExt,            // EMR_SETWINDOWEXTEX               9
        bHandleSetWindowOrg,            // EMR_SETWINDOWORGEX               10
        bHandleSetViewportExt,          // EMR_SETVIEWPORTEXTEX             11
        bHandleSetViewportOrg,          // EMR_SETVIEWPORTORGEX             12
        bHandleNotImplemented,          // EMR_SETBRUSHORGEX                13
        bHandleEOF,                     // EMR_EOF                          14
        bHandleSetPixel,                // EMR_SETPIXELV                    15
        bHandleSetMapperFlags,          // EMR_SETMAPPERFLAGS               16
        bHandleSetMapMode,              // EMR_SETMAPMODE                   17
        bHandleSetBkMode,               // EMR_SETBKMODE                    18
        bHandleSetPolyFillMode,         // EMR_SETPOLYFILLMODE              19
        bHandleSetRop2,                 // EMR_SETROP2                      20
        bHandleSetStretchBltMode,       // EMR_SETSTRETCHBLTMODE            21
        bHandleSetTextAlign,            // EMR_SETTEXTALIGN                 22
        bHandleNotImplemented,          // EMR_SETCOLORADJUSTMENT           23
        bHandleSetTextColor,            // EMR_SETTEXTCOLOR                 24
        bHandleSetBkColor,              // EMR_SETBKCOLOR                   25
        bHandleOffsetClipRgn,           // EMR_OFFSETCLIPRGN                26
        bHandleMoveTo,                  // EMR_MOVETOEX                     27
        bHandleSetMetaRgn,              // EMR_SETMETARGN                   28
        bHandleExcludeClipRect,         // EMR_EXCLUDECLIPRECT              29
        bHandleIntersectClipRect,       // EMR_INTERSECTCLIPRECT            30
        bHandleScaleViewportExt,        // EMR_SCALEVIEWPORTEXTEX           31
        bHandleScaleWindowExt,          // EMR_SCALEWINDOWEXTEX             32
        bHandleSaveDC,                  // EMR_SAVEDC                       33
        bHandleRestoreDC,               // EMR_RESTOREDC                    34
        bHandleSetWorldTransform,       // EMR_SETWORLDTRANSFORM            35
        bHandleModifyWorldTransform,    // EMR_MODIFYWORLDTRANSFORM         36
        bHandleSelectObject,            // EMR_SELECTOBJECT                 37
        bHandleCreatePen,               // EMR_CREATEPEN                    38
        bHandleCreateBrushIndirect,     // EMR_CREATEBRUSHINDIRECT          39
        bHandleDeleteObject,            // EMR_DELETEOBJECT                 40
        bHandleAngleArc,                // EMR_ANGLEARC                     41
        bHandleEllipse,                 // EMR_ELLIPSE                      42
        bHandleRectangle,               // EMR_RECTANGLE                    43
        bHandleRoundRect,               // EMR_ROUNDRECT                    44
        bHandleArc,                     // EMR_ARC                          45
        bHandleChord,                   // EMR_CHORD                        46
        bHandlePie,                     // EMR_PIE                          47
        bHandleSelectPalette,           // EMR_SELECTPALETTE                48
        bHandleCreatePalette,           // EMR_CREATEPALETTE                49
        bHandleSetPaletteEntries,       // EMR_SETPALETTEENTRIES            50
        bHandleResizePalette,           // EMR_RESIZEPALETTE                51
        bHandleRealizePalette,          // EMR_REALIZEPALETTE               52
        bHandleExtFloodFill,            // EMR_EXTFLOODFILL                 53
        bHandleLineTo,                  // EMR_LINETO                       54
        bHandleArcTo,                   // EMR_ARCTO                        55
        bHandlePolyDraw,                // EMR_POLYDRAW                     56
        bHandleSetArcDirection,         // EMR_SETARCDIRECTION              57
        bHandleNotImplemented,          // EMR_SETMITERLIMIT                58
        bHandleBeginPath,               // EMR_BEGINPATH                    59
        bHandleEndPath,                 // EMR_ENDPATH                      60
        bHandleCloseFigure,             // EMR_CLOSEFIGURE                  61
        bHandleFillPath,                // EMR_FILLPATH                     62
        bHandleStrokeAndFillPath,       // EMR_STROKEANDFILLPATH            63
        bHandleStrokePath,              // EMR_STROKEPATH                   64
        bHandleFlattenPath,             // EMR_FLATTENPATH                  65
        bHandleWidenPath,               // EMR_WIDENPATH                    66
        bHandleSelectClipPath,          // EMR_SELECTCLIPPATH               67
        bHandleAbortPath,               // EMR_ABORTPATH                    68
        bHandleNotImplemented,          //                                  69
        bHandleGdiComment,              // EMR_GDICOMMENT                   70
        bHandleFillRgn,                 // EMR_FILLRGN                      71
        bHandleFrameRgn,                // EMR_FRAMERGN                     72
        bHandleInvertRgn,               // EMR_INVERTRGN                    73
        bHandlePaintRgn,                // EMR_PAINTRGN                     74
        bHandleExtSelectClipRgn,        // EMR_EXTSELECTCLIPRGN             75
        bHandleBitBlt,                  // EMR_BITBLT                       76
        bHandleStretchBlt,              // EMR_STRETCHBLT                   77
        bHandleMaskBlt,                 // EMR_MASKBLT                      78
        bHandlePlgBlt,                  // EMR_PLGBLT                       79
        bHandleSetDIBitsToDevice,       // EMR_SETDIBITSTODEVICE            80
        bHandleStretchDIBits,           // EMR_STRETCHDIBITS                81
        bHandleExtCreateFont,           // EMR_EXTCREATEFONTINDIRECTW       82
        bHandleExtTextOut,              // EMR_EXTTEXTOUTA                  83
        bHandleExtTextOut,              // EMR_EXTTEXTOUTW                  84
        bHandlePoly16,                  // EMR_POLYBEZIER16                 85
        bHandlePoly16,                  // EMR_POLYGON16                    86
        bHandlePoly16,                  // EMR_POLYLINE16                   87
        bHandlePoly16,                  // EMR_POLYBEZIERTO16               88
        bHandlePoly16,                  // EMR_POLYLINETO16                 89
        bHandlePolyPoly16,              // EMR_POLYPOLYLINE16               90
        bHandlePolyPoly16,              // EMR_POLYPOLYGON16                91
        bHandlePoly16,                  // EMR_POLYDRAW16                   92
        bHandleCreateMonoBrush,         // EMR_CREATEMONOBRUSH              93
        bHandleCreateDIBPatternBrush,   // EMR_CREATEDIBPATTERNBRUSHPT      94
        bHandleExtCreatePen,            // EMR_EXTCREATEPEN                 95
        bHandlePolyTextOut,             // EMR_POLYTEXTOUTA                 96
        bHandlePolyTextOut,             // EMR_POLYTEXTOUTW                 97
        bHandleNotImplemented,          // EMR_SETICMMODE                   98
        bHandleNotImplemented,          // EMR_CREATECOLORSPACE             99
        bHandleNotImplemented,          // EMR_SETCOLORSPACE               100
        bHandleNotImplemented,          // EMR_DELETECOLORSPACE            101
        bHandleNotImplemented,          // EMR_GLSRECORD                   102
        bHandleNotImplemented,          // EMR_GLSBOUNDEDRECORD            103
        bHandleNotImplemented,          // EMR_PIXELFORMAT                 104
        bHandleNotImplemented,          //                                 105
        bHandleNotImplemented,          //                                 106
        bHandleNotImplemented,          //                                 107
        bHandleNotImplemented,          //                                 108
        bHandleNotImplemented,          //                                 109
        bHandleNotImplemented,          //                                 110
        bHandleNotImplemented,          // EMR_COLORCORRECTPALETTE         111
        bHandleNotImplemented,          // EMR_ALPHABLEND                  112
        bHandleNotImplemented,          // EMR_ALPHADIBBLEND               113
        bHandleNotImplemented,          // EMR_TRANSPARENTIMAGE            114
        bHandleNotImplemented,          // EMR_TRANSPARENTDIBIMAGE         115
        bHandleNotImplemented           // EMR_GRADIENTFILL                116

} ;

#if DBG

PSZ         pszMfRecords[] = {
                        "NULL RECORD               ",
                        "EMR_HEADER                ",
                        "EMR_POLYBEZIER            ",
                        "EMR_POLYGON               ",
                        "EMR_POLYLINE              ",
                        "EMR_POLYBEZIERTO          ",
                        "EMR_POLYLINETO            ",
                        "EMR_POLYPOLYLINE          ",
                        "EMR_POLYPOLYGON           ",
                        "EMR_SETWINDOWEXTEX        ",
                        "EMR_SETWINDOWORGEX        ",
                        "EMR_SETVIEWPORTEXTEX      ",
                        "EMR_SETVIEWPORTORGEX      ",
                        "EMR_SETBRUSHORGEX         ",
                        "EMR_EOF                   ",
                        "EMR_SETPIXELV             ",
                        "EMR_SETMAPPERFLAGS        ",
                        "EMR_SETMAPMODE            ",
                        "EMR_SETBKMODE             ",
                        "EMR_SETPOLYFILLMODE       ",
                        "EMR_SETROP2               ",
                        "EMR_SETSTRETCHBLTMODE     ",
                        "EMR_SETTEXTALIGN          ",
                        "EMR_SETCOLORADJUSTMENT    ",
                        "EMR_SETTEXTCOLOR          ",
                        "EMR_SETBKCOLOR            ",
                        "EMR_OFFSETCLIPRGN         ",
                        "EMR_MOVETOEX              ",
                        "EMR_SETMETARGN            ",
                        "EMR_EXCLUDECLIPRECT       ",
                        "EMR_INTERSECTCLIPRECT     ",
                        "EMR_SCALEVIEWPORTEXTEX    ",
                        "EMR_SCALEWINDOWEXTEX      ",
                        "EMR_SAVEDC                ",
                        "EMR_RESTOREDC             ",
                        "EMR_SETWORLDTRANSFORM     ",
                        "EMR_MODIFYWORLDTRANSFORM  ",
                        "EMR_SELECTOBJECT          ",
                        "EMR_CREATEPEN             ",
                        "EMR_CREATEBRUSHINDIRECT   ",
                        "EMR_DELETEOBJECT          ",
                        "EMR_ANGLEARC              ",
                        "EMR_ELLIPSE               ",
                        "EMR_RECTANGLE             ",
                        "EMR_ROUNDRECT             ",
                        "EMR_ARC                   ",
                        "EMR_CHORD                 ",
                        "EMR_PIE                   ",
                        "EMR_SELECTPALETTE         ",
                        "EMR_CREATEPALETTE         ",
                        "EMR_SETPALETTEENTRIES     ",
                        "EMR_RESIZEPALETTE         ",
                        "EMR_REALIZEPALETTE        ",
                        "EMR_EXTFLOODFILL          ",
                        "EMR_LINETO                ",
                        "EMR_ARCTO                 ",
                        "EMR_POLYDRAW              ",
                        "EMR_SETARCDIRECTION       ",
                        "EMR_SETMITERLIMIT         ",
                        "EMR_BEGINPATH             ",
                        "EMR_ENDPATH               ",
                        "EMR_CLOSEFIGURE           ",
                        "EMR_FILLPATH              ",
                        "EMR_STROKEANDFILLPATH     ",
                        "EMR_STROKEPATH            ",
                        "EMR_FLATTENPATH           ",
                        "EMR_WIDENPATH             ",
                        "EMR_SELECTCLIPPATH        ",
                        "EMR_ABORTPATH             ",
                        "unknown record            ",
                        "EMR_GDICOMMENT            ",
                        "EMR_FILLRGN               ",
                        "EMR_FRAMERGN              ",
                        "EMR_INVERTRGN             ",
                        "EMR_PAINTRGN              ",
                        "EMR_EXTSELECTCLIPRGN      ",
                        "EMR_BITBLT                ",
                        "EMR_STRETCHBLT            ",
                        "EMR_MASKBLT               ",
                        "EMR_PLGBLT                ",
                        "EMR_SETDIBITSTODEVICE     ",
                        "EMR_STRETCHDIBITS         ",
                        "EMR_EXTCREATEFONTINDIRECTW",
                        "EMR_EXTTEXTOUTA           ",
                        "EMR_EXTTEXTOUTW           ",
                        "EMR_POLYBEZIER16          ",
                        "EMR_POLYGON16             ",
                        "EMR_POLYLINE16            ",
                        "EMR_POLYBEZIERTO16        ",
                        "EMR_POLYLINETO16          ",
                        "EMR_POLYPOLYLINE16        ",
                        "EMR_POLYPOLYGON16         ",
                        "EMR_POLYDRAW16            ",
                        "EMR_CREATEMONOBRUSH       ",
                        "EMR_CREATEDIBPATTERNBRUSHP",
                        "EMR_EXTCREATEPEN          ",
                        "EMR_POLYTEXTOUTA          ",
                        "EMR_POLYTEXTOUTW          ",
                        "EMR_SETICMMODE            ",
                        "EMR_CREATECOLORSPACE      ",
                        "EMR_SETCOLORSPACE         ",
                        "EMR_DELETECOLORSPACE      ",
                        "EMR_GLSRECORD             ",
                        "EMR_GLSBOUNDEDRECORD      ",
                        "EMR_PIXELFORMAT           ",
                        "105                       ",
                        "106                       ",
                        "107                       ",
                        "108                       ",
                        "109                       ",
                        "110                       ",
                        "EMR_COLORCORRECTPALETTE   ",
                        "EMR_ALPHABLEND            ",
                        "EMR_ALPHADIBBLEND         ",
                        "EMR_TRANSPARENTIMAGE      ",
                        "EMR_TRANSPARENTDIBIMAGE   ",
                        "EMR_GRADIENTFILL          "
};

#endif

/*****************************************************************************
 *  Parse the Win32 metafile.
 *
 *  The Win32 metafile is represented by the metafile bits pointed to
 *  by pMetafileBits.  The metafile bits may be obtained from a memory mapped
 *  file, or from some shared memory (from the clipboard).
 *****************************************************************************/
BOOL bParseWin32Metafile(PBYTE pMetafileBits, PLOCALDC pLocalDC)
{
INT         iType ;
PVOID       pVoid ;
PENHMETARECORD pemr ;
PENHMETAHEADER pMf32Header ;
DWORD       nFileSize ;
BOOL        bRet ;
INT         iRecordCount,
            iLastError ;

        bRet = TRUE ;

        // Get the file length from the header.
        // Test to make sure the first record is a Win32 Metafile header.

        pMf32Header = (PENHMETAHEADER) pMetafileBits ;
        if (   (pMf32Header->iType      != EMR_HEADER)
            || (pMf32Header->dSignature != ENHMETA_SIGNATURE)
           )
        {
            RIP("MF3216: bParseWin32Metafile, First Record not a Win32 Metafile Header\n") ;
            return(FALSE) ;
        }

        if (!IsValidEnhMetaRecord(pLocalDC->pht, pMf32Header))
        {
            EMFVALFAIL(("MF3216: bParseWin32Metafile, IsValidEnhMetaRecord failed\n"));
            return(FALSE);
        }


        // Record a pointer to the beginning of the Win32 metafile and
        // it's length incase we need to emit the Win32 metafile  as  a comment
        // record(s).

        pLocalDC->pMf32Bits = (PBYTE) pMf32Header ;
        pLocalDC->cMf32Bits = pMf32Header->nBytes ;

        // Get the file size for the parser.

        nFileSize = pMf32Header->nBytes ;


        // Initialize pbCurrent, & pbEnd pointers into the
        // metafile bits.

        pLocalDC->pbCurrent = pMetafileBits ;
        pLocalDC->pbEnd   = pLocalDC->pbCurrent + nFileSize ;

        if (pLocalDC->pbEnd < pLocalDC->pbCurrent)
        {
            RIP("MF3216: bParseWin32Metafile, pointer arithmetic overflow\n");
            return(FALSE);
        }

        // Init the record count.

        iRecordCount = 0 ;

        // Go through the metafile bits.  Handle each record based on
        // it's type.  bGetNextRecord returns TRUE if pemr contains
        // a pointer to a record.

        while (bGetNextRecord(pLocalDC, &pemr))
        {
            if (!IsValidEnhMetaRecord(pLocalDC->pht, pemr))
            {
                EMFVALFAIL(("MF3216: bParseWin32Metafile, IsValidEnhMetaRecord failed\n"));
                bRet = FALSE;
                break;
            }

            iRecordCount++ ;

            // Set up a convienent point to the record.

            pVoid = (PVOID) pemr ;

            // Handle the record based on it's type.

            iType = (INT) pemr->iType ;

            // Check if the record type falls within the range of the
            // call table.  Eventually, all the record handlers  should
            // be in the call table.

            if (iType <= EMR_LAST_MF3216_SUPPORTED)
            {
                bRet = pdofnDrawingOrders[iType](pVoid, pLocalDC) ;
#if DBG
                if (bRet == FALSE)
                {
                    iLastError = GetLastError() ;
                    PUTS1("MF3216: Error on Win32 Metafile record #: %d\n", iRecordCount) ;
                    PUTS1("\tRecord type: %s\n", pszMfRecords[iType]) ;
                    PUTS1("\tLast Error Code: %08.8X\n", iLastError) ;
                }
#endif
#if 0
                if (bRet == FALSE)
                    break ;
#else
                // In ancient times (i.e., before NT4.0), someone explicitly
                // removed the code above which exits the loop if the handler
                // fails.  Possibly this was a compatibility fix in which
                // the app depended on the metafile conversion to continue
                // even in the event of a failure.
                //
                // Unfortunately, this fix also allows the parser to continue
                // even if the output buffer has run out of space.  To
                // minimize the change, we will explicitly look for this case
                // and break out of the loop if it happens.  (Refer to bEmit()
                // in emit.c to see where ERROR_BUFFER_OVERFLOW is set).

                if (pLocalDC->flags & ERR_BUFFER_OVERFLOW)
                    break ;
#endif
            }
            else
            {
                PUTS1("MF3216: bParseWin32Metafile - record not supported: %d\n", iType) ;
            }
        }
#if 0
        // Display some statictics

        if (bRet == TRUE)
        {
            PUTS1("MF3216: %d Win32 Metafile records processed\n",
                   iRecordCount) ;
        }
#endif
        return(bRet) ;
}

/*****************************************************************************
 * Get next record
 *
 *  This is a support routine for bParseWin32Metafile.
 *  It is assumed that pbCurrent, & pbEnd are initialized
 *  the first time this routine is called.
 *
 *  It returns TRUE if a valid pointer to record is returned in
 *  pemr.  If there are not more records FALSE is returned.
 *****************************************************************************/
BOOL bGetNextRecord(PLOCALDC pLocalDC, PENHMETARECORD *ppemr)
{
DWORD   nSize ;

        // Check for the end of buffer.
        // If this is the end return FALSE and set *ppemr to 0.

        if (pLocalDC->pbCurrent == pLocalDC->pbEnd)
        {
            *ppemr = (PENHMETARECORD) NULL ;
            return (FALSE) ;
        }

        // Well it's not the end of the buffer.
        // So, return a pointer to this record, update pbCurrent, and
        // return TRUE ;

        *ppemr = (PENHMETARECORD) pLocalDC->pbCurrent ;

        nSize = ((PENHMETARECORD) pLocalDC->pbCurrent)->nSize ;
        pLocalDC->pbCurrent += nSize ;

        return(TRUE) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\objects.c ===
/*****************************************************************************
 *
 * objects - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *
 *
 *  14-Jan-1992
 *  Jeffrey Newman
 *
 *  CR1:    14-Jan-1992 -   this entire comment and the design that it
 *                          specifies.
 *
 *  The Object system in mf3216.
 *
 *  Overview
 *
 *      The Win32 objects (represented by object handle indicies) must be
 *      mapped to Win16 objects (also represented by object handle indices).
 *      Win32 uses stock objects, Win16 does not.  MF3216 uses a scheme
 *      for lazy stock object creation.  Through lazy stock object creation
 *      no unused objects will be emitted into the Win16 metafile.
 *
 *      Objects in a Win16 metafile are maintained in an Object Table. The
 *      object table is not recorded in the Win16 metafile.  It is created at
 *      play-time. Each entry in the Win16-Object-Table is called a slot.
 *      Slots are allocated one per object.  If an object is deleted then the
 *      slot becomes available for the next object created.  The first object-
 *      slot, starting from 0, in a linear search, that is available will be
 *      used to hold the next create object request.
 *
 *      Objects in either a Win32 or a Win16 metafile are represented as an
 *      index into the Object Table.  Every object created must occupy
 *      the same slot at play-time that it would have occupied at record-time.
 *
 *      Win32 objects have an object ID (index in the handle table) recorded
 *      with them.  Win16 objects do not.
 *
 *  Data Structures
 *
 *      There are two primary data structures used in the translation of
 *      Win32 objects to Win16 objects.  Both of them are dynamically
 *      allocated arrays.  The size of these arrays are determined by
 *      estimating the number of objects required in the Win16 metafile from
 *      the size of the handle table used in the Win32 metafile.  The size of
 *      the handle table is recorded in the Win32 metafile header.
 *
 *      The data structure piW16ObjectHandleSlotStatus is used to represent
 *      the status of the Win16 handle table as it would appear at any point
 *      during the Win16 metafile playback process.  A slot is either in
 *      use or free.
 *
 *      The data structure piW32ToW16ObjectMap is a translation table
 *      from the Win32 object indicies to the Win16 object indicies.
 *      The position in the array (aka the index into the array) is the
 *      Win32 handle.  The value in this entry is the Win16 slot number
 *      for the handle.
 *
 *      The first 16 entries in piW32ToW16ObjectMap array are used for the
 *      stock objects.
 *
 *  Support Routines
 *
 *          bInitHandleTableManager
 *
 *              1]  Allocate memory for pW16ObjHndlSlotStatus and
 *                  piW32ToW16ObjectMap arrays.
 *
 *              2]  Initialize pW16ObjHndlSlotStatus and
 *                  piW32ToW16ObjectMap to empty and UNMAPPED respectively.
 *
 *              3]  Returns a TRUE if there were no problems with the
 *                  initialization, FALSE if anything went wrong.
 *
 *              4]  It is expected that this routie will be called once from
 *                  the entry level routine when translation is first started.
 *
 *          iNormalizeHandle
 *
 *              1]  The idea behind this routine is to isolate the handling
 *                  of stock object handles to one place.
 *
 *              2]  Input will be a Win32 handle index, either stock or a
 *                  standard object.
 *
 *              3]  Output will be the index of the entry in the
 *                  piW32ToW16ObjectMap table that corresponds to the W32
 *                  handle.  If an error is detected -1 is returned.
 *
 *              4]  All the stock objects will be between the range of 0
 *                  and LAST_STOCK, and all the non-stock objects will be
 *                  greater than LAST_STOCK.
 *
 *          iGetW16ObjectHandleSlot
 *
 *              1]  This routine searches the pW16ObjHndlSlotStatus array
 *                  looking for the first available open slot.
 *
 *              2]  Mark the slot found as to its intended use.
 *
 *              3]  Returns the first open slot if found, else return -1.
 *
 *              4]  In essence this routine mimics the actions of the
 *                  Win16 play-time handle allocation system, in either
 *                  Win3.0 or Win3.1
 *
 *              5]  We also keep track of the max object count here.
 *
 *          iAllocateW16Handle
 *
 *              1]  This routine actually does the handle allocation.
 *
 *              2]  It sets the entry in pW16ObjHndlSlotStatus array
 *                  for the slot allocated by iGetW16ObjectHandleSlot to
 *                  an "in-use" status (for the intended use).
 *
 *              3]  It returns a ihW16 (an index handle to the Win16 handle
 *                  table, aka the Win16 handle slot number).
 *
 *          iValidateHandle
 *
 *              1]  This routine does a lot more than validate a Win32 handle.
 *                  It does some limited error checking on the Win32 handle,
 *                  to make sure its within a reasonable range.  Then if a
 *                  Win16 handle table slot has already been allocated for
 *                  this Win32 handle it will return the Win16 handle that
 *                  was previously allocated.  Alternatively, if a Win16
 *                  handle has not been previously allocated for a Win32
 *                  STOCK handle it will allocate a W16 handle and return the
 *                  Win16 handle.  This function is called by FillRgn, FrameRgn
 *                  and SelectObject to allow lazy allocation of stock objects.
 *
 *              2]  Input is a Win32 handle, either a stock or a non-stock
 *                  handle.
 *
 *              3]  Output is a Win16 handle, this is the value in the
 *                  Win32-index of the piW32ToW16ObjectMap.  If a stock object
 *                  does not exist, it will create one.
 *
 *              4]  If there is an error a -1 is returned.
 *
 *      Doer Routines
 *
 *              All the Doers return a bool.  TRUE if everything went OK.
 *              FALSE if there were any problems.
 *
 *              NOTE: The Doers that create an object actually must do
 *              quite a bit of work to translate the object's prameters.
 *              This is in addition to managing the handle table.  The
 *              work outlined below just deals with the management of the
 *              handle table.
 *
 *          DoSelectObject
 *
 *              1]  For stock objects this is the workhorse routine.
 *
 *              2]  For normal, non-stock, objects this routine will verify
 *                  that an object has been created for this Win32 object-index.
 *                  Then it will emit a Win16SelectObject metafile record.
 *
 *              3]  For stock objects things get a little more complicated.
 *                  First this routine must make sure a Win16 object has been
 *                  created for this stock object.  If a Win16 object has not
 *                  been created yet, then it will be. After a Win16 object
 *                  is created a Win16SelectObject record will be emitted for
 *                  the object.
 *
 *          DoDeleteObject
 *
 *              1]  The object handle is checked for reasonable limits.
 *                  We will also make sure that the Win16 slot has a handle
 *                  allocated to it.  If it does not then we will return an
 *                  error.
 *
 *              2]  If this is a stock object we fail and return an error.
 *
 *              3]  If this is a non-stock object we emit a Win16DeleteObject
 *                  record.  Then we set pW16ObjHndlSlotStatus to
 *                  indicate that this slot is available.  We also set
 *                  piW32ToW16ObjectMap to -1 (UNMAPPED).
 *
 *          DoCreatePen
 *          DoExtCreatePen
 *          DoCreateBrushIndirect
 *          DoCreateMonoBrush
 *          DoCreateDIBPatternBrush
 *          DoExtCreateFont
 *
 *              1]  Make sure the Win32 handle is not already being used
 *                  for something else.  If it is return an error.
 *
 *              2]  Validate the handle for this Object.  This will return
 *                  a Win16 object table index (actually a slot number).
 *                  We really don't care what the slot number is as long
 *                  as we got one.  DoDeleteObject and DoSelectObject always
 *                  refer to handles by their Win32 object indicies, and there
 *                  is no place else where used.
 *
 *              3]  Emit a Win16CreateObject metafile record.
 *
 *
 *      Special Routines
 *
 *          bCommonRegionCode
 *          Need to list the bitblt routines that use handles also
 *
 *              1]  These routines just need to create objects in the Win16
 *                  metafile.  There are no corresponding objects in the Win32
 *                  metafile.
 *
 *              2]  Allocate a Win16 handle.
 *
 *              3]  Use the object as needed.  This includes emitting a
 *                  region or bitmap object into the Win16 metafile.
 *
 *              4]  De-allocate the object.  This include emitting a
 *                  DeleteObject record.
 *
 * CR1
 * Paths require the current pen to selected into the helperDC.
 * In order to keep track of create, select, & delete of the pen
 * object we will add an extra field to the W16ObjectHandleSlotStatus
 * array entries.  This new field will contain either a NULL handle
 * or a valid Win32 handle.  Currently only pens need to be selected
 * into the helper DC for paths, so they are the only objects whose
 * W32 handle field is not NULL.
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define ABS(A)      ((A) < 0 ? (-(A)) : (A))

//  Stock objects                          Name              Stock
//                                                           Object
//                                                             ID

LOGBRUSH    albStock[] = {
    {BS_SOLID, 0x0FFFFFF, 0},           // White Brush          0
    {BS_SOLID, 0x0C0C0C0, 0},           // Ligh Grey Brush      1
    {BS_SOLID, 0x0808080, 0},           // Grey Brush           2
    {BS_SOLID, 0x0404040, 0},           // Dark Grey Brush      3
    {BS_SOLID, 0x0000000, 0},           // Black Brush          4
    {BS_HOLLOW, 0x0000000, 0}           // Hollow Brush         5
} ;

LOGPEN      alpnStock[] = {
    {PS_SOLID,  0, 0, 0x0FFFFFF},       // White Pen            6
    {PS_SOLID,  0, 0, 0x0000000},       // Black Pen            7
    {PS_NULL,   0, 0, 0x0FFFFFF}        // Null Pen             8
} ;

// Internal function prototypes.

BOOL bCreateStockObject(PLOCALDC pLocalDC, INT ihw32Norm) ;
BOOL bCreateStockFont(PLOCALDC pLocalDC, INT ihW32) ;

/***************************************************************************
 * bInitHandleTableManager - Init the Handle Table Manager.
 *
 *      1]  Allocate memory for pW16ObjHndlSlotStatus and
 *          piW32ToW16ObjectMap arrays.
 *
 *      2]  Initialize pW16ObjHndlSlotStatus and
 *          piW32ToW16ObjectMap to empty and UNMAPPED respectively.
 *
 *      3]  Returns a TRUE if there were no problems with the
 *          initialization, FALSE if anything went wrong.
 *
 *      4]  It is expected that this routie will be called once from
 *          the entry level routine when translation is first started.
 *
 **************************************************************************/
BOOL bInitHandleTableManager(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
BOOL    b ;
UINT    i ;

        b = FALSE ;

        // The total number of handles required will be the stock handles
        // plus the handles used by the Win32 metafile plus one extra
        // for temporary brush used in opaque rectangle in textout.

        pLocalDC->cW32ToW16ObjectMap = pmf32header->nHandles + (STOCK_LAST + 1) + 1;

        // Allocate storage for the translation map.

        i = pLocalDC->cW32ToW16ObjectMap * sizeof(INT) ;
        pLocalDC->piW32ToW16ObjectMap = (PINT) LocalAlloc(LMEM_FIXED, i) ;
        if (pLocalDC->piW32ToW16ObjectMap == NULL)
            goto error_exit ;

        // Initialize the W32 to W16 object map to UNMAPPED (-1).
        // Since we never will have mapping to -1 we can test for
        // -1 in the map to make sure we are not double allocating a slot.

        for (i = 0 ; i < pLocalDC->cW32ToW16ObjectMap ; i++)
            pLocalDC->piW32ToW16ObjectMap[i] = UNMAPPED ;

        // Allocate storage for the slot status tables.
        // The number of Win16 object table slot may expand during conversion
        // due to temporary bitmaps and regions.  It is my educated guess
        // that we will never need more than 5 extra slots, because we
        // only use a slot for a very short time, then free it.  We are
        // allocating 256 extra slots in the name of robustness.
    // Note that the multi-format comment record may take up some
    // of these slots and increase the high water mark for object index.
    // We need to expand the table when required.

        pLocalDC->cW16ObjHndlSlotStatus = pLocalDC->cW32ToW16ObjectMap + 256 ;
        if (pLocalDC->cW16ObjHndlSlotStatus > (UINT) (WORD) MAXWORD)
            goto error_exit ;       // w16 handle index is only 16-bit

        i = pLocalDC->cW16ObjHndlSlotStatus * sizeof(W16OBJHNDLSLOTSTATUS) ;
        pLocalDC->pW16ObjHndlSlotStatus
        = (PW16OBJHNDLSLOTSTATUS) LocalAlloc(LMEM_FIXED, i) ;
        if (pLocalDC->pW16ObjHndlSlotStatus == NULL)
            goto error_exit ;

        // Initialize the W16ObjectHandleSlotStatus to a state where every
        // handle is available.

        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
            pLocalDC->pW16ObjHndlSlotStatus[i].use       = OPEN_AVAILABLE_SLOT ;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;
        }

    // Initialize the pW32hPal palette handle table.
    // This table is used to store the W32 palette handles created during
    // the conversion.

        pLocalDC->cW32hPal = pmf32header->nHandles;
    i = pLocalDC->cW32hPal * sizeof(HPALETTE);
        pLocalDC->pW32hPal = (HPALETTE *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, i) ;
    if (pLocalDC->pW32hPal == NULL)
            goto error_exit ;

    b = TRUE;

error_exit:
    if (!b)
    {
            if (pLocalDC->piW32ToW16ObjectMap)
        {
        if (LocalFree(pLocalDC->piW32ToW16ObjectMap))
            ASSERTGDI(FALSE, "MF3216: LocalFree failed");
                pLocalDC->piW32ToW16ObjectMap = (PINT) NULL;
        }

        if (pLocalDC->pW16ObjHndlSlotStatus)
        {
            if (LocalFree(pLocalDC->pW16ObjHndlSlotStatus))
                ASSERTGDI(FALSE, "MF3216: LocalFree failed");
            pLocalDC->pW16ObjHndlSlotStatus = NULL;
        }
    }

    return(b) ;
}


/***************************************************************************
 * bDeleteW16Object - Delete a W16 Object.
 *
 *  This is the routine that is called to Delete a W16 Object that has
 *  no corresponding W32 object.  Region and Bitmaps are two examples.
 **************************************************************************/
BOOL bDeleteW16Object(PLOCALDC pLocalDC, INT ihW16)
{
BOOL    b ;

    ASSERTGDI
    (
            pLocalDC->pW16ObjHndlSlotStatus[ihW16].use != OPEN_AVAILABLE_SLOT,
        "MF3216: bDeleteW16Object, bad use value"
    );

        // Mark the W16 Slot just freed as available.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].use = OPEN_AVAILABLE_SLOT ;

        // Emit a Win16 DeleteOject record for the Object

        b = bEmitWin16DeleteObject(pLocalDC, LOWORD(ihW16)) ;

        return (b) ;
}


/***************************************************************************
 * iGetW16ObjectHandleSlot - return the first W16 open slot in the handle
 *                           table.
 *
 *      1]  This routine searches the pW16ObjHndlSlotStatus array
 *          looking for the first available open slot.
 *
 *      2]  Mark the slot found as to its intended use.
 *
 *      3]  Returns the first open slot if found, else return -1.
 *
 *      4]  In essence this routine mimics the actions of the
 *          Win16 play-time handle allocation system, in either
 *          Win3.0 or Win3.1
 *
 *      5]  We also keep track of the max object count here.
 *
 **************************************************************************/
INT iGetW16ObjectHandleSlot(PLOCALDC pLocalDC, INT iIntendedUse)
{
BOOL    b ;
UINT    i ;

        b = FALSE ;

        // Search for an available slot.

        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use == OPEN_AVAILABLE_SLOT)
            {
                b = TRUE ;
                break ;
            }
        }

        // If a slot was found then mark its intended use.
        // Also set the W32 handle that may be associated with this
        // W16 handle to NULL. (Meaning no association at this time.)

        if (b)
        {
            ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle == 0,
        "MF3216: iGetW16ObjectHandleSlot: w32Handle is not 0");

            pLocalDC->pW16ObjHndlSlotStatus[i].use       = iIntendedUse ;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;

        // Update the number of object counts.  This will be used
        // when we update the metafile header.

            if ((INT) i >= pLocalDC->nObjectHighWaterMark)
                pLocalDC->nObjectHighWaterMark = (INT) i;

            return((INT) i);
        }
        else
        {
            RIP("MF3216: iGetW16ObjectHandleSlot, Slot not found\n") ;
            return(-1) ;
        }
}


/***************************************************************************
 * iNormalizeHandle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *
 *     1]  The idea behind this routine is to isolate the handling
 *         of stock object handles to one place.
 *
 *     2]  Input will be a Win32 handle index, either stock or a
 *         standard object.
 *
 *     3]  Output will be the index of the entry in the
 *         piW32ToW16ObjectMap table that corresponds to the W32
 *         handle.  If an error is detected -1 is returned.
 *
 *     4]  All the stock objects will be between the range of 0
 *         and LAST_STOCK, and all the non-stock objects will be
 *         greater than LAST_STOCK.
 *
 **************************************************************************/
INT iNormalizeHandle(PLOCALDC pLocalDC, INT ihW32)
{
INT     ihW32Norm ;

        if (ihW32 & ENHMETA_STOCK_OBJECT)
        {
            ihW32Norm = ihW32 & ~ENHMETA_STOCK_OBJECT ;
            if ((UINT) ihW32Norm > STOCK_LAST)
            {
                RIP("MF3216: iNormalizeHandle, bad stock object\n") ;
                ihW32Norm = -1 ;
            }
        }
        else
        {
            ihW32Norm = ihW32 + STOCK_LAST + 1 ;
            if ((UINT) ihW32Norm >= pLocalDC->cW32ToW16ObjectMap)
            {
                RIP("MF3216: iNormalizeHandle, bad standard object\n") ;
                ihW32Norm = -1 ;
            }
        }

        return(ihW32Norm) ;
}


/***************************************************************************
 * iAllocateW16Handle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *        It is to be called from the object creation routines.
 *
 *     1]  This routine actually does the handle allocation.
 *
 *     2]  It sets the entry in pW16ObjHndlSlotStatus array
 *         for the slot allocated by iGetW16ObjectHandleSlot to
 *         an "in-use" status (for the intended use).
 *
 *     3]  It returns a ihW16 (an index handle to the Win16 handle
 *         table, aka the Win16 handle slot number).
 *
 **************************************************************************/
INT iAllocateW16Handle(PLOCALDC pLocalDC, INT ihW32, INT iIntendedUse)
{
INT     ihW32Norm,
        ihW16 ;

        // Assume the worst, set up for a failed return code.

        ihW16 = -1 ;

        // Normalize the handle.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihW32) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Check for double allocation of a Win32 handle index.
        // If we find a double allocation, this would indicate an error
        // in the Win32 metafile.
        // Error out on this due to the possibility of
        // a brush being used for a bitmap, or some other wrong use of a handle.

        if (pLocalDC->piW32ToW16ObjectMap[ihW32Norm] != UNMAPPED)
        {
            RIP("MF3216: iAllocateW16Handle, Double W32 handle allocation detected\n") ;
            goto error_exit ;
        }

        // Get a slot in the Win16 handle table.

        ihW16 = iGetW16ObjectHandleSlot(pLocalDC, iIntendedUse) ;
        if (ihW16 == -1)
            goto error_exit ;

        // Set the W32 to W16 slot mapping

        pLocalDC->piW32ToW16ObjectMap[ihW32Norm] = ihW16 ;

error_exit:
        return(ihW16) ;
}

/***************************************************************************
 * iValidateHandle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *
 *     1]  This routine does a lot more than validate a Win32 handle.
 *         It does some limited error checking on the Win32 handle,
 *         to make sure its within a reasonable range.  Then if a
 *         Win16 handle table slot has already been allocated for
 *         this Win32 handle it will return the Win16 handle that
 *         was previously allocated.  Alternatively, if a Win16
 *         handle has not been previously allocated for a Win32
 *         STOCK handle it will allocate a W16 handle and return the
 *         Win16 handle.  This function is called by FillRgn, FrameRgn
 *         and SelectObject to allow lazy allocation of stock objects.
 *
 *     2]  Input is a Win32 handle, either a stock or a non-stock
 *         handle.
 *
 *     3]  Output is a Win16 handle, this is the value in the
 *         Win32-index of the piW32ToW16ObjectMap.  If a stock object
 *         does not exist, it will create one.
 *
 *     4]  If there is an error a -1 is returned.
 **************************************************************************/
INT iValidateHandle(PLOCALDC pLocalDC, INT ihW32)
{
INT     ihW32Norm,
        ihW16 ;

        // Assume the worst.

        ihW16 = -1 ;

        // NOTE: Normalizing the W32 handles takes care of checking
        // for a reasonable W32 handle value.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihW32) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Check the W32ToW16 map, to determine if this W32 handle has
        // already been allocated a W16 slot.

        ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        if (ihW16 == UNMAPPED)
        {
            // There is no mapping from W32 to W16.  This implies
            // that the object in question does not exist.  If this is
            // a stock object, then we will create the object at this time.
            // Alternatively, if this is a non-stock object then we have an
            // error condition.

            if ((DWORD) ihW32Norm <= STOCK_LAST)
            {
                if (bCreateStockObject(pLocalDC, ihW32))
                    ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        else
            ihW16 = -1 ;
            }
            else
            {
                RIP("MF3216: iValidateHandle - Unmapped Standard Object\n") ;
            ihW16 = -1 ;
            }
        }

error_exit:
        return (ihW16) ;
}


/***************************************************************************
 *  DoDeleteObject  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR1 - Most of this routine was rewritten to conform to the new
 *        objects management system.
 *
 *      1]  The object handle is checked for reasonable limits.
 *          We will also make sure that the Win16 slot has a handle
 *          allocated to it.  If it does not then we will return an
 *          error.
 *
 *      2]  If this is a stock object we fail and return an error.
 *
 *      3]  If this is a non-stock object we emit a Win16DeleteObject
 *          record.  Then we set pW16ObjHndlSlotStatus to
 *          indicate that this slot is available.  We also set
 *          piW32ToW16ObjectMap to -1 (UNMAPPED).
 **************************************************************************/
BOOL WINAPI DoDeleteObject
(
PLOCALDC pLocalDC,
INT    ihObject
)
{
BOOL    b ;
INT     ihW16,
        ihW32Norm;

        // Assume the worst.

        b = FALSE ;

        // Normalize the W32 handle.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihObject) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Make sure we're not deleting a stock object.

        if ((DWORD) ihW32Norm <= STOCK_LAST)
        {
            PUTS("MF3216: DoDeleteObject, attempt to delete a stock object\n") ;
            return(TRUE);
        }

        // If this is a palette, then we do not delete the win16 object.
        // We do delete our local version of the palette.

    if (pLocalDC->pW32hPal && pLocalDC->pW32hPal[ihObject])
        {
        b = DeleteObject(pLocalDC->pW32hPal[ihObject]);
        pLocalDC->pW32hPal[ihObject] = 0;

            if (b == FALSE)
                RIP("MF3216: DoDeleteObject - DeleteObject (hPalette) failed\n") ;
            return (b) ;
        }

        // Map the ihW32 to a ihW16 (object handle table slot).

        ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        if (ihW16 == UNMAPPED)
        {
            RIP("MF3216: DoDeleteObject, attempt to delete a non-existent object\n");
            goto error_exit ;
        }

        // Make sure the object is one that we expect.
    // There is no region object or bitmap object in the enhanced metafiles.

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_FONT,
                 "MF3216: DoDeleteObject, Invalid Object Deletion\n") ;

        // If there was a Win32 handle associated with this Win16 handle
        // then the w32Handle field of the W16ObjHndlSlotStatus[ihW16]
        // entry in the handle slot status array will be non-null. If
        // it is non-null then we should delete the Win32 handle at this time.

        if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0)
        {
            if (!DeleteObject(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle))
        {
            ASSERTGDI(FALSE, "MF3216: DoDeleteObject, DeleteObject failed");
        }
            pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle = 0 ;
        }

        // Mark the slot as available.
        // And set the map entry for the W32ToW16 map to unmapped.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].use = OPEN_AVAILABLE_SLOT ;
        pLocalDC->piW32ToW16ObjectMap[ihW32Norm]   = UNMAPPED ;

        // Emit the delete drawing order.

        b = bEmitWin16DeleteObject(pLocalDC, LOWORD(ihW16)) ;

error_exit:
        return (b) ;
}

/***************************************************************************
 *  DoSelectObject  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR1 - Major rewrite due to handle system redesign.
 *
 *  DoSelectObject
 *
 *      1]  For stock objects this is the workhorse routine.
 *
 *      2]  For normal, non-stock, objects this routine will verify
 *          that an object has been created for this Win32 object-index.
 *          Then it will emit a Win16SelectObject metafile record.
 *
 *      3]  For stock objects things get a little more complicated.
 *          First this routine must make sure a Win16 object has been
 *          created for this stock object.  If a Win16 object has not
 *          been created yet, then it will be. After a Win16 object
 *          is created a Win16SelectObject record will be emitted for
 *          the object.
 **************************************************************************/
BOOL WINAPI DoSelectObject
(
PLOCALDC pLocalDC,
LONG   ihObject
)
{
BOOL    b ;
INT     ihW16;

        // Assume the worst.

        b = FALSE ;

        // Make sure that the W16 object exists before we emit the
    // SelectObject record.  Stock objects may not have been created
    // and iValidateHandle will take care of creating them.

        ihW16 = iValidateHandle(pLocalDC, ihObject) ;
        if (ihW16 == -1)
            goto error_exit ;

        // Make sure the object is one that we expect.
    // There is no region object or bitmap object in the enhanced metafiles.

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_FONT,
                 "MF3216: DoSelectObject, Invalid Object Deletion\n") ;

    // Remember the currently selected pen.  This is used in path and text.

    if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN)
        pLocalDC->lhpn32 = ihObject;

    // Remember the currently selected brush.  This is used in text.

    if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH)
        pLocalDC->lhbr32 = ihObject;

        // If there was a Win32 handle associated with this Win16 handle
        // then the w32Handle field of the W16ObjHndlSlotStatus[ihW16]
        // entry in the handle slot status array will be non-null. If
        // it is non-null then we should select the W32 object into the
        // helper DC at this time.

        if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0)
            SelectObject(pLocalDC->hdcHelper,
             pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle) ;

        b = bEmitWin16SelectObject(pLocalDC, LOWORD(ihW16)) ;

error_exit:
        return(b) ;
}


/***************************************************************************
 * bCreateStockObject
 **************************************************************************/
BOOL bCreateStockObject(PLOCALDC pLocalDC, INT ihW32)
{
BOOL        b ;
INT         i ;

        ASSERTGDI((ihW32 & ENHMETA_STOCK_OBJECT) != 0,
        "MF3216: bCreateStockObject, invalid stock handle");

        switch (ihW32 & ~ENHMETA_STOCK_OBJECT)
        {
            case WHITE_BRUSH:
            case LTGRAY_BRUSH:
            case GRAY_BRUSH:
            case DKGRAY_BRUSH:
            case BLACK_BRUSH:
            case NULL_BRUSH:
                b = DoCreateBrushIndirect(pLocalDC, ihW32, &albStock[ihW32 & ~ENHMETA_STOCK_OBJECT]) ;
                break ;

            case WHITE_PEN:
            case BLACK_PEN:
            case NULL_PEN:
                i = (ihW32 & ~ENHMETA_STOCK_OBJECT) - WHITE_PEN ;
                b = DoCreatePen(pLocalDC, ihW32, (PLOGPEN) &alpnStock[i]) ;
                break ;


            case OEM_FIXED_FONT:
            case ANSI_FIXED_FONT:
            case ANSI_VAR_FONT:
            case SYSTEM_FONT:
            case DEVICE_DEFAULT_FONT:
            case SYSTEM_FIXED_FONT:
                b = bCreateStockFont(pLocalDC, ihW32) ;
                break ;

            case DEFAULT_PALETTE:
            default:
        // Logical palettes are handled in DoSelectPalette and should
        // not get here.

                RIP("MF3216: bCreateStockObject - Invalid Stock Object\n") ;
                b =FALSE ;
                break ;
        }

        return (b) ;
}


/***************************************************************************
 * bCreateStockFont
 **************************************************************************/
BOOL bCreateStockFont(PLOCALDC pLocalDC, INT ihW32)
{
BOOL     b ;
INT      i ;
LOGFONTW LogFontW ;
HANDLE   hFont ;

        b = FALSE ;

        ASSERTGDI((ihW32 & ENHMETA_STOCK_OBJECT) != 0,
        "MF3216: bCreateStockObject, invalid stock handle");

        // Get a handle to this logfont.

        hFont = GetStockObject(ihW32 & ~ENHMETA_STOCK_OBJECT) ;
        if (hFont == (HANDLE) 0)
        {
            RIP("MF3216: bCreateStockFont, GetStockObject (font) failed\n") ;
            goto error_exit ;
        }

        // Get the logfont data.  Assume we get at least one char in the
    // facename string.

        i = GetObjectW(hFont, sizeof(LOGFONTW), &LogFontW) ;
        if (i <= (INT) offsetof(LOGFONTW,lfFaceName[0]))
        {
            PUTS("MF3216: bCreateStockFont - GetObjectW failed\n") ;
            goto error_exit ;
        }

    // Zero out the remaining logfont structure.

    for ( ; i < sizeof(LOGFONTW); i++)
        ((PBYTE) &LogFontW)[i] = 0;

        // Create a LogFont for this stock font in the Win16 metafile.

        b = DoExtCreateFont(pLocalDC,
                            ihW32,
                            &LogFontW);
error_exit:
        return (b) ;
}


/***************************************************************************
 *  CreateBrushIndirect  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateBrushIndirect
(
PLOCALDC    pLocalDC,
INT         ihBrush,
LPLOGBRUSH  lpLogBrush
)
{
WIN16LOGBRUSH Win16LogBrush ;
BOOL          b ;
INT           ihW16 ;
LOGBRUSH      LogBrush ;

        b = FALSE ;

// Only 3 brush styles are allowed.

    if (lpLogBrush->lbStyle != BS_SOLID
     && lpLogBrush->lbStyle != BS_HATCHED
     && lpLogBrush->lbStyle != BS_HOLLOW)
            goto error_exit ;

// Make a copy of the logical brush.

        LogBrush = *lpLogBrush;

// The first 6 hatched styles map directly from Win32 to Win16.
// The remaining hatched brushes are simulated using DIB pattern
// brushes.  Note that the background color of a hatched brush
// is the current background color but that of a DIB pattern brush
// is given at create time!  We will use the current background color
// in the DIB pattern brush when it is created.  As a result, the
// output of these brushes may look different!

        if (LogBrush.lbStyle == BS_HATCHED)
        {
        switch (LogBrush.lbHatch)
        {
        case HS_HORIZONTAL:
        case HS_VERTICAL:
        case HS_FDIAGONAL:
        case HS_BDIAGONAL:
        case HS_CROSS:
        case HS_DIAGCROSS:
                break;

        default:
                RIP("MF3216: Unknown hatched pattern\n");
        LogBrush.lbStyle = BS_SOLID;
        break;
        }
        }

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// This brush is needed by the helper DC for BitBlt simulations.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreateBrushIndirect(lpLogBrush) ;

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreateBrushIndirect failed");

// Assign all the Win32 brush attributes to Win16 brush attributes.

        Win16LogBrush.lbStyle = (WORD) LogBrush.lbStyle ;
        Win16LogBrush.lbColor = LogBrush.lbColor ;
        Win16LogBrush.lbHatch = (SHORT) LogBrush.lbHatch ;

// Call the Win16 routine to emit the brush to the metafile.

        b = bEmitWin16CreateBrushIndirect(pLocalDC, &Win16LogBrush) ;

error_exit:
        return(b) ;
}


/******************************Public*Routine******************************\
* CreateMonoDib
*
* This is the same as CreateBitmap except that the bits are assumed
* to be DWORD aligned and that the scans start from the bottom of the bitmap.
*
* This routine is temporary until CreateDIBitmap supports monochrome bitmaps
*
* History:
*  Wed Jul 01 11:02:24 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

HBITMAP CreateMonoDib
(
    LPBITMAPINFO pbmi,
    CONST BYTE * pjBits,
    UINT     iUsage
)
{
    HBITMAP hbm;

    ASSERTGDI(pbmi->bmiHeader.biPlanes == 1, "CreateMonoDib: bad biPlanes value");
    ASSERTGDI(pbmi->bmiHeader.biBitCount == 1, "CreateMonoDib: bad biBitCount value");

    hbm = CreateBitmap((int)  pbmi->bmiHeader.biWidth,
               (int)  pbmi->bmiHeader.biHeight,
               (UINT) 1,
               (UINT) 1,
               (CONST VOID *) NULL);
    if (!hbm)
    return(hbm);

    SetDIBits((HDC) 0, hbm, 0, (UINT) pbmi->bmiHeader.biHeight,
          (CONST VOID *) pjBits, pbmi, iUsage);

    return(hbm);
}


/***************************************************************************
 *  CreateMonoBrush  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateMonoBrush
(
PLOCALDC    pLocalDC,
DWORD       ihBrush,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
DWORD       iUsage
)
{
BOOL        b ;
INT         ihW16;
DWORD       ul ;
BYTE        pbmi[sizeof(BITMAPINFOHEADER) + 2 * sizeof(RGBQUAD)];
HBITMAP     hbm;

        b = FALSE ;

// Need to make a copy of the bitmap info header,  for a few reasons
//  1] the memory mapped file is write protected.
//  2] the iUsage may be (is) use palatte indicies, and we need
//     use RGB colors.

        ((PBITMAPINFO) pbmi)->bmiHeader = pBitmapInfo->bmiHeader;

// Need to make sure the iUsage is DIB_RGB_COLORS
// and the palette is initialized to Black and White.

        ul = 0 ;
        ((PBITMAPINFO) pbmi)->bmiColors[0] = (*((RGBQUAD *) &(ul))) ;

        ul = 0x00ffffff ;
        ((PBITMAPINFO) pbmi)->bmiColors[1] = (*((RGBQUAD *) &(ul))) ;

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// This brush is needed by the helper DC for BitBlt simulations.

    if ((hbm = CreateMonoDib
           (
               pBitmapInfo,
               (CONST BYTE *) pBits,
               (UINT) iUsage
           )
        )
       )
    {
        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreatePatternBrush(hbm);

        if (!DeleteObject(hbm))
        ASSERTGDI(FALSE, "MF3216: DoCreateMonoBrush, DeleteObject failed");
    }

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreatePatternBrush failed");

// Call the Win16 routine to emit the brush to the metafile.

        b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        (PBITMAPINFO) pbmi,
                                        sizeof(pbmi),
                                        pBits,
                                        cbBits,
                                        (WORD) DIB_RGB_COLORS,
                                        (WORD) BS_PATTERN  // Mono brush!
                       ) ;
error_exit:
        return(b) ;
}

/***************************************************************************
 *  CreateDIPatternBrush  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateDIBPatternBrush
(
PLOCALDC    pLocalDC,
DWORD       ihBrush,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
DWORD       iUsage
)
{
BOOL    b;
INT     ihW16;
HBITMAP hbm;
PBYTE   pBits24;
DWORD   cbBits24;
BITMAPINFOHEADER bmih;

    hbm = (HBITMAP) 0;
    pBits24 = (PBYTE) NULL;
        b = FALSE ;

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// We assume that the bitmap info is followed by the bits immediately,
// i.e. it is a packed dib.
// This brush is needed by the helper DC for BitBlt simulations.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreateDIBPatternBrushPt((LPVOID) pBitmapInfo, (UINT) iUsage);

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreateDIBPatternBrushPt failed");

// We need to convert new bitmap info formats to the win3 formats.

    if (pBitmapInfo->bmiHeader.biPlanes != 1
     || pBitmapInfo->bmiHeader.biBitCount == 16
     || pBitmapInfo->bmiHeader.biBitCount == 32)
    {
        if (!(hbm = CreateDIBitmap(pLocalDC->hdcHelper,
                (LPBITMAPINFOHEADER) pBitmapInfo,
                CBM_INIT | CBM_CREATEDIB,
                pBits,
                (LPBITMAPINFO) pBitmapInfo,
                (UINT) iUsage)))
                goto error_exit ;

        bmih = *(PBITMAPINFOHEADER) pBitmapInfo;
        bmih.biPlanes       = 1;
        bmih.biBitCount     = 24;
        bmih.biCompression  = BI_RGB;
        bmih.biSizeImage    = 0;
        bmih.biClrUsed      = 0;
        bmih.biClrImportant = 0;

            cbBits24 = CJSCAN(bmih.biWidth,bmih.biPlanes,bmih.biBitCount)
                * ABS(bmih.biHeight);

        pBits24 = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits24);
        if (pBits24 == (LPBYTE) NULL)
            goto error_exit;

        // Get bitmap info and bits in 24bpp.

        if (!GetDIBits(pLocalDC->hdcHelper,
               hbm,
               0,
               (UINT) bmih.biHeight,
               pBits24,
               (LPBITMAPINFO) &bmih,
               DIB_RGB_COLORS))
            goto error_exit;

            b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        (PBITMAPINFO) &bmih,
                                        sizeof(bmih),
                                        pBits24,
                                        cbBits24,
                                        (WORD) DIB_RGB_COLORS,
                                        (WORD) BS_DIBPATTERN
                       ) ;
    }
    else
    {

// Call the Win16 routine to emit the brush to the metafile.

            b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        pBitmapInfo,
                                        cbBitmapInfo,
                                        pBits,
                                        cbBits,
                                        (WORD) iUsage,
                                        (WORD) BS_DIBPATTERN
                       ) ;
    }

error_exit:
    if (hbm)
        DeleteObject(hbm);
    if (pBits24)
        LocalFree((HANDLE) pBits24);
        return(b) ;
}


/***************************************************************************
 * CreatePen  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreatePen
(
PLOCALDC    pLocalDC,
INT         ihPen,
PLOGPEN     pLogPen
)
{
EXTLOGPEN   ExtLogPen ;
BOOL        b ;

        ExtLogPen.elpPenStyle   = PS_GEOMETRIC | pLogPen->lopnStyle ;
        ExtLogPen.elpWidth      = (UINT) pLogPen->lopnWidth.x ;
        ExtLogPen.elpBrushStyle = BS_SOLID ;
        ExtLogPen.elpColor      = pLogPen->lopnColor ;
        ExtLogPen.elpNumEntries = 0 ;
        // ExtLogPen.elpHatch   = 0 ;
        // ExtLogPen.elpStyleEntry[0] = 0;

        b = DoExtCreatePen(pLocalDC, ihPen, &ExtLogPen) ;

        return (b) ;
}

/***************************************************************************
 *  ExtCreatePen  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtCreatePen
(
PLOCALDC    pLocalDC,
INT         ihPen,
PEXTLOGPEN  pExtLogPen
)
{
BOOL        b ;
WORD        iStyle ;
POINTS      ptsWidth ;
INT         ihW16 ;
UINT        iPenStyle ;
POINTL      ptlWidth ;
COLORREF    crColor ;

    b = FALSE;

    // Get pen style.

        iPenStyle = pExtLogPen->elpPenStyle & PS_STYLE_MASK ;
        switch(iPenStyle)
        {
            case PS_SOLID:
            case PS_DASH:
            case PS_DOT:
            case PS_DASHDOT:
            case PS_DASHDOTDOT:
            case PS_NULL:
            case PS_INSIDEFRAME:
                break ;

            case PS_ALTERNATE:
                iPenStyle = PS_DOT ;
                break ;

            case PS_USERSTYLE:
            default:
                // CR1: default to solid.
                iPenStyle = PS_SOLID ;
                break ;
        }

    // Get pen color.

        switch (pExtLogPen->elpBrushStyle)
        {
        case BS_SOLID:
        case BS_HATCHED:
            crColor   = pExtLogPen->elpColor ;
        break;

        // If the extended pen contains a hollow brush, then
        // we will emit a NULL pen.
        case BS_NULL:    // BS_HOLLOW is the same as BS_NULL
            iPenStyle = PS_NULL ;
            crColor   = 0 ;
        break;

        // Win3.x does not support pens with bitmap patterns.
        // So we will just use solid pens here.  Since we do not
        // know what pen color to use, we choose the text color.
        case BS_PATTERN:
        case BS_DIBPATTERN:
        case BS_DIBPATTERNPT:
            default:
            crColor   =  pLocalDC->crTextColor ;
        break;
        }

    // Get pen width.
    // If this is a cosmetic pen then the width is 0.

        ptlWidth.y = 0 ;
        if ((pExtLogPen->elpPenStyle & PS_TYPE_MASK) == PS_COSMETIC)
            ptlWidth.x = 0 ;
        else
            ptlWidth.x = pExtLogPen->elpWidth ;

    // Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihPen, REALIZED_PEN);
        if (ihW16 == -1)
            goto error_exit ;

        // This is where we need to create a pen for helper DC.
        // We do not select it into the helper DC at this time.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreatePen((int) iPenStyle, ptlWidth.x, crColor) ;

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: DoExtCreatePen, CreatePen failed");

    // Get pen width in play time page units.

        ptlWidth.x = (LONG) iMagnitudeXform(pLocalDC, (INT) ptlWidth.x, CX_MAG);

        // Set the Win16 pen attributes

        iStyle     = (WORD) iPenStyle  ;
        ptsWidth.x = (WORD) ptlWidth.x ;
        ptsWidth.y = (WORD) ptlWidth.y ;

        // Call the Win16 routine to emit the pen to the metafile.

        b = bEmitWin16CreatePen(pLocalDC, iStyle, &ptsWidth, crColor) ;

error_exit:
        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\preamble.c ===
/*****************************************************************************
 *
 * Preamble - Preamble routines for MF3216
 *
 * Date: 7/18/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/


#include "precomp.h"
#pragma hdrstop

BOOL bSetWindowOrgAndExtToFrame(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;

/*----------------------------------------------------------------------------
 *  DoHeader -  Emit the Win16 metafile header
 *---------------------------------------------------------------------------*/
BOOL APIENTRY DoHeader(PLOCALDC pLocalDC, PENHMETAHEADER pemfheader)
{
BOOL        b ;

        b = bInitHandleTableManager(pLocalDC, pemfheader) ;
        if (b == FALSE)
            goto error_exit ;

    b = bInitXformMatrices(pLocalDC, pemfheader) ;
        if (b == FALSE)
            goto error_exit ;

        // The metafile will always be memory based.

    pLocalDC->mf16Header.mtType    = MEMORYMETAFILE ;
    pLocalDC->mf16Header.mtVersion = 0x300 ;    // magic number for Win3.0
    pLocalDC->mf16Header.mtHeaderSize = sizeof (METAHEADER) / 2 ;

    // Init fields to 0.  They will be updated at the end of translation.

    pLocalDC->mf16Header.mtSize      = 0 ;
    pLocalDC->mf16Header.mtNoObjects = 0 ;
    pLocalDC->mf16Header.mtMaxRecord = 0 ;      // NOTE: We need a max record size.
    pLocalDC->mf16Header.mtNoParameters = 0 ;

    // Emit the MF16 metafile header to the metafile.

    b = bEmit(pLocalDC, &pLocalDC->mf16Header, sizeof(METAHEADER)) ;
        if (b == FALSE)
            goto error_exit ;

        if (pLocalDC->flags & INCLUDE_W32MF_COMMENT)
        {
            b = bHandleWin32Comment(pLocalDC) ;
            if (b == FALSE)
                goto error_exit ;
        }

    // Prepare the transform for the 16-bit metafile.  See comments in
    // xforms.c.

    // Emit the Win16 MapMode record

        b = bEmitWin16SetMapMode(pLocalDC, LOWORD(pLocalDC->iMapMode)) ;
        if (b == FALSE)
            goto error_exit ;

        // Set the Win16 metafile WindowExt to the size of the frame
        // in play-time device units.

        b = bSetWindowOrgAndExtToFrame(pLocalDC, pemfheader) ;
        if (b == FALSE)
        {
            RIP("MF3216: DoHeader, bSetWindowOrgAndExtToFrame failure\n") ;
            goto error_exit ;
        }

error_exit:
    return(b) ;
}



/*----------------------------------------------------------------------------
 * Calculate and Emit into the Win16 metafile a Window origin
 * and extent drawing order
 * that will set the Window Origin and Extent to the size of the picture  frame in
 * play-time-page (reference-logical) units.
 *---------------------------------------------------------------------------*/
BOOL bSetWindowOrgAndExtToFrame(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
FLOAT   ecxPpmmPlay,        // cx pixels per millimeter play
        ecyPpmmPlay,        // cy pixels per millimeter play
        ecx01PpmmPlay,      // cx pixels per .01 millimeter play
        ecy01PpmmPlay,      // cy pixels per .01 millimeter play
        ecxPelsFrame,       // cx play-time frame in device units
        ecyPelsFrame,       // cy play-time frame in device units
        exPelsFrame,        // x play-time frame in device units
        eyPelsFrame ;       // y play-time frame in device units

INT     cxFrame,            // cx Picture Frame
        cyFrame,            // cy Picture Frame
        xFrame,             // x Picture Frame
        yFrame ;            // y Picture Frame

SIZEL   szlFrame ;
POINTL  ptlFrame ;

        // Calculate the play-time (reference) pixels per millimeter.

        ecxPpmmPlay = (FLOAT) pLocalDC->cxPlayDevPels / (FLOAT) pLocalDC->cxPlayDevMM ;
        ecyPpmmPlay = (FLOAT) pLocalDC->cyPlayDevPels / (FLOAT) pLocalDC->cyPlayDevMM ;

        // Scale the pixels per millimeter to pixels per .01 millimeters.

        ecx01PpmmPlay = ecxPpmmPlay / 100.0f ;
        ecy01PpmmPlay = ecyPpmmPlay / 100.0f ;

        // Pickup the fram origin

        xFrame = pmf32header->rclFrame.left ;
        yFrame = pmf32header->rclFrame.top ;

        // Translate the frame origin to play-time-device units.

        exPelsFrame = ecx01PpmmPlay * (FLOAT) xFrame ;
        eyPelsFrame = ecy01PpmmPlay * (FLOAT) yFrame ;

        // Convert the Frame origin to play-time-page units.
        // (aka reference-logical units.)

        ptlFrame.x = (LONG) (exPelsFrame * pLocalDC->xformPDevToPPage.eM11 + 0.5f);
        ptlFrame.y = (LONG) (eyPelsFrame * pLocalDC->xformPDevToPPage.eM22 + 0.5f);
    if (!bCoordinateOverflowTest((PLONG) &ptlFrame, 2))
            return(FALSE);

        // Set the Window origin.

        if (!bEmitWin16SetWindowOrg(pLocalDC,
                    (SHORT) ptlFrame.x,
                    (SHORT) ptlFrame.y))
        {
            RIP("MF3216: bEmitWin16SetWindowOrg failed\n") ;
            return(FALSE);
        }

        // Calculate the Frame width and height.

        cxFrame = pmf32header->rclFrame.right - pmf32header->rclFrame.left ;
        cyFrame = pmf32header->rclFrame.bottom - pmf32header->rclFrame.top ;

        // Convert the frame width and height into play-time-device units.
        // (aka reference-device units.)

        ecxPelsFrame = ecx01PpmmPlay * (FLOAT) cxFrame ;
        ecyPelsFrame = ecy01PpmmPlay * (FLOAT) cyFrame ;

        // Translate the play-time device units into play-time-page units.
        // (aka reference-device to reference-logical units.)
    // This is an identity transform for MM_ANISOTROPIC mode.  For other
    // fixed mapping modes, the SetWindowExt record has no effect.

        szlFrame.cx = (LONG) (ecxPelsFrame + 0.5f);
        szlFrame.cy = (LONG) (ecyPelsFrame + 0.5f);
    if (!bCoordinateOverflowTest((PLONG) &szlFrame, 2))
            return(FALSE);

        // Set the Window Extent.

        if (!bEmitWin16SetWindowExt(pLocalDC,
                    (SHORT) szlFrame.cx,
                    (SHORT) szlFrame.cy))
        {
            RIP("MF3216: bEmitWin16SetWindowExt failed\n") ;
            return(FALSE);
        }

        return(TRUE);
}


/*----------------------------------------------------------------------------
 *  UpdateMf16Header - Update the metafile header with the:
 *             metafile size,
 *             number of objects,
 *             the max record size.
 *---------------------------------------------------------------------------*/
BOOL bUpdateMf16Header(PLOCALDC pLocalDC)
{
BOOL    b ;
INT     iCpTemp ;

    // Fill in the missing info in the Win16 metafile header.

    pLocalDC->mf16Header.mtSize      = pLocalDC->ulBytesEmitted / 2 ;
    pLocalDC->mf16Header.mtNoObjects = (WORD) (pLocalDC->nObjectHighWaterMark + 1) ;
    pLocalDC->mf16Header.mtMaxRecord = pLocalDC->ulMaxRecord ;

        // Reset the output buffer index to the beginning of the buffer.

        iCpTemp = pLocalDC->ulBytesEmitted ;
        pLocalDC->ulBytesEmitted = 0 ;

    // re-emit the Win16 metafile header.

    b = bEmit(pLocalDC, &pLocalDC->mf16Header, (DWORD) sizeof (pLocalDC->mf16Header)) ;

        pLocalDC->ulBytesEmitted = iCpTemp ;

    return (b) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\paths.c ===
/*****************************************************************************
 *
 * paths - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  BeginPath  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoBeginPath
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        // Set the global flag telling all all the geometric
        // rendering routines that we are accumulating drawing orders
        // for the path.

        pLocalDC->flags |= RECORDING_PATH ;

        // Tell the helper DC we are begining the path accumulation.

        b = BeginPath(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoBeginPath, BeginPath failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  EndPath  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoEndPath
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        // Reset the global flag, turning off the path accumulation.

        pLocalDC->flags &= ~RECORDING_PATH ;

        b = EndPath(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoEndPath, EndPath failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  WidenPath  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoWidenPath
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        b = WidenPath(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoWidenPath, WidenPath failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  SelectClipPath  - Win32 to Win16 Metafile Converter Entry Point
 *
 * History:
 *  Tue Apr 07 17:05:37 1992  	-by-	Hock San Lee	[hockl]
 * Wrote it.
 **************************************************************************/

BOOL WINAPI DoSelectClipPath(PLOCALDC pLocalDC, INT iMode)
{
    // If there is no initial clip region and we are going to operate
    // on the initial clip region, we have to
    // create one.  Otherwise, GDI will create some random default
    // clipping region for us!

    if ((iMode == RGN_DIFF || iMode == RGN_XOR || iMode == RGN_OR)
     && bNoDCRgn(pLocalDC, DCRGN_CLIP))
    {
	BOOL   bRet;
	HRGN hrgnDefault;
	
	if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
					  (int) (SHORT) MINSHORT,
					  (int) (SHORT) MAXSHORT,
					  (int) (SHORT) MAXSHORT)))
	{
	    ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
	    return(FALSE);
	}
	
	bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
		!= ERROR);
	ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");
	
	if (!DeleteObject(hrgnDefault))
	    ASSERTGDI(FALSE, "MF3216: DeleteObject failed");
	
	if (!bRet)
	    return(FALSE);
    }

    // Do it to the helper DC.

    if (!SelectClipPath(pLocalDC->hdcHelper, iMode))
        return(FALSE);

    // Dump the clip region data.

    return(bDumpDCClipping(pLocalDC));
}


/***************************************************************************
 *  FlattenPath  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoFlattenPath
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        b = FlattenPath(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoFlattenPath, FlattenPath failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  AbortPath  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoAbortPath
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        // Reset the global flag, turning off the path accumulation.

        pLocalDC->flags &= ~RECORDING_PATH ;

        b = AbortPath(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoAbortPath, AbortPath failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  CloseFigure  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCloseFigure
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        b = CloseFigure(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoCloseFigure, CloseFigure failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  DoRenderPath  - Common code for StrokePath, FillPath and StrokeAndFillPath.
 **************************************************************************/

// Macro for copy a point in the path data.

#define MOVE_A_POINT(iDst, pjTypeDst, pptDst, iSrc, pjTypeSrc, pptSrc)	\
	{								\
	    pjTypeDst[iDst] = pjTypeSrc[iSrc];				\
	    pptDst[iDst]    = pptSrc[iSrc];				\
	}

BOOL WINAPI DoRenderPath(PLOCALDC pLocalDC, INT mrType)
{
    BOOL    b;
    PBYTE   pb    = (PBYTE) NULL;
    PBYTE   pbNew = (PBYTE) NULL;
    LPPOINT ppt, pptNew;
    LPBYTE  pjType, pjTypeNew;
    PDWORD  pPolyCount;
    INT     cpt, cptNew, cPolyCount;
    INT     i, j, jStart;
    LONG    lhpn32;

    b = FALSE;				// assume failure

// Flatten the path, to convert all the beziers into polylines.

    if (!FlattenPath(pLocalDC->hdcHelper))
    {
	RIP("MF3216: DoRendarPath, FlattenPath failed\n");
	goto exit_DoRenderPath;
    }

// Get the path data.

    // First get a count of the number of points.

    cpt = GetPath(pLocalDC->hdcHelper, (LPPOINT) NULL, (LPBYTE) NULL, 0);
    if (cpt == -1)
    {
	RIP("MF3216: DoRendarPath, GetPath failed\n");
	goto exit_DoRenderPath;
    }

    // Check for empty path.

    if (cpt == 0)
    {
	b = TRUE;
	goto exit_DoRenderPath;
    }

    // Allocate memory for the path data.
 
    if (!(pb = (PBYTE) LocalAlloc
		(
		    LMEM_FIXED,
		    cpt * (sizeof(POINT) + sizeof(BYTE))
		)
	 )
       )
    {
	RIP("MF3216: DoRendarPath, LocalAlloc failed\n");
	goto exit_DoRenderPath;
    }

    // Order of assignment is important for dword alignment.

    ppt    = (LPPOINT) pb;
    pjType = (LPBYTE) (ppt + cpt);

    // Finally, get the path data.

    if (GetPath(pLocalDC->hdcHelper, ppt, pjType, cpt) != cpt)
    {
	RIP("MF3216: DoRendarPath, GetPath failed\n");
	goto exit_DoRenderPath;
    }

// The path data is in record-time world coordinates.  They are the
// coordinates we will use in the PolyPoly rendering functions below.
//
// Since we have flattened the path, the path data should only contain
// the following types:
//
//   PT_MOVETO
//   PT_LINETO
//   (PT_LINETO | PT_CLOSEFIGURE)
//
// To simplify, we will close the figure explicitly by inserting points
// and removing the (PT_LINETO | PT_CLOSEFIGURE) type from the path data.
// At the same time, we will create the PolyPoly structure to prepare for
// the PolyPolygon or PolyPolyline call.
//
// Note that there cannot be more than one half (PT_LINETO | PT_CLOSEFIGURE)
// points since they are followed by the PT_MOVETO points (except for the
// last point).  In addition, the first point must be a PT_MOVETO.
//
// We will also remove the empty figure, i.e. consecutive PT_MOVETO, from
// the new path data in the process.

// First, allocate memory for the new path data.

    cptNew = cpt + cpt / 2;
    if (!(pbNew = (PBYTE) LocalAlloc
		    (
			LMEM_FIXED,
			cptNew * (sizeof(POINT) + sizeof(DWORD) + sizeof(BYTE))
		    )
	 )
       )
    {
	RIP("MF3216: DoRendarPath, LocalAlloc failed\n");
	goto exit_DoRenderPath;
    }

    // Order of assignment is important for dword alignment.

    pptNew     = (LPPOINT) pbNew;
    pPolyCount = (PDWORD) (pptNew + cptNew);
    pjTypeNew  = (LPBYTE) (pPolyCount + cptNew);

// Close the path explicitly.

    i = 0;
    j = 0;
    cPolyCount = 0;			// number of entries in PolyCount array
    while (i < cpt)
    {
	ASSERTGDI(pjType[i] == PT_MOVETO, "MF3216: DoRenderPath, bad pjType[]");

	// Copy everything upto the next closefigure or moveto.

	jStart = j;

	// copy the moveto
	MOVE_A_POINT(j, pjTypeNew, pptNew, i, pjType, ppt);
	i++; j++;

	if (i >= cpt)			// stop if the last point is a moveto
	{
	    j--;			// don't include the last moveto
	    break;
	}

	while (i < cpt)
	{
	    MOVE_A_POINT(j, pjTypeNew, pptNew, i, pjType, ppt);
	    i++; j++;

	    // look for closefigure and moveto
	    if (pjTypeNew[j - 1] != PT_LINETO)
		break;
	}

	if (pjTypeNew[j - 1] == PT_MOVETO)
	{
	    i--; j--;			// restart the next figure from moveto
	    if (j - jStart == 1)	// don't include consecutive moveto's
		j = jStart;		// ignore the first moveto
	    else
		pPolyCount[cPolyCount++] = j - jStart;	// add one poly
	}
	else if (pjTypeNew[j - 1] == PT_LINETO)
	{				// we have reached the end of path data
	    pPolyCount[cPolyCount++] = j - jStart;	// add one poly
	    break;
	}
	else if (pjTypeNew[j - 1] == (PT_LINETO | PT_CLOSEFIGURE))
	{
	    pjTypeNew[j - 1] = PT_LINETO;

	    // Insert a PT_LINETO to close the figure.

	    pjTypeNew[j] = PT_LINETO;
	    pptNew[j]    = pptNew[jStart];
	    j++;
	    pPolyCount[cPolyCount++] = j - jStart;	// add one poly
	}
	else
	{
	    ASSERTGDI(FALSE, "MF3216: DoRenderPath, unknown pjType[]");
	}
    } // while

    ASSERTGDI(j <= cptNew && cPolyCount <= cptNew,
	"MF3216: DoRenderPath, path data overrun");

    cptNew = j;

    // Check for empty path.

    if (cptNew == 0)
    {
	b = TRUE;
	goto exit_DoRenderPath;
    }

// Now we have a path data that consists of only PT_MOVETO and PT_LINETO.
// Furthermore, there is no "empty" figure, i.e. consecutive PT_MOVETO, in
// the path.  We can finally render the picture with PolyPolyline or
// PolyPolygon.

    if (mrType == EMR_STROKEPATH)
    {
// Do StrokePath.

	b = DoPolyPolyline(pLocalDC, (PPOINTL) pptNew, (PDWORD) pPolyCount,
		(DWORD) cPolyCount);
    }
    else
    {
// Do FillPath and StrokeAndFillPath.

	// If we are doing fill only, we need to select in a NULL pen.

	if (mrType == EMR_FILLPATH)
	{
	    lhpn32 = pLocalDC->lhpn32;	// remember the previous pen
	    if (!DoSelectObject(pLocalDC, ENHMETA_STOCK_OBJECT | NULL_PEN))
	    {
		ASSERTGDI(FALSE, "MF3216: DoRenderPath, DoSelectObject failed");
		goto exit_DoRenderPath;
	    }
	}

	// Do the PolyPolygon.

	b = DoPolyPolygon(pLocalDC, (PPOINTL) pptNew, (PDWORD) pPolyCount,
		(DWORD) cptNew, (DWORD) cPolyCount);

	// Restore the previous pen.

	if (mrType == EMR_FILLPATH)
	    if (!DoSelectObject(pLocalDC, lhpn32))
		ASSERTGDI(FALSE, "MF3216: DoRenderPath, DoSelectObject failed");
    }


exit_DoRenderPath:

// Since this call affects the path state and current position in the helper
// DC, we need to update the helper DC.

    switch(mrType)
    {
    case EMR_STROKEPATH:
	if (!StrokePath(pLocalDC->hdcHelper))
	    ASSERTGDI(FALSE, "MF3216: DoRenderPath, StrokePath failed");
	break;
    case EMR_FILLPATH:
	if (!FillPath(pLocalDC->hdcHelper))
	    ASSERTGDI(FALSE, "MF3216: DoRenderPath, FillPath failed");
	break;
    case EMR_STROKEANDFILLPATH:
	if (!StrokeAndFillPath(pLocalDC->hdcHelper))
	    ASSERTGDI(FALSE, "MF3216: DoRenderPath, StrokeAndFillPath failed");
	break;
    default:
	ASSERTGDI(FALSE, "MF3216: DoRenderPath, unknown mrType");
	break;
    }

    if (pbNew)
	if (LocalFree((HANDLE) pbNew))
	    RIP("MF3216: DoRendarPath, LocalFree failed\n");
    if (pb)
	if (LocalFree((HANDLE) pb))
	    RIP("MF3216: DoRendarPath, LocalFree failed\n");

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\precomp.h ===
#include "stddef.h"
#include "mf3216.h"
#include "wingdip.h"
#include "entry.h"
#include "win16api.h"
#include "..\client\mf16.h"
#include "..\client\metadef.h"
#include <math.h>
#include "handlers.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\polygons.c ===
/*****************************************************************************
 *
 * polygons - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  PolyPolygon  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyPolygon
(
PLOCALDC pLocalDC,
PPOINTL pptl,
PDWORD  pcptl,
DWORD   cptl,
DWORD   ccptl
)
{
BOOL    b;
PWORD   pcptlBuff = (PWORD) NULL;
PPOINTL pptlBuff  = (PPOINTL) NULL;
PPOINTL pptlSrc, pptlDst;
DWORD   i, cptlMax, cptlNeed, cptli;

        // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        return(PolyPolygon(pLocalDC->hdcHelper, (LPPOINT) pptl, (LPINT) pcptl, (INT) ccptl));

        // NOTE: There is a semantic between the Win32 PolyPolygon and
        // the Win16 PolyPolygon.  Win32 will close each polygon, Win16
        // will not.  As a result, we have to insert points as necessary
    // to make the polygons closed.  We cannot use multiple polygons
    // to replace a single PolyPolygon because they are different if
    // the polygons overlap and the polyfill mode is winding.

        // If there are not verrics just return TRUE.

        if (ccptl == 0)
            return(TRUE) ;

    b = FALSE;          // assume failure

    // Compute the maximum size of the temporary point array required
    // to create closed PolyPolygon in win16.

    cptlMax = cptl + ccptl;

        // Allocate a buffer for the temporary point array.

        pptlBuff = (PPOINTL) LocalAlloc(LMEM_FIXED, cptlMax * sizeof(POINTL)) ;
        if (!pptlBuff)
        {
            PUTS("MF3216: DoPolyPolygon, LocalAlloc failed\n") ;
            goto exit;
        }

        // Allocate a buffer for the new polycount array and make a copy
    // of the old array.

        pcptlBuff = (PWORD) LocalAlloc(LMEM_FIXED, ccptl * sizeof(WORD)) ;
        if (!pcptlBuff)
        {
            PUTS("MF3216: DoPolyPolygon, LocalAlloc failed\n") ;
            goto exit;
        }

    for (i = 0; i < ccptl; i++)
        pcptlBuff[i] = (WORD) pcptl[i];

    // Insert the points and update the polycount as necessary.

    pptlDst = pptlBuff;
    pptlSrc = pptl;
    cptlNeed = cptl;
    for (i = 0; i < ccptl; i++)
    {
        cptli = pcptl[i];

        if (cptli < 2)
        goto exit;

        RtlCopyMemory(pptlDst, pptlSrc, cptli * sizeof(POINTL)) ;
        if (pptlDst[0].x != pptlDst[cptli - 1].x
         || pptlDst[0].y != pptlDst[cptli - 1].y)
        {
        pptlDst[cptli] = pptlDst[0];
        pptlDst++;
        cptlNeed++;
        pcptlBuff[i]++;
        }
        pptlSrc += cptli;
        pptlDst += cptli;
    }

        // The Win16 poly record is limited to 64K points.
        // Need to check this limit.

        if (cptlNeed > (DWORD) (WORD) MAXWORD)
    {
            PUTS("MF3216: DoPolyPolygon, Too many point in poly array\n") ;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY) ;
            goto exit ;
    }

        // Do the transformations.

    if (!bXformRWorldToPPage(pLocalDC, pptlBuff, cptlNeed))
            goto exit;

        // Compress the POINTLs to POINTSs

        vCompressPoints(pptlBuff, cptlNeed) ;

        // Call the Win16 routine to emit the PolyPolygon to the metafile.

    b = bEmitWin16PolyPolygon(pLocalDC, (PPOINTS) pptlBuff,
        pcptlBuff, (WORD) cptlNeed, (WORD) ccptl);
exit:
        // Free the memory.

        if (pptlBuff)
            if (LocalFree(pptlBuff))
            ASSERTGDI(FALSE, "MF3216: DoPolyPolygon, LocalFree failed");

        if (pcptlBuff)
            if (LocalFree(pcptlBuff))
            ASSERTGDI(FALSE, "MF3216: DoPolyPolygon, LocalFree failed");

        return(b) ;
}

/***************************************************************************
 *  SetPolyFillMode  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetPolyFillMode
(
PLOCALDC  pLocalDC,
DWORD   iPolyFillMode
)
{
BOOL    b ;

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetPolyFillMode(pLocalDC, LOWORD(iPolyFillMode)) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\regions.c ===
/*****************************************************************************
 *
 * regions - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *
 * NOTES:
 *
        When there are no embedded metafiles we need to do the following:

            1]  Read the metafile data from the Win32 metafile.  This
                is done by the handler routines that in turn call these
                routines.

            2]  Translate the Win32 metafile data into Win16 metafile data.

                The region data for FillRgn, FrameRgn, InvertRgn, and PaintRgn
                are in record-time world coordinates. The region data for
                these region API's will have to be translated from record-time
                -world coordinates to play-time-page coordinates
                (XFORM_WORLD_TO_PAGE). The helperDC will be used for
                this transformation.

                The region data for SelectClipRgn and OffsetClipRgn are in
                record-time device coordinates.  The region data for these
                APIs will be translated from record-time-device coordinates
                to play-time-device coordinates.

            3]  Emit a Win16 create region metafile record.

            4]  Select the newly created region into the metafile.

            5]  Do the region function (FillRegion, FrameRegion, ...).
                This means emit a FillRegion or FrameRegion drawing order
                into the Win16 metafile.

            6]  Emit a Delete Region drawing order.

            7]  Clean up all the memory resources used.

        When there are embedded metafiles things get a little more  complicated.
        Most of the complications are hidden in PlayMetafile record processing.
        Items 1 thru 3 will be handled by the PlayMetafile Doer.

            1]  We need to keep the region from the previous DC level.
                This can be done by the helper DC (SaveDC).  We will have to
                do a GetClipRgn and a SelectMetaRgn.  A MetaRgn is the clip
                region from the previous level.

            2]  We will have to intersect any clip regions from the current
                level with any clip regions from the previous level. This can
                be done by the helper DC (using the hrgnMeta & ExtCombineRegion)

            3]  When we pop out from this level we will have to restore the
                previous saved region. This can be done by the helper DC.
                (RestoreDC).

        Since we do not know whether or not there will be an embedded metafile
        in the metafile we are currently processing we will always shadow
        the Clip Region call into the helper DC.


 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop




BOOL bEmitWin3Region(PLOCALDC pLocalDC, HRGN hrgn);

#define MIN_RGN_COORD16 -30000
#define MAX_RGN_COORD16  30000

/***************************************************************************
 * DoDrawRgn
 *
 *  CR1: This routine was added as part of the handle manager change.
 *       I noticed that almost all of the Region Rendering code was
 *       the same.
 **************************************************************************/
BOOL APIENTRY DoDrawRgn
(
 PLOCALDC  pLocalDC,
 INT       ihBrush,
 INT       nWidth,
 INT       nHeight,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       mrType
)
{
BOOL    b ;
HRGN    hrgn = (HRGN) 0;
INT     ihW16Rgn = -1,
        ihW16Brush = -1;

        b = FALSE ;

        // Translate the Win32 region data from Metafile-World to
        // Referencd-Page space.
        // This is done by ExtCreateRegion's xform.  The returned region
        // is transformed.

        hrgn = ExtCreateRegion(&pLocalDC->xformRWorldToPPage, cRgnData,
        (LPRGNDATA) pRgnData);
        if (!hrgn)
        {
            RIP("MF3216: DoDrawRgn, ExtCreateRegion failed\n") ;
            goto error_exit ;
        }

        // Allocate a handle for the region.
        // This is different from a normal handle allocation, because
        // there is no region handle in Win32.  We are using one of our
        // extra slots here.

        ihW16Rgn = iGetW16ObjectHandleSlot(pLocalDC, REALIZED_REGION) ;
        if (ihW16Rgn == -1)
            goto error_exit ;

        // Emit a Win16 create region record for the region.

    if (!bEmitWin3Region(pLocalDC, hrgn))
        {
            RIP("MF3216: DoDrawRgn, bEmitWin3Region failed\n") ;
            goto error_exit ;
    }

        // Translate the W32 Brush object index to a W16 Brush object index.

    if (ihBrush)
    {
        // Make sure that the W16 object exists.  Stock brushes may not
        // have been created and iValidateHandle will take care of creating
        // them.

            ihW16Brush = iValidateHandle(pLocalDC, ihBrush) ;
            if (ihW16Brush == -1)
                goto error_exit ;
    }

        // Emit the Region Record depending upon the function type.

        switch (mrType)
        {
            case EMR_FILLRGN:
                if(ihW16Brush == -1)
                    goto error_exit;
                b = bEmitWin16FillRgn(pLocalDC,
                                      LOWORD(ihW16Rgn),
                                      LOWORD(ihW16Brush)) ;
                break ;

            case EMR_FRAMERGN:
                nWidth  = iMagnitudeXform (pLocalDC, nWidth, CX_MAG) ;
                nHeight = iMagnitudeXform (pLocalDC, nHeight, CY_MAG) ;
                if(ihW16Brush == -1)
                    goto error_exit;

                b = bEmitWin16FrameRgn(pLocalDC,
                                       LOWORD(ihW16Rgn),
                                       LOWORD(ihW16Brush),
                                       LOWORD(nWidth),
                                       LOWORD(nHeight)) ;
                break ;

            case EMR_INVERTRGN:
                b = bEmitWin16InvertRgn(pLocalDC,
                                        LOWORD(ihW16Rgn)) ;
                break ;

            case EMR_PAINTRGN:
                b = bEmitWin16PaintRgn(pLocalDC,
                                       LOWORD(ihW16Rgn)) ;
                break ;

        default:
                RIP("MF3216: DoDrawRgn, unknown type\n") ;
                break ;
        }

error_exit:
        // Delete the W16 Region Object.

        if (ihW16Rgn != -1)
        bDeleteW16Object(pLocalDC, ihW16Rgn) ;

    if (hrgn)
        DeleteObject(hrgn) ;

        return(b) ;
}


/***************************************************************************
 *  ExtSelectClipRgn  - Win32 to Win16 Metafile Converter Entry Point
 *
 * History:
 *  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
 * Wrote it.
 **************************************************************************/

BOOL WINAPI DoExtSelectClipRgn
(
 PLOCALDC  pLocalDC,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       iMode
)
{
    HANDLE hrgn;
    BOOL   bRet;
    BOOL   bNoClipRgn ;

    bNoClipRgn = bNoDCRgn(pLocalDC, DCRGN_CLIP);

    // Do it to the helper DC.

    if (cRgnData == 0)      // default clipping
    {
    ASSERTGDI(iMode == RGN_COPY, "MF3216: DoExtSelectClipRgn: bad iMode\n");

    // No work if no previous clip region.

    if (bNoClipRgn)
        return(TRUE);

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, (HRGN)0, iMode) != ERROR);
    }
    else
    {

    // If there is no initial clip region and we are going to operate
    // on the initial clip region, we have to
    // create one.  Otherwise, GDI will create some random default
    // clipping region for us!

    if (bNoClipRgn
     && (iMode == RGN_DIFF || iMode == RGN_XOR || iMode == RGN_OR))
    {
        HRGN hrgnDefault;
    
        if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
                          (int) (SHORT) MINSHORT,
                          (int) (SHORT) MAXSHORT,
                          (int) (SHORT) MAXSHORT)))
        {
        ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
            return(FALSE);
        }
    
        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
            != ERROR);
        ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");
    
        if (!DeleteObject(hrgnDefault))
        ASSERTGDI(FALSE, "MF3216: DeleteObject failed");
    
        if (!bRet)
        return(FALSE);
    }

        // Create a region from the region data passed in.

        if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, pRgnData)))
        {
            RIP("MF3216: DoExtSelectClipRgn, Create region failed\n");
            return(FALSE);
        }

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgn, iMode) != ERROR);

        ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed\n");

        if (!DeleteObject(hrgn))
            RIP("MF3216: DeleteObject failed\n");
    }

    // dump the clip region data.

    if (bRet)
    return(bDumpDCClipping(pLocalDC));
    else
        return(FALSE);
}


/***************************************************************************
 *  SetMetaRgn  - Win32 to Win16 Metafile Converter Entry Point
 *
 * History:
 *  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
 * Wrote it.
 **************************************************************************/

BOOL WINAPI DoSetMetaRgn(PLOCALDC pLocalDC)
{
    // No work if the clip region does not exist.

    if (bNoDCRgn(pLocalDC, DCRGN_CLIP))
    return(TRUE);

    // Do it to the helper DC.

    if (!SetMetaRgn(pLocalDC->hdcHelper))
        return(FALSE);

    // Dump the clip region data.

    return(bDumpDCClipping(pLocalDC));
}


/***************************************************************************
 *  OffsetClipRgn  - Win32 to Win16 Metafile Converter Entry Point
 *
 * History:
 *  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
 * Wrote it.
 **************************************************************************/

BOOL WINAPI DoOffsetClipRgn(PLOCALDC pLocalDC, INT x, INT y)
{
    POINTL aptl[2];
    BOOL   b;

    // Do it to the helper DC.

    if (!OffsetClipRgn(pLocalDC->hdcHelper, x, y))
        return(FALSE);

    // Dump region if the meta region exists.
    // We don't offset the meta region!

    if (!bNoDCRgn(pLocalDC, DCRGN_META))
    return(bDumpDCClipping(pLocalDC));

    // Translate the record-time world offsets to play-time page offsets.

    aptl[0].x = 0;
    aptl[0].y = 0;
    aptl[1].x = x;
    aptl[1].y = y;

    if (!bXformRWorldToPPage(pLocalDC, aptl, 2))
        return(FALSE);

    aptl[1].x -= aptl[0].x;
    aptl[1].y -= aptl[0].y;

    b = bEmitWin16OffsetClipRgn(pLocalDC, (SHORT) aptl[1].x, (SHORT) aptl[1].y);
    ASSERTGDI(b, "MF3216: DoOffsetClipRgn, bEmitWin16OffsetClipRgn failed\n");

    return(b) ;
}


/***************************************************************************
 *  bNoDCRgn  - Return TRUE if the dc clip region does not exist.
 *                Otherwise, return FALSE.
 *  This is TEMPORARY only.  Get gdi to provide this functionality.
 **************************************************************************/

BOOL bNoDCRgn(PLOCALDC pLocalDC, INT iType)
{
    BOOL  bRet = FALSE;     // assume the dc region exists
    HRGN  hrgnTmp;

    ASSERTGDI(iType == DCRGN_CLIP || iType == DCRGN_META,
    "MF3216: bNoDCRgn, bad iType\n");

    if (!(hrgnTmp = CreateRectRgn(0, 0, 0, 0)))
    {
    ASSERTGDI(FALSE, "MF3216: bNoDCRgn, CreateRectRgn failed\n");
        return(bRet);
    }

    switch (GetRandomRgn(pLocalDC->hdcHelper,
             hrgnTmp,
             iType == DCRGN_CLIP ? 1 : 2
            )
       )
    {
    case -1:    // error
    ASSERTGDI(FALSE, "GetRandomRgn failed");
    break;
    case 0: // no dc region
    bRet = TRUE;
    break;
    case 1: // has dc region
    break;
    }

    if (!DeleteObject(hrgnTmp))
    ASSERTGDI(FALSE, "DeleteObject failed");

    return(bRet);
}

/***************************************************************************
 *  bDumpDCClipping - Dump the DC clipping regions.
 *
 * History:
 *  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
 * Wrote it.
 **************************************************************************/

BOOL bDumpDCClipping(PLOCALDC pLocalDC)
{
BOOL      bRet            = FALSE;      // assume failure
HRGN      hrgnRDev        = (HRGN) 0;
HRGN      hrgnPPage       = (HRGN) 0;
HRGN      hrgnPPageBounds = (HRGN) 0;
LPRGNDATA lprgnRDev       = (LPRGNDATA) NULL;
LPRGNDATA lprgnPPage      = (LPRGNDATA) NULL;
DWORD     cRgnData;
INT       i;
INT       nrcl;
PRECTL    prcl;
RECTL     rclPPage;

// Since clipping region is not scalable in Win30, we do not emit
// SelectClipRgn record.  Instead, we set the clipping to the default, i.e.
// no clipping, and then emit the scalable IntersectClipRect/ExcludeClipRect
// records to exclude clipping region.  This will allow the win30 metafiles
// to be scalable.

// First, emit a default clipping region.

    // On Win3.x, the META_SELECTCLIPREGION record only works if it has
    // a NULL handle.  The Win3x metafile driver does not translate the
    // region handle at playback time!

    if (!bW16Emit1(pLocalDC, META_SELECTCLIPREGION, 0))
        goto ddcc_exit;

// Now find the clip and meta regions to be excluded from the default
// clipping region.

    if (!(hrgnRDev = CreateRectRgn(0, 0, 0, 0)))
        goto ddcc_exit;

    switch (GetRandomRgn(pLocalDC->hdcHelper, hrgnRDev, 3)) // meta and clip
    {
    case -1:    // error
    ASSERTGDI(FALSE, "GetRandomRgn failed");
        goto ddcc_exit;
    case 0: // no clip region, we are done
    bRet = TRUE;
        goto ddcc_exit;
    case 1: // has clip region
    break;
    }

    // Get the clip region data.
    // First query the size of the buffer required to hold the clip region data.

    if (!(cRgnData = GetRegionData(hrgnRDev, 0, (LPRGNDATA) NULL)))
        goto ddcc_exit;

    // Allocate the memory for the clip region data buffer.

    if (!(lprgnRDev = (LPRGNDATA) LocalAlloc(LMEM_FIXED, cRgnData)))
        goto ddcc_exit;

    // Get clip region data.

    if (GetRegionData(hrgnRDev, cRgnData, lprgnRDev) != cRgnData)
        goto ddcc_exit;

    // Create the clip region in the playtime page space.

    if (!(hrgnPPage = ExtCreateRegion(&pLocalDC->xformRDevToPPage, cRgnData, lprgnRDev)))
        goto ddcc_exit;

    // Get the bounding box for the playtime clip region in page space.

    if (GetRgnBox(hrgnPPage, (LPRECT) &rclPPage) == ERROR)
        goto ddcc_exit;

    // Bound it to 16-bit.

    rclPPage.left   = max(MIN_RGN_COORD16,rclPPage.left);
    rclPPage.top    = max(MIN_RGN_COORD16,rclPPage.top);
    rclPPage.right  = min(MAX_RGN_COORD16,rclPPage.right);
    rclPPage.bottom = min(MAX_RGN_COORD16,rclPPage.bottom);

// Set the bounding box as the bounds for the clipping.

    if (!bEmitWin16IntersectClipRect(pLocalDC,
                     (SHORT) rclPPage.left,
                     (SHORT) rclPPage.top,
                     (SHORT) rclPPage.right,
                     (SHORT) rclPPage.bottom))
    goto ddcc_exit;

    // Create the bounding region.

    if (!(hrgnPPageBounds = CreateRectRgn(rclPPage.left,
                      rclPPage.top,
                      rclPPage.right,
                      rclPPage.bottom)))
        goto ddcc_exit;

    // Exclude the regions in playtime page space.

    if (CombineRgn(hrgnPPage, hrgnPPageBounds, hrgnPPage, RGN_DIFF) == ERROR)
        goto ddcc_exit;

// Finally, exclude the rectangles from the bounding box.

    if (!(cRgnData = GetRegionData(hrgnPPage, 0, (LPRGNDATA) NULL)))
        goto ddcc_exit;

    if (!(lprgnPPage = (LPRGNDATA) LocalAlloc(LMEM_FIXED, cRgnData)))
        goto ddcc_exit;

    if (GetRegionData(hrgnPPage, cRgnData, lprgnPPage) != cRgnData)
        goto ddcc_exit;

    // Get the number of rectangles in the transformed region.

    nrcl = lprgnPPage->rdh.nCount;
    prcl = (PRECTL) lprgnPPage->Buffer;

    // Emit a series of Exclude Clip Rectangle Metafile records.

    for (i = 0 ; i < nrcl; i++)
    {
    ASSERTGDI(prcl[i].left   >= MIN_RGN_COORD16
           && prcl[i].top    >= MIN_RGN_COORD16
           && prcl[i].right  <= MAX_RGN_COORD16
           && prcl[i].bottom <= MAX_RGN_COORD16,
        "MF3216: bad coord");

        if (!bEmitWin16ExcludeClipRect(pLocalDC,
                      (SHORT) prcl[i].left,
                      (SHORT) prcl[i].top,
                      (SHORT) prcl[i].right,
                      (SHORT) prcl[i].bottom))
        goto ddcc_exit;
    }

    bRet = TRUE;            // we are golden!

// Cleanup all the resources used.

ddcc_exit:

    if (hrgnRDev)
        DeleteObject(hrgnRDev);

    if (hrgnPPage)
        DeleteObject(hrgnPPage);

    if (hrgnPPageBounds)
        DeleteObject(hrgnPPageBounds);

    if (lprgnRDev)
        LocalFree(lprgnRDev);

    if (lprgnPPage)
        LocalFree(lprgnPPage);

    return(bRet) ;
}

/***************************************************************************
 * Emit a 16-bit CreateRegion record for the given region.
 *
 * This code is copied from the 16-bit metafile driver in gdi.
 *
 **************************************************************************/

WIN3REGION w3rgnEmpty =
{
    0,              // nextInChain
    6,              // ObjType
    0x2F6,          // ObjCount
    sizeof(WIN3REGION) - sizeof(SCAN) + 2,
                    // cbRegion
    0,              // cScans
    0,              // maxScan
    {0,0,0,0},      // rcBounding
    {0,0,0,{0,0},0} // aScans[]
};

BOOL bEmitWin3Region(PLOCALDC pLocalDC, HRGN hrgn)
{
/*
 * in win2, METACREATEREGION records contained an entire region object,
 * including the full header.  this header changed in win3.
 *
 * to remain compatible, the region records will be saved with the
 * win2 header.  here we save our region with a win2 header.
 */
    PWIN3REGION lpw3rgn;
    DWORD       cbNTRgnData;
    DWORD       curRectl;
    WORD        cScans;
    WORD        maxScanEntry;
    WORD        curScanEntry;
    DWORD       cbw3data;
    PRGNDATA    lprgn;
    LPRECT      lprc;
    PSCAN       lpScan;
    BOOL    bRet;

    ASSERTGDI(hrgn, "MF3216: bEmitWin3Region, hrgn is NULL");

    // Get the NT Region Data
    cbNTRgnData = GetRegionData(hrgn, 0, NULL);
    if (cbNTRgnData == 0)
    return(FALSE);

    lprgn = (PRGNDATA) LocalAlloc(LMEM_FIXED, cbNTRgnData);
    if (!lprgn)
    return(FALSE);

    cbNTRgnData = GetRegionData(hrgn, cbNTRgnData, lprgn);
    if (cbNTRgnData == 0)
    {
        LocalFree((HANDLE) lprgn);
    return(FALSE);
    }

    // Handle the empty region.

    if (!lprgn->rdh.nCount)
    {
    bRet = bEmitWin16CreateRegion(pLocalDC, sizeof(WIN3REGION) - sizeof(SCAN), (PVOID) &w3rgnEmpty);

    LocalFree((HANDLE)lprgn);
    return(bRet);
    }

    lprc = (LPRECT)lprgn->Buffer;

    // Create the Windows 3.x equivalent

    // worst case is one scan for each rect
    cbw3data = 2*sizeof(WIN3REGION) + (WORD)lprgn->rdh.nCount*sizeof(SCAN);

    lpw3rgn = (PWIN3REGION)LocalAlloc(LMEM_FIXED, cbw3data);
    if (!lpw3rgn)
    {
        LocalFree((HANDLE) lprgn);
    return(FALSE);
    }

    // Grab the bounding rect.
    lpw3rgn->rcBounding.left   = (SHORT)lprgn->rdh.rcBound.left;
    lpw3rgn->rcBounding.right  = (SHORT)lprgn->rdh.rcBound.right;
    lpw3rgn->rcBounding.top    = (SHORT)lprgn->rdh.rcBound.top;
    lpw3rgn->rcBounding.bottom = (SHORT)lprgn->rdh.rcBound.bottom;

    cbw3data = sizeof(WIN3REGION) - sizeof(SCAN) + 2;

    // visit all the rects
    curRectl     = 0;
    cScans       = 0;
    maxScanEntry = 0;
    lpScan       = lpw3rgn->aScans;

    while(curRectl < lprgn->rdh.nCount)
    {
    LPWORD  lpXEntry;
    DWORD   cbScan;

    curScanEntry = 0;       // Current X pair in this scan

    lpScan->scnPntTop    = (WORD)lprc[curRectl].top;
    lpScan->scnPntBottom = (WORD)lprc[curRectl].bottom;

    lpXEntry = (LPWORD) lpScan->scnPntsX;

    // handle rects on this scan
    do
    {
        lpXEntry[curScanEntry + 0] = (WORD)lprc[curRectl].left;
        lpXEntry[curScanEntry + 1] = (WORD)lprc[curRectl].right;
        curScanEntry += 2;
        curRectl++;
    } while ((curRectl < lprgn->rdh.nCount)
        && (lprc[curRectl-1].top    == lprc[curRectl].top)
        && (lprc[curRectl-1].bottom == lprc[curRectl].bottom)
           );

    lpScan->scnPntCnt      = curScanEntry;
    lpXEntry[curScanEntry] = curScanEntry;  // Count also follows Xs
    cScans++;

    if (curScanEntry > maxScanEntry)
        maxScanEntry = curScanEntry;

    // account for each new scan + each X1 X2 Entry but the first
    cbScan = sizeof(SCAN)-(sizeof(WORD)*2) + (curScanEntry*sizeof(WORD));
    cbw3data += cbScan;
    lpScan = (PSCAN)(((LPBYTE)lpScan) + cbScan);
    }

    // Initialize the header
    lpw3rgn->nextInChain = 0;
    lpw3rgn->ObjType = 6;           // old Windows OBJ_RGN identifier
    lpw3rgn->ObjCount= 0x2F6;       // any non-zero number
    lpw3rgn->cbRegion = (WORD)cbw3data;   // don't count type and next
    lpw3rgn->cScans = cScans;
    lpw3rgn->maxScan = maxScanEntry;

    bRet = bEmitWin16CreateRegion(pLocalDC, cbw3data-2, (PVOID) lpw3rgn);

    if (LocalFree((HANDLE)lprgn))
    ASSERTGDI(FALSE, "bEmitWin3Region: LocalFree(lprgn) Failed\n");
    if (LocalFree((HANDLE)lpw3rgn))
    ASSERTGDI(FALSE, "bEmitWin3Region: LocalFree(lpw3rgn) Failed\n");

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\rects.c ===
/*****************************************************************************
 *
 * rects - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  Rectangle  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoRectangle
(
PLOCALDC pLocalDC,
int    x1,
int    y1,
int    x2,
int    y2
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, 0, 0, 0, 0, EMR_RECTANGLE) ;

        return(b) ;
}


/***************************************************************************
 *  RoundRect  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoRoundRect
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, 0, 0, EMR_ROUNDRECT);

        return(b) ;
}


/***************************************************************************
 *  IntersectClipRect/ExcludeClipRect - Win32 to Win16 Metafile Converter
 *  Entry Point
 **************************************************************************/

BOOL WINAPI DoClipRect
(
PLOCALDC pLocalDC,
INT xLeft,
INT yTop,
INT xRight,
INT yBottom,
INT mrType
)
{
BOOL    bNoClipRgn ;

	// Do it to the helper DC.

	// If there is no initial clip region, we have to
	// create one.  Otherwise, GDI will create some random default
	// clipping region for us!

	bNoClipRgn = bNoDCRgn(pLocalDC, DCRGN_CLIP);

	if (bNoClipRgn)
	{
	    BOOL bRet;
	    HRGN hrgnDefault;
	
	    if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
					      (int) (SHORT) MINSHORT,
					      (int) (SHORT) MAXSHORT,
					      (int) (SHORT) MAXSHORT)))
	    {
		ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
	        return(FALSE);
	    }
	
	    bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
		    != ERROR);
	    ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");
	
	    if (!DeleteObject(hrgnDefault))
		ASSERTGDI(FALSE, "MF3216: DeleteObject failed");
	
	    if (!bRet)
		return(FALSE);
	}

	switch(mrType)
	{
	case EMR_INTERSECTCLIPRECT:
	    if (!IntersectClipRect(pLocalDC->hdcHelper, xLeft, yTop, xRight, yBottom))
                return(FALSE);
	    break;

	case EMR_EXCLUDECLIPRECT:
	    if (!ExcludeClipRect(pLocalDC->hdcHelper, xLeft, yTop, xRight, yBottom))
                return(FALSE);
	    break;

	default:
	    ASSERTGDI(FALSE, "MF3216: DoClipRect, bad mrType\n");
	    break;
	}

	// Dump the clip region data.

	return(bDumpDCClipping(pLocalDC));

#if 0
// It's too much work to try to optimize it here!

	POINTL  aptl[2] ;

	// Dump the clip region data if there is a strange xform.

	if (pLocalDC->flags & STRANGE_XFORM || bNoClipRgn)
	    return(bDumpDCClipping(pLocalDC));

        // Do the simple case.
	// Are they inclusive-exclusive?!

        aptl[0].x = xLeft;
        aptl[0].y = yTop ;
        aptl[1].x = xRight;
        aptl[1].y = yBottom ;

	// Order the rectangle first, see EXFORMOBJ::bXform(ERECTL) in gre!

	if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, 2))
            return(FALSE);

        ASSERTGDI(bCoordinateOverflowTest((PLONG) aptl, 4), "MF3216: coord overflow");

	// Verify rectangle ordering and check off-by-1 error!

	if (mrType == EMR_INTERSECTCLIPRECT)
            return(bEmitWin16IntersectClipRect(pLocalDC,
                                               (SHORT) aptl[0].x,
                                               (SHORT) aptl[0].y,
                                               (SHORT) aptl[1].x,
                                               (SHORT) aptl[1].y));
	else
            return(bEmitWin16ExcludeClipRect(pLocalDC,
                                               (SHORT) aptl[0].x,
                                               (SHORT) aptl[0].y,
                                               (SHORT) aptl[1].x,
                                               (SHORT) aptl[1].y));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\text.c ===
/*****************************************************************************
 *
 * text - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

__declspec(dllimport)
ULONG
__stdcall
RtlUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

ULONG
__stdcall
RtlUnicodeToMultiByteSize(
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

DWORD GetCodePage(HDC hdc)
{
  DWORD FAR *lpSrc = UlongToPtr(GetTextCharsetInfo(hdc, 0, 0));
  CHARSETINFO csi;

  TranslateCharsetInfo(lpSrc, &csi, TCI_SRCCHARSET);

  return csi.ciACP;
}


/***************************************************************************
 *  ExtTextOut  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtTextOut
(
PLOCALDC pLocalDC,
INT     x,                  // Initial x position
INT     y,                  // Initial y position
DWORD   flOpts,             // Options
PRECTL  prcl,               // Clipping rectangle
PWCH    pwch,               // Character array
DWORD   cch,                // Character count
PLONG   pDx,                // Inter-Character spacing
DWORD   iGraphicsMode,      // Graphics mode
INT     mrType              // Either EMR_EXTTEXTOUTW (Unicode)
                //     or EMR_EXTTEXTOUTA (Ansi)
)
{
    INT     i;
    BOOL    b;
    RECTS   rcs;
    POINTL  ptlRef;
    UINT    fTextAlign;
    WORD    fsOpts;
    PCHAR   pch, pchAlloc;
    PPOINTL pptl;
    POINTL  ptlAdjust;
    BOOL    bAdjustAlignment;
    ULONG   nANSIChars;
    PCHAR   pDBCSBuffer = NULL;

    pptl     = (PPOINTL) NULL;
    fsOpts   = (WORD) flOpts;
    pchAlloc = (PCHAR) NULL;
    bAdjustAlignment = FALSE;
    b        = FALSE;       // assume failure

    ASSERTGDI(mrType == EMR_EXTTEXTOUTA || mrType == EMR_EXTTEXTOUTW,
    "MF3216: DoExtTextOut: bad record type");

// We do not handle the advanced graphics mode here except when
// we are in a path!

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

    if (pLocalDC->flags & RECORDING_PATH)
    {
    // The helper DC is in the advanced graphics mode.  We need to set
    // it to the compatible graphics mode temporarily if necessary.

    if (iGraphicsMode != GM_ADVANCED)
        SetGraphicsMode(pLocalDC->hdcHelper, iGraphicsMode);

    if (mrType == EMR_EXTTEXTOUTA)
        b = ExtTextOutA
        (
            pLocalDC->hdcHelper,
            (int)    x,
            (int)    y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPSTR)  pwch,
            (int)    cch,
            (LPINT)  pDx
        );
    else
        b = ExtTextOutW
        (
            pLocalDC->hdcHelper,
            (int)    x,
            (int)    y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPWSTR) pwch,
            (int)    cch,
            (LPINT)  pDx
        );

    // Restore the graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
        SetGraphicsMode(pLocalDC->hdcHelper, GM_ADVANCED);

    return(b);
    }

// If the string uses the current position, make sure that the metafile
// has the same current position as that of the helper DC.

    fTextAlign = GetTextAlign(pLocalDC->hdcHelper);

    if (fTextAlign & TA_UPDATECP)
    {
    POINT   ptCP;

    // Update the current position in the converted metafile if
    // it is different from that of the helper DC.  See notes
    // in DoMoveTo().

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        goto exit_DoExtTextOut;

    // Make sure that the converted metafile has the same CP as the
    // helper DC.

    if (!bValidateMetaFileCP(pLocalDC, ptCP.x, ptCP.y))
        goto exit_DoExtTextOut;

    // Initialize the XY start position.

    x = ptCP.x;
    y = ptCP.y;
    }

// Transform the XY start position.

    ptlRef.x = x;
    ptlRef.y = y;

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &ptlRef, 1))
    goto exit_DoExtTextOut;

// If we have an opaque/clipping rectangle, transform it.
// If we have a strange transform, we will do the rectangle at this time.

    if (fsOpts & (ETO_OPAQUE | ETO_CLIPPED))
    {
    RECTL rcl;

    rcl = *prcl ;

    if (!(pLocalDC->flags & STRANGE_XFORM))
    {
        if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &rcl, 2))
        goto exit_DoExtTextOut;

        // The overflow test has been done in the xform.

        rcs.left   = (SHORT) rcl.left;
        rcs.top    = (SHORT) rcl.top;
        rcs.right  = (SHORT) rcl.right;
        rcs.bottom = (SHORT) rcl.bottom;
    }
    else
    {
            if (fsOpts & ETO_OPAQUE)
            {
        LONG     lhpn32;
        LONG     lhbr32;
        INT  ihW32Br;
        LOGBRUSH lbBkColor;

        // Remember the previous pen and brush

        lhpn32 = pLocalDC->lhpn32;
        lhbr32 = pLocalDC->lhbr32;

        if (DoSelectObject(pLocalDC, ENHMETA_STOCK_OBJECT | NULL_PEN))
        {
            lbBkColor.lbStyle = BS_SOLID;
            lbBkColor.lbColor = pLocalDC->crBkColor;
            lbBkColor.lbHatch = 0;

            // Get an unused W32 object index.

            ihW32Br = pLocalDC->cW32ToW16ObjectMap - (STOCK_LAST + 1) - 1;

                    if (DoCreateBrushIndirect(pLocalDC, ihW32Br, &lbBkColor))
            {
            if (DoSelectObject(pLocalDC, ihW32Br))
            {
                if (DoRectangle(pLocalDC, rcl.left, rcl.top, rcl.right, rcl.bottom))
                fsOpts &= ~ETO_OPAQUE;

                // Restore the previous brush.

                if (!DoSelectObject(pLocalDC, lhbr32))
                ASSERTGDI(FALSE,
                 "MF3216: DoExtTextOut, DoSelectObject failed");
            }
            if (!DoDeleteObject(pLocalDC, ihW32Br))
                ASSERTGDI(FALSE,
                "MF3216: DoExtTextOut, DoDeleteObject failed");
            }

            // Restore the previous pen.

            if (!DoSelectObject(pLocalDC, lhpn32))
            ASSERTGDI(FALSE,
                "MF3216: DoExtTextOut, DoSelectObject failed");
        }

        // Check if the rectangle is drawn.

        if (fsOpts & ETO_OPAQUE)
            goto exit_DoExtTextOut;
            }

            if (fsOpts & ETO_CLIPPED)
            {
        // Save the DC so that we can restore it when we are done

        if (!DoSaveDC(pLocalDC))
            goto exit_DoExtTextOut;

                fsOpts &= ~ETO_CLIPPED;     // need to restore dc

                if (!DoClipRect(pLocalDC, rcl.left, rcl.top,
                           rcl.right, rcl.bottom, EMR_INTERSECTCLIPRECT))
            goto exit_DoExtTextOut;
            }
    }
    }

// Convert the Unicode to Ansi.

    if (mrType == EMR_EXTTEXTOUTW)
    {
        DWORD dwCP;
        
//        RtlUnicodeToMultiByteSize(&nANSIChars, pwch, cch * sizeof(WORD));

        dwCP = GetCodePage(pLocalDC->hdcHelper);
        nANSIChars = WideCharToMultiByte(dwCP, 0, pwch, cch, NULL, 0, NULL, NULL);
        
        if (nANSIChars == cch)
        {
            pch = pchAlloc = (PCHAR) LocalAlloc(LMEM_FIXED, cch * sizeof(BYTE)) ;

            if (pch == (PCHAR) NULL)
            {
                RIP("MF3216: ExtTextOut, pch LocalAlloc failed\n") ;
                goto exit_DoExtTextOut;
            }

            WideCharToMultiByte(dwCP, 0, pwch, cch, pch, cch, NULL, NULL);
        }
        else
        {
        // DBCS char string

            UINT    cjBufferSize;

            // we want DX array on a DWORD boundary

            cjBufferSize = ((nANSIChars+3)/4) * 4 * (sizeof(char) + sizeof(LONG));
            pchAlloc = pDBCSBuffer = LocalAlloc(LMEM_FIXED, cjBufferSize);

            if (pDBCSBuffer)
            {
            // start munging passed in parameters

                mrType = EMR_EXTTEXTOUTA;

                WideCharToMultiByte(dwCP, 0, pwch, cch, pDBCSBuffer, nANSIChars, NULL, NULL);

                pwch = (PWCH) pDBCSBuffer;
                pch = (PCHAR) pwch;
                cch = nANSIChars;

                if (pDx)
                {
                    ULONG ii, jj;

                    PULONG pDxTmp = (PLONG) &pDBCSBuffer[((nANSIChars+3)/4)*4];

                    for(ii=jj=0; ii < nANSIChars; ii++, jj++)
                    {
                        pDxTmp[ii] = pDx[jj];

                        if(IsDBCSLeadByteEx(dwCP, pDBCSBuffer[ii]))
                        {
                            pDxTmp[++ii] = 0;
                        }
                    }

                    pDx = pDxTmp;
                }
            }
            else
            {
                goto exit_DoExtTextOut;
            }
        }
    }
    else
    {
        pch = (PCHAR) pwch ;
    }

// Transform the intercharacter spacing information.
// Allocate an array of (cch + 1) points to transform the points in,
// and copy the points to the array.
// ATTENTION: The following will not work if the current font has a vertical default
// baseline

    pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, (cch + 1) * sizeof(POINTL));
    if (pptl == (PPOINTL) NULL)
    {
        RIP("MF3216: ExtTextOut, pptl LocalAlloc failed\n") ;
    goto exit_DoExtTextOut;
    }

    pptl[0].x = x;
    pptl[0].y = y;
    for (i = 1; i < (INT) cch + 1; i++)
    {
    pptl[i].x = pptl[i-1].x + pDx[i-1];
    pptl[i].y = y;
    }

// If there is no rotation or shear then we can
// output the characters as a string.
// On the other hand, if there is rotation or shear then we
// have to output each character independently.

    if (!(pLocalDC->flags & STRANGE_XFORM))
    {
    // Win31 does not do text alignment correctly in some transforms.
    // It performs alignment in device space but win32 does it in the
    // notional space.  As a result, a win32 TextOut call may produce
    // different output than a similar call in win31.  We cannot
    // convert this correctly since if we make it works on win31,
    // it will not work on wow!

    PSHORT pDx16;

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) pptl, (INT) cch + 1))
        goto exit_DoExtTextOut;

        // Convert it to the Dx array.  We do not need to compute it
    // as a vector since we have a scaling transform here.

    pDx16 = (PSHORT) pptl;
        for (i = 0; i < (INT) cch; i++)
            pDx16[i] = (SHORT) (pptl[i+1].x - pptl[i].x);

        // Emit the Win16 ExtTextOut metafile record.

        if (!bEmitWin16ExtTextOut(pLocalDC,
                                  (SHORT) ptlRef.x, (SHORT) ptlRef.y,
                                  fsOpts, &rcs, (PSTR) pch, (SHORT) cch,
                  (PWORD) pDx16))
        goto exit_DoExtTextOut;
    }
    else
    {
    // Deal with alignment in the world space.  We should really
    // do it in the notional space but with escapement and angles,
    // things gets complicated pretty easily.  We will try
    // our best to make it work in the common case.  We will not
    // worry about escapement and angles.

    ptlAdjust.x = 0;
        ptlAdjust.y = 0;

    switch (fTextAlign & (TA_LEFT | TA_RIGHT | TA_CENTER))
    {
    case TA_LEFT:           // default, no need to adjust x's
        break;
    case TA_RIGHT:          // shift the string by the string length
        bAdjustAlignment = TRUE;
        ptlAdjust.x = pptl[0].x - pptl[cch+1].x;
        break;
    case TA_CENTER:         // shift the string to the center
        bAdjustAlignment = TRUE;
        ptlAdjust.x = (pptl[0].x - pptl[cch+1].x) / 2;
        break;
    }

    // We will not adjust for the vertical alignment in the strange
    // transform case.  We cannot rotate the glyphs in any case.
#if 0
    switch (fTextAlign & (TA_TOP | TA_BOTTOM | TA_BASELINE))
    {
    case TA_TOP:            // default, no need to adjust y's
        break;
    case TA_BOTTOM:
        ptlAdjust.y = -logfont.height;
        break;
    case TA_BASELINE:
        ptlAdjust.y = -(logfont.height - logfont.baseline);
        break;
    }
#endif // 0

    // Adjust the character positions taking into account the alignment.

        for (i = 0; i < (INT) cch + 1; i++)
    {
        pptl[i].x += ptlAdjust.x;
        pptl[i].y += ptlAdjust.y;
    }

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) pptl, (INT) cch + 1))
        goto exit_DoExtTextOut;

    // Reset the alignment since it has been accounted for.

    if (bAdjustAlignment)
            if (!bEmitWin16SetTextAlign(pLocalDC,
                (WORD) ((fTextAlign & ~(TA_LEFT | TA_RIGHT | TA_CENTER)) | TA_LEFT)))
        goto exit_DoExtTextOut;

    // Output the characters one at a time.

        for (i = 0 ; i < (INT) cch ; i++)
        {
        ASSERTGDI(!(fsOpts & (ETO_OPAQUE | ETO_CLIPPED)),
        "mf3216: DoExtTextOut: rectangle not expected");

            if (!bEmitWin16ExtTextOut(pLocalDC,
                                      (SHORT) pptl[i].x, (SHORT) pptl[i].y,
                                      fsOpts, (PRECTS) NULL,
                                      (PSTR) &pch[i], 1, (PWORD) NULL))
            goto exit_DoExtTextOut;
        }
    }

// Everything is golden.

    b = TRUE;

// Cleanup and return.

exit_DoExtTextOut:

    // Restore the alignment.

    if (bAdjustAlignment)
        (void) bEmitWin16SetTextAlign(pLocalDC, (WORD) fTextAlign);

    if ((flOpts & ETO_CLIPPED) && !(fsOpts & ETO_CLIPPED))
        (void) DoRestoreDC(pLocalDC, -1);

    if (pchAlloc)
        LocalFree((HANDLE) pchAlloc);

    if (pptl)
        LocalFree((HANDLE) pptl);

// Update the current position if the call succeeds.

    if (b)
    {
    if (fTextAlign & TA_UPDATECP)
    {
        // Update the helper DC.

        if (mrType == EMR_EXTTEXTOUTA)
        ExtTextOutA
        (
            pLocalDC->hdcHelper,
            (int)    x,
            (int)    y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPSTR)  pwch,
            (int)    cch,
            (LPINT)  pDx
        );
        else
        ExtTextOutW
        (
            pLocalDC->hdcHelper,
            (int)    x,
            (int)    y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPWSTR) pwch,
            (int)    cch,
            (LPINT)  pDx
        );

        // Make the metafile CP invalid to force update
        // when it is used next time

            pLocalDC->ptCP.x = MAXLONG ;
            pLocalDC->ptCP.y = MAXLONG ;
    }
    }

    return(b);
}


/***************************************************************************
 *  SetTextAlign  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetTextAlign
(
PLOCALDC pLocalDC,
DWORD   fMode
)
{
BOOL    b ;

    // Do it to the helper DC.  It needs this in a path bracket
    // and to update current position correctly.

    SetTextAlign(pLocalDC->hdcHelper, (UINT) fMode);

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetTextAlign(pLocalDC, LOWORD(fMode)) ;

        return(b) ;
}


/***************************************************************************
 *  SetTextColor  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetTextColor
(
PLOCALDC pLocalDC,
COLORREF    crColor
)
{
BOOL    b ;

        pLocalDC->crTextColor = crColor ;   // used by ExtCreatePen

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetTextColor(pLocalDC, crColor) ;

        return(b) ;
}


/***************************************************************************
 *  UnicodeToAnsi - Unicode to ANSI conversion routine.
 **************************************************************************/
VOID vUnicodeToAnsi
(
    PCHAR   pAnsi,
    PWCH    pUnicode,
    DWORD   cch
)
{
    (void) RtlUnicodeToMultiByteN(pAnsi, cch, NULL, pUnicode, cch * sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\win16api.h ===
/****************************************************************************
 *
 *  Win16 Emitter Routines header file
 *
 *  Date:   7/18/91
 *  Author: Jeffrey Newman (c-jeffn)
 *
 ***************************************************************************/

#ifndef _WIN16_MF3216_
#define _WIN16_MF3216_

#pragma pack(1)

typedef struct tagRECTS {
    SHORT 	left;
    SHORT 	top;
    SHORT 	right;
    SHORT 	bottom;
} RECTS, *PRECTS;

typedef struct tagWIN16LOGPEN {
    WORD     lopnStyle;
    POINTS   lopnWidth;
    COLORREF lopnColor;
} WIN16LOGPEN, *LPWIN16LOGPEN;

typedef struct tagWIN16LOGBRUSH
  {
    WORD	lbStyle;
    DWORD	lbColor;
    SHORT       lbHatch;
  } WIN16LOGBRUSH, *LPWIN16LOGBRUSH;

typedef struct tagWIN16LOGFONT
{
    SHORT     lfHeight;
    SHORT     lfWidth;
    SHORT     lfEscapement;
    SHORT     lfOrientation;
    SHORT     lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    BYTE      lfFaceName[LF_FACESIZE];
} WIN16LOGFONT, *LPWIN16LOGFONT;

typedef struct tagMETARECORD0 {
    DWORD rdSize;
    WORD  rdFunction;
} METARECORD0;

// Define METARECORD1 through METARECORD9.

#define METARECORD_(n)				\
	typedef struct tagMETARECORD##n {	\
	    DWORD rdSize;			\
	    WORD  rdFunction;			\
	    WORD  rdParm[n];			\
	} METARECORD##n

METARECORD_(1);
METARECORD_(2);
METARECORD_(3);
METARECORD_(4);
METARECORD_(5);
METARECORD_(6);
METARECORD_(7);
METARECORD_(8);
METARECORD_(9);

typedef struct tagMETARECORD_CREATEFONTINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGFONT lf16;
} METARECORD_CREATEFONTINDIRECT;

typedef struct tagMETARECORD_CREATEPENINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGPEN lopn16;
} METARECORD_CREATEPENINDIRECT;

typedef struct tagMETARECORD_CREATEBRUSHINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGBRUSH lb16;
} METARECORD_CREATEBRUSHINDIRECT;

typedef struct tagMETARECORD_DIBCREATEPATTERNBRUSH {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  iType;
    WORD  iUsage;
} METARECORD_DIBCREATEPATTERNBRUSH;

typedef struct tagMETARECORD_POLY {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  cpt;
} METARECORD_POLY;

typedef struct tagMETARECORD_POLYPOLYGON {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  ccpt;
} METARECORD_POLYPOLYGON;

typedef struct tagMETARECORD_DIBSTRETCHBLT {
    DWORD rdSize;
    WORD  rdFunction;
    DWORD rop;
    SHORT cySrc;
    SHORT cxSrc;
    SHORT ySrc;
    SHORT xSrc;
    SHORT cy;
    SHORT cx;
    SHORT y;
    SHORT x;
} METARECORD_DIBSTRETCHBLT;

typedef struct tagMETARECORD_SETPALENTRIES {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  iStart;
    WORD  cEntries;
} METARECORD_SETPALENTRIES;

typedef struct tagMETARECORD_ESCAPE {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  wEscape;
    WORD  wCount;
} METARECORD_ESCAPE, *PMETARECORD_ESCAPE;

#pragma pack()

#define bEmitWin16EOF(pLocalDC)                                            \
                   bW16Emit0(pLocalDC, 0)

#define bEmitWin16RealizePalette(pLocalDC)                                 \
                   bW16Emit0(pLocalDC, META_REALIZEPALETTE)

#define bEmitWin16SaveDC(pLocalDC)                                         \
                   bW16Emit0(pLocalDC, META_SAVEDC)

#define bEmitWin16SetTextAlign(pLocalDC, wFlags)                           \
                   bW16Emit1(pLocalDC, META_SETTEXTALIGN, wFlags)

#define bEmitWin16SetStretchBltMode(pLocalDC, iStretchMode)                \
                   bW16Emit1(pLocalDC, META_SETSTRETCHBLTMODE, iStretchMode)

#define bEmitWin16SetROP2(pLocalDC, nDrawMode)                             \
                   bW16Emit1(pLocalDC, META_SETROP2, nDrawMode)

#define bEmitWin16SetPolyFillMode(pLocalDC, iPolyFillMode)                 \
                   bW16Emit1(pLocalDC, META_SETPOLYFILLMODE, iPolyFillMode)

#define bEmitWin16SetBkMode(pLocalDC, iBkMode)                             \
                   bW16Emit1(pLocalDC, META_SETBKMODE, iBkMode)

#define bEmitWin16SelectPalette(pLocalDC, ihObject)                        \
                   bW16Emit1(pLocalDC, META_SELECTPALETTE, ihObject)

#define bEmitWin16SelectObject(pLocalDC, ihObject)                         \
                   bW16Emit1(pLocalDC, META_SELECTOBJECT, ihObject)

#define bEmitWin16DeleteObject(pLocalDC, ihObject)                         \
                   bW16Emit1(pLocalDC, META_DELETEOBJECT, ihObject)

#define bEmitWin16SetMapMode(pLocalDC, iMapMode)                           \
                   bW16Emit1(pLocalDC, META_SETMAPMODE, iMapMode)

#define bEmitWin16PaintRgn(pLocalDC, ihRgn)                                \
                   bW16Emit1(pLocalDC, META_PAINTREGION, ihRgn)

#define bEmitWin16InvertRgn(pLocalDC, ihRgn)                               \
                   bW16Emit1(pLocalDC, META_INVERTREGION, ihRgn)

#define bEmitWin16RestoreDC(pLocalDC, nSavedDC)                            \
                   bW16Emit1(pLocalDC, META_RESTOREDC, nSavedDC)

#define bEmitWin16ResizePalette(pLocalDC, cEntries) 	                   \
                   bW16Emit1(pLocalDC, META_RESIZEPALETTE, cEntries)

#define bEmitWin16SetTextColor(pLocalDC, crColor)                          \
                   bW16Emit2(pLocalDC, META_SETTEXTCOLOR,                  \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16SetMapperFlags(pLocalDC, dwFlags)                        \
                   bW16Emit2(pLocalDC, META_SETMAPPERFLAGS,                \
                             HIWORD(dwFlags), LOWORD(dwFlags))

#define bEmitWin16SetBkColor(pLocalDC, crColor)                            \
                   bW16Emit2(pLocalDC, META_SETBKCOLOR,                    \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16SetWindowOrg(pLocalDC, x, y)                             \
                   bW16Emit2(pLocalDC, META_SETWINDOWORG, x, y)

#define bEmitWin16SetWindowExt(pLocalDC, x, y)                             \
                   bW16Emit2(pLocalDC, META_SETWINDOWEXT, x, y)

#define bEmitWin16SetViewportOrg(pLocalDC, x, y)                           \
                   bW16Emit2(pLocalDC, META_SETVIEWPORTORG, x, y)

#define bEmitWin16SetViewportExt(pLocalDC, x, y)                           \
                   bW16Emit2(pLocalDC, META_SETVIEWPORTEXT, x, y)

#define bEmitWin16OffsetClipRgn(pLocalDC, x, y)                            \
                   bW16Emit2(pLocalDC, META_OFFSETCLIPRGN, x, y)

#define bEmitWin16FillRgn(pLocalDC, ihRgn, ihBrush)                        \
                   bW16Emit2(pLocalDC, META_FILLREGION, ihBrush, ihRgn)

#define bEmitWin16MoveTo(pLocalDC, x, y)                                   \
                   bW16Emit2(pLocalDC, META_MOVETO, x, y)

#define bEmitWin16LineTo(pLocalDC, x, y)                                   \
                   bW16Emit2(pLocalDC, META_LINETO, x, y)

#define bEmitWin16FrameRgn(pLocalDC, ihRgn, ihBrush, nWidth, nHeight)      \
                   bW16Emit4(pLocalDC, META_FRAMEREGION,                   \
                             nWidth, nHeight, ihBrush, ihRgn)

#define bEmitWin16ExcludeClipRect(pLocalDC, xLeft, yTop, xRight, yBottom)  \
                   bW16Emit4(pLocalDC, META_EXCLUDECLIPRECT,               \
                             xLeft, yTop, xRight, yBottom)

#define bEmitWin16IntersectClipRect(pLocalDC, xLeft, yTop, xRight, yBottom)\
                   bW16Emit4(pLocalDC, META_INTERSECTCLIPRECT,             \
                             xLeft, yTop, xRight, yBottom)

#define bEmitWin16SetPixel(pLocalDC, x, y, crColor)                        \
                   bW16Emit4(pLocalDC, META_SETPIXEL, x, y,                \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16ExtFloodFill(pLocalDC, x, y, crColor, iMode)             \
                   bW16Emit5(pLocalDC, META_EXTFLOODFILL, x, y,            \
                             HIWORD(crColor), LOWORD(crColor), iMode)

#define bEmitWin16Rectangle(pLocalDC, x1, y1, x2, y2)                      \
                   bW16Emit4(pLocalDC, META_RECTANGLE, x1, y1, x2, y2)

#define bEmitWin16Ellipse(pLocalDC, x1, y1, x2, y2)                        \
                   bW16Emit4(pLocalDC, META_ELLIPSE, x1, y1, x2, y2)

#define bEmitWin16RoundRect(pLocalDC, x1, y1, x2, y2, x3, y3)              \
                   bW16Emit6(pLocalDC, META_ROUNDRECT, x1, y1, x2, y2, x3, y3)

#define bEmitWin16Arc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)            \
                   bW16Emit8(pLocalDC, META_ARC,                           \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16Chord(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)          \
                   bW16Emit8(pLocalDC, META_CHORD,                         \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16Pie(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)            \
                   bW16Emit8(pLocalDC, META_PIE,                           \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16BitBltNoSrc(pLocalDC, x, y, cx, cy, rop)		   \
                   bW16Emit9(pLocalDC, META_DIBBITBLT,                     \
                             x, y, cx, cy, 0, 0, 0, HIWORD(rop), LOWORD(rop))

BOOL bW16Emit0
(
PLOCALDC pLocalDC,
WORD     RecordID
) ;

BOOL bW16Emit1
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1
) ;

BOOL bW16Emit2
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2
) ;

BOOL bW16Emit4
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4
) ;

BOOL bW16Emit5
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5
) ;

BOOL bW16Emit6
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6
) ;

BOOL bW16Emit8
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6,
WORD     x7,
WORD     x8
) ;

BOOL bW16Emit9
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6,
WORD     x7,
WORD     x8,
WORD     x9
) ;

BOOL bEmitWin16CreateFontIndirect
(
  PLOCALDC pLocalDC,
  LPWIN16LOGFONT lpWin16LogFont
) ;

BOOL bEmitWin16Poly
(
  PLOCALDC pLocalDC,
  LPPOINTS ppt,
  SHORT    cpt,
  WORD     metaType
) ;

BOOL bEmitWin16PolyPolygon
(
  PLOCALDC pLocalDC,
  PPOINTS  ppt,
  PWORD    pcpt,
  WORD     cpt,
  WORD     ccpt
) ;

BOOL bEmitWin16StretchBlt
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  SHORT    cx,
  SHORT    cy,
  SHORT    xSrc,
  SHORT    ySrc,
  SHORT    cxSrc,
  SHORT    cySrc,
  DWORD    rop,
  PBITMAPINFO lpbmi,
  DWORD       cbbmi,
  PBYTE    lpBits,
  DWORD    cbBits
) ;

BOOL bEmitWin16ExtTextOut
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  WORD     fwOpts,
  PRECTS   prcts,
  PSTR     ach,
  SHORT    nCount,
  PWORD    lpDx
) ;

BOOL bEmitWin16CreateRegion
(
PLOCALDC pLocalDC,
DWORD    cbRgn,
PVOID    pRgn
) ;

BOOL bEmitWin16SetPaletteEntries
(
PLOCALDC        pLocalDC,
DWORD           iStart,
DWORD           cEntries,
LPPALETTEENTRY  pPalEntries
) ;

BOOL bEmitWin16CreatePalette
(
PLOCALDC     pLocalDC,
LPLOGPALETTE lpLogPal
) ;

BOOL bEmitWin16CreateBrushIndirect
(
  PLOCALDC        pLocalDC,
  LPWIN16LOGBRUSH lpLogBrush16
) ;

BOOL bEmitWin16CreateDIBPatternBrush
(
  PLOCALDC    pLocalDC,
  PBITMAPINFO pBitmapInfo,
  DWORD       cbBitmapInfo,
  PBYTE       pBits,
  DWORD       cbBits,
  WORD        iUsage,
  WORD        iType
) ;

BOOL bEmitWin16CreatePen
(
  PLOCALDC pLocalDC,
  WORD     iPenStyle,
  PPOINTS  pptsWidth,
  COLORREF crColor
) ;

BOOL bEmitWin16EscapeEnhMetaFile
(
  PLOCALDC pLocalDC,
  PMETARECORD_ESCAPE pmfeEnhMF,
  LPBYTE   lpEmfData
) ;
#endif // _WIN16_MF3216_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\xforms.c ===
/*****************************************************************************
 *
 * xforms - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *----------------------------------------------------------------------------
 *
 *   September 21, 1991
 *   Updated [20-Dec-1991]
 *
 *   Transformations in the Win32 to Win16 translator.
 *
 *   We are now supporting coordinate transformations from any
 *   map mode to any map mode.
 *
 *   Where:
 *        W    is the record-time-world to record-time-device xform.
 *             (aka metafile-world to metafile-device.)
 *        D    is the record-time device to play-time-device xform.
 *             (aka metafile-device to reference-device.)
 *        P    is the play-time-device to play-time-page xform.
 *             (aka reference-device to reference-logical (or page).)
 *
 *   W is the transformation defined by the world xform, map mode, window org,
 *   window extent, viewport org, and viewport extent in the
 *   Win32 metafile. This transform is also known as the world to
 *   device xform.
 *
 *   The normal composite xform is:
 *
 *         W D P
 *        ^ ^ ^ ^
 *        | | | +-  coordinate recorded in the win16 metafile.
 *        | | |     play-time-page coordinates (aka reference-logical)
 *        | | +---- play-time-device (reference-device) coordinates.
 *        | +------ record-time device (metafile-device) coordinates.
 *        +-------- world coordinates, recorded in Win32 metafile
 *
 *  The following comment is from Hockl's mail about transforms.
 *
 *   Message 11:
 *   From hockl Thu Dec 19 11:50:54 1991
 *   To: c-jeffn
 *   Cc: johnc
 *   Subject: Transform hints for the 32-16 converter
 *   Date: Thu Dec 19 11:46:40 1991
 *
 *   Here are some transform hints for the converter:
 *
 *   A. Issue the following records immediately following the 16-bit header
 *      record:
 *
 *      1. SetMapMode - use the given mapping mode, it is MM_ANISOTROPIC
 *         in most cases.
 *
 *      2. SetWindowOrg - use the upper left coordinates of the rclFrame.
 *         The coordinates are in the logical units of the reference DC.  So
 *         you have to convert .01mm to the reference device coordinates, then
 *         to the logical coordinates.  You can use the third transform
 *         defined in B.4 below to convert device coordinates to the logical
 *         coordinates of the reference device.  (Note the conversion formula
 *         for LPtoDP is defined as Dx = (Lx - xWO) * xVE/xWE + xVO and so on).
 *         This record is required to translate the converted picture to the
 *         origin (see comments in GetMetaFileBitsEx).
 *
 *      3. SetWindowExt - use the extents of the rclFrame.
 *      xExt = rclFrame.right - rclFrame.left;
 *      yExt = rclFrame.bottom - rclFrame.top;
 *         The extents are in the device units of the reference DC.  So
 *         you have to convert .01mm to the reference device units.
 *
 *      These three records should always be generated.  Note that
 *      SetWindowExt has no effect in all fixed mapping modes (e.g.
 *      MM_LOENGLISH and MM_TEXT) and will have no effect when the converted
 *      metafile is played.
 *
 *   B. Once you have issued the records, you need to use a xform helper DC
 *      to convert the coordinates of all drawing orders.  To do this, you
 *      need to do the following:
 *
 *      1. Create a xform helper DC.  This is a display info DC.
 *
 *      2. Call SetVirtualResolution to set the xform helper DC to that of
 *         the metafile.  Use the metafile header's szlDevice and
 *         szlMillimeters values to set the resolution.  This is to ensure
 *         that the help DC maps the logical coordinates to the device
 *         coordinates of the original metafile device.  If you reuse this
 *         helper DC in conversion, make sure you initialize the transforms
 *         using SetMapMode, ModifyWorldTransform, SetWindowOrgEx and
 *         SetViewportOrgEx.  You can use the same code in the
 *         CreateMetaFileEx function.
 *
 *      3. Once you have set up the xform helper DC, you should play all
 *         32-bit xform calls into the helper DC.  But never emit any
 *         xform records in the converter.  Everytime the xform is changed
 *         in the helper DC, you need to get the world to device xform
 *         (xformWDHelper) from the helper DC.  The xformWDHelper is used to
 *         convert the coordinates of the drawing orders subsequently.
 *         You can get it using the GetTransform(hdcHelper,XFORM_WORLD_TO_DEVICE)
 *         private API.
 *
 *      4. To convert drawing order coordinates, you pass them through three
 *         transforms.  The first is the xformWDHelper as computed above.  It
 *         converts all logical coordiates into the device coordinates of
 *         the original metafile device.  Note that this coordinates may
 *         be different from the conversion's reference device.  For example,
 *         the metafile may be created for a printer but the conversion is
 *         requested for the display.  The second transform therefore scales
 *         the coordinates from the metafile device to the reference device.
 *         The scaled coordinates are in MM_TEXT units.  So we need the third
 *         transform to convert the coordinates into the requested mapmode
 *         units.  For MM_TEXT, MM_ANISOTROPIC and MM_ISOTROPIC mapmode, this
 *         is the identity transform.  For the other mapmodes, this is a scale
 *         transform.  The scale transform maps the device units of the
 *         reference device to the logical units and can be computed using
 *         szlDevice, szlMillimeters of the reference device (not the metafile
 *         device!) and some predefined constants (to map millimeter to
 *         english, for example).  Note that in these fixed mapping modes, the
 *         y-axis goes in the opposite direction.  So make sure that the eM22
 *         component of the third transform is negative.  As you can see, the
 *         second and third transform never change in the duration of the
 *         conversion.  So you can combine them into one to optimize computation
 *         of the composite transform.  The composite transfom makes up of the
 *         three transforms and is used to convert drawing order coordinates
 *         into coordinates for the converted metafile.
 *
 *   C. To display a converted metafile in Windows 3.0, do the following before
 *      calling PlayMetaFile:
 *
 *      1. If the mapmode is MM_ANISOTROPIC, which is 99.9% of the time, call
 *         SetMapMode(MM_ANISOTROPIC), SetViewportOrigin and SetViewportExt.
 *         The viewport origin defines the upper left corner of the display area
 *         and the viewport origin defines the extent of the display area.  Both
 *         are in device units.
 *
 *      2. If the mapmode is MM_ISOTROPIC, which is strange, call
 *         SetMapMode(MM_ISOTROPIC), SetViewportOrigin and SetViewportExt.
 *         This is almost the same as C.1 above.
 *
 *      3. If the mapmode is others, the metafile has a fixed physical size
 *         and cannot be scaled easily without a lot of heck in the application.
 *         Call SetViewportOrigin to define the upper left corner of the display
 *         area.  The origin is in device coordinates.
 *
 *   I hope these steps are clear.  If you have any questions, feel free to
 *   give me a call.
 *
 *       HockL
 *
 *
 *
 ******************************************************************************/


#include "precomp.h"
#pragma hdrstop




BOOL WINAPI GetTransform(HDC hdc,DWORD iXform,LPXFORM pxform);
BOOL WINAPI SetVirtualResolution(HDC hdc,
                                   int cxDevice,
                                   int cyDevice,
                                   int cxMillimeters,
                                   int cyMillimeters);


BOOL bComputeCompositeXform(PLOCALDC pLocalDC) ;
VOID vInitRecDevToPlayDevXform(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;


/*
    [19-Dec-1991]
    A note about transformations.

    We will map into any map mode (when the converter is complete).

    We will use a helper DC to compute our transformation matrices.

    All the Win32 APIs that effect transformations or map modes
    will be sent to a helper DC.  The helper DC will return a transform
    matrix that converts from World Coordinates to Device Coordinates.
    This transformation matrix is: xformRWorldToRDev.

    xformRWorldToRDev is combined with the xformRDevToPPage matrix to produce
    the xformRWorldToPPage matrix.  All coordinates are mapped through the
    xformRWorldToPPage matrix.
*/


XFORM   xformIdentity = {(FLOAT) 1.0,
                         (FLOAT) 0.0,
                         (FLOAT) 0.0,
                         (FLOAT) 1.0,
                         (FLOAT) 0.0,
                         (FLOAT) 0.0 } ;


/****************************************************************************
 *  Initialize all the matrices.
 ****************************************************************************/

// Units per millimeter array.  It must be in the order of MM_LOMETRIC,
// MM_HIMETRIC, MM_LOENGLISH, MM_HIENGLISH, MM_TWIPS.

FLOAT aeUnitsPerMM[5] = { 10.0f, 100.0f, 3.937f, 39.37f, 56.6928f };

BOOL bInitXformMatrices(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
    // Init xformRDevToPDev.

        vInitRecDevToPlayDevXform(pLocalDC, pmf32header) ;

    // Init xformPDevToPPage and xformPPageToPDev.
    // (aka reference-device to reference-logical) transform.

        switch(pLocalDC->iMapMode)
        {
            case MM_TEXT:
            case MM_ANISOTROPIC:
            case MM_ISOTROPIC:
                pLocalDC->xformPDevToPPage = xformIdentity ;
                pLocalDC->xformPPageToPDev = xformIdentity ;
                break ;

            case MM_LOMETRIC:
            case MM_HIMETRIC:
            case MM_LOENGLISH:
            case MM_HIENGLISH:
            case MM_TWIPS:
        {
        FLOAT exUnitsPerPel;
        FLOAT eyUnitsPerPel;

        // Compute units per pixel.

        exUnitsPerPel = (FLOAT) pLocalDC->cxPlayDevMM
                  / (FLOAT) pLocalDC->cxPlayDevPels
                  * aeUnitsPerMM[pLocalDC->iMapMode - MM_LOMETRIC];
        
        eyUnitsPerPel = (FLOAT) pLocalDC->cyPlayDevMM
                  / (FLOAT) pLocalDC->cyPlayDevPels
                  * aeUnitsPerMM[pLocalDC->iMapMode - MM_LOMETRIC];

                pLocalDC->xformPDevToPPage.eM11 = exUnitsPerPel;
                pLocalDC->xformPDevToPPage.eM12 = 0.0f;
                pLocalDC->xformPDevToPPage.eM21 = 0.0f;
                pLocalDC->xformPDevToPPage.eM22 = -eyUnitsPerPel;
                pLocalDC->xformPDevToPPage.eDx  = 0.0f;
                pLocalDC->xformPDevToPPage.eDy  = 0.0f;

                pLocalDC->xformPPageToPDev.eM11 = 1.0f / exUnitsPerPel;
                pLocalDC->xformPPageToPDev.eM12 = 0.0f;
                pLocalDC->xformPPageToPDev.eM21 = 0.0f;
                pLocalDC->xformPPageToPDev.eM22 = -1.0f / eyUnitsPerPel;
                pLocalDC->xformPPageToPDev.eDx  = 0.0f;
                pLocalDC->xformPPageToPDev.eDy  = 0.0f;
        }
            break ;
        }

    // Init xformRDevToPPage.
        // This xform is used in the SelectClipRegion code.

        if (!CombineTransform(&pLocalDC->xformRDevToPPage,
                              &pLocalDC->xformRDevToPDev,
                              &pLocalDC->xformPDevToPPage))
        {
            RIP("MF3216: InitXformMatrices, CombineTransform failed\n");
            return(FALSE);
        }

        // We are going to use the helper DC to compute the
        // Record-time-World to Record-time-Device transform.

        // Set the Helper DC virtual resolution to the Metafiles
        // resolution.

        if (!SetVirtualResolution(pLocalDC->hdcHelper,
                                 (INT) pmf32header->szlDevice.cx,
                                 (INT) pmf32header->szlDevice.cy,
                                 (INT) pmf32header->szlMillimeters.cx,
                                 (INT) pmf32header->szlMillimeters.cy))
        {
            RIP("MF3216: InitXformMatrices, SetVirtualResolution failed \n") ;
            return(FALSE);
        }

        // Init other matrices.

        return(bComputeCompositeXform(pLocalDC));
}

/****************************************************************************
 *  Initialize the Record-time to Play-time scalers. (xformRDevToPDev)
 ****************************************************************************/
VOID vInitRecDevToPlayDevXform(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
FLOAT   ecxRecDevPels,
        ecyRecDevPels,
        ecxRecDevMM,
        ecyRecDevMM,
        ecxPlayDevPels,
        ecyPlayDevPels,
        ecxPlayDevMM,
        ecyPlayDevMM,
        exMillsPerPelRec,
        eyMillsPerPelRec,
        exMillsPerPelPlay,
        eyMillsPerPelPlay ;


        // Pickup the physical dimensions of the record-time
        // device, both in pels and millimeters.
        // Converts them to floats

        ecxRecDevPels = (FLOAT) pmf32header->szlDevice.cx ;
        ecyRecDevPels = (FLOAT) pmf32header->szlDevice.cy ;
        ecxRecDevMM   = (FLOAT) pmf32header->szlMillimeters.cx ;
        ecyRecDevMM   = (FLOAT) pmf32header->szlMillimeters.cy ;

        // convert the Play-time device dimensions to floats.

        ecxPlayDevPels = (FLOAT) pLocalDC->cxPlayDevPels ;
        ecyPlayDevPels = (FLOAT) pLocalDC->cyPlayDevPels ;
        ecxPlayDevMM   = (FLOAT) pLocalDC->cxPlayDevMM ;
        ecyPlayDevMM   = (FLOAT) pLocalDC->cyPlayDevMM ;

        // Calucalte the pels per millimeter for both the record-time
        // and play-time devices.

        exMillsPerPelRec = ecxRecDevMM / ecxRecDevPels ;
        eyMillsPerPelRec = ecyRecDevMM / ecyRecDevPels ;

        exMillsPerPelPlay = ecxPlayDevMM / ecxPlayDevPels ;
        eyMillsPerPelPlay = ecyPlayDevMM / ecyPlayDevPels ;

        // Init the Record-time-device to the Play-time-device transform.
        // aka  the Metafile-device to the Reference-device transform.

        pLocalDC->xformRDevToPDev.eM11 = exMillsPerPelRec / exMillsPerPelPlay ;
        pLocalDC->xformRDevToPDev.eM12 = (FLOAT) 0.0 ;
        pLocalDC->xformRDevToPDev.eDx  = (FLOAT) 0.0 ;
        pLocalDC->xformRDevToPDev.eM21 = (FLOAT) 0.0 ;
        pLocalDC->xformRDevToPDev.eM22 = eyMillsPerPelRec / eyMillsPerPelPlay ;
        pLocalDC->xformRDevToPDev.eDy  = (FLOAT) 0.0 ;

        return;
}


#if 0
/***************************************************************************
 * vInvertMatrix - Invert a matrix
 **************************************************************************/
VOID vInvertMatrix(PXFORM pxformSrc, PINVERSMATRIX pinvxfm)
{
FLOAT   eM11, eM12, eM21, eM22, eDx, eDy,
        detA ;

        // dereference the matrix elements, just to make the rest of this
        // routine more readable.

        eM11 = pxformSrc->eM11 ;
        eM12 = pxformSrc->eM12 ;
        eM21 = pxformSrc->eM21 ;
        eM22 = pxformSrc->eM22 ;
        eDx  = pxformSrc->eDx ;
        eDy  = pxformSrc->eDy ;

        // First determine the determinant of the source matrix.

        detA = (eM11 * eM22) - (eM11 * eDy) ;

        pinvxfm->a1 = eM22 / detA ;
        pinvxfm->a2 = -(eM21 / detA) ;
        pinvxfm->a3 = ((eM21 * eDy) - (eDx * eM22)) / detA ;
        pinvxfm->b1 = -(eM12 / detA) ;
        pinvxfm->b2 = eM11 / detA ;
        pinvxfm->b3 = -(((eM11 * eDy) - (eDx * eM12)) / detA) ;
        pinvxfm->c1 = (FLOAT) 0.0 ;
        pinvxfm->c2 = (FLOAT) 0.0 ;
        pinvxfm->c3 = ((eM11 * eM22) - (eM21 * eM12)) / detA ;

        // This is just for testing.

        pinvxfm->a1 = pxformSrc->eM11 ;
        pinvxfm->a2 = pxformSrc->eM12 ;
        pinvxfm->a3 = (FLOAT) 0.0 ;
        pinvxfm->b1 = pxformSrc->eM21 ;
        pinvxfm->b2 = pxformSrc->eM22 ;
        pinvxfm->b3 = (FLOAT) 0.0 ;
        pinvxfm->c1 = pxformSrc->eDx ;
        pinvxfm->c2 = pxformSrc->eDy ;
        pinvxfm->c3 = (FLOAT) 1.0 ;

        return ;

}
#endif // 0


/***************************************************************************
 * XformPDevToPPage  - Do a transform on the array of points passed in.
 *
 *                     This does the play-time (reference) device to
 *                     play-time (reference) page (logical) transformation.
 **************************************************************************/
BOOL bXformPDevToPPage(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
BOOL    b ;

        b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformPDevToPPage) ;

        return (b) ;
}


/***************************************************************************
 * XformPPageToPDev  - Do a transform on the array of points passed in.
 *
 *                     This does the play-time (reference) page (logical) to
 *                     play-time (reference) device transformation.
 **************************************************************************/
BOOL bXformPPageToPDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
BOOL    b ;

        b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformPPageToPDev) ;

        return (b) ;
}


/***************************************************************************
 * XformRWorldToRDev  - Do a transform on the array of points passed in.
 *
 *                      This does the Record-time (metafile) world to
 *                      record-time device translation.
 **************************************************************************/
BOOL bXformRWorldToRDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
BOOL    b ;

        b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRWorldToRDev) ;

        return (b) ;
}


/***************************************************************************
 * XformRDevToRWorld  - Do a transform on the array of points passed in.
 *
 *                      This does the Record-device (metafile) world to
 *                      record-time world translation.
 **************************************************************************/
BOOL bXformRDevToRWorld(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
BOOL    b ;

        b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRDevToRWorld) ;

        return (b) ;
}


/***************************************************************************
 * XformRWorldToPPage - Do a transform on the array of points passed in.
 *
 *            This is the workhorse translation routine.
 *            This translates from record-time-world (aka metafile-world)
 *            to record-time-device (aka metafile-device)  then from
 *            record-time-device (aka metafile-device) to play-time-device
 *            (aka reference-device) then from play-time-device
 *            (aka reference-device) to play-time-page (reference-logical)
 *            space.
 **************************************************************************/
BOOL bXformRWorldToPPage(PLOCALDC pLocalDC, PPOINTL aptl, DWORD nCount)
{
BOOL    b ;

        b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRWorldToPPage) ;

        return (b) ;
}


/***************************************************************************
 * bXformWorkhorse - Transformation Workhorse.
 **************************************************************************/
BOOL bXformWorkhorse(PPOINTL aptl, DWORD nCount, PXFORM pXform)
{
INT     i ;
FLOAT   x, y ;
BOOL    b ;
FLOAT   fx, fy;

        for (i = 0 ; i < (INT) nCount ; i++)
        {
            x = (FLOAT) aptl[i].x ;
            y = (FLOAT) aptl[i].y ;
            fx = (x * pXform->eM11 + y * pXform->eM21 + pXform->eDx) ;
            fy = (x * pXform->eM12 + y * pXform->eM22 + pXform->eDy) ;
            aptl[i].x = (LONG) (fx + ((fx < 0.0) ? -0.5f : 0.5f)) ;
            aptl[i].y = (LONG) (fy + ((fy < 0.0) ? -0.5f : 0.5f)) ;
        }

        // Do the coordinate overflow detection.

        b = bCoordinateOverflowTest((PLONG) aptl, nCount * 2) ;

        return (b) ;
}

/***************************************************************************
 * vXformWorkhorseFloat - Transformation Workhorse.
 **************************************************************************/
VOID vXformWorkhorseFloat(PPOINTFL aptfl, UINT nCount, PXFORM pXform)
{
UINT    i ;
FLOAT   x, y ;

        for (i = 0 ; i < nCount ; i++)
        {
            x = aptfl[i].x ;
            y = aptfl[i].y ;
            aptfl[i].x = x * pXform->eM11 + y * pXform->eM21 + pXform->eDx;
            aptfl[i].y = x * pXform->eM12 + y * pXform->eM22 + pXform->eDy;
        }
}

/*****************************************************************************
 * iMagnitudeXform - Transform the magnitude of a number from
 *                   Record-time-World to Play-time-Page coordinate space.
 *****************************************************************************/
INT iMagnitudeXform (PLOCALDC pLocalDC, INT value, INT iType)
{
PXFORM  pxform ;
INT     iRet ;

        pxform = &(pLocalDC->xformRWorldToPPage) ;

        iRet = iMagXformWorkhorse (value, pxform, iType) ;

        return (iRet) ;
}

/*****************************************************************************
 * iMagXformWorkhorse - get the magnitude component of a translated vector
 *****************************************************************************/
INT iMagXformWorkhorse (INT value, PXFORM pxform, INT iType)
{
POINTFL aptfl[2] ;
FLOAT   x1, y1, x2, y2;
double  emag ;

// Create a vector, from (0,0) to the point.

        aptfl[0].x = 0.0f ;
        aptfl[0].y = 0.0f ;

        if (iType == CX_MAG)
        {
            aptfl[1].x = (FLOAT) value ;
            aptfl[1].y = 0.0f ;
        }
        else
        {
            aptfl[1].x = 0.0f ;
            aptfl[1].y = (FLOAT) value ;
        }

    vXformWorkhorseFloat(aptfl, 2, pxform);

// Now get the magnitude

        x1 = aptfl[0].x ;
        y1 = aptfl[0].y ;
        x2 = aptfl[1].x ;
        y2 = aptfl[1].y ;

        emag = sqrt((double) ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))) ;

        return((INT) (emag + (double) 0.5f));
}


/*****************************************************************************
 * bRotationTest -
 *        return -  TRUE if there is a rotation or shear in this xform
 *                  FALSE if there is none.
 *****************************************************************************/
BOOL bRotationTest(PXFORM pxform)
{
BOOL    b ;

        if (   (pxform->eM12 != (FLOAT) 0.0)
            || (pxform->eM21 != (FLOAT) 0.0)
           )
        {
            b = TRUE ;
        }
        else
        {
            b = FALSE ;
        }

        return(b) ;
}

/***************************************************************************
 *  SetMapMode  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  All the map mode translations are done by the helper DC.
 *  The Helper DC always transforms to device, then we combine the
 *  MetafileWorldToDevice with the DeviceToPage transform.
 *  This becomes the Win32 to Win16 transform.
 *
 *  Some of the metafiles converted from Win16 to Win32 do not
 *  define a Viewport extent.  Since the Isotropic and AnIsotropic
 *  map modes are undefined if either the Viewport Extent or the Window
 *  Extent are undefined we will default the Viewport extent to the
 *  device extent in the Win32 metafile header.
 **************************************************************************/
BOOL WINAPI DoSetMapMode
(
 PLOCALDC  pLocalDC,
 DWORD   ulMapMode
)
{
BOOL    b ;


        if (!SetMapMode(pLocalDC->hdcHelper, ulMapMode))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetMapMode failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}


/***************************************************************************
 *  ScaleWindowsExtEx  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoScaleWindowExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
)
{
BOOL    b ;

        // Set the Windows extent

        if (!ScaleWindowExtEx(pLocalDC->hdcHelper,
                           Xnum, Xdenom,
                           Ynum, Ydenom,
                           (LPSIZE) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoScaleWindowExt failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  ScaleViewportExtEx  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoScaleViewportExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
)
{
BOOL    b ;

        // Set the viewport extent

        if (!ScaleViewportExtEx(pLocalDC->hdcHelper,
                           Xnum, Xdenom,
                           Ynum, Ydenom,
                           (LPSIZE) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoScaleViewportExt failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  SetViewportExtEx  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetViewportExt
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
)
{
BOOL    b ;

        // Set the viewport extent

        if (!SetViewportExtEx(pLocalDC->hdcHelper, x, y, (LPSIZE) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetViewportExt failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  SetViewportOrgEx  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetViewportOrg
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
)
{
BOOL    b ;

        // Set the viewport origin

        if (!SetViewportOrgEx(pLocalDC->hdcHelper, x, y, (LPPOINT) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetViewportOrg failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  SetWindowExtEx  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetWindowExt
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
)
{
BOOL    b ;

        // Set the window extent

        if (!SetWindowExtEx(pLocalDC->hdcHelper, x, y, (LPSIZE) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetWindowExt failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  SetWindowOrgEx  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  Since we will always record TWIPS in the Win16 metafile,
 *  we will transform the WindowOrg from the current MapMode to
 *  TWIPS. Then we will set the Dx and Dy elements of the Viewport
 *  transformation matrix.
 *
 **************************************************************************/
BOOL WINAPI DoSetWindowOrg
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
)
{
BOOL    b ;

        // Set the window origin

        if (!SetWindowOrgEx(pLocalDC->hdcHelper, x, y, (LPPOINT) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetWindowOrg failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  SetWorldTransform  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetWorldTransform
(
 PLOCALDC  pLocalDC,
 PXFORM  pxf
)
{
BOOL    b ;


        // Set the world xform in the helper DC.

        if (!SetWorldTransform(pLocalDC->hdcHelper, pxf))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetWorldTransform failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  ModifyWorldTransform  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoModifyWorldTransform
(
 PLOCALDC  pLocalDC,
 PXFORM  pxf,
 DWORD   imode
)
{
BOOL    b ;

        // Set the world xform in the helper DC.

        if (!ModifyWorldTransform(pLocalDC->hdcHelper, pxf, imode))
    {
            ASSERTGDI(FALSE, "MF3216: DoModifyWorldTransform failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}


/****************************************************************************
 * bComputeCompositeXform - Compute the composite Xforms.
 *
 * The following transforms are re-computed:
 *
 *  xformRWorldToRDev
 *  xformRDevToRWorld
 *  xformRWorldToPPage
 *
 ****************************************************************************/
BOOL bComputeCompositeXform(PLOCALDC pLocalDC)
{
BOOL    b ;

    // Recompute xformRWorldToRDev.
        // Get the record-time world to record-time device xform
        // from the helper DC

        b = GetTransform(pLocalDC->hdcHelper,
                         XFORM_WORLD_TO_DEVICE,
                         &pLocalDC->xformRWorldToRDev) ;
        if (b == FALSE)
        {
            RIP("MF3216: bComputeCompositeXform - GetTransform (RWorld to RDev) failed \n") ;
            goto error_exit ;
        }

    // Recompute xformRDevToRWorld.
        // Get the record-time-device to record-time-world xform

        b = GetTransform(pLocalDC->hdcHelper,
                         XFORM_DEVICE_TO_WORLD,
                         &pLocalDC->xformRDevToRWorld) ;
        if (b == FALSE)
        {
            RIP("MF3216: bComputeCompositeXform - GetTransform (RDev To RWorld) failed \n") ;
            goto error_exit ;
        }

    // Recompute xformRWorldToPPage.

        b = CombineTransform(&pLocalDC->xformRWorldToPPage,
                             &pLocalDC->xformRWorldToRDev,
                             &pLocalDC->xformRDevToPPage);
        if (b == FALSE)
        {
            RIP("MF3216: bComputeCompositeXform - CombineTransform failed\n");
            goto error_exit ;
        }

    // Recompute transform flags.

        if (pLocalDC->xformRWorldToRDev.eM12 != (FLOAT) 0.0
     || pLocalDC->xformRWorldToRDev.eM21 != (FLOAT) 0.0)
            pLocalDC->flags |= STRANGE_XFORM ;
        else
            pLocalDC->flags &= ~STRANGE_XFORM ;

error_exit:
        return(b) ;
}

/***************************************************************************
 *  bCoordinateOverflowTest - Test for 1 16 bit coordinate overflow
 *
 *  RETURNS:    FALSE if there is a coordinate overflow
 *              TRUE   if  there is no overflow.
 **************************************************************************/
BOOL bCoordinateOverflowTest(PLONG pCoordinates, INT nCount)
{
BOOL    b ;
INT     i, j ;

        b = TRUE ;
        for (i = 0 ; i < nCount ; i++)
        {

            j = pCoordinates[i] ;
            if (j < -32768 || j > 32767)
            {
                b = FALSE ;
                SetLastError(ERROR_ARITHMETIC_OVERFLOW);
                RIP("MF3216: bCoordinateOverflowTest, coordinate overflow\n") ;
                break ;
            }
        }

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\win16api.c ===
/****************************************************************************
 *
 *  Win16 Metafile emitter routines
 *
 *  Date:   7/19/91
 *  Author: Jeffrey Newman (c-jeffn)
 *
 ***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/****************************************************************************
 * bW16Emit0 - This is the base routine to emit a Win16 drawing order
 *             with 0 parameters.
 ***************************************************************************/
BOOL bW16Emit0
(
PLOCALDC   pLocalDC,
WORD       RecordID
)
{
BOOL	    b;
METARECORD0 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit1 - This is the base routine to emit a Win16 drawing order
 *             with 1 parameter.
 ***************************************************************************/
BOOL bW16Emit1
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1
)
{
BOOL	    b;
METARECORD1 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit2 - This is the base routine to emit a Win16 drawing order
 *             with 2 parameters.
 ***************************************************************************/
BOOL bW16Emit2
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2
)
{
BOOL	    b;
METARECORD2 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x2;
	mr.rdParm[1]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit4 - This is the base routine to emit a Win16 drawing order
 *             with 4 parameters.
 ***************************************************************************/
BOOL bW16Emit4
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4
)
{
BOOL	    b;
METARECORD4 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x4;
	mr.rdParm[1]  = x3;
	mr.rdParm[2]  = x2;
	mr.rdParm[3]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit5 - This is the base routine to emit a Win16 drawing order
 *             with 5 parameters.
 ***************************************************************************/
BOOL bW16Emit5
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5
)
{
BOOL	    b;
METARECORD5 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x5;
	mr.rdParm[1]  = x4;
	mr.rdParm[2]  = x3;
	mr.rdParm[3]  = x2;
	mr.rdParm[4]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit6 - This is the base routine to emit a Win16 drawing order
 *             with 6 parameters.
 ***************************************************************************/
BOOL bW16Emit6
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6
)
{
BOOL	    b;
METARECORD6 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x6;
	mr.rdParm[1]  = x5;
	mr.rdParm[2]  = x4;
	mr.rdParm[3]  = x3;
	mr.rdParm[4]  = x2;
	mr.rdParm[5]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit8 - This is the base routine to emit a Win16 drawing order
 *             with 8 parameters.
 ***************************************************************************/
BOOL bW16Emit8
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6,
WORD       x7,
WORD       x8
)
{
BOOL	    b;
METARECORD8 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x8;
	mr.rdParm[1]  = x7;
	mr.rdParm[2]  = x6;
	mr.rdParm[3]  = x5;
	mr.rdParm[4]  = x4;
	mr.rdParm[5]  = x3;
	mr.rdParm[6]  = x2;
	mr.rdParm[7]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit9 - This is the base routine to emit a Win16 drawing order
 *             with 9 parameters.
 ***************************************************************************/
BOOL bW16Emit9
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6,
WORD       x7,
WORD       x8,
WORD       x9
)
{
BOOL	    b;
METARECORD9 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x9;
	mr.rdParm[1]  = x8;
	mr.rdParm[2]  = x7;
	mr.rdParm[3]  = x6;
	mr.rdParm[4]  = x5;
	mr.rdParm[5]  = x4;
	mr.rdParm[6]  = x3;
	mr.rdParm[7]  = x2;
	mr.rdParm[8]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreateFontIndirect - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateFontIndirect
(
PLOCALDC       pLocalDC,
LPWIN16LOGFONT lpWin16LogFont
)
{
BOOL	b;
METARECORD_CREATEFONTINDIRECT mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = META_CREATEFONTINDIRECT;
	mr.lf16       = *lpWin16LogFont;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * Polyline/Polygon - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16Poly
(
PLOCALDC pLocalDC,
LPPOINTS ppt,
SHORT    cpt,
WORD     metaType
)
{
BOOL	b ;
WORD    nSize ;
METARECORD_POLY mr;

        // Caculate the size of the points array

        nSize = (WORD) (cpt * sizeof(POINTS));

        // Build up the header of the Win16 poly record

	mr.rdSize     = (sizeof(mr) + nSize) / sizeof(WORD);
	mr.rdFunction = metaType;
	mr.cpt        = cpt;

        // Emit the Header, then if it succeds emit the points.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            b = bEmit(pLocalDC, ppt, nSize);
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * PolyPolygon - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16PolyPolygon
(
PLOCALDC pLocalDC,
PPOINTS  ppt,
PWORD    pcpt,
WORD     cpt,
WORD     ccpt
)
{
BOOL	b ;
WORD    nSize ;
METARECORD_POLYPOLYGON mr;

        nSize  = cpt * sizeof(POINTS);
        nSize += ccpt * sizeof(WORD);
        nSize += sizeof(mr);

        // Build up the header of the Win16 polyline record

	mr.rdSize     = nSize / sizeof(WORD);
	mr.rdFunction = META_POLYPOLYGON;
	mr.ccpt       = ccpt;

        // Emit the Header, then if it succeds emit the Point counts,
        // then if it succeds emit the points.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            b = bEmit(pLocalDC, pcpt, ccpt * sizeof(WORD));
            if (b)
            {
                b = bEmit(pLocalDC, ppt, cpt * sizeof(POINTS));
            }

        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * StretchBlt - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16StretchBlt
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  SHORT    cx,
  SHORT    cy,
  SHORT    xSrc,
  SHORT    ySrc,
  SHORT    cxSrc,
  SHORT    cySrc,
  DWORD    rop,
  PBITMAPINFO lpbmi,
  DWORD       cbbmi,
  PBYTE    lpBits,
  DWORD    cbBits
)
{
BOOL	b ;
DWORD   nSize ;
METARECORD_DIBSTRETCHBLT mr;

        // Need to make real sure the plane count is 1,
        // otherwise this is not a DIB.

        if (lpbmi->bmiHeader.biPlanes != 1)
        {
            RIP("MF3216: bEmitWin16StretchBlt, Invalid biPlanes in DIB\n") ;
            return (FALSE) ;
        }

        // Create the static portion of the
        // Win 3.0 StretchBlt metafile record.

	nSize = sizeof(mr) + cbbmi + cbBits;

	mr.rdSize     = nSize / sizeof(WORD);
	mr.rdFunction = META_DIBSTRETCHBLT;
	mr.rop        = rop;
	mr.cySrc      = cySrc;
	mr.cxSrc      = cxSrc;
	mr.ySrc       = ySrc;
	mr.xSrc       = xSrc;
	mr.cy         = cy;
	mr.cx         = cx;
	mr.y          = y;
	mr.x          = x;

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
	{
	    // Emit the bitmap info

            b = bEmit(pLocalDC, lpbmi, cbbmi);
	    if (b)
	    {
	        // Emit the actual bits, if any.

                b = bEmit(pLocalDC, lpBits, cbBits);
	    }
	}

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * ExtTextOut - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16ExtTextOut
(
PLOCALDC pLocalDC,
SHORT    x,
SHORT    y,
WORD     fwOpts,
PRECTS   prcts,
PSTR     ach,
SHORT    nCount,
PWORD    lpDx
)
{
BOOL	b ;
DWORD   i, nBaseRecord ;
WORD    awRecord[11] ;


        // Calculate the size of the record

        i = ((WORD) nCount + 1) / 2 * 2;   // i = size of string in bytes
	if (lpDx)
            i += (WORD) nCount * sizeof(WORD); // add in size of Dx vector
        i += sizeof(awRecord);             // add in size of basic record
        if (!(fwOpts & (ETO_OPAQUE | ETO_CLIPPED)))
            i -= sizeof(RECTS);            // adjust for a rectangle being present
        i /= sizeof(WORD) ;                // change to word count

        // Set the record size, type,
        // x & y position, character count, and options.

        awRecord[0] = LOWORD(i) ;
        awRecord[1] = HIWORD(i) ;
        awRecord[2] = META_EXTTEXTOUT ;
        awRecord[3] = y ;
        awRecord[4] = x ;
        awRecord[5] = nCount ;
        awRecord[6] = fwOpts ;

        // Only if there is a opaque / clipping rectangle present
        // do we copy it over, other wise it is nonexistent.
        // We need to adjust the size of the Record emitted based upon
        // the existence of the opaque / clipping rectangle.

        nBaseRecord = 7 * sizeof(WORD) ;
        if (fwOpts & (ETO_OPAQUE | ETO_CLIPPED))
        {
            awRecord[7] = prcts->left ;
            awRecord[8] = prcts->top ;
            awRecord[9] = prcts->right ;
            awRecord[10] = prcts->bottom ;

            nBaseRecord += 4 * sizeof(WORD) ;
        }

        // Emit the record.

        b = bEmit(pLocalDC, awRecord, nBaseRecord) ;
        if (b)
        {
            // Emit the character string.

            i = ((WORD) nCount + 1) / 2 * 2 ;
            b = bEmit(pLocalDC, ach, i) ;
            if (b)
            {
		if (lpDx)
		{
                    // Emit the intercharacter spacing array

                    i = (WORD) (nCount * sizeof(WORD)) ;
                    b = bEmit(pLocalDC, lpDx, i) ;
                }
            }
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) awRecord) ;

        return(b) ;
}

/****************************************************************************
 * Create Region - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateRegion
(
PLOCALDC pLocalDC,
DWORD    cbRgn,
PVOID    pRgn
)
{
BOOL	    b;
METARECORD0 mr;

	mr.rdSize     = (sizeof(mr) + cbRgn) / sizeof(WORD);
	mr.rdFunction = META_CREATEREGION;

	// Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

	// Emit the region data.

	b = bEmit(pLocalDC, pRgn, cbRgn);

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * SetPaletteEntries - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16SetPaletteEntries
(
PLOCALDC       pLocalDC,
DWORD          iStart,
DWORD          cEntries,
LPPALETTEENTRY pPalEntries
)
{
BOOL	b ;
DWORD   cbPalEntries ;
METARECORD_SETPALENTRIES mr;

        cbPalEntries = cEntries * sizeof(PALETTEENTRY);

	mr.rdSize     = (sizeof(mr) + cbPalEntries) / sizeof(WORD);
	mr.rdFunction = META_SETPALENTRIES;
	mr.iStart     = (WORD) iStart;
	mr.cEntries   = (WORD) cEntries;

        // Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Emit the actual palette entries.

        b = bEmit(pLocalDC, pPalEntries, cbPalEntries) ;

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreatePalette - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreatePalette
(
PLOCALDC     pLocalDC,
LPLOGPALETTE lpLogPal
)
{
BOOL	b;
DWORD   cbLogPal;
METARECORD0 mr;

        cbLogPal  = sizeof(LOGPALETTE) - sizeof(PALETTEENTRY)
		    + lpLogPal->palNumEntries * sizeof(PALETTEENTRY) ;

	mr.rdSize     = (sizeof(mr) + cbLogPal) / sizeof(WORD);
	mr.rdFunction = META_CREATEPALETTE;

        // Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Emit the actual logpalette.

        b = bEmit(pLocalDC, lpLogPal, cbLogPal);

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return (b) ;
}

/****************************************************************************
 * CreateBrushIndirect - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateBrushIndirect
(
PLOCALDC        pLocalDC,
LPWIN16LOGBRUSH lpLogBrush16
)
{
BOOL	b;
METARECORD_CREATEBRUSHINDIRECT mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = META_CREATEBRUSHINDIRECT;
	mr.lb16       = *lpLogBrush16;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreateDIPatternBrush - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateDIBPatternBrush
(
PLOCALDC    pLocalDC,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
WORD        iUsage,
WORD        iType
)
{
BOOL	b ;
METARECORD_DIBCREATEPATTERNBRUSH mr;

	mr.rdSize     = (sizeof(mr) + cbBitmapInfo + cbBits + 1) / sizeof(WORD);
	mr.rdFunction = META_DIBCREATEPATTERNBRUSH;
	mr.iType      = iType;
	mr.iUsage     = iUsage;

// On NT, the packed DIB is dword aligned.  But on win3x, it is word aligned.
// Therefore, we emit the bitmap info followed by the bitmap bits in two
// separate stages.

        ASSERTGDI(cbBitmapInfo % 2 == 0,
	    "MF3216: bEmitWin16CreateDIBPatternBrush, bad bitmap info size");

        // Emit the static portion of the record.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b == FALSE)
            goto error_exit ;

        // Emit the bitmap info.

        b = bEmit(pLocalDC, pBitmapInfo, cbBitmapInfo) ;
        if (b == FALSE)
            goto error_exit ;

        // Emit the bitmap bits.

        b = bEmit(pLocalDC, pBits, (cbBits + 1) / sizeof(WORD) * sizeof(WORD)) ;

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

error_exit:
        return(b);
}

/****************************************************************************
 * CreatePen - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreatePen
(
PLOCALDC pLocalDC,
WORD     iPenStyle,
PPOINTS  pptsWidth,
COLORREF crColor
)
{
BOOL	b;
METARECORD_CREATEPENINDIRECT mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = META_CREATEPENINDIRECT;
	mr.lopn16.lopnStyle = iPenStyle;
	mr.lopn16.lopnWidth = *pptsWidth;
	mr.lopn16.lopnColor = crColor;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

#if 0
/****************************************************************************
 * Escape - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16Escape
(
PLOCALDC pLocalDC,
SHORT    wEscape,
SHORT    wCount,
LPSTR    lpInData,
LPSTR    lpOutData
)
{
BOOL	b ;
METARECORD_ESCAPE mr;

        NOTUSED(lpOutData) ;

        // Init the type & length field of the metafile record.
        // Then emit the header of the escape record to the Win16 metafile.

	mr.rdSize     = (sizeof(mr) + (WORD) wCount) / sizeof(WORD);
	mr.rdFunction = META_ESCAPE;
	mr.wEscape    = wEscape;
	mr.wCount     = (WORD) wCount;

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            // Emit the actual data.
            b = bEmit(pLocalDC, lpInData, (DWORD) (WORD) wCount) ;
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}
#endif // 0

/****************************************************************************
 * Escape - Win16 Metafile Emitter for enhanced metafile comment
 ***************************************************************************/
BOOL bEmitWin16EscapeEnhMetaFile
(
  PLOCALDC pLocalDC,
  PMETARECORD_ESCAPE pmfe,
  LPBYTE   lpEmfData
)
{
BOOL	b ;
PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE) pmfe;

        // Emit the header of the escape record to the Win16 metafile.

        b = bEmit(pLocalDC, (PVOID) pmfeEnhMF, sizeof(META_ESCAPE_ENHANCED_METAFILE));
        if (b)
        {
            // Emit the enhanced metafile data.
            b = bEmit(pLocalDC, lpEmfData, pmfeEnhMF->cbCurrent);
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) pmfeEnhMF);

        return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\uexts\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* This file is for debugging tools and extensions.
*
* Created: 22-Dec-1991
* Author: John Colleran
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#if defined(_X86_)
#define FASTCALL    __fastcall
#else
#define FASTCALL
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>
#include <winspool.h>
#include <limits.h>
#include <string.h>
#include <nlsconv.h>
#include <wingdip.h>

#include "winddi.h"
#include "firewall.h"
#include "ntgdistr.h"
#include "ntgdi.h"
#include "xfflags.h"
#include "hmgshare.h"
#include "local.h"
#include "metarec.h"
#include "mfrec16.h"
#include "metadef.h"
#include "font.h"

#include <excpt.h>
#include <ntstatus.h>
#include <wdbgexts.h>
#include <ntsdexts.h>
#define NOEXTAPI
#include <dbgext.h>
#include <ntcsrmsg.h>



/**************************************************************************\
 *
\**************************************************************************/

typedef struct _FLAGDEF {
    char *psz;          // description
    FLONG fl;           // flag
} FLAGDEF;


FLAGDEF afdLDC_FL[] = {
    { "LDC_SAP_CALLBACK              ",  LDC_SAP_CALLBACK             },
    { "LDC_DOC_STARTED               ",  LDC_DOC_STARTED              },
    { "LDC_PAGE_STARTED              ",  LDC_PAGE_STARTED             },
    { "LDC_CALL_STARTPAGE            ",  LDC_CALL_STARTPAGE           },
    { "LDC_NEXTBAND                  ",  LDC_NEXTBAND                 },
    { "LDC_EMPTYBAND                 ",  LDC_EMPTYBAND                },
    { "LDC_META_ARCDIR_CLOCKWISE     ",  LDC_META_ARCDIR_CLOCKWISE    },
    { "LDC_FONT_CHANGE               ",  LDC_FONT_CHANGE              },
    { "LDC_DOC_CANCELLED             ",  LDC_DOC_CANCELLED            },
    { "LDC_META_PRINT                ",  LDC_META_PRINT               },
    { "LDC_PRINT_DIRECT              ",  LDC_PRINT_DIRECT             },
    { "LDC_BANDING                   ",  LDC_BANDING                  },
    { "LDC_DOWNLOAD_FONTS            ",  LDC_DOWNLOAD_FONTS           },
    { "LDC_RESETDC_CALLED            ",  LDC_RESETDC_CALLED           },
    { "LDC_FORCE_MAPPING             ",  LDC_FORCE_MAPPING            },
    { "LDC_INFO                      ",  LDC_INFO                     },
    { "NULL                          ",  0                            },
};

FLAGDEF afdDirty[] = {
    { "DIRTY_FILL              ", DIRTY_FILL              },
    { "DIRTY_LINE              ", DIRTY_LINE              },
    { "DIRTY_TEXT              ", DIRTY_TEXT              },
    { "DIRTY_BACKGROUND        ", DIRTY_BACKGROUND        },
    { "DIRTY_CHARSET           ", DIRTY_CHARSET           },
    { "SLOW_WIDTHS             ", SLOW_WIDTHS             },
    { "DC_CACHED_TM_VALID      ", DC_CACHED_TM_VALID      },
    { "DISPLAY_DC              ", DISPLAY_DC              },
    { "DIRTY_PTLCURRENT        ", DIRTY_PTLCURRENT        },
    { "DIRTY_PTFXCURRENT       ", DIRTY_PTFXCURRENT       },
    { "DIRTY_STYLESTATE        ", DIRTY_STYLESTATE        },
    { "DC_PLAYMETAFILE         ", DC_PLAYMETAFILE         },
    { "DC_BRUSH_DIRTY          ", DC_BRUSH_DIRTY          },
    { "DC_DIBSECTION           ", DC_DIBSECTION           },
    { "DC_LAST_CLIPRGN_VALID   ", DC_LAST_CLIPRGN_VALID   },
    {                          0, 0                       }
};

FLAGDEF afdIcmMode[] = {
    { "ICM_ON                  ", ICM_ON                  },
    { "ICM_OFF                 ", ICM_OFF                 },
    {                          0, 0                       }
};

FLAGDEF afdBrushAttr[] = {
    { "ATTR_CACHED             ", ATTR_CACHED             },
    { "ATTR_TO_BE_DELETED      ", ATTR_TO_BE_DELETED      },
    { "ATTR_NEW_COLOR          ", ATTR_NEW_COLOR          },
    { "ATTR_CANT_SELECT        ", ATTR_CANT_SELECT        },
    {                          0, 0                       }
};


#define PRINT_FLAGS(ulIn,sSpace,afd)                \
{                                                   \
    ULONG ul = ulIn;                                \
    FLAGDEF *pfd;                                   \
                                                    \
    for (pfd=afd; pfd->psz; pfd++)                  \
        if (ul & pfd->fl)                           \
            Print("    %s%s\n",sSpace, pfd->psz);   \
}

char *pszMapMode(long l)
{
    char *psz;
    switch (l) {
    case MM_TEXT       : psz = "MM_TEXT"       ; break;
    case MM_LOMETRIC   : psz = "MM_LOMETRIC"   ; break;
    case MM_HIMETRIC   : psz = "MM_HIMETRIC"   ; break;
    case MM_LOENGLISH  : psz = "MM_LOENGLISH"  ; break;
    case MM_HIENGLISH  : psz = "MM_HIENGLISH"  ; break;
    case MM_TWIPS      : psz = "MM_TWIPS"      ; break;
    case MM_ISOTROPIC  : psz = "MM_ISOTROPIC"  ; break;
    case MM_ANISOTROPIC: psz = "MM_ANISOTROPIC"; break;
    default            : psz = "MM_?"          ; break;
    }
    return( psz );
}

char *pszBkMode(long l)
{
    char *psz;
    switch (l)
    {
    case TRANSPARENT:   psz = "TRANSPARENT"; break;
    case OPAQUE     :   psz = "OPAQUE"     ; break;
    default         :   psz = "BKMODE_?"   ; break;
    }
    return( psz );
}

char *pszObjType(HOBJ h)
{
    char *psz;

    switch (LO_TYPE(h))
    {
    case LO_BRUSH_TYPE     :   psz = "BRUSH     "; break;
    case LO_DC_TYPE        :   psz = "DC        "; break;
    case LO_BITMAP_TYPE    :   psz = "BITMAP    "; break;
    case LO_PALETTE_TYPE   :   psz = "PALETTE   "; break;
    case LO_FONT_TYPE      :   psz = "FONT      "; break;
    case LO_REGION_TYPE    :   psz = "REGION    "; break;
    case LO_CLIENTOBJ_TYPE :   psz = "CLIENTOBJ "; break;
    case LO_ALTDC_TYPE     :   psz = "ALTDC     "; break;
    case LO_PEN_TYPE       :   psz = "PEN       "; break;
    case LO_EXTPEN_TYPE    :   psz = "EXTPEN    "; break;
    case LO_DIBSECTION_TYPE:   psz = "DIBSECTION"; break;
    case LO_METAFILE16_TYPE:   psz = "METAFILE16"; break;
    case LO_METAFILE_TYPE  :   psz = "METAFILE  "; break;
    case LO_METADC16_TYPE  :   psz = "METADC16  "; break;
    default:
        switch (GRE_TYPE(h))
        {
        case DEF_TYPE          :   psz = "DEF          "; break;
        case DC_TYPE           :   psz = "DC           "; break;
        case DD_DIRECTDRAW_TYPE:   psz = "DD_DIRECTDRAW"; break;
        case DD_SURFACE_TYPE   :   psz = "DD_SURFACE   "; break;
        case RGN_TYPE          :   psz = "RGN          "; break;
        case SURF_TYPE         :   psz = "SURF         "; break;
        case CLIENTOBJ_TYPE    :   psz = "CLIENTOBJ    "; break;
        case PATH_TYPE         :   psz = "PATH         "; break;
        case PAL_TYPE          :   psz = "PAL          "; break;
        case ICMLCS_TYPE       :   psz = "ICMLCS       "; break;
        case LFONT_TYPE        :   psz = "LFONT        "; break;
        case RFONT_TYPE        :   psz = "RFONT        "; break;
        case PFE_TYPE          :   psz = "PFE          "; break;
        case PFT_TYPE          :   psz = "PFT          "; break;
        case ICMCXF_TYPE       :   psz = "ICMCXF       "; break;
        case ICMDLL_TYPE       :   psz = "ICMDLL       "; break;
        case BRUSH_TYPE        :   psz = "BRUSH        "; break;
        case PFF_TYPE          :   psz = "PFF          "; break;
        case CACHE_TYPE        :   psz = "CACHE        "; break;
        case SPACE_TYPE        :   psz = "SPACE        "; break;
        case META_TYPE         :   psz = "META         "; break;
        case EFSTATE_TYPE      :   psz = "EFSTATE      "; break;
        case BMFD_TYPE         :   psz = "BMFD         "; break;
        case VTFD_TYPE         :   psz = "VTFD         "; break;
        case TTFD_TYPE         :   psz = "TTFD         "; break;
        case RC_TYPE           :   psz = "RC           "; break;
        case TEMP_TYPE         :   psz = "TEMP         "; break;
        case DRVOBJ_TYPE       :   psz = "DRVOBJ       "; break;
        case DCIOBJ_TYPE       :   psz = "DCIOBJ       "; break;
        case SPOOL_TYPE        :   psz = "SPOOL        "; break;
        default                :   psz = "unknown      "; break;
        }
    }
    return( psz );
}




/******************************Public*Routine******************************\
*
* History:
*  03-Nov-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

char *gaszHelpCli[] = {
 "=======================================================================\n"
,"GDIEXTS client debugger extentions:\n"
,"-----------------------------------------------------------------------\n"
,"dh  [object handle]   -- dump HMGR entry of handle\n"
,"ddc [DC handle]       -- dump DC obj (ddc -? for more info)\n"
,"hbr [brush handle]    -- dump DC brush object\n"
,"dcfont                -- dumps all logfont/cfontsinfo\n"
,"dcache                -- dump client side object cache info\n"
,"\n"
,"use gdikdx.dll extensions for kernel debuging\n"
,"=======================================================================\n"
,NULL
};

VOID
help(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
{
    PNTSD_OUTPUT_ROUTINE Print;
    char **ppsz = gaszHelpCli;

// Avoid warnings.

    hCurrentProcess  = hCurrentProcess;
    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

    Print = lpExtensionApis->lpOutputRoutine;

// The help info is formatted as a doubly NULL-terminated array of strings.
// So, until we hit the NULL, print each string.

    while (*ppsz)
        Print(*ppsz++);
}

/******************************Public*Routine******************************\
* dumphandle
*
* Dumps the contents of a GDI client handle
*
* History:
*  23-Dec-1991 -by- John Colleran
* Wrote it.
\**************************************************************************/

void dh(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    PENTRY pent;
    DWORD  ho;
    ENTRY  ent;                            // copy of handle entry
    ULONG  ulTemp;

// eliminate warnings

    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

// set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

// do some real work

    ho = (ULONG)EvalExpression(lpArgumentString);

    GetValue(pent,"&gdi32!pGdiSharedHandleTable");

    pent += HANDLE_TO_INDEX(ho);
    move(ent,pent);

// just incase they just gave us the index

    ho = MAKE_HMGR_HANDLE(HANDLE_TO_INDEX(ho),ent.FullUnique);

// Print the entry.

    Print("--------------------------------------------------\n");
    Print("Entry from ghmgr for handle 0x%08lx, pent = %lx\n", ho,pent);

    Print("    objt        = 0x%x, %s\n" , ent.Objt,pszObjType(ho));
    Print("    puser       = 0x%x\n"     , ent.pUser);
    Print("    ObjectOwner = 0x%08lx\n"  , ent.ObjectOwner.ulObj);
    Print("    pidOwner    = 0x%x\n"     , ent.ObjectOwner.Share.Pid);
    Print("    usUnique    = 0x%hx\n"    , ent.FullUnique);

    Print("    pobj krnl   = 0x%08lx\n"  , ent.einfo.pobj);
    Print("    ShareCount  = 0x%x\n"     , ent.ObjectOwner.Share.Count);
    Print("    lock        = %s\n"       , ent.ObjectOwner.Share.Lock ? "LOCKED" : "UNLOCKED");
    Print("    fsHmgr      = 0x%hx\n"    , ent.Flags);

    Print("--------------------------------------------------\n");
}

/******************************Public*Routine******************************\
* dcfonts
*
* Dumps the contents of a GDI client handle
*
* History:
*  23-Dec-1991 -by- John Colleran
* Wrote it.
\**************************************************************************/

void dcfont(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    int i;
    PENTRY pent;
    ENTRY ent;
    ULONG pid;
    ULONG h;
    ULONG ho;

// eliminate warnings

    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

// set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

// do some real work

    GetValue(pent,"&gdi32!pGdiSharedHandleTable");
    GetValue(pid,"&gdi32!gW32PID");

    ho = (ULONG)EvalExpression(lpArgumentString);

    i = 0;

    if (ho)
        i =  HANDLE_TO_INDEX(ho);

    Print("pent = %lx, pid = %lx, lf type = %lx\n",pent,pid,LFONT_TYPE);

    for (;i < 1000/*MAX_HANDLE_COUNT*/; ++i)
    {
        move(ent,pent+i);

        if ((ent.Objt == LFONT_TYPE) &&
            ((ent.ObjectOwner.Share.Pid == pid) || ho))
        {
            LOCALFONT lf;
            h = MAKE_HMGR_HANDLE(i,ent.FullUnique);

            Print("\n");
            Print("%3lx: h = %lx, puser = %lx, owner = %lx\n",i,h,ent.pUser,ent.ObjectOwner.Share.Pid);

            if (ent.pUser)
            {
                CFONT cf;
                PCFONT pcf;

                move(lf,ent.pUser);

                for (pcf = lf.pcf; pcf; pcf = cf.pcfNext)
                {
                    move(cf,pcf);

                    Print("    pcf = 0x%lx, fl = 0x%lx, lHeight = %d\n",
                        pcf,cf.fl,cf.lHeight);

                    Print("          efm11 = 0x%08lx, efm22 = 0x%08lx, hdc = 0x%08lx\n",
                        lEfToF(cf.efM11),lEfToF(cf.efM22),cf.hdc);
                }
            }
        }

        if (ho)
            break;
    }
}

/******************************Public*Routine******************************\
*
* History:
*  10-Apr-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

void ddc(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    PENTRY pent;
    DWORD  ho;
    ENTRY  ent;                            // copy of handle entry
    ULONG  ulTemp;
    BOOL   bVerbose = FALSE;
    BOOL   bLDC     = FALSE;

    // eliminate warnings

    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

    // set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    if (*lpArgumentString == '-')
    {
        char chOpt;
        do {
            chOpt = *(++lpArgumentString);

            switch (chOpt) {
            case 'v':
            case 'V':
                bVerbose = TRUE;
                break;

            case 'L':
            case 'l':
                bLDC = TRUE;
                break;
            }

        } while ((chOpt != ' ') && (chOpt != '\0'));
    }

    // do some real work

    ho = (ULONG)EvalExpression(lpArgumentString);

    GetValue(pent,"&gdi32!pGdiSharedHandleTable");

    pent += HANDLE_TO_INDEX(ho);
    move(ent,pent);

    // now get the dcAttr

    Print("DC dump for handle %lx, pUser = %lx\n",ho,ent.pUser);

    if (ent.pUser != NULL)
    {
        DC_ATTR dca;

        move(dca,ent.pUser);

        Print("        objt         = 0x%x\n"        , ent.Objt);

        Print("        pldc         = 0x%x\n"        , dca.pvLDC);

        Print("        ulDirty_     = 0x%08x\n"       , dca.ulDirty_);
        PRINT_FLAGS(dca.ulDirty_,"        ",afdDirty);

        Print("        hbrush       = 0x%08x\n"       , dca.hbrush);
        Print("        hpen         = 0x%08x\n"       , dca.hpen);
        Print("        hfont        = 0x%08x\n"       , dca.hlfntNew);

        Print("        bkColor      = 0x%x, (0x%x)\n", dca.crBackgroundClr,dca.ulBackgroundClr);
        Print("        foreColor    = 0x%x, (0x%x)\n", dca.crForegroundClr,dca.ulForegroundClr);

        Print("        lIcmMode     = 0x%08lx\n"      ,dca.lIcmMode);
        PRINT_FLAGS(dca.lIcmMode,"        ",afdIcmMode);

        Print("        hcmXform     = 0x%08lx\n"      ,dca.hcmXform);
        Print("        hColorSpace  = 0x%08lx\n"      ,dca.hColorSpace);
        Print("        pProfile     = 0x%08lx\n"      ,dca.pProfile);
        Print("        hProfile     = 0x%08lx\n"      ,dca.hProfile);
        Print("        IcmBrush     = 0x%08lx\n"      ,dca.IcmBrushColor);
        Print("        IcmPen       = 0x%08lx\n"      ,dca.IcmPenColor);

        if (bVerbose)
        {
            ULONG ul;
            PSZ psz;

            // REGION

            Print("    REGION\n");

            if (dca.VisRectRegion.AttrFlags & ATTR_RGN_VALID)
            {
                switch  (dca.VisRectRegion.Flags)
                {
                case NULLREGION:
                    Print("        NULLREGION\n");
                    break;

                SIMPLEREGION;
                    Print("        SIMPLEREGION, 1rect\n");
                    Print("        AttrFlags    = 0x%x,%s\n",
                            dca.VisRectRegion.AttrFlags,
                            (dca.VisRectRegion.AttrFlags & ATTR_RGN_DIRTY) ? "DIRTY" : "CLEAN");

                    Print("        RECT         = 0x%x, 0x%x, 0x%x, 0x%x\n",
                            dca.VisRectRegion.Rect.left,
                            dca.VisRectRegion.Rect.top,
                            dca.VisRectRegion.Rect.right,
                            dca.VisRectRegion.Rect.bottom);
                    break;

                case COMPLEXREGION:
                    Print("        COMPLEXREGION\n");
                    break;

                default:
                    Print("        ERROR in region\n");
                    break;
                }
            }
            else
            {
                Print("        invalid cached region\n");
            }

            Print("    Other attributes\n");

            Print("        BkMode       = 0x%x, (0x%x)\n", dca.lBkMode,dca.jBkMode);
            Print("        FillMode     = 0x%x, (0x%x)\n", dca.lFillMode,dca.jFillMode);
            Print("        StretchMode  = 0x%x, (0x%x)\n", dca.lStretchBltMode,dca.jStretchBltMode);
            Print("        PtlCurrent(L)= 0x%x,0x%x\n"   , dca.ptlCurrent.x,dca.ptlCurrent.y);
            Print("        PtlCurrent(D)= 0x%x,0x%x\n"   , dca.ptfxCurrent.x,dca.ptfxCurrent.y);
            Print("        ROP2         = 0x%x\n"        , dca.jROP2);
            Print("        GraphicsMode = 0x%x\n"        , dca.iGraphicsMode);

            Print("    Text attributes\n");

            Print("        code page    = 0x%x\n"        , dca.iCS_CP);
            Print("        flTextAlign  = 0x%x\n"        , dca.flTextAlign);
            Print("        lTextAlign   = 0x%x\n"        , dca.lTextAlign );
            Print("        lTextExtra   = 0x%x\n"        , dca.lTextExtra );
            Print("        lRelAbs      = 0x%x\n"        , dca.lRelAbs    );
            Print("        lBreakExtra  = 0x%x\n"        , dca.lBreakExtra);
            Print("        cBreak       = 0x%x\n"        , dca.cBreak     );

            Print("    XFORMS\n");

            Print("        flXform      = 0x%08lx\n", dca.flXform);

            Print("        Map Mode     = %ld, %s\n", dca.iMapMode, pszMapMode(dca.iMapMode));

            Print("        Window Org   = (%8ld, %8ld)\n", dca.ptlWindowOrg.x,
                                                 dca.ptlWindowOrg.y);
            Print("        Window Ext   = (%8ld, %8ld)\n", dca.szlWindowExt.cx,
                                                 dca.szlWindowExt.cy);
            Print("        Viewport Org = (%8ld, %8ld)\n", dca.ptlViewportOrg.x,
                                                   dca.ptlViewportOrg.y);
            Print("        Viewport Ext = (%8ld, %8ld)\n", dca.szlViewportExt.cx,
                                                   dca.szlViewportExt.cy);
            Print("        Virtual Pix  = (%8ld, %8ld)\n", dca.szlVirtualDevicePixel.cx,
                                                   dca.szlVirtualDevicePixel.cy);
            Print("        Virtual mm   = (%8ld, %8ld)\n", dca.szlVirtualDeviceMm.cx,
                                                     dca.szlVirtualDeviceMm.cy);

            Print("\tMatrix\n");
            Print("\t\tM11        =  0x%08lx\n", lEfToF(dca.mxWtoD.efM11));
            Print("\t\tM12        =  0x%08lx\n", lEfToF(dca.mxWtoD.efM12));
            Print("\t\tM21        =  0x%08lx\n", lEfToF(dca.mxWtoD.efM21));
            Print("\t\tM22        =  0x%08lx\n", lEfToF(dca.mxWtoD.efM22));
            Print("\t\tDx         =  0x%08lx\n", lEfToF(dca.mxWtoD.efDx));
            Print("\t\tDy         =  0x%08lx\n", lEfToF(dca.mxWtoD.efDy));
            Print("\t\tFDx        =  0x%08lx\n", dca.mxWtoD.fxDx);
            Print("\t\tFDy        =  0x%08lx\n", dca.mxWtoD.fxDy);
        }

        if (bLDC && dca.pvLDC)
        {
            LDC ldc;
            move(ldc,dca.pvLDC);

            Print("    LDC\n");
            Print("        hdc          = 0x%08x\n"      , ldc.hdc);
            Print("        fl           = 0x%x\n"        , ldc.fl);
            PRINT_FLAGS(ldc.fl,"        ",afdLDC_FL);

            Print("        iType        = 0x%x, %s\n"    , ldc.iType, ldc.iType == LO_DC ? "LO_DC" : "LO_METADC");
            Print("        PMDC         = 0x%x\n"        , ldc.pvPMDC);
            Print("        pwszPort     = %ws\n"         , ldc.pwszPort ? ldc.pwszPort : L"NULL");
            Print("        pfnAbort     = 0x%08x\n"      , ldc.pfnAbort);
            Print("        hSpooler     = 0x%x\n"        , ldc.hSpooler);
            Print("        pdm          = 0x%x\n"        , ldc.pDevMode);
            Print("        pdm.devname  = %ws\n"         , ldc.pDevMode ? ldc.pDevMode->dmDeviceName : L"NULL");
        }
    }
}

/******************************Public*Routine******************************\
*
* History:
*  10-Apr-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

void hbrush(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    PENTRY pent;
    DWORD  ho;
    ENTRY  ent;                            // copy of handle entry
    ULONG  ulTemp;
    BOOL   bVerbose = FALSE;
    BOOL   bLDC     = FALSE;

    // eliminate warnings

    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

    // set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    if (*lpArgumentString == '-')
    {
        char chOpt;
        do {
            chOpt = *(++lpArgumentString);

            switch (chOpt) {
            case 'v':
            case 'V':
                bVerbose = TRUE;
                break;

            case 'L':
            case 'l':
                bLDC = TRUE;
                break;
            }

        } while ((chOpt != ' ') && (chOpt != '\0'));
    }

    // do some real work

    ho = (ULONG)EvalExpression(lpArgumentString);

    GetValue(pent,"&gdi32!pGdiSharedHandleTable");

    pent += HANDLE_TO_INDEX(ho);
    move(ent,pent);

    // now get the dcAttr

    Print("BRUSH dump for handle %lx, pUser = %lx\n",ho,ent.pUser);

    if (ent.pUser != NULL)
    {
        BRUSHATTR bra;

        move(bra,ent.pUser);

        Print("        objt         = 0x%x\n"        , ent.Objt);

        Print("        AttrFlags    = 0x%x, (0x%x)\n", bra.AttrFlags);
        PRINT_FLAGS(bra.AttrFlags,"        ",afdBrushAttr);

        Print("        lbColor      = 0x%x, (0x%x)\n", bra.lbColor);


    }
}

void dcache(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    PCFONT pcf;
    CFONT  cf;
    int    i;
    PGDI_SHARED_MEMORY pshare;

    // eliminate warnings

    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

    // set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    // do some real work

    GetValue(pshare,"&gdi32!pGdiSharedMemory");
    pcf = pshare->acfPublic;

    Print("Public CFONT Table, %lx\n",pcf);

    for (i = 0; i < MAX_PUBLIC_CFONT; ++i)
    {
        move(cf,pcf);

        if (cf.hf)
        {
            Print("%2d: hf = 0x%lx, pcf = 0x%lx, fl = 0x%lx, lHeight = %d\n",
                i,cf.hf,pcf,cf.fl,cf.lHeight);
        }

        cf.hf = 0;

        pcf++;
    }
}


#if 0

/******************************Public*Routine******************************\
*
* History:
*  10-Apr-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

void clidumphmgr(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{

    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    LHE  lhe;
    LHE *pLocalTable;

    ULONG aulCount[LO_LAST];
    int i;
    int c;
    for (i = 0; i < LO_LAST; ++i)
        aulCount[i] = 0;

// eliminate warnings

    hCurrentThread = hCurrentThread;
    dwCurrentPc = dwCurrentPc;
    lpArgumentString = lpArgumentString;

// set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    GetValue(c,"&gdi32!cLheCommitted");

    Print("cLheCommitted = %ld\n",c);

    GetValue(pLocalTable,"&gdi32!pLocalTable");

    for (i = 0; i < (int)c; ++i)
    {
        int iType;

        move(lhe,(pLocalTable+i));

        iType = lhe.iType & 0x0f;

        if (iType < LO_LAST)
            aulCount[iType]++;
        else
            Print("Invalid handle %lx, type = %ld\n",i,lhe.iType);
    }

    for (i = 0; i < LO_LAST; ++i)
        Print("\t%s - %ld\n",aszType[i],aulCount[i]);

    return;
}

void clidumpcache(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{

    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    LDC   ldc;
    HCACHE hc;

    PVOID apv[CACHESIZE];
    int i;
    BOOL b;
    PVOID pv;
    PLDC *gapldc;
    PHCACHE gaphcBrushes;
    PHCACHE gaphcFonts;

// eliminate warnings

    hCurrentThread = hCurrentThread;
    dwCurrentPc = dwCurrentPc;
    lpArgumentString = lpArgumentString;

// set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

// do the dc's

    Print("Cached objects - bucket: client handle, client handle, ...\n");
    Print("Cached DC's\n");

    GetAddress(gapldc,"gdi32!gapldc");

    move(apv,gapldc);

    for (i = 0; i < CACHESIZE; ++i)
    {
        b = FALSE;

        if (apv[i])
        {
            if (!b)
            {
                Print("\t%d: ",i);
                b = TRUE;
            }

            for (pv = apv[i]; pv; pv = ldc.pldcNext)
            {
                move(ldc,pv);
                Print("%x, ",ldc.lhdc);
            }
        }

        if (b)
            Print("\n");
    }

// do the brushes

    Print("Cached Brushes\n");

    GetAddress(gaphcBrushes,"gdi32!gaphcBrushes");
    move(apv,gaphcBrushes);

    for (i = 0; i < CACHESIZE; ++i)
    {
        b = FALSE;

        if (apv[i])
        {
            if (!b)
            {
                Print("\t%d: ",i);
                b = TRUE;
            }

            for (pv = apv[i]; pv; pv = hc.phcNext)
            {
                move(hc,pv);
                Print("%x, ",hc.hLocal);
            }
        }

        if (b)
            Print("\n");
    }

// do the fonts

    Print("Cached Fonts\n");

    GetAddress(gaphcFonts,"gdi32!gaphcFonts");
    move(apv,gaphcFonts);

    for (i = 0; i < CACHESIZE; ++i)
    {
        b = FALSE;

        if (apv[i])
        {
            if (!b)
            {
                Print("\t%d: ",i);
                b = TRUE;
            }

            for (pv = apv[i]; pv; pv = hc.phcNext)
            {
                move(hc,pv);
                Print("%x, ",hc.hLocal);
            }
        }

        if (b)
            Print("\n");
    }

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\acons.c ===
/****************************** Module Header ******************************\
* Module Name: acons.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains code for dealing with animated icons/cursors.
*
* History:
* 10-02-91 DarrinM      Created.
* 07-30-92 DarrinM      Unicodized.
* 11-28-94 JimA         Moved to client from server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Resource Directory format for IconEditor generated icon and cursor
 * (.ICO & .CUR) files.  All fields are shared except xHotspot and yHotspot
 * which are only valid for cursors.
 */
typedef struct _ICONFILERESDIR {    // ird
    BYTE bWidth;
    BYTE bHeight;
    BYTE bColorCount;
    BYTE bReserved;
    WORD xHotspot;
    WORD yHotspot;
    DWORD dwDIBSize;
    DWORD dwDIBOffset;
} ICONFILERESDIR;

typedef struct _HOTSPOTREC {    // hs
    WORD xHotspot;
    WORD yHotspot;
} HOTSPOTREC;

PCURSORRESOURCE ReadIconGuts(
    IN  PFILEINFO   pfi,
    IN  LPNEWHEADER pnhBase,
    IN  int         offResBase,
    OUT LPWSTR     *prt,
    IN  int         cxDesired,
    IN  int         cyDesired,
    IN  DWORD       LR_flags);

BOOL ReadTag(
    IN  PFILEINFO pfi,
    OUT PRTAG     ptag);

BOOL ReadChunk(
    IN  PFILEINFO pfi,
    IN      PRTAG ptag,
    OUT     PVOID pv);

BOOL SkipChunk(
    IN PFILEINFO pfi,
    IN PRTAG     ptag);

HICON CreateAniIcon(
    LPCWSTR pszName,
    LPWSTR rt,
    int cicur,
    DWORD *aicur,
    int cpcur,
    HCURSOR *ahcur,
    JIF jifRate,
    PJIF ajifRate,
    BOOL fPublic);

HCURSOR ReadIconFromFileMap(
    IN PFILEINFO   pfi,
    IN int         cbSize,
    IN DWORD       cxDesired,
    IN DWORD       cyDesired,
    IN DWORD       LR_flags);

HICON LoadAniIcon(
    IN PFILEINFO pfi,
    IN LPWSTR    rt,
    IN DWORD     cxDesired,
    IN DWORD     cyDesired,
    IN DWORD     LR_flags);



/***************************************************************************\
* LoadCursorFromFile (API)
*
* Called by SetSystemCursor.
*
* History:
* 08-03-92 DarrinM      Created.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, HCURSOR, WINAPI, LoadCursorFromFileW, LPCWSTR, pszFilename)
HCURSOR WINAPI LoadCursorFromFileW(
    LPCWSTR pszFilename)
{
    return(LoadImage(NULL,
                     pszFilename,
                     IMAGE_CURSOR,
                     0,
                     0,
                     LR_DEFAULTSIZE | LR_LOADFROMFILE));
}



/***********************************************************************\
* LoadCursorFromFileA
*
* Returns: hCursor
*
* 10/9/1995 Created SanfordS
\***********************************************************************/


FUNCLOG1(LOG_GENERAL, HCURSOR, WINAPI, LoadCursorFromFileA, LPCSTR, pszFilename)
HCURSOR WINAPI LoadCursorFromFileA(
    LPCSTR pszFilename)
{
    LPWSTR lpUniName;
    HCURSOR hcur;

    if (pszFilename == NULL ||
            !MBToWCS(pszFilename, -1, &lpUniName, -1, TRUE))
        return (HANDLE)NULL;

    hcur = LoadCursorFromFileW(lpUniName);

    UserLocalFree(lpUniName);

    return hcur;
}



/***********************************************************************\
* ReadFilePtr
*
* Works like ReadFile but with pointers to a mapped file buffer.
*
* Returns:
*
* 11/16/1995 Created SanfordS
\***********************************************************************/
BOOL ReadFilePtr(
    IN  PFILEINFO pfi,
    OUT LPVOID   *ppBuf,
    IN  DWORD     cb)
{
    *ppBuf = pfi->pFilePtr;
    pfi->pFilePtr += cb;
    return (pfi->pFilePtr <= pfi->pFileEnd);
}



/***********************************************************************\
* ReadFilePtrUnaligned
*
* Works like ReadFile but with pointers to a mapped file buffer.
*
* Returns:
*
* 11/16/1995 Created SanfordS
\***********************************************************************/
BOOL ReadFilePtrUnaligned(
    IN  PFILEINFO pfi,
    OUT VOID UNALIGNED **ppBuf,
    IN  DWORD     cb)
{
    *ppBuf = pfi->pFilePtr;
    pfi->pFilePtr += cb;
    return (pfi->pFilePtr <= pfi->pFileEnd);
}



/***********************************************************************\
* ReadFilePtrCopy
*
* Works even more like ReadFile in that is copies data to the given buffer.
*
* Returns:
*
* 11/16/1995 Created SanfordS
\***********************************************************************/
BOOL ReadFilePtrCopy(
    IN     PFILEINFO pfi,
    IN OUT LPVOID pBuf,
    IN     DWORD cb)
{
    if (pfi->pFilePtr + cb > pfi->pFileEnd) {
        return(FALSE);
    }
    RtlCopyMemory(pBuf, pfi->pFilePtr, cb);
    pfi->pFilePtr += cb;
    return TRUE;
}



/***************************************************************************\
* ReadTag, ReadChunk, SkipChunk
*
* Some handy functions for reading RIFF files.
*
* History:
* 10-02-91 DarrinM      Created.
* 03-25-93 Jonpa        Changed to use RIFF format instead of ASDF
\***************************************************************************/
BOOL ReadTag(
    IN  PFILEINFO pfi,
    OUT PRTAG     ptag)
{
    ptag->ckID = ptag->ckSize = 0L;  // in case we fail the read.

    return(ReadFilePtrCopy(pfi, ptag, sizeof(RTAG)));
}



BOOL ReadChunk(
    IN  PFILEINFO pfi,
    IN  PRTAG     ptag,
    OUT PVOID     pv)
{
    if (!ReadFilePtrCopy(pfi, pv, ptag->ckSize))
        return FALSE;

    /* WORD align file pointer */
    if( ptag->ckSize & 1 )
        pfi->pFilePtr++;


    if (pfi->pFilePtr <= pfi->pFileEnd) {
        return TRUE;
    } else {
        RIPMSG0(RIP_WARNING, "ReadChunk: Advanced pointer past end of file map");
        return FALSE;
    }
}



BOOL SkipChunk(
    IN PFILEINFO pfi,
    IN PRTAG     ptag)
{
    /*
     * Round ptag->ckSize up to nearest word boundary
     * to maintain alignment
     */
    pfi->pFilePtr += (ptag->ckSize + 1) & (~1);
    if (pfi->pFilePtr <= pfi->pFileEnd) {
        return TRUE;
    } else {
        RIPMSG0(RIP_WARNING, "SkipChunk: Advanced pointer past end of file map");
        return FALSE;
    }
}



/***************************************************************************\
* LoadCursorIconFromFileMap
*
* If pszName is one of the IDC_* values then we use WIN.INI to find a
* custom cursor/icon.  Otherwise, pszName points to a filename of a .ICO/.CUR
* file to be loaded.  If the file is an .ANI file containing a multiframe
* animation then LoadAniIcon is called to create an ACON.  Otherwise if
* the file is an .ANI file containing just a single frame then it is loaded
* and a normal CURSOR/ICON resource is created from it.
*
* 12-26-91 DarrinM      Wrote it.
* 03-17-93 JonPa        Changed to use RIFF format for ani-cursors
* 11/16/1995 SanfordS   Added LR_flags support
\***************************************************************************/

HANDLE LoadCursorIconFromFileMap(
    IN PFILEINFO   pfi,
    IN OUT LPWSTR *prt,
    IN DWORD       cxDesired,
    IN DWORD       cyDesired,
    IN DWORD       LR_flags,
    OUT LPBOOL     pfAni)
{
    LPNEWHEADER pnh;
    int offResBase;

    *pfAni = FALSE;
    offResBase = 0;

    /*
     * Determine if this is an .ICO/.CUR file or an .ANI file.
     */
    pnh = (LPNEWHEADER)pfi->pFileMap;
    if (*(LPDWORD)pnh == FOURCC_RIFF) {

        RTAG tag;

        /*
         * It's an ANICURSOR!
         * Seek back to beginning + 1 tag.
         */
        pfi->pFilePtr = pfi->pFileMap + sizeof(tag);

        /* check RIFF type for ACON */
        if (*(LPDWORD)pfi->pFilePtr != FOURCC_ACON) {
            return NULL;
        }
        pfi->pFilePtr += sizeof(DWORD);
        if (pfi->pFilePtr > pfi->pFileEnd) {
            return NULL;
        }

        /*
         * Ok, we have a ACON chunk.  Find the first ICON chunk and set
         * things up so it looks we've just loaded the header of a normal
         * .CUR file, then fall into the .CUR bits handling code below.
         */
        while (ReadTag(pfi, &tag)) {
            /*
             * Handle each chunk type.
             */
            if (tag.ckID == FOURCC_anih) {

                ANIHEADER anih;

                if (!ReadChunk(pfi, &tag, &anih)) {
                    return NULL;
                }

                if (!(anih.fl & AF_ICON) || (anih.cFrames == 0)) {
                    return NULL;
                }

                // If this ACON has more than one frame then go ahead
                // and create an ACON, otherwise just use the first
                // frame to create a normal ICON/CURSOR.

                if (anih.cFrames > 1) {

                    *pfAni = TRUE;
                    *prt = RT_CURSOR;
                    return(LoadAniIcon(pfi,
                                       RT_CURSOR,
                                       cxDesired,
                                       cyDesired,
                                       LR_flags));
                }

            } else if (tag.ckID == FOURCC_LIST) {
                LPDWORD pdwType = NULL;
                BOOL fOK = FALSE;
                /*
                 * If this is the fram list, then get the first icon out of it
                 */

                /* check LIST type for fram */

                if( tag.ckSize >= sizeof(DWORD) &&
                        (fOK = ReadFilePtr( pfi,
                                            &pdwType,
                                            sizeof(DWORD))) &&
                        *pdwType == FOURCC_fram) {

                    if (!ReadTag(pfi, &tag)) {
                        return NULL;
                    }

                    if (tag.ckID == FOURCC_icon) {
                        /*
                         * We've found what we're looking for.  Get current position
                         * in file to be used as the base from which the icon data
                         * offsets are offset from.
                         */
                        offResBase = (int)(pfi->pFilePtr - pfi->pFileMap);

                        /*
                         * Grab the header first, since the following code assumes
                         * it was read above.
                         */
                        ReadFilePtr(pfi, &pnh, sizeof(NEWHEADER));

                        /*
                         * Break out and let the icon loading/cursor creating code
                         * take it from here.
                         */
                        break;
                    } else {
                        SkipChunk(pfi, &tag);
                    }
                } else {
                    /*
                     * Something bad happened in the type read, if it was
                     * a file error then close and exit, otherwise just
                     * skip the rest of the chunk
                     */
                    if(!fOK) {
                        return NULL;
                    }
                    /*
                     * take the type we just read out of the tag size and
                     * skip the rest
                     */
                    tag.ckSize -= sizeof(DWORD);
                    SkipChunk(pfi, &tag);
                }
            } else {
                /*
                 * We're not interested in this chunk, skip it.
                 */
                SkipChunk(pfi, &tag);
            }
        }
    } else { // not a RIFF file.
        if ((pnh->ResType != FT_ICON) && (pnh->ResType != FT_CURSOR)) {
            return NULL;
        }
    }
    {
        PCURSORRESOURCE pcres;

        pcres = ReadIconGuts(pfi,
                             pnh,
                             offResBase,
                             prt,
                             cxDesired,
                             cyDesired,
                             LR_flags);

        if (pcres == NULL) {
            return NULL;
        }

        return ConvertDIBIcon((LPBITMAPINFOHEADER)pcres,
                              NULL,
                              pfi->pszName,
                              *prt == RT_ICON,
                              cxDesired,
                              cyDesired,
                              LR_flags);
    }
}


/***********************************************************************\
* ReadIconGuts
*
* Returns: a pointer to a locally allocated buffer extraced from the
*          given file that looks like a icon/acon resource.
*          Also returns the type of the icon (RT_ICON or RT_CURSOR)
*
*
* 8/23/1995 SanfordS   Documented
* 11/16/1995 SanfordS  Added LR_flags support
\***********************************************************************/
PCURSORRESOURCE ReadIconGuts(
    IN  PFILEINFO  pfi,
    IN  NEWHEADER *pnhBase,
    IN  int        offResBase,
    OUT LPWSTR    *prt,
    IN  int        cxDesired,
    IN  int        cyDesired,
    IN  DWORD      LR_flags)
{
    NEWHEADER *pnh;
    int i, Id;
    ICONFILERESDIR UNALIGNED *pird;
    PCURSORRESOURCE pcres;
    RESDIR UNALIGNED *prd;
    DWORD cb;
    HOTSPOTREC UNALIGNED *phs;
    LPBITMAPINFOHEADER pbih;

    /*
     * Construct a fake array of RESDIR entries using the info at the head
     * of the file.  Store the data offset in the idIcon WORD so it can be
     * returned by RtlGetIdFromDirectory.
     */
    pnh = (NEWHEADER *)UserLocalAlloc(0, sizeof(NEWHEADER) +
            (pnhBase->ResCount * (sizeof(RESDIR) + sizeof(HOTSPOTREC))));
    if (pnh == NULL)
        return NULL;

    *pnh = *pnhBase;
    prd = (RESDIR UNALIGNED *)(pnh + 1);
    phs = (HOTSPOTREC UNALIGNED *)(prd + pnhBase->ResCount);

    for (i = 0; i < (int)pnh->ResCount; i++, prd++) {
        /*
         * Read the resource directory from the icon file.
         */
        ReadFilePtrUnaligned(pfi, &pird, sizeof(ICONFILERESDIR));

        /*
         * Convert from the icon editor's resource directory format
         * to the post-RC.EXE format LookupIconIdFromDirectory expects.
         */
        prd->Icon.Width  = pird->bWidth;
        prd->Icon.Height = pird->bHeight;
        prd->Icon.reserved = 0;
        prd->BytesInRes = pird->dwDIBSize;
        prd->idIcon = (WORD)pird->dwDIBOffset;

        if (pnh->ResType == FT_ICON) {
            /*
             * 10/18/2000 - dwaynen
             *
             * For icons, this is really an ICONDIRENTRY (which has 
             * wPlanes and wBitCount fields that overlap xHotSpot and
             * yHotSpot!
             */
            prd->Icon.ColorCount = pird->bColorCount;
            prd->Planes     = pird->xHotspot;
            prd->BitCount   = pird->yHotspot;
        } else {
            /*
             * 10/18/2000 - dwaynen
             *
             * Hopefully, cursors will only have one image.  Otherwise,
             * our selection logic is gonna be screwed up because we don't
             * store the color bit depth!  I suppose we could dig out the
             * actual bitmap header and find the info there.  Consider doing
             * this if we ever want to support multi-resource cursors.
             */
            prd->Icon.ColorCount = 0;
            prd->Planes     = 0;
            prd->BitCount   = 0;
        }

        phs->xHotspot = pird->xHotspot;
        phs->yHotspot = pird->yHotspot;
        phs++;
    }

    *prt = pnhBase->ResType == FT_ICON ? RT_ICON : RT_CURSOR;
    Id = RtlGetIdFromDirectory((PBYTE)pnh,
                                *prt == RT_ICON,
                                cxDesired,
                                cyDesired,
                                LR_flags,
                                &cb);

    /*
     * Allocate for worst case (cursor).
     */
    pcres = (PCURSORRESOURCE)UserLocalAlloc(0,
            cb + FIELD_OFFSET(CURSORRESOURCE, bih));
    if (pcres == NULL) {
        goto CleanExit;
    }

    if (*prt == RT_CURSOR) {
        /*
         * Fill in hotspot info for cursors.
         */
        prd = (RESDIR UNALIGNED *)(pnh + 1);
        phs = (HOTSPOTREC UNALIGNED *)(prd + pnh->ResCount);

        for( i = 0; i < pnh->ResCount; i++ ) {
            if (prd[i].idIcon == (WORD)Id) {
                pcres->xHotspot = phs[i].xHotspot;
                pcres->yHotspot = phs[i].yHotspot;
                break;
            }
        }

        if (i == pnh->ResCount) {
            pcres->xHotspot = pird->xHotspot;
            pcres->yHotspot = pird->yHotspot;
        }
        pbih = &pcres->bih;
    } else {
        pbih = (LPBITMAPINFOHEADER)pcres;
    }

    /*
     * Read in the header information into pcres.
     */
    pfi->pFilePtr = pfi->pFileMap + offResBase + Id;
    if (!ReadFilePtrCopy(pfi, pbih, cb)) {
        UserLocalFree(pnh);
        UserLocalFree(pcres);
        return NULL;
    }


CleanExit:
    UserLocalFree(pnh);
    return pcres;
}


/***************************************************************************\
* CreateAniIcon
*
* For now, CreateAniIcon copies the jif rate table and the sequence table
* but not the CURSOR structs.  This is ok as long as this routine is
* internal only.
*
* History:
* 10-02-91 DarrinM      Created.
\***************************************************************************/

HCURSOR CreateAniIcon(
    LPCWSTR pszName,
    LPWSTR  rt,
    int     cicur,
    DWORD   *aicur,
    int     cpcur,
    HCURSOR *ahcur,
    JIF     jifRate,
    PJIF    ajifRate,
    BOOL    fPublic)
{
    HCURSOR hacon;
    CURSORDATA acon;
    DWORD cbacon;
    HCURSOR *ahcurT;             // Array of image frame pointers
    DWORD *aicurT;               // Array of frame indices (sequence table)
    PJIF ajifRateT;              // Array of time offsets
    int i;

    /*
     * Start by allocating space for the ACON structure and the ahcur and
     * ajifRate arrays.
     */
    hacon = (HCURSOR)NtUserCallOneParam(fPublic,
                                        SFI__CREATEEMPTYCURSOROBJECT);
    if (hacon == NULL)
        return NULL;

    /*
     * Save a couple UserLocalAlloc calls by allocating the memory needed for
     * the CURSOR, JIF, and SEQ arrays at once.
     */
    RtlZeroMemory(&acon, sizeof(acon));
    cbacon = (cpcur * sizeof(HCURSOR)) +
            (cicur * sizeof(JIF)) + (cicur * sizeof(DWORD));
    ahcurT = (HCURSOR *)UserLocalAlloc(HEAP_ZERO_MEMORY, cbacon);
    if (ahcurT == NULL) {
        NtUserDestroyCursor((HCURSOR)hacon, CURSOR_ALWAYSDESTROY);
        return NULL;
    }
    acon.aspcur = (PCURSOR *)ahcurT;

    /*
     * Set up work pointers
     */
    ajifRateT = (PJIF)((PBYTE)ahcurT + (cpcur * sizeof(HCURSOR)));
    aicurT = (DWORD *)((PBYTE)ajifRateT + (cicur * sizeof(JIF)));

    /*
     * Save offsets to arrays to make copying them to the server
     * easier.
     */
    acon.ajifRate = (PJIF)(cpcur * sizeof(HCURSOR));
    acon.aicur = (KPDWORD)((KPBYTE)acon.ajifRate + (cicur * sizeof(JIF)));

    acon.cpcur = cpcur;
    acon.cicur = cicur;

    acon.CURSORF_flags = CURSORF_ACON;

    /*
     * Store this information away so we can identify
     * repeated calls to LoadCursor/Icon for the same
     * resource type/id.
     */
    acon.rt = PTR_TO_ID(rt);
    acon.lpModName = szUSER32;
    acon.lpName = (LPWSTR)pszName;

    /*
     * Make a private copy of the cursor pointers and the animation rate table.
     */
    for (i = 0; i < cpcur; i++) {
        ahcurT[i] = ahcur[i];
//        ahcurT[i]->fPointer |= PTRI_ANIMATED;   // if GDI needs it

    }

    for (i = 0; i < cicur; i++) {

        /*
         * If constant rate, initialize the rate table to a single value.
         */
        if (ajifRate == NULL)
            ajifRateT[i] = jifRate;
        else
            ajifRateT[i] = ajifRate[i];

        /*
         * If no sequence table then build a unity map to the cursor table.
         */
        if (aicur == NULL)
            aicurT[i] = i;
        else
            aicurT[i] = aicur[i];
    }

    /*
     * Stuff acon data into the cursor
     */
    if (!_SetCursorIconData(hacon, &acon)) {
        NtUserDestroyCursor(hacon, CURSOR_ALWAYSDESTROY);
        hacon = NULL;
    }
    UserLocalFree(ahcurT);

    return hacon;
}


/***************************************************************************\
* ReadIconFromFileMap
*
* LATER: Error handling.
*
* History:
* 12-21-91 DarrinM      Created.
\***************************************************************************/

HCURSOR ReadIconFromFileMap(
    PFILEINFO   pfi,
    int         cbSize,   // used to seek past this chunk in case of error
    DWORD       cxDesired,
    DWORD       cyDesired,
    DWORD       LR_flags)
{
    PCURSORRESOURCE pcres;
    HCURSOR         hcur = NULL;
    LPNEWHEADER     pnh;
    int             offResBase;
    LPWSTR          rt;

    /*
     * Get current position in file to be used as the base from which
     * the icon data offsets are offset from.
     */
    offResBase = (int)(pfi->pFilePtr - pfi->pFileMap);

    /*
     * Read the .ICO/.CUR data's header.
     */
    ReadFilePtr(pfi, &pnh, sizeof(NEWHEADER));

    pcres = ReadIconGuts(pfi,
                         pnh,
                         offResBase,
                         &rt,
                         cxDesired,
                         cyDesired,
                         LR_flags);

    if (pcres != NULL) {
        hcur = (HCURSOR)ConvertDIBIcon((LPBITMAPINFOHEADER)pcres,
                                       NULL,
                                       NULL,
                                       (rt == RT_ICON),
                                       cxDesired,
                                       cyDesired,
                                       LR_ACONFRAME | LR_flags);

        UserLocalFree(pcres);
    }

    /*
     * Seek to the end of this chunk, regardless of our current position.
     */
    pfi->pFilePtr = pfi->pFileMap + ((offResBase + cbSize + 1) & (~1));

    return hcur;
}


/***************************************************************************\
* LoadAniIcon
*
*   Loads an animatied cursor from a RIFF file.  The RIFF file format for
*   animated cursors looks like this:
*
*   RIFF( 'ACON'
*       LIST( 'INFO'
*           INAM( <name> )
*           IART( <artist> )
*       )
*       anih( <anihdr> )
*       [rate( <rateinfo> )  ]
*       ['seq '( <seq_info> )]
*   LIST( 'fram' icon( <icon_file> ) ... )
*   )
*
*
* History:
* 10-02-91 DarrinM      Created.
* 03-17-93 JonPa        Rewrote to use RIFF format instead of RAD
* 04-22-93 JonPa        Finalized RIFF format (changed from ANI to ACON etc)
* 11/16/1995 SanfordS   Added LR_flags support.
\***************************************************************************/

HICON LoadAniIcon(
    IN PFILEINFO pfi,
    IN LPWSTR    rt,
    IN DWORD     cxDesired,
    IN DWORD     cyDesired,
    IN DWORD     LR_flags)
{
    int cpcur, ipcur = 0, i, cicur;
    ANIHEADER anih;
    ANIHEADER *panih = NULL;
    HICON hacon = NULL;
    HCURSOR *phcur = NULL;
    JIF jifRate, *pjifRate;
    RTAG tag;
    DWORD *picur;

    /*
     * Position to the beginning of the file.
     */
    pfi->pFilePtr = pfi->pFileMap + sizeof(tag);

#if DBG
    if ((ULONG_PTR)pfi->pFileEnd != ((ULONG_PTR)(pfi->pFileMap + sizeof (RTAG) + ((RTAG *)(pfi->pFileMap))->ckSize + 1) & ~1)) {
        RIPMSG2(RIP_WARNING, "LoadAniIcon: First RIFF chunk has invalid ckSize. Actual:%#lx Expected:%#lx",
                ((RTAG *)(pfi->pFileMap))->ckSize, (pfi->pFileEnd - pfi->pFileMap - sizeof(RTAG)) & ~1);
    }
#endif

    /* read the chunk type */
    if(!ReadFilePtrCopy(pfi,
                        &tag.ckID,
                        sizeof(tag.ckID))) {
        goto laiFileErr;
    }

    if (tag.ckID != FOURCC_ACON)
        goto laiFileErr;

    /* look for 'anih', 'rate', 'seq ', and 'icon' chunks */
    while( ReadTag(pfi, &tag)) {

        switch( tag.ckID ) {
        case FOURCC_anih:
            if (!ReadChunk(pfi, &tag, &anih))
                goto laiFileErr;

            if (!(anih.fl & AF_ICON) || (anih.cFrames == 0))
                goto laiFileErr;

            /*
             * Allocate space for the ANIHEADER, HCURSOR array and a
             * rate table (in case we run into one later).
             */
            cpcur = anih.cFrames;
            cicur = anih.cSteps;
            panih = (PANIHEADER)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(ANIHEADER));

            if (panih == NULL)
                goto laiFileErr;

            phcur = UserLocalAlloc(HEAP_ZERO_MEMORY, cpcur * sizeof(HCURSOR) + cicur * sizeof(JIF) + cicur * sizeof(DWORD));
            UserAssert(phcur == NATURAL_ALIGNED_PTR(HCURSOR, phcur));
            if (phcur == NULL) {
                goto laiFileErr;
            }

            pjifRate = NULL;
            picur = NULL;

            *panih = anih;
            jifRate = panih->jifRate;
            break;


        case FOURCC_rate:
            /*
             * If we find a rate chunk, read it into its preallocated
             * space.
             */
            pjifRate = (PJIF)((PBYTE)phcur + cpcur * sizeof(HCURSOR));
            UserAssert(pjifRate == NATURAL_ALIGNED_PTR(JIF, pjifRate));
            if(!ReadChunk(pfi, &tag, (PBYTE)pjifRate))
                goto laiFileErr;
            break;


        case FOURCC_seq:
            /*
             * If we find a seq chunk, read it into its preallocated
             * space.
             */
            picur = (DWORD *)((PBYTE)phcur + cpcur * sizeof(HCURSOR) +
                    cicur * sizeof(JIF));
            UserAssert(picur == NATURAL_ALIGNED_PTR(DWORD, picur));
            if(!ReadChunk(pfi, &tag, (PBYTE)picur))
                goto laiFileErr;
            break;


        case FOURCC_LIST:
            {
                DWORD cbChunk = (tag.ckSize + 1) & ~1;

                /*
                 * See if this list is the 'fram' list of icon chunks
                 */
                if(!ReadFilePtrCopy(pfi, &tag.ckID, sizeof(tag.ckID))) {
                    goto laiFileErr;
                }

                cbChunk -= sizeof(tag.ckID);

                if (tag.ckID != FOURCC_fram) {
                    /*
                     * Not the fram list (probably the INFO list).  Skip
                     * the rest of this chunk.  (Don't forget that we have
                     * already skipped one dword!)
                     */
                    tag.ckSize = cbChunk;
                    SkipChunk(pfi, &tag);
                    break;
                }

                while(cbChunk >= sizeof(tag)) {
                    if (!ReadTag(pfi, &tag))
                        goto laiFileErr;

                    cbChunk -= sizeof(tag);

                    if(tag.ckID == FOURCC_icon) {

                        /*
                         * Ok, load the icon/cursor bits, create a cursor from
                         * them, and save a pointer to it away in the ACON
                         * cursor pointer array.
                         */
                        phcur[ipcur] = ReadIconFromFileMap(pfi,
                                                           tag.ckSize,
                                                           cxDesired,
                                                           cyDesired,
                                                           LR_flags);

                        if (phcur[ipcur] == NULL) {
                            for (i = 0; i < ipcur; i++)
                                NtUserDestroyCursor(phcur[i], 0);
                            goto laiFileErr;
                        }

                        ipcur++;
                    } else {
                        /*
                         * Unknown chunk in fram list, just ignore it
                         */
                        SkipChunk(pfi, &tag);
                    }

                    cbChunk -= (tag.ckSize + 1) & ~1;
                }
            }
            break;

        default:
            /*
             * We're not interested in this chunk, skip it.
             */
            if(!SkipChunk(pfi, &tag))
                goto laiFileErr;
            break;

        }

    }

    /*
     * Sanity check the count of frames so we won't fault trying
     * to select a nonexistant cursor
     */
    if (cpcur != ipcur) {
        RIPMSG2(RIP_WARNING, "LoadAniIcon: Invalid number of frames; Actual:%#lx Expected:%#lx",
                ipcur, cpcur);
        for (i = 0; i < ipcur; i++)
            NtUserDestroyCursor(phcur[i], CURSOR_ALWAYSDESTROY);
        goto laiFileErr;
    }



    if (cpcur != 0)
        hacon = CreateAniIcon(pfi->pszName,
                              rt,
                              cicur,
                              picur,
                              cpcur,
                              phcur,
                              jifRate,
                              pjifRate,
                              LR_flags & LR_GLOBAL);

laiFileErr:

#if DBG
    if (hacon == NULL) {
        RIPMSG0(RIP_WARNING, "LoadAniIcon: Invalid icon data format");
    }
#endif

    if (panih != NULL)
        UserLocalFree(panih);

    if (phcur != NULL) {
        UserLocalFree(phcur);
    }

    return hacon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\callproc.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    callproc.h

Abstract:

    Private DialogProc call routines
    Copied from ldrthunk.asm

Author:

    Joe Jones (joejo) 11-30-98

Revision History:

--*/

#ifndef _CALLPROC_
#define _CALLPROC_

#if defined(_X86_)
LRESULT
InternalCallWinProc(
    WNDPROC proc,
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

/*
 * Bug 246472 - joejo
 * fixup all DDE Callbacks since some apps make their callbacks
 * C-Style instead of PASCAL.
 */
HDDEDATA
UserCallDDECallback(
    PFNCALLBACK pfnDDECallback,
    UINT wType,
    UINT wFmt,
    HCONV hConv,
    HSZ hsz1,
    HSZ hsz2,
    HDDEDATA hData,
    ULONG_PTR dwData1,
    ULONG_PTR dwData2
    );


#else

#define InternalCallWinProc(winproc, hwnd, message, wParam, lParam)    \
    (winproc)(hwnd, message, wParam, lParam)


#define UserCallDDECallback(pfnDDECallback, wType, wFmt, hConv, hsz1, hsz2, hData, dwData1, dwData2) \
    (pfnDDECallback)(wType, wFmt, hConv, hsz1, hsz2, hData, dwData1, dwData2)


#endif

PWND FASTCALL ValidateHwnd(HWND hwnd);

LRESULT UserCallWinProc(PACTIVATION_CONTEXT pActCtx, WNDPROC pfn, HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#endif /* _CALLPROC_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\btnctl.c ===
/**************************** Module Header ********************************\
* Module Name: btnctl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Radio Button and Check Box Handling Routines
*
* History:
* ??-???-???? ??????    Ported from Win 3.0 sources
* 01-Feb-1991 mikeke    Added Revalidation code
* 03-Jan-1992 ianja     Neutralized (ANSI/wide-character)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/* ButtonCalcRect codes */
#define CBR_CLIENTRECT 0
#define CBR_CHECKBOX   1
#define CBR_CHECKTEXT  2
#define CBR_GROUPTEXT  3
#define CBR_GROUPFRAME 4
#define CBR_PUSHBUTTON 5

CONST BYTE mpStyleCbr[] = {
    CBR_PUSHBUTTON,  /* BS_PUSHBUTTON */
    CBR_PUSHBUTTON,  /* BS_DEFPUSHBUTTON */
    CBR_CHECKTEXT,   /* BS_CHECKBOX */
    CBR_CHECKTEXT,   /* BS_AUTOCHECKBOX */
    CBR_CHECKTEXT,   /* BS_RADIOBUTTON */
    CBR_CHECKTEXT,   /* BS_3STATE */
    CBR_CHECKTEXT,   /* BS_AUTO3STATE */
    CBR_GROUPTEXT,   /* BS_GROUPBOX */
    CBR_CLIENTRECT,  /* BS_USERBUTTON */
    CBR_CHECKTEXT,   /* BS_AUTORADIOBUTTON */
    CBR_CLIENTRECT,  /* BS_PUSHBOX */
    CBR_CLIENTRECT,  /* BS_OWNERDRAW */
};

#define IMAGE_BMMAX    IMAGE_CURSOR+1
static CONST BYTE rgbType[IMAGE_BMMAX] = {
    BS_BITMAP,          // IMAGE_BITMAP
    BS_ICON,            // IMAGE_CURSOR
    BS_ICON             // IMAGE_ICON
};

#define IsValidImage(imageType, realType, max)   \
    ((imageType < max) && (rgbType[imageType] == realType))

typedef struct tagBTNDATA {
    LPWSTR  lpsz;       // Text string
    PBUTN   pbutn;      // Button data
    WORD    wFlags;     // Alignment flags
} BTNDATA, FAR * LPBTNDATA;

void xxxDrawButton(PBUTN pbutn, HDC hdc, UINT pbfPush);

LOOKASIDE ButtonLookaside;

/***************************************************************************\
*
*  IsPushButton()
*
*  Returns non-zero if the window is a push button.  Returns flags that
*  are interesting if it is.  These flags are
*
*
*
\***************************************************************************/

UINT IsPushButton(
    PWND pwnd)
{
    BYTE bStyle;
    UINT flags;

    bStyle = TestWF(pwnd, BFTYPEMASK);

    flags = 0;

    switch (bStyle) {
        case LOBYTE(BS_PUSHBUTTON):
            flags |= PBF_PUSHABLE;
            break;

        case LOBYTE(BS_DEFPUSHBUTTON):
            flags |= PBF_PUSHABLE | PBF_DEFAULT;
            break;

        default:
            if (TestWF(pwnd, BFPUSHLIKE))
                flags |= PBF_PUSHABLE;
            break;
    }

    return(flags);
}

/***************************************************************************\
*
*  GetAlignment()
*
*  Gets default alignment of button.  If BS_HORZMASK and/or BS_VERTMASK
*  is specified, uses those.  Otherwise, uses default for button.
*
* It's probably a fine time to describe what alignment flags mean for
* each type of button.  Note that the presence of a bitmap/icon affects
* the meaning of alignments.
*
* (1) Push like buttons
*      With one of {bitmap, icon, text}:
*          Just like you'd expect
*      With one of {bitmap, icon} AND text:
*          Image & text are centered as a unit; alignment means where
*          the image shows up.  E.G., left-aligned means the image
*          on the left, text on the right.
* (2) Radio/check like buttons
*      Left aligned means check/radio box is on left, then bitmap/icon
*          and text follows, left justified.
*      Right aligned means checkk/radio box is on right, preceded by
*          text and bitmap/icon, right justified.
*      Centered has no meaning.
*      With one of {bitmap, icon} AND text:
*          Top aligned means bitmap/icon above, text below
*          Bottom aligned means text above, bitmap/icon below
*      With one of {bitmap, icon, text}
*          Alignments mean what you'd expect.
* (3) Group boxes
*      Left aligned means text is left justified on left side
*      Right aligned means text is right justified on right side
*      Center aligned means text is in middle
*
*
\***************************************************************************/

WORD GetAlignment(
    PWND pwnd)
{
    BYTE bHorz;
    BYTE bVert;

    bHorz = TestWF(pwnd, BFHORZMASK);
    bVert = TestWF(pwnd, BFVERTMASK);

    if (!bHorz || !bVert) {
        if (IsPushButton(pwnd)) {
            if (!bHorz)
                bHorz = LOBYTE(BFCENTER);
        } else {
            if (!bHorz)
                bHorz = LOBYTE(BFLEFT);
        }

        if (!bVert)
            bVert = LOBYTE(BFVCENTER);
    }

    return bHorz | bVert;
}


/***************************************************************************\
*
*  BNSetFont()
*
*  Changes button font, and decides if we can use real bold font for default
*  push buttons or if we have to simulate it.
*
\***************************************************************************/

void BNSetFont(
    PBUTN pbutn,
    HFONT hfn,
    BOOL fRedraw)
{
    PWND pwnd = pbutn->spwnd;

    pbutn->hFont = hfn;

    if (fRedraw && IsVisible(pwnd)) {
        NtUserInvalidateRect(HWq(pwnd), NULL, TRUE);
    }

}


/***************************************************************************\
* xxxBNInitDC
*
* History:
\***************************************************************************/

HBRUSH xxxBNInitDC(
    PBUTN pbutn,
    HDC hdc)
{
    UINT    wColor;
    BYTE    bStyle;
    HBRUSH  hbr;
    PWND pwnd = pbutn->spwnd;

    CheckLock(pwnd);

    /*
     * Set BkMode before getting brush so that the app can change it to
     * transparent if it wants.
     */
    SetBkMode(hdc, OPAQUE);

    bStyle = TestWF(pwnd, BFTYPEMASK);

    switch (bStyle) {
        default:
            if (TestWF(pwnd, WFWIN40COMPAT) && !TestWF(pwnd, BFPUSHLIKE)) {
                wColor = WM_CTLCOLORSTATIC;
                break;
            }

        case LOBYTE(BS_PUSHBUTTON):
        case LOBYTE(BS_DEFPUSHBUTTON):
        case LOBYTE(BS_OWNERDRAW):
        case LOBYTE(BS_USERBUTTON):
            wColor = WM_CTLCOLORBTN;
            break;
    }

    hbr = GetControlBrush(HWq(pwnd), hdc, wColor);

    /*
     * Select in the user's font if set, and save the old font so that we can
     * restore it when we release the dc.
     */
    if (pbutn->hFont) {
        SelectObject(hdc, pbutn->hFont);
    }

    /*
     * Clip output to the window rect if needed.
     */
    if (bStyle != LOBYTE(BS_GROUPBOX)) {
        IntersectClipRect(hdc, 0, 0,
            pwnd->rcClient.right - pwnd->rcClient.left,
            pwnd->rcClient.bottom - pwnd->rcClient.top);
    }

    if (TestWF(pwnd,WEFRTLREADING))
        SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));

    return(hbr);
}

/***************************************************************************\
* xxxBNGetDC
*
* History:
\***************************************************************************/

HDC xxxBNGetDC(
    PBUTN pbutn,
    HBRUSH *lphbr)
{
    HDC hdc;
    PWND pwnd = pbutn->spwnd;

    CheckLock(pwnd);

    if (IsVisible(pwnd)) {
        HBRUSH  hbr;

        hdc = NtUserGetDC(HWq(pwnd));
        hbr = xxxBNInitDC(pbutn, hdc);

        if (lphbr!=NULL)
            *lphbr = hbr;

        return hdc;
    }

    return NULL;
}

/***************************************************************************\
* BNReleaseDC
*
* History:
\***************************************************************************/

void BNReleaseDC(
    PBUTN pbutn,
    HDC hdc)
{
    PWND pwnd = pbutn->spwnd;

    if (TestWF(pwnd,WEFRTLREADING))
        SetTextAlign(hdc, GetTextAlign(hdc) & ~TA_RTLREADING);

    if (pbutn->hFont) {
        SelectObject(hdc, ghFontSys);
    }

    ReleaseDC(HWq(pwnd), hdc);
}

/***************************************************************************\
* xxxBNOwnerDraw
*
* History:
\***************************************************************************/

void xxxBNOwnerDraw(
    PBUTN pbutn,
    HDC hdc,
    UINT itemAction)
{
    DRAWITEMSTRUCT drawItemStruct;
    TL tlpwndParent;
    PWND pwnd = pbutn->spwnd;
    UINT itemState = 0;

    if (TestWF(pwnd, WEFPUIFOCUSHIDDEN)) {
        itemState |= ODS_NOFOCUSRECT;
    }
    if (TestWF(pwnd, WEFPUIACCELHIDDEN)) {
        itemState |= ODS_NOACCEL;
    }
    if (BUTTONSTATE(pbutn) & BST_FOCUS) {
        itemState |= ODS_FOCUS;
    }
    if (BUTTONSTATE(pbutn) & BST_PUSHED) {
        itemState |= ODS_SELECTED;
    }

    if (TestWF(pwnd, WFDISABLED))
        itemState |= ODS_DISABLED;

    drawItemStruct.CtlType = ODT_BUTTON;
    drawItemStruct.CtlID = PtrToUlong(pwnd->spmenu);
    drawItemStruct.itemAction = itemAction;
    drawItemStruct.itemState = itemState;
    drawItemStruct.hwndItem = HWq(pwnd);
    drawItemStruct.hDC = hdc;
    _GetClientRect(pwnd, &drawItemStruct.rcItem);
    drawItemStruct.itemData = 0L;

    /*
     * Send a WM_DRAWITEM message to the parent
     * IanJa:  in this case pMenu is being used as the control ID
     */
    ThreadLock(REBASEPWND(pwnd, spwndParent), &tlpwndParent);
    SendMessage(HW(REBASEPWND(pwnd, spwndParent)), WM_DRAWITEM, (WPARAM)pwnd->spmenu,
            (LPARAM)&drawItemStruct);
    ThreadUnlock(&tlpwndParent);
}

/***************************************************************************\
* CalcBtnRect
*
* History:
\***************************************************************************/

void BNCalcRect(
    PWND pwnd,
    HDC hdc,
    LPRECT lprc,
    int code,
    UINT pbfFlags)
{
    int cch;
    SIZE extent;
    int dy;
    LPWSTR lpName;
    UINT align;

    _GetClientRect(pwnd, lprc);

    align = GetAlignment(pwnd);

    switch (code) {
    case CBR_PUSHBUTTON:
        // Subtract out raised edge all around
        InflateRect(lprc, -SYSMET(CXEDGE), -SYSMET(CYEDGE));

        if (pbfFlags & PBF_DEFAULT)
            InflateRect(lprc, -SYSMET(CXBORDER), -SYSMET(CYBORDER));
        break;

    case CBR_CHECKBOX:
        switch (align & LOBYTE(BFVERTMASK))
        {
        case LOBYTE(BFVCENTER):
                lprc->top = (lprc->top + lprc->bottom - gpsi->oembmi[OBI_CHECK].cy) / 2;
                break;

            case LOBYTE(BFTOP):
            case LOBYTE(BFBOTTOM):
                PSMGetTextExtent(hdc, (LPWSTR)szOneChar, 1, &extent);
                dy = extent.cy + extent.cy/4;

                // Save vertical extent
                extent.cx = dy;

                // Get centered amount

                dy = (dy - gpsi->oembmi[OBI_CHECK].cy) / 2;
                if ((align & LOBYTE(BFVERTMASK)) == LOBYTE(BFTOP))
                    lprc->top += dy;
                else
                    lprc->top = lprc->bottom - extent.cx + dy;
                break;
        }

        if (TestWF(pwnd, BFRIGHTBUTTON))
            lprc->left = lprc->right - gpsi->oembmi[OBI_CHECK].cx;
        else
            lprc->right = lprc->left + gpsi->oembmi[OBI_CHECK].cx;

        break;

    case CBR_CHECKTEXT:
        if (TestWF(pwnd, BFRIGHTBUTTON)) {
            lprc->right -= gpsi->oembmi[OBI_CHECK].cx;

            // More spacing for 4.0 dudes
            if (TestWF(pwnd, WFWIN40COMPAT)) {
                PSMGetTextExtent(hdc, szOneChar, 1, &extent);
                lprc->right -= extent.cx  / 2;
            }
        } else {
            lprc->left += gpsi->oembmi[OBI_CHECK].cx;

            // More spacing for 4.0 dudes
            if (TestWF(pwnd, WFWIN40COMPAT)) {
                PSMGetTextExtent(hdc, szOneChar, 1, &extent);
                lprc->left +=  extent.cx / 2;
            }
        }
        break;

    case CBR_GROUPTEXT:
        if (!pwnd->strName.Length)
            goto EmptyRect;

        lpName = REBASE(pwnd, strName.Buffer);
        if (!(cch = pwnd->strName.Length / sizeof(WCHAR))) {
EmptyRect:
            SetRectEmpty(lprc);
            break;
        }

        PSMGetTextExtent(hdc, lpName, cch, &extent);
        extent.cx += SYSMET(CXEDGE) * 2;

        switch (align & LOBYTE(BFHORZMASK))
        {
        // BFLEFT, nothing
        case LOBYTE(BFLEFT):
            lprc->left += (gpsi->cxSysFontChar - SYSMET(CXBORDER));
            lprc->right = lprc->left + (int)(extent.cx);
            break;

        case LOBYTE(BFRIGHT):
            lprc->right -= (gpsi->cxSysFontChar - SYSMET(CXBORDER));
            lprc->left = lprc->right - (int)(extent.cx);
            break;

        case LOBYTE(BFCENTER):
            lprc->left = (lprc->left + lprc->right - (int)(extent.cx)) / 2;
            lprc->right = lprc->left + (int)(extent.cx);
            break;
        }

        // Center aligned.
        lprc->bottom = lprc->top + extent.cy + SYSMET(CYEDGE);
        break;

    case CBR_GROUPFRAME:
        PSMGetTextExtent(hdc, (LPWSTR)szOneChar, 1, &extent);
        lprc->top += extent.cy / 2;
        break;
    }
}

/***************************************************************************\
*
*  BtnGetMultiExtent()
*
*  Calculates button text extent, given alignment flags.
*
\***************************************************************************/

void BNMultiExtent(
    WORD wFlags,
    HDC hdc,
    LPRECT lprcMax,
    LPWSTR lpsz,
    int cch,
    PINT pcx,
    PINT pcy)
{
    RECT rcT;

    UINT dtFlags = DT_CALCRECT | DT_WORDBREAK | DT_EDITCONTROL;
    CopyRect(&rcT, lprcMax);

    // Note that since we're just calculating the maximum dimensions,
    // left-justification and top-justification are not important.
    // Also, remember to leave margins horz and vert that follow our rules
    // in DrawBtnText().

    InflateRect(&rcT, -SYSMET(CXEDGE), -SYSMET(CYBORDER));

    if ((wFlags & LOBYTE(BFHORZMASK)) == LOBYTE(BFCENTER))
        dtFlags |= DT_CENTER;

    if ((wFlags & LOBYTE(BFHORZMASK)) == LOBYTE(BFRIGHT))
        dtFlags |= DT_RIGHT;

    if ((wFlags & LOBYTE(BFVERTMASK)) == LOBYTE(BFVCENTER))
        dtFlags |= DT_VCENTER;

    if ((wFlags & LOBYTE(BFVERTMASK)) == LOBYTE(BFBOTTOM))
        dtFlags |= DT_BOTTOM;

    DrawTextExW(hdc, lpsz, cch, &rcT, dtFlags, NULL);

    if (pcx)
        *pcx = rcT.right-rcT.left;
    if (pcy)
        *pcy = rcT.bottom-rcT.top;
}

/***************************************************************************\
*
*  BtnMultiDraw()
*
*  Draws multiline button text
*
\***************************************************************************/

BOOL CALLBACK BNMultiDraw(
    HDC hdc,
    LPARAM lData,
    WPARAM wData,
    int cx,
    int cy)
{
    LPBTNDATA lpbd = (LPBTNDATA)lData;
    int cch = (int)wData;
    RECT rcT;
    UINT dtFlags = DT_WORDBREAK | DT_EDITCONTROL;
    PBUTN pbutn = lpbd->pbutn;

    if (TestWF(pbutn->spwnd, WEFPUIACCELHIDDEN)) {
        dtFlags |= DT_HIDEPREFIX;
    } else if (pbutn->fPaintKbdCuesOnly){
        dtFlags |= DT_PREFIXONLY;
    }

    if (TestWF(pbutn->spwnd, WEFRIGHT)) {
        dtFlags |= DT_RIGHT;
    }
    
    rcT.left    = 0;
    rcT.top     = 0;
    rcT.right   = cx;
    rcT.bottom  = cy;

    // Horizontal alignment
    UserAssert(DT_LEFT == 0);
    switch (lpbd->wFlags & LOBYTE(BFHORZMASK)) {
        case LOBYTE(BFCENTER):
            dtFlags |= DT_CENTER;
            break;

        case LOBYTE(BFRIGHT):
            dtFlags |= DT_RIGHT;
            break;
    }

    // Vertical alignment
    UserAssert(DT_TOP == 0);
    switch (lpbd->wFlags & LOBYTE(BFVERTMASK)) {
        case LOBYTE(BFVCENTER):
            dtFlags |= DT_VCENTER;
            break;

        case LOBYTE(BFBOTTOM):
            dtFlags |= DT_BOTTOM;
            break;
    }

    DrawTextExW(hdc, lpbd->lpsz, cch, &rcT, dtFlags, NULL);
    return(TRUE);
}

/***************************************************************************\
* xxxBNSetCapture
*
* History:
\***************************************************************************/

BOOL xxxBNSetCapture(
    PBUTN pbutn,
    UINT codeMouse)
{
    PWND pwnd = pbutn->spwnd;

    BUTTONSTATE(pbutn) |= codeMouse;

    CheckLock(pwnd);

    if (!(BUTTONSTATE(pbutn) & BST_CAPTURED)) {
        NtUserSetCapture(HWq(pwnd));
        BUTTONSTATE(pbutn) |= BST_CAPTURED;

        /*
         * To prevent redundant CLICK messages, we set the INCLICK bit so
         * the WM_SETFOCUS code will not do a xxxButtonNotifyParent(BN_CLICKED).
         */

        BUTTONSTATE(pbutn) |= BST_INCLICK;

        NtUserSetFocus(HWq(pwnd));

        BUTTONSTATE(pbutn) &= ~BST_INCLICK;
    }
    return(BUTTONSTATE(pbutn) & BST_CAPTURED);
}


/***************************************************************************\
* xxxButtonNotifyParent
*
* History:
\***************************************************************************/

void xxxButtonNotifyParent(
    PWND pwnd,
    UINT code)
{
    TL tlpwndParent;
    PWND pwndParent;            // Parent if it exists

    CheckLock(pwnd);

    if (pwnd->spwndParent)
        pwndParent = REBASEPWND(pwnd, spwndParent);
    else
        pwndParent = pwnd;

    /*
     * Note: A button's pwnd->spmenu is used to store the control ID
     */
    ThreadLock(pwndParent, &tlpwndParent);
    SendMessage(HW(pwndParent), WM_COMMAND,
            MAKELONG(PTR_TO_ID(pwnd->spmenu), code), (LPARAM)HWq(pwnd));
    ThreadUnlock(&tlpwndParent);
}

/***************************************************************************\
* xxxBNReleaseCapture
*
* History:
\***************************************************************************/

void xxxBNReleaseCapture(
    PBUTN pbutn,
    BOOL fCheck)
{
    PWND pwndT;
    UINT check;
    BOOL fNotifyParent = FALSE;
    TL tlpwndT;
    PWND pwnd = pbutn->spwnd;

    CheckLock(pwnd);

    if (BUTTONSTATE(pbutn) & BST_PUSHED) {
        SendMessageWorker(pwnd, BM_SETSTATE, FALSE, 0, FALSE);
        if (fCheck) {
            switch (TestWF(pwnd, BFTYPEMASK)) {
            case BS_AUTOCHECKBOX:
            case BS_AUTO3STATE:
                check = (UINT)((BUTTONSTATE(pbutn) & BST_CHECKMASK) + 1);

                if (check > (UINT)(TestWF(pwnd, BFTYPEMASK) == BS_AUTO3STATE? BST_INDETERMINATE : BST_CHECKED)) {
                    check = BST_UNCHECKED;
                }
                SendMessageWorker(pwnd, BM_SETCHECK, check, 0, FALSE);
                break;

            case BS_AUTORADIOBUTTON:
                pwndT = pwnd;
                do {
                    ThreadLock(pwndT, &tlpwndT);

                    if ((UINT)SendMessage(HW(pwndT), WM_GETDLGCODE, 0, 0L) &
                            DLGC_RADIOBUTTON) {
                        SendMessage(HW(pwndT), BM_SETCHECK, (pwnd == pwndT), 0L);
                    }
                    pwndT = _GetNextDlgGroupItem(REBASEPWND(pwndT, spwndParent),
                            pwndT, FALSE);
                    ThreadUnlock(&tlpwndT);

                } while (pwndT != pwnd);
            }

            fNotifyParent = TRUE;
        }
    }

    if (BUTTONSTATE(pbutn) & BST_CAPTURED) {
        BUTTONSTATE(pbutn) &= ~(BST_CAPTURED | BST_MOUSE);
        NtUserReleaseCapture();
    }

    if (fNotifyParent) {

        /*
         * We have to do the notification after setting the buttonstate bits.
         */
        xxxButtonNotifyParent(pwnd, BN_CLICKED);
    }
}

/***************************************************************************\
*
*  DrawBtnText()
*
*  Draws text of button.
*
\***************************************************************************/

void xxxBNDrawText(
    PBUTN pbutn,
    HDC hdc,
    BOOL dbt,
    BOOL fDepress)
{
    RECT    rc;
    HBRUSH  hbr;
    int     x;
    int     y;
    int     cx;
    int     cy;
    LPWSTR   lpName;
    BYTE    bStyle;
    int     cch;
    UINT    dsFlags;
    BTNDATA bdt;
    UINT    pbfPush;
    PWND    pwnd = pbutn->spwnd;

    bStyle = TestWF(pwnd, BFTYPEMASK);

    if (bStyle > sizeof(mpStyleCbr)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid button style");
    } else if ((bStyle == LOBYTE(BS_GROUPBOX)) && (dbt == DBT_FOCUS))
        return;

    pbfPush = IsPushButton(pwnd);
    if (pbfPush) {
        BNCalcRect(pwnd, hdc, &rc, CBR_PUSHBUTTON, pbfPush);
        IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

        //
        // This is because we don't have WM_CTLCOLOR / CTLCOLOR_BTN
        // actually set up the button colors.  For old apps, CTLCOLOR_BTN
        // needs to work like CTLCOLOR_STATIC.
        //
        SetBkColor(hdc, SYSRGB(3DFACE));
        SetTextColor(hdc, SYSRGB(BTNTEXT));
        hbr = SYSHBR(BTNTEXT);
    } else {
        BNCalcRect(pwnd, hdc, &rc, mpStyleCbr[bStyle], pbfPush);

        // Skip stuff for ownerdraw buttons, since we aren't going to
        // draw text/image.
        if (bStyle == LOBYTE(BS_OWNERDRAW))
            goto DrawFocus;
        else
            hbr = SYSHBR(WINDOWTEXT);
    }

    // Alignment
    bdt.wFlags = GetAlignment(pwnd);
    bdt.pbutn = pbutn;

    // Bail if we have nothing to draw
    if (TestWF(pwnd, BFBITMAP)) {
        BITMAP bmp;

        // Bitmap button
        if (!pbutn->hImage)
            return;

        GetObject(pbutn->hImage, sizeof(BITMAP), &bmp);
        cx = bmp.bmWidth;
        cy = bmp.bmHeight;

        dsFlags = DST_BITMAP;
        goto UseImageForName;
    } else if (TestWF(pwnd, BFICON)) {
        // Icon button
        if (!pbutn->hImage)
            return;

        NtUserGetIconSize(pbutn->hImage, 0, &cx, &cy);
        cy /= 2;    // The bitmap height is half because a Mask is present in NT

        dsFlags = DST_ICON;
UseImageForName:
        lpName = (LPWSTR)pbutn->hImage;
        cch = TRUE;
    } else {
        // Text button
        if (!pwnd->strName.Length)
            return;

        lpName = REBASE(pwnd, strName.Buffer);
        cch    = pwnd->strName.Length / sizeof(WCHAR);

        if (TestWF(pwnd, BFMULTILINE)) {

            bdt.lpsz = lpName;

            BNMultiExtent(bdt.wFlags, hdc, &rc, lpName, cch, &cx, &cy);

            lpName = (LPWSTR)(LPBTNDATA)&bdt;
            dsFlags = DST_COMPLEX;

        } else {
            SIZE size;

            PSMGetTextExtent(hdc, lpName, cch, &size);
            cx = size.cx;
            cy = size.cy;
            /*
             * If the control doesn't need underlines, set DST_HIDEPREFIX and
             * also do not show the focus indicator
             */
            dsFlags = DST_PREFIXTEXT;
            if (TestWF(pwnd, WEFPUIACCELHIDDEN)) {
                dsFlags |= DSS_HIDEPREFIX;
            } else if (pbutn->fPaintKbdCuesOnly) {
                dsFlags |= DSS_PREFIXONLY;
            }
        }


        //
        // Add on a pixel or two of vertical space to make centering
        // happier.  That way underline won't abut focus rect unless
        // spacing is really tight.
        //
        cy++;
    }

    //
    // ALIGNMENT
    //

    // Horizontal
    switch (bdt.wFlags & LOBYTE(BFHORZMASK)) {
        //
        // For left & right justified, we leave a margin of CXEDGE on either
        // side for eye-pleasing space.
        //
        case LOBYTE(BFLEFT):
            x = rc.left + SYSMET(CXEDGE);
            break;

        case LOBYTE(BFRIGHT):
            x = rc.right - cx - SYSMET(CXEDGE);
            break;

        default:
            x = (rc.left + rc.right - cx) / 2;
            break;
    }

    // Vertical
    switch (bdt.wFlags & LOBYTE(BFVERTMASK)) {
        //
        // For top & bottom justified, we leave a margin of CYBORDER on
        // either side for more eye-pleasing space.
        //
        case LOBYTE(BFTOP):
            y = rc.top + SYSMET(CYBORDER);
            break;

        case LOBYTE(BFBOTTOM):
            y = rc.bottom - cy - SYSMET(CYBORDER);
            break;

        default:
            y = (rc.top + rc.bottom - cy) / 2;
            break;
    }

    //
    // Draw the text
    //
    if (dbt & DBT_TEXT) {
        //
        // This isn't called for USER buttons.
        //
        UserAssert(bStyle != LOBYTE(BS_USERBUTTON));

        if (fDepress) {
            x += SYSMET(CXBORDER);
            y += SYSMET(CYBORDER);
        }

        if (TestWF(pwnd, WFDISABLED)) {
            UserAssert(HIBYTE(BFICON) == HIBYTE(BFBITMAP));
            if (SYSMET(SLOWMACHINE)  &&
                !TestWF(pwnd, BFICON | BFBITMAP) &&
                (GetBkColor(hdc) != SYSRGB(GRAYTEXT)))
            {
                // Perf && consistency with menus, statics
                SetTextColor(hdc, SYSRGB(GRAYTEXT));
            }
            else
                dsFlags |= DSS_DISABLED;
        }

        //
        // Use transparent mode for checked push buttons since we're going to
        // fill background with dither.
        //
        if (pbfPush) {
            switch (BUTTONSTATE(pbutn) & BST_CHECKMASK) {
                case BST_INDETERMINATE:
                    hbr = SYSHBR(GRAYTEXT);
                    dsFlags |= DSS_MONO;
                    // FALL THRU

                case BST_CHECKED:
                    // Drawing on dithered background...
                    SetBkMode(hdc, TRANSPARENT);
                    break;
            }
        }

        //
        // Use brush and colors currently selected into hdc when we grabbed
        // color
        //
        DrawState(hdc, hbr, BNMultiDraw, (LPARAM)lpName,
            (WPARAM)cch, x, y, cx, cy,
            dsFlags);
    }

    // Draw focus rect.
    //
    // This can get called for OWNERDRAW and USERDRAW buttons. However, only
    // OWNERDRAW buttons let the owner change the drawing of the focus button.
DrawFocus:
    if (dbt & DBT_FOCUS) {
        if (bStyle == LOBYTE(BS_OWNERDRAW)) {
            // For ownerdraw buttons, this is only called in response to a
            // WM_SETFOCUS or WM_KILL FOCUS message.  So, we can check the
            // new state of the focus by looking at the BUTTONSTATE bits
            // which are set before this procedure is called.
            xxxBNOwnerDraw(pbutn, hdc, ODA_FOCUS);
        } else {
            // Don't draw the focus if underlines are not turned on
            if (!TestWF(pwnd, WEFPUIFOCUSHIDDEN)) {

                // Let focus rect always hug edge of push buttons.  We already
                // have the client area setup for push buttons, so we don't have
                // to do anything.
                if (!pbfPush) {

                    RECT rcClient;

                    _GetClientRect(pwnd, &rcClient);
                    if (bStyle == LOBYTE(BS_USERBUTTON))
                        CopyRect(&rc, &rcClient);
                    else {
                        // Try to leave a border all around text.  That causes
                        // focus to hug text.
                        rc.top = max(rcClient.top, y-SYSMET(CYBORDER));
                        rc.bottom = min(rcClient.bottom, rc.top + SYSMET(CYEDGE) + cy);

                        rc.left = max(rcClient.left, x-SYSMET(CXBORDER));
                        rc.right = min(rcClient.right, rc.left + SYSMET(CXEDGE) + cx);
                    }
                } else
                    InflateRect(&rc, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

                // Are back & fore colors set properly?
                DrawFocusRect(hdc, &rc);
            }
        }
    }
}


/***************************************************************************\
*
*  DrawCheck()
*
\***************************************************************************/

void xxxButtonDrawCheck(
    PBUTN pbutn,
    HDC hdc,
    HBRUSH hbr)
{
    RECT rc;
    int bm;
    UINT flags;
    BOOL fDoubleBlt = FALSE;
    TL tlpwnd;
    PWND pwnd = pbutn->spwnd;
    PWND pwndParent;

    BNCalcRect(pwnd, hdc, &rc, CBR_CHECKBOX, 0);

    flags = 0;
    if (BUTTONSTATE(pbutn) & BST_CHECKMASK)
        flags |= DFCS_CHECKED;
    if (BUTTONSTATE(pbutn) & BST_PUSHED)
        flags |= DFCS_PUSHED;
    if (TestWF(pwnd, WFDISABLED))
        flags |= DFCS_INACTIVE;

    bm = OBI_CHECK;
    switch (TestWF(pwnd, BFTYPEMASK)) {
        case BS_AUTORADIOBUTTON:
        case BS_RADIOBUTTON:
            fDoubleBlt = TRUE;
            bm = OBI_RADIO;
            flags |= DFCS_BUTTONRADIO;
            break;

        case BS_3STATE:
        case BS_AUTO3STATE:
            if ((BUTTONSTATE(pbutn) & BST_CHECKMASK) == BST_INDETERMINATE) {
                bm = OBI_3STATE;
                flags |= DFCS_BUTTON3STATE;
                break;
            }
            // FALL THRU

        default:
            flags |= DFCS_BUTTONCHECK;
            break;
    }

    rc.right = rc.left + gpsi->oembmi[bm].cx;
    rc.bottom = rc.top + gpsi->oembmi[bm].cy;

    ThreadLockAlways(pwnd->spwndParent, &tlpwnd);
    pwndParent = REBASEPWND(pwnd, spwndParent);
    PaintRect(HW(pwndParent), HWq(pwnd), hdc, hbr, &rc);
    ThreadUnlock(&tlpwnd);

    if (TestWF(pwnd, BFFLAT) && gpsi->BitCount != 1) {
        flags |= DFCS_MONO | DFCS_FLAT;
        DrawFrameControl(hdc, &rc, DFC_BUTTON, flags);
    } else {

        switch (flags & (DFCS_CHECKED | DFCS_PUSHED | DFCS_INACTIVE))
        {
        case 0:
            break;

        case DFCS_CHECKED:
            bm += DOBI_CHECK;
            break;

        // These are mutually exclusive!
        case DFCS_PUSHED:
        case DFCS_INACTIVE:
            bm += DOBI_DOWN;        // DOBI_DOWN == DOBI_INACTIVE
            break;

        case DFCS_CHECKED | DFCS_PUSHED:
            bm += DOBI_CHECKDOWN;
            break;

        case DFCS_CHECKED | DFCS_INACTIVE:
            bm += DOBI_CHECKDOWN + 1;
            break;
        }

        if (fDoubleBlt) {
            // This is a diamond-shaped radio button -- Blt with a mask so that
            // the exterior keeps the same color as the window's background
            DWORD clrTextSave = SetTextColor(hdc, 0x00000000L);
            DWORD clrBkSave   = SetBkColor(hdc, 0x00FFFFFFL);
            POEMBITMAPINFO pOem = gpsi->oembmi + OBI_RADIOMASK;

            NtUserBitBltSysBmp(hdc, rc.left, rc.top, pOem->cx, pOem->cy,
                    pOem->x, pOem->y, SRCAND);

            pOem = gpsi->oembmi + bm;
            NtUserBitBltSysBmp(hdc, rc.left, rc.top, pOem->cx, pOem->cy,
                    pOem->x, pOem->y, SRCINVERT);

            SetTextColor(hdc, clrTextSave);
            SetBkColor(hdc, clrBkSave);
        } else {
            POEMBITMAPINFO pOem = gpsi->oembmi + bm;
            DWORD dwROP = 0;

            // We do not want to mirror the check box.
            if (MIRRORED_HDC(hdc)) {
                dwROP = NOMIRRORBITMAP;
            }
            NtUserBitBltSysBmp(hdc, rc.left, rc.top, pOem->cx, pOem->cy,
                    pOem->x, pOem->y, SRCCOPY | dwROP);
        }
    }
}


/***************************************************************************\
* xxxButtonDrawNewState
*
* History:
\***************************************************************************/

void xxxButtonDrawNewState(
    PBUTN pbutn,
    HDC hdc,
    HBRUSH hbr,
    UINT sOld)
{
    PWND pwnd = pbutn->spwnd;

    CheckLock(pwnd);

    if (sOld != (UINT)(BUTTONSTATE(pbutn) & BST_PUSHED)) {
        UINT    pbfPush;

        pbfPush = IsPushButton(pwnd);

        switch (TestWF(pwnd, BFTYPEMASK)) {
        case BS_GROUPBOX:
        case BS_OWNERDRAW:
            break;

        default:
            if (!pbfPush) {
                xxxButtonDrawCheck(pbutn, hdc, hbr);
                break;
            }

        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
        case BS_PUSHBOX:
            xxxDrawButton(pbutn, hdc, pbfPush);
            break;
        }
    }
}

/***************************************************************************\
*
*  DrawButton()
*
*  Draws push-like button with text
*
\***************************************************************************/

void xxxDrawButton(
    PBUTN pbutn,
    HDC hdc,
    UINT pbfPush)
{
    RECT rc;
    UINT flags = 0;
    UINT state = 0;
    PWND pwnd = pbutn->spwnd;

    if (BUTTONSTATE(pbutn) & BST_PUSHED)
        state |= DFCS_PUSHED;

    if (!pbutn->fPaintKbdCuesOnly) {
        if (BUTTONSTATE(pbutn) & BST_CHECKMASK)
            state |= DFCS_CHECKED;

        if (TestWF(pwnd, WFWIN40COMPAT))
            flags = BF_SOFT;

        if (TestWF(pwnd, BFFLAT))
            flags |= BF_FLAT | BF_MONO;

        _GetClientRect(pwnd, &rc);

        if (pbfPush & PBF_DEFAULT) {
            DrawFrame(hdc, &rc, 1, DF_WINDOWFRAME);
            InflateRect(&rc, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

            if (state & DFCS_PUSHED)
                flags |= BF_FLAT;
        }

        DrawPushButton(hdc, &rc, state, flags);
    }

    xxxBNDrawText(pbutn, hdc, DBT_TEXT | (BUTTONSTATE(pbutn) &
           BST_FOCUS ? DBT_FOCUS : 0), (state & DFCS_PUSHED));
}


/***************************************************************************\
* xxxBNPaint
*
* History:
\***************************************************************************/

void xxxBNPaint(
    PBUTN pbutn,
    HDC hdc)
{
    UINT bsWnd;
    RECT rc;
    HBRUSH  hbr;
    HBRUSH hbrBtnSave;
    TL tlpwndParent;
    UINT pbfPush;
    PWND pwnd = pbutn->spwnd;
    PWND pwndParent;

    CheckLock(pwnd);

    hbr = xxxBNInitDC(pbutn, hdc);

    bsWnd = TestWF(pwnd, BFTYPEMASK);
    pbfPush = IsPushButton(pwnd);
    if (!pbfPush && !pbutn->fPaintKbdCuesOnly) {
        _GetClientRect(pwnd, &rc);

        if ((bsWnd != LOBYTE(BS_OWNERDRAW)) &&
            (bsWnd != LOBYTE(BS_GROUPBOX))) {
             ThreadLock(pwnd->spwndParent, &tlpwndParent);
             pwndParent = REBASEPWND(pwnd, spwndParent);
             PaintRect(HW(pwndParent), HWq(pwnd), hdc, hbr, &rc);
             ThreadUnlock(&tlpwndParent);
        }

        hbrBtnSave = SelectObject(hdc, hbr);
    }

    switch (bsWnd) {
    case BS_CHECKBOX:
    case BS_RADIOBUTTON:
    case BS_AUTORADIOBUTTON:
    case BS_3STATE:
    case BS_AUTOCHECKBOX:
    case BS_AUTO3STATE:
        if (!pbfPush) {
            xxxBNDrawText(pbutn, hdc,
                DBT_TEXT | (BUTTONSTATE(pbutn) & BST_FOCUS ? DBT_FOCUS : 0), FALSE);
            if (!pbutn->fPaintKbdCuesOnly) {
                xxxButtonDrawCheck(pbutn, hdc, hbr);
            }
            break;
        }
        /*
         * Fall through for PUSHLIKE buttons
         */

    case BS_PUSHBUTTON:
    case BS_DEFPUSHBUTTON:
        xxxDrawButton(pbutn, hdc, pbfPush);
        break;

    case BS_PUSHBOX:
        xxxBNDrawText(pbutn, hdc,
            DBT_TEXT | (BUTTONSTATE(pbutn) & BST_FOCUS ? DBT_FOCUS : 0), FALSE);

        xxxButtonDrawNewState(pbutn, hdc, hbr, 0);
        break;

    case BS_USERBUTTON:
        xxxButtonNotifyParent(pwnd, BN_PAINT);

        if (BUTTONSTATE(pbutn) & BST_PUSHED) {
            xxxButtonNotifyParent(pwnd, BN_PUSHED);
        }
        if (TestWF(pwnd, WFDISABLED)) {
            xxxButtonNotifyParent(pwnd, BN_DISABLE);
        }
        if (BUTTONSTATE(pbutn) & BST_FOCUS) {
            xxxBNDrawText(pbutn, hdc, DBT_FOCUS, FALSE);
        }
        break;

    case BS_OWNERDRAW:
        xxxBNOwnerDraw(pbutn, hdc, ODA_DRAWENTIRE);
        break;

    case BS_GROUPBOX:
        if (!pbutn->fPaintKbdCuesOnly) {
            BNCalcRect(pwnd, hdc, &rc, CBR_GROUPFRAME, 0);
            DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT |
                (TestWF(pwnd, BFFLAT) ? BF_FLAT | BF_MONO : 0));

            BNCalcRect(pwnd, hdc, &rc, CBR_GROUPTEXT, 0);
            ThreadLock(pwnd->spwndParent, &tlpwndParent);
            pwndParent = REBASEPWND(pwnd, spwndParent);
            PaintRect(HW(pwndParent), HWq(pwnd), hdc, hbr, &rc);
            ThreadUnlock(&tlpwndParent);
        }

        /*
         * FillRect(hdc, &rc, hbrBtn);
         */
        xxxBNDrawText(pbutn, hdc, DBT_TEXT, FALSE);
        break;
    }

    if (!pbfPush)
        SelectObject(hdc, hbrBtnSave);

    /*
     * Release the font which may have been loaded by xxxButtonInitDC.
     */
    if (pbutn->hFont) {
        SelectObject(hdc, ghFontSys);
    }
}
/***************************************************************************\
* RepaintButton
*
\***************************************************************************/
void RepaintButton (PBUTN pbutn)
{
    HDC hdc = xxxBNGetDC(pbutn, NULL);
    if (hdc != NULL) {
        xxxBNPaint(pbutn, hdc);
        BNReleaseDC(pbutn, hdc);
    }
}
/***************************************************************************\
* ButtonWndProc
*
* WndProc for buttons, check boxes, etc.
*
* History:
\***************************************************************************/

LRESULT APIENTRY ButtonWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    UINT bsWnd;
    UINT wOldState;
    RECT rc;
    POINT pt;
    HDC hdc;
    HBRUSH      hbr;
    PAINTSTRUCT ps;
    TL tlpwndParent;
    PBUTN pbutn;
    PWND pwndParent;
    static BOOL fInit = TRUE;
    LONG lResult;

    CheckLock(pwnd);

    bsWnd = TestWF(pwnd, BFTYPEMASK);

    VALIDATECLASSANDSIZE(pwnd, FNID_BUTTON);
    INITCONTROLLOOKASIDE(&ButtonLookaside, BUTN, spwnd, 8);

    /*
     * Get the pbutn for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,pbutn) when
     * we initially created the button control.
     */
    pbutn = ((PBUTNWND)pwnd)->pbutn;

    switch (message) {
    case WM_NCHITTEST:
        if (bsWnd == LOBYTE(BS_GROUPBOX)) {
            return (LONG)HTTRANSPARENT;
        } else {
            goto CallDWP;
        }

    case WM_ERASEBKGND:
        if (bsWnd == LOBYTE(BS_OWNERDRAW)) {

            /*
             * Handle erase background for owner draw buttons.
             */
            _GetClientRect(pwnd, &rc);
            ThreadLock(pwnd->spwndParent, &tlpwndParent);
            pwndParent = REBASEPWND(pwnd, spwndParent);
            PaintRect(HW(pwndParent), hwnd, (HDC)wParam, (HBRUSH)CTLCOLOR_BTN, &rc);
            ThreadUnlock(&tlpwndParent);
        }

        /*
         * Do nothing for other buttons, but don't let DefWndProc() do it
         * either.  It will be erased in xxxBNPaint().
         */
        return (LONG)TRUE;

    case WM_PRINTCLIENT:
        xxxBNPaint(pbutn, (HDC)wParam);
        break;

    case WM_PAINT:

        /*
         * If wParam != NULL, then this is a subclassed paint.
         */
        if ((hdc = (HDC)wParam) == NULL)
            hdc = NtUserBeginPaint(hwnd, &ps);

        if (IsVisible(pwnd))
            xxxBNPaint(pbutn, hdc);

        if (!wParam)
            NtUserEndPaint(hwnd, &ps);
        break;

    case WM_SETFOCUS:
        BUTTONSTATE(pbutn) |= BST_FOCUS;
        if ((hdc = xxxBNGetDC(pbutn, NULL)) != NULL) {
            xxxBNDrawText(pbutn, hdc, DBT_FOCUS, FALSE);

            BNReleaseDC(pbutn, hdc);
        }

        if (TestWF(pwnd, BFNOTIFY))
            xxxButtonNotifyParent(pwnd, BN_SETFOCUS);

        if (!(BUTTONSTATE(pbutn) & BST_INCLICK)) {
            switch (bsWnd) {
            case LOBYTE(BS_RADIOBUTTON):
            case LOBYTE(BS_AUTORADIOBUTTON):
                if (!(BUTTONSTATE(pbutn) & BST_DONTCLICK)) {
                    if (!(BUTTONSTATE(pbutn) & BST_CHECKMASK)) {
                        xxxButtonNotifyParent(pwnd, BN_CLICKED);
                    }
                }
                break;
            }
        }
        break;

    case WM_GETDLGCODE:
        switch (bsWnd) {
        case LOBYTE(BS_DEFPUSHBUTTON):
            wParam = DLGC_DEFPUSHBUTTON;
            break;

        case LOBYTE(BS_PUSHBUTTON):
        case LOBYTE(BS_PUSHBOX):
            wParam = DLGC_UNDEFPUSHBUTTON;
            break;

        case LOBYTE(BS_AUTORADIOBUTTON):
        case LOBYTE(BS_RADIOBUTTON):
            wParam = DLGC_RADIOBUTTON;
            break;

        case LOBYTE(BS_GROUPBOX):
            return (LONG)DLGC_STATIC;

        case LOBYTE(BS_CHECKBOX):
        case LOBYTE(BS_AUTOCHECKBOX):

            /*
             * If this is a char that is a '=/+', or '-', we want it
             */
            if (lParam && ((LPMSG)lParam)->message == WM_CHAR) {
                switch (wParam) {
                case TEXT('='):
                case TEXT('+'):
                case TEXT('-'):
                    wParam = DLGC_WANTCHARS;
                    break;

                default:
                    wParam = 0;
                }
            } else {
                wParam = 0;
            }
            break;

        default:
            wParam = 0;
        }
        return (LONG)(wParam | DLGC_BUTTON);

    case WM_CAPTURECHANGED:
        if (BUTTONSTATE(pbutn) & BST_CAPTURED) {
            // Unwittingly, we've been kicked out of capture,
            // so undepress etc.
            if (BUTTONSTATE(pbutn) & BST_MOUSE)
                SendMessageWorker(pwnd, BM_SETSTATE, FALSE, 0, FALSE);
            BUTTONSTATE(pbutn) &= ~(BST_CAPTURED | BST_MOUSE);
        }
        break;

    case WM_KILLFOCUS:

        /*
         * If we are losing the focus and we are in "capture mode", click
         * the button.  This allows tab and space keys to overlap for
         * fast toggle of a series of buttons.
         */
        if (BUTTONSTATE(pbutn) & BST_MOUSE) {

            /*
             * If for some reason we are killing the focus, and we have the
             * mouse captured, don't notify the parent we got clicked.  This
             * breaks Omnis Quartz otherwise.
             */
            SendMessageWorker(pwnd, BM_SETSTATE, FALSE, 0, FALSE);
        }

        xxxBNReleaseCapture(pbutn, TRUE);

        BUTTONSTATE(pbutn) &= ~BST_FOCUS;
        if ((hdc = xxxBNGetDC(pbutn, NULL)) != NULL) {
            xxxBNDrawText(pbutn, hdc, DBT_FOCUS, FALSE);

            BNReleaseDC(pbutn, hdc);
        }

        if (TestWF(pwnd, BFNOTIFY))
            xxxButtonNotifyParent(pwnd, BN_KILLFOCUS);

        /*
         * Since the bold border around the defpushbutton is done by
         * someone else, we need to invalidate the rect so that the
         * focus rect is repainted properly.
         */
        NtUserInvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_LBUTTONDBLCLK:

        /*
         * Double click messages are recognized for BS_RADIOBUTTON,
         * BS_USERBUTTON, and BS_OWNERDRAW styles.  For all other buttons,
         * double click is handled like a normal button down.
         */
        switch (bsWnd) {
        default:
            if (!TestWF(pwnd, BFNOTIFY))
                goto btnclick;

        case LOBYTE(BS_USERBUTTON):
        case LOBYTE(BS_RADIOBUTTON):
        case LOBYTE(BS_OWNERDRAW):
            xxxButtonNotifyParent(pwnd, BN_DOUBLECLICKED);
            break;
        }
        break;

    case WM_LBUTTONUP:
        if (BUTTONSTATE(pbutn) & BST_MOUSE) {
            xxxBNReleaseCapture(pbutn, TRUE);
        }
        break;

    case WM_MOUSEMOVE:
        if (!(BUTTONSTATE(pbutn) & BST_MOUSE)) {
            break;
        }

        /*
         *** FALL THRU **
         */
    case WM_LBUTTONDOWN:
btnclick:
        if (xxxBNSetCapture(pbutn, BST_MOUSE)) {
            _GetClientRect(pwnd, &rc);
            POINTSTOPOINT(pt, lParam);
            SendMessageWorker(pwnd, BM_SETSTATE, PtInRect(&rc, pt), 0, FALSE);
        }
        break;

    case WM_CHAR:
        if (BUTTONSTATE(pbutn) & BST_MOUSE)
            goto CallDWP;

        if (bsWnd != LOBYTE(BS_CHECKBOX) &&
            bsWnd != LOBYTE(BS_AUTOCHECKBOX))
            goto CallDWP;

        switch (wParam) {
        case TEXT('+'):
        case TEXT('='):
            wParam = 1;    // we must Set the check mark on.
            goto   SetCheck;

        case TEXT('-'):
            wParam = 0;    // Set the check mark off.
SetCheck:
            // Must notify only if the check status changes
            if ((WORD)(BUTTONSTATE(pbutn) & BST_CHECKMASK) != (WORD)wParam)
            {
                // We must check/uncheck only if it is AUTO
                if (bsWnd == LOBYTE(BS_AUTOCHECKBOX))
                {
                    if (xxxBNSetCapture(pbutn, 0))
                    {
                        SendMessageWorker(pwnd, BM_SETCHECK, wParam, 0, FALSE);

                        xxxBNReleaseCapture(pbutn, TRUE);
                    }
                }

                xxxButtonNotifyParent(pwnd, BN_CLICKED);
            }
            break;

        default:
            goto CallDWP;
        }
        break;

    case BM_CLICK:
        // Don't recurse into this code!
        if (BUTTONSTATE(pbutn) & BST_INBMCLICK)
            break;

        BUTTONSTATE(pbutn) |= BST_INBMCLICK;
        SendMessageWorker(pwnd, WM_LBUTTONDOWN, 0, 0, FALSE);
        SendMessageWorker(pwnd, WM_LBUTTONUP, 0, 0, FALSE);
        BUTTONSTATE(pbutn) &= ~BST_INBMCLICK;

        /*
         *** FALL THRU **
         */

    case WM_KEYDOWN:
        if (BUTTONSTATE(pbutn) & BST_MOUSE)
            break;

        if (wParam == VK_SPACE) {
            if (xxxBNSetCapture(pbutn, 0)) {
                SendMessageWorker(pwnd, BM_SETSTATE, TRUE, 0, FALSE);
            }
        } else {
            xxxBNReleaseCapture(pbutn, FALSE);
        }
        break;

    case WM_KEYUP:
    case WM_SYSKEYUP:
        if (BUTTONSTATE(pbutn) & BST_MOUSE) {
            goto CallDWP;
        }

        /*
         * Don't cancel the capture mode on the up of the tab in case the
         * guy is overlapping tab and space keys.
         */
        if (wParam == VK_TAB) {
            goto CallDWP;
        }

        /*
         * WARNING: pwnd is history after this call!
         */
        xxxBNReleaseCapture(pbutn, (wParam == VK_SPACE));

        if (message == WM_SYSKEYUP) {
            goto CallDWP;
        }
        break;

    case BM_GETSTATE:
        return (LONG)BUTTONSTATE(pbutn);

    case BM_SETSTATE:
        wOldState = (UINT)(BUTTONSTATE(pbutn) & BST_PUSHED);
        if (wParam) {
            BUTTONSTATE(pbutn) |= BST_PUSHED;
        } else {
            BUTTONSTATE(pbutn) &= ~BST_PUSHED;
        }

        if ((hdc = xxxBNGetDC(pbutn, &hbr)) != NULL) {
            if (bsWnd == LOBYTE(BS_USERBUTTON)) {
                xxxButtonNotifyParent(pwnd, (UINT)(wParam ? BN_PUSHED : BN_UNPUSHED));
            } else if (bsWnd == LOBYTE(BS_OWNERDRAW)) {
                if (wOldState != (UINT)(BUTTONSTATE(pbutn) & BST_PUSHED)) {
                    /*
                     * Only notify for drawing if state has changed..
                     */
                    xxxBNOwnerDraw(pbutn, hdc, ODA_SELECT);
                }
            } else {
                xxxButtonDrawNewState(pbutn, hdc, hbr, wOldState);
            }

            BNReleaseDC(pbutn, hdc);
        }
        if (wOldState != (BOOL)(BUTTONSTATE(pbutn) & BST_PUSHED)) {
            NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        }
        break;

    case BM_GETCHECK:
        return (LONG)(BUTTONSTATE(pbutn) & BST_CHECKMASK);

    case BM_SETCHECK:
        switch (bsWnd) {
        case LOBYTE(BS_RADIOBUTTON):
        case LOBYTE(BS_AUTORADIOBUTTON):
            if (wParam) {
                    SetWindowState(pwnd, WFTABSTOP);
            } else {
                    ClearWindowState(pwnd, WFTABSTOP);
            }

            /*
             *** FALL THRU **
             */
        case LOBYTE(BS_CHECKBOX):
        case LOBYTE(BS_AUTOCHECKBOX):
            if (wParam) {
                wParam = 1;
            }
            goto CheckIt;

        case LOBYTE(BS_3STATE):
        case LOBYTE(BS_AUTO3STATE):
            if (wParam > BST_INDETERMINATE) {
                wParam = BST_INDETERMINATE;
            }
CheckIt:
            if ((UINT)(BUTTONSTATE(pbutn) & BST_CHECKMASK) != (UINT)wParam) {
                BUTTONSTATE(pbutn) &= ~BST_CHECKMASK;
                BUTTONSTATE(pbutn) |= (UINT)wParam;

                if (!IsVisible(pwnd))
                    break;

                if ((hdc = xxxBNGetDC(pbutn, &hbr)) != NULL) {
                    if (TestWF(pwnd, BFPUSHLIKE)) {
                        xxxDrawButton(pbutn, hdc, PBF_PUSHABLE);
                    } else {
                        xxxButtonDrawCheck(pbutn, hdc, hbr);
                    }
                    BNReleaseDC(pbutn, hdc);
                }

                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
            }
            break;
        }
        break;

    case BM_SETSTYLE:
        NtUserAlterWindowStyle(hwnd, BS_TYPEMASK, (DWORD)wParam);

        if (lParam) {
            NtUserInvalidateRect(hwnd, NULL, TRUE);
        }
        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        break;

    case WM_SETTEXT:

        /*
         * In case the new group name is longer than the old name,
         * this paints over the old name before repainting the group
         * box with the new name.
         */
        if (bsWnd == LOBYTE(BS_GROUPBOX)) {
            hdc = xxxBNGetDC(pbutn, &hbr);
            if (hdc != NULL) {
                BNCalcRect(pwnd, hdc, &rc, CBR_GROUPTEXT, 0);
                NtUserInvalidateRect(hwnd, &rc, TRUE);

                pwndParent = REBASEPWND(pwnd, spwndParent);
                ThreadLock(pwnd->spwndParent, &tlpwndParent);
                PaintRect(HW(pwndParent), hwnd, hdc, hbr, &rc);
                ThreadUnlock(&tlpwndParent);

                BNReleaseDC(pbutn, hdc);
            }
        }

        lResult = _DefSetText(hwnd, (LPWSTR)lParam, (BOOL)fAnsi);

        NotifyWinEvent(EVENT_OBJECT_NAMECHANGE, hwnd, OBJID_WINDOW, INDEXID_CONTAINER);
        goto DoEnable;

        /*
         *** FALL THRU **
         */
    case WM_ENABLE:
        lResult = 0L;
DoEnable:
        RepaintButton(pbutn);
        return lResult;

    case WM_SETFONT:
        /*
         * wParam - handle to the font
         * lParam - if true, redraw else don't
         */
        BNSetFont(pbutn, (HFONT)wParam, (BOOL)(lParam != 0));
        break;

    case WM_GETFONT:
        return (LRESULT)pbutn->hFont;

    case BM_GETIMAGE:
    case BM_SETIMAGE:
        if (!IsValidImage(wParam, TestWF(pwnd, BFIMAGEMASK), IMAGE_BMMAX)) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid button image type");
        } else {
            HANDLE  hOld = pbutn->hImage;

            if (message == BM_SETIMAGE) {
                pbutn->hImage = (HANDLE)lParam;
                if (TestWF(pwnd, WFVISIBLE)) {
                    NtUserInvalidateRect(hwnd, NULL, TRUE);
                }
            }
            return (LRESULT)hOld;
        }
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        if (pbutn) {
            Unlock(&pbutn->spwnd);
            FreeLookasideEntry(&ButtonLookaside, pbutn);
        }
        NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);
        break;

    case WM_NCCREATE:
        // Borland's OBEX has a button with style 0x98; We didn't strip
        // these bits in win3.1 because we checked for 0x08.
        // Stripping these bits cause a GP Fault in OBEX.
        // For win3.1 guys, I use the old code to strip the style bits.
        //
        if (TestWF(pwnd, WFWIN31COMPAT)) {
            if(((!TestWF(pwnd, WFWIN40COMPAT)) &&
                (((LOBYTE(pwnd->style)) & (LOBYTE(~BS_LEFTTEXT))) == LOBYTE(BS_USERBUTTON))) ||
               (TestWF(pwnd, WFWIN40COMPAT) &&
               (bsWnd == LOBYTE(BS_USERBUTTON))))
            {
                // BS_USERBUTTON is no longer allowed for 3.1 and beyond.
                // Just turn to normal push button.
                NtUserAlterWindowStyle(hwnd, BS_TYPEMASK, 0);
                RIPMSG0(RIP_WARNING, "BS_USERBUTTON no longer supported");
            }
        }
        if (TestWF(pwnd,WEFRIGHT)) {
            NtUserAlterWindowStyle(hwnd, BS_RIGHT | BS_RIGHTBUTTON, BS_RIGHT | BS_RIGHTBUTTON);
        }
        goto CallDWP;

    case WM_INPUTLANGCHANGEREQUEST:

        //
        // #115190
        // If the window is one of controls on top of dialogbox,
        // let the parent dialog handle it.
        //
        if (TestwndChild(pwnd) && pwnd->spwndParent) {
            PWND pwndParent = REBASEPWND(pwnd, spwndParent);
            if (pwndParent) {
                PCLS pclsParent = REBASEALWAYS(pwndParent, pcls);

                UserAssert(pclsParent != NULL);
                if (pclsParent->atomClassName == gpsi->atomSysClass[ICLS_DIALOG]) {
                    RIPMSG0(RIP_VERBOSE, "Button: WM_INPUTLANGCHANGEREQUEST is sent to parent.\n");
                    return SendMessageWorker(pwndParent, message, wParam, lParam, FALSE);
                }
            }
        }
        goto CallDWP;

    case WM_UPDATEUISTATE:
        {
            DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
            if (ISBSTEXTOROD(pwnd)) {
                pbutn->fPaintKbdCuesOnly = TRUE;
                RepaintButton(pbutn);
                pbutn->fPaintKbdCuesOnly = FALSE;
            }
        }
        break;

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }

    return 0L;
}

/***************************************************************************\
\***************************************************************************/

LRESULT WINAPI ButtonWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_BUTTON))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, TRUE);

    return ButtonWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI ButtonWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_BUTTON))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, FALSE);

    return ButtonWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\cldib.c ===
/****************************** Module Header ******************************\
* Module Name: cldib.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*
* 09-26-95 ChrisWil  Ported dib-scale code.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Constants.
 */
#define FX1  65536   // 1.0 in fixed point


/*
 * Local Macros.
 */
#define BPPTOINDEX(bpp) ((UINT)(bpp) >> 3)

#define RGBQ(r,g,b) RGB(b, g, r)
#define RGBQR(rgb)  GetBValue(rgb)
#define RGBQG(rgb)  GetGValue(rgb)
#define RGBQB(rgb)  GetRValue(rgb)

#define Pel4(p,x)  (BYTE)(((x) & 1) ? (((LPBYTE)(p))[(x)/2] & 15) : (((LPBYTE)(p))[(x)/2] >> 4))
#define Pel8(p,x)  (BYTE)(((LPBYTE)(p))[(x)])
#define Pel16(p,x) (((WORD UNALIGNED *)(p))[(x)])
#define Pel24(p,x) (*(DWORD UNALIGNED *)((LPBYTE)(p) + (x) * 3))

/*
 * Function Typedefs.
 */
typedef VOID (*SCALEPROC)(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
typedef VOID (*INITPROC)(LPBITMAPINFOHEADER);

/*
 * Local Routines.
 */
BOOL     ScaleDIB(LPBITMAPINFOHEADER, LPVOID, LPBITMAPINFOHEADER, LPVOID);
VOID     InitDst8(LPBITMAPINFOHEADER);
VOID     Scale48(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
VOID     Scale88(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
VOID     Scale424(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
VOID     Scale824(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
VOID     Scale2424(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
BYTE     Map8(COLORREF);
COLORREF MixRGBI(LPDWORD, BYTE, BYTE,BYTE, BYTE, int, int);
COLORREF MixRGB(DWORD, DWORD, DWORD, DWORD, int, int);

/*
 * Globals needed for color-mapping of resources.
 */
SCALEPROC  ScaleProc[4][4] = {
    NULL,  Scale48, NULL, Scale424,
    NULL,  Scale88, NULL, Scale824,
    NULL,  NULL   , NULL, NULL,
    NULL,  NULL   , NULL, Scale2424
};

INITPROC InitDst[] = {
    NULL, InitDst8, NULL, NULL
};

BYTE rmap[256], gmap[256], bmap[256];


/***************************************************************************\
* SmartStretchDIBits
*
* calls GDI StretchDIBits, unless the stretch is 2:1 and the source
* is 4bpp, then is does it itself in a nice way.
*
* this optimization should just be put into GDI.
*
* can we change the passed bits? I assume we cant, could avoid a alloc
* if so.
*
\***************************************************************************/

int SmartStretchDIBits(
    HDC          hdc,
    int          xD,
    int          yD,
    int          dxD,
    int          dyD,
    int          xS,
    int          yS,
    int          dxS,
    int          dyS,
    LPVOID       lpBits,
    LPBITMAPINFO lpbi,
    UINT         wUsage,
    DWORD        rop)
{
    LPBYTE             lpBitsNew;
    UINT               bpp;
    RGBQUAD            rgb;
    LPBITMAPINFOHEADER lpbiNew = NULL;

    int i;

    /*
     * thunk to USER32
     */
    UserAssert(rop == SRCCOPY);
    UserAssert(wUsage == DIB_RGB_COLORS);
    UserAssert(xS == 0 && yS == 0);

    if ((GetDIBColorTable(hdc, 0, 1, &rgb) != 1) &&
        (dxD != dxS || dyD != dyS) &&           // 1:1 stretch just call GDI
        (dxD >= dxS/2) && (dyD >= dyS/2) &&     // less than 1:2 shrink call GDI
        (lpbi->bmiHeader.biCompression == 0) && // must be un-compressed
        (lpbi->bmiHeader.biBitCount == 4 ||     // input must be 4,8,24
         lpbi->bmiHeader.biBitCount == 8 ||
         lpbi->bmiHeader.biBitCount == 24)) {

        bpp = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

        bpp = (bpp > 8 ? 24 : 8);

        lpbiNew = (LPBITMAPINFOHEADER)UserLocalAlloc(0,
                 sizeof(BITMAPINFOHEADER) + (256 * sizeof(RGBQUAD)) +
                 (UINT)((((dxD * bpp) / 8) + 3) & ~3) * (UINT)dyD);

        if (lpbiNew) {

            *lpbiNew            = lpbi->bmiHeader;
            lpbiNew->biWidth    = dxD;
            lpbiNew->biHeight   = dyD;
            lpbiNew->biBitCount = (WORD)bpp;
            lpBitsNew = (LPBYTE)lpbiNew          +
                        sizeof(BITMAPINFOHEADER) +
                        (256 * sizeof(RGBQUAD));

            if (ScaleDIB((LPBITMAPINFOHEADER)lpbi,
                         (LPVOID)lpBits,
                         lpbiNew,
                         lpBitsNew)) {

                lpbi   = (LPBITMAPINFO)lpbiNew;
                lpBits = lpBitsNew;
                dxS    = dxD;
                dyS    = dyD;
            }
        }
    }

    i = StretchDIBits(hdc,
                      xD,
                      yD,
                      dxD,
                      dyD,
                      xS,
                      yS,
                      dxS,
                      dyS,
                      lpBits,
                      lpbi,
                      wUsage,
                      rop);

    if (lpbiNew)
        UserLocalFree(lpbiNew);

    return i;
}

/***************************************************************************\
* ScaleDIB
*
*   Parameters
*   ----------
*   lpbiSrc - BITMAPINFO of source.
*   lpSrc   - Input bits to crunch.
*   lpbiDst - BITMAPINFO of destination.
*   lpDst   - Output bits to crunch.
*
*
\***************************************************************************/

BOOL ScaleDIB(
    LPBITMAPINFOHEADER lpbiSrc,
    LPVOID             lpSrc,
    LPBITMAPINFOHEADER lpbiDst,
    LPVOID             lpDst)
{
    LPBYTE  pbSrc;
    LPBYTE  pbDst;
    LPDWORD pal;
    int     dxSrc;
    int     dySrc;
    int     dxDst;
    int     dyDst;
    int     iSrc;
    int     iDst;
    int     x0;
    int     y0;
    int     sdx;
    int     sdy;
    LONG    WidthBytesSrc;
    LONG    WidthBytesDst;

    if ((lpbiSrc->biCompression != BI_RGB) ||
        (lpbiDst->biCompression != BI_RGB)) {
        return FALSE;
    }

    iSrc = BPPTOINDEX(lpbiSrc->biBitCount);
    iDst = BPPTOINDEX(lpbiDst->biBitCount);

    if (ScaleProc[iSrc][iDst] == NULL)
        return FALSE;

    dxSrc = (int)lpbiSrc->biWidth;
    dySrc = (int)lpbiSrc->biHeight;

    dxDst = (int)lpbiDst->biWidth;
    dyDst = (int)lpbiDst->biHeight;

    WidthBytesDst = BitmapWidth(lpbiDst->biWidth, lpbiDst->biBitCount);
    WidthBytesSrc = BitmapWidth(lpbiSrc->biWidth, lpbiSrc->biBitCount);

    lpbiDst->biSizeImage = (WidthBytesDst * dyDst);

    pbSrc = (LPBYTE)lpSrc;
    pbDst = (LPBYTE)lpDst;

    pal = (LPDWORD)(lpbiSrc + 1);

    if (InitDst[iDst])
        InitDst[iDst](lpbiDst);

    if ((dxSrc == (dxDst * 2)) && (dySrc == (dyDst * 2))) {

        sdx = FX1 * 2;
        sdy = FX1 * 2;
        y0  = FX1 / 2;
        x0  = FX1 / 2;

    } else {

        sdx = (dxSrc - 1) * FX1 / (dxDst - 1);
        sdy = (dySrc - 1) * FX1 / (dyDst - 1);
        y0  = 0;
        x0  = 0;
    }

    /*
     * Make sure we don't croak on a bad bitmap since this can hose winlogon
     * if it's the desktop wallpaper.
     */
    try {
        ScaleProc[iSrc][iDst](pal,
                              pbSrc,
                              WidthBytesSrc,
                              x0,
                              y0,
                              sdx,
                              sdy,
                              pbDst,
                              WidthBytesDst,
                              dxDst,
                              dyDst);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* Scale48
*
*
\***************************************************************************/

VOID Scale48(
    LPDWORD pal,
    LPBYTE  pbSrc,
    LONG    WidthBytesSrc,
    int     x0,
    int     y0,
    int     sdx,
    int     sdy,
    LPBYTE  pbDst,
    LONG    WidthBytesDst,
    int     dxDst,
    int     dyDst)
{
    BYTE    b0;
    BYTE    b1;
    BYTE    b2;
    BYTE    b3;
    LPBYTE  pb;
    int     x;
    int     y;
    UINT    sx;
    UINT    sy;

    for (sy=y0, y=0; y < dyDst; y++, sy+=sdy) {

        pb = pbSrc + (WidthBytesSrc * (sy / FX1));

        for (sx=x0, x=0; x < dxDst; x++, sx+=sdx) {

            b0 = Pel4(pb, (sx / FX1));
            b1 = Pel4(pb, (sx / FX1) + 1);
            b2 = Pel4(pb + WidthBytesSrc, (sx / FX1));
            b3 = Pel4(pb + WidthBytesSrc, (sx / FX1) + 1);

            pbDst[x] = Map8(MixRGBI(pal, b0, b1, b2, b3, sx % FX1, sy % FX1));
        }

        pbDst += WidthBytesDst;
    }
}

/***************************************************************************\
* Scale88
*
*
\***************************************************************************/

VOID Scale88(
    LPDWORD pal,
    LPBYTE  pbSrc,
    LONG    WidthBytesSrc,
    int     x0,
    int     y0,
    int     sdx,
    int     sdy,
    LPBYTE  pbDst,
    LONG    WidthBytesDst,
    int     dxDst,
    int     dyDst)
{
    BYTE   b0;
    BYTE   b1;
    BYTE   b2;
    BYTE   b3;
    LPBYTE pb;
    int    x;
    int    y;
    UINT   sx;
    UINT   sy;

    for (sy=y0, y=0; y < dyDst; y++, sy+=sdy) {

        pb = pbSrc + (WidthBytesSrc * (sy / FX1));

        for (sx=x0, x=0; x < dxDst; x++, sx+=sdx) {

            b0 = Pel8(pb, (sx / FX1));
            b1 = Pel8(pb, (sx / FX1) + 1);
            b2 = Pel8(pb + WidthBytesSrc, (sx / FX1));
            b3 = Pel8(pb + WidthBytesSrc, (sx / FX1) + 1);

            pbDst[x] = Map8(MixRGBI(pal, b0, b1, b2, b3, sx % FX1, sy % FX1));
        }

        pbDst += WidthBytesDst;
    }
}

/***************************************************************************\
* Scale424
*
*
\***************************************************************************/

VOID Scale424(
    LPDWORD pal,
    LPBYTE  pbSrc,
    LONG    WidthBytesSrc,
    int     x0,
    int     y0,
    int     sdx,
    int     sdy,
    LPBYTE  pbDst,
    LONG    WidthBytesDst,
    int     dxDst,
    int     dyDst)
{
    BYTE     b0;
    BYTE     b1;
    BYTE     b2;
    BYTE     b3;
    LPBYTE   pb;
    int      x;
    int      y;
    UINT     sx;
    UINT     sy;
    COLORREF rgb;

    for (sy=y0, y=0; y < dyDst; y++, sy+=sdy) {

        pb = pbSrc + (WidthBytesSrc * (sy / FX1));

        for (sx=x0, x=0; x < dxDst; x++, sx+=sdx) {

            b0 = Pel4(pb, (sx / FX1));
            b1 = Pel4(pb, (sx / FX1) + 1);
            b2 = Pel4(pb + WidthBytesSrc, (sx / FX1));
            b3 = Pel4(pb + WidthBytesSrc, (sx / FX1) + 1);

            rgb = MixRGBI(pal, b0, b1, b2, b3, sx % FX1, sy % FX1);

            *pbDst++ = GetBValue(rgb);
            *pbDst++ = GetGValue(rgb);
            *pbDst++ = GetRValue(rgb);
        }

        pbDst += (WidthBytesDst - (dxDst * 3));
    }
}

/***************************************************************************\
* Scale824
*
*
\***************************************************************************/

VOID Scale824(
    LPDWORD pal,
    LPBYTE  pbSrc,
    LONG    WidthBytesSrc,
    int     x0,
    int     y0,
    int     sdx,
    int     sdy,
    LPBYTE  pbDst,
    LONG    WidthBytesDst,
    int     dxDst,
    int     dyDst)
{
    BYTE     b0;
    BYTE     b1;
    BYTE     b2;
    BYTE     b3;
    LPBYTE   pb;
    int      x;
    int      y;
    UINT     sx;
    UINT     sy;
    COLORREF rgb;

    for (sy=y0, y=0; y < dyDst; y++, sy+=sdy) {

        pb = pbSrc + (WidthBytesSrc * (sy / FX1));

        for (sx=x0, x=0; x < dxDst; x++, sx+=sdx) {

            b0 = Pel8(pb, (sx / FX1));
            b1 = Pel8(pb, (sx / FX1) + 1);
            b2 = Pel8(pb + WidthBytesSrc, (sx / FX1));
            b3 = Pel8(pb + WidthBytesSrc, (sx / FX1) + 1);

            rgb = MixRGBI(pal, b0, b1, b2, b3, sx % FX1, sy % FX1);

            *pbDst++ = GetBValue(rgb);
            *pbDst++ = GetGValue(rgb);
            *pbDst++ = GetRValue(rgb);
        }

        pbDst += (WidthBytesDst - (dxDst * 3));
    }
}

/***************************************************************************\
* Scale2424
*
*
\***************************************************************************/

VOID Scale2424(
    LPDWORD pal,
    LPBYTE  pbSrc,
    LONG    WidthBytesSrc,
    int     x0,
    int     y0,
    int     sdx,
    int     sdy,
    LPBYTE  pbDst,
    LONG    WidthBytesDst,
    int     dxDst,
    int     dyDst)
{
    DWORD    bgr0;
    DWORD    bgr1;
    DWORD    bgr2;
    DWORD    bgr3;
    LPBYTE   pb;
    int      x;
    int      y;
    UINT     sx;
    UINT     sy;
    COLORREF rgb;

    UNREFERENCED_PARAMETER(pal);

    for (sy=y0, y=0; y < dyDst; y++, sy+=sdy) {

        pb = pbSrc + (WidthBytesSrc * (sy / FX1));

        for (sx=x0, x=0; x < dxDst; x++, sx+=sdx) {

            bgr0 = Pel24(pb, (sx / FX1));
            bgr1 = Pel24(pb, (sx / FX1) + 1);
            bgr2 = Pel24(pb + WidthBytesSrc, (sx / FX1));
            bgr3 = Pel24(pb + WidthBytesSrc, (sx / FX1) + 1);

            rgb = MixRGB(bgr0, bgr1, bgr2, bgr3, sx % FX1, sy % FX1);

            *pbDst++ = GetBValue(rgb);
            *pbDst++ = GetGValue(rgb);
            *pbDst++ = GetRValue(rgb);
        }

        pbDst += (WidthBytesDst - (dxDst * 3));
    }
}

/***************************************************************************\
* MixRGB
*
*   r0  x   r1
*   y   *
*   r2  r3
*
* Note: inputs are RGBQUADs, output is a COLORREF.
*
\***************************************************************************/

COLORREF MixRGB(
    DWORD r0,
    DWORD r1,
    DWORD r2,
    DWORD r3,
    int   x,
    int   y)
{
    int r;
    int g;
    int b;

    if (x == 0 && y == 0) {

        r = RGBQR(r0);
        g = RGBQG(r0);
        b = RGBQB(r0);

    } else if (x == 0) {

        r = ((FX1-y) * RGBQR(r0) + y * RGBQR(r2))/FX1;
        g = ((FX1-y) * RGBQG(r0) + y * RGBQG(r2))/FX1;
        b = ((FX1-y) * RGBQB(r0) + y * RGBQB(r2))/FX1;
    }
    else if (y == 0)
    {
        r = ((FX1-x) * RGBQR(r0) + x * RGBQR(r1))/FX1;
        g = ((FX1-x) * RGBQG(r0) + x * RGBQG(r1))/FX1;
        b = ((FX1-x) * RGBQB(r0) + x * RGBQB(r1))/FX1;
    }
    else if (x == FX1/2 && y == FX1/2)
    {
        r = (RGBQR(r0) + RGBQR(r1) + RGBQR(r2) + RGBQR(r3))/4;
        g = (RGBQG(r0) + RGBQG(r1) + RGBQG(r2) + RGBQG(r3))/4;
        b = (RGBQB(r0) + RGBQB(r1) + RGBQB(r2) + RGBQB(r3))/4;
    }
    else
    {
        r =((ULONG)RGBQR(r0) * (FX1-x) / FX1 * (FX1-y) + (ULONG)RGBQR(r1) * x / FX1 * (FX1-y) +
            (ULONG)RGBQR(r2) * (FX1-x) / FX1 * y       + (ULONG)RGBQR(r3) * x / FX1 * y       )/FX1;

        g =((ULONG)RGBQG(r0) * (FX1-x) / FX1 * (FX1-y) + (ULONG)RGBQG(r1) * x / FX1 * (FX1-y) +
            (ULONG)RGBQG(r2) * (FX1-x) / FX1 * y       + (ULONG)RGBQG(r3) * x / FX1 * y       )/FX1;

        b =((ULONG)RGBQB(r0) * (FX1-x) / FX1 * (FX1-y) + (ULONG)RGBQB(r1) * x / FX1 * (FX1-y) +
            (ULONG)RGBQB(r2) * (FX1-x) / FX1 * y       + (ULONG)RGBQB(r3) * x / FX1 * y       )/FX1;
    }

    return RGB(r,g,b);
}

/***************************************************************************\
* MixRGBI
*
*
\***************************************************************************/

_inline COLORREF MixRGBI(
    LPDWORD pal,
    BYTE    b0,
    BYTE    b1,
    BYTE    b2,
    BYTE    b3,
    int     x,
    int     y)
{
    if (((b0 == b1) && (b1 == b2) && (b2 == b3)) || ((x == 0) && (y == 0)))
        return RGBX(pal[b0]);
    else
        return MixRGB(pal[b0], pal[b1], pal[b2], pal[b3], x, y);
}

/***************************************************************************\
* InitDst8
*
*
\***************************************************************************/

_inline VOID InitDst8(
    LPBITMAPINFOHEADER lpbi)
{
    int     r;
    int     g;
    int     b;
    LPDWORD pdw;

    pdw = (LPDWORD)(lpbi + 1);
    lpbi->biClrUsed = 6*6*6;

    for (r=0; r < 6; r++) {

        for (g=0; g < 6; g++) {

            for (b=0; b < 6; b++) {
                *pdw++ = RGBQ((r * 255) / 5, (g * 255) / 5, (b * 255) / 5);
            }
        }
    }

    for (b=0; b < 256; b++) {
        bmap[b] = (b * 5 + 128) / 255;
        gmap[b] = 6 * bmap[b];
        rmap[b] = 36 * bmap[b];
    }
}

/***************************************************************************\
* Map8
*
*
\***************************************************************************/

_inline BYTE Map8(
    COLORREF rgb)
{
    return rmap[GetRValue(rgb)] +
           gmap[GetGValue(rgb)] +
           bmap[GetBValue(rgb)];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\callback.c ===
/****************************** Module Header ******************************\
* Module Name: callback.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager callback related functions
*
* Created: 11/11/91 Sanford Staab
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* DoCallback
*
* Description:
* Performs a synchronous callback to the given instance's callback proc.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
HDDEDATA DoCallback(
PCL_INSTANCE_INFO pcii,
WORD wType,
WORD wFmt,
HCONV hConv,
HSZ hsz1,
HSZ hsz2,
HDDEDATA hData,
ULONG_PTR dw1,
ULONG_PTR dw2)
{
    HDDEDATA hDataRet;
    PCLIENTINFO pci;

    CheckDDECritIn;


    /*
     * Zombie conversations don't generate callbacks!
     */
    if (hConv && TypeFromHandle(hConv) == HTYPE_ZOMBIE_CONVERSATION) {
        return(0);
    }

    pci = GetClientInfo();
    pci->cInDDEMLCallback++;

    pcii->cInDDEMLCallback++;
    LeaveDDECrit;
    CheckDDECritOut;

    /*
     * Bug 246472 - joejo
     * fixup all DDE Callbacks since some apps make their callbacks
     * C-Style instead of PASCAL.
     */
    hDataRet = UserCallDDECallback(*pcii->pfnCallback, (UINT)wType, (UINT)wFmt, hConv, hsz1, hsz2,
            hData, dw1, dw2);
    
    EnterDDECrit;
    pcii->cInDDEMLCallback--;
    pci->cInDDEMLCallback--;

    if (!(pcii->afCmd & APPCLASS_MONITOR) && pcii->MonitorFlags & MF_CALLBACKS) {
        PEVENT_PACKET pep;

        pep = (PEVENT_PACKET)DDEMLAlloc(sizeof(EVENT_PACKET) - sizeof(DWORD) +
                sizeof(MONCBSTRUCT));
        if (pep != NULL) {

            pep->EventType =    MF_CALLBACKS;
            pep->fSense =       TRUE;
            pep->cbEventData =  sizeof(MONCBSTRUCT);

#define pcbs ((MONCBSTRUCT *)&pep->Data)
            pcbs->cb =      sizeof(MONCBSTRUCT);
            pcbs->dwTime =  NtGetTickCount();
            pcbs->hTask =   (HANDLE)LongToHandle( pcii->tid );
            pcbs->dwRet =   HandleToUlong(hDataRet);
            pcbs->wType =   wType;
            pcbs->wFmt =    wFmt;
            pcbs->hConv =   hConv;
            pcbs->hsz1 =    (HSZ)LocalToGlobalAtom(LATOM_FROM_HSZ(hsz1));
            pcbs->hsz2 =    (HSZ)LocalToGlobalAtom(LATOM_FROM_HSZ(hsz2));
            pcbs->hData =   hData;
            pcbs->dwData1 = dw1;
            pcbs->dwData2 = dw2;
            if (((wType == XTYP_CONNECT) || (wType == XTYP_WILDCONNECT)) && dw1) {
                RtlCopyMemory(&pcbs->cc, (PVOID)dw1, sizeof(CONVCONTEXT));
            }

            LeaveDDECrit;

                if (wType & XCLASS_DATA) {
                    if (hDataRet && hDataRet != CBR_BLOCK) {
                        pcbs->cbData = DdeGetData(hDataRet, (LPBYTE)pcbs->Data, 32, 0);
                    }
                } else if (hData) {
                    pcbs->cbData = DdeGetData(hData, (LPBYTE)pcbs->Data, 32, 0);
                }

                Event(pep);

            EnterDDECrit;

            GlobalDeleteAtom(LATOM_FROM_HSZ(pcbs->hsz1));
            GlobalDeleteAtom(LATOM_FROM_HSZ(pcbs->hsz2));
            DDEMLFree(pep);
#undef pcbs
        }
    }
    return (hDataRet);
}



/***************************************************************************\
* _ClientEventCallback
*
* Description:
* Called from the server side to perform event callbacks.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
DWORD _ClientEventCallback(
PCL_INSTANCE_INFO pcii,
PEVENT_PACKET pep)
{
    HDDEDATA hData;

    EnterDDECrit;

    switch (pep->EventType) {
    case 0: // MonitorFlags change event - everybody gets it
        pcii->MonitorFlags = pep->Data;
        break;

    case MF_CALLBACKS:
        {
            MONCBSTRUCT mcb;

            mcb = *((MONCBSTRUCT *)&pep->Data);
            mcb.hsz1 = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)mcb.hsz1));
            mcb.hsz2 = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)mcb.hsz2));
            if (    mcb.wType == XTYP_REGISTER ||
                    mcb.wType == XTYP_UNREGISTER) {
                mcb.hsz2 = INST_SPECIFIC_HSZ_FROM_LATOM((LATOM)(ULONG_PTR)mcb.hsz2);
            }
            hData = InternalCreateDataHandle(pcii, (LPSTR)&mcb,
                    pep->cbEventData, 0,
                    HDATA_NOAPPFREE | HDATA_READONLY | HDATA_EXECUTE, 0, 0);
            if (hData) {
                DoCallback(pcii, (WORD)XTYP_MONITOR, 0, 0, 0, 0, hData, 0L,
                        pep->EventType);
                InternalFreeDataHandle((HDDEDATA)hData, TRUE);
                DeleteAtom(LATOM_FROM_HSZ(mcb.hsz1));
                DeleteAtom(LATOM_FROM_HSZ(mcb.hsz2));
            }
        }
        break;

    case MF_LINKS:
        {
            MONLINKSTRUCT ml;

            ml = *((MONLINKSTRUCT *)&pep->Data);
            ml.hszSvc = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)ml.hszSvc));
            ml.hszTopic = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)ml.hszTopic));
            ml.hszItem = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)ml.hszItem));
            hData = InternalCreateDataHandle(pcii, (LPSTR)&ml,
                    pep->cbEventData, 0,
                    HDATA_NOAPPFREE | HDATA_READONLY | HDATA_EXECUTE, 0, 0);
            if (hData) {
                DoCallback(pcii, (WORD)XTYP_MONITOR, 0, 0, 0, 0, hData, 0L,
                        pep->EventType);
                InternalFreeDataHandle((HDDEDATA)hData, TRUE);
                DeleteAtom(LATOM_FROM_HSZ(ml.hszSvc));
                DeleteAtom(LATOM_FROM_HSZ(ml.hszTopic));
                DeleteAtom(LATOM_FROM_HSZ(ml.hszItem));
            }
        }
        break;

    case MF_CONV:
        {
            MONCONVSTRUCT mc;

            mc = *((MONCONVSTRUCT *)&pep->Data);
            mc.hszSvc = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)mc.hszSvc));
            mc.hszTopic = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)mc.hszTopic));
            hData = InternalCreateDataHandle(pcii, (LPSTR)&mc,
                    pep->cbEventData, 0,
                    HDATA_NOAPPFREE | HDATA_READONLY | HDATA_EXECUTE, 0, 0);
            if (hData) {
                DoCallback(pcii, (WORD)XTYP_MONITOR, 0, 0, 0, 0, hData, 0L,
                        pep->EventType);
                InternalFreeDataHandle((HDDEDATA)hData, TRUE);
                DeleteAtom(LATOM_FROM_HSZ(mc.hszSvc));
                DeleteAtom(LATOM_FROM_HSZ(mc.hszTopic));
            }
        }
        break;

    case MF_HSZ_INFO:
        if (!(pcii->flags & IIF_UNICODE)) {
            LPSTR pszAnsi;
            /*
             * Translate HSZ string back into ANSI
             */
            if (WCSToMB(((PMONHSZSTRUCT)&pep->Data)->str,
                    ((int)pep->cbEventData - (int)((PMONHSZSTRUCT)&pep->Data)->cb) / sizeof(WCHAR),
                    &pszAnsi,
                    (int)pep->cbEventData - (int)((PMONHSZSTRUCT)&pep->Data)->cb,
                    TRUE)) {
                strcpy(((PMONHSZSTRUCTA)&pep->Data)->str, pszAnsi);
                UserLocalFree(pszAnsi);
            }
            ((PMONHSZSTRUCT)&pep->Data)->cb = sizeof(MONHSZSTRUCTA);
        }
        // fall through
    case MF_SENDMSGS:
    case MF_POSTMSGS:
        if (pep->EventType == MF_POSTMSGS) {
            PMONMSGSTRUCT pmms = (PMONMSGSTRUCT)&pep->Data;
            BYTE buf[32];

            /*
             * We may need to translate the Execute string to/from
             * UNICODE depending on what type of monitor this is
             * going to.
             */
            if (pmms->wMsg == WM_DDE_EXECUTE) {
                BOOL fUnicodeText;
                int flags;

                flags = (IS_TEXT_UNICODE_UNICODE_MASK |
                        IS_TEXT_UNICODE_REVERSE_MASK |
                        (IS_TEXT_UNICODE_NOT_UNICODE_MASK &
                        (~IS_TEXT_UNICODE_ILLEGAL_CHARS)) |
                        IS_TEXT_UNICODE_NOT_ASCII_MASK);
#ifdef ISTEXTUNICODE_WORKS
                fUnicodeText = RtlIsTextUnicode(pmms->dmhd.Data,
                        min(32, pmms->dmhd.cbData), &flags);
#else
                fUnicodeText = (*(LPSTR)pmms->dmhd.Data == '\0');
#endif

                if (pcii->flags & IIF_UNICODE && !fUnicodeText) {
                    /* Ascii->UNICODE */
                    RtlMultiByteToUnicodeN((LPWSTR)buf, 32, NULL,
                            (LPSTR)&pmms->dmhd.Data,
                            min(32, pmms->dmhd.cbData));
                    RtlCopyMemory(&pmms->dmhd.Data, buf, 32);
                } else if (!(pcii->flags & IIF_UNICODE) && fUnicodeText) {
                    /* UNICODE->Ascii */
                    RtlUnicodeToMultiByteN((LPSTR)buf, 32, NULL,
                            (LPWSTR)&pmms->dmhd.Data,
                            min(32, pmms->dmhd.cbData));
                    RtlCopyMemory(&pmms->dmhd.Data, buf, 32);
                }
            }
        }
    case MF_ERRORS:
        hData = InternalCreateDataHandle(pcii, (LPSTR)&pep->Data,
                pep->cbEventData, 0,
                HDATA_NOAPPFREE | HDATA_READONLY | HDATA_EXECUTE, 0, 0);
        if (hData) {
            DoCallback(pcii, (WORD)XTYP_MONITOR, 0, 0, 0, 0, hData, 0L,
                    pep->EventType);
            InternalFreeDataHandle((HDDEDATA)hData, TRUE);
        }
        break;
    }

    LeaveDDECrit;
    return (0);
}



/***************************************************************************\
* EnableEnumProc
*
* Description:
* Helper function for applying pees->wCmd to each client and server
* DDEML window.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL EnableEnumProc(
HWND hwnd,
PENABLE_ENUM_STRUCT pees)
{
    PCONV_INFO pcoi;

    for (pcoi = (PCONV_INFO)GetWindowLongPtr(hwnd, GWLP_PCI);
                pcoi != NULL; pcoi = pcoi->next) {
        pcoi->cLocks++;
        *pees->pfRet |= SetEnableState(pcoi, pees->wCmd);
        if (pees->wCmd2) {
            /*
             * Only let ES_CHECKQUEUEONCE be done on one window but
             * don't stop the wCmd from getting to all the other
             * windows.
             */
            if (SetEnableState(pcoi, pees->wCmd2) &&
                    pees->wCmd2 == EC_CHECKQUEUEONCE) {
                pees->wCmd2 = 0;
            }
        }
        pcoi->cLocks--;
        if (pcoi->cLocks == 0 && pcoi->state & ST_FREE_CONV_RES_NOW) {
            FreeConversationResources(pcoi);
            break;
        }
    }
    return (TRUE);
}


/***************************************************************************\
* DdeEnableCallback (DDEML API)
*
* Description:
* Turns on and off asynchronous callbacks (BLOCKABLE).
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeEnableCallback, DWORD, idInst, HCONV, hConv, UINT, wCmd)
BOOL DdeEnableCallback(
DWORD idInst,
HCONV hConv,
UINT wCmd)
{
    BOOL fRet = FALSE;
    PCL_INSTANCE_INFO pcii;
    PCONV_INFO pcoi;
    ENABLE_ENUM_STRUCT ees;

    EnterDDECrit;

    pcii = (PCL_INSTANCE_INFO)ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    switch (wCmd) {
    case EC_QUERYWAITING:
    case EC_DISABLE:
    case EC_ENABLEONE:
    case EC_ENABLEALL:
        break;

    default:
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (hConv) {
        pcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
                HTYPE_CLIENT_CONVERSATION, InstFromHandle(idInst));
        if (pcoi == NULL) {
            pcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
                    HTYPE_SERVER_CONVERSATION, InstFromHandle(idInst));
        }
        if (pcoi == NULL) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            goto Exit;
        }
        pcoi->cLocks++;
        fRet = SetEnableState(pcoi, wCmd);
        switch (wCmd) {
        case EC_ENABLEALL:
        case EC_ENABLEONE:
            CheckForQueuedMessages(pcoi);
        }
        pcoi->cLocks--;
        if (pcoi->cLocks == 0 && pcoi->state & ST_FREE_CONV_RES_NOW) {
            FreeConversationResources(pcoi);
        }
    } else {
        if (wCmd == EC_ENABLEONE) {
            wCmd = EC_ENABLEONEOFALL;
        }
        switch (wCmd) {
        case EC_ENABLEONEOFALL:
            pcii->ConvStartupState = ST_BLOCKNEXT | ST_BLOCKALLNEXT;
            break;

        case EC_DISABLE:
            pcii->ConvStartupState = ST_BLOCKED;
            break;

        case EC_ENABLEALL:
            pcii->ConvStartupState = 0;
            break;
        }
        ees.pfRet = &fRet;
        ees.wCmd = (WORD)wCmd;
        switch (wCmd) {
        case EC_ENABLEALL:
            ees.wCmd2 = EC_CHECKQUEUE;
            break;

        case EC_ENABLEONEOFALL:
            ees.wCmd2 = EC_CHECKQUEUEONCE;
            break;

        default:
            ees.wCmd2 = 0;
        }
        EnumChildWindows(pcii->hwndMother, (WNDENUMPROC)EnableEnumProc,
                (LPARAM)&ees);
    }

Exit:
    LeaveDDECrit;
    return (fRet);
}



/***************************************************************************\
* SetEnableState
*
* Description:
* Sets the given conversation's enable state based on the EC_ flag
* given.
*
* Returns: fSuccess/fProcessed.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SetEnableState(
PCONV_INFO pcoi,
UINT wCmd)
{
    BOOL fRet = TRUE;

    switch (wCmd) {
    case EC_CHECKQUEUEONCE:
    case EC_CHECKQUEUE:
        fRet = CheckForQueuedMessages(pcoi);
        break;

    case EC_QUERYWAITING:
        fRet = !(pcoi->dmqOut == NULL ||
                (pcoi->dmqOut->next == NULL &&
                GetClientInfo()->CI_flags & CI_PROCESSING_QUEUE));
        break;

    case EC_DISABLE:
        pcoi->state |= ST_BLOCKED;
        pcoi->state &= ~(ST_BLOCKNEXT | ST_BLOCKALLNEXT);
        break;

    case EC_ENABLEONE:
        pcoi->state &= ~ST_BLOCKED;
        pcoi->state |= ST_BLOCKNEXT;
        break;

    case EC_ENABLEONEOFALL:
        pcoi->state &= ~ST_BLOCKED;
        pcoi->state |= (ST_BLOCKNEXT | ST_BLOCKALLNEXT);
        break;

    case EC_ENABLEALL:
        pcoi->state &= ~(ST_BLOCKED | ST_BLOCKNEXT | ST_BLOCKALLNEXT);
        break;

    default:
        return(FALSE);
    }
    return (fRet);
}




/***************************************************************************\
* _ClientGetDDEHookData
*
* Description:
* Callback from server to extract data from lParam and place it into
* the pdmhd for use by DDESPY apps. This does a very similar thing
* to the CopyDDEDataIn/Out apis but this only grabs a limited amount
* of the data suitable for posting to the DDESPY app(s). This should
* be merged with the Copy APIs eventually.
*
* History:
* 12-16-91 sanfords Created.
\***************************************************************************/
DWORD _ClientGetDDEHookData(
UINT message,
LPARAM lParam,
PDDEML_MSG_HOOK_DATA pdmhd)
{
    PBYTE pb;
    HANDLE hDDE;

    UnpackDDElParam(message, lParam, &pdmhd->uiLo, &pdmhd->uiHi);
    switch (message) {
    case WM_DDE_DATA:
    case WM_DDE_POKE:
    case WM_DDE_ADVISE:
        hDDE = (HANDLE)pdmhd->uiLo;
        break;

    case WM_DDE_EXECUTE:
        hDDE = (HANDLE)pdmhd->uiHi;
        break;

    case WM_DDE_ACK:
    case WM_DDE_REQUEST:
    case WM_DDE_UNADVISE:
    case WM_DDE_TERMINATE:
        pdmhd->cbData = 0;
        return (1);
    }

    pdmhd->cbData = (DWORD)UserGlobalSize(hDDE);
    if (pdmhd->cbData) {
        USERGLOBALLOCK(hDDE, pb);
        if (pb == NULL) {
            pdmhd->cbData = 0;
        } else {
            RtlCopyMemory(&pdmhd->Data, pb, min(pdmhd->cbData,
                    sizeof(DDEML_MSG_HOOK_DATA) -
                    FIELD_OFFSET(DDEML_MSG_HOOK_DATA, Data)));
            USERGLOBALUNLOCK(hDDE);
        }
    }
    return (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\clenum.c ===
/****************************** Module Header ******************************\
* Module Name: clenum
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* For enumeration functions
*
* 04-27-91 ScottLu Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define IEP_UNICODE 0x1 // Convert Atom to unicode string (vs ANSI)
#define IEP_ENUMEX 0x2 // Pass lParam back to callback function (vs no lParam)

HWND *phwndCache = NULL;


/***************************************************************************\
* InternalEnumWindows
*
* Calls server and gets back a window list. This list is enumerated, for each
* window the callback address is called (into the application), until either
* end-of-list is reached or FALSE is return ed. lParam is passed into the
* callback function for app reference.
*
*
* If any windows are returned (cHwnd > 0) the caller is responsible for
* freeing the window buffer when done with the list
*
* 04-27-91 ScottLu Created.
\***************************************************************************/
DWORD BuildHwndList(
    HDESK hdesk,
    HWND hwndNext,
    BOOL fEnumChildren,
    DWORD idThread,
    HWND **pphwndFirst)
{
    UINT cHwnd;
    HWND *phwndFirst;
    NTSTATUS Status;
    int cTries;

    /*
     * Allocate a buffer to hold the names.
     */
    cHwnd = 64;
    phwndFirst = (HWND *)InterlockedExchangePointer(&(PVOID)phwndCache, 0);
    if (phwndFirst == NULL) {
        phwndFirst = UserLocalAlloc(0, cHwnd * sizeof(HWND));
        if (phwndFirst == NULL) {
            return 0;
        }
    }

    Status = NtUserBuildHwndList(hdesk,
                                 hwndNext,
                                 fEnumChildren,
                                 idThread,
                                 cHwnd,
                                 phwndFirst,
                                 &cHwnd);

    /*
     * If the buffer wasn't big enough, reallocate the buffer and try again.
     */
    cTries = 0;
    while (Status == STATUS_BUFFER_TOO_SMALL) {
        UserLocalFree(phwndFirst);

        /*
         * If we can't seem to get it right, call it quits.
         */
        if (cTries++ == 10) {
            return 0;
        }

        phwndFirst = UserLocalAlloc(0, cHwnd * sizeof(HWND));
        if (phwndFirst == NULL) {
            return 0;
        }

        Status = NtUserBuildHwndList(hdesk,
                                     hwndNext,
                                     fEnumChildren,
                                     idThread,
                                     cHwnd,
                                     phwndFirst,
                                     &cHwnd);
    }

    if (!NT_SUCCESS(Status) || cHwnd <= 1) {
        UserLocalFree(phwndFirst);
        return 0;
    }

    *pphwndFirst = phwndFirst;
    return cHwnd - 1;
}

BOOL InternalEnumWindows(
    HDESK hdesk,
    HWND hwnd,
    WNDENUMPROC lpfn,
    LPARAM lParam,
    DWORD idThread,
    BOOL fEnumChildren)
{
    UINT i;
    UINT cHwnd;
    HWND *phwndT;
    HWND *phwndFirst;
    BOOL fSuccess = TRUE;

    /*
     * Get the hwnd list. It is returned in a block of memory allocated with
     * UserLocalAlloc.
     */
    if ((cHwnd = BuildHwndList(hdesk, hwnd, fEnumChildren, idThread,
            &phwndFirst)) == -1) {
        return FALSE;
    }

    /*
     * In Win 3.1 it was not an error if there were no windows in the thread.
     */
    if (cHwnd == 0) {
        if (idThread == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }


    /*
     * Loop through the windows, call the function pointer back for each
     * one. End loop if either FALSE is return ed or the end-of-list is
     * reached.
     */
    phwndT = phwndFirst;
    for (i = 0; i < cHwnd; i++) {

        /*
         * Call ValidateHwnd instead of RevalidateHwnd so that restricted
         * processes don't see handles they aren't supposed to.
         */
        if (ValidateHwnd(*phwndT)) {
            if (!(fSuccess = (*lpfn)(*phwndT, lParam))) {
                break;
            }
        }
        phwndT++;
    }

    /*
     * Free up buffer and return status - TRUE if entire list was enumerated,
     * FALSE otherwise.
     */
    phwndT = (HWND *)InterlockedExchangePointer(&(PVOID)phwndCache, phwndFirst);
    if (phwndT != NULL) {
        UserLocalFree(phwndT);
    }

    return fSuccess;
}


/***************************************************************************\
* EnumWindows
*
* Enumerates all top-level windows. Calls back lpfn with each hwnd until
* either end-of-list or FALSE is return ed. lParam is passed into callback
* function for app reference.
*
* 04-27-91 ScottLu Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, EnumWindows, WNDENUMPROC, lpfn, LPARAM, lParam)
BOOL WINAPI EnumWindows(
    WNDENUMPROC lpfn,
    LPARAM lParam)
{
    return InternalEnumWindows(NULL, NULL, lpfn, lParam, 0L, FALSE);
}

/***************************************************************************\
* EnumChildWindows
*
* Enumerates all children of the passed in window. Calls back lpfn with each
* hwnd until either end-of-list or FALSE is return ed. lParam is passed into
* callback function for app reference.
*
* 04-27-91 ScottLu Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, EnumChildWindows, HWND, hwnd, WNDENUMPROC, lpfn, LPARAM, lParam)
BOOL WINAPI EnumChildWindows(
    HWND hwnd,
    WNDENUMPROC lpfn,
    LPARAM lParam)
{
    return InternalEnumWindows(NULL, hwnd, lpfn, lParam, 0L, TRUE);
}

/***************************************************************************\
* EnumThreadWindows
*
* Enumerates all top level windows created by idThread. Calls back lpfn with
* each hwnd until either end-of-list or FALSE is return ed. lParam is passed
* into callback function for app reference.
*
* 06-23-91 ScottLu Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumThreadWindows, DWORD, idThread, WNDENUMPROC, lpfn, LPARAM, lParam)
BOOL EnumThreadWindows(
    DWORD idThread,
    WNDENUMPROC lpfn,
    LPARAM lParam)
{
    return InternalEnumWindows(NULL, NULL, lpfn, lParam, idThread, FALSE);
}

/***************************************************************************\
* EnumDesktopWindows
*
* Enumerates all top level windows on the desktop specified by hdesk.
* Calls back lpfn with each hwnd until either end-of-list or FALSE
* is returned. lParam is passed into callback function for app reference.
*
* 10-10-94 JimA     Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDesktopWindows, HDESK, hdesk, WNDENUMPROC, lpfn, LPARAM, lParam)
BOOL EnumDesktopWindows(
    HDESK hdesk,
    WNDENUMPROC lpfn,
    LPARAM lParam)
{
    return InternalEnumWindows(hdesk, NULL, lpfn, lParam, 0, FALSE);
}




/***************************************************************************\
* InternalEnumProps
*
* Calls server and gets back a list of props for the specified window.
* The callback address is called (into the application), until either
* end-of-list is reached or FALSE is return ed.
* lParam is passed into the callback function for app reference when
* IEP_ENUMEX is set. Atoms are turned into UNICODE string if IEP_UNICODE
* is set.
*
* 22-Jan-1992 JohnC Created.
\***************************************************************************/

#define MAX_ATOM_SIZE 512
#define ISSTRINGATOM(atom)     ((WORD)(atom) >= 0xc000)

INT InternalEnumProps(
    HWND hwnd,
    PROPENUMPROC lpfn,
    LPARAM lParam,
    UINT flags)
{
    DWORD ii;
    DWORD cPropSets;
    PPROPSET pPropSet;
    WCHAR awch[MAX_ATOM_SIZE];
    PVOID pKey;
    INT iRetVal;
    DWORD cchName;
    NTSTATUS Status;
    int cTries;

    /*
     * Allocate a buffer to hold the names.
     */
    cPropSets = 32;
    pPropSet = UserLocalAlloc(0, cPropSets * sizeof(PROPSET));
    if (pPropSet == NULL) {
        return -1;
    }

    Status = NtUserBuildPropList(hwnd, cPropSets, pPropSet, &cPropSets);

    /*
     * If the buffer wasn't big enough, reallocate the buffer and try again.
     */
    cTries = 0;
    while (Status == STATUS_BUFFER_TOO_SMALL) {
        UserLocalFree(pPropSet);

        /*
         * If we can't seem to get it right, call it quits.
         */
        if (cTries++ == 10) {
            return -1;
        }

        pPropSet = UserLocalAlloc(0, cPropSets * sizeof(PROPSET));
        if (pPropSet == NULL) {
            return -1;
        }

        Status = NtUserBuildPropList(hwnd, cPropSets, pPropSet, &cPropSets);
    }

    if (!NT_SUCCESS(Status)) {
        UserLocalFree(pPropSet);
        return -1;
    }

    for (ii = 0; ii < cPropSets; ii++) {
        if (ISSTRINGATOM(pPropSet[ii].atom)) {
            pKey = (PVOID)awch;
            if (flags & IEP_UNICODE) {
                cchName = GlobalGetAtomNameW(pPropSet[ii].atom,
                                             (LPWSTR)pKey,
                                             MAX_ATOM_SIZE);
            } else {
                cchName = GlobalGetAtomNameA(pPropSet[ii].atom,
                                             (LPSTR)pKey,
                                             sizeof(awch));
            }

            /*
             * If cchName is zero, we must assume that the property belongs
             * to another process. Because we can't get the name, just skip
             * it.
             */
            if (cchName == 0) {
                continue;
            }
        } else {
            pKey = (PVOID)pPropSet[ii].atom;
        }

        if (flags & IEP_ENUMEX) {
            iRetVal = (*(PROPENUMPROCEX)lpfn)(hwnd, pKey,
                    pPropSet[ii].hData, lParam);
        } else {
            iRetVal = (*lpfn)(hwnd, pKey, pPropSet[ii].hData);
        }

        if (!iRetVal) {
            break;
        }
    }

    UserLocalFree(pPropSet);

    return iRetVal;
}


/***************************************************************************\
* EnumProps
*
* This function enumerates all entries in the property list of the specified
* window. It enumerates the entries by passing them, one by one, to the
* callback function specified by lpEnumFunc. EnumProps continues until the
* last entry is enumerated or the callback function return s zero.
*
* 22-Jan-1992 JohnC Created.
\***************************************************************************/
FUNCLOG2(LOG_GENERAL, INT, WINAPI, EnumPropsA, HWND, hwnd, PROPENUMPROCA, lpfn)
INT WINAPI EnumPropsA(
    HWND hwnd,
    PROPENUMPROCA lpfn)
{
    return InternalEnumProps(hwnd, (PROPENUMPROC)lpfn, 0, 0);
}



FUNCLOG2(LOG_GENERAL, INT, WINAPI, EnumPropsW, HWND, hwnd, PROPENUMPROCW, lpfn)
INT WINAPI EnumPropsW(
    HWND hwnd,
    PROPENUMPROCW lpfn)
{
    return InternalEnumProps(hwnd, (PROPENUMPROC)lpfn, 0, IEP_UNICODE);
}

/***************************************************************************\
* EnumPropsEx
*
* This function enumerates all entries in the property list of the specified
* window. It enumerates the entries by passing them, one by one, to the
* callback function specified by lpEnumFunc. EnumProps continues until the
* last entry is enumerated or the callback function return s zero.
*
* 22-Jan-1992 JohnC Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, EnumPropsExA, HWND, hwnd, PROPENUMPROCEXA, lpfn, LPARAM, lParam)
BOOL WINAPI EnumPropsExA(
    HWND hwnd,
    PROPENUMPROCEXA lpfn,
    LPARAM lParam)
{
    return InternalEnumProps(hwnd, (PROPENUMPROC)lpfn, lParam, IEP_ENUMEX);
}


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, EnumPropsExW, HWND, hwnd, PROPENUMPROCEXW, lpfn, LPARAM, lParam)
BOOL WINAPI EnumPropsExW(
    HWND hwnd,
    PROPENUMPROCEXW lpfn,
    LPARAM lParam)
{
    return InternalEnumProps(hwnd, (PROPENUMPROC)lpfn, lParam, IEP_UNICODE|IEP_ENUMEX);
}



BOOL InternalEnumObjects(
    HWINSTA hwinsta,
    NAMEENUMPROCW lpfn,
    LPARAM lParam,
    BOOL fAnsi)
{
    PNAMELIST pNameList;
    DWORD i;
    UINT cbData;
    PWCHAR pwch;
    PCHAR pch;
    CHAR achTmp[MAX_PATH];
    BOOL iRetVal;
    NTSTATUS Status;
    int cTries;

    /*
     * Allocate a buffer to hold the names. The size of the buffer is
     * determined by the maximum size for a window station name defined
     * in ntstubs.c.
     */
    cbData = STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);
    pNameList = UserLocalAlloc(0, cbData);
    if (pNameList == NULL) {
        return FALSE;
    }

    Status = NtUserBuildNameList(hwinsta, cbData, pNameList, &cbData);

    /*
     * If the buffer wasn't big enough, reallocate the buffer and try again.
     */
    cTries = 0;
    while (Status == STATUS_BUFFER_TOO_SMALL) {
        UserLocalFree(pNameList);

        /*
         * If we can't seem to get it right, call it quits.
         */
        if (cTries++ == 10) {
            return FALSE;
        }

        pNameList = UserLocalAlloc(0, cbData);
        if (pNameList == NULL) {
            return FALSE;
        }

        Status = NtUserBuildNameList(hwinsta, cbData, pNameList, &cbData);
    }

    if (!NT_SUCCESS(Status)) {
        UserLocalFree(pNameList);
        return FALSE;
    }

    pwch = pNameList->awchNames;
    pch = achTmp;

    for (i = 0; i < pNameList->cNames; i++) {
        if (fAnsi) {
            if (WCSToMB(pwch, -1, &pch, sizeof(achTmp), FALSE) ==
                    sizeof(achTmp)) {

                /*
                 * The buffer may have overflowed, so force it to be
                 * allocated.
                 */
                if (WCSToMB(pwch, -1, &pch, -1, TRUE) == 0) {
                    iRetVal = FALSE;
                    break;
                }
            }
            iRetVal = (*(NAMEENUMPROCA)lpfn)(pch, lParam);
            if (pch != achTmp) {
                UserLocalFree(pch);
                pch = achTmp;
            }
        } else {
            iRetVal = (*(NAMEENUMPROCW)lpfn)(pwch, lParam);
        }
        if (!iRetVal) {
            break;
        }

        pwch = pwch + wcslen(pwch) + 1;
    }

    UserLocalFree(pNameList);

    return iRetVal;
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, EnumWindowStationsA, WINSTAENUMPROCA, lpEnumFunc, LPARAM, lParam)
BOOL WINAPI EnumWindowStationsA(
    WINSTAENUMPROCA lpEnumFunc,
    LPARAM lParam)
{
    return InternalEnumObjects(NULL, (NAMEENUMPROCW)lpEnumFunc, lParam, TRUE);
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, EnumWindowStationsW, WINSTAENUMPROCW, lpEnumFunc, LPARAM, lParam)
BOOL WINAPI EnumWindowStationsW(
    WINSTAENUMPROCW lpEnumFunc,
    LPARAM lParam)
{
    return InternalEnumObjects(NULL, (NAMEENUMPROCW)lpEnumFunc, lParam, FALSE);
}



FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, EnumDesktopsA, HWINSTA, hwinsta, DESKTOPENUMPROCA, lpEnumFunc, LPARAM, lParam)
BOOL WINAPI EnumDesktopsA(
    HWINSTA hwinsta,
    DESKTOPENUMPROCA lpEnumFunc,
    LPARAM lParam)
{
    return InternalEnumObjects(hwinsta, (NAMEENUMPROCW)lpEnumFunc, lParam, TRUE);
}


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, EnumDesktopsW, HWINSTA, hwinsta, DESKTOPENUMPROCW, lpEnumFunc, LPARAM, lParam)
BOOL WINAPI EnumDesktopsW(
    HWINSTA hwinsta,
    DESKTOPENUMPROCW lpEnumFunc,
    LPARAM lParam)
{
    return InternalEnumObjects(hwinsta, (NAMEENUMPROCW)lpEnumFunc, lParam, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\classc.c ===
/****************************** Module Header ******************************\
* Module Name: classc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains
*
* History:
* 15-Dec-1993 JohnC      Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * These arrays are used by GetClassWord/Long.
 */

// !!! can't we get rid of this and just special case GCW_ATOM

CONST BYTE afClassDWord[] = {
     FIELD_SIZE(CLS, spicnSm),          // GCL_HICONSM       (-34)
     0,
     FIELD_SIZE(CLS, atomNVClassName),    // GCW_ATOM          (-32)
     0,
     0,
     0,
     0,
     0,
     FIELD_SIZE(CLS, style),            // GCL_STYLE         (-26)
     0,
     FIELD_SIZE(CLS, lpfnWndProc),      // GCL_WNDPROC       (-24)
     0,
     0,
     0,
     FIELD_SIZE(CLS, cbclsExtra),       // GCL_CBCLSEXTRA    (-20)
     0,
     FIELD_SIZE(CLS, cbwndExtra),       // GCL_CBWNDEXTRA    (-18)
     0,
     FIELD_SIZE(CLS, hModule),          // GCL_HMODULE       (-16)
     0,
     FIELD_SIZE(CLS, spicn),            // GCL_HICON         (-14)
     0,
     FIELD_SIZE(CLS, spcur),            // GCL_HCURSOR       (-12)
     0,
     FIELD_SIZE(CLS, hbrBackground),    // GCL_HBRBACKGROUND (-10)
     0,
     FIELD_SIZE(CLS, lpszMenuName)      // GCL_HMENUNAME      (-8)
};

CONST BYTE aiClassOffset[] = {
    FIELD_OFFSET(CLS, spicnSm),         // GCL_HICONSM
    0,
    FIELD_OFFSET(CLS, atomNVClassName), // GCW_ATOM
    0,
    0,
    0,
    0,
    0,
    FIELD_OFFSET(CLS, style),           // GCL_STYLE
    0,
    FIELD_OFFSET(CLS, lpfnWndProc),     // GCL_WNDPROC
    0,
    0,
    0,
    FIELD_OFFSET(CLS, cbclsExtra),      // GCL_CBCLSEXTRA
    0,
    FIELD_OFFSET(CLS, cbwndExtra),      // GCL_CBWNDEXTRA
    0,
    FIELD_OFFSET(CLS, hModule),         // GCL_HMODULE
    0,
    FIELD_OFFSET(CLS, spicn),           // GCL_HICON
    0,
    FIELD_OFFSET(CLS, spcur),           // GCL_HCURSOR
    0,
    FIELD_OFFSET(CLS, hbrBackground),   // GCL_HBRBACKGROUND
    0,
    FIELD_OFFSET(CLS, lpszMenuName)     // GCL_MENUNAME
};

/*
 * INDEX_OFFSET must refer to the first entry of afClassDWord[]
 */
#define INDEX_OFFSET GCLP_HICONSM


/***************************************************************************\
* GetClassData
*
* GetClassWord and GetClassLong are now identical routines because they both
* can return DWORDs.  This single routine performs the work for them both
* by using two arrays; afClassDWord to determine whether the result should be
* a UINT or a DWORD, and aiClassOffset to find the correct offset into the
* CLS structure for a given GCL_ or GCL_ index.
*
* History:
* 11-19-90 darrinm      Wrote.
\***************************************************************************/

ULONG_PTR _GetClassData(
    PCLS pcls,
    PWND pwnd,   // used for transition to kernel-mode for GCL_WNDPROC
    int index,
    BOOL bAnsi)
{
    KERNEL_ULONG_PTR dwData;
    DWORD dwCPDType = 0;

    index -= INDEX_OFFSET;

    if (index < 0) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return 0;
    }

    UserAssert(index >= 0);
    UserAssert(index < sizeof(afClassDWord));
    UserAssert(sizeof(afClassDWord) == sizeof(aiClassOffset));
    if (afClassDWord[index] == sizeof(DWORD)) {
        dwData = *(KPDWORD)(((KPBYTE)pcls) + aiClassOffset[index]);
    } else if (afClassDWord[index] == sizeof(KERNEL_ULONG_PTR)) {
        dwData = *(KPKERNEL_ULONG_PTR)(((KPBYTE)pcls) + aiClassOffset[index]);
    } else {
        dwData = (DWORD)*(KPWORD)(((KPBYTE)pcls) + aiClassOffset[index]);
    }

    index += INDEX_OFFSET;

    /*
     * If we're returning an icon or cursor handle, do the reverse
     * mapping here.
     */
    switch(index) {
    case GCLP_MENUNAME:
        if (IS_PTR(pcls->lpszMenuName)) {
            /*
             * The Menu Name is a real string: return the client-side address.
             * (If the class was registered by another app this returns an
             * address in that app's addr. space, but it's the best we can do)
             */
            dwData = bAnsi ?
                    (ULONG_PTR)pcls->lpszClientAnsiMenuName :
                    (ULONG_PTR)pcls->lpszClientUnicodeMenuName;
        }
        break;

    case GCLP_HICON:
    case GCLP_HCURSOR:
    case GCLP_HICONSM:
        /*
         * We have to go to the kernel to convert the pcursor to a handle because
         * cursors are allocated out of POOL, which is not accessable from the client.
         */
        if (dwData) {
            dwData = NtUserCallHwndParam(PtoH(pwnd), index, SFI_GETCLASSICOCUR);
        }
        break;

    case GCLP_WNDPROC:
        {

        /*
         * Always return the client wndproc in case this is a server
         * window class.
         */

        if (pcls->CSF_flags & CSF_SERVERSIDEPROC) {
            dwData = MapServerToClientPfn(dwData, bAnsi);
        } else {
            KERNEL_ULONG_PTR dwT = dwData;

            dwData = MapClientNeuterToClientPfn(pcls, dwT, bAnsi);

            /*
             * If the client mapping didn't change the window proc then see if
             * we need a callproc handle.
             */
            if (dwData == dwT) {
                /*
                 * Need to return a CallProc handle if there is an Ansi/Unicode mismatch
                 */
                if (bAnsi != !!(pcls->CSF_flags & CSF_ANSIPROC)) {
                    dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
                }
            }
        }

        if (dwCPDType) {
            ULONG_PTR dwCPD;

            dwCPD = GetCPD(pwnd, dwCPDType | CPD_WNDTOCLS, KERNEL_ULONG_PTR_TO_ULONG_PTR(dwData));

            if (dwCPD) {
                dwData = dwCPD;
            } else {
                RIPMSG0(RIP_WARNING, "GetClassLong unable to alloc CPD returning handle\n");
            }
        }
        }
        break;

    case GCL_CBCLSEXTRA:
        if ((pcls->CSF_flags & CSF_WOWCLASS) && (pcls->CSF_flags & CSF_WOWEXTRA)) {
            /*
             * The 16-bit app changed its Extra bytes value.  Return the changed
             * value.  FritzS
             */

            return PWCFromPCLS(pcls)->iClsExtra;
        }
        else
            return pcls->cbclsExtra;

        break;

    /*
     * WOW uses a pointer straight into the class structure.
     */
    case GCLP_WOWWORDS:
        if (pcls->CSF_flags & CSF_WOWCLASS) {
            return ((ULONG_PTR)PWCFromPCLS(pcls));
        } else
            return 0;

    case GCL_STYLE:
        dwData &= CS_VALID;
        break;
    }

    return KERNEL_ULONG_PTR_TO_ULONG_PTR(dwData);
}



/***************************************************************************\
* _GetClassLong (API)
*
* Return a class long.  Positive index values return application class longs
* while negative index values return system class longs.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 10-16-90 darrinm      Wrote.
\***************************************************************************/

ULONG_PTR _GetClassLongPtr(
    PWND pwnd,
    int index,
    BOOL bAnsi)
{
    PCLS pcls = REBASEALWAYS(pwnd, pcls);

    if (index < 0) {
        return _GetClassData(pcls, pwnd, index, bAnsi);
    } else {
        if ((UINT)index + sizeof(ULONG_PTR) > (UINT)pcls->cbclsExtra) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return 0;
        } else {
            ULONG_PTR UNALIGNED * KPTR_MODIFIER pudw;
            pudw = (ULONG_PTR UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pcls + 1) + index);
            return *pudw;
        }
    }
}

#ifdef _WIN64
DWORD _GetClassLong(
    PWND pwnd,
    int index,
    BOOL bAnsi)
{
    PCLS pcls = REBASEALWAYS(pwnd, pcls);

    if (index < 0) {
        if (index < INDEX_OFFSET || afClassDWord[index - INDEX_OFFSET] > sizeof(DWORD)) {
            RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "GetClassLong: invalid index %d", index);
            return 0;
        }
        return (DWORD)_GetClassData(pcls, pwnd, index, bAnsi);
    } else {
        if ((UINT)index + sizeof(DWORD) > (UINT)pcls->cbclsExtra) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return 0;
        } else {
            DWORD UNALIGNED * KPTR_MODIFIER pudw;
            pudw = (DWORD UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pcls + 1) + index);
            return *pudw;
        }
    }
}
#endif

/***************************************************************************\
* GetClassWord (API)
*
* Return a class word.  Positive index values return application class words
* while negative index values return system class words.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 10-16-90 darrinm      Wrote.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, WORD, DUMMYCALLINGTYPE, GetClassWord, HWND, hwnd, int, index)
WORD GetClassWord(
    HWND hwnd,
    int index)
{
    PWND pwnd;
    PCLS pclsClient;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    pclsClient = (PCLS)REBASEALWAYS(pwnd, pcls);

    try {
        if (index == GCW_ATOM) {
            return (WORD)_GetClassData(pclsClient, pwnd, index, FALSE);
        } else {
            if ((index < 0) || ((UINT)index + sizeof(WORD) > (UINT)pclsClient->cbclsExtra)) {
                RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
                return 0;
            } else {
                WORD UNALIGNED * KPTR_MODIFIER puw;
                puw = (WORD UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pclsClient + 1) + index);
                return *puw;
            }
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
            RIP_WARNING,
            "Window %x no longer valid",
            hwnd);
        return 0;
    }

}

/***************************************************************************\
* VersionRegisterClass
*
* Tries to register a versioned class by loading calling a
* predefined entry point in the DLL lpzDllName in the specified activation context.
*
* History:
* 10-16-01 msadek    Wrote.
\***************************************************************************/

BOOL VersionRegisterClass(
    LPWSTR lpzClassName, 
    LPWSTR lpzDllName, 
    PACTIVATION_CONTEXT lpActivationContext, 
    HMODULE *phModule)
{
    BOOL bRet = FALSE;
    HMODULE hDllMod = NULL;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), 
                                                                            RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };
    RtlActivateActivationContextUnsafeFast(&ActivationFrame, lpActivationContext);

    __try { 
        /*
         * Try to register it, by loading its DLL. Notice that this DLL
         * will never get unloaded unless we failed to create the window.
         * but once we created a window by loading this DLL will never free it.
         */ 
        PREGISTERCLASSNAMEW pRegisterClassNameW = NULL; 
        
        if ((hDllMod = LoadLibraryW(lpzDllName)) && 
            (pRegisterClassNameW = (PREGISTERCLASSNAMEW)GetProcAddress(hDllMod, "RegisterClassNameW"))) { 

            if (IS_PTR(lpzClassName)) { 
                bRet = (*pRegisterClassNameW)(lpzClassName); 
            } else { 
                UNICODE_STRING UnicodeClassName; 
                WCHAR Buffer[MAX_ATOM_LEN]; 

                UnicodeClassName.MaximumLength = (USHORT)(MAX_ATOM_LEN * sizeof(WCHAR)); 
                UnicodeClassName.Buffer = Buffer; 
                if (NtUserGetAtomName((ATOM)lpzClassName, &UnicodeClassName)) { 
                    bRet = (*pRegisterClassNameW)(Buffer); 
                } 
            } 
        } 
    } __finally { 
        RtlDeactivateActivationContextUnsafeFast(&ActivationFrame); 
    }

    if (!bRet && hDllMod != NULL) {
        FREE_LIBRARY_SAVE_ERROR(hDllMod);
    } else if (phModule) {
        *phModule = hDllMod;
    }

    return bRet;
}

/***************************************************************************\
* ClassNameToVersion
*
* Map class name to class name+version.
* lpClassName   : Class name to be mapped, it may be ANSI, Unicode or an Atom.
* pClassVerName : Buffer to receive the class name+version.
* lpDllName     : if it is not NULL it will point to the DLL owns this class 
                  name.
* bIsANSI       : True of lpClassName is ANSI, FALSE if it is Unicode.
*
* Return: If it succeed it returns lpClassName or lpClassName.
*         if it failed it returns NULL.
*
* History:
* 08-01-00 MHamid      Wrote.
\***************************************************************************/
LPWSTR
ClassNameToVersion(
    LPCWSTR lpClassName,
    LPWSTR pClassVerName,
    LPWSTR *lpDllName,
    PACTIVATION_CONTEXT* lppActivationContext,
    BOOL bIsANSI
    )
{
    int cbSrc;
    int cbDst;
    UNICODE_STRING UnicodeClassName;
    ACTIVATION_CONTEXT_SECTION_KEYED_DATA acskd;
    ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION UNALIGNED * pRedirEntry;
    LPWSTR lpClassNameRet; 
    LPWSTR pwstr;
    ULONG strLength;
    LPWSTR Buffer;
    NTSTATUS Status;

    acskd.ActivationContext = NULL;
    if (lppActivationContext != NULL) {
        *lppActivationContext = NULL;
    }

    /*
     * Allocate local buffer.
     */
    Buffer = UserLocalAlloc(0, MAX_ATOM_LEN * sizeof(WCHAR));
    if (Buffer == NULL) {
        return NULL;
    }

    /*
     * Capture lpClassName into a local buffer.
     */
    if (IS_PTR(lpClassName)) {
        /*
         * lpClassName is string.
         */
        if (bIsANSI) {
            /*
             * it is ANSI then convert it to unicode.
             */
            cbSrc = strlen((LPSTR)lpClassName) + 1;
            RtlMultiByteToUnicodeN(Buffer,
                    MAX_ATOM_LEN * sizeof(WCHAR), &cbDst,
                    (LPSTR)lpClassName, cbSrc);
        } else {
            /*
             * It is already unicode, then just copy it.
             */
            cbSrc = min (wcslen(lpClassName) + 1, MAX_ATOM_LEN);
            cbSrc *= sizeof(WCHAR);
            RtlCopyMemory(Buffer, lpClassName, cbSrc);
        }
        /*
         * Build the UNICODE_STRING
         */
        RtlInitUnicodeString(&UnicodeClassName, Buffer);
    } else {
        /*
         * lpClassName is an atom, get its name and build the UNICODE_STRING
         */
        UnicodeClassName.MaximumLength = (USHORT)(MAX_ATOM_LEN * sizeof(WCHAR));
        UnicodeClassName.Buffer = Buffer;
        UnicodeClassName.Length = (USHORT)NtUserGetAtomName((ATOM)lpClassName, &UnicodeClassName) * sizeof(WCHAR);

        if (!UnicodeClassName.Length) {
            lpClassNameRet = NULL;
            goto Free_Buffer;
        }
    }

    /*
     * Call Fusion to map the class name.
     */
    RtlZeroMemory(&acskd, sizeof(acskd));
    acskd.Size = sizeof(acskd);

    Status = RtlFindActivationContextSectionString(
        FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT,
        NULL,
        ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION,
        &UnicodeClassName,
        &acskd);
    /*
     * If there is no Activation Section we will use the plain class name.
     */
    if ((Status == STATUS_SXS_SECTION_NOT_FOUND) ||
        (Status == STATUS_SXS_KEY_NOT_FOUND)) {
        lpClassNameRet = (LPWSTR)lpClassName;
        goto Free_Buffer;
    }

    /*
     * Case of failure return NULL.
     */
    if (!NT_SUCCESS(Status) || 
        acskd.DataFormatVersion != ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION_FORMAT_WHISTLER) {

        lpClassNameRet = NULL;
        goto Free_Buffer;
    }

    pRedirEntry = (PACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION) acskd.Data;

    UserAssert(pRedirEntry);

    pwstr = (LPWSTR)(((ULONG_PTR) pRedirEntry) + pRedirEntry->VersionSpecificClassNameOffset);
    strLength = pRedirEntry->VersionSpecificClassNameLength + sizeof(WCHAR);
    if (lpDllName) {
        *lpDllName = (LPWSTR)(((ULONG_PTR) acskd.SectionBase) + pRedirEntry->DllNameOffset);
    }

    UserAssert(pwstr);
    UserAssert(strLength <= MAX_ATOM_LEN * sizeof(WCHAR));
    /*
     * if the call is ANSI then convert the class name+version to ANSI string.
     */
    if (bIsANSI) {
        RtlUnicodeToMultiByteN((LPSTR)pClassVerName,
                MAX_ATOM_LEN, &cbDst,
                pwstr, strLength);
    } else {
        /*
         * if it is unicode then just copy the class name+version to the caller's buffer.
         */
        RtlCopyMemory(pClassVerName, pwstr, strLength);
    }
    /*
     * And return it.
     */
    lpClassNameRet = pClassVerName;
    if (lppActivationContext != NULL) {
        *lppActivationContext = acskd.ActivationContext;
        acskd.ActivationContext = NULL;
    }

Free_Buffer: 
    /*
     * Don't forget to free the local memory.
     */
    UserLocalFree(Buffer);

    if (acskd.ActivationContext != NULL) {
        RtlReleaseActivationContext(acskd.ActivationContext);
        acskd.ActivationContext = NULL;
    }
    return lpClassNameRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\clhook.c ===
/****************************** Module Header ******************************\
* Module Name: clhook.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Client-side hook code.
*
* 05-09-1991 ScottLu Created.
* 08-Feb-1992 IanJa Unicode/ANSI
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* SetWindowsHookExAW
*
* Client side routine for SetWindowsHookEx(). Needs to remember the library
* name since hmods aren't global. Remembers the hmod as well so that
* it can be used to calculate pfnFilter in different process contexts.
*
* History:
* 05-15-91 ScottLu Created.
\***************************************************************************/

HHOOK SetWindowsHookExAW(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadID,
    DWORD dwFlags)
{
    WCHAR pwszLibFileName[MAX_PATH];

    /*
     * If we're passing an hmod, we need to grab the file name of the
     * module while we're still on the client since module handles
     * are NOT global.
     */
    if (hmod != NULL) {
        if (GetModuleFileNameW(hmod,
                               pwszLibFileName,
                               ARRAY_SIZE(pwszLibFileName)) == 0) {

            /*
             * hmod is bogus - return NULL.
             */
            return NULL;
        }
    }

    return _SetWindowsHookEx(hmod,
            (hmod == NULL) ? NULL : pwszLibFileName,
            dwThreadID, idHook, (PROC)lpfn, dwFlags);
}

/***************************************************************************\
* SetWindowsHookA,
* SetWindowsHookW
*
* ANSI and Unicode wrappers for NtUserSetWindowsHookAW(). Could easily be macros
* instead, but do we want to expose NtUserSetWindowsHookAW() ?
*
* History:
* 30-Jan-1992 IanJa   Created
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HHOOK, WINAPI, SetWindowsHookA, int, nFilterType, HOOKPROC, pfnFilterProc)
HHOOK
WINAPI
SetWindowsHookA(
    int nFilterType,
    HOOKPROC pfnFilterProc)
{
    return NtUserSetWindowsHookAW(nFilterType, pfnFilterProc, HF_ANSI);
}



FUNCLOG2(LOG_GENERAL, HHOOK, WINAPI, SetWindowsHookW, int, nFilterType, HOOKPROC, pfnFilterProc)
HHOOK
WINAPI
SetWindowsHookW(
    int nFilterType,
    HOOKPROC pfnFilterProc)
{
    return NtUserSetWindowsHookAW(nFilterType, pfnFilterProc, 0);
}


/***************************************************************************\
* SetWindowsHookExA,
* SetWindowsHookExW
*
* ANSI and Unicode wrappers for SetWindowsHookExAW(). Could easily be macros
* instead, but do we want to expose SetWindowsHookExAW() ?
*
* History:
* 30-Jan-1992 IanJa Created
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, HHOOK, WINAPI, SetWindowsHookExA, int, idHook, HOOKPROC, lpfn, HINSTANCE, hmod, DWORD, dwThreadId)
HHOOK WINAPI SetWindowsHookExA(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId)
{
    return SetWindowsHookExAW(idHook, lpfn, hmod, dwThreadId, HF_ANSI);
}


FUNCLOG4(LOG_GENERAL, HHOOK, WINAPI, SetWindowsHookExW, int, idHook, HOOKPROC, lpfn, HINSTANCE, hmod, DWORD, dwThreadId)
HHOOK WINAPI SetWindowsHookExW(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId)
{
    return SetWindowsHookExAW(idHook, lpfn, hmod, dwThreadId, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\clienta.c ===
/**************************************************************************\
* Module Name: clienta.c
*
* Client/Server call related routines dealing with ANSI text.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Created: 04-Dec-90
*
* History:
* 14-Jan-92 created by IanJa
*
\**************************************************************************/

#undef UNICODE

#define NONTOSPINTERLOCK
#include <ntosp.h>

#include <ntrtl.h>      // WINBASEP.H or something.
#include <nturtl.h>
#include <ntcsrmsg.h>

#include "..\client\usercli.h"

#include "cltxt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\client.c ===
/**************************************************************************\
* Module Name: client.c
*
* Client/Server call related routines.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 04-Dec-1990 SMeans    Created.
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "kbd.h"
#include "ntsend.h"
#include "vdm.h"

/*
 *  NOTE --  this table must match the FNID list in user.h.  It provides a WOWCLASS for each FNID.
 */

int aiClassWow[] = {
    WOWCLASS_SCROLLBAR,
    WOWCLASS_ICONTITLE,
    WOWCLASS_MENU,
    WOWCLASS_DESKTOP,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_SWITCHWND,
    WOWCLASS_BUTTON,
    WOWCLASS_COMBOBOX,
    WOWCLASS_COMBOLBOX,
    WOWCLASS_DIALOG,
    WOWCLASS_EDIT,
    WOWCLASS_LISTBOX,
    WOWCLASS_MDICLIENT,
    WOWCLASS_STATIC,
    WOWCLASS_WIN16,    // 2A9
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,     // 2B1
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16
    };

HBITMAP WOWLoadBitmapA(HINSTANCE hmod, LPCSTR lpName, LPBYTE pResData, DWORD cbResData);
HMENU WowServerLoadCreateMenu(HANDLE hMod, LPTSTR lpName, CONST LPMENUTEMPLATE pmt,
    DWORD cb, BOOL fCallClient);
DWORD GetFullUserHandle(WORD wHandle);

UINT GetClipboardCodePage(LCID, LCTYPE);

extern HANDLE WOWFindResourceExWCover(HANDLE hmod, LPCWSTR rt, LPCWSTR lpUniName, WORD LangId);

extern BOOL APIENTRY EnableEUDC();


CONST WCHAR szKLKey[]  = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Keyboard Layouts\\";
CONST WCHAR szKLFile[] = L"Layout File";
CONST WCHAR szKLAttributes[] = L"Attributes";
CONST WCHAR szKLId[]   = L"Layout ID";
#define NSZKLKEY   (sizeof szKLKey + 16)


CONST LPWSTR pwszKLLibSafety     = L"kbdus.dll";
CONST UINT   wKbdLocaleSafety    = 0x04090409;
CONST LPWSTR pwszKLLibSafetyJPN  = L"kbdjpn.dll";
CONST UINT   wKbdLocaleSafetyJPN = 0x04110411;
CONST LPWSTR pwszKLLibSafetyKOR  = L"kbdkor.dll";
CONST UINT   wKbdLocaleSafetyKOR = 0x04120412;

#define CCH_KL_LIBNAME 256
#define CCH_KL_ID 16

UNICODE_STRING strRootDirectory;

VOID CheckValidLayoutName(LPWSTR lpszName);

BOOL WOWModuleUnload(HANDLE hModule) {
    return (BOOL)NtUserCallOneParam((ULONG_PTR)hModule,
                                    SFI__WOWMODULEUNLOAD);
}

BOOL WOWCleanup(HANDLE hInstance, DWORD hTaskWow) {
    return (BOOL)NtUserCallTwoParam((ULONG_PTR)hInstance,
                                    (ULONG_PTR)hTaskWow,
                                    SFI__WOWCLEANUP);
}
/***************************************************************************\
* BringWindowToTop (API)
*
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, BringWindowToTop, HWND, hwnd)
BOOL BringWindowToTop(
    HWND hwnd)
{
    return NtUserSetWindowPos(hwnd,
                              HWND_TOP,
                              0,
                              0,
                              0,
                              0,
                              SWP_NOSIZE | SWP_NOMOVE);
}


FUNCLOG2(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, ChildWindowFromPoint, HWND, hwndParent, POINT, point)
HWND ChildWindowFromPoint(
    HWND  hwndParent,
    POINT point)
{
    /*
     * Cool Hack Alert... Corel Ventura 5.0
     * Dies after it calls ChildWindowFromPoint, and
     * the combobox doesn't have its edit window at 1,1...
     */
    if ((point.x == 1) && (point.y == 1)) {
        PCBOX pcCombo;
        PWND pwnd;

        pwnd = ValidateHwnd(hwndParent);
        if (pwnd == NULL)
            return NULL;

        if (!TestWF(pwnd, WFWIN40COMPAT)   &&
            GETFNID(pwnd) == FNID_COMBOBOX &&
            TestWindowProcess(pwnd) &&
            ((pcCombo = ((PCOMBOWND)pwnd)->pcbox) != NULL) &&
            !(pcCombo->fNoEdit)) {

            RIPMSG0(RIP_WARNING, "ChildWindowFromPoint: Combobox @1,1. Returning spwndEdit");
            return HWq(pcCombo->spwndEdit);
        }

    }

    return NtUserChildWindowFromPointEx(hwndParent, point, 0);
}



FUNCLOG1(LOG_GENERAL, HICON, DUMMYCALLINGTYPE, CopyIcon, HICON, hicon)
HICON CopyIcon(
    HICON hicon)
{
    HICON    hIconT = NULL;
    ICONINFO ii;

    if (GetIconInfo(hicon, &ii)) {
        hIconT = CreateIconIndirect(&ii);

        DeleteObject(ii.hbmMask);

        if (ii.hbmColor != NULL)
            DeleteObject(ii.hbmColor);
    }

    return hIconT;
}

/***************************************************************************\
* AdjustWindowRect (API)
*
* History:
* 01-Jul-1991 MikeKe    Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, AdjustWindowRect, LPRECT, lprc, DWORD, style, BOOL, fMenu)
BOOL WINAPI AdjustWindowRect(
    LPRECT lprc,
    DWORD  style,
    BOOL   fMenu)
{
    ConnectIfNecessary(0);

    return _AdjustWindowRectEx(lprc, style, fMenu, 0L);
}

/***************************************************************************\
* TranslateAcceleratorA/W
*
* Put here so we can check for NULL on client side, and before validation
* for both DOS and NT cases.
*
* 05-29-91 ScottLu Created.
* 01-05-93 IanJa   Unicode/ANSI.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, int, WINAPI, TranslateAcceleratorW, HWND, hwnd, HACCEL, hAccel, LPMSG, lpMsg)
int WINAPI TranslateAcceleratorW(
    HWND hwnd,
    HACCEL hAccel,
    LPMSG lpMsg)
{
    /*
     * NULL pwnd is a valid case - since this is called from the center
     * of main loops, pwnd == NULL happens all the time, and we shouldn't
     * generate a warning because of it.
     */
    if (hwnd == NULL)
        return FALSE;

    /*
     * We only need to pass key-down messages to the server,
     * everything else ends up returning 0/FALSE from this function.
     */
    switch (lpMsg->message) {

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
    case WM_CHAR:
    case WM_SYSCHAR:
        return NtUserTranslateAccelerator(hwnd, hAccel, lpMsg);

    default:
        return 0;
    }
}


FUNCLOG3(LOG_GENERAL, int, WINAPI, TranslateAcceleratorA, HWND, hwnd, HACCEL, hAccel, LPMSG, lpMsg)
int WINAPI TranslateAcceleratorA(
    HWND   hwnd,
    HACCEL hAccel,
    LPMSG  lpMsg)
{
    WPARAM wParamT;
    int iT;

    /*
     * NULL pwnd is a valid case - since this is called from the center
     * of main loops, pwnd == NULL happens all the time, and we shouldn't
     * generate a warning because of it.
     */
    if (hwnd == NULL)
        return FALSE;

    /*
     * We only need to pass key-down messages to the server,
     * everything else ends up returning 0/FALSE from this function.
     */
    switch (lpMsg->message) {

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
    case WM_CHAR:
    case WM_SYSCHAR:
        wParamT = lpMsg->wParam;
        RtlMBMessageWParamCharToWCS(lpMsg->message, &(lpMsg->wParam));
        iT = NtUserTranslateAccelerator(hwnd, hAccel, lpMsg);
        lpMsg->wParam = wParamT;
        return iT;

    default:
        return 0;
    }
}

/***************************************************************************\
* Clipboard functions
*
* 11-Oct-1991 mikeke Created.
\***************************************************************************/

typedef struct _HANDLENODE {
    struct _HANDLENODE *pnext;
    UINT   fmt;
    HANDLE handleServer;
    HANDLE handleClient;
    BOOL   fGlobalHandle;
} HANDLENODE;
typedef HANDLENODE *PHANDLENODE;

PHANDLENODE gphn = NULL;

/***************************************************************************\
* DeleteClientClipboardHandle
*
* 11-Oct-1991 MikeKe    Created.
\***************************************************************************/

BOOL DeleteClientClipboardHandle(
    PHANDLENODE phn)
{
    LPMETAFILEPICT lpMFP;

    UserAssert(phn->handleClient != (HANDLE)0);

    switch (phn->fmt) {
    case CF_BITMAP:
    case CF_DSPBITMAP:
    case CF_PALETTE:
        // Does nothing (should remove).
        //
        //GdiDeleteLocalObject((ULONG)hobjDelete);
        break;

    case CF_METAFILEPICT:
    case CF_DSPMETAFILEPICT:
        USERGLOBALLOCK(phn->handleClient, lpMFP);
        if (lpMFP) {
            DeleteMetaFile(lpMFP->hMF);
            USERGLOBALUNLOCK(phn->handleClient);
            UserGlobalFree(phn->handleClient);
        } else {
            RIPMSGF1(RIP_ERROR,
                     "Can't lock client handle 0x%p",
                     phn->handleClient);
            return FALSE;
        }
        break;

    case CF_ENHMETAFILE:
    case CF_DSPENHMETAFILE:
        DeleteEnhMetaFile((HENHMETAFILE)phn->handleClient);
        break;

    default:
    //case CF_TEXT:
    //case CF_OEMTEXT:
    //case CF_UNICODETEXT:
    //case CF_LOCALE:
    //case CF_DSPTEXT:
    //case CF_DIB:
    //case CF_DIBV5:
        if (phn->fGlobalHandle) {
            if (UserGlobalFree(phn->handleClient)) {
                RIPMSGF1(RIP_WARNING,
                         "UserGlobalFree(0x%p) failed",
                         phn->handleClient);
                return FALSE;
            }
        } else {
            UserAssert(GlobalFlags(phn->handleClient) == GMEM_INVALID_HANDLE);
        }
        break;
    }

    /*
     * Deleted successfully
     */
    return TRUE;

}

/***************************************************************************\
* ClientEmptyClipboard
*
* Empties the client side clipboard list.
*
* 01-15-93 ScottLu      Created.
\***************************************************************************/

void ClientEmptyClipboard(void)
{
    PHANDLENODE phnNext;
    PHANDLENODE phnT;

    RtlEnterCriticalSection(&gcsClipboard);

    phnT = gphn;
    while (phnT != NULL) {
        phnNext = phnT->pnext;

        if (phnT->handleClient != (HANDLE)0) {
            DeleteClientClipboardHandle(phnT);
        }

        UserLocalFree(phnT);

        phnT = phnNext;
    }
    gphn = NULL;

    /*
     * Tell wow to cleanup it's clipboard stuff
     */
    if (pfnWowEmptyClipBoard) {
        pfnWowEmptyClipBoard();
    }

    RtlLeaveCriticalSection(&gcsClipboard);
}


/***************************************************************************\
* GetClipboardData
*
* 11-Oct-1991 mikeke Created.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, HANDLE, WINAPI, GetClipboardData, UINT, uFmt)
HANDLE WINAPI GetClipboardData(
    UINT uFmt)
{
    HANDLE       handleClient;
    HANDLE       handleServer;
    PHANDLENODE  phn;
    PHANDLENODE  phnNew;
    GETCLIPBDATA gcd;

    /*
     * Get the Server's Data; return if there is no data.
     */
    if (!(handleServer = NtUserGetClipboardData(uFmt, &gcd)))
        return (HANDLE)NULL;

    /*
     * Handle any translation that must be done for text items.  The
     * format returned will only differ for text items.  Metafile and
     * Enhanced-Metafiles are handled through GDI for their converstions.
     * And Bitmap color space convertion also nessesary for CF_BITMAP,
     * CF_DIB and CF_DIBV5 with color space.
     */
    if (uFmt != gcd.uFmtRet) {

        LPBYTE       lpSrceData = NULL;
        LPBYTE       lpDestData = NULL;
        LPBYTE       lptData = NULL;
        LPDWORD      lpLocale;
        DWORD        uLocale;
        int          iSrce;
        int          iDest;
        UINT         uCPage;
        SETCLIPBDATA scd;
        UINT         cbNULL = 0;

        /*
         * Make sure handleServer is server-side memory handle
         */
        if ((gcd.uFmtRet == CF_TEXT)        || (gcd.uFmtRet == CF_OEMTEXT) ||
            (gcd.uFmtRet == CF_UNICODETEXT) ||
            (gcd.uFmtRet == CF_DIB)         || (gcd.uFmtRet == CF_DIBV5)) {

            if ((lpSrceData = CreateLocalMemHandle(handleServer)) == NULL) {
                goto AbortDummyHandle;
            }

            /*
             * Allocate space for the converted TEXT data.
             */
            if (!(iSrce = (UINT)GlobalSize(lpSrceData))) {
                goto AbortDummyHandle;
            }

            /*
             * Only CF_xxxTEXT may have locale information.
             */
            if ((gcd.uFmtRet == CF_TEXT) || (gcd.uFmtRet == CF_OEMTEXT) ||
                (gcd.uFmtRet == CF_UNICODETEXT)) {

                /*
                 * Get the locale out of the parameter-struct.  We will
                 * use this to get the codepage for text-translation.
                 */
                if (lpLocale = (LPDWORD)CreateLocalMemHandle(gcd.hLocale)) {

                    uLocale = *lpLocale;
                    GlobalFree(lpLocale);
                } else {
                    uLocale = 0;
                }

                /*
                 * And also, pre-allocate translated buffer in same size as source.
                 */
                if ((lpDestData = GlobalAlloc(LPTR, iSrce)) == NULL) {
                    goto AbortDummyHandle;
                }
            }

            switch (uFmt) {
                case CF_TEXT:
                cbNULL = 1;
                if (gcd.uFmtRet == CF_OEMTEXT) {

                    /*
                     * CF_OEMTEXT --> CF_TEXT conversion
                     */
                    OemToAnsi((LPSTR)lpSrceData, (LPSTR)lpDestData);
                } else {

                    uCPage = GetClipboardCodePage(uLocale,
                                                  LOCALE_IDEFAULTANSICODEPAGE);

                    /*
                     * CF_UNICODETEXT --> CF_TEXT conversion
                     */
                    iDest = 0;
                    if ((iDest = WideCharToMultiByte(uCPage,
                                                     (DWORD)0,
                                                     (LPWSTR)lpSrceData,
                                                     (int)(iSrce / sizeof(WCHAR)),
                                                     (LPSTR)NULL,
                                                     (int)iDest,
                                                     (LPSTR)NULL,
                                                     (LPBOOL)NULL)) == 0) {
AbortGetClipData:
                        UserGlobalFree(lpDestData);
AbortDummyHandle:
                        if (lpSrceData) {
                            UserGlobalFree(lpSrceData);
                        }
                        return NULL;
                    }

                    if (!(lptData = GlobalReAlloc(lpDestData, iDest, LPTR | LMEM_MOVEABLE)))
                        goto AbortGetClipData;

                    lpDestData = lptData;

                    if (WideCharToMultiByte(uCPage,
                                            (DWORD)0,
                                            (LPWSTR)lpSrceData,
                                            (int)(iSrce / sizeof(WCHAR)),
                                            (LPSTR)lpDestData,
                                            (int)iDest,
                                            (LPSTR)NULL,
                                            (LPBOOL)NULL) == 0)
                        goto AbortGetClipData;
                }
                break;

            case CF_OEMTEXT:
                cbNULL = 1;
                if (gcd.uFmtRet == CF_TEXT) {

                    /*
                     * CF_TEXT --> CF_OEMTEXT conversion
                     */
                    AnsiToOem((LPSTR)lpSrceData, (LPSTR)lpDestData);
                } else {

                    uCPage = GetClipboardCodePage(uLocale,
                                                  LOCALE_IDEFAULTCODEPAGE);

                    /*
                     * CF_UNICODETEXT --> CF_OEMTEXT conversion
                     */
                    iDest = 0;
                    if ((iDest = WideCharToMultiByte(uCPage,
                                                     (DWORD)0,
                                                     (LPWSTR)lpSrceData,
                                                     (int)(iSrce / sizeof(WCHAR)),
                                                     (LPSTR)NULL,
                                                     (int)iDest,
                                                     (LPSTR)NULL,
                                                     (LPBOOL)NULL)) == 0)
                        goto AbortGetClipData;

                    if (!(lptData = GlobalReAlloc(lpDestData, iDest, LPTR | LMEM_MOVEABLE)))
                        goto AbortGetClipData;

                    lpDestData = lptData;

                    if (WideCharToMultiByte(uCPage,
                                            (DWORD)0,
                                            (LPWSTR)lpSrceData,
                                            (int)(iSrce / sizeof(WCHAR)),
                                            (LPSTR)lpDestData,
                                            (int)iDest,
                                            (LPSTR)NULL,
                                            (LPBOOL)NULL) == 0)
                        goto AbortGetClipData;
                }
                break;

            case CF_UNICODETEXT:
                cbNULL = 2;
                if (gcd.uFmtRet == CF_TEXT) {

                    uCPage = GetClipboardCodePage(uLocale,
                                                  LOCALE_IDEFAULTANSICODEPAGE);

                    /*
                     * CF_TEXT --> CF_UNICODETEXT conversion
                     */
                    iDest = 0;
                    if ((iDest = MultiByteToWideChar(uCPage,
                                                     (DWORD)MB_PRECOMPOSED,
                                                     (LPSTR)lpSrceData,
                                                     (int)iSrce,
                                                     (LPWSTR)NULL,
                                                     (int)iDest)) == 0)
                        goto AbortGetClipData;

                    if (!(lptData = GlobalReAlloc(lpDestData,
                            iDest * sizeof(WCHAR), LPTR | LMEM_MOVEABLE)))
                        goto AbortGetClipData;

                    lpDestData = lptData;

                    if (MultiByteToWideChar(uCPage,
                                            (DWORD)MB_PRECOMPOSED,
                                            (LPSTR)lpSrceData,
                                            (int)iSrce,
                                            (LPWSTR)lpDestData,
                                            (int)iDest) == 0)
                        goto AbortGetClipData;

                } else {

                    uCPage = GetClipboardCodePage(uLocale,
                                                  LOCALE_IDEFAULTCODEPAGE);

                    /*
                     * CF_OEMTEXT --> CF_UNICDOETEXT conversion
                     */
                    iDest = 0;
                    if ((iDest = MultiByteToWideChar(uCPage,
                                                     (DWORD)MB_PRECOMPOSED,
                                                     (LPSTR)lpSrceData,
                                                     (int)iSrce,
                                                     (LPWSTR)NULL,
                                                     (int)iDest)) == 0)
                        goto AbortGetClipData;

                    if (!(lptData = GlobalReAlloc(lpDestData,
                            iDest * sizeof(WCHAR), LPTR | LMEM_MOVEABLE)))
                        goto AbortGetClipData;

                    lpDestData = lptData;

                    if (MultiByteToWideChar(uCPage,
                                            (DWORD)MB_PRECOMPOSED,
                                            (LPSTR)lpSrceData,
                                            (int)iSrce,
                                            (LPWSTR)lpDestData,
                                            (int)iDest) == 0)
                        goto AbortGetClipData;
                }
                break;

            case CF_BITMAP:
                if (gcd.uFmtRet == CF_DIBV5) {

                    /*
                     * CF_DIBV5 --> CF_BITMAP (sRGB)
                     *
                     * The GDI bitmap handle will be returned in handleServer.
                     */
                    if ((handleServer = GdiConvertBitmapV5(lpSrceData,iSrce,
                                                           gcd.hPalette,CF_BITMAP)) == NULL) {

                        /*
                         * GDI failed to convert.
                         */
                        RIPMSG0(RIP_ERROR,
                                "GetClipboardData: Failed CF_DIBV5 -> CF_BITMAP");
                        goto AbortDummyHandle;
                    }
                } else {
                    RIPMSG0(RIP_ERROR, "GetClipboardData: bad conversion request");
                    goto AbortDummyHandle;
                }
                break;

            case CF_DIB:
                if (gcd.uFmtRet == CF_DIBV5) {

                    /*
                     * CF_DIBV5 --> CF_DIB (sRGB)
                     *
                     * The local memory handle will be returned in lpDestData.
                     */
                    if ((lpDestData = (LPBYTE) GdiConvertBitmapV5(lpSrceData,iSrce,
                                                                  gcd.hPalette,CF_DIB)) == NULL) {

                        /*
                         * GDI failed to convert.
                         */
                        RIPMSG0(RIP_ERROR,
                                "GetClipboardData: Failed CF_DIBV5 -> CF_DIB");
                        goto AbortDummyHandle;
                    }
                } else {

                    RIPMSG0(RIP_ERROR, "GetClipboardData: bad conversion request");
                    goto AbortDummyHandle;
                }
                break;
            }
        }

        if (lpDestData) {
            /*
             * Replace the dummy user-mode memory handle with the actual handle.
             */
            handleServer = ConvertMemHandle(lpDestData, cbNULL);
            if (handleServer == NULL)
                goto AbortGetClipData;
        }

        /*
         * Update the server.  If that is successfull update the client
         */
        RtlEnterCriticalSection(&gcsClipboard);
        scd.fGlobalHandle    = gcd.fGlobalHandle;
        scd.fIncSerialNumber = FALSE;
        if (!NtUserSetClipboardData(uFmt, handleServer, &scd)) {
            handleServer = NULL;
        }
        RtlLeaveCriticalSection(&gcsClipboard);

        if (lpDestData)
            UserGlobalFree(lpDestData);
        if (lpSrceData)
            UserGlobalFree(lpSrceData);

        if (handleServer == NULL)
            return NULL;
    }

    /*
     * See if we already have a client side handle; validate the format
     * as well because some server objects, metafile for example, are dual mode
     * and yield two kinds of client objects enhanced and regular metafiles
     */
    handleClient = NULL;
    RtlEnterCriticalSection(&gcsClipboard);

    phn = gphn;
    while (phn) {
        if ((phn->handleServer == handleServer) && (phn->fmt == uFmt)) {
            handleClient = phn->handleClient;
            goto Exit;
        }
        phn = phn->pnext;
    }

    /*
     * We don't have a handle cached so we'll create one.
     */
    phnNew = (PHANDLENODE)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(HANDLENODE));
    if (phnNew == NULL) {
        goto Exit;
    }

    phnNew->handleServer  = handleServer;
    phnNew->fmt           = gcd.uFmtRet;
    phnNew->fGlobalHandle = gcd.fGlobalHandle;

    switch (uFmt) {

        /*
         * Misc GDI Handles
         */
        case CF_BITMAP:
        case CF_DSPBITMAP:
        case CF_PALETTE:
            phnNew->handleClient = handleServer;
            break;

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
            phnNew->handleClient = GdiCreateLocalMetaFilePict(handleServer);
            break;

        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
            phnNew->handleClient = GdiCreateLocalEnhMetaFile(handleServer);
            break;

        /*
         * GlobalHandle Cases
         */
        case CF_TEXT:
        case CF_OEMTEXT:
        case CF_UNICODETEXT:
        case CF_LOCALE:
        case CF_DSPTEXT:
        case CF_DIB:
        case CF_DIBV5:
            phnNew->handleClient = CreateLocalMemHandle(handleServer);
            phnNew->fGlobalHandle = TRUE;
            break;

        default:
            /*
             * Private Data Format; If this is global data, create a copy of that
             * data here on the client. If it isn't global data, it is just a dword
             * in which case we just return a dword. If it is global data and
             * the server fails to give us that memory, return NULL. If it isn't
             * global data, handleClient is just a dword.
             */
            if (phnNew->fGlobalHandle) {
                phnNew->handleClient = CreateLocalMemHandle(handleServer);
            } else {
                phnNew->handleClient = handleServer;
            }
            break;
    }

    if (phnNew->handleClient == NULL) {
        /*
         * Something bad happened; GDI didn't give us back a handle. Since
         * GDI has logged the error, we'll just clean up and return an error.
         */
        RIPMSGF1(RIP_WARNING,
                "Unable to convert server handle 0x%p to client handle",
                handleServer);

        UserLocalFree(phnNew);
        goto Exit;
    }

#if DBG
    /*
     * If handleClient came from a GlobalAlloc, then fGlobalHandle must be TRUE.
     * Some formats are acutally global handles but require special cleanup.
     */
    switch (phnNew->fmt) {
        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
            break;

        default:
            UserAssert(phnNew->fGlobalHandle
                       ^ (GlobalFlags(phnNew->handleClient) == GMEM_INVALID_HANDLE));
            break;
    }
#endif

    /*
     * Cache the new handle by linking it into our list
     */
    phnNew->pnext = gphn;
    gphn = phnNew;
    handleClient = phnNew->handleClient;

Exit:
    RtlLeaveCriticalSection(&gcsClipboard);
    return handleClient;
}

/***************************************************************************\
* GetClipboardCodePage (internal)
*
*   This routine returns the code-page associated with the given locale.
*
* 24-Aug-1995 ChrisWil  Created.
\***************************************************************************/

#define GETCCP_SIZE 8

UINT GetClipboardCodePage(
    LCID   uLocale,
    LCTYPE uLocaleType)
{
    WCHAR wszCodePage[GETCCP_SIZE];
    DWORD uCPage;

    if (GetLocaleInfoW(uLocale, uLocaleType, wszCodePage, GETCCP_SIZE)) {

        uCPage = (UINT)wcstol(wszCodePage, NULL, 10);

    } else {

        switch(uLocaleType) {

        case LOCALE_IDEFAULTCODEPAGE:
            uCPage = CP_OEMCP;
            break;

        case LOCALE_IDEFAULTANSICODEPAGE:
            uCPage = CP_ACP;
            break;

        default:
            uCPage = CP_MACCP;
            break;
        }
    }

    return uCPage;
}

/***************************************************************************\
* SetClipboardData
*
* Stub routine needs to exist on the client side so any global data gets
* allocated DDESHARE.
*
* 05-20-91 ScottLu Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HANDLE, WINAPI, SetClipboardData, UINT, wFmt, HANDLE, hMem)
HANDLE WINAPI SetClipboardData(
    UINT   wFmt,
    HANDLE hMem)
{
    PHANDLENODE  phnNew;
    HANDLE       hServer = NULL;
    SETCLIPBDATA scd;
    BOOL         fGlobalHandle = FALSE;

    if (hMem != NULL) {

        switch(wFmt) {

            case CF_BITMAP:
            case CF_DSPBITMAP:
            case CF_PALETTE:
                hServer = hMem;
                break;

            case CF_METAFILEPICT:
            case CF_DSPMETAFILEPICT:
                hServer = GdiConvertMetaFilePict(hMem);
                break;

            case CF_ENHMETAFILE:
            case CF_DSPENHMETAFILE:
                hServer = GdiConvertEnhMetaFile(hMem);
                break;

            /*
             * Must have a valid hMem (GlobalHandle)
             */
            case CF_TEXT:
            case CF_OEMTEXT:
            case CF_LOCALE:
            case CF_DSPTEXT:
                hServer = ConvertMemHandle(hMem, 1);
                fGlobalHandle = TRUE;
                break;

            case CF_UNICODETEXT:
                hServer = ConvertMemHandle(hMem, 2);
                fGlobalHandle = TRUE;
                break;

            case CF_DIB:
            case CF_DIBV5:
                hServer = ConvertMemHandle(hMem, 0);
                fGlobalHandle = TRUE;
                break;

            /*
             * hMem should have been NULL but Write sends non-null when told
             * to render
             */
            case CF_OWNERDISPLAY:
                // Fall Through;

            /*
             * May have an hMem (GlobalHandle) or may be private handle\info
             */
            default:
                if (GlobalFlags(hMem) == GMEM_INVALID_HANDLE) {
                    hServer = hMem;    // No server equivalent; private data
                    goto SCD_AFTERNULLCHECK;
                } else {
                    fGlobalHandle = TRUE;
                    hServer = ConvertMemHandle(hMem, 0);
                }
                break;
        }

        if (hServer == NULL) {
            /*
             * Something bad happened, gdi didn't give us back a handle.
             * Since gdi has logged the error, we'll just clean up and
             * return an error.
             */
            RIPMSG0(RIP_WARNING, "SetClipboardData: bad handle");
            return NULL;
        }
    }

SCD_AFTERNULLCHECK:

    RtlEnterCriticalSection(&gcsClipboard);

    /*
     * Update the server if that is successfull update the client
     */
    scd.fGlobalHandle    = fGlobalHandle;
    scd.fIncSerialNumber = TRUE;

    if (!NtUserSetClipboardData(wFmt, hServer, &scd)) {
        RtlLeaveCriticalSection(&gcsClipboard);
        return NULL;
    }

    /*
     * See if we already have a client handle of this type.  If so
     * delete it.
     */
    phnNew = gphn;
    while (phnNew) {
        if (phnNew->fmt == wFmt) {
            if (phnNew->handleClient != NULL) {
                DeleteClientClipboardHandle(phnNew);
                /*
                 * Notify WOW to clear its associated cached h16 for this format
                 * so that OLE32 thunked calls, which bypass the WOW cache will work.
                 */
                if (pfnWowCBStoreHandle) {
                    pfnWowCBStoreHandle((WORD)wFmt, 0);
                }
            }
            break;
        }

        phnNew = phnNew->pnext;
    }

    /*
     * If we aren't re-using an old client cache entry alloc a new one
     */
    if (!phnNew) {
        phnNew = (PHANDLENODE)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(HANDLENODE));

        if (phnNew == NULL) {
            RIPMSG0(RIP_WARNING, "SetClipboardData: not enough memory");

            RtlLeaveCriticalSection(&gcsClipboard);
            return NULL;
        }

        /*
         * Link in the newly allocated cache entry
         */
        phnNew->pnext = gphn;
        gphn = phnNew;
    }

    phnNew->handleServer  = hServer;
    phnNew->handleClient  = hMem;
    phnNew->fmt           = wFmt;
    phnNew->fGlobalHandle = fGlobalHandle;

    RtlLeaveCriticalSection(&gcsClipboard);

    return hMem;
}

/**************************************************************************\
* SetDeskWallpaper
*
* 22-Jul-1991 mikeke Created
* 01-Mar-1992 GregoryW Modified to call SystemParametersInfo.
\**************************************************************************/

BOOL SetDeskWallpaper(
    IN LPCSTR pString OPTIONAL)
{
    return SystemParametersInfoA(SPI_SETDESKWALLPAPER, 0, (PVOID)pString, TRUE);
}

/***************************************************************************\
* ReleaseDC (API)
*
* A complete Thank cannot be generated for ReleaseDC because its first
* parameter (hwnd) unnecessary and should be discarded before calling the
* server-side routine _ReleaseDC.
*
* History:
* 03-28-91 SMeans Created.
* 06-17-91 ChuckWh Added support for local DCs.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, ReleaseDC, HWND, hwnd, HDC, hdc)
BOOL WINAPI ReleaseDC(
    HWND hwnd,
    HDC hdc)
{

    /*
     * NOTE: This is a smart stub that calls _ReleaseDC so there is
     * no need for a separate ReleaseDC layer or client-server stub.
     * _ReleaseDC has simpler layer and client-server stubs since the
     * hwnd can be ignored.
     */

    UNREFERENCED_PARAMETER(hwnd);

    /*
     * Translate the handle.
     */
    if (hdc == NULL)
        return FALSE;

    /*
     *  call GDI to release user mode DC resources
     */

    GdiReleaseDC(hdc);

    return (BOOL)NtUserCallOneParam((ULONG_PTR)hdc, SFI__RELEASEDC);
}

int WINAPI
ToAscii(
    UINT wVirtKey,
    UINT wScanCode,
    CONST BYTE *lpKeyState,
    LPWORD lpChar,
    UINT wFlags
    )
{
    WCHAR UnicodeChar[2];
    int cch, retval;

    retval = ToUnicode(wVirtKey, wScanCode, lpKeyState, UnicodeChar,2, wFlags);
    cch = (retval < 0) ? -retval : retval;
    if (cch != 0) {
        if (!NT_SUCCESS(RtlUnicodeToMultiByteN(
                (LPSTR)lpChar,
                (ULONG) sizeof(*lpChar),
                (PULONG)&cch,
                UnicodeChar,
                cch * sizeof(WCHAR)))) {
            return 0;
        }
    }
    return (retval < 0) ? -cch : cch;
}

static UINT uCachedCP = 0;
static HKL  hCachedHKL = 0;

int WINAPI
ToAsciiEx(
    UINT wVirtKey,
    UINT wScanCode,
    CONST BYTE *lpKeyState,
    LPWORD lpChar,
    UINT wFlags,
    HKL hkl
    )
{
    WCHAR UnicodeChar[2];
    int cch, retval;
    BOOL fUsedDefaultChar;

    retval = ToUnicodeEx(wVirtKey, wScanCode, lpKeyState, UnicodeChar,2, wFlags, hkl);
    cch = (retval < 0) ? -retval : retval;
    if (cch != 0) {
        if (hkl != hCachedHKL) {
            DWORD dwCodePage;
            if (!GetLocaleInfoW(
                     HandleToUlong(hkl) & 0xffff,
                     LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                     (LPWSTR)&dwCodePage,
                     sizeof(dwCodePage) / sizeof(WCHAR)
                     )) {
                return 0;
            }
            uCachedCP = dwCodePage;
            hCachedHKL = hkl;
        }
        if (!WideCharToMultiByte(
                 uCachedCP,
                 0,
                 UnicodeChar,
                 cch,
                 (LPSTR)lpChar,
                 sizeof(*lpChar),
                 NULL,
                 &fUsedDefaultChar)) {
            return 0;
        }
    }
    return (retval < 0) ? -cch : cch;
}

/**************************************************************************\
* ScrollDC *
* DrawIcon *
* ExcludeUpdateRgn *
* ValidateRgn *
* DrawFocusRect *
* FrameRect *
* ReleaseDC *
* GetUpdateRgn *
* *
* These USER entry points all need handles translated before the call is *
* passed to the server side handler. *
* *
* History: *
* Mon 17-Jun-1991 22:51:45 -by- Charles Whitmer [chuckwh] *
* Wrote the stubs. The final form of these routines depends strongly on *
* what direction the user stubs take in general. *
\**************************************************************************/


BOOL WINAPI ScrollDC(
    HDC hDC,
    int dx,
    int dy,
    CONST RECT *lprcScroll,
    CONST RECT *lprcClip,
    HRGN hrgnUpdate,
    LPRECT lprcUpdate)
{
    if (hDC == NULL)
        return FALSE;

    /*
     * If we're not scrolling, just empty the update region and return.
     */
    if (dx == 0 && dy == 0) {
        if (hrgnUpdate)
            SetRectRgn(hrgnUpdate, 0, 0, 0, 0);
        if (lprcUpdate)
            SetRectEmpty(lprcUpdate);
        return TRUE;
    }

    return NtUserScrollDC(hDC, dx, dy, lprcScroll, lprcClip,
            hrgnUpdate, lprcUpdate);
}


FUNCLOG4(LOG_GENERAL, BOOL, WINAPI, DrawIcon, HDC, hdc, int, x, int, y, HICON, hicon)
BOOL WINAPI DrawIcon(HDC hdc,int x,int y,HICON hicon)
{
    return DrawIconEx(hdc, x, y, hicon, 0, 0, 0, 0, DI_NORMAL | DI_COMPAT | DI_DEFAULTSIZE );
}



FUNCLOG9(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawIconEx, HDC, hdc, int, x, int, y, HICON, hIcon, int, cx, int, cy, UINT, istepIfAniCur, HBRUSH, hbrFlickerFreeDraw, UINT, diFlags)
BOOL DrawIconEx( HDC hdc, int x, int y, HICON hIcon,
                 int cx, int cy, UINT istepIfAniCur,
                 HBRUSH hbrFlickerFreeDraw, UINT diFlags)
{
    DRAWICONEXDATA did;
    HBITMAP hbmT;
    BOOL retval = FALSE;
    HDC hdcr;
    BOOL fAlpha = FALSE;
    LONG rop = (diFlags & DI_NOMIRROR) ? NOMIRRORBITMAP : 0;

    if (diFlags & ~DI_VALID) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        return(FALSE);
    }

    if (diFlags & DI_DEFAULTSIZE) {
        cx = 0;
        cy = 0;
    }

    if (!IsMetaFile(hdc)) {
        hdcr = GdiConvertAndCheckDC(hdc);
        if (hdcr == (HDC)0)
            return FALSE;

        return NtUserDrawIconEx(hdcr, x, y, hIcon, cx, cy, istepIfAniCur,
                                hbrFlickerFreeDraw, diFlags, FALSE, &did);
    }

    if (!NtUserDrawIconEx(NULL, 0, 0, hIcon, cx, cy, 0, NULL, 0, TRUE, &did)) {
        return FALSE;
    }

    if ((diFlags & ~DI_NOMIRROR) == 0)
        return TRUE;

    RtlEnterCriticalSection(&gcsHdc);

    /*
     * We really want to draw an alpha icon if we can.  But we need to
     * respect the user's request to draw only the image or only the
     * mask.  We decide if we are, or are not, going to draw the icon
     * with alpha information here.
     */
    if (did.hbmUserAlpha != NULL && ((diFlags & DI_NORMAL) == DI_NORMAL)) {
        fAlpha = TRUE;
    }

    RIPMSG5(RIP_WARNING, "Drawing to metafile! fAlpha=%d, did.cx=%d, did.cy=%d, cx=%d, cy=%d", fAlpha, did.cx, did.cy, cx, cy);
    /*
     * Setup the attributes
     */
    if (!cx)
        cx = did.cx;
    if (!cy)
        cy = did.cy / 2;

    SetTextColor(hdc, 0x00000000L);
    SetBkColor(hdc, 0x00FFFFFFL);

    if (fAlpha) {
        BLENDFUNCTION bf;

        hbmT = SelectObject(ghdcBits2, did.hbmUserAlpha);

        bf.BlendOp = AC_SRC_OVER;
        bf.BlendFlags = AC_MIRRORBITMAP;
        bf.SourceConstantAlpha = 0xFF;
        bf.AlphaFormat = AC_SRC_ALPHA;

        AlphaBlend(hdc,
                   x,
                   y,
                   cx,
                   cy,
                   ghdcBits2,
                   0,
                   0,
                   did.cx,
                   did.cy / 2,
                   bf);
        SelectObject(ghdcBits2,hbmT);
        retval = TRUE;
    } else {
        if (diFlags & DI_MASK) {

            if (did.hbmMask) {

                hbmT = SelectObject(ghdcBits2, did.hbmMask);
                StretchBlt(hdc,
                           x,
                           y,
                           cx,
                           cy,
                           ghdcBits2,
                           0,
                           0,
                           did.cx,
                           did.cy / 2,
                           rop | SRCAND);
                SelectObject(ghdcBits2,hbmT);
                retval = TRUE;
            }
        }

        if (diFlags & DI_IMAGE) {

            if (did.hbmColor != NULL) {
                hbmT = SelectObject(ghdcBits2, did.hbmColor);
                StretchBlt(hdc,
                           x,
                           y,
                           cx,
                           cy,
                           ghdcBits2,
                           0,
                           0,
                           did.cx,
                           did.cy / 2,
                           rop | SRCINVERT);
                SelectObject(ghdcBits2, hbmT);
                retval = TRUE;
            } else {
                if (did.hbmMask) {
                    hbmT = SelectObject(ghdcBits2, did.hbmMask);
                    StretchBlt(hdc,
                               x,
                               y,
                               cx,
                               cy,
                               ghdcBits2,
                               0,
                               did.cy / 2,
                               did.cx,
                               did.cy / 2,
                               rop | SRCINVERT);
                    SelectObject(ghdcBits2, hbmT);
                    retval = TRUE;
                }
            }
        }
    }

    RtlLeaveCriticalSection(&gcsHdc);

    return retval;
}




FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, ValidateRgn, HWND, hWnd, HRGN, hRgn)
BOOL WINAPI ValidateRgn(HWND hWnd,HRGN hRgn)
{
    return (BOOL)NtUserCallHwndParamLock(hWnd, (ULONG_PTR)hRgn,
                                         SFI_XXXVALIDATERGN);
}


FUNCLOG3(LOG_GENERAL, int, WINAPI, GetUpdateRgn, HWND, hWnd, HRGN, hRgn, BOOL, bErase)
int WINAPI GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
{
    PWND pwnd;

    if (hRgn == NULL) {
        RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING, "Invalid region %#p", hRgn);
        return ERROR;
    }

    if ((pwnd = ValidateHwnd(hWnd)) == NULL) {
        return ERROR;
    }

    /*
     * Check for the simple case where nothing needs to be done.
     */
    if (pwnd->hrgnUpdate == NULL &&
            !TestWF(pwnd, WFSENDERASEBKGND) &&
            !TestWF(pwnd, WFSENDNCPAINT) &&
            !TestWF(pwnd, WFUPDATEDIRTY) &&
            !TestWF(pwnd, WFPAINTNOTPROCESSED)) {
        SetRectRgn(hRgn, 0, 0, 0, 0);
        return NULLREGION;
    }

    return NtUserGetUpdateRgn(hWnd, hRgn, bErase);
}



FUNCLOG3(LOG_GENERAL, int, WINAPI, GetUpdateRect, HWND, hWnd, LPRECT, lprc, BOOL, bErase)
int WINAPI GetUpdateRect(HWND hWnd, LPRECT lprc, BOOL bErase)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hWnd)) == NULL) {
        return FALSE;
    }

    /*
     * Check for the simple case where nothing needs to be done.
     */
    if (pwnd->hrgnUpdate == NULL &&
            !TestWF(pwnd, WFSENDERASEBKGND) &&
            !TestWF(pwnd, WFSENDNCPAINT) &&
            !TestWF(pwnd, WFUPDATEDIRTY) &&
            !TestWF(pwnd, WFPAINTNOTPROCESSED)) {
        if (lprc)
            SetRectEmpty(lprc);
        return FALSE;
    }

    return NtUserGetUpdateRect(hWnd, lprc, bErase);
}


/***************************************************************************\
* ScrollWindow (API)
*
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

#define SW_FLAG_RC  (SW_SCROLLWINDOW | SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN)
#define SW_FLAG_NRC (SW_SCROLLWINDOW | SW_INVALIDATE | SW_ERASE)

BOOL WINAPI
ScrollWindow(
    HWND hwnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip)
{
    return NtUserScrollWindowEx(
            hwnd,
            dx,
            dy,
            prcScroll,
            prcClip,
            NULL,
            NULL,
            !IS_PTR(prcScroll) ? SW_FLAG_RC : SW_FLAG_NRC) != ERROR;
}

/***************************************************************************\
* SwitchToThisWindow
\***************************************************************************/
FUNCLOGVOID2(LOG_GENERAL, WINAPI, SwitchToThisWindow, HWND, hwnd, BOOL, fAltTab)
VOID WINAPI SwitchToThisWindow(
    HWND hwnd,
    BOOL fAltTab)
{
    (VOID)NtUserCallHwndParamLock(hwnd, fAltTab, SFI_XXXSWITCHTOTHISWINDOW);
}


/***************************************************************************\
* WaitForInputIdle
*
* Waits for a given process to go idle.
*
* 09-18-91 ScottLu Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, WaitForInputIdle, HANDLE, hProcess, DWORD, dwMilliseconds)
DWORD WaitForInputIdle(
    HANDLE hProcess,
    DWORD dwMilliseconds)
{
    PROCESS_BASIC_INFORMATION processinfo;
    ULONG_PTR idProcess;
    NTSTATUS Status;

    /*
     * First get the process id from the hProcess.
     */
    Status = NtQueryInformationProcess(hProcess,
                                       ProcessBasicInformation,
                                       &processinfo, sizeof(processinfo),
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_TYPE_MISMATCH) {
            if ((ULONG_PTR)hProcess & 0x2) {
                /*
                 * WOW Process handles are really semaphore handles.
                 * CreateProcess ORs in a 0x2 (the low 2 bits of handles
                 * are not used) so we can identify it more clearly.
                 */
                idProcess = ((ULONG_PTR)hProcess & ~0x03);
                return NtUserWaitForInputIdle(idProcess, dwMilliseconds, TRUE);
            }

            /*
             * VDM (DOS) Process handles are really semaphore handles.
             * CreateProcess ORs in a 0x1 (the low 2 bits of handles
             * are not used) so we can identify and return immidiately.
             */
            if ((ULONG_PTR)hProcess & 0x1) {
                return 0;
            }
        }

        RIPERR1(ERROR_INVALID_HANDLE,
                RIP_WARNING,
                "WaitForInputIdle invalid process 0x%p",
                hProcess);
        return WAIT_FAILED;
    }

    idProcess = processinfo.UniqueProcessId;
    return NtUserWaitForInputIdle(idProcess, dwMilliseconds, FALSE);
}

DWORD WINAPI MsgWaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *pHandles,
    BOOL fWaitAll,
    DWORD dwMilliseconds,
    DWORD dwWakeMask)
{
    return  MsgWaitForMultipleObjectsEx(nCount, pHandles,
                dwMilliseconds, dwWakeMask, fWaitAll?MWMO_WAITALL:0);
}


DWORD WINAPI MsgWaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *pHandles,
    DWORD dwMilliseconds,
    DWORD dwWakeMask,
    DWORD dwFlags)
#ifdef MESSAGE_PUMP_HOOK
{
    DWORD dwResult;

    BEGIN_MESSAGEPUMPHOOK()
        if (fInsideHook) {
            dwResult = gmph.pfnMsgWaitForMultipleObjectsEx(nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags);
        } else {
            dwResult = RealMsgWaitForMultipleObjectsEx(nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags);
        }
    END_MESSAGEPUMPHOOK()

    return dwResult;
}


DWORD WINAPI RealMsgWaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *pHandles,
    DWORD dwMilliseconds,
    DWORD dwWakeMask,
    DWORD dwFlags)
#endif
{
    HANDLE hEventInput;
    PHANDLE ph;
    DWORD dwIndex;
    BOOL  ReenterWowScheduler;
    PCLIENTINFO pci;
    HANDLE rgHandles[ 8 + 1 ];
    BOOL fWaitAll = ((dwFlags & MWMO_WAITALL) != 0);
    BOOL fAlertable = ((dwFlags & MWMO_ALERTABLE) != 0);
    CLIENTTHREADINFO *pcti;

    if (dwFlags & ~MWMO_VALID) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "MsgWaitForMultipleObjectsEx, invalid flags 0x%x", dwFlags);
        return WAIT_FAILED;
    }

    pci = GetClientInfo();
    pcti = GETCLIENTTHREADINFO();
    if (pcti && (!fWaitAll || !nCount)) {
        if (GetInputBits(pcti, LOWORD(dwWakeMask), (dwFlags & MWMO_INPUTAVAILABLE))) {
            return nCount;
        }
    }

    /*
     * Note -- the wake mask is a WORD, and only 3 flags are defined, so
     * they can be combined for the call.
     */

    hEventInput = (HANDLE)NtUserCallOneParam(MAKELONG(dwWakeMask, dwFlags), SFI_XXXGETINPUTEVENT);

    if (hEventInput == NULL) {
        RIPMSG0(RIP_WARNING, "MsgWaitForMultipleObjectsEx, GetInputEvent failed");
        return WAIT_FAILED;
    }

    /*
     * If needed, allocate a new array of handles that will include the
     * input event handle.
     */
    ph = rgHandles;
    if (pHandles) {
        if (nCount > 8) {
            ph = (PHANDLE)UserLocalAlloc(HEAP_ZERO_MEMORY,
                                         sizeof(HANDLE) * (nCount + 1));
            if (ph == NULL) {
                NtUserCallNoParam(SFI_CLEARWAKEMASK);
                return WAIT_FAILED;
            }
        }

        RtlCopyMemory((PVOID)ph, pHandles, sizeof(HANDLE) * nCount);
    } else {
        /*
         * If this isn't zero, the function parameters are invalid.
         */
        nCount = 0;
    }

    ph[nCount] = hEventInput;


    /*
     * WowApps must exit the Wow scheduler otherwise other tasks in this
     * Wow scheduler can't run. The only exception is if the timeout is
     * Zero. We pass HEVENT_REMOVEME as the handle so we will go into the
     * sleeptask AND return without going to sleep but letting other apps
     * run.
     */
    if ((pci->dwTIFlags & TIF_16BIT) && dwMilliseconds) {
        ReenterWowScheduler = TRUE;
        NtUserWaitForMsgAndEvent(HEVENT_REMOVEME);
        /*
         * If our wait condition is satisfied, make sure we won't wait.
         * We must have a pcti now since we just went to the kernel.
         */
        pcti = GETCLIENTTHREADINFO();
        if (GetInputBits(pcti, LOWORD(dwWakeMask), (dwFlags & MWMO_INPUTAVAILABLE))) {
            SetEvent(hEventInput);
        }
    } else {
        ReenterWowScheduler = FALSE;
    }

    dwIndex = WaitForMultipleObjectsEx(nCount + 1, ph, fWaitAll, dwMilliseconds, fAlertable);

    /*
     * Clear the wake mask since we're done waiting on these events.
     */
    NtUserCallNoParam(SFI_CLEARWAKEMASK);

    /*
     * If needed reenter the wow scheduler.
     */
    if (ReenterWowScheduler) {
        NtUserCallOneParam(DY_OLDYIELD, SFI_XXXDIRECTEDYIELD);
    }

    if (ph != rgHandles) {
        UserLocalFree(ph);
    }

    return dwIndex;
}

/***************************************************************************\
* GrayString
*
* GrayStingA used to convert the string and call GrayStringW but that
* did not work in a number of special cases such as the app passing in
* a pointer to a zero length string.  Eventually GrayStringA had almost as
* much code as GrayStringW so now they are one.
*
* History:
* 06-11-91 JimA     Created.
* 06-17-91 ChuckWh  Added GDI handle conversion.
* 02-12-92 mikeke   Made it completely client side
\***************************************************************************/

BOOL InnerGrayStringAorW(
    HDC            hdc,
    HBRUSH         hbr,
    GRAYSTRINGPROC lpfnPrint,
    LPARAM         lParam,
    int            cch,
    int            x,
    int            y,
    int            cx,
    int            cy,
    BOOL           bAnsi)
{
    HBITMAP hbm;
    HBITMAP hbmOld;
    BOOL    fResult;
    HFONT   hFontSave = NULL;
    BOOL    fReturn = FALSE;
    DWORD   dwOldLayout = GDI_ERROR;

    /*
     * Win 3.1 tries to calc the size even if we don't know if it is a string.
     */
    if (cch == 0) {

        try {

            cch = bAnsi ? strlen((LPSTR)lParam) : wcslen((LPWSTR)lParam);

        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            fReturn = TRUE;
        }

        if (fReturn)
            return FALSE;
    }

    if (cx == 0 || cy == 0) {

       SIZE size;

        /*
         * We use the caller supplied hdc (instead of hdcBits) since we may be
         * graying a font which is different than the system font and we want to
         * get the proper text extents.
         */
        try {
            if (bAnsi) {
                GetTextExtentPointA(hdc, (LPSTR)lParam, cch, &size);
            } else {
                GetTextExtentPointW(hdc, (LPWSTR)lParam, cch, &size);
            }

            cx = size.cx;
            cy = size.cy;

        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            fReturn = TRUE;
        }

        if (fReturn)
            return FALSE;
    }

    UserAssert (ghdcGray != NULL);

    RtlEnterCriticalSection(&gcsHdc);

    if (gcxGray < cx || gcyGray < cy) {

        if ((hbm = CreateBitmap(cx, cy, 1, 1, 0L)) != NULL) {

            hbmOld = SelectObject(ghdcGray, hbm);
            DeleteObject(hbmOld);

            gcxGray = cx;
            gcyGray = cy;

        } else {
            cx = gcxGray;
            cy = gcyGray;
        }
    }

    /*
     * If the caller hdc is mirrored then mirror ghdcGray.
     */
    if (MIRRORED_HDC(hdc)) {
        dwOldLayout = SetLayoutWidth(ghdcGray, cx, LAYOUT_RTL);
    }

    /*
     * Force the ghdcGray font to be the same as hDC; ghdcGray is always
     * the system font
     */
    hFontSave = SelectObject(hdc, ghFontSys);

    if (hFontSave != ghFontSys) {
        SelectObject(hdc, hFontSave);
        hFontSave = SelectObject(ghdcGray, hFontSave);
    }

    if (lpfnPrint != NULL) {
        PatBlt(ghdcGray, 0, 0, cx, cy, WHITENESS);
        fResult = (*lpfnPrint)(ghdcGray, lParam, cch);
    } else {

        if (bAnsi) {
            fResult = TextOutA(ghdcGray, 0, 0, (LPSTR)lParam, cch);
        } else {
            fResult = TextOutW(ghdcGray, 0, 0, (LPWSTR)lParam, cch);
        }
    }

    if (fResult)
        PatBlt(ghdcGray, 0, 0, cx, cy, DESTINATION | PATTERN);

    if (fResult || cch == -1) {

        HBRUSH hbrSave;
        DWORD  textColorSave;
        DWORD  bkColorSave;

        textColorSave = SetTextColor(hdc, 0x00000000L);
        bkColorSave = SetBkColor(hdc, 0x00FFFFFFL);

        hbrSave = SelectObject(hdc, hbr ? hbr : ghbrWindowText);

        BitBlt(hdc,
               x,
               y,
               cx,
               cy,
               ghdcGray,
               0,
               0,
               (((PATTERN ^ DESTINATION) & SOURCE) ^ PATTERN));

        SelectObject(hdc, hbrSave);

        /*
         * Restore saved colors
         */
        SetTextColor(hdc, textColorSave);
        SetBkColor(hdc, bkColorSave);
    }

    SelectObject(ghdcGray, hFontSave);

    /*
     * Restore ghdcGray layout state.
     */
    if (dwOldLayout != GDI_ERROR) {
        SetLayoutWidth(ghdcGray, cx, dwOldLayout);
    }

    RtlLeaveCriticalSection(&gcsHdc);

    return fResult;
}


FUNCLOG9(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GrayStringA, HDC, hdc, HBRUSH, hbr, GRAYSTRINGPROC, lpfnPrint, LPARAM, lParam, int, cch, int, x, int, y, int, cx, int, cy)
BOOL GrayStringA(
    HDC            hdc,
    HBRUSH         hbr,
    GRAYSTRINGPROC lpfnPrint,
    LPARAM         lParam,
    int            cch,
    int            x,
    int            y,
    int            cx,
    int            cy)
{
    return (InnerGrayStringAorW(hdc,
                                hbr,
                                lpfnPrint,
                                lParam,
                                cch,
                                x,
                                y,
                                cx,
                                cy,
                                TRUE));
}


FUNCLOG9(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GrayStringW, HDC, hdc, HBRUSH, hbr, GRAYSTRINGPROC, lpfnPrint, LPARAM, lParam, int, cch, int, x, int, y, int, cx, int, cy)
BOOL GrayStringW(
    HDC            hdc,
    HBRUSH         hbr,
    GRAYSTRINGPROC lpfnPrint,
    LPARAM         lParam,
    int            cch,
    int            x,
    int            y,
    int            cx,
    int            cy)
{
    return (InnerGrayStringAorW(hdc,
                                hbr,
                                lpfnPrint,
                                lParam,
                                cch,
                                x,
                                y,
                                cx,
                                cy,
                                FALSE));
}


/***************************************************************************\
* GetUserObjectSecurity (API)
*
* Gets the security descriptor of an object
*
* History:
* 07-01-91 JimA         Created.
\***************************************************************************/
FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetUserObjectSecurity, HANDLE, hObject, PSECURITY_INFORMATION, pRequestedInformation, PSECURITY_DESCRIPTOR, pSecurityDescriptor, DWORD, nLength, LPDWORD, lpnLengthRequired)
BOOL GetUserObjectSecurity(
    HANDLE hObject,
    PSECURITY_INFORMATION pRequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthRequired)
{
    NTSTATUS Status;

    Status = NtQuerySecurityObject(hObject,
                                   *pRequestedInformation,
                                   pSecurityDescriptor,
                                   nLength,
                                   lpnLengthRequired);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
* SetUserObjectSecurity (API)
*
* Sets the security descriptor of an object
*
* History:
* 07-01-91 JimA         Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetUserObjectSecurity, HANDLE, hObject, PSECURITY_INFORMATION, pRequestedInformation, PSECURITY_DESCRIPTOR, pSecurityDescriptor)
BOOL SetUserObjectSecurity(
    HANDLE hObject,
    PSECURITY_INFORMATION pRequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    NTSTATUS Status;

    Status = NtSetSecurityObject(hObject,
                                 *pRequestedInformation,
                                 pSecurityDescriptor);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return FALSE;
    }
    return TRUE;
}


/***************************************************************************\
* GetUserObjectInformation (API)
*
* Gets information about an object
*
* History:
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetUserObjectInformationA, HANDLE, hObject, int, nIndex, PVOID, pvInfo, DWORD, nLength, LPDWORD, pnLengthNeeded)
BOOL GetUserObjectInformationA(
    HANDLE hObject,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength,
    LPDWORD pnLengthNeeded)
{
    PVOID pvInfoW;
    DWORD nLengthW;
    BOOL fSuccess;

    if (nIndex == UOI_NAME || nIndex == UOI_TYPE) {
        nLengthW = nLength * sizeof(WCHAR);
        pvInfoW = UserLocalAlloc(HEAP_ZERO_MEMORY, nLengthW);
        fSuccess = NtUserGetObjectInformation(hObject,
                                              nIndex,
                                              pvInfoW,
                                              nLengthW,
                                              pnLengthNeeded);
        if (fSuccess) {
            if (pnLengthNeeded != NULL) {
                 *pnLengthNeeded /= sizeof(WCHAR);
            }
            WCSToMB(pvInfoW, -1, &(PCHAR)pvInfo, nLength, FALSE);
        }
        UserLocalFree(pvInfoW);
        return fSuccess;
    } else {
        return NtUserGetObjectInformation(hObject,
                                          nIndex,
                                          pvInfo,
                                          nLength,
                                          pnLengthNeeded);
    }
}

BOOL GetWinStationInfo(
    WSINFO* pWsInfo)
{
    return (BOOL)NtUserCallOneParam((ULONG_PTR)pWsInfo, SFI__GETWINSTATIONINFO);
}

/***************************************************************************\
* GetServerIMEKeyboardLayout
*
* This routine finds HKL matches the IME module name sent from the Hydra
* client at its session startup.
* Hydra server tries to load the same IME module in the client, rather
* than to use the same HKL: that's because, on FE machines,
* the same IME might have different HKL dependent to each system.
*
* If the same IME name is found in registry, then it returns the HKL.
* If it cannot find, return value is 0.
*
* History:
\***************************************************************************/
ULONG GetServerIMEKeyboardLayout(
    LPTSTR pszImeFileName)
{
    BOOL fFound = FALSE;
    ULONG wLayoutId;
    UNICODE_STRING UnicodeStringKLKey;
    UNICODE_STRING UnicodeStringSubKLKey;
    UNICODE_STRING UnicodeStringIME;
    OBJECT_ATTRIBUTES OA;
    HANDLE hKey;
    ULONG Index;
    WCHAR awchKLRegKey[NSZKLKEY];
    LPWSTR lpszKLRegKey = awchKLRegKey;
    NTSTATUS Status;

    RtlInitUnicodeString(&UnicodeStringKLKey, szKLKey);
    InitializeObjectAttributes(&OA, &UnicodeStringKLKey, OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &OA))) {

        for (Index = 0; TRUE; Index++) {

            BYTE KeyBuffer[sizeof(KEY_BASIC_INFORMATION) + KL_NAMELENGTH * sizeof(WCHAR)];
            PKEY_BASIC_INFORMATION pKeyInfo;
            ULONG ResultLength;

            pKeyInfo = (PKEY_BASIC_INFORMATION)KeyBuffer;
            Status = NtEnumerateKey(hKey,
                                    Index,
                                    KeyBasicInformation,
                                    pKeyInfo,
                                    sizeof(KeyBuffer),
                                    &ResultLength);

            if (NT_SUCCESS(Status)) {
                UnicodeStringSubKLKey.Buffer = (PWSTR)&(pKeyInfo->Name[0]);
                UnicodeStringSubKLKey.Length = (USHORT)pKeyInfo->NameLength;
                UnicodeStringSubKLKey.MaximumLength = (USHORT)pKeyInfo->NameLength;
                RtlUnicodeStringToInteger(&UnicodeStringSubKLKey, 16, &wLayoutId);

                if (IS_IME_KBDLAYOUT(wLayoutId)) {

                    HANDLE hSubKey;

                    wcscpy(lpszKLRegKey, szKLKey);
                    wcsncat(lpszKLRegKey, UnicodeStringSubKLKey.Buffer,
                                          UnicodeStringSubKLKey.Length / sizeof(WCHAR));
                    RtlInitUnicodeString(&UnicodeStringKLKey, lpszKLRegKey);
                    InitializeObjectAttributes(&OA, &UnicodeStringKLKey, OBJ_CASE_INSENSITIVE, NULL, NULL);

                    if (NT_SUCCESS(NtOpenKey(&hSubKey, KEY_READ, &OA))) {
                        /*
                         * GetIME file name from "HKLM\...\<Index>\IME File"
                         */
                        static CONST WCHAR szIMEfile[]  = L"IME file";
                        struct {
                            KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
                            WCHAR awchImeName[CCH_KL_LIBNAME];
                        } IMEfile;
                        LPWSTR pwszIME;
                        DWORD cbSize;

                        RtlInitUnicodeString(&UnicodeStringIME, szIMEfile);

                        Status = NtQueryValueKey(hSubKey,
                                                 &UnicodeStringIME,
                                                 KeyValuePartialInformation,
                                                 &IMEfile,
                                                 sizeof IMEfile,
                                                 &cbSize);
                        NtClose(hSubKey);

                        if (NT_SUCCESS(Status)) {
                            pwszIME = (LPWSTR)IMEfile.KeyInfo.Data;
                            pwszIME[CCH_KL_LIBNAME - 1] = L'\0';
                            if (!lstrcmpi(pwszIME, pszImeFileName)) {
                                /*
                                 * IME file name match !!
                                 */
                                fFound = TRUE;
                                break;
                            }
                        }
                    }
                }
            }
            else {
                break;
            }
        }
        NtClose(hKey);
    }

    if (fFound)
        return wLayoutId;

    return 0;
}

/***************************************************************************\
* GetRemoteKeyboardLayout
*
* Returns TRUE if the client winstation specified a keyboard layout.
* If TRUE, the LayoutBuf contains the name of the keyboard layout.
* History:
\***************************************************************************/

extern ULONG GetRemoteKeyboardLayoutFromConfigData(VOID);
extern BOOL GetRemoteInputLanguage(LANGID*, PWCHAR);

BOOL
GetRemoteKeyboardLayout(
    PWCHAR pwszKLName,
    LANGID* pLangId)
{
    ULONG   KeyboardLayout;
    BOOL    fLangDataOK;
    WCHAR   wszImeFileName[FIELD_SIZE(WINSTATIONCLIENTW, imeFileName) / sizeof(WCHAR)];

    /*
     * Skip if this is the main session
     */
    if (!ISREMOTESESSION()) {
        return FALSE;
    }

    KeyboardLayout = GetRemoteKeyboardLayoutFromConfigData();

    fLangDataOK = GetRemoteInputLanguage(pLangId, wszImeFileName);

    if (IS_IME_ENABLED()) {
        if (!fLangDataOK) {
            /*
             * To preserve the W2k/XP behavior,
             * if ClientData was not retrieved
             * and if the machine is IME enabled,
             * bail out here.
             */
            return FALSE;
        }

        if (IS_IME_KBDLAYOUT(KeyboardLayout)) {
            KeyboardLayout = GetServerIMEKeyboardLayout(wszImeFileName);
        }
    }

    if (KeyboardLayout != 0) {
        wsprintfW(pwszKLName, L"%8.8lx", KeyboardLayout);
        return TRUE;
    }

    return FALSE;
}

ULONG GetRemoteKeyboardLayoutFromConfigData(VOID)
{
    WINSTATIONCONFIG            ConfigData;
    ULONG                       Length;

    if (!ISREMOTESESSION()) {
        RIPMSGF0(RIP_WARNING, "This is not a remote session!");
    }

    /*
     * Fetch the WinStation's basic information
     */
    if (!WinStationQueryInformationW(SERVERNAME_CURRENT,
                                     LOGONID_CURRENT,
                                     WinStationConfiguration,
                                     &ConfigData,
                                     sizeof(ConfigData),
                                     &Length)) {

        RIPMSGF0(RIP_WARNING, "Failed to get remote client ConfigData.");
        return 0;
    }

    RIPMSGF1(RIP_WARNING, "The keyboard layout is %08x", ConfigData.User.KeyboardLayout);

    return ConfigData.User.KeyboardLayout;
}

BOOL GetRemoteInputLanguage(LANGID* pLangId,
                            PWCHAR pwszImeFileName)
{
    WINSTATIONCLIENTW           ClientData;
    ULONG                       Length;

    if (!ISREMOTESESSION()) {
        RIPMSGF0(RIP_WARNING, "This is not a remote session!");
    }

    /*
     * Fetch the more remote client information.
     * N.b. this and above functions are departed from GetRemoteKeyboardLayout()
     * to reduce the stack consumption.
     */
    if (!WinStationQueryInformationW(SERVERNAME_CURRENT,
                                     LOGONID_CURRENT,
                                     WinStationClient,
                                     &ClientData,
                                     sizeof(ClientData),
                                     &Length)) {
        RIPMSGF0(RIP_WARNING, "Failed to get the remote ClientData -> no info about the langid");
        *pLangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
        return FALSE;
    }

    *pLangId = LOWORD(ClientData.ActiveInputLocale);
    TAGMSGF1(DBGTAG_KBD, "remote InputLocale is %08x", (DWORD)*pLangId);
    RtlCopyMemory(pwszImeFileName, ClientData.imeFileName, sizeof ClientData.imeFileName);
    return TRUE;
}


/***************************************************************************\
* CommonCreateWindowStation (API)
*
* Creates a windowstation object
*
* History:
\***************************************************************************/

HWINSTA CommonCreateWindowStation(
    PUNICODE_STRING         pstrName,
    ACCESS_MASK             amRequest,
    DWORD                   dwFlags,
    PSECURITY_ATTRIBUTES    lpsa)
{
    OBJECT_ATTRIBUTES   Obja;
    HANDLE              hRootDirectory;
    HWINSTA             hwinstaNew = NULL;
    WCHAR               wszKLName[KL_NAMELENGTH];
    HANDLE              hKeyboardFile = NULL;
    DWORD               offTable;
    UNICODE_STRING      strKLID;
    UINT                uKbdInputLocale, uFlags;
    NTSTATUS            Status;

    /*
     * Load initial keyboard layout.  Continue even if
     * this fails (esp. important with KLF_INITTIME set)
     */
    ULONG               KeyboardLayout = 0;

    KBDTABLE_MULTI_INTERNAL kbdTableMulti;

    extern BOOL CtxInitUser32(VOID);

    TAGMSGF0(DBGTAG_KBD, "entering");

    hKeyboardFile = NULL;

    /*
     * Get winstation info
     */
    if (ISREMOTESESSION()) {
        LANGID langidKbd;

        if (GetRemoteKeyboardLayout(wszKLName, &langidKbd)) {    // will we make the short-cut version?
            uFlags = KLF_ACTIVATE | KLF_INITTIME;
            hKeyboardFile = OpenKeyboardLayoutFile(wszKLName, langidKbd,
                                                   &uFlags, &offTable, &uKbdInputLocale, &kbdTableMulti);
            if (hKeyboardFile == NULL) {
                RIPMSGF0(RIP_WARNING, "OpenKeyboardLayoutFile() failed for the remote layout, will use the fallback.");
            }
        }
    }

    if (hKeyboardFile == NULL) {

        GetActiveKeyboardName(wszKLName);
retry:
        uFlags = KLF_ACTIVATE | KLF_INITTIME;
        hKeyboardFile = OpenKeyboardLayoutFile(wszKLName, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                &uFlags, &offTable, &uKbdInputLocale, &kbdTableMulti);
        if (hKeyboardFile == NULL) {
            if (wcscmp(wszKLName, L"00000409")) {
                wcscpy(wszKLName, L"00000409");
                RIPMSG0(RIP_WARNING, "OpendKeyboardLayoutFile() failed: will use the fallback keyboard layout.");
                goto retry;
            }
            uKbdInputLocale = 0x04090409;
        }
    }


    /*
     * Finish the rest of the DLL initialization for WinStations.
     * Until this point we had no video driver.
     *
     * clupu: We have to prevent this for NOIO windowstations !!!
     */
    if (ISTS()) {
        if (!CtxInitUser32()) {
            RIPMSG0(RIP_WARNING, "CtxInitUser32 failed");
            goto Exit;
        }
    }

    RtlInitUnicodeString(&strKLID, wszKLName);

    /*
     * If a name was specified, open the parent directory.  Be sure
     * to test the length rather than the buffer because for NULL
     * string RtlCreateUnicodeStringFromAsciiz will allocate a
     * buffer pointing to an empty string.
     */
    if (pstrName->Length != 0) {
        InitializeObjectAttributes(&Obja,
                                   (PUNICODE_STRING)&strRootDirectory,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL, NULL);
        Status = NtOpenDirectoryObject(&hRootDirectory,
                DIRECTORY_CREATE_OBJECT, &Obja);
        if (!NT_SUCCESS(Status)) {
            RIPNTERR0(Status, RIP_VERBOSE, "");
            goto Exit;
        }
    } else {
        pstrName = NULL;
        hRootDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja,
                               pstrName,
                               OBJ_CASE_INSENSITIVE  |
                               ((dwFlags & CWF_CREATE_ONLY) ? 0 : OBJ_OPENIF) |
                               ((lpsa && lpsa->bInheritHandle) ? OBJ_INHERIT : 0),
                               hRootDirectory,
                               lpsa ? lpsa->lpSecurityDescriptor : NULL);

    /*
     * NULL hKeyboardFile will let the kernel to utilize
     * the kbdnull layout which is a built in as a fallback layout
     * in Win32k.sys.
     */
    hwinstaNew = NtUserCreateWindowStation(
                            &Obja,
                            amRequest,
                            hKeyboardFile,
                            offTable,
                            &kbdTableMulti,
                            &strKLID,
                            uKbdInputLocale);

    if (hRootDirectory != NULL)
        NtClose(hRootDirectory);
Exit:
    if (hKeyboardFile) {
        NtClose(hKeyboardFile);
    }
    return hwinstaNew;
}


FUNCLOG4(LOG_GENERAL, HWINSTA, DUMMYCALLINGTYPE, CreateWindowStationA, LPCSTR, pwinsta, DWORD, dwFlags, ACCESS_MASK, amRequest, PSECURITY_ATTRIBUTES, lpsa)
HWINSTA CreateWindowStationA(
    LPCSTR      pwinsta,
    DWORD       dwFlags,
    ACCESS_MASK amRequest,
    PSECURITY_ATTRIBUTES lpsa)
{
    UNICODE_STRING UnicodeString;
    HWINSTA hwinsta;

    if (!RtlCreateUnicodeStringFromAsciiz(&UnicodeString, pwinsta))
        return NULL;

    hwinsta = CommonCreateWindowStation(&UnicodeString, amRequest, dwFlags, lpsa);

    RtlFreeUnicodeString(&UnicodeString);

    return hwinsta;
}


FUNCLOG4(LOG_GENERAL, HWINSTA, DUMMYCALLINGTYPE, CreateWindowStationW, LPCWSTR, pwinsta, DWORD, dwFlags, ACCESS_MASK, amRequest, PSECURITY_ATTRIBUTES, lpsa)
HWINSTA CreateWindowStationW(
    LPCWSTR     pwinsta,
    DWORD       dwFlags,
    ACCESS_MASK amRequest,
    PSECURITY_ATTRIBUTES lpsa)
{
    UNICODE_STRING strWinSta;

    RtlInitUnicodeString(&strWinSta, pwinsta);

    return CommonCreateWindowStation(&strWinSta, amRequest, dwFlags, lpsa);
}


/***************************************************************************\
* OpenWindowStation (API)
*
* Opens a windowstation object
*
* History:
\***************************************************************************/

HWINSTA CommonOpenWindowStation(
    CONST UNICODE_STRING *pstrName,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    WCHAR awchName[sizeof(WINSTA_NAME) / sizeof(WCHAR)];
    UNICODE_STRING strDefaultName;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE hRootDirectory;
    HWINSTA hwinsta;
    NTSTATUS Status;

    InitializeObjectAttributes(&ObjA,
                               (PUNICODE_STRING)&strRootDirectory,
                               OBJ_CASE_INSENSITIVE,
                               NULL, NULL);
    Status = NtOpenDirectoryObject(&hRootDirectory,
                                   DIRECTORY_TRAVERSE,
                                   &ObjA);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return NULL;
    }

    if (pstrName->Length == 0) {
        RtlCopyMemory(awchName, WINSTA_NAME, sizeof(WINSTA_NAME));
        RtlInitUnicodeString(&strDefaultName, awchName);
        pstrName = &strDefaultName;
    }

    InitializeObjectAttributes(&ObjA,
                               (PUNICODE_STRING)pstrName,
                               OBJ_CASE_INSENSITIVE,
                               hRootDirectory,
                               NULL);
    if (fInherit)
        ObjA.Attributes |= OBJ_INHERIT;

    hwinsta = NtUserOpenWindowStation(&ObjA, amRequest);

    NtClose(hRootDirectory);

    return hwinsta;
}


FUNCLOG3(LOG_GENERAL, HWINSTA, DUMMYCALLINGTYPE, OpenWindowStationA, LPCSTR, pwinsta, BOOL, fInherit, ACCESS_MASK, amRequest)
HWINSTA OpenWindowStationA(
    LPCSTR pwinsta,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    UNICODE_STRING UnicodeString;
    HWINSTA hwinsta;

    if (!RtlCreateUnicodeStringFromAsciiz(&UnicodeString, pwinsta))
        return NULL;

    hwinsta = CommonOpenWindowStation(&UnicodeString, fInherit, amRequest);

    RtlFreeUnicodeString(&UnicodeString);

    return hwinsta;
}


FUNCLOG3(LOG_GENERAL, HWINSTA, DUMMYCALLINGTYPE, OpenWindowStationW, LPCWSTR, pwinsta, BOOL, fInherit, ACCESS_MASK, amRequest)
HWINSTA OpenWindowStationW(
    LPCWSTR pwinsta,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    UNICODE_STRING strWinSta;

    RtlInitUnicodeString(&strWinSta, pwinsta);

    return CommonOpenWindowStation(&strWinSta, fInherit, amRequest);
}

/***************************************************************************\
* CommonCreateDesktop (API)
*
* Creates a desktop object
*
* History:
\***************************************************************************/

HDESK CommonCreateDesktop(
    PUNICODE_STRING pstrDesktop,
    PUNICODE_STRING pstrDevice,
    LPDEVMODEW      pDevmode,
    DWORD           dwFlags,
    ACCESS_MASK     amRequest,
    PSECURITY_ATTRIBUTES lpsa)
{
    OBJECT_ATTRIBUTES Obja;
    HDESK hdesk = NULL;

    InitializeObjectAttributes(&Obja,
                               pstrDesktop,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENIF |
                                   ((lpsa && lpsa->bInheritHandle) ? OBJ_INHERIT : 0),
                               NtUserGetProcessWindowStation(),
                               lpsa ? lpsa->lpSecurityDescriptor : NULL);

    hdesk = NtUserCreateDesktop(&Obja,
                                pstrDevice,
                                pDevmode,
                                dwFlags,
                                amRequest);

    return hdesk;
}

/***************************************************************************\
* CreateDesktopA (API)
*
* Creates a desktop object
*
* History:
\***************************************************************************/


FUNCLOG6(LOG_GENERAL, HDESK, DUMMYCALLINGTYPE, CreateDesktopA, LPCSTR, pDesktop, LPCSTR, pDevice, LPDEVMODEA, pDevmode, DWORD, dwFlags, ACCESS_MASK, amRequest, PSECURITY_ATTRIBUTES, lpsa)
HDESK CreateDesktopA(
    LPCSTR pDesktop,
    LPCSTR pDevice,
    LPDEVMODEA pDevmode,
    DWORD dwFlags,
    ACCESS_MASK amRequest,
    PSECURITY_ATTRIBUTES lpsa)
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeDesktop;
    UNICODE_STRING UnicodeDevice;
    PUNICODE_STRING pUnicodeDevice = NULL;
    LPDEVMODEW lpDevModeW = NULL;
    HDESK hdesk;

    RtlInitAnsiString(&AnsiString, pDesktop);
    Status = RtlAnsiStringToUnicodeString(&UnicodeDesktop, &AnsiString, TRUE);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR1(Status,
                  RIP_WARNING,
                  "CreateDesktop fails with Status = 0x%x",
                  Status);
        return NULL;
    }

    if (pDevice) {
        pUnicodeDevice = &UnicodeDevice;
        RtlInitAnsiString(&AnsiString, pDevice);
        Status = RtlAnsiStringToUnicodeString(&UnicodeDevice, &AnsiString, TRUE);

        if (!NT_SUCCESS(Status)) {
            RIPNTERR0(Status, RIP_VERBOSE, "");
            RtlFreeUnicodeString(&UnicodeDesktop);
            return NULL;
        }
    }

    if (pDevmode) {
        lpDevModeW = GdiConvertToDevmodeW(pDevmode);
    }

    hdesk = CommonCreateDesktop(&UnicodeDesktop,
                                pUnicodeDevice,
                                lpDevModeW,
                                dwFlags,
                                amRequest,
                                lpsa);

    RtlFreeUnicodeString(&UnicodeDesktop);
    if (pDevice) {
        RtlFreeUnicodeString(&UnicodeDevice);
    }

    if (lpDevModeW) {
        RtlFreeHeap(RtlProcessHeap(), 0, lpDevModeW);
    }

    return hdesk;
}

/***************************************************************************\
* CreateDesktopW (API)
*
* Creates a desktop object
*
* History:
\***************************************************************************/


FUNCLOG6(LOG_GENERAL, HDESK, DUMMYCALLINGTYPE, CreateDesktopW, LPCWSTR, pDesktop, LPCWSTR, pDevice, LPDEVMODEW, pDevmode, DWORD, dwFlags, ACCESS_MASK, amRequest, PSECURITY_ATTRIBUTES, lpsa)
HDESK CreateDesktopW(
    LPCWSTR pDesktop,
    LPCWSTR pDevice,
    LPDEVMODEW pDevmode,
    DWORD dwFlags,
    ACCESS_MASK amRequest,
    PSECURITY_ATTRIBUTES lpsa)
{
    UNICODE_STRING strDesktop;
    UNICODE_STRING strDevice;

    RtlInitUnicodeString(&strDesktop, pDesktop);
    RtlInitUnicodeString(&strDevice, pDevice);

    return CommonCreateDesktop(&strDesktop,
                               pDevice ? &strDevice : NULL,
                               pDevmode,
                               dwFlags,
                               amRequest,
                               lpsa);
}

/***************************************************************************\
* OpenDesktop (API)
*
* Opens a desktop object
*
* History:
\***************************************************************************/

HDESK CommonOpenDesktop(
    PUNICODE_STRING pstrDesktop,
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    OBJECT_ATTRIBUTES ObjA;

    InitializeObjectAttributes(&ObjA,
                               pstrDesktop,
                               OBJ_CASE_INSENSITIVE,
                               NtUserGetProcessWindowStation(),
                               NULL);
    if (fInherit) {
        ObjA.Attributes |= OBJ_INHERIT;
    }

    return NtUserOpenDesktop(&ObjA, dwFlags, amRequest);
}


FUNCLOG4(LOG_GENERAL, HDESK, DUMMYCALLINGTYPE, OpenDesktopA, LPCSTR, pdesktop, DWORD, dwFlags, BOOL, fInherit, ACCESS_MASK, amRequest)
HDESK OpenDesktopA(
    LPCSTR pdesktop,
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    UNICODE_STRING UnicodeString;
    HDESK hdesk;

    if (!RtlCreateUnicodeStringFromAsciiz(&UnicodeString, pdesktop))
        return NULL;

    hdesk = CommonOpenDesktop(&UnicodeString, dwFlags, fInherit, amRequest);

    RtlFreeUnicodeString(&UnicodeString);

    return hdesk;
}


FUNCLOG4(LOG_GENERAL, HDESK, DUMMYCALLINGTYPE, OpenDesktopW, LPCWSTR, pdesktop, DWORD, dwFlags, BOOL, fInherit, ACCESS_MASK, amRequest)
HDESK OpenDesktopW(
    LPCWSTR pdesktop,
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    UNICODE_STRING strDesktop;

    RtlInitUnicodeString(&strDesktop, pdesktop);

    return CommonOpenDesktop(&strDesktop, dwFlags, fInherit, amRequest);
}

/***************************************************************************\
* RegisterClassWOW(API)
*
* History:
* 28-Jul-1992 ChandanC Created.
\***************************************************************************/
ATOM
WINAPI
RegisterClassWOWA(
    WNDCLASSA *lpWndClass,
    LPDWORD pdwWOWstuff)
{
    WNDCLASSEXA wc;

    /*
     * On 64-bit plaforms we'll have 32 bits of padding between style and
     * lpfnWndProc in WNDCLASS, so start the copy from the first 64-bit
     * aligned field and hand copy the rest.
     */
    RtlCopyMemory(&(wc.lpfnWndProc), &(lpWndClass->lpfnWndProc), sizeof(WNDCLASSA) - FIELD_OFFSET(WNDCLASSA, lpfnWndProc));
    wc.style = lpWndClass->style;
    wc.hIconSm = NULL;
    wc.cbSize = sizeof(WNDCLASSEXA);

    return RegisterClassExWOWA(&wc, pdwWOWstuff, 0, 0);
}


/**************************************************************************\
* WowGetDefWindowProcBits - Fills in bit array for WOW
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

WORD WowGetDefWindowProcBits(
    PBYTE    pDefWindowProcBits,
    WORD     cbDefWindowProcBits)
{
    WORD  wMaxMsg;
    KPBYTE pbSrc;
    PBYTE pbDst, pbDstEnd;

    UNREFERENCED_PARAMETER(cbDefWindowProcBits);

    /*
     * Merge the bits from gpsi->gabDefWindowMsgs and
     * gpsi->gabDefWindowSpecMsgs into WOW's DefWindowProcBits.  These two
     * indicate which messages must go directly to the server and which
     * can be handled with some special code in DefWindowProcWorker.
     * Bitwise OR'ing the two gives a bit array with 1 in the bit field
     * for each message that must go to user32's DefWindowProc, and 0
     * for those that can be returned back to the client immediately.
     *
     * For speed we assume WOW has zeroed the buffer, in fact it's in
     * USER.EXE's code segment and is zeroed in the image.
     */

    wMaxMsg = max(gSharedInfo.DefWindowMsgs.maxMsgs,
            gSharedInfo.DefWindowSpecMsgs.maxMsgs);

    UserAssert((wMaxMsg / 8 + 1) <= cbDefWindowProcBits);

    //
    // If the above assertion fires, the size of the DWPBits array in
    // \nt\private\mvdm\wow16\user\user.asm needs to be increased.
    //

    /* First copy the bits from DefWindowMsgs */

    RtlCopyMemory(
        pDefWindowProcBits,
        gSharedInfo.DefWindowMsgs.abMsgs,
        gSharedInfo.DefWindowMsgs.maxMsgs / 8 + 1
        );

    /* Next OR in the bits from DefWindowSpecMsgs */

    pbSrc = gSharedInfo.DefWindowSpecMsgs.abMsgs;
    pbDst = pDefWindowProcBits;
    pbDstEnd = pbDst + (gSharedInfo.DefWindowSpecMsgs.maxMsgs / 8 + 1);

    while (pbDst < pbDstEnd)
    {
        *pbDst++ |= *pbSrc++;
    }

    return wMaxMsg;
}



FUNCLOG2(LOG_GENERAL, ULONG_PTR, DUMMYCALLINGTYPE, UserRegisterWowHandlers, APFNWOWHANDLERSIN, apfnWowIn, APFNWOWHANDLERSOUT, apfnWowOut)
ULONG_PTR UserRegisterWowHandlers(
    APFNWOWHANDLERSIN apfnWowIn,
    APFNWOWHANDLERSOUT apfnWowOut)
{
    VDM_QUERY_VDM_PROCESS_DATA QueryVdmProcessData;
    NTSTATUS Status;

    //
    // Check the Target Process to see if this is a Wx86 process
    //

    QueryVdmProcessData.IsVdmProcess = FALSE;

    QueryVdmProcessData.ProcessHandle = NtCurrentProcess();

    Status = NtVdmControl(VdmQueryVdmProcess, &QueryVdmProcessData);

    if (!NT_SUCCESS(Status) || QueryVdmProcessData.IsVdmProcess == FALSE) {

        return STATUS_ACCESS_DENIED;
    }

    // In'ees
    pfnLocalAlloc = apfnWowIn->pfnLocalAlloc;
    pfnLocalReAlloc = apfnWowIn->pfnLocalReAlloc;
    pfnLocalLock = apfnWowIn->pfnLocalLock;
    pfnLocalUnlock = apfnWowIn->pfnLocalUnlock;
    pfnLocalSize = apfnWowIn->pfnLocalSize;
    pfnLocalFree = apfnWowIn->pfnLocalFree;
    pfnGetExpWinVer = apfnWowIn->pfnGetExpWinVer;
    pfn16GlobalAlloc = apfnWowIn->pfn16GlobalAlloc;
    pfn16GlobalFree = apfnWowIn->pfn16GlobalFree;
    pfnWowEmptyClipBoard = apfnWowIn->pfnEmptyCB;
    pfnWowEditNextWord = apfnWowIn->pfnWowEditNextWord;
    pfnWowCBStoreHandle = apfnWowIn->pfnWowCBStoreHandle;
    pfnFindResourceExA = apfnWowIn->pfnFindResourceEx;
    pfnLoadResource = apfnWowIn->pfnLoadResource;
    pfnLockResource = apfnWowIn->pfnLockResource;
    pfnUnlockResource = apfnWowIn->pfnUnlockResource;
    pfnFreeResource = apfnWowIn->pfnFreeResource;
    pfnSizeofResource = apfnWowIn->pfnSizeofResource;
    pfnFindResourceExW = WOWFindResourceExWCover;
    pfnWowDlgProcEx = apfnWowIn->pfnWowDlgProcEx;
    pfnWowWndProcEx = apfnWowIn->pfnWowWndProcEx;
    pfnWowGetProcModule = apfnWowIn->pfnGetProcModule16;
    pfnWowTask16SchedNotify = apfnWowIn->pfnWowTask16SchedNotify;
    pfnWOWTellWOWThehDlg = apfnWowIn->pfnWOWTellWOWThehDlg;
    pfnWowMsgBoxIndirectCallback = apfnWowIn->pfnWowMsgBoxIndirectCallback;
    pfnWowIlstrcmp = apfnWowIn->pfnWowIlstrsmp;

    // Out'ees
#if DBG
    apfnWowOut->dwBldInfo = (WINVER << 16) | 0x80000000;
#else
    apfnWowOut->dwBldInfo = (WINVER << 16);
#endif
    apfnWowOut->pfnCsCreateWindowEx            = _CreateWindowEx;
    apfnWowOut->pfnDirectedYield               = DirectedYield;
    apfnWowOut->pfnFreeDDEData                 = FreeDDEData;
    apfnWowOut->pfnGetClassWOWWords            = GetClassWOWWords;
    apfnWowOut->pfnInitTask                    = InitTask;
    apfnWowOut->pfnRegisterClassWOWA           = RegisterClassWOWA;
    apfnWowOut->pfnRegisterUserHungAppHandlers = RegisterUserHungAppHandlers;
    apfnWowOut->pfnServerCreateDialog          = InternalCreateDialog;
    apfnWowOut->pfnServerLoadCreateCursorIcon  = WowServerLoadCreateCursorIcon;
    apfnWowOut->pfnServerLoadCreateMenu        = WowServerLoadCreateMenu;
    apfnWowOut->pfnWOWCleanup                  = WOWCleanup;
    apfnWowOut->pfnWOWModuleUnload             = WOWModuleUnload;
    apfnWowOut->pfnWOWFindWindow               = WOWFindWindow;
    apfnWowOut->pfnWOWLoadBitmapA              = WOWLoadBitmapA;
    apfnWowOut->pfnWowWaitForMsgAndEvent       = NtUserWaitForMsgAndEvent;
    apfnWowOut->pfnYieldTask                   = NtUserYieldTask;
    apfnWowOut->pfnGetFullUserHandle           = GetFullUserHandle;
    apfnWowOut->pfnGetMenuIndex                = NtUserGetMenuIndex;
    apfnWowOut->pfnWowGetDefWindowProcBits     = WowGetDefWindowProcBits;
    apfnWowOut->pfnFillWindow                  = FillWindow;
    apfnWowOut->aiWowClass                     = aiClassWow;
    return (ULONG_PTR)&gSharedInfo;
}

/***************************************************************************\
* GetEditDS
*
* This is a callback to WOW used to allocate a segment for DS_LOCALEDIT
* edit controls.  The segment is disguised to look like a WOW hInstance.
*
* 06-19-92 sanfords Created
\***************************************************************************/
HANDLE GetEditDS()
{
    UserAssert(pfn16GlobalAlloc != NULL);

    return((HANDLE)((*pfn16GlobalAlloc)(GHND | GMEM_SHARE, 256)));
}



/***************************************************************************\
* ReleaseEditDS
*
* This is a callback to WOW used to free a segment for DS_LOCALEDIT
* edit controls.
*
* 06-19-92 sanfords Created
\***************************************************************************/
VOID ReleaseEditDS(
HANDLE h)
{
    UserAssert(pfn16GlobalFree != NULL);

    (*pfn16GlobalFree)(LOWORD(HandleToUlong(h)));
}



/***************************************************************************\
* TellWOWThehDlg
*
* This is a callback to WOW used to inform WOW of the hDlg of a newly
* created dialog window.
*
* 08-31-97 cmjones  Created
\***************************************************************************/
VOID TellWOWThehDlg(
HWND hDlg)
{
    UserAssert(pfnWOWTellWOWThehDlg != NULL);

    (*pfnWOWTellWOWThehDlg)(hDlg);
}



/***************************************************************************\
* DispatchClientMessage
*
* pwnd is threadlocked in the kernel and thus always valid.
*
* 19-Aug-1992 mikeke   created
\***************************************************************************/
LRESULT DispatchClientMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR pfn)
{
    PCLIENTINFO pci = GetClientInfo();
    HWND hwnd = KHWND_TO_HWND(pci->CallbackWnd.hwnd);
    PACTIVATION_CONTEXT pActCtx = pci->CallbackWnd.pActCtx;
    LRESULT lRet = 0;

    /*
     * Assert that the header comment is legit (it must be). For WM_TIMER
     * messages not associated with a window, pwnd can be NULL. So don't
     * rip validating the handle.
     */
    UserAssert(pwnd == ValidateHwndNoRip(hwnd));

    /*
     * Add assert to catch dispatching messages to a thread not associated
     * with a desktop.
     */
    UserAssert(GetClientInfo()->ulClientDelta != 0);

    if (message == WM_TIMER && lParam != 0) {
        /*
         * Console windows use WM_TIMER for the caret. However, they don't
         * use a timer callback, so if this is CSRSS and there's a WM_TIMER
         * for us, the only way lParam would be non-zero is if someone's trying
         * to make us fault. No, this isn't a nice thing to do, but there
         * are bad, bad people out there. Windows Bug #361246.
         */
        if (!gfServerProcess) {
            /*
             * We can't really trust what's in lParam, so make sure we
             * handle any exceptions that occur during this call.
             */
            try {
                lRet = UserCallWinProcCheckWow(pActCtx,
                                               (WNDPROC)pfn,
                                               hwnd,
                                               message,
                                               wParam,
                                               NtGetTickCount(),
                                               &(pwnd->state),
                                               TRUE);
            } except ((GetAppCompatFlags2(VER40) & GACF2_NO_TRYEXCEPT_CALLWNDPROC) ?
                      EXCEPTION_CONTINUE_SEARCH : W32ExceptionHandler(FALSE, RIP_WARNING)) {
                      /*
                       * Windows NT Bug #359866.
                       * Some applications like Hagaki Studio 2000 need to handle
                       * the exception in WndProc in their handler, even though it
                       * skips the API calls. For those apps, we have to honor the
                       * behavior of NT4, with no protection.
                       */
            }
        }
    } else {
        lRet = UserCallWinProcCheckWow(pActCtx, (WNDPROC)pfn, hwnd, message, wParam, lParam, &(pwnd->state), TRUE);
    }

    return lRet;
}

/**************************************************************************\
* ArrangeIconicWindows
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, ArrangeIconicWindows, HWND, hwnd)
UINT ArrangeIconicWindows(
    HWND hwnd)
{
    return (UINT)NtUserCallHwndLock(hwnd, SFI_XXXARRANGEICONICWINDOWS);
}

/**************************************************************************\
* BeginDeferWindowPos
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, HANDLE, DUMMYCALLINGTYPE, BeginDeferWindowPos, int, nNumWindows)
HANDLE BeginDeferWindowPos(
    int nNumWindows)
{
    if (nNumWindows < 0) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"nNumWindows\" (%ld) to BeginDeferWindowPos",
                nNumWindows);

        return 0;
    }

    return (HANDLE)NtUserCallOneParam(nNumWindows, SFI__BEGINDEFERWINDOWPOS);
}

/**************************************************************************\
* EndDeferWindowPos
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EndDeferWindowPos, HDWP, hWinPosInfo)
BOOL EndDeferWindowPos(
    HDWP hWinPosInfo)
{
    return NtUserEndDeferWindowPosEx(hWinPosInfo, FALSE);
}

/**************************************************************************\
* CascadeChildWindows
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CascadeChildWindows, HWND, hwndParent, UINT, nCode)
BOOL CascadeChildWindows(
    HWND hwndParent,
    UINT nCode)
{
    return (BOOL) CascadeWindows(hwndParent, nCode, NULL, 0, NULL);
}

/**************************************************************************\
* CloseWindow
*
* 22-Jul-1991 mikeke    Created
* 17-Feb-1998 MCostea   Use xxxShowWindow instead of xxxCloseWindow
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CloseWindow, HWND, hwnd)
BOOL CloseWindow(
    HWND hwnd)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return FALSE;
    }
    if (!TestWF(pwnd, WFMINIMIZED)) {
        NtUserShowWindow(hwnd, SW_SHOWMINIMIZED);
    }
    return TRUE;
}

/**************************************************************************\
* CreateMenu
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

HMENU CreateMenu()
{
    return (HMENU)NtUserCallNoParam(SFI__CREATEMENU);
}

/**************************************************************************\
* CreatePopupMenu
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

HMENU CreatePopupMenu()
{
    return (HMENU)NtUserCallNoParam(SFI__CREATEPOPUPMENU);
}

/**************************************************************************\
* CurrentTaskLock
*
* 21-Apr-1992 jonpa    Created
\**************************************************************************/
#if 0 /* WOW is not using this but they might some day */
DWORD CurrentTaskLock(
    DWORD hlck)
{
    return (DWORD)NtUserCallOneParam(hlck, SFI_CURRENTTASKLOCK);
}
#endif
/**************************************************************************\
* DestroyCaret
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

BOOL DestroyCaret()
{
    return (BOOL)NtUserCallNoParam(SFI_ZZZDESTROYCARET);
}

/**************************************************************************\
* DirectedYield
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

void DirectedYield(
    DWORD dwThreadId)
{
    NtUserCallOneParam(dwThreadId, SFI_XXXDIRECTEDYIELD);
}

/**************************************************************************\
* DrawMenuBar
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawMenuBar, HWND, hwnd)
BOOL DrawMenuBar(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwndLock(hwnd, SFI_XXXDRAWMENUBAR);
}

/**************************************************************************\
* EnableWindow
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnableWindow, HWND, hwnd, BOOL, bEnable)
BOOL EnableWindow(
    HWND hwnd,
    BOOL bEnable)
{
    return (BOOL)NtUserCallHwndParamLock(hwnd, bEnable,
                                         SFI_XXXENABLEWINDOW);
}

/**************************************************************************\
* EnumClipboardFormats
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, EnumClipboardFormats, UINT, fmt)
UINT EnumClipboardFormats(
    UINT fmt)
{
    /*
     * So apps can tell if the API failed or just ran out of formats
     * we "clear" the last error.
     */
    UserSetLastError(ERROR_SUCCESS);

    return (UINT)NtUserCallOneParam(fmt, SFI__ENUMCLIPBOARDFORMATS);
}

/**************************************************************************\
* FlashWindow
*
* 22-Jul-1991 mikeke    Created
* 08-Aug-1997 Gerardob  Added FlashWindowEx.
* 16-Nov-1997 MCostea   Make it use NtUserFlashWindowEx
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, FlashWindow, HWND, hwnd, BOOL, bInvert)
BOOL FlashWindow(
    HWND hwnd,
    BOOL bInvert)
{
    FLASHWINFO fwi = {
            sizeof(FLASHWINFO), // cbSize
            hwnd,   // hwnd
            bInvert ? (FLASHW_CAPTION | FLASHW_TRAY) : 0,   // flags
            1,      // uCount
            0       // dwTimeout
        };
    return (BOOL)NtUserFlashWindowEx(&fwi);
}

/**************************************************************************\
* GetDialogBaseUnits
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
LONG GetDialogBaseUnits(
    VOID)
{
    return MAKELONG(gpsi->cxSysFontChar, gpsi->cySysFontChar);
}

/**************************************************************************\
* GetInputDesktop
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
HDESK GetInputDesktop(
    VOID)
{
    return (HDESK)NtUserCallNoParam(SFI__GETINPUTDESKTOP);
}

/***************************************************************************\
* GetClientKeyboardType
*
* This routine returns the keyboard type sent from the Hydra client.
* Hydra client sends keyboard types at session startup.
*
* Returns the client winstation specified a keyboard type.
* History:
\***************************************************************************/
BOOL GetClientKeyboardType(
    PCLIENTKEYBOARDTYPE KeyboardType)
{
    ULONG Length;
    WINSTATIONCLIENTW ClientData;
    static CLIENTKEYBOARDTYPE ClientKeyboard = { (ULONG)-1, (ULONG)-1, (ULONG)-1 };

    //
    // Should be called only if this is a HYDRA remote session.
    //
    if (!ISREMOTESESSION()) {
        RIPMSGF0(RIP_WARNING, "This is not a remote session!");
    }

    //  Skip if this is the console
    if (!ISREMOTESESSION()) {
        return FALSE;
    }

    if (ClientKeyboard.Type == (ULONG)-1) {

        // Fetch the WinStation's basic information
        if (!WinStationQueryInformationW(SERVERNAME_CURRENT,
                                         LOGONID_CURRENT,
                                         WinStationClient,
                                         &ClientData,
                                         sizeof(ClientData),
                                         &Length)) {
            return FALSE;
        }

        ClientKeyboard.Type        = ClientData.KeyboardType;
        ClientKeyboard.SubType     = ClientData.KeyboardSubType;
        ClientKeyboard.FunctionKey = ClientData.KeyboardFunctionKey;

    }

    *KeyboardType = ClientKeyboard;

    return TRUE;
}


/**************************************************************************\
* GetKeyboardType
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetKeyboardType, int, nTypeFlags)
int GetKeyboardType(
    int nTypeFlags)
{
    if (ISREMOTESESSION()) {
        //
        //  Get keyboard type from Hydra client if this is not the console
        //
        CLIENTKEYBOARDTYPE KeyboardType;

        if (GetClientKeyboardType(&KeyboardType)) {
            switch (nTypeFlags) {
            case 0:
                return KeyboardType.Type;
            case 1:
                if (KeyboardType.Type == 7) {               /* 7 is a Japanese */
                    // Because HIWORD has been using private value
                    // for Japanese keyboard layout.
                    return LOWORD(KeyboardType.SubType);
                }
                else
                    return KeyboardType.SubType;
            case 2:
                return KeyboardType.FunctionKey;
            default:
                break;
            }
        }
        return 0;
    }
    return (int)NtUserCallOneParam(nTypeFlags, SFI__GETKEYBOARDTYPE);
}

/**************************************************************************\
* GetMessagePos
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

DWORD GetMessagePos()
{
    return (DWORD)NtUserCallNoParam(SFI__GETMESSAGEPOS);
}

/**************************************************************************\
* GetQueueStatus
*
* 22-Jul-1991   mikeke      Created
* 14-Dec-2000   JStall      Converted to WMH
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetQueueStatus, UINT, flags)
DWORD GetQueueStatus(
    UINT flags)
#ifdef MESSAGE_PUMP_HOOK
{
    DWORD dwResult;

    BEGIN_MESSAGEPUMPHOOK()
        if (fInsideHook) {
            dwResult = gmph.pfnGetQueueStatus(flags);
        } else {
            dwResult = RealGetQueueStatus(flags);
        }
    END_MESSAGEPUMPHOOK()

    return dwResult;
}


DWORD RealGetQueueStatus(
    UINT flags)
#endif
{
    if (flags & ~QS_VALID) {
        RIPERR2(ERROR_INVALID_FLAGS, RIP_WARNING, "Invalid flags %x & ~%x != 0",
              flags, QS_VALID);
        return 0;
    }

    return (DWORD)NtUserCallOneParam(flags, SFI__GETQUEUESTATUS);
}

/**************************************************************************\
* KillSystemTimer
*
* 7-Jul-1992 mikehar    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, KillSystemTimer, HWND, hwnd, UINT, nIDEvent)
BOOL KillSystemTimer(
    HWND hwnd,
    UINT nIDEvent)
{
    return (BOOL)NtUserCallHwndParam(hwnd, nIDEvent, SFI__KILLSYSTEMTIMER);
}

/**************************************************************************\
* LoadRemoteFonts
*  02-Dec-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

void LoadRemoteFonts(void)
{
    NtUserCallOneParam(TRUE,SFI_XXXLW_LOADFONTS);

    /*
     * After load remote fonts, let eudc enabled.
     */
    EnableEUDC(TRUE);
}


/**************************************************************************\
* LoadLocalFonts
*  31-Mar-1994 -by- Bodin Dresevic [gerritv]
* Wrote it.
\**************************************************************************/

void LoadLocalFonts(void)
{
    NtUserCallOneParam(FALSE,SFI_XXXLW_LOADFONTS);
}


/**************************************************************************\
* MessageBeep
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, MessageBeep, UINT, wType)
BOOL MessageBeep(
    UINT wType)
{
    return (BOOL)NtUserCallOneParam(wType, SFI_XXXMESSAGEBEEP);
}

/**************************************************************************\
* OpenIcon
*
* 22-Jul-1991 mikeke    Created
* 17-Feb-1998 MCostea   Use xxxShowWindow instead of xxxCloseWindow
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, OpenIcon, HWND, hwnd)
BOOL OpenIcon(
    HWND hwnd)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return FALSE;
    }
    if (TestWF(pwnd, WFMINIMIZED)) {
        NtUserShowWindow(hwnd, SW_NORMAL);
    }
    return TRUE;
}

HWND GetShellWindow(void) {
    PCLIENTINFO pci;
    PWND pwnd;

    ConnectIfNecessary(0);

    pci = GetClientInfo();
    pwnd = pci->pDeskInfo->spwndShell;
    if (pwnd != NULL) {
        pwnd = (PWND)((KERNEL_ULONG_PTR)pwnd - pci->ulClientDelta);
        return HWq(pwnd);
    }
    return NULL;
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetShellWindow, HWND, hwnd)
BOOL  SetShellWindow(HWND hwnd)
{
    return (BOOL)NtUserSetShellWindowEx(hwnd, hwnd);
}

HWND GetProgmanWindow(void) {
    PCLIENTINFO pci;
    PWND pwnd;

    ConnectIfNecessary(0);

    pci = GetClientInfo();
    pwnd = pci->pDeskInfo->spwndProgman;
    if (pwnd != NULL) {
        pwnd = (PWND)((KERNEL_ULONG_PTR)pwnd - pci->ulClientDelta);
        return HWq(pwnd);
    }
    return NULL;
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetProgmanWindow, HWND, hwnd)
BOOL  SetProgmanWindow(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwndOpt(hwnd, SFI__SETPROGMANWINDOW);
}

HWND GetTaskmanWindow(void) {
    PCLIENTINFO pci;
    PWND pwnd;

    ConnectIfNecessary(0);

    pci = GetClientInfo();
    pwnd = pci->pDeskInfo->spwndTaskman;
    if (pwnd != NULL) {
        pwnd = (PWND)((KERNEL_ULONG_PTR)pwnd - pci->ulClientDelta);
        return HWq(pwnd);
    }
    return NULL;
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetTaskmanWindow, HWND, hwnd)
BOOL  SetTaskmanWindow(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwndOpt(hwnd, SFI__SETTASKMANWINDOW);
}

/**************************************************************************\
* SetWindowContextHelpId
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetWindowContextHelpId, HWND, hwnd, DWORD, id)
BOOL SetWindowContextHelpId(
    HWND hwnd,
    DWORD id)
{
    return (BOOL)NtUserCallHwndParam(hwnd, id, SFI__SETWINDOWCONTEXTHELPID);
}

/**************************************************************************\
* GetWindowContextHelpId
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetWindowContextHelpId, HWND, hwnd)
DWORD GetWindowContextHelpId(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwnd(hwnd, SFI__GETWINDOWCONTEXTHELPID);
}

VOID SetWindowState(
    PWND pwnd,
    UINT flags)
{
    if (TestWF(pwnd, flags) != LOBYTE(flags)) {
        NtUserCallHwndParam(HWq(pwnd), flags, SFI_SETWINDOWSTATE);
    }
}

VOID ClearWindowState(
    PWND pwnd,
    UINT flags)
{
    if (TestWF(pwnd, flags)) {
        NtUserCallHwndParam(HWq(pwnd), flags, SFI_CLEARWINDOWSTATE);
    }
}

/**************************************************************************\
* PostQuitMessage
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOGVOID1(LOG_GENERAL, DUMMYCALLINGTYPE, PostQuitMessage, int, nExitCode)
VOID PostQuitMessage(
    int nExitCode)
{
    NtUserCallOneParam(nExitCode, SFI__POSTQUITMESSAGE);
}

/**************************************************************************\
* REGISTERUSERHUNAPPHANDLERS
*
* 01-Apr-1992 jonpa    Created
\**************************************************************************/
BOOL RegisterUserHungAppHandlers(
    PFNW32ET pfnW32EndTask,
    HANDLE   hEventWowExec)
{
    return (BOOL)NtUserCallTwoParam((ULONG_PTR)pfnW32EndTask,
                                    (ULONG_PTR)hEventWowExec,
                                    SFI_XXXREGISTERUSERHUNGAPPHANDLERS);
}

/**************************************************************************\
* ReleaseCapture
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
BOOL ReleaseCapture(
    VOID)
{
    return (BOOL)NtUserCallNoParam(SFI_XXXRELEASECAPTURE);
}

/**************************************************************************\
* ReplyMessage
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ReplyMessage, LRESULT, pp1)
BOOL ReplyMessage(
    LRESULT pp1)
{
    return (BOOL)NtUserCallOneParam(pp1, SFI__REPLYMESSAGE);
}

/**************************************************************************\
* RegisterSystemThread
*
* 21-Jun-1994 johnc    Created
\**************************************************************************/
FUNCLOGVOID2(LOG_GENERAL, DUMMYCALLINGTYPE, RegisterSystemThread, DWORD, dwFlags, DWORD, dwReserved)
VOID RegisterSystemThread(
    DWORD dwFlags, DWORD dwReserved)
{
    NtUserCallTwoParam(dwFlags, dwReserved, SFI_ZZZREGISTERSYSTEMTHREAD);
}

/**************************************************************************\
* SetCaretBlinkTime
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetCaretBlinkTime, UINT, wMSeconds)
BOOL SetCaretBlinkTime(
    UINT wMSeconds)
{
    return (BOOL)NtUserCallOneParam(wMSeconds, SFI__SETCARETBLINKTIME);
}

/**************************************************************************\
* SetCaretPos
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetCaretPos, int, X, int, Y)
BOOL SetCaretPos(
    int X,
    int Y)
{
    return (BOOL)NtUserCallTwoParam(X, Y, SFI_ZZZSETCARETPOS);
}

/**************************************************************************\
* SetCursorPos
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetCursorPos, int, X, int, Y)
BOOL SetCursorPos(
    int X,
    int Y)
{
    return (BOOL)NtUserCallTwoParam(X, Y, SFI_ZZZSETCURSORPOS);
}

/**************************************************************************\
* SetDoubleClickTime
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetDoubleClickTime, UINT, cms)
BOOL SetDoubleClickTime(
    UINT cms)
{
    return (BOOL)NtUserCallOneParam(cms, SFI__SETDOUBLECLICKTIME);
}

/**************************************************************************\
* SetForegroundWindow
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetForegroundWindow, HWND, hwnd)
BOOL SetForegroundWindow(
    HWND hwnd)
{
    return NtUserSetForegroundWindow(hwnd);
}

/**************************************************************************\
* AllowSetForegroundWindow
*
* 28-Jan-1998 GerardoB    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, AllowSetForegroundWindow, DWORD, dwProcessId)
BOOL AllowSetForegroundWindow(
    DWORD dwProcessId)
{
    return (BOOL)NtUserCallOneParam(dwProcessId, SFI_XXXALLOWSETFOREGROUNDWINDOW);
}

/**************************************************************************\
* LockSetForegroundWindow
*
* 07-Apr-1998 GerardoB    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, LockSetForegroundWindow, UINT, uLockCode)
BOOL LockSetForegroundWindow(
    UINT uLockCode)
{
    return (BOOL)NtUserCallOneParam(uLockCode, SFI__LOCKSETFOREGROUNDWINDOW);
}

/**************************************************************************\
* ShowCursor
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, int, DUMMYCALLINGTYPE, ShowCursor, BOOL, bShow)
int ShowCursor(
    BOOL bShow)
{
    return (int)NtUserCallOneParam(bShow, SFI_ZZZSHOWCURSOR);
}

/**************************************************************************\
* ShowOwnedPopups
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ShowOwnedPopups, HWND, hwnd, BOOL, fShow)
BOOL ShowOwnedPopups(
    HWND hwnd,
    BOOL fShow)
{
    return (BOOL)NtUserCallHwndParamLock(hwnd, fShow,
                                         SFI_XXXSHOWOWNEDPOPUPS);
}

/**************************************************************************\
* ShowStartGlass
*
* 10-Sep-1992 scottlu    Created
\**************************************************************************/
FUNCLOGVOID1(LOG_GENERAL, DUMMYCALLINGTYPE, ShowStartGlass, DWORD, dwTimeout)
VOID ShowStartGlass(
    DWORD dwTimeout)
{
    NtUserCallOneParam(dwTimeout, SFI_ZZZSHOWSTARTGLASS);
}

/**************************************************************************\
* SwapMouseButton
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SwapMouseButton, BOOL, fSwap)
BOOL SwapMouseButton(
    BOOL fSwap)
{
    return (BOOL)NtUserCallOneParam(fSwap, SFI__SWAPMOUSEBUTTON);
}

/**************************************************************************\
* TileChildWindows
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, TileChildWindows, HWND, hwndParent, UINT, flags)
BOOL TileChildWindows(
    HWND hwndParent,
    UINT flags)
{
    return (BOOL)TileWindows(hwndParent, flags, NULL, 0, NULL);
}

/**************************************************************************\
* UnhookWindowsHook
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, UnhookWindowsHook, int, nCode, HOOKPROC, pfnFilterProc)
BOOL UnhookWindowsHook(
    int nCode,
    HOOKPROC pfnFilterProc)
{
    return (BOOL)NtUserCallTwoParam(nCode, (ULONG_PTR)pfnFilterProc,
                                    SFI_ZZZUNHOOKWINDOWSHOOK);
}

/**************************************************************************\
* UpdateWindow
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, UpdateWindow, HWND, hwnd)
BOOL UpdateWindow(
    HWND hwnd)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return FALSE;
    }

    /*
     * Don't need to do anything if this window does not need any painting
     * and it has no child windows
     */
    if (!NEEDSPAINT(pwnd) && (pwnd->spwndChild == NULL)) {
        return TRUE;
    }

    return (BOOL)NtUserCallHwndLock(hwnd, SFI_XXXUPDATEWINDOW);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, RegisterShellHookWindow, HWND, hwnd)
BOOL RegisterShellHookWindow(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwnd(hwnd, SFI__REGISTERSHELLHOOKWINDOW);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DeregisterShellHookWindow, HWND, hwnd)
BOOL DeregisterShellHookWindow(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwnd(hwnd, SFI__DEREGISTERSHELLHOOKWINDOW);
}

/**************************************************************************\
* UserRealizePalette
*
* 13-Nov-1992 mikeke     Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, UserRealizePalette, HDC, hdc)
UINT UserRealizePalette(
    HDC hdc)
{
    return (UINT)NtUserCallOneParam((ULONG_PTR)hdc, SFI_XXXREALIZEPALETTE);
}

/**************************************************************************\
* WindowFromDC
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, WindowFromDC, HDC, hdc)
HWND WindowFromDC(
    HDC hdc)
{
    return (HWND)NtUserCallOneParam((ULONG_PTR)hdc, SFI__WINDOWFROMDC);
}

/***************************************************************************\
* GetWindowRgn
*
* Parameters:
*     hwnd    --  Window handle
*     hrgn    --  Region to copy window region into
*
* Returns:
*     Region complexity code
*
* Comments:
*     hrgn gets returned in window rect coordinates (not client rect)
*
* 30-JUl-1994 ScottLu    Created.
\***************************************************************************/
FUNCLOG2(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetWindowRgn, HWND, hwnd, HRGN, hrgn)
int GetWindowRgn(
    HWND hwnd,
    HRGN hrgn)
{
    int code;
    PWND pwnd;

    if (hrgn == NULL) {
        return ERROR;
    }

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return ERROR;
    }

    /*
     * If there is no region selected into this window, then return error
     */
    if (pwnd->hrgnClip == NULL || TestWF(pwnd, WFMAXFAKEREGIONAL)) {
        return ERROR;
    }

    code = CombineRgn(hrgn, KHRGN_TO_HRGN(pwnd->hrgnClip), NULL, RGN_COPY);
    if (code == ERROR) {
        return ERROR;
    }

    /*
     * Offset it to window rect coordinates (not client rect coordinates)
     */
    if (GETFNID(pwnd) != FNID_DESKTOP) {
        code = OffsetRgn(hrgn, -pwnd->rcWindow.left, -pwnd->rcWindow.top);
    }

    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        MirrorRgn(HW(pwnd), hrgn);
    }

    return code;
}

/***************************************************************************\
* GetWindowRgnBox
*
* Parameters:
*     hwnd    --  Window handle
*     lprc    --  Rectangle for bounding box
*
* Returns:
*     Region complexity code
*
* Comments:
*     This function is designed after GetWindowRgn(), but does not require
*     an HRGN to be passed in since it only returns the complexity code.
*
* 06-JUN-2000 JStall    Created.
\***************************************************************************/
FUNCLOG2(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetWindowRgnBox, HWND, hwnd, LPRECT, lprc)
int GetWindowRgnBox(
    HWND hwnd,
    LPRECT lprc)
{
    int code;
    PWND pwnd;

    if (lprc == NULL) {
        return ERROR;
    }

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return ERROR;
    }

    /*
     * If there is no region selected into this window, then return error
     */
    if (pwnd->hrgnClip == NULL || TestWF(pwnd, WFMAXFAKEREGIONAL)) {
        return ERROR;
    }

    code = GetRgnBox(KHRGN_TO_HRGN(pwnd->hrgnClip), lprc);
    if (code == ERROR) {
        return ERROR;
    }

    /*
     * Offset it to window rect coordinates (not client rect coordinates)
     */
    if (GETFNID(pwnd) != FNID_DESKTOP) {
        OffsetRect(lprc, -pwnd->rcWindow.left, -pwnd->rcWindow.top);
    }

    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        MirrorWindowRect(pwnd, lprc);
    }

    return code;
}

/***************************************************************************\
* GetActiveKeyboardName
*
* Retrieves the active keyboard layout ID from the registry.
*
* 01-11-95 JimA         Created.
* 03-06-95 GregoryW     Modified to use new registry layout
\***************************************************************************/
VOID GetActiveKeyboardName(
    LPWSTR lpszName)
{
    LPTSTR szKbdActive = TEXT("Active");
    LPTSTR szKbdLayout = TEXT("Keyboard Layout");
    LPTSTR szKbdLayoutPreload = TEXT("Keyboard Layout\\Preload");
    NTSTATUS rc;
    DWORD cbSize;
    HANDLE UserKeyHandle, hKey, hKeyPreload;
    OBJECT_ATTRIBUTES ObjA;
    UNICODE_STRING UnicodeString;
    ULONG CreateDisposition;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        WCHAR KeyLayoutId[KL_NAMELENGTH];
    } KeyValueId;

    /*
     * Load initial keyboard name ( HKEY_CURRENT_USER\Keyboard Layout\Preload\1 )
     */
    rc = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserKeyHandle);
    if (!NT_SUCCESS(rc)) {
        RIPMSGF1(RIP_WARNING, "Could NOT open HKEY_CURRENT_USER (%lx).", rc);
        wcscpy(lpszName, L"00000409");
        return;
    }

    RtlInitUnicodeString(&UnicodeString, szKbdLayoutPreload);
    InitializeObjectAttributes(&ObjA,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               UserKeyHandle,
                               NULL );
    rc = NtOpenKey(&hKey,
                   KEY_ALL_ACCESS,
                   &ObjA );
    if (NT_SUCCESS(rc)) {
        /*
         *  Query the value from the registry.
         */
        RtlInitUnicodeString(&UnicodeString, L"1");

        rc = NtQueryValueKey(hKey,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             &KeyValueId,
                             sizeof(KeyValueId),
                             &cbSize );

        if (rc == STATUS_BUFFER_OVERFLOW) {
            RIPMSGF0(RIP_WARNING, "Buffer overflow.");
            rc = STATUS_SUCCESS;
        }
        if (NT_SUCCESS(rc)) {
            wcsncpycch(lpszName, (LPWSTR)KeyValueId.KeyInfo.Data, KL_NAMELENGTH - 1);
            lpszName[KL_NAMELENGTH - 1] = L'\0';
        } else {
            /*
             * Error reading value...use default
             */
            wcscpy(lpszName, L"00000409");
        }

        NtClose(hKey);
        NtClose(UserKeyHandle);
        if (IS_IME_ENABLED()) {
            CheckValidLayoutName(lpszName);
        }
        return;
    }

    /*
     * NOTE: The code below is only executed the first time a user logs
     *       on after an upgrade from NT3.x to NT4.0.
     *
     * The Preload key does not exist in the registry.  Try reading the
     * old registry entry "Keyboard Layout\Active".  If it exists, we
     * convert it to the new style Preload key.
     */
    RtlInitUnicodeString(&UnicodeString, szKbdLayout);
    InitializeObjectAttributes(&ObjA,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               UserKeyHandle,
                               NULL );
    rc = NtOpenKey(&hKey, KEY_ALL_ACCESS, &ObjA);

    NtClose(UserKeyHandle);

    if (!NT_SUCCESS(rc)) {
        RIPMSGF1(RIP_WARNING,
                 "Could not determine active keyboard layout 0x%x.",
                 rc);
        wcscpy(lpszName, L"00000409");
        return;
    }

    /*
     *  Query the value from the registry.
     */
    RtlInitUnicodeString(&UnicodeString, szKbdActive);

    rc = NtQueryValueKey(hKey,
                         &UnicodeString,
                         KeyValuePartialInformation,
                         &KeyValueId,
                         sizeof(KeyValueId),
                         &cbSize );

    if (rc == STATUS_BUFFER_OVERFLOW) {
        RIPMSGF0(RIP_WARNING, "Buffer overflow.");
        rc = STATUS_SUCCESS;
    }
    if (NT_SUCCESS(rc)) {
        wcsncpycch(lpszName, (LPWSTR)KeyValueId.KeyInfo.Data, KL_NAMELENGTH - 1);
        lpszName[KL_NAMELENGTH - 1] = L'\0';
    } else {
        /*
         * Error reading value...use default
         */
        RIPMSGF1(RIP_WARNING,
                 "Could not query active keyboard layout 0x%x.",
                 rc);
        wcscpy(lpszName, L"00000409");
        NtClose(hKey);
        return;
    }

    /*
     * if 'Active' keyboard layout is for Japanese/Korean layout. just put
     * IME prefix, because user prefer to have keyboard layout with IME as
     * default.
     */
    if (IS_IME_ENABLED()) {
        UINT wLanguageId = (UINT)wcstoul(lpszName, NULL, 16);

        /*
         * Default keyboard layout values.
         *
         * [LATER, if needed]
         *
         * The hard-codeed default value might be wanted
         * come from registry or somewhere...
         */
        CONST LPWSTR lpszJapaneseDefaultLayout = L"E0010411";
        CONST LPWSTR lpszKoreanDefaultLayout   = L"E0010412";

        /*
         * Need to mask off hi-word to look up locale ID, because
         * NEC PC-9800 Series version of Windows NT 3.5 contains
         * bogus value in hi-word.
         */
        wLanguageId &= 0x0000FFFF;

        if (PRIMARYLANGID(wLanguageId) == LANG_JAPANESE) {

            /*
             * Set Japanese default layout Id.
             */
            wcscpy(lpszName,lpszJapaneseDefaultLayout);

        } else if (PRIMARYLANGID(wLanguageId) == LANG_KOREAN) {

            /*
             * Set Korean default layout Id.
             */
            wcscpy(lpszName,lpszKoreanDefaultLayout);
        }
    }

    /*
     * We have the Active value.  Now create the Preload key.
     */
    RtlInitUnicodeString(&UnicodeString, L"Preload");
    InitializeObjectAttributes(&ObjA,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               hKey,
                               NULL );
    rc = NtCreateKey(&hKeyPreload,
                     STANDARD_RIGHTS_WRITE |
                       KEY_QUERY_VALUE |
                       KEY_ENUMERATE_SUB_KEYS |
                       KEY_SET_VALUE |
                       KEY_CREATE_SUB_KEY,
                     &ObjA,
                     0,
                     NULL,
                     0,
                     &CreateDisposition );

    if (!NT_SUCCESS(rc)) {
        RIPMSGF1(RIP_WARNING, "Could NOT create Preload key (0x%x).", rc);
        NtClose(hKey);
        return;
    }

    /*
     * Set the new value entry.
     */
    RtlInitUnicodeString(&UnicodeString, L"1");
    rc = NtSetValueKey(hKeyPreload,
                       &UnicodeString,
                       0,
                       REG_SZ,
                       lpszName,
                       (wcslen(lpszName) + 1) * sizeof(WCHAR));

    if (!NT_SUCCESS(rc)) {
        RIPMSGF1(RIP_WARNING,
                 "Could NOT create value entry 1 for Preload key (0x%x).",
                 rc);
        NtClose(hKey);
        NtClose(hKeyPreload);
        return;
    }

    /*
     * Success: attempt to delete the Active value key.
     */
    RtlInitUnicodeString(&UnicodeString, szKbdActive);
    rc = NtDeleteValueKey(hKey, &UnicodeString);

    if (!NT_SUCCESS(rc)) {
        RIPMSGF1(RIP_WARNING, "Could NOT delete value key 'Active'.", rc);
    }

    NtClose(hKey);
    NtClose(hKeyPreload);
}


/***************************************************************************\
* LoadPreloadKeyboardLayouts
*
* Loads the keyboard layouts stored under the Preload key in the user's
* registry. The first layout, the default, was already loaded.
*
* 03-06-95 GregoryW     Created.
\***************************************************************************/

// size allows up to 999 preloaded!!!!!
#define NSIZEPRELOAD    (4)

VOID LoadPreloadKeyboardLayouts(
    VOID)
{
    UINT i;
    WCHAR szPreLoadee[NSIZEPRELOAD];
    WCHAR lpszName[KL_NAMELENGTH];

    if (!ISREMOTESESSION()) {
        /*
         * Console doesn't have a client layout, so start from 2.
         */
        i = 2;
    } else {
        /*
         * Client might have specified a keyboard layout, if this
         * is so, then Preload\1 was not loaded, so start from 1.
         */
        i = 1;
    }

    for (; i < 1000; i++) {
        wsprintf(szPreLoadee, L"%d", i );
        if ((GetPrivateProfileStringW(
                 L"Preload",
                 szPreLoadee,
                 L"",
                 lpszName,
                 KL_NAMELENGTH,
                 L"keyboardlayout.ini") == -1 ) || (*lpszName == L'\0')) {
            break;
        }
        LoadKeyboardLayoutW(lpszName, KLF_REPLACELANG |KLF_SUBSTITUTE_OK |KLF_NOTELLSHELL);
    }
}

LPWSTR GetKeyboardDllName(
    LPWSTR pwszLibIn,
    LPWSTR pszKLName,
    LANGID langid,
    PUINT puFlags,
    PUINT pKbdInputLocale)
{
    NTSTATUS Status;
    WCHAR awchKL[KL_NAMELENGTH];
    WCHAR awchKLRegKey[NSZKLKEY];
    LPWSTR lpszKLRegKey = &awchKLRegKey[0];
    LPWSTR pwszLib;
    LPWSTR pwszId;
    UINT wLayoutId;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES OA;
    HANDLE hKey;
    DWORD cbSize;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        WCHAR awchLibName[CCH_KL_LIBNAME];
    } KeyFile;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        WCHAR awchId[CCH_KL_ID];
    } KeyId;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        DWORD Attributes;
    } KeyAttributes;

    if (pszKLName == NULL) {
        return NULL;
    }

    if (langid == MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)) {
        langid = (UINT)wcstoul(pszKLName, NULL, 16);
        TAGMSGF1(DBGTAG_KBD, "langid is acquired from pszKLName: %04x", langid);
    } else {
        TAGMSGF1(DBGTAG_KBD, "langid is passed in: %04x", langid);
    }

    /*
     * Substitute Layout if required.
     */
    if (*puFlags & KLF_SUBSTITUTE_OK) {
        GetPrivateProfileStringW(L"Substitutes",
                                 pszKLName,
                                 pszKLName,
                                 awchKL,
                                 ARRAY_SIZE(awchKL),
                                 L"keyboardlayout.ini");
        /*
         * #273562 : Flush the registry cache, because the cpanel applet
         * destroys and recreates the Substitutes section a lot, which
         * would otherwise leave us with STATUS_KEY_DELETED.
         */
        WritePrivateProfileStringW(NULL, NULL, NULL, NULL);

        awchKL[KL_NAMELENGTH - 1] = L'\0';
        wcscpy(pszKLName, awchKL);
    }

    wLayoutId = (UINT)wcstoul(pszKLName, NULL, 16);

    /*
     * Get DLL name from the registry, load it, and get the entry point.
     */
    pwszLib = NULL;
    wcscpy(lpszKLRegKey, szKLKey);
    wcscat(lpszKLRegKey, pszKLName);
    RtlInitUnicodeString(&UnicodeString, lpszKLRegKey);
    InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &OA))) {
        /*
         * Read the "Layout File" value.
         */
        RtlInitUnicodeString(&UnicodeString, szKLFile);

        Status = NtQueryValueKey(hKey,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 &KeyFile,
                                 sizeof(KeyFile),
                                 &cbSize);
        if (Status == STATUS_BUFFER_OVERFLOW) {
            RIPMSGF0(RIP_WARNING, "(Layout File) - Buffer overflow.");
            Status = STATUS_SUCCESS;
        }
        if (NT_SUCCESS(Status)) {
            pwszLib = (LPWSTR)KeyFile.KeyInfo.Data;
            pwszLib[CCH_KL_LIBNAME - 1] = L'\0';
        } else {
            RIPMSGF1(RIP_WARNING,
                     "Failed to get the DLL name for %ws",
                     pszKLName);
        }

        RtlInitUnicodeString(&UnicodeString, szKLAttributes);
        Status = NtQueryValueKey(hKey,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 &KeyAttributes,
                                 sizeof(KeyAttributes),
                                 &cbSize);
        if (NT_SUCCESS(Status)) {
            if ((*((PDWORD)KeyAttributes.KeyInfo.Data) & ~KLF_ATTRMASK) != 0) {
                RIPMSGF1(RIP_WARNING,
                         "Unexpected attributes %lx",
                         *((PDWORD)KeyAttributes.KeyInfo.Data));
            }

            *puFlags |= (*(PDWORD)KeyAttributes.KeyInfo.Data & KLF_ATTRMASK);
        }

        /*
         * If the high word of wLayoutId is 0xE??? then this is an IME based
         * keyboard layout.
         */
        if (IS_IME_KBDLAYOUT(wLayoutId)) {
            wLayoutId = (UINT)HIWORD(wLayoutId);
        } else if (HIWORD(wLayoutId)) {
            /*
             * If the high word of wLayoutId is non-null then read the
             * "Layout ID" value. Layout IDs start at 1, increase
             * sequentially and are unique.
             */
            RtlInitUnicodeString(&UnicodeString, szKLId);

            Status = NtQueryValueKey(hKey,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    &KeyId,
                    sizeof(KeyId),
                    &cbSize);

            if (Status == STATUS_BUFFER_OVERFLOW) {
                RIPMSGF0(RIP_WARNING, "Buffer overflow.");
                Status = STATUS_SUCCESS;
            }
            if (NT_SUCCESS(Status)) {
                pwszId = (LPWSTR)KeyId.KeyInfo.Data;
                pwszId[CCH_KL_ID - 1] = L'\0';
                wLayoutId = (wcstol(pwszId, NULL, 16) & 0x0fff) | 0xf000;
            } else {
                wLayoutId = (UINT)0xfffe ;    // error in layout ID, load separately
            }
        }
        NtClose(hKey);
    } else {
        /*
         * Get DLL name from the registry, load it, and get the entry point.
         */
        pwszLib = NULL;
        RtlInitUnicodeString(&UnicodeString,
                             L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Keyboard Layout");
        InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

        if (NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &OA))) {
            RtlInitUnicodeString(&UnicodeString, pszKLName);

            Status = NtQueryValueKey(hKey,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    &KeyFile,
                    sizeof(KeyFile),
                    &cbSize);

            if (Status == STATUS_BUFFER_OVERFLOW) {
                RIPMSGF0(RIP_WARNING, "Buffer overflow.");
                Status = STATUS_SUCCESS;
            }
            if (NT_SUCCESS(Status)) {
                pwszLib = (LPWSTR)KeyFile.KeyInfo.Data;
                pwszLib[CCH_KL_LIBNAME - 1] = L'\0';
            }

            NtClose(hKey);
        }

        if (pwszLib == NULL) {
            RIPMSGF1(RIP_WARNING,
                     "Failed to get the library name for %ws",
                     pszKLName);
        }
    }

    *pKbdInputLocale = (UINT)MAKELONG(LOWORD(langid),LOWORD(wLayoutId));

    if (pwszLib == NULL) {
        if (ISREMOTESESSION() && IS_IME_KBDLAYOUT(wLayoutId)) {
            /*
             * -- port from HYDRA --
             * Could not find the keyboard KL for FE, so give them some reasonable one.
             * If the high word of wLayoutId is 0xE??? then this is an IME based
             * keyboard layout.
             * And, the safe KL name is KBDJPN.DLL for Japanese.
             *                       or KBDKOR.DLL for Korean
             *                       or KBDUS.DLL  for other Far East
             */
            if (PRIMARYLANGID(langid) == LANG_JAPANESE) {
                pwszLib = pwszKLLibSafetyJPN;
                *pKbdInputLocale = wKbdLocaleSafetyJPN;
            } else if (PRIMARYLANGID(langid) == LANG_KOREAN) {
                pwszLib = pwszKLLibSafetyKOR;
                *pKbdInputLocale = wKbdLocaleSafetyKOR;
            } else {
                pwszLib = pwszKLLibSafety;
                *pKbdInputLocale = MAKELONG(LOWORD(langid), LOWORD(langid));
            }
        } else if (*puFlags & KLF_INITTIME) {
            pwszLib = pwszKLLibSafety;
            *pKbdInputLocale = wKbdLocaleSafety;
        } else {
            RIPMSG1(RIP_WARNING, "no DLL name for %ws", pszKLName);
            /*
             * We're going to use the fallback layout...
             * This could happen when IMM32 is trying to unload the IME,
             * by making any non IME keyboard layout tentatively active.
             */
            pwszLib = pwszKLLibSafety;
            *pKbdInputLocale = wKbdLocaleSafety;
        }
    }

    if (pwszLib) {
        wcscpy(pwszLibIn, pwszLib);
        pwszLib = pwszLibIn;
    }

    return pwszLib;
}


/***************************************************************************\
* OpenKeyboardLayoutFile
*
* Opens a layout file and computes the table offset.
*
* 01-11-95 JimA         Moved LoadLibrary code from server.
\***************************************************************************/
HANDLE OpenKeyboardLayoutFileWorker(
    LPWSTR pwszLib,
    LPWSTR lpszKLName,
    CONST UINT* puFlags,
    PUINT poffTable,
    OUT OPTIONAL PKBDTABLE_MULTI_INTERNAL pKbdTableMultiIn)
{
    WCHAR awchRealLayoutFile[MAX_PATH];
    HANDLE hLibModule, hLibMulti = NULL;
    WCHAR awchModName[MAX_PATH];

    PKBDTABLES (*pfn)(void);            // @1
    PKBDNLSTABLES (* pfnNls)(void);     // @2
    BOOL (*pfnLayerNT4)(LPWSTR);        // @3
    BOOL (*pfnLayer)(HKL, LPWSTR, PCLIENTKEYBOARDTYPE, LPVOID);  // @5
    BOOL (*pfnMulti)(PKBDTABLE_MULTI);  // @6

    TAGMSGF1(DBGTAG_KBD, "opening '%S'", pwszLib);

RetryLoad:
    hLibModule = LoadLibraryW(pwszLib);

    if (hLibModule == NULL) {
        RIPMSG1(RIP_WARNING, "Keyboard Layout: cannot load %ws", pwszLib);

        /*
         * It is OK to fail to load DLL here. If this ever happens, the
         * fallback keyboard layout built in win32k.sys shall be used.
         */
        return NULL;
    }

    if (pwszLib != pwszKLLibSafety) {
        /*
         * if the layout driver is not "REAL" layout driver, the driver has
         * "3" or "5" entry point, then we call this to get real layout driver..
         * This is neccesary for Japanese and Korean systems. because their
         * keyboard layout driver is "KBDJPN.DLL" or "KBDKOR.DLL", but its
         * "REAL" driver becomes different depending their keyboard hardware.
         */

        /*
         * Get the entrypoints.
         */
        pfnLayerNT4 = (BOOL(*)(LPWSTR))GetProcAddress(hLibModule, (LPCSTR)3);
        pfnLayer  = (BOOL(*)(HKL, LPWSTR, PCLIENTKEYBOARDTYPE, LPVOID))GetProcAddress(hLibModule, (LPCSTR)5);

        if (pKbdTableMultiIn && !ISREMOTESESSION()) {
            pfnMulti = (BOOL(*)(PKBDTABLE_MULTI))GetProcAddress(hLibModule, (LPCSTR)6);
        } else {
            pfnMulti = NULL;
        }

        /*
         * Firstly check if multiple layout is included.
         * This needs to be done before the dll name is redirected to
         * the real one (if layered).
         */
        if (pfnMulti) {
            UserAssert(pKbdTableMultiIn);
            UserAssert(!ISREMOTESESSION());

            if (pfnMulti(&pKbdTableMultiIn->multi)) {
                UINT i;

                /*
                 * Do multi layout stuff only if the layout dll returns
                 * a legitimate result.
                 */
                if (pKbdTableMultiIn->multi.nTables < KBDTABLE_MULTI_MAX) {
                    for (i = 0; i < pKbdTableMultiIn->multi.nTables; ++i) {
                        UINT uiOffset;

                        TAGMSGF2(DBGTAG_KBD | RIP_THERESMORE, "opening %d, %S", i, pKbdTableMultiIn->multi.aKbdTables[i].wszDllName);

                        UserAssert(i < KBDTABLE_MULTI_MAX);

                        pKbdTableMultiIn->files[i].hFile = OpenKeyboardLayoutFileWorker(pKbdTableMultiIn->multi.aKbdTables[i].wszDllName,
                                                                                        NULL,
                                                                                        puFlags,
                                                                                        &uiOffset,
                                                                                        NULL);
                        TAGMSG1(DBGTAG_KBD, "hFile = %p", pKbdTableMultiIn->files[i].hFile);
                        if (pKbdTableMultiIn->files[i].hFile) {
                            pKbdTableMultiIn->files[i].wTable = LOWORD(uiOffset);
                            pKbdTableMultiIn->files[i].wNls = HIWORD(uiOffset);
                        }
                    }
                } else {
                    pKbdTableMultiIn->multi.nTables = 0;
                    RIPMSGF2(RIP_ERROR, "KL=%S returned bogus nTables=%x",
                            lpszKLName, pKbdTableMultiIn->multi.nTables);
                }
            }
        }

        /*
         * If there are private entries, call them.
         */
        if (pfnLayer || pfnLayerNT4) {
            HKL hkl;
            UNICODE_STRING UnicodeString;
            CLIENTKEYBOARDTYPE clientKbdType;
            PCLIENTKEYBOARDTYPE pClientKbdType = NULL;

            UserAssert(lpszKLName);

            RtlInitUnicodeString(&UnicodeString, lpszKLName);
            RtlUnicodeStringToInteger(&UnicodeString, 0x10, (PULONG)&hkl);

            /*
             * When we reach here, the layout DLL may have KBDNLSTABLE
             * even if we fail from now on. Our temporary layout
             * dll should have the fallback tables for just in case.
             */

            if (ISREMOTESESSION() && GetClientKeyboardType(&clientKbdType)) {
                pClientKbdType = &clientKbdType;
            }

            /*
             * Call the entry.
             * a. NT5 / Hydra (oridinal=5)
             * b. NT4 compatible (3)
             */
            if ((pfnLayer && pfnLayer(hkl, awchRealLayoutFile, pClientKbdType, NULL)) ||
                    (pfnLayerNT4 && pfnLayerNT4(awchRealLayoutFile))) {

                HANDLE hLibModuleNew;
                /*
                 * Try to load "REAL" keyboard layout file.
                 */
                TAGMSG1(DBGTAG_KBD, "awchRealLayoutFile='%S'", awchRealLayoutFile);
                if (hLibModuleNew = LoadLibraryW(awchRealLayoutFile)) {
                    /*
                     * Set "REAL" layout file name.
                     */
                    pwszLib = awchRealLayoutFile;
                    /*
                     * Unload temporary layout driver.
                     */
                    FreeLibrary(hLibModule);
                    /*
                     * Updates it.
                     */
                    hLibModule = hLibModuleNew;
                }
            }
        }
    }

    /*
     * HACK Part 1!  Get the pointer to the layout table and
     * change it to a virtual offset.  The server will then
     * use this offset when poking through the file header to
     * locate the table within the file.
     */
    pfn = (PKBDTABLES(*)(void))GetProcAddress(hLibModule, (LPCSTR)1);
    if (pfn == NULL) {
        RIPMSGF0(RIP_ERROR, "cannot get proc addr of '1'");
        if (pKbdTableMultiIn) {
            /*
             * Main load somehow failed. Need to clean up
             * the dynamic layout switching stuff.
             */
            UINT i;

            RIPMSGF0(RIP_WARNING, "multi table exists, cleaning up");

            for (i = 0; i < pKbdTableMultiIn->multi.nTables && i < KBDTABLE_MULTI_MAX; ++i) {
                if (pKbdTableMultiIn->files[i].hFile) {
                    NtClose(pKbdTableMultiIn->files[i].hFile);
                    pKbdTableMultiIn->files[i].hFile = NULL;
                }
            }
            pKbdTableMultiIn->multi.nTables = 0;
        }
        if ((*puFlags & KLF_INITTIME) && (pwszLib != pwszKLLibSafety)) {
            pwszLib = pwszKLLibSafety;
            goto RetryLoad;
        }
        return NULL;
    }
    *poffTable = (UINT)((PBYTE)pfn() - (PBYTE)hLibModule);

    if (pKbdTableMultiIn) {
        /*
         * Save the toplevel Dll name
         */
        lstrcpyn(pKbdTableMultiIn->wszDllName, pwszLib, ARRAY_SIZE(pKbdTableMultiIn->wszDllName));
        pKbdTableMultiIn->wszDllName[ARRAY_SIZE(pKbdTableMultiIn->wszDllName) - 1] = 0;
        TAGMSGF1(DBGTAG_KBD, " real DllName is '%ls'", pKbdTableMultiIn->wszDllName);
    }

    pfnNls = (PKBDNLSTABLES(*)(void))GetProcAddress(hLibModule, (LPCSTR)2);
    if (pfnNls != NULL) {
        UINT offNlsTable;

        offNlsTable = (UINT)((PBYTE)pfnNls() - (PBYTE)hLibModule);

        TAGMSGF2(DBGTAG_KBD | RIP_THERESMORE, "Offset to KBDTABLES    = %d (%x)", *poffTable, *poffTable);
        TAGMSGF2(DBGTAG_KBD, "Offset to KBDNLSTABLES = %d (%x)", offNlsTable, offNlsTable);

        /*
         * Combine these offsets...
         *
         *  LOWORD(*poffTable) = Offset to KBDTABLES.
         *  HIWORD(*poffTable) = Offset to KBDNLSTABLES.
         */
        *poffTable |= (offNlsTable << 16);
    }

    /*
     * Open the dll for read access.
     */
    GetModuleFileName(hLibModule, awchModName, ARRAY_SIZE(awchModName));
    FreeLibrary(hLibModule);

    return CreateFileW(awchModName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);
}

HANDLE OpenKeyboardLayoutFile(
    LPWSTR lpszKLName,
    LANGID langid,
    PUINT puFlags,
    PUINT poffTable,
    PUINT pKbdInputLocale,
    OUT OPTIONAL PKBDTABLE_MULTI_INTERNAL pKbdTableMultiIn)
{
    LPWSTR pwszLib;
    WCHAR awchModName[MAX_PATH];

    if (pKbdTableMultiIn) {
        RtlZeroMemory(pKbdTableMultiIn, sizeof(*pKbdTableMultiIn));
    }

    pwszLib = GetKeyboardDllName(awchModName, lpszKLName, langid, puFlags, pKbdInputLocale);
    if (pwszLib == NULL) {
        return NULL;
    }

    TAGMSG0(DBGTAG_KBD, "=================");
    TAGMSGF1(DBGTAG_KBD, "loading '%S'", lpszKLName);
    TAGMSGF1(DBGTAG_KBD, "input locale is %08x", *pKbdInputLocale);

    return OpenKeyboardLayoutFileWorker(pwszLib, lpszKLName, puFlags, poffTable, pKbdTableMultiIn);
}


/***************************************************************************\
* LoadKeyboardLayoutEx
*
* Loads a keyboard translation table from a dll, replacing the layout associated
* with hkl.  This routine is needed to provide Win95 compatibility.
*
* 10-27-95 GregoryW    Created.
\***************************************************************************/
HKL LoadKeyboardLayoutWorker(
    HKL hkl,
    LPCWSTR lpszKLName,
    LANGID langid,
    UINT uFlags,
    BOOL fFailSafe)
{
    UINT offTable;
    KBDTABLE_MULTI_INTERNAL kbdTableMulti;
    UINT i;
    UINT KbdInputLocale;
    HANDLE hFile;
    HKL hKbdLayout;
    WCHAR awchKL[KL_NAMELENGTH];

    TAGMSGF1(DBGTAG_KBD, "called with KLNAME=%S", lpszKLName);

    /*
     * If there is a substitute keyboard layout OpenKeyboardLayoutFile returns
     * the substitute keyboard layout name to load.
     */
    wcsncpy(awchKL, lpszKLName, KL_NAMELENGTH - 1);
    awchKL[KL_NAMELENGTH - 1] = L'\0';

    /*
     * "langid" is non-zero to propagate the client side
     * input locale. This should be zero for the console
     * session.
     */
    UserAssert(langid == MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) || ISREMOTESESSION());

    /*
     * Open the layout file
     */
    hFile = OpenKeyboardLayoutFile(awchKL, langid, &uFlags, &offTable, &KbdInputLocale, &kbdTableMulti);
    if (hFile == NULL) {
        RIPMSGF1(RIP_WARNING, "Couldn't open layout file for '%ws'", awchKL);
        if (!fFailSafe && (uFlags & KLF_FAILSAFE) == 0) {
            // If not fail safe mode, just bail to fail.
            return NULL;
        }
        uFlags &= ~KLF_SUBSTITUTE_OK;

        /*
         * If the first attempt fails, we should not try to setup the
         * dynamic switching.
         */
        kbdTableMulti.multi.nTables = 0;
        if (wcscmp(awchKL, L"00000409")) {
            wcscpy(awchKL, L"00000409");
            hFile = OpenKeyboardLayoutFile(awchKL, langid, &uFlags, &offTable, &KbdInputLocale, NULL);
        }
    }

    /*
     * Call the server to read the keyboard tables. Note that the server
     * will close the file handle when it is done.
     */
    hKbdLayout = _LoadKeyboardLayoutEx(hFile, offTable,
                                       &kbdTableMulti,
                                       hkl, awchKL, KbdInputLocale, uFlags);
    NtClose(hFile);

    /*
     * Free opened files for dynamic layout switching.
     */
    for (i = 0; i < kbdTableMulti.multi.nTables && i < KBDTABLE_MULTI_MAX; ++i) {
        if (kbdTableMulti.files[i].hFile) {
            NtClose(kbdTableMulti.files[i].hFile);
        }
    }

    CliImmInitializeHotKeys(ISHK_ADD, UlongToHandle(KbdInputLocale));

    return hKbdLayout;
}


FUNCLOG3(LOG_GENERAL, HKL, DUMMYCALLINGTYPE, LoadKeyboardLayoutEx, HKL, hkl, LPCWSTR, lpszKLName, UINT, uFlags)
HKL LoadKeyboardLayoutEx(
    HKL hkl,
    LPCWSTR lpszKLName,
    UINT uFlags)
{
    /*
     * NULL hkl is not allowed.
     */
    if (hkl == (HKL)NULL) {
        return NULL;
    }

    return LoadKeyboardLayoutWorker(hkl, lpszKLName, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), uFlags, FALSE);
}

/***************************************************************************\
* LoadKeyboardLayout
*
* Loads a keyboard translation table from a dll.
*
* 01-09-95 JimA         Moved LoadLibrary code from server.
\***************************************************************************/
FUNCLOG2(LOG_GENERAL, HKL, DUMMYCALLINGTYPE, LoadKeyboardLayoutW, LPCWSTR, lpszKLName, UINT, uFlags)
HKL LoadKeyboardLayoutW(
    LPCWSTR lpszKLName,
    UINT uFlags)
{
    return LoadKeyboardLayoutWorker(NULL,
                                    lpszKLName,
                                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                    uFlags,
                                    FALSE);
}


FUNCLOG2(LOG_GENERAL, HKL, DUMMYCALLINGTYPE, LoadKeyboardLayoutA, LPCSTR, lpszKLName, UINT, uFlags)
HKL LoadKeyboardLayoutA(
    LPCSTR lpszKLName,
    UINT uFlags)
{
    WCHAR awchKLName[MAX_PATH];
    LPWSTR lpBuffer = awchKLName;

    if (!MBToWCS(lpszKLName, -1, &lpBuffer, sizeof(awchKLName), FALSE)) {
        return (HKL)NULL;
    }

    return LoadKeyboardLayoutW(awchKLName, uFlags);
}

BOOL UnloadKeyboardLayout(
    IN HKL hkl)
{
    BOOL fRet = NtUserUnloadKeyboardLayout(hkl);

    if (fRet) {
        CliImmInitializeHotKeys(ISHK_REMOVE, hkl);
        return TRUE;
    }

    return FALSE;
}


/**************************************************************************\
* GetKeyboardLayout
*
* 01-17-95 GregoryW     Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, HKL, DUMMYCALLINGTYPE, GetKeyboardLayout, DWORD, idThread)
HKL GetKeyboardLayout(
    DWORD idThread)
{
    return (HKL)NtUserCallOneParam(idThread, SFI__GETKEYBOARDLAYOUT);
}



FUNCLOGVOID1(LOG_GENERAL, DUMMYCALLINGTYPE, SetDebugErrorLevel, DWORD, dwLevel)
VOID SetDebugErrorLevel(
    DWORD dwLevel)
{
    UNREFERENCED_PARAMETER(dwLevel);
}

VOID CheckValidLayoutName(
    LPWSTR lpszKLName)
{
    UINT wLayoutId;
    WCHAR awchKLRegKey[NSZKLKEY];
    LPWSTR lpszKLRegKey = &awchKLRegKey[0];
    OBJECT_ATTRIBUTES OA;
    HANDLE hKey;
    UNICODE_STRING UnicodeString;

    UserAssert(IS_IME_ENABLED());

    wLayoutId = (UINT)wcstoul(lpszKLName, NULL, 16);

    if (IS_IME_KBDLAYOUT(wLayoutId)) {
        /*
         * If it's an IME layout, we need to check if the layout name exists
         * in the HKEY_LOCAL_MACHINE. If we've upgraded from NT 3.51 the
         * corresponding entry might be lost because those process-type IMEs
         * that are supported on NT 3.51 are not supported in NT 4.0.
         */
        wcscpy(lpszKLRegKey, szKLKey);
        wcscat(lpszKLRegKey, lpszKLName);
        RtlInitUnicodeString(&UnicodeString, lpszKLRegKey);
        InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

        if (NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &OA))) {
            NtClose(hKey);
        } else {
            /*
             * Quick and dirty way to make the fallback name...
             */
            lpszKLName[0] = lpszKLName[1] = lpszKLName[2] = lpszKLName[3] = L'0';
        }
    }
}

/**************************************************************************\
* GetProcessDefaultLayout
*
* 22-Jan-1998 SamerA    Created
\**************************************************************************/
BOOL WINAPI GetProcessDefaultLayout(
    DWORD *pdwDefaultLayout)
{
    return (BOOL)NtUserCallOneParam((ULONG_PTR)pdwDefaultLayout,
                                    SFI__GETPROCESSDEFAULTLAYOUT);
}

/**************************************************************************\
* SetProcessDefaultLayout
*
* 22-Jan-1998 SamerA    Created
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, SetProcessDefaultLayout, DWORD, dwDefaultLayout)
BOOL WINAPI SetProcessDefaultLayout(
    DWORD dwDefaultLayout)
{
    return (BOOL)NtUserCallOneParam(dwDefaultLayout, SFI__SETPROCESSDEFAULTLAYOUT);
}

/***************************************************************************\
* IsWinEventHookInstalled
*
* History:
* Jul-18-2000 DwayneN Created
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsWinEventHookInstalled, DWORD, event)
BOOL
IsWinEventHookInstalled(
    DWORD event)
{
    /*
     * We need to ensure that we are a GUI thread.  If we fail to convert
     * to a GUI thread, we have to return TRUE to indicate that there might
     * be a hook installed for the event - since we can't check it for sure.
     * In reality, any future calls to User APIs like NotifyWinEvent will
     * probably fail as well, so this is probably a dead-end anyway.
     */
    ConnectIfNecessary(TRUE);

    return(FEVENTHOOKED(event));
};

HWND
VerNtUserCreateWindowEx(
    IN DWORD dwExStyle,
    IN PLARGE_STRING pstrClassName,
    IN PLARGE_STRING pstrWindowName OPTIONAL,
    IN DWORD dwStyle,
    IN int x,
    IN int y,
    IN int nWidth,
    IN int nHeight,
    IN HWND hwndParent,
    IN HMENU hmenu,
    IN HANDLE hModule,
    IN LPVOID pParam,
    IN DWORD dwFlags)
{
    HWND hwnd = NULL;
    PACTIVATION_CONTEXT pActCtx = NULL;
    LARGE_IN_STRING strClassNameVer;
    PLARGE_STRING pstrClassNameVer = pstrClassName;
    NTSTATUS Status;
    WCHAR ClassNameVer[MAX_ATOM_LEN];
    LPWSTR lpClassNameVer;
#ifdef LAME_BUTTON
    PWND pwnd;
#endif
    LPWSTR lpDllName = NULL;
    HMODULE hDllMod = NULL;
    PREGISTERCLASSNAMEW pRegisterClassNameW = NULL;
    BOOL bRegistered = FALSE;
    PACTIVATION_CONTEXT lpActivationContext = NULL;

    strClassNameVer.fAllocated = FALSE;

    if (GetClientInfo()->dwTIFlags & TIF_16BIT) {
       /*
        * No Fusion redirection for 16BIT apps
        */
       if (!(GetAppCompatFlags2(VERMAX) & GACF2_FORCEFUSION)) {
          dwFlags &= ~CW_FLAGS_VERSIONCLASS;
       }
    }

#ifdef LAZY_CLASS_INIT
    LazyInitClasses();
#endif

    if (dwFlags & CW_FLAGS_VERSIONCLASS) {
        /*
         * Get the current active App context to be activated whenever we call
         * the user WndProc.
         * Be aware that RtlGetActiveActivationContext will increment the pActCtx
         * ref count for that reason we have to release it in fnNCDESTROY.
         */
        ACTIVATION_CONTEXT_BASIC_INFORMATION ActivationContextInfo = {0};
        const ACTIVATIONCONTEXTINFOCLASS ActivationContextInfoClass = ActivationContextBasicInformation;
        Status =
            RtlQueryInformationActiveActivationContext(
                ActivationContextInfoClass,
                &ActivationContextInfo,
                sizeof(ActivationContextInfo),
                NULL
                );
        UserAssert (NT_SUCCESS(Status));
        if ((ActivationContextInfo.Flags & ACTIVATION_CONTEXT_FLAG_NO_INHERIT) == 0) {
            pActCtx = ActivationContextInfo.ActivationContext;
        } else {
            RtlReleaseActivationContext(ActivationContextInfo.ActivationContext);
        }

        /*
         * Now convert the class name to class name+version.
         */
        if (IS_PTR(pstrClassName)) {
            lpClassNameVer = ClassNameToVersion((LPWSTR)pstrClassName->Buffer, ClassNameVer, &lpDllName, &lpActivationContext, FALSE);
        } else {
            lpClassNameVer = ClassNameToVersion((LPWSTR)pstrClassName, ClassNameVer, &lpDllName, &lpActivationContext, FALSE);
        }
        if (lpClassNameVer == NULL) {
            RIPMSG0(RIP_WARNING, "CreateWindowEx: Couldn't resolve the class name");
            return NULL;
        }

        if (IS_PTR(lpClassNameVer)) {
            RtlInitLargeUnicodeString(
                    (PLARGE_UNICODE_STRING)&strClassNameVer.strCapture,
                    lpClassNameVer, (UINT)-1);
            pstrClassNameVer = (PLARGE_STRING)&strClassNameVer.strCapture;
        } else {
            pstrClassNameVer = (PLARGE_STRING)lpClassNameVer;
        }
    }

TryAgain:

    hwnd = NtUserCreateWindowEx(dwExStyle,
                                pstrClassName,
                                pstrClassNameVer,
                                pstrWindowName,
                                dwStyle,
                                x,
                                y,
                                nWidth,
                                nHeight,
                                hwndParent,
                                hmenu,
                                hModule,
                                pParam,
                                dwFlags,
                                pActCtx);

    /*
     * Did we fail to create the window due to the class not being
     * registered?
     */
    if (hwnd == NULL &&
        (dwFlags & CW_FLAGS_VERSIONCLASS) &&
        lpDllName != NULL &&
        !bRegistered &&
        GetLastError() == ERROR_CANNOT_FIND_WND_CLASS) {
        /*
         * Then try to register it by loading its DLL. Notice that this DLL
         * will never get unloaded unless we failed to create the window.
         * But once we created a window by loading this DLL we'll never free it.
         */
        bRegistered = VersionRegisterClass(IS_PTR(pstrClassName) ? pstrClassName->Buffer : pstrClassName, lpDllName, lpActivationContext, &hDllMod);
        if (bRegistered) {
            goto TryAgain;
        }
    }

    if (hwnd == NULL && hDllMod != NULL) {
        FREE_LIBRARY_SAVE_ERROR(hDllMod);
        hDllMod = NULL;
    }

    if (lpActivationContext != NULL) {
        RtlReleaseActivationContext(lpActivationContext);
        lpActivationContext = NULL;
    }


#ifdef LAME_BUTTON
    pwnd = ValidateHwnd(hwnd);
    if (pwnd != NULL && TestWF(pwnd, WEFLAMEBUTTON)) {
        ULONG nCallers;
        PVOID stack[16];
        PVOID pStackTrace = NULL;

        /*
         * Get a stack trace and store it for use when the button is
         * pressed.
         */
        nCallers = RtlWalkFrameChain(stack, ARRAY_SIZE(stack), 0);
        if (nCallers > 0) {
            pStackTrace = UserLocalAlloc(HEAP_ZERO_MEMORY,
                                         (nCallers + 1) * sizeof(PVOID));
            if (pStackTrace != NULL) {
                RtlCopyMemory(pStackTrace, stack, nCallers * sizeof(PVOID));

                /*
                 * NULL terminate the array so we know where it ends.
                 */
                ((PVOID*)pStackTrace)[nCallers] = NULL;
            }
        }

        SetProp(hwnd, MAKEINTATOM(gatomLameButton), pStackTrace);
    }
#endif

    CLEANUPLPSTRW(strClassNameVer);

    return hwnd;
}

/**************************************************************************\
* AllowForegroundActivation
*
* 26-Apr-2001 clupu    Created
\**************************************************************************/
VOID AllowForegroundActivation(
    VOID)
{
    NtUserCallNoParam(SFI__ALLOWFOREGROUNDACTIVATION);
}

/**************************************************************************\
* DisableProcessWindowGhosting
*
* 31-May-2001 msadek   Created
\**************************************************************************/
VOID DisableProcessWindowsGhosting(
    VOID)
{
    NtUserCallNoParam(SFI__DISABLEPROCESSWINDOWSGHOSTING);
}

/**************************************************************************\
* IsProcess16Bit
*
* This is a private function for the GDI guys. Exporting this function is
* more expendient than fixing the headers such that they can include what
* they need to do this themselves. Longterm, this function should be removed
* and the headers properly munged.
*
* 15-Oct-2001 JasonSch    Created
\**************************************************************************/
BOOL IsProcess16Bit(
    VOID)
{
    return (GetClientInfo()->CI_flags & CI_16BIT) != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\clientw.c ===
/**************************************************************************\
* Module Name: clientw.c
*
* Client/Server call related routines dealing with UNICODE text.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Created: 04-Dec-90
*
* History:
* 14-Jan-92 created by IanJa
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifndef UNICODE
#define UNICODE
#endif

#include "cltxt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\clinit.c ===
/****************************** Module Header ******************************\
* Module Name: clinit.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the init code for the USER.DLL. When the DLL is
* dynlinked its initialization procedure (UserClientDllInitialize) is called by
* the loader.
*
* History:
* 18-Sep-1990 DarrinM Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include "csrhlpr.h"

/*
 * Global variables local to this module (startup).
 */
BOOL         gfFirstThread = TRUE;
PDESKTOPINFO pdiLocal;
#if DBG
BOOL         gbIhaveBeenInited;
#endif
static DWORD gdwLpkEntryPoints;

CONST WCHAR szWindowsKey[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows";
CONST WCHAR szAppInit[] = L"AppInit_DLLs";

WCHAR szWindowStationDirectory[MAX_SESSION_PATH];
extern CONST PVOID apfnDispatch[];

/*
 * External declared routines needed for startup.
 */
NTSTATUS GdiProcessSetup(VOID);
NTSTATUS GdiDllInitialize(IN PVOID hmod, IN DWORD Reason);


/***************************************************************************\
* UserClientDllInitialize
*
* When USER32.DLL is loaded by an EXE (either at EXE load or at LoadModule
* time) this routine is called by the loader. Its purpose is to initialize
* everything that will be needed for future User API calls by the app.
*
* History:
* 19-Sep-1990 DarrinM Created.
\***************************************************************************/
BOOL UserClientDllInitialize(
    IN PVOID    hmod,
    IN DWORD    Reason,
    IN PCONTEXT pctx)
{
    SYSTEM_BASIC_INFORMATION SystemInformation;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(pctx);

#if DBG
    if (RtlGetNtGlobalFlags() & FLG_SHOW_LDR_SNAPS) {
        RIPMSG1(RIP_WARNING,
                "UserClientDllInitialize: entered for reason %x",
                Reason);
    }
#endif

    if (Reason == DLL_PROCESS_ATTACH) {
        USERCONNECT userconnect;
        ULONG ulConnect = sizeof(USERCONNECT);
        ULONG SessionId = NtCurrentPeb()->SessionId;

        UserVerify(DisableThreadLibraryCalls(hmod));

#if DBG
        UserAssert(!gbIhaveBeenInited);
        if (gbIhaveBeenInited) {
            return TRUE;
        } else {
            gbIhaveBeenInited = TRUE;
        }
#endif

        Status  = RtlInitializeCriticalSection(&gcsClipboard);
        Status |= RtlInitializeCriticalSection(&gcsLookaside);
        Status |= RtlInitializeCriticalSection(&gcsHdc);
        Status |= RtlInitializeCriticalSection(&gcsAccelCache);
        Status |= RtlInitializeCriticalSection(&gcsDDEML);
        Status |= RtlInitializeCriticalSection(&gcsUserApiHook);
#ifdef MESSAGE_PUMP_HOOK
        Status |= RtlInitializeCriticalSection(&gcsMPH);
#endif

        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING,
                    "Failed to create critical sections. Status 0x%x",
                    Status);
            return FALSE;
        }

#ifdef LAME_BUTTON
        gatomLameButton = AddAtomW(LAMEBUTTON_PROP_NAME);
        if (gatomLameButton == 0) {
            RIPMSG0(RIP_WARNING, "Failed to create lame button atom");
            return FALSE;
        }
#endif

#if DBG
        gpDDEMLHeap = RtlCreateHeap(HEAP_GROWABLE | HEAP_CLASS_1
                              | HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED
                              , NULL, 8 * 1024, 2 * 1024, NULL, NULL);

        if (gpDDEMLHeap == NULL) {
            gpDDEMLHeap = RtlProcessHeap();
        }
#endif

        Status = NtQuerySystemInformation(SystemBasicInformation,
                                          &SystemInformation,
                                          sizeof(SystemInformation),
                                          NULL);
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING,
                    "NtQuerySystemInformation failed with Status 0x%x",
                    Status);
            return FALSE;
        }
        gHighestUserAddress = SystemInformation.MaximumUserModeAddress;

        userconnect.ulVersion = USERCURRENTVERSION;

        if (SessionId != 0) {
            WCHAR szSessionDir[MAX_SESSION_PATH];
            swprintf(szSessionDir,
                     L"%ws\\%ld%ws",
                     SESSION_ROOT,
                     SessionId,
                     WINSS_OBJECT_DIRECTORY_NAME);

            Status = UserConnectToServer(szSessionDir,
                                         &userconnect,
                                         &ulConnect,
                                         (PBOOLEAN)&gfServerProcess);
        } else {
            Status = UserConnectToServer(WINSS_OBJECT_DIRECTORY_NAME,
                                         &userconnect,
                                         &ulConnect,
                                         (PBOOLEAN)&gfServerProcess);
        }

        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING,
                    "UserConnectToServer failed with Status 0x%x",
                    Status);
            return FALSE;
        }


        /*
         * If this is the server process, the shared info is not yet valid,
         * so don't copy out the returned info.
         */
        if (!gfServerProcess) {
            HINSTANCE hImm32 = NULL;

            gSharedInfo = userconnect.siClient;
            gpsi = gSharedInfo.psi;

            if (IS_IME_ENABLED()) {
                WCHAR wszImmFile[MAX_PATH];

                InitializeImmEntryTable();
                GetImmFileName(wszImmFile);
                hImm32 = GetModuleHandleW(wszImmFile);
            }
            if (!fpImmRegisterClient(&userconnect.siClient, hImm32)) {
                RIPMSG0(RIP_WARNING,
                        "UserClientDllInitialize: ImmRegisterClient failed");
                return FALSE;
            }
        }

        pfnFindResourceExA = (PFNFINDA)FindResourceExA;
        pfnFindResourceExW = (PFNFINDW)FindResourceExW;
        pfnLoadResource    = (PFNLOAD)LoadResource;
        pfnSizeofResource  = (PFNSIZEOF)SizeofResource;

        /*
         * Register with the base the USER hook it should call when it
         * does a WinExec() (this is soft-linked because some people still
         * use charmode nt!)
         */
        RegisterWaitForInputIdle(WaitForInputIdle);


        /*
         * Remember USER32.DLL's hmodule so we can grab resources from it later.
         */
        hmodUser = hmod;

        pUserHeap = RtlProcessHeap();

        /*
         * Initialize callback table
         */
        NtCurrentPeb()->KernelCallbackTable = apfnDispatch;
        NtCurrentPeb()->PostProcessInitRoutine = NULL;

        if (SessionId != 0) {
            swprintf(szWindowStationDirectory, L"%ws\\%ld%ws", SESSION_ROOT, SessionId, WINSTA_DIR);
            RtlInitUnicodeString(&strRootDirectory, szWindowStationDirectory);
        } else {
            RtlInitUnicodeString(&strRootDirectory, WINSTA_DIR);
        }

#ifdef _JANUS_
        if (gfServerProcess) {
            gfEMIEnable = FALSE;
        } else {
            gfEMIEnable = InitInstrument(&gdwEMIControl);
        }
#endif
    } else if (Reason == DLL_PROCESS_DETACH) {
        if (ghImm32 != NULL) {
            // IMM32.DLL is loaded by USER32, so free it.
            FreeLibrary(ghImm32);
        }

        /*
         * If we loaded OLE, tell it we're done.
         */
        if (ghinstOLE != NULL) {
            /*
             * Later5.0 GerardoB. This causes check OLE32.DLL to fault
             *  because they get their DLL_PROCESS_DETACH first
             * (*(OLEUNINITIALIZEPROC)gpfnOLEOleUninitialize)();
             */
            RIPMSG0(RIP_WARNING, "OLE would fault if I call OleUninitialize now");
            FreeLibrary(ghinstOLE);
        }

#ifdef _JANUS_
        /*
         * If the user has enabled the Error Instrumentation and we've had to
         * log something (which is indicated by gEventSource being non-NULL),
         * unregister the event source.
         */
        if (gEventSource != NULL) {
            DeregisterEventSource(gEventSource);
        }
#endif

        RtlDeleteCriticalSection(&gcsClipboard);
        RtlDeleteCriticalSection(&gcsLookaside);
        RtlDeleteCriticalSection(&gcsHdc);
        RtlDeleteCriticalSection(&gcsAccelCache);
        RtlDeleteCriticalSection(&gcsDDEML);
        RtlDeleteCriticalSection(&gcsUserApiHook);
#ifdef MESSAGE_PUMP_HOOK
        RtlDeleteCriticalSection(&gcsMPH);
#endif

#if DBG
        if (gpDDEMLHeap != RtlProcessHeap()) {
            RtlDestroyHeap(gpDDEMLHeap);
        }
#endif

    }

    Status = GdiDllInitialize(hmod, Reason);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "GdiDllInitialize failed with Status 0x%x",
                Status);
    }

    return NT_SUCCESS(Status);
}

BOOL LoadIcons(
    VOID)
{
    int i;

    /*
     * Load the small version of WINLOGO which will be set into
     * gpsi->hIconSmWindows on the kernel side.
     */
    if (LoadIcoCur(NULL,
                   (LPCWSTR)UIntToPtr(OIC_WINLOGO_DEFAULT),
                   RT_ICON,
                   SYSMET(CXSMICON),
                   SYSMET(CYSMICON),
                   LR_GLOBAL) == NULL) {
        RIPMSG0(RIP_WARNING, "Couldn't load small winlogo icon");
        return FALSE;
    }

    for (i = 0; i < COIC_CONFIGURABLE; i++) {
        if (LoadIcoCur(NULL,
                       (LPCWSTR)UIntToPtr(OIC_FIRST_DEFAULT + i),
                       RT_ICON,
                       0,
                       0,
                       LR_SHARED | LR_GLOBAL) == NULL) {
            RIPMSG1(RIP_WARNING, "Couldn't load icon 0x%x", i);
            return FALSE;
        }
    }

    return TRUE;
}

BOOL LoadCursors(
    VOID)
{
    int i = 0;

    for (i = 0; i < COCR_CONFIGURABLE; i++) {
        if (LoadIcoCur(NULL,
                       (LPCWSTR)UIntToPtr(OCR_FIRST_DEFAULT + i),
                       RT_CURSOR,
                       0,
                       0,
                       LR_SHARED | LR_GLOBAL | LR_DEFAULTSIZE) == NULL) {
            RIPMSG1(RIP_WARNING, "Couldn't load cursor 0x%x", i);
            return FALSE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* LoadCursorsAndIcons
*
* This gets called from our initialization call from csr so they're around
* when window classes get registered. Window classes get registered right
* after the initial csr initialization call.
*
* Later on these default images will get overwritten by custom
* registry entries.  See UpdateCursors/IconsFromRegistry().
*
* 27-Sep-1992 ScottLu      Created.
* 14-Oct-1995 SanfordS     Rewrote.
\***************************************************************************/
BOOL LoadCursorsAndIcons(
    VOID)
{
    if (!LoadCursors() || !LoadIcons()) {
        return FALSE;
    } else {
        /*
         * Now go to the kernel and fixup the IDs from DEFAULT values to
         * standard values.
         */
        NtUserCallNoParam(SFI__LOADCURSORSANDICONS);

        return TRUE;
    }
}

/***************************************************************************\
* UserRegisterControls
*
* Register the control classes. This function must be called for each
* client process.
*
* History:
* ??-??-?? DarrinM Ported.
* ??-??-?? MikeKe Moved here from server.
\***************************************************************************/
BOOL UserRegisterControls(
    VOID)
{
    int i;
    WNDCLASSEX wndcls;

    static CONST struct {
        UINT    style;
        WNDPROC lpfnWndProcW;
        int     cbWndExtra;
        LPCTSTR lpszCursor;
        HBRUSH  hbrBackground;
        LPCTSTR lpszClassName;
        WORD    fnid;
    } rc[] = {

        {CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW,
         ButtonWndProcW,
         sizeof(BUTNWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"Button",
         FNID_BUTTON
        },

        {CS_GLOBALCLASS | CS_DBLCLKS | CS_PARENTDC | CS_VREDRAW | CS_HREDRAW,
         ComboBoxWndProcW,
         sizeof(COMBOWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"ComboBox",
         FNID_COMBOBOX
        },

        {CS_GLOBALCLASS | CS_DBLCLKS | CS_SAVEBITS,
         ComboListBoxWndProcW,
         sizeof(LBWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"ComboLBox",
         FNID_COMBOLISTBOX
        },

        {CS_GLOBALCLASS | CS_DBLCLKS | CS_SAVEBITS,
         DefDlgProcW,
         DLGWINDOWEXTRA,
         IDC_ARROW,
         NULL,
         DIALOGCLASS,
         FNID_DIALOG
        },

        {CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS,
         EditWndProcW,
         max((sizeof(EDITWND) - sizeof(WND)), CBEDITEXTRA),
         IDC_IBEAM,
         NULL,
         L"Edit",
         FNID_EDIT
        },

        {CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS,
         ListBoxWndProcW,
         sizeof(LBWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"ListBox",
         FNID_LISTBOX
        },

        {CS_GLOBALCLASS,
         MDIClientWndProcW,
         sizeof(MDIWND) - sizeof(WND),
         IDC_ARROW,
         (HBRUSH)(COLOR_APPWORKSPACE + 1),
         L"MDIClient",
         FNID_MDICLIENT
        },

        {CS_GLOBALCLASS,
         ImeWndProcW,
         sizeof(IMEWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"IME",
         FNID_IME
        },

        {CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS,
         StaticWndProcW,
         sizeof(STATWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"Static",
         FNID_STATIC
        }
    };

    /*
     * Classes are registered via the table.
     */
    RtlZeroMemory(&wndcls, sizeof(wndcls));
    wndcls.cbSize       = sizeof(wndcls);
    wndcls.hInstance    = hmodUser;

    for (i = 0; i < ARRAY_SIZE(rc); i++) {
        wndcls.style        = rc[i].style;
        wndcls.lpfnWndProc  = rc[i].lpfnWndProcW;
        wndcls.cbWndExtra   = rc[i].cbWndExtra;
        wndcls.hCursor      = LoadCursor(NULL, rc[i].lpszCursor);
        wndcls.hbrBackground= rc[i].hbrBackground;
        wndcls.lpszClassName= rc[i].lpszClassName;

        if (!RegisterClassExWOWW(&wndcls, NULL, rc[i].fnid, 0)) {
            RIPMSGF1(RIP_WARNING,
                     "Failed to register class 0x%x",
                     (ULONG)rc[i].fnid);
            return FALSE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* UserRegisterDDEML
*
* Register all the DDEML classes.
*
* History:
* 01-Dec-1991 Sanfords Created.
\***************************************************************************/
BOOL UserRegisterDDEML(
    VOID)
{
    WNDCLASSEXA wndclsa;
    WNDCLASSEXW wndclsw;
    int i;
    static CONST struct {
        WNDPROC lpfnWndProc;
        ULONG cbWndExtra;
        LPCWSTR lpszClassName;
    } classesW[] = {
        {DDEMLMotherWndProc,
         sizeof(PCL_INSTANCE_INFO),
         L"DDEMLMom"
        },

        {DDEMLServerWndProc,
         sizeof(PSVR_CONV_INFO),     // GWL_PSI
         L"DDEMLUnicodeServer"
        },

        {DDEMLClientWndProc,
         sizeof(PCL_CONV_INFO)    +     // GWL_PCI
            sizeof(CONVCONTEXT)   +     // GWL_CONVCONTEXT
            sizeof(LONG)          +     // GWL_CONVSTATE
            sizeof(HANDLE)        +     // GWL_CHINST
            sizeof(HANDLE),             // GWL_SHINST

         L"DDEMLUnicodeClient"
        }
    };

    static CONST struct {
        WNDPROC lpfnWndProc;
        ULONG cbWndExtra;
        LPCSTR lpszClassName;
    } classesA[] = {
        {DDEMLClientWndProc,
         sizeof(PCL_CONV_INFO)    +     // GWL_PCI
            sizeof(CONVCONTEXT)   +     // GWL_CONVCONTEXT
            sizeof(LONG)          +     // GWL_CONVSTATE
            sizeof(HANDLE)        +     // GWL_CHINST
            sizeof(HANDLE),             // GWL_SHINST
         "DDEMLAnsiClient"
        },

        {DDEMLServerWndProc,
         sizeof(PSVR_CONV_INFO),     // GWL_PSI
         "DDEMLAnsiServer"
        }
    };


    /*
     * Classes are registered via the table.
     */
    RtlZeroMemory(&wndclsa, sizeof(wndclsa));
    wndclsa.cbSize       = sizeof(wndclsa);
    wndclsa.hInstance    = hmodUser;

    RtlZeroMemory(&wndclsw, sizeof(wndclsw));
    wndclsw.cbSize       = sizeof(wndclsw);
    wndclsw.hInstance    = hmodUser;


    for (i = 0; i < ARRAY_SIZE(classesW); ++i) {
        wndclsw.lpfnWndProc = classesW[i].lpfnWndProc;
        wndclsw.cbWndExtra = classesW[i].cbWndExtra;
        wndclsw.lpszClassName = classesW[i].lpszClassName;
        if (!RegisterClassExWOWW(&wndclsw, NULL, FNID_DDE_BIT, 0)) {
            RIPMSGF1(RIP_WARNING, "Failed to register UNICODE class 0x%x", i);
            return FALSE;
        }
    }

    for (i = 0; i < ARRAY_SIZE(classesA); ++i) {
        wndclsa.lpfnWndProc = classesA[i].lpfnWndProc;
        wndclsa.cbWndExtra = classesA[i].cbWndExtra;
        wndclsa.lpszClassName = classesA[i].lpszClassName;
        if (!RegisterClassExWOWA(&wndclsa, NULL, FNID_DDE_BIT, 0)) {
            RIPMSGF1(RIP_WARNING, "Failed to register ANSI class 0x%x", i);
            return FALSE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* LoadAppDlls
*
* History:
*
* 10-Apr-1992  sanfords   Birthed.
\***************************************************************************/
VOID LoadAppDlls(
    VOID)
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjA;
    HKEY hKeyWindows;
    NTSTATUS Status;
    DWORD cbSize;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        WCHAR awch[24];
    } KeyFile;
    PKEY_VALUE_PARTIAL_INFORMATION  lpKeyFile = (PKEY_VALUE_PARTIAL_INFORMATION)&KeyFile;
    DWORD cbSizeCurrent = sizeof(KeyFile);
    BOOL bAlloc = FALSE;

    if (gfLogonProcess || gfServerProcess || SYSMET(CLEANBOOT)) {
        /*
         * Don't let the logon process load appdlls because if the dll
         * sets any hooks or creates any windows, the logon process
         * will fail SetThreadDesktop().
         *
         * Additionally, we should not load app DLLs when in safe mode.
         */
        return;
    }

    /*
     * If the image is an NT Native image, we are running in the
     * context of the server.
     */
    if (RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress)->
        OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_NATIVE) {
        return;
    }

    RtlInitUnicodeString(&UnicodeString, szWindowsKey);
    InitializeObjectAttributes(&ObjA,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&hKeyWindows, KEY_READ, &ObjA);
    if (!NT_SUCCESS(Status)) {
        return;
    }

    /*
     * Read the "AppInit_Dlls" value.
     */
    RtlInitUnicodeString(&UnicodeString, szAppInit);
    while (TRUE) {
        Status = NtQueryValueKey(hKeyWindows,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 lpKeyFile,
                                 cbSizeCurrent,
                                 &cbSize);
        if (Status == STATUS_BUFFER_OVERFLOW) {
            if (bAlloc) {
                UserGlobalFree(lpKeyFile);
            }
            lpKeyFile = GlobalAlloc(LPTR, cbSize);
            if (!lpKeyFile) {
                RIPERR0(ERROR_OUTOFMEMORY,
                        RIP_WARNING,
                        "LoadAppDlls failed");
                NtClose(hKeyWindows);
                return;
            }
            bAlloc = TRUE;
            cbSizeCurrent = cbSize;
            continue;
        }
        break;
    }
    if (NT_SUCCESS(Status)) {
        LPWSTR pszSrc, pszDst, pszBase;
        WCHAR ch;

        pszBase = pszDst = pszSrc = (LPWSTR)lpKeyFile->Data;
        while (*pszSrc != L'\0') {

            while (*pszSrc == L' ' || *pszSrc == L',') {
                pszSrc++;
            }

            if (*pszSrc == L'\0') {
                break;
            }

            while (*pszSrc != L',' &&
                   *pszSrc != L'\0' &&
                   *pszSrc != L' ') {
                *pszDst++ = *pszSrc++;
            }

            ch = *pszSrc;               // get it here cuz its being done in-place.
            *pszDst++ = L'\0';          // '\0' is dll name delimiter

            LoadLibrary(pszBase);
            pszBase = pszDst;

            pszSrc++;

            if (ch == L'\0') {
                break;
            }
        }

    }

    if (bAlloc) {
        UserGlobalFree(lpKeyFile);
    }

    NtClose(hKeyWindows);
}

VOID InitOemXlateTables(
    VOID)
{
    char ach[NCHARS];
    WCHAR awch[NCHARS];
    WCHAR awchCtrl[NCTRLS];
    INT i;
    INT cch;
    char OemToAnsi[NCHARS];
    char AnsiToOem[NCHARS];

    for (i = 0; i < NCHARS; i++) {
        ach[i] = (char)i;
    }

    /*
     * First generate pAnsiToOem table.
     */

    if (GetOEMCP() == GetACP()) {
        /*
         * For far east code pages using MultiByteToWideChar below
         * won't work.  Conveniently for these code pages the OEM
         * CP equals the ANSI codepage making it trivial to compute
         * pOemToAnsi and pAnsiToOem arrays
         *
         */

        RtlCopyMemory(OemToAnsi, ach, NCHARS);
        RtlCopyMemory(AnsiToOem, ach, NCHARS);
    } else {
        cch = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  ach,
                                  NCHARS,
                                  awch,
                                  NCHARS);

        UserAssert(cch == NCHARS);

        WideCharToMultiByte(CP_OEMCP,
                            0,
                            awch,
                            NCHARS,
                            AnsiToOem,
                            NCHARS,
                            "_",
                            NULL);
        /*
         * Now generate pOemToAnsi table.
         */
        cch = MultiByteToWideChar(CP_OEMCP,
                                  MB_PRECOMPOSED | MB_USEGLYPHCHARS,
                                  ach,
                                  NCHARS,
                                  awch,
                                  NCHARS);

        UserAssert(cch == NCHARS);

        /*
         * Now patch special cases for Win3.1 compatibility
         *
         * 0x07 BULLET              (glyph 0x2022) must become 0x0007 BELL
         * 0x0F WHITE STAR WITH SUN (glyph 0x263C) must become 0x00A4 CURRENCY SIGN
         * 0x7F HOUSE               (glyph 0x2302) must become 0x007f DELETE
         */
        awch[0x07] = 0x0007;
        awch[0x0F] = 0x00a4;
        awch[0x7f] = 0x007f;

        WideCharToMultiByte(CP_ACP,
                            0,
                            awch,
                            NCHARS,
                            OemToAnsi,
                            NCHARS,
                            "_",
                            NULL);

        /*
         * Now for all OEM chars < 0x20 (control chars), test whether the glyph
         * we have is really in CP_ACP or not.  If not, then restore the
         * original control character. Note: 0x00 remains 0x00.
         */
        MultiByteToWideChar(CP_ACP, 0, OemToAnsi, NCTRLS, awchCtrl, NCTRLS);

        for (i = 1; i < NCTRLS; i++) {
            if (awchCtrl[i] != awch[i]) {
                OemToAnsi[i] = (char)i;
            }
        }
    }

    NtUserCallTwoParam((ULONG_PTR)OemToAnsi, (ULONG_PTR)AnsiToOem, SFI_INITANSIOEM);
}

const PFNCLIENT pfnClientA = {
        (KPROC)ScrollBarWndProcA,
        (KPROC)DefWindowProcA,
        (KPROC)MenuWndProcA,
        (KPROC)DesktopWndProcA,
        (KPROC)DefWindowProcA,
        (KPROC)DefWindowProcA,
        (KPROC)DefWindowProcA,
        (KPROC)ButtonWndProcA,
        (KPROC)ComboBoxWndProcA,
        (KPROC)ComboListBoxWndProcA,
        (KPROC)DefDlgProcA,
        (KPROC)EditWndProcA,
        (KPROC)ListBoxWndProcA,
        (KPROC)MDIClientWndProcA,
        (KPROC)StaticWndProcA,
        (KPROC)ImeWndProcA,
        (KPROC)fnHkINLPCWPSTRUCTA,
        (KPROC)fnHkINLPCWPRETSTRUCTA,
        (KPROC)DispatchHookA,
        (KPROC)DispatchDefWindowProcA,
        (KPROC)DispatchClientMessage,
        (KPROC)MDIActivateDlgProcA};

const   PFNCLIENT pfnClientW = {
        (KPROC)ScrollBarWndProcW,
        (KPROC)DefWindowProcW,
        (KPROC)MenuWndProcW,
        (KPROC)DesktopWndProcW,
        (KPROC)DefWindowProcW,
        (KPROC)DefWindowProcW,
        (KPROC)DefWindowProcW,
        (KPROC)ButtonWndProcW,
        (KPROC)ComboBoxWndProcW,
        (KPROC)ComboListBoxWndProcW,
        (KPROC)DefDlgProcW,
        (KPROC)EditWndProcW,
        (KPROC)ListBoxWndProcW,
        (KPROC)MDIClientWndProcW,
        (KPROC)StaticWndProcW,
        (KPROC)ImeWndProcW,
        (KPROC)fnHkINLPCWPSTRUCTW,
        (KPROC)fnHkINLPCWPRETSTRUCTW,
        (KPROC)DispatchHookW,
        (KPROC)DispatchDefWindowProcW,
        (KPROC)DispatchClientMessage,
        (KPROC)MDIActivateDlgProcW};

const PFNCLIENTWORKER pfnClientWorker = {
        (KPROC)ButtonWndProcWorker,
        (KPROC)ComboBoxWndProcWorker,
        (KPROC)ListBoxWndProcWorker,
        (KPROC)DefDlgProcWorker,
        (KPROC)EditWndProcWorker,
        (KPROC)ListBoxWndProcWorker,
        (KPROC)MDIClientWndProcWorker,
        (KPROC)StaticWndProcWorker,
        (KPROC)ImeWndProcWorker};


/***************************************************************************\
* ClientThreadSetup
*
\***************************************************************************/
BOOL ClientThreadSetup(
    VOID)
{
    PCLIENTINFO pci;
    BOOL fFirstThread;
    DWORD ConnectState;

    /*
     * NT BUG 268642: Only the first thread calls GdiProcessSetup but all the
     * other threads must wait until the setup for GDI is finished.
     *
     * We can safely use gcsAccelCache critical section to protect this (even
     * though the name is not intuitive at all)
     */

    RtlEnterCriticalSection(&gcsAccelCache);

    fFirstThread = gfFirstThread;

    /*
     * Setup GDI before continuing.
     */
    if (fFirstThread) {
        gfFirstThread = FALSE;
        GdiProcessSetup();
    }

    RtlLeaveCriticalSection(&gcsAccelCache);

    /*
     * We've already checked to see if we need to connect
     * (i.e. NtCurrentTeb()->Win32ThreadInfo == NULL). This routine
     * just does the connecting. If we've already been through here
     * once, don't do it again.
     */
    pci = GetClientInfo();
    if (pci->CI_flags & CI_INITIALIZED) {
        RIPMSG0(RIP_ERROR, "Already initialized!");
        return FALSE;
    }

    /*
     * Create the queue info and thread info. Only once for this process do
     * we pass client side addresses to the server (for server callbacks).
     */
    if (gfServerProcess && fFirstThread) {
        USERCONNECT userconnect;
        NTSTATUS    Status;

        /*
         * We know that the shared info is now available in
         * the kernel. Map it into the server process.
         */
        userconnect.ulVersion = USERCURRENTVERSION;
        userconnect.dwDispatchCount = gDispatchTableValues;
        Status = NtUserProcessConnect(NtCurrentProcess(),
                                      &userconnect,
                                      sizeof(USERCONNECT));
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

        gSharedInfo = userconnect.siClient;
        gpsi = gSharedInfo.psi;
        UserAssert(gpsi);

        UserAssert(pfnClientA.pfnScrollBarWndProc   == (KPROC)ScrollBarWndProcA);
        UserAssert(pfnClientA.pfnTitleWndProc       == (KPROC)DefWindowProcA);
        UserAssert(pfnClientA.pfnMenuWndProc        == (KPROC)MenuWndProcA);
        UserAssert(pfnClientA.pfnDesktopWndProc     == (KPROC)DesktopWndProcA);
        UserAssert(pfnClientA.pfnDefWindowProc      == (KPROC)DefWindowProcA);
        UserAssert(pfnClientA.pfnMessageWindowProc  == (KPROC)DefWindowProcA);
        UserAssert(pfnClientA.pfnHkINLPCWPSTRUCT    == (KPROC)fnHkINLPCWPSTRUCTA);
        UserAssert(pfnClientA.pfnHkINLPCWPRETSTRUCT == (KPROC)fnHkINLPCWPRETSTRUCTA);
        UserAssert(pfnClientA.pfnButtonWndProc      == (KPROC)ButtonWndProcA);
        UserAssert(pfnClientA.pfnComboBoxWndProc    == (KPROC)ComboBoxWndProcA);
        UserAssert(pfnClientA.pfnComboListBoxProc   == (KPROC)ComboListBoxWndProcA);
        UserAssert(pfnClientA.pfnDialogWndProc      == (KPROC)DefDlgProcA);
        UserAssert(pfnClientA.pfnEditWndProc        == (KPROC)EditWndProcA);
        UserAssert(pfnClientA.pfnListBoxWndProc     == (KPROC)ListBoxWndProcA);
        UserAssert(pfnClientA.pfnMDIActivateDlgProc == (KPROC)MDIActivateDlgProcA);
        UserAssert(pfnClientA.pfnMDIClientWndProc   == (KPROC)MDIClientWndProcA);
        UserAssert(pfnClientA.pfnStaticWndProc      == (KPROC)StaticWndProcA);
        UserAssert(pfnClientA.pfnDispatchHook       == (KPROC)DispatchHookA);
        UserAssert(pfnClientA.pfnDispatchMessage    == (KPROC)DispatchClientMessage);
        UserAssert(pfnClientA.pfnImeWndProc         == (KPROC)ImeWndProcA);

        UserAssert(pfnClientW.pfnScrollBarWndProc   == (KPROC)ScrollBarWndProcW);
        UserAssert(pfnClientW.pfnTitleWndProc       == (KPROC)DefWindowProcW);
        UserAssert(pfnClientW.pfnMenuWndProc        == (KPROC)MenuWndProcW);
        UserAssert(pfnClientW.pfnDesktopWndProc     == (KPROC)DesktopWndProcW);
        UserAssert(pfnClientW.pfnDefWindowProc      == (KPROC)DefWindowProcW);
        UserAssert(pfnClientW.pfnMessageWindowProc  == (KPROC)DefWindowProcW);
        UserAssert(pfnClientW.pfnHkINLPCWPSTRUCT    == (KPROC)fnHkINLPCWPSTRUCTW);
        UserAssert(pfnClientW.pfnHkINLPCWPRETSTRUCT == (KPROC)fnHkINLPCWPRETSTRUCTW);
        UserAssert(pfnClientW.pfnButtonWndProc      == (KPROC)ButtonWndProcW);
        UserAssert(pfnClientW.pfnComboBoxWndProc    == (KPROC)ComboBoxWndProcW);
        UserAssert(pfnClientW.pfnComboListBoxProc   == (KPROC)ComboListBoxWndProcW);
        UserAssert(pfnClientW.pfnDialogWndProc      == (KPROC)DefDlgProcW);
        UserAssert(pfnClientW.pfnEditWndProc        == (KPROC)EditWndProcW);
        UserAssert(pfnClientW.pfnListBoxWndProc     == (KPROC)ListBoxWndProcW);
        UserAssert(pfnClientW.pfnMDIActivateDlgProc == (KPROC)MDIActivateDlgProcW);
        UserAssert(pfnClientW.pfnMDIClientWndProc   == (KPROC)MDIClientWndProcW);
        UserAssert(pfnClientW.pfnStaticWndProc      == (KPROC)StaticWndProcW);
        UserAssert(pfnClientW.pfnDispatchHook       == (KPROC)DispatchHookW);
        UserAssert(pfnClientW.pfnDispatchMessage    == (KPROC)DispatchClientMessage);
        UserAssert(pfnClientW.pfnImeWndProc         == (KPROC)ImeWndProcW);

        UserAssert(pfnClientWorker.pfnButtonWndProc      == (KPROC)ButtonWndProcWorker);
        UserAssert(pfnClientWorker.pfnComboBoxWndProc    == (KPROC)ComboBoxWndProcWorker);
        UserAssert(pfnClientWorker.pfnComboListBoxProc   == (KPROC)ListBoxWndProcWorker);
        UserAssert(pfnClientWorker.pfnDialogWndProc      == (KPROC)DefDlgProcWorker);
        UserAssert(pfnClientWorker.pfnEditWndProc        == (KPROC)EditWndProcWorker);
        UserAssert(pfnClientWorker.pfnListBoxWndProc     == (KPROC)ListBoxWndProcWorker);
        UserAssert(pfnClientWorker.pfnMDIClientWndProc   == (KPROC)MDIClientWndProcWorker);
        UserAssert(pfnClientWorker.pfnStaticWndProc      == (KPROC)StaticWndProcWorker);
        UserAssert(pfnClientWorker.pfnImeWndProc         == (KPROC)ImeWndProcWorker);

#if DBG
        {
            PULONG_PTR pdw;

            /*
             * Make sure that everyone got initialized
             */
            for (pdw = (PULONG_PTR)&pfnClientA;
                 (ULONG_PTR)pdw<(ULONG_PTR)(&pfnClientA) + sizeof(pfnClientA);
                 pdw++) {
                UserAssert(*pdw);
            }

            for (pdw = (PULONG_PTR)&pfnClientW;
                 (ULONG_PTR)pdw<(ULONG_PTR)(&pfnClientW) + sizeof(pfnClientW);
                 pdw++) {
                UserAssert(*pdw);
            }
        }
#endif

#if DBG
    {
        extern CONST INT gcapfnScSendMessage;
        BOOLEAN apfnCheckMessage[64];
        int i;

        /*
         * Do some verification of the message table. Since we only have
         * 6 bits to store the function index, the function table can have
         * at most 64 entries. Also verify that none of the indexes point
         * past the end of the table and that all the function entries
         * are used.
         */
        UserAssert(gcapfnScSendMessage <= 64);
        RtlZeroMemory(apfnCheckMessage, sizeof(apfnCheckMessage));
        for (i = 0; i < WM_USER; i++) {
            UserAssert(MessageTable[i].iFunction < gcapfnScSendMessage);
            apfnCheckMessage[MessageTable[i].iFunction] = TRUE;
        }

        for (i = 0; i < gcapfnScSendMessage; i++) {
            UserAssert(apfnCheckMessage[i]);
        }
    }
#endif

    }

    /*
     * Pass the function pointer arrays to the kernel. This also establishes
     * the kernel state for the thread. If ClientThreadSetup is called from
     * CsrConnectToUser this call will raise an exception if the thread
     * cannot be converted to a gui thread. The exception is handled in
     * CsrConnectToUser.
     */
#if DBG && !defined(BUILD_WOW6432)
    /*
     * On debug systems, go to the kernel for all processes to verify we're
     * loading user32.dll at the right address.
     */
    if (fFirstThread) {
#elif defined(BUILD_WOW6432)
    /*
     * On WOW64 always register the client fns.
     */
    {
#else
    if (gfServerProcess && fFirstThread) {
#endif
        if (!NT_SUCCESS(NtUserInitializeClientPfnArrays(&pfnClientA, &pfnClientW, &pfnClientWorker, hmodUser))) {

            RIPERR0(ERROR_OUTOFMEMORY,
                    RIP_WARNING,
                    "NtUserInitializeClientPfnArrays failed");

            return FALSE;
        }
    }

    /*
     * Mark this thread as being initialized. If the connection to the
     * server fails, NtCurrentTeb()->Win32ThreadInfo will remain NULL.
     */
    pci->CI_flags |= CI_INITIALIZED;

    /*
     * Some initialization only has to occur once per process.
     */
    if (fFirstThread) {
        ConnectState = (DWORD)NtUserCallNoParam(SFI_REMOTECONNECTSTATE);

        /*
         * Winstation Winlogon and CSR must do graphics initialization
         * after the connect.
         */
        if (ConnectState != CTX_W32_CONNECT_STATE_IDLE) {
            if ((ghdcBits2 = CreateCompatibleDC(NULL)) == NULL) {
                RIPERR0(ERROR_OUTOFMEMORY, RIP_WARNING, "ghdcBits2 creation failed");
                return FALSE;
            }

            if (!InitClientDrawing()) {
                RIPERR0(ERROR_OUTOFMEMORY, RIP_WARNING, "InitClientDrawing failed");
                return FALSE;
            }
        }

        gfSystemInitialized = NtUserGetThreadDesktop(GetCurrentThreadId(),
                                                     NULL) != NULL;

        /*
         * If an lpk is loaded for this process notify the kernel.
         */
        if (gdwLpkEntryPoints) {
            NtUserCallOneParam(gdwLpkEntryPoints, SFI_REGISTERLPK);
        }

        if (gfServerProcess || GetClientInfo()->pDeskInfo == NULL) {
            /*
             * Perform any server initialization.
             */
            UserAssert(gpsi);

            if (pdiLocal = UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(DESKTOPINFO))) {
                GetClientInfo()->pDeskInfo = pdiLocal;
            } else {
                RIPERR0(ERROR_OUTOFMEMORY, RIP_WARNING, "pdiLocal creation failed");
                return FALSE;
            }
        }

        if (gfServerProcess) {
            /*
             * Winstation Winlogon and CSR must do graphics initialization
             * after the connect.
             */
            if (ConnectState != CTX_W32_CONNECT_STATE_IDLE) {
                if (!LoadCursorsAndIcons()) {
                    RIPERR0(ERROR_OUTOFMEMORY, RIP_WARNING, "LoadCursorsAndIcons failed");
                    return FALSE;
                }
            }

            InitOemXlateTables();
        }

        LoadAppDlls();
    } else if (gfServerProcess) {
        GetClientInfo()->pDeskInfo = pdiLocal;
    }

    pci->lpClassesRegistered = &gbClassesRegistered;
#ifndef LAZY_CLASS_INIT
    /*
     * Kernel sets CI_REGISTERCLASSES when appropriate (i.e. always
     * for the first thread and for other threads if the last GUI
     * thread for a process has exited) except for the CSR proces.
     * For the CSR process, you must register the classes on the
     * first thread anyways.
     */

    if (fFirstThread || (pci->CI_flags & CI_REGISTERCLASSES)) {
        /*
         * If it's the first thread we already made it to the kernel
         * to get the ConnectState.
         */
        if (!fFirstThread) {
            ConnectState = (DWORD)NtUserCallNoParam(SFI_REMOTECONNECTSTATE);
        }

        if (ConnectState != CTX_W32_CONNECT_STATE_IDLE) {
            /*
             * Register the control classes.
             */
            if (!UserRegisterControls() || !UserRegisterDDEML()) {
                return FALSE;
            }
        }
    }
#endif

    return TRUE;
}

/***************************************************************************\
* Dispatch routines.
*
*
\***************************************************************************/
HLOCAL WINAPI DispatchLocalAlloc(
    UINT   uFlags,
    UINT   uBytes,
    HANDLE hInstance)
{
    UNREFERENCED_PARAMETER(hInstance);

    return LocalAlloc(uFlags, uBytes);
}

HLOCAL WINAPI DispatchLocalReAlloc(
    HLOCAL hMem,
    UINT   uBytes,
    UINT   uFlags,
    HANDLE hInstance,
    PVOID* ppv)
{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(ppv);

    return LocalReAlloc(hMem, uBytes, uFlags);
}

LPVOID WINAPI DispatchLocalLock(
    HLOCAL hMem,
    HANDLE hInstance)
{
    UNREFERENCED_PARAMETER(hInstance);

    return LocalLock(hMem);
}

BOOL WINAPI DispatchLocalUnlock(
    HLOCAL hMem,
    HANDLE hInstance)
{
    UNREFERENCED_PARAMETER(hInstance);

    return LocalUnlock(hMem);
}

UINT WINAPI DispatchLocalSize(
    HLOCAL hMem,
    HANDLE hInstance)
{
    UNREFERENCED_PARAMETER(hInstance);

    return (UINT)LocalSize(hMem);
}

HLOCAL WINAPI DispatchLocalFree(
    HLOCAL hMem,
    HANDLE hInstance)
{
    UNREFERENCED_PARAMETER(hInstance);

    return LocalFree(hMem);
}

/***************************************************************************\
* Allocation routines for RTL functions.
*
*
\***************************************************************************/
PVOID UserRtlAllocMem(
    ULONG uBytes)
{
    return UserLocalAlloc(HEAP_ZERO_MEMORY, uBytes);
}

VOID UserRtlFreeMem(
    PVOID pMem)
{
    UserLocalFree(pMem);
}

/***************************************************************************\
* InitClientDrawing
*
* History:
* 20-Aug-1992 mikeke    Created
\***************************************************************************/
BOOL InitClientDrawing(
    VOID)
{
    static CONST WORD patGray[8] = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};
    BOOL fSuccess = TRUE;
    HBITMAP hbmGray = CreateBitmap(8, 8, 1, 1, (LPBYTE)patGray);

    fSuccess &= !!hbmGray;

    UserAssert(ghbrWhite == NULL);
    ghbrWhite = GetStockObject(WHITE_BRUSH);
    fSuccess &= !!ghbrWhite;

    UserAssert(ghbrBlack == NULL);
    ghbrBlack = GetStockObject(BLACK_BRUSH);
    fSuccess &= !!ghbrBlack;

    /*
     * Create the global-objects for client drawing.
     */
    ghbrWindowText = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT));
    fSuccess &= !!ghbrWindowText;

    ghFontSys = GetStockObject(SYSTEM_FONT);
    fSuccess &= !!ghFontSys;

    ghdcGray = CreateCompatibleDC(NULL);
    fSuccess &= !!ghdcGray;

    if (!fSuccess) {
        RIPMSG0(RIP_WARNING, "InitClientDrawing failed to allocate resources");
        return FALSE;
    }

    /*
     * Setup the gray surface.
     */
    SelectObject(ghdcGray, hbmGray);
    SelectObject(ghdcGray, ghFontSys);
    SelectObject(ghdcGray, KHBRUSH_TO_HBRUSH(gpsi->hbrGray));

    /*
     * Setup the gray attributes.
     */
    SetBkMode(ghdcGray, OPAQUE);
    SetTextColor(ghdcGray, 0x00000000L);
    SetBkColor(ghdcGray, 0x00FFFFFFL);

    gcxGray = 8;
    gcyGray = 8;

    return TRUE;
}

VOID
InitializeLpkHooks(
    CONST FARPROC *lpfpLpkHooks)
{
    /*
     * Called from GdiInitializeLanguagePack(). Remember what entry points
     * are supported. Pass the information to the kernel the first time this
     * process connects in ClientThreadSetup().
     */
    if (lpfpLpkHooks[LPK_TABBED_TEXT_OUT]) {
        fpLpkTabbedTextOut = (FPLPKTABBEDTEXTOUT)lpfpLpkHooks[LPK_TABBED_TEXT_OUT];
        gdwLpkEntryPoints |= (1 << LPK_TABBED_TEXT_OUT);
    }
    if (lpfpLpkHooks[LPK_PSM_TEXT_OUT]) {
        fpLpkPSMTextOut = (FPLPKPSMTEXTOUT)lpfpLpkHooks[LPK_PSM_TEXT_OUT];
        gdwLpkEntryPoints |= (1 << LPK_PSM_TEXT_OUT);
    }
    if (lpfpLpkHooks[LPK_DRAW_TEXT_EX]) {
        fpLpkDrawTextEx = (FPLPKDRAWTEXTEX)lpfpLpkHooks[LPK_DRAW_TEXT_EX];
        gdwLpkEntryPoints |= (1 << LPK_DRAW_TEXT_EX);
    }
    if (lpfpLpkHooks[LPK_EDIT_CONTROL]) {
        fpLpkEditControl = (PLPKEDITCALLOUT)lpfpLpkHooks[LPK_EDIT_CONTROL];
        gdwLpkEntryPoints |= (1 << LPK_EDIT_CONTROL);
    }
}

/***************************************************************************\
*
* CtxInitUser32
*
* Called by CreateWindowStation() and winsrv.dll DoConnect routine.
*
* Winstation Winlogon and CSR must do graphics initialization after the
* connect. This is because no video driver is loaded until then.
*
* This routine must contain everything that was skipped before.
*
* History:
* Dec-11-1997 clupu    Ported from Citrix
\***************************************************************************/
BOOL CtxInitUser32(
    VOID)
{
    /*
     * Only do once.
     */
    if (ghdcBits2 != NULL || NtCurrentPeb()->SessionId == 0) {
        return TRUE;
    }

    ghdcBits2 = CreateCompatibleDC(NULL);
    if (ghdcBits2 == NULL) {
        RIPMSG0(RIP_WARNING, "Could not allocate ghdcBits2");
        return FALSE;
    }

    if (!InitClientDrawing()) {
        RIPMSG0(RIP_WARNING, "InitClientDrawing failed");
        return FALSE;
    }

    if (gfServerProcess) {
        if (!LoadCursorsAndIcons()) {
            RIPMSG0(RIP_WARNING, "LoadCursorsAndIcons failed");
            return FALSE;
        }
    }

#ifndef LAZY_CLASS_INIT
    /*
     * Register the control and DDE classes.
     */
    if (!UserRegisterControls() || !UserRegisterDDEML()) {
        return FALSE;
    }
#endif

    return TRUE;
}

#if DBG
DWORD GetRipComponent(
    VOID)
{
    return RIP_USER;
}

VOID SetRipFlags(
    DWORD dwRipFlags)
{
    NtUserSetRipFlags(dwRipFlags);
}

VOID SetDbgTag(
    int tag,
    DWORD dwBitFlags)
{
    NtUserSetDbgTag(tag, dwBitFlags);
}

VOID PrivateSetRipFlags(
    DWORD dwRipFlags)
{
    gDbgGlobals.dwTouchedMask |= USERDBG_FLAGSTOUCHED;
    gDbgGlobals.dwRIPFlags = dwRipFlags;
}

VOID PrivateSetDbgTag(
    int tag,
    DWORD dwBitFlags)
{
    gDbgGlobals.dwTouchedMask |= USERDBG_TAGSTOUCHED;
    gDbgGlobals.adwDBGTAGFlags[tag] = dwBitFlags;
}

DWORD GetDbgTagFlags(
    int tag)
{
    if (gDbgGlobals.dwTouchedMask & USERDBG_TAGSTOUCHED) {
        return gDbgGlobals.adwDBGTAGFlags[tag];
    } else {
        return (gpsi != NULL ? gpsi->adwDBGTAGFlags[tag] : 0);
    }
}

DWORD GetRipFlags(
    VOID)
{
    if (gDbgGlobals.dwTouchedMask & USERDBG_FLAGSTOUCHED) {
        return gDbgGlobals.dwRIPFlags;
    } else {
        return (gpsi != NULL ? gpsi->dwRIPFlags : RIPF_DEFAULT);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\clmenu.c ===
/****************************** Module Header ******************************\
*
* Module Name: clmenu.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Loading Routines
*
* History:
* 24-Sep-1990 mikeke        From win30
* 29-Nov-1994 JimA          Moved from server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* MenuLoadWinTemplates
*
* Recursive routine that loads in the new style menu template and
* builds the menu. Assumes that the menu template header has already been
* read in and processed elsewhere...
*
* History:
* 28-Sep-1990 mikeke     from win30
\***************************************************************************/

LPBYTE MenuLoadWinTemplates(
    LPBYTE lpMenuTemplate,
    HMENU *phMenu)
{
    HMENU hMenu;
    UINT menuFlags = 0;
    ULONG_PTR menuId = 0;
    LPWSTR lpmenuText;
    MENUITEMINFO    mii;
    UNICODE_STRING str;

    if (!(hMenu = NtUserCreateMenu()))
        goto memoryerror;

    do {

        /*
         * Get the menu flags.
         */
        menuFlags = (UINT)(*(WORD *)lpMenuTemplate);
        lpMenuTemplate += 2;

        if (menuFlags & ~MF_VALID) {
            RIPERR1(ERROR_INVALID_DATA, RIP_WARNING, "Menu Flags %lX are invalid", menuFlags);
            goto memoryerror;
        }


        if (!(menuFlags & MF_POPUP)) {
            menuId = *(WORD *)lpMenuTemplate;
            lpMenuTemplate += 2;
        }

        lpmenuText = (LPWSTR)lpMenuTemplate;

        if (*lpmenuText) {
            /*
             * Some Win3.1 and Win95 16 bit apps (chessmaster, mavis typing) know that
             * dwItemData for MFT_OWNERDRAW items is a pointer to a string in the resource data.
             * So WOW has given us the proper pointer from the 16 bit resource.
             *
             * Sundown Note:
             * __unaligned unsigned long value pointed by lpMenuTemplate is zero-extended to
             * update lpmenuText. WOW restrictions.
             */
            if ((menuFlags & MFT_OWNERDRAW)
                    && (GetClientInfo()->dwTIFlags & TIF_16BIT)) {
                lpmenuText = (LPWSTR)ULongToPtr( (*(DWORD UNALIGNED *)lpMenuTemplate) );
                /*
                 * We'll skip one WCHAR later; so skip only the difference now.
                 */
                lpMenuTemplate += sizeof(DWORD) - sizeof(WCHAR);
            } else {
                /*
                 * If a string exists, then skip to the end of it.
                 */
                RtlInitUnicodeString(&str, lpmenuText);
                lpMenuTemplate = lpMenuTemplate + str.Length;
            }

        } else {
            lpmenuText = NULL;
        }

        /*
         * Skip over terminating NULL of the string (or the single NULL
         * if empty string).
         */
        lpMenuTemplate += sizeof(WCHAR);
        lpMenuTemplate = NextWordBoundary(lpMenuTemplate);

        RtlZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_STATE | MIIM_FTYPE;
        if (lpmenuText) {
            mii.fMask |= MIIM_STRING;
        }

        if (menuFlags & MF_POPUP) {
            mii.fMask |= MIIM_SUBMENU;
            lpMenuTemplate = MenuLoadWinTemplates(lpMenuTemplate,
                    (HMENU *)&menuId);
            if (!lpMenuTemplate)
                goto memoryerror;

            mii.hSubMenu = (HMENU)menuId;
        }

        /*
         * We have to take out MF_HILITE since that bit marks the end of a
         * menu in a resource file.  Since we shouldn't have any pre hilited
         * items in the menu anyway, this is no big deal.
         */
        if (menuFlags & MF_BITMAP) {

            /*
             * Don't allow bitmaps from the resource file.
             */
            menuFlags = (UINT)((menuFlags | MFT_RIGHTJUSTIFY) & ~MF_BITMAP);
        }

        // We have to take out MFS_HILITE since that bit marks the end of a menu in
        // a resource file.  Since we shouldn't have any pre hilited items in the
        // menu anyway, this is no big deal.
        mii.fState = (menuFlags & MFS_OLDAPI_MASK) & ~MFS_HILITE;
        mii.fType = (menuFlags & MFT_OLDAPI_MASK);
        if (menuFlags & MFT_OWNERDRAW)
        {
            mii.fMask |= MIIM_DATA;
            mii.dwItemData = (ULONG_PTR) lpmenuText;
            lpmenuText = 0;
        }
        mii.dwTypeData = (LPWSTR) lpmenuText;
        mii.cch = (UINT)-1;
        mii.wID = (UINT)menuId;

        if (!NtUserThunkedMenuItemInfo(hMenu, MFMWFP_NOITEM, TRUE, TRUE,
                    &mii, lpmenuText ? &str : NULL)) {
            if (menuFlags & MF_POPUP)
                NtUserDestroyMenu(mii.hSubMenu);
            goto memoryerror;
        }

    } while (!(menuFlags & MF_END));

    *phMenu = hMenu;
    return lpMenuTemplate;

memoryerror:
    if (hMenu != NULL)
        NtUserDestroyMenu(hMenu);
    *phMenu = NULL;
    return NULL;
}


/***************************************************************************\
* MenuLoadChicagoTemplates
*
* Recursive routine that loads in the new new style menu template and
* builds the menu. Assumes that the menu template header has already been
* read in and processed elsewhere...
*
* History:
* 15-Dec-93 SanfordS    Created
\***************************************************************************/

PMENUITEMTEMPLATE2 MenuLoadChicagoTemplates(
    PMENUITEMTEMPLATE2 lpMenuTemplate,
    HMENU *phMenu,
    WORD wResInfo,
    UINT mftRtl)
{
    HMENU hMenu;
    HMENU hSubMenu;
    long menuId = 0;
    LPWSTR lpmenuText;
    MENUITEMINFO    mii;
    UNICODE_STRING str;
    DWORD           dwHelpID;

    if (!(hMenu = NtUserCreateMenu()))
        goto memoryerror;

    do {
        if (!(wResInfo & MFR_POPUP)) {
            /*
             * If the PREVIOUS wResInfo field was not a POPUP, the
             * dwHelpID field is not there.  Back up so things fit.
             */
            lpMenuTemplate = (PMENUITEMTEMPLATE2)(((LPBYTE)lpMenuTemplate) -
                    sizeof(lpMenuTemplate->dwHelpID));
            dwHelpID = 0;
        } else
            dwHelpID = lpMenuTemplate->dwHelpID;

        menuId = lpMenuTemplate->menuId;

        RtlZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_STATE | MIIM_FTYPE ;

        mii.fType = lpMenuTemplate->fType | mftRtl;
        if (mii.fType & ~MFT_MASK) {
            RIPERR1(ERROR_INVALID_DATA, RIP_WARNING, "Menu Type flags %lX are invalid", mii.fType);
            goto memoryerror;
        }

        mii.fState  = lpMenuTemplate->fState;
        if (mii.fState & ~MFS_MASK) {
            RIPERR1(ERROR_INVALID_DATA, RIP_WARNING, "Menu State flags %lX are invalid", mii.fState);
            goto memoryerror;
        }

        wResInfo = lpMenuTemplate->wResInfo;
        if (wResInfo & ~(MF_END | MFR_POPUP)) {
            RIPERR1(ERROR_INVALID_DATA, RIP_WARNING, "Menu ResInfo flags %lX are invalid", wResInfo);
            goto memoryerror;
        }

        if (dwHelpID) {
            NtUserSetMenuContextHelpId(hMenu,dwHelpID);
        }
        if (lpMenuTemplate->mtString[0]) {
            lpmenuText = lpMenuTemplate->mtString;
            mii.fMask |= MIIM_STRING;
        } else {
            lpmenuText = NULL;
        }
        RtlInitUnicodeString(&str, lpmenuText);

        mii.dwTypeData = (LPWSTR) lpmenuText;

        /*
         * skip to next menu item template (DWORD boundary)
         */
        lpMenuTemplate = (PMENUITEMTEMPLATE2)
                (((LPBYTE)lpMenuTemplate) +
                sizeof(MENUITEMTEMPLATE2) +
                ((str.Length + 3) & ~3));

        if (mii.fType & MFT_OWNERDRAW)
        {
            mii.fMask |= MIIM_DATA;
            mii.dwItemData = (ULONG_PTR) mii.dwTypeData;
            mii.dwTypeData = 0;
        }

        /*
         * If MFT_RIGHTORDER is specified then all subsequent
         * menus are right-to-left as well.
         */
        if (mii.fType & MFT_RIGHTORDER)
        {
            mftRtl = MFT_RIGHTORDER;
            NtUserSetMenuFlagRtoL(hMenu);
        }

        if (wResInfo & MFR_POPUP) {
            mii.fMask |= MIIM_SUBMENU;
            lpMenuTemplate = MenuLoadChicagoTemplates(lpMenuTemplate,
                    &hSubMenu, MFR_POPUP, mftRtl);
            if (lpMenuTemplate == NULL)
                goto memoryerror;
            mii.hSubMenu = hSubMenu;
        }

        if (mii.fType & MFT_BITMAP) {

            /*
             * Don't allow bitmaps from the resource file.
             */
            mii.fType = (mii.fType | MFT_RIGHTJUSTIFY) & ~MFT_BITMAP;
        }

        mii.cch = (UINT)-1;
        mii.wID = menuId;
        if (!NtUserThunkedMenuItemInfo(hMenu, MFMWFP_NOITEM, TRUE, TRUE,
                    &mii, &str)) {
            if (wResInfo & MFR_POPUP)
                NtUserDestroyMenu(mii.hSubMenu);
            goto memoryerror;
        }
        wResInfo &= ~MFR_POPUP;
    } while (!(wResInfo & MFR_END));

    *phMenu = hMenu;
    return lpMenuTemplate;

memoryerror:
    if (hMenu != NULL)
        NtUserDestroyMenu(hMenu);
    *phMenu = NULL;
    return NULL;
}


/***************************************************************************\
* CreateMenuFromResource
*
* Loads the menu resource named by the lpMenuTemplate parameter. The
* template specified by lpMenuTemplate is a collection of one or more
* MENUITEMTEMPLATE structures, each of which may contain one or more items
* and popup menus. If successful, returns a handle to the menu otherwise
* returns NULL.
*
* History:
* 28-Sep-1990 mikeke     from win30
\***************************************************************************/

HMENU CreateMenuFromResource(
    LPBYTE lpMenuTemplate)
{
    HMENU hMenu = NULL;
    UINT menuTemplateVersion;
    UINT menuTemplateHeaderSize;

    /*
     * Win3 menu resource: First, strip version number word out of the menu
     * template.  This value should be 0 for Win3, 1 for win4.
     */
    menuTemplateVersion = *((WORD *)lpMenuTemplate)++;
    if (menuTemplateVersion > 1) {
        RIPMSG0(RIP_WARNING, "Menu Version number > 1");
        return NULL;
    }
    menuTemplateHeaderSize = *((WORD *)lpMenuTemplate)++;
    lpMenuTemplate += menuTemplateHeaderSize;
    switch (menuTemplateVersion) {
    case 0:
        MenuLoadWinTemplates(lpMenuTemplate, &hMenu);
        break;

    case 1:
        MenuLoadChicagoTemplates((PMENUITEMTEMPLATE2)lpMenuTemplate, &hMenu, 0, 0);
        break;
    }
    return hMenu;
}

/***************************************************************************\
* SetMenu (API)
*
* Sets the menu for the hwnd.
*
* History:
* 10-Mar-1996 ChrisWil  Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetMenu, HWND, hwnd, HMENU, hmenu)
BOOL SetMenu(
    HWND  hwnd,
    HMENU hmenu)
{
    return NtUserSetMenu(hwnd, hmenu, TRUE);
}

/***************************************************************************\
* LoadMenu (API)
*
* Loads the menu resource named by lpMenuName from the executable
* file associated by the module specified by the hInstance parameter. The
* menu is loaded only if it hasn't been previously loaded. Otherwise it
* retrieves a handle to the loaded resource. Returns NULL if unsuccessful.
*
* History:
* 04-05-91 ScottLu Fixed to work with client/server.
* 28-Sep-1990 mikeke from win30
\***************************************************************************/

HMENU CommonLoadMenu(
    HINSTANCE hmod,
    HANDLE hResInfo
    )
{
    HANDLE h;
    PVOID p;
    HMENU hMenu = NULL;

    if (h = LOADRESOURCE(hmod, hResInfo)) {

        if (p = LOCKRESOURCE(h, hmod)) {

            hMenu = CreateMenuFromResource(p);

            UNLOCKRESOURCE(h, hmod);
        }
        /*
         * Win95 and Win3.1 do not free this resource; some 16 bit apps (chessmaster
         * and mavis typing) require this for their ownerdraw menu stuff.
         * For 32 bit apps, FreeResource is a nop anyway. For 16 bit apps,
         * Wow frees the 32 bit resource (returned by LockResource16)
         * in UnlockResource16; the actual 16 bit resource is freed when the task
         * goes away.
         *
         *   FREERESOURCE(h, hmod);
         */
    }

    return (hMenu);
}


FUNCLOG2(LOG_GENERAL, HMENU, WINAPI, LoadMenuA, HINSTANCE, hmod, LPCSTR, lpName)
HMENU WINAPI LoadMenuA(
    HINSTANCE hmod,
    LPCSTR lpName)
{
    HANDLE hRes;

    if (hRes = FINDRESOURCEA(hmod, (LPSTR)lpName, (LPSTR)RT_MENU))
        return CommonLoadMenu(hmod, hRes);
    else
        return NULL;
}


FUNCLOG2(LOG_GENERAL, HMENU, WINAPI, LoadMenuW, HINSTANCE, hmod, LPCWSTR, lpName)
HMENU WINAPI LoadMenuW(
    HINSTANCE hmod,
    LPCWSTR lpName)
{
    HANDLE hRes;

    if (hRes = FINDRESOURCEW(hmod, (LPWSTR)lpName, RT_MENU))
        return CommonLoadMenu(hmod, hRes);
    else
        return NULL;
}
/***************************************************************************\
* InternalInsertMenuItem
*
* History:
*  09/20/96 GerardoB - Created
\***************************************************************************/
BOOL InternalInsertMenuItem (HMENU hMenu, UINT uID, BOOL fByPosition, LPCMENUITEMINFO lpmii)
{
 return ThunkedMenuItemInfo(hMenu, uID, fByPosition, TRUE, (LPMENUITEMINFOW)lpmii, FALSE);
}

/***************************************************************************\
* ValidateMENUITEMINFO() -
*   it converts and validates a MENUITEMINFO95 or a new-MENUITEMINFO-with-old-flags
*     to a new MENUITEMINFO -- this way all internal code can assume one look for the
*   structure
*
* History:
*  12-08-95 Ported from Nashville - jjk
*  07-19-96 GerardoB - Fixed up for 5.0
\***************************************************************************/
BOOL ValidateMENUITEMINFO(LPMENUITEMINFO lpmiiIn, LPMENUITEMINFO lpmii, DWORD dwAPICode)
{
    BOOL fOldApp;

    if (lpmiiIn == NULL) {
        VALIDATIONFAIL(lpmiiIn);
    }

    /*
     * In order to map the old flags to the new ones, we might have to modify
     *  the lpmiiIn structure. So we make a copy to avoid breaking anyone.
     */
    fOldApp = (lpmiiIn->cbSize == SIZEOFMENUITEMINFO95);
    UserAssert(SIZEOFMENUITEMINFO95 < sizeof(MENUITEMINFO));
    RtlCopyMemory(lpmii, lpmiiIn, SIZEOFMENUITEMINFO95);
    if (fOldApp) {
        lpmii->cbSize = sizeof(MENUITEMINFO);
        lpmii->hbmpItem = NULL;
    } else if (lpmiiIn->cbSize == sizeof(MENUITEMINFO)) {
        lpmii->hbmpItem = lpmiiIn->hbmpItem;
    } else {
        VALIDATIONFAIL(lpmiiIn->cbSize);
    }


    if (lpmii->fMask & ~MIIM_MASK) {
        VALIDATIONFAIL(lpmii->fMask);
    } else if ((lpmii->fMask & MIIM_TYPE)
            && (lpmii->fMask & (MIIM_FTYPE | MIIM_STRING | MIIM_BITMAP))) {
        /*
         * Don't let them mix new and old flags
         */
        VALIDATIONFAIL(lpmii->fMask);
    }

    /*
     * No more validation needed for Get calls
     */
    if (dwAPICode == MENUAPI_GET) {
        /*
         * Map MIIM_TYPE for old apps doing a Get.
         * Keep the MIIM_TYPE flag so we'll know this guy passed the old flags.
         * GetMenuItemInfo uses lpmii->hbmpItem to determine if a bitmap
         *  was returned. So we NULL it out here. The caller is using the
         *  old flags so he shouldn't care about it.
         */
        if (lpmii->fMask & MIIM_TYPE) {
            lpmii->fMask |= MIIM_FTYPE | MIIM_BITMAP | MIIM_STRING;
            lpmii->hbmpItem = NULL;
        }
        return TRUE;
    }

    /*
     * Map MIIM_TYPE to MIIM_FTYPE
     */
    if (lpmii->fMask & MIIM_TYPE) {
        lpmii->fMask |= MIIM_FTYPE;
    }

    if (lpmii->fMask & MIIM_FTYPE) {
        if (lpmii->fType & ~MFT_MASK) {
            VALIDATIONFAIL(lpmii->fType);
        }
        /*
         * If using MIIM_TYPE, Map MFT_BITMAP to MIIM_BITMAP
         *  and MFT_NONSTRING to MIIM_STRING.
         * Old applications couldn't use string and bitmap simultaneously
         *  so setting one implies clearing the other.
         */
        if (lpmii->fMask & MIIM_TYPE) {
            if (lpmii->fType & MFT_BITMAP) {
                /*
                 * Don't display a warning. A lot of shell menus hit this
                 * if (!fOldApp) {
                 *     VALIDATIONOBSOLETE(MFT_BITMAP, MIIM_BITMAP);
                 *  }
                 */
                lpmii->fMask |= MIIM_BITMAP | MIIM_STRING;
                lpmii->hbmpItem = (HBITMAP)lpmii->dwTypeData;
                lpmii->dwTypeData = 0;
            } else if (!(lpmii->fType & MFT_NONSTRING)) {
                /*
                 * Don't display a warning. A lot of shell menus hit this
                 * if (!fOldApp) {
                 *     VALIDATIONOBSOLETE(MFT_STRING, MIIM_STRING);
                 *  }
                 */
                lpmii->fMask |= MIIM_BITMAP | MIIM_STRING;
                lpmii->hbmpItem = NULL;
            }
        } else if (lpmii->fType & MFT_BITMAP) {
            /*
             * Don't let them mix new and old flags
             */
            VALIDATIONFAIL(lpmii->fType);
        }
    }

    if ((lpmii->fMask & MIIM_STATE) && (lpmii->fState & ~MFS_MASK)){
        VALIDATIONFAIL(lpmii->fState);
    }

    if (lpmii->fMask & MIIM_CHECKMARKS) {
        if ((lpmii->hbmpChecked != NULL) && !GdiValidateHandle((HBITMAP)lpmii->hbmpChecked)) {
            VALIDATIONFAIL(lpmii->hbmpChecked);
        }
        if ((lpmii->hbmpUnchecked != NULL) && !GdiValidateHandle((HBITMAP)lpmii->hbmpUnchecked)) {
            VALIDATIONFAIL(lpmii->hbmpUnchecked);
        }
    }

    if (lpmii->fMask & MIIM_SUBMENU) {
        if ((lpmii->hSubMenu != NULL) && !VALIDATEHMENU(lpmii->hSubMenu)) {
            VALIDATIONFAIL(lpmii->hSubMenu);
        }
    }

    /*
     * Warning: NULL lpmii->hbmpItem accepted as valid (or the explorer breaks)
     */
    if (lpmii->fMask & MIIM_BITMAP) {
        if ((lpmii->hbmpItem != HBMMENU_CALLBACK)
                && (lpmii->hbmpItem >= HBMMENU_MAX)
                && !GdiValidateHandle(lpmii->hbmpItem)) {

            /*
             * Compatibility hack
             */
            if (((HBITMAP)LOWORD(HandleToUlong(lpmii->hbmpItem)) >= HBMMENU_MAX) || !IS_PTR(lpmii->hbmpItem)) {
                VALIDATIONFAIL(lpmii->hbmpItem);
            }
        }
    }

    /*
     * Warning: No dwTypeData / cch validation
     */

    return TRUE;

    VALIDATIONERROR(FALSE);
}

/***************************************************************************\
* ValidateMENUINFO() -
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/

BOOL ValidateMENUINFO(LPCMENUINFO lpmi, DWORD dwAPICode)
{
    if (lpmi == NULL) {
        VALIDATIONFAIL(lpmi);
    }

    if (lpmi->cbSize != sizeof(MENUINFO)) {
        VALIDATIONFAIL(lpmi->cbSize);
    }

    if (lpmi->fMask & ~MIM_MASK) {
        VALIDATIONFAIL(lpmi->fMask);
    }

    /*
     * No more validation needed for Get calls
     */
    if (dwAPICode == MENUAPI_GET){
        return TRUE;
    }

    if ((lpmi->fMask & MIM_STYLE) && (lpmi->dwStyle & ~MNS_VALID)) {
        VALIDATIONFAIL(lpmi->dwStyle);
    }

    if (lpmi->fMask & MIM_BACKGROUND) {
        if ((lpmi->hbrBack != NULL)
                && !GdiValidateHandle((HBRUSH)lpmi->hbrBack)) {

            VALIDATIONFAIL(lpmi->hbrBack);
        }
    }

    return TRUE;

    VALIDATIONERROR(FALSE);
}
/***************************************************************************\
* GetMenuInfo
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetMenuInfo, HMENU, hMenu, LPMENUINFO, lpmi)
BOOL GetMenuInfo(HMENU hMenu, LPMENUINFO lpmi)
{
    PMENU pMenu;

    if (!ValidateMENUINFO(lpmi, MENUAPI_GET)) {
        return FALSE;
    }

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return FALSE;
    }

    if (lpmi->fMask & MIM_STYLE) {
        lpmi->dwStyle = pMenu->fFlags & MNS_VALID;
    }

    if (lpmi->fMask & MIM_MAXHEIGHT) {
        lpmi->cyMax = pMenu->cyMax;
    }

    if (lpmi->fMask & MIM_BACKGROUND) {
        lpmi->hbrBack = KHBRUSH_TO_HBRUSH(pMenu->hbrBack);
    }

    if (lpmi->fMask & MIM_HELPID) {
        lpmi->dwContextHelpID = pMenu->dwContextHelpId;
    }

    if (lpmi->fMask & MIM_MENUDATA) {
        lpmi->dwMenuData = KERNEL_ULONG_PTR_TO_ULONG_PTR(pMenu->dwMenuData);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\clglobal.c ===
/****************************** Module Header ******************************\
* Module Name: clglobal.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all of USER.DLL's global variables. These are all
* instance-specific, i.e. each client has his own copy of these. In general,
* there shouldn't be much reason to create instance globals.
*
* NOTE: In this case what we mean by global is that this data is shared by
* all threads of a given process, but not shared between processes
* or between the client and the server. None of this data is useful
* (or even accessable) to the server.
*
* History:
* 10-18-90 DarrinM Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


#ifdef LAZY_CLASS_INIT
BOOL gbClassesRegistered;
#endif

/*
 * We get this warning if we don't explicitly initalize gZero:
 *
 * C4132: 'gZero' : const object should be initialized
 *
 * But we can't explicitly initialize it since it is a union. So
 * we turn the warning off.
 */
#pragma warning(disable:4132)
CONST ALWAYSZERO gZero;
#pragma warning(default:4132)

/*
 * Amount wheel has been scrolled in a control less than WHEEL_DELTA. Each
 * control resets this variable to 0 in WM_KILLFOCUS, and verifies it is
 * 0 in WM_SETFOCUS.
 * CONSIDER: Should be per-queue rather than per client?
 */
int gcWheelDelta;

WCHAR awchSlashStar[] = L"\\*";
CHAR achSlashStar[] = "\\*";

PSERVERINFO gpsi;
SHAREDINFO gSharedInfo;
HMODULE hmodUser;               // USER.DLL's hmodule
ULONG_PTR gHighestUserAddress;

BOOL gfServerProcess;           // USER is linked on the CSR server side
BOOL gfSystemInitialized;       // System has been initialized

ACCESS_MASK gamWinSta;          // ACCESS_MASK for the current WindowStation

PVOID pUserHeap;

WCHAR szUSER32[] = TEXT("USER32");
CONST WCHAR szNull[2] = { TEXT('\0'), TEXT('\015') };
CONST WCHAR szOneChar[] = TEXT("0");
WCHAR szSLASHSTARDOTSTAR[] = TEXT("\\*");  /* This is a single "\"  */

LPWSTR pwcHighContrastScheme;
LPSTR  pcHighContrastScheme;

/* Maps MessageBox type to number of buttons in the MessageBox */
CONST BYTE mpTypeCcmd[] = { 1, 2, 3, 3, 2, 2, 3 };

/* Maps MessageBox type to index into SEBbuttons array */
CONST BYTE mpTypeIich[] = { 0, 2, 5, 12, 9, 16, 19 };

CONST UINT SEBbuttons[] = {
    SEB_OK, SEB_HELP,
    SEB_OK, SEB_CANCEL, SEB_HELP,
    SEB_ABORT, SEB_RETRY, SEB_IGNORE, SEB_HELP,
    SEB_YES, SEB_NO, SEB_HELP,
    SEB_YES, SEB_NO, SEB_CANCEL, SEB_HELP,
    SEB_RETRY, SEB_CANCEL, SEB_HELP,
    SEB_CANCEL, SEB_TRYAGAIN, SEB_CONTINUE, SEB_HELP,
};

ATOM atomMDIActivateProp;

#ifdef LAME_BUTTON
ATOM gatomLameButton;
#endif

CRITICAL_SECTION gcsLookaside;
CRITICAL_SECTION gcsHdc;
CRITICAL_SECTION gcsClipboard;
CRITICAL_SECTION gcsAccelCache;

#ifdef _JANUS_
BOOL gfEMIEnable;
DWORD gdwEMIControl;
BOOL gfDMREnable;
HANDLE gEventSource;
#endif

HDC    ghdcBits2;
HDC    ghdcGray;
HFONT  ghFontSys;
HBRUSH ghbrWindowText;
int    gcxGray;
int    gcyGray;

FPLPKTABBEDTEXTOUT fpLpkTabbedTextOut = UserLpkTabbedTextOut;
FPLPKPSMTEXTOUT fpLpkPSMTextOut       = UserLpkPSMTextOut;
FPLPKDRAWTEXTEX fpLpkDrawTextEx       = (FPLPKDRAWTEXTEX)NULL;
PLPKEDITCALLOUT fpLpkEditControl      = (PLPKEDITCALLOUT)NULL;

/*
 * These are the resource call procedure addresses. If WOW is running,
 * it makes a call to set all these up to point to it. If it isn't
 * running, it defaults to the values you see below.
 */
PFNFINDA pfnFindResourceExA; // Assigned dynamically - _declspec (PFNFINDA)FindResourceExA,
PFNFINDW pfnFindResourceExW; // Assigned dynamically - _declspec (PFNFINDW)FindResourceExW,
PFNLOAD pfnLoadResource; // Assigned dynamically - _declspec (PFNLOAD)LoadResource,
PFNLOCK pfnLockResource             = (PFNLOCK)_LockResource;
PFNUNLOCK pfnUnlockResource         = (PFNUNLOCK)_UnlockResource;
PFNFREE pfnFreeResource             = (PFNFREE)_FreeResource;
PFNSIZEOF pfnSizeofResource; // Assigned dynamically - _declspec (PFNSIZEOF)SizeofResource
PFNLALLOC pfnLocalAlloc             = (PFNLALLOC)DispatchLocalAlloc;
PFNLREALLOC pfnLocalReAlloc         = (PFNLREALLOC)DispatchLocalReAlloc;
PFNLLOCK pfnLocalLock               = (PFNLLOCK)DispatchLocalLock;
PFNLUNLOCK pfnLocalUnlock           = (PFNUNLOCK)DispatchLocalUnlock;
PFNLSIZE pfnLocalSize               = (PFNLSIZE)DispatchLocalSize;
PFNLFREE pfnLocalFree               = (PFNLFREE)DispatchLocalFree;
PFNGETEXPWINVER pfnGetExpWinVer     = RtlGetExpWinVer;
PFN16GALLOC pfn16GlobalAlloc;
PFN16GFREE pfn16GlobalFree;
PFNEMPTYCB pfnWowEmptyClipBoard;
PFNWOWWNDPROCEX  pfnWowWndProcEx;
PFNWOWDLGPROCEX  pfnWowDlgProcEx;
PFNWOWEDITNEXTWORD   pfnWowEditNextWord;
PFNWOWCBSTOREHANDLE pfnWowCBStoreHandle;
PFNGETPROCMODULE16  pfnWowGetProcModule;
PFNWOWTELLWOWTHEHDLG pfnWOWTellWOWThehDlg;
PFNWOWMSGBOXINDIRECTCALLBACK pfnWowMsgBoxIndirectCallback;
PFNWOWILSTRCMP  pfnWowIlstrcmp;
PFNWOWTASK16SCHEDNOTIFY pfnWowTask16SchedNotify;

/*
 * UserApiHook
 *
 * It is important to keep guah initialization in sync with ResetUserApiHook()
 * and the definition of USERAPIHOOK. This initialization must be done here
 * so that the function pointers are valid immediately on startup.
 */
BYTE grgbDwpLiteHookMsg[(WM_USER + 7) / 8];
BYTE grgbWndLiteHookMsg[(WM_USER + 7) / 8];
BYTE grgbDlgLiteHookMsg[(WM_USER + 7) / 8];

HMODULE ghmodUserApiHook;
USERAPIHOOK guah =
{
    sizeof(USERAPIHOOK),
    RealDefWindowProcA,
    RealDefWindowProcW,
    {
        NULL,
        0
    },
    RealGetScrollInfo,
    RealSetScrollInfo,
    RealEnableScrollBar,
    RealAdjustWindowRectEx,
    RealSetWindowRgn,
    {
        DefaultOWP,
        DefaultOWP,
        NULL,
        0
    },
    {
        DefaultOWP,
        DefaultOWP,
        NULL,
        0
    },
    RealGetSystemMetrics,
    RealSystemParametersInfoA,
    RealSystemParametersInfoW,
    ForceResetUserApiHook,
    RealDrawFrameControl,
    RealDrawCaption,
    RealMDIRedrawFrame
};
BOOL    gfUserApiHook;
LONG    gcCallUserApiHook;
LONG    gcLoadUserApiHook;
RTL_CRITICAL_SECTION gcsUserApiHook;
INITUSERAPIHOOK      gpfnInitUserApi;

#ifdef MESSAGE_PUMP_HOOK

/*
 * MessagePumpHook
 */
BOOL                gfMessagePumpHook;
LONG                gcLoadMPH;
MESSAGEPUMPHOOK     gmph =
{
    sizeof(gmph),
    NtUserRealInternalGetMessage,
    NtUserRealWaitMessageEx,
    RealGetQueueStatus,
    RealMsgWaitForMultipleObjectsEx,
};
RTL_CRITICAL_SECTION gcsMPH;
INITMESSAGEPUMPHOOK  gpfnInitMPH;

#if TEST_DUSER_WMH
HDCONTEXT g_hctx = NULL;           // DirectUser Context
#endif // TEST_DUSER_WMH

#endif // MESSAGE_PUMP_HOOK


/*
 * Menu Drag and Drop
 */
HINSTANCE ghinstOLE;
FARPROC gpfnOLEOleUninitialize;
FARPROC gpfnOLERegisterDD;
FARPROC gpfnOLERevokeDD;
FARPROC gpfnOLEDoDD;

/*
 * Accelerator table resources list.
 */
PACCELCACHE gpac;

/*
 * IME Window Handling.
 */
DWORD gfConIme = UNKNOWN_CONIME;

/*
 * Used for TS Services Message Box handling
 */
FARPROC     gfnWinStationSendMessageW;
HINSTANCE   ghinstWinStaDll;

/*
 * Are we winlogon?
 */
BOOL gfLogonProcess;

#if DBG
USERDBGGLOBALS gDbgGlobals;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\clmsg.c ===
/****************************** Module Header ******************************\
* Module Name: ClMsg.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Includes the mapping table for messages when calling the server.
*
* 04-11-91 ScottLu Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define fnINDESTROYCLIPBRD      fnDWORD
#define fnOUTDWORDDWORD         fnDWORD
#define fnPOWERBROADCAST        fnDWORD
#define fnLOGONNOTIFY           fnKERNELONLY
#define fnINLPKDRAWSWITCHWND    fnKERNELONLY

#define MSGFN(func) fn ## func
#define FNSCSENDMESSAGE CFNSCSENDMESSAGE

#include "messages.h"

#if DBG
BOOL gfTurboDWP = TRUE;
#endif

#define BEGIN_CALLWINPROC(fInsideHook, lRet)                            \
    PCLIENTTHREADINFO pcti = GetClientInfo()->pClientThreadInfo;        \
    BOOL fCallBack = ((pcti!=NULL) &&                                   \
             TEST_BOOL_FLAG(pcti->CTIF_flags, CTIF_INCALLBACKMESSAGE)); \
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame \
        = {                                                             \
            sizeof(ActivationFrame),                                    \
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER \
        };                                                              \
    fInsideHook = FALSE;                                                \
                                                                        \
    if (!fCallBack) {                                                   \
        RtlActivateActivationContextUnsafeFast(                         \
            &ActivationFrame,                                           \
            pActCtx);                                                   \
                                                                        \
        fInsideHook = _BeginIfHookedUserApiHook();                      \
    }                                                                   \
                                                                        \
    __try {                                                             \

#define END_CALLWINPROC(fInsideHook)                                    \
    } __finally {                                                       \
        if (!fCallBack) {                                               \
            if (fInsideHook) {                                          \
                _EndUserApiHook();                                      \
            }                                                           \
            RtlDeactivateActivationContextUnsafeFast(                   \
                &ActivationFrame);                                      \
        }                                                               \
    }


/***************************************************************************\
* UserCallWinProc
*
* Setups everything to finally call a Win32 WNDPROC
*
* History:
* 27-Apr-2000  jstall     Rewrote to support "lightweight hooks"
\***************************************************************************/

LRESULT
UserCallWinProc(
    PACTIVATION_CONTEXT pActCtx,
    WNDPROC pfn,
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fInsideHook;
    LRESULT lRet = 0;

    BEGIN_CALLWINPROC(fInsideHook, lRet)
        BOOL fOverride = fInsideHook && IsMsgOverride(msg, &guah.uoiWnd.mm);

        pfn = MapKernelClientFnToClientFn(pfn);

        if (fOverride) {
            /*
             * NOTE: It is important that the same lRet is passed to all three
             * calls, allowing the Before and After OWP's to examine the value.
             */
            PVOID pvCookie = NULL;
            if (!guah.uoiWnd.pfnBeforeOWP(hwnd, msg, wParam, lParam, &lRet, &pvCookie)) {
                lRet = InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn),
                                           hwnd,
                                           msg,
                                           wParam,
                                           lParam);
                guah.uoiWnd.pfnAfterOWP(hwnd, msg, wParam, lParam, &lRet, &pvCookie);
            }
        } else {
            lRet = InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn),
                                       hwnd,
                                       msg,
                                       wParam,
                                       lParam);
        }
    END_CALLWINPROC(fInsideHook)

    return lRet;
}


/***************************************************************************\
* UserCallWinProcCheckWow
*
* Sets up everything to finally call a Win32 or WOW WNDPROC.
*
* History:
* 27-Apr-2000  jstall     Rewrote to support "lightweight hooks"
\***************************************************************************/

LRESULT
UserCallWinProcCheckWow(
    PACTIVATION_CONTEXT pActCtx,
    WNDPROC pfn,
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    PVOID pww,
    BOOL fEnableLiteHooks)
{
    BOOL fInsideHook;
    LRESULT lRet = 0;

    BEGIN_CALLWINPROC(fInsideHook, lRet)

        BOOL fOverride = fInsideHook && fEnableLiteHooks && IsMsgOverride(msg, &guah.uoiWnd.mm);

        pfn = MapKernelClientFnToClientFn(pfn);

        if (fOverride) {
            /*
             * NOTE: It is important that the same lRet is passed to all three
             * calls, allowing the Before and After OWP's to examine the value.
             */
            void * pvCookie = NULL;
            if (guah.uoiWnd.pfnBeforeOWP(hwnd, msg, wParam, lParam, &lRet, &pvCookie)) {
                goto DoneCalls;
            }

            lRet = (IsWOWProc(pfn) ? (*pfnWowWndProcEx)(hwnd, msg, wParam, lParam, PtrToUlong(pfn), KPVOID_TO_PVOID(pww)) :
                InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn), hwnd, msg, wParam, lParam));

            if (guah.uoiWnd.pfnAfterOWP(hwnd, msg, wParam, lParam, &lRet, &pvCookie)) {
                // Fall through and exit normally
            }
DoneCalls:
            ;
        } else {
            lRet = (IsWOWProc(pfn) ? (*pfnWowWndProcEx)(hwnd, msg, wParam, lParam, PtrToUlong(pfn), KPVOID_TO_PVOID(pww)) :
                InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn), hwnd, msg, wParam, lParam));
        }
    END_CALLWINPROC(fInsideHook)

    return lRet;
#ifdef _WIN64
    UNREFERENCED_PARAMETER(pww);
#endif // _WIN64
}


/***************************************************************************\
* UserCallDlgProcCheckWow
*
* Setups everything to finally call a Win32 or WOW DLGPROC
*
* History:
* 27-Apr-2000  jstall     Rewrote to support "lightweight hooks"
\***************************************************************************/

BOOL
UserCallDlgProcCheckWow(
    PACTIVATION_CONTEXT pActCtx,
    DLGPROC pfn,
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    PVOID pww,
    INT_PTR * pret)
{
    BOOL fInsideHook;
    INT_PTR fRet = 0;
    BOOL fHandled = FALSE;

    BEGIN_CALLWINPROC(fInsideHook, fRet)

        BOOL fOverride = fInsideHook && IsMsgOverride(msg, &guah.uoiDlg.mm);

        pfn = MapKernelClientFnToClientFn(pfn);

        if (fOverride) {
            /*
             * NOTE: It is important that the same lRet is passed to all three
             * calls, allowing the Before and After OWP's to examine the value.
             */
            void * pvCookie = NULL;
            if (guah.uoiDlg.pfnBeforeOWP(hwnd, msg, wParam, lParam, (LRESULT*) &fRet, &pvCookie)) {
                fHandled = TRUE;
                goto DoneCalls;
            }

            fRet = (IsWOWProc(pfn) ? (*pfnWowDlgProcEx)(hwnd, msg, wParam, lParam, PtrToUlong(pfn), KPVOID_TO_PVOID(pww)) :
                InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn), hwnd, msg, wParam, lParam));

            if (guah.uoiDlg.pfnAfterOWP(hwnd, msg, wParam, lParam, (LRESULT*) &fRet, &pvCookie)) {
                fHandled = TRUE;
                // Fall through and exit normally
            }
DoneCalls:
            ;
        } else {
            fRet = (IsWOWProc(pfn) ? (*pfnWowDlgProcEx)(hwnd, msg, wParam, lParam, PtrToUlong(pfn), KPVOID_TO_PVOID(pww)) :
                InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn), hwnd, msg, wParam, lParam));
        }

    END_CALLWINPROC(fInsideHook)

    *pret = fRet;

    return fHandled;
#ifdef _WIN64
    UNREFERENCED_PARAMETER(pww);
#endif // _WIN64
}


/***************************************************************************\
* GetMouseKeyState
*
* Returns the state of mouse and keyboard keys that are sent
* in a mouse message.
*
* History:
* 12-Nov-1998 adams     Created.
\***************************************************************************/

WORD
GetMouseKeyState(void)
{
    WORD keystate;

    /*
     * Note that it is more efficient to call GetKeyState for each
     * key than to call GetKeyboardState, since the keys we are testing
     * are cached and don't require a trip to the kernel to fetch.
     */

#define TESTANDSETKEYSTATE(x)            \
    if (GetKeyState(VK_##x) & 0x8000) {  \
        keystate |= MK_##x;              \
    }

    keystate = 0;
    TESTANDSETKEYSTATE(LBUTTON)
    TESTANDSETKEYSTATE(RBUTTON)
    TESTANDSETKEYSTATE(MBUTTON)
    TESTANDSETKEYSTATE(XBUTTON1)
    TESTANDSETKEYSTATE(XBUTTON2)
    TESTANDSETKEYSTATE(SHIFT)
    TESTANDSETKEYSTATE(CONTROL)

    return keystate;
}

/***************************************************************************\
* These are client side thunks for server side window procs. This is being
* done so that when an app gets a wndproc via GetWindowLong, GetClassLong,
* or GetClassInfo, it gets a real callable address - some apps don't call
* CallWindowProc, but call the return ed address directly.
*
* 01-13-92 ScottLu Created.
* 03-Dec-1993 mikeke  added client side handling of some messages
\***************************************************************************/

LRESULT WINAPI DesktopWndProcWorker(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    PWND pwnd;

    if (FWINDOWMSG(message, FNID_DESKTOP)) {
        return CsSendMessage(hwnd, message, wParam, lParam,
                0L, FNID_DESKTOP, fAnsi);
    }

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);

}

LRESULT WINAPI DesktopWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DesktopWndProcWorker(hwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI DesktopWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DesktopWndProcWorker(hwnd, message, wParam, lParam, FALSE);
}

/***************************************************************************\
* These are client side thunks for server side window procs. This is being
* done so that when an app gets a wndproc via GetWindowLong, GetClassLong,
* or GetClassInfo, it gets a real callable address - some apps don't call
* CallWindowProc, but call the return ed address directly.
*
* 01-13-92 ScottLu Created.
* 03-Dec-1993 mikeke  added client side handling of some messages
\***************************************************************************/

LRESULT WINAPI MenuWndProcWorker(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    PWND pwnd;

    if (FWINDOWMSG(message, FNID_MENU)) {
        return CsSendMessage(hwnd, message, wParam, lParam,
                0L, FNID_MENU, fAnsi);
    }

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    switch (message) {
    case WM_LBUTTONDBLCLK:
    case WM_NCLBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_NCRBUTTONDBLCLK:

        /*
         * Ignore double clicks on these windows.
         */
        break;

    case WM_DESTROY:
        break;

    default:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }

    return 0;
}

LRESULT WINAPI MenuWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return MenuWndProcWorker(hwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI MenuWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return MenuWndProcWorker(hwnd, message, wParam, lParam, FALSE);
}

/***************************************************************************\
\***************************************************************************/


LRESULT WINAPI ScrollBarWndProcWorker(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    PSBWND psbwnd;
    LPSCROLLINFO lpsi;
    PSBDATA pw;

    if (FWINDOWMSG(message, FNID_SCROLLBAR)) {
        return CsSendMessage(hwnd, message, wParam, lParam,
                0L, FNID_SCROLLBAR, fAnsi);
    }

    if ((psbwnd = (PSBWND)ValidateHwnd(hwnd)) == NULL)
        return 0;

    switch (message) {
    case WM_GETDLGCODE:
        return DLGC_WANTARROWS;

    case SBM_GETPOS:
        return (LONG)psbwnd->SBCalc.pos;

    case SBM_GETRANGE:
        *((LPINT)wParam) = psbwnd->SBCalc.posMin;
        *((LPINT)lParam) = psbwnd->SBCalc.posMax;
        return 0;

    case SBM_GETSCROLLINFO:
        lpsi = (LPSCROLLINFO)lParam;
        if ((lpsi->cbSize != sizeof(SCROLLINFO)) &&
            (lpsi->cbSize != sizeof(SCROLLINFO) - 4)) {
            RIPMSG0(RIP_ERROR, "SCROLLINFO: invalid cbSize");
            return FALSE;
        }

        if (lpsi->fMask & ~SIF_MASK)
        {
            RIPMSG0(RIP_ERROR, "SCROLLINFO: Invalid fMask");
            return FALSE;
        }

        pw = (PSBDATA)KPSBDATA_TO_PSBDATA(&(psbwnd->SBCalc));
        return(NtUserSBGetParms(hwnd, SB_CTL, pw, lpsi));

    case SBM_GETSCROLLBARINFO:
        return NtUserGetScrollBarInfo(hwnd, OBJID_CLIENT, (PSCROLLBARINFO)lParam);

    default:
        return DefWindowProcWorker((PWND)psbwnd, message,
                wParam, lParam, fAnsi);
    }
}


LRESULT WINAPI ScrollBarWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return ScrollBarWndProcWorker(hwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI ScrollBarWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return ScrollBarWndProcWorker(hwnd, message, wParam, lParam, FALSE);
}


/***************************************************************************\
* SendMessage
*
* Translates the message, calls SendMessage on server side.
*
* 04-11-91 ScottLu  Created.
* 04-27-92 DarrinM  Added code to support client-to-client SendMessages.
\***************************************************************************/

LRESULT SendMessageWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    HWND hwnd = HWq(pwnd);
    PCLIENTINFO pci;
    PCLS pcls;
    BOOLEAN fAnsiRecv;
    BOOLEAN fNeedTranslation = FALSE;
    BOOLEAN bDoDbcsMessaging = FALSE;
    LRESULT lRet;

    UserAssert(pwnd);

    /*
     * Pass DDE messages to the server.
     */
    if (message >= WM_DDE_FIRST && message <= WM_DDE_LAST)
        goto lbServerSendMessage;

    /*
     * Server must handle inter-thread SendMessages and SendMessages
     * to server-side procs.
     */
    if ((PtiCurrent() != GETPTI(pwnd)) || TestWF(pwnd, WFSERVERSIDEPROC))
        goto lbServerSendMessage;

    /*
     * Server must handle hooks (at least for now).
     */
    pci = GetClientInfo();
    if (IsHooked(pci, (WHF_CALLWNDPROC | WHF_CALLWNDPROCRET))) {
lbServerSendMessage:
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                FNID_SENDMESSAGE, fAnsi);
    }

    /*
     * If the sender and the receiver are both ANSI or both UNICODE
     * then no message translation is necessary.
     *
     * EditWndProc may need to go to the server for translation if we
     * are calling vanilla EditWndProc from SendMessageA and the edit
     * control is currently subclassed Ansi but the edit control is
     * stored Unicode.
     */
    fAnsiRecv = !!(TestWF(pwnd, WFANSIPROC));
    if (!fAnsi != !fAnsiRecv) {

        /*
         * Translation might be necessary between sender and receiver,
         * check to see if this is one of the messages we translate.
         */
        switch (message) {
        case WM_CHARTOITEM:
        case EM_SETPASSWORDCHAR:
        case WM_CHAR:
        case WM_DEADCHAR:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
        case WM_MENUCHAR:
        case WM_IME_CHAR:
        case WM_IME_COMPOSITION:
            if (fAnsi) {
                /*
                 * Setup DBCS Messaging for WM_CHAR...
                 */
                BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_CLIENTA(message,wParam,TRUE);

                /*
                 * Convert wParam to Unicode...
                 */
                RtlMBMessageWParamCharToWCS(message, &wParam);

                /*
                 * The message has been converted to Unicode.
                 */
                fAnsi = FALSE;
            } else {
                POINT ptZero = {0,0};
                /*
                 * Convert wParam to ANSI...
                 */
                RtlWCSMessageWParamCharToMB(message, &wParam);

                /*
                 * Let's DBCS messaging for WM_CHAR....
                 */
                BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_CLIENTW(
                    hwnd,message,wParam,lParam,0,ptZero,bDoDbcsMessaging);

                /*
                 * The message has been converted to ANSI.
                 */
                fAnsi = TRUE;
            }
            break;

        case EM_SETSEL:
        case EM_GETSEL:
        case CB_GETEDITSEL:
            if (IS_DBCS_ENABLED()) {
                RIPERR1(ERROR_INVALID_PARAMETER,
                        RIP_WARNING,
                        "Invalid DBCS message (%x) to SendMessageWorker",message);
            }
            //
            // Fall down...

        default:
            if ((message < WM_USER) && MessageTable[message].bThunkMessage) {
                fNeedTranslation = TRUE;
            }
        }
    }

#ifndef LATER
    /*
     * If the window has a client side worker proc and has
     * not been subclassed, dispatch the message directly
     * to the worker proc.  Otherwise, dispatch it normally.
     */
    pcls = REBASEALWAYS(pwnd, pcls);

    if ((!IsInsideUserApiHook()) &&
        (pcls->fnid >= FNID_CONTROLSTART && pcls->fnid <= FNID_CONTROLEND) &&
        ((KERNEL_ULONG_PTR)pwnd->lpfnWndProc == FNID_TO_CLIENT_PFNW_KERNEL(pcls->fnid) ||
         (KERNEL_ULONG_PTR)pwnd->lpfnWndProc == FNID_TO_CLIENT_PFNA_KERNEL(pcls->fnid))) {
        PWNDMSG pwm = &gSharedInfo.awmControl[pcls->fnid - FNID_START];

        /*
         * If this message is not processed by the control, call
         * xxxDefWindowProc
         */
        if (pwm->abMsgs && ((message > pwm->maxMsgs) ||
                !((pwm->abMsgs)[message / 8] & (1 << (message & 7))))) {

            /*
             * Special case dialogs so that we can ignore unimportant
             * messages during dialog creation.
             */
            if (pcls->fnid == FNID_DIALOG &&
                    PDLG(pwnd) && PDLG(pwnd)->lpfnDlg != NULL) {
                /*
                 * If A/W translation are needed for Dialog,
                 * it should go to kernel side to perform proper message.
                 * DefDlgProcWorker will call aplication's DlgProc directly
                 * without A/W conversion.
                 */
                if (fNeedTranslation) {
                    goto lbServerSendMessage;
                }
                /*
                 * Call woker procudure.
                 */
            SendMessageToWorker1Again:
                lRet = ((PROC)(FNID_TO_CLIENT_PFNWORKER(pcls->fnid)))(pwnd, message, wParam, lParam, fAnsi);
                /*
                 * if we have DBCS TrailingByte that should be sent, send it here..
                 */
                DISPATCH_DBCS_MESSAGE_IF_EXIST(message,wParam,bDoDbcsMessaging,SendMessageToWorker1);

                return lRet;
            } else {
                /*
                 * Call worker procedure.
                 */
            SendMessageToDefWindowAgain:
                lRet = DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
                /*
                 * if we have DBCS TrailingByte that should be sent, send it here..
                 */
                 DISPATCH_DBCS_MESSAGE_IF_EXIST(message,wParam,bDoDbcsMessaging,SendMessageToDefWindow);

                return lRet;
            }
        } else {
            /*
             * Call woker procudure.
             */
        SendMessageToWorker2Again:
            lRet = ((PROC)(FNID_TO_CLIENT_PFNWORKER(pcls->fnid)))(pwnd, message, wParam, lParam, fAnsi);

            /*
             * if we have DBCS TrailingByte that should be sent, send it here..
             */
            DISPATCH_DBCS_MESSAGE_IF_EXIST(message,wParam,bDoDbcsMessaging,SendMessageToWorker2);

            return lRet;
        }
    }
#endif

    /*
     * If this message needs to be translated, go through the kernel.
     */
    if (fNeedTranslation) {
        goto lbServerSendMessage;
    }

    /*
     * Call Client Windows procudure.
     */
SendMessageToWndProcAgain:
    lRet = UserCallWinProcCheckWow(pwnd->pActCtx, (WNDPROC)pwnd->lpfnWndProc, hwnd, message, wParam, lParam, &(pwnd->state), TRUE);

    /*
     * if we have DBCS TrailingByte that should be sent, send it here..
     */
    DISPATCH_DBCS_MESSAGE_IF_EXIST(message,wParam,bDoDbcsMessaging,SendMessageToWndProc);

    return lRet;
}

// LATER!!! can this somehow be combined or subroutinized with SendMessageWork
// so we don't have to copies of 95% identical code.

/***************************************************************************\
* SendMessageTimeoutWorker
*
* Translates the message, calls SendMessageTimeout on server side.
*
* 07-21-92 ChrisBB  Created/modified SendMessageWorkder
\***************************************************************************/

LRESULT SendMessageTimeoutWorker(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    PULONG_PTR lpdwResult,
    BOOL fAnsi)
{
    SNDMSGTIMEOUT smto;

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (message & RESERVED_MSG_BITS) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"message\" (%ld) to SendMessageTimeoutWorker",
                message);

        return(0);
    }

    if (fuFlags & ~SMTO_VALID) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid dwFlags (%x) for SendMessageTimeout\n", fuFlags);
        return(0);
    }

    if (lpdwResult != NULL)
        *lpdwResult = 0L;

    /*
     * Always send broadcast requests straight to the server.
     * Note: the xParam is used to id if it's from timeout or
     * from an normal sendmessage.
     */
    smto.fuFlags = fuFlags;
    smto.uTimeout = uTimeout;
    smto.lSMTOReturn = 0;
    smto.lSMTOResult = 0;

    /*
     * Thunk through a special sendmessage for -1 hwnd's so that the general
     * purpose thunks don't allow -1 hwnd's.
     */
    if (hwnd == (HWND)-1 || hwnd == (HWND)0x0000FFFF) {
        /*
         * Get a real hwnd so the thunks will validation ok. Note that since
         * -1 hwnd is really rare, calling GetDesktopWindow() here is not a
         * big deal.
         */
        hwnd = GetDesktopWindow();

        CsSendMessage(hwnd, message, wParam, lParam,
                (ULONG_PTR)&smto, FNID_SENDMESSAGEFF, fAnsi);
    } else {
        CsSendMessage(hwnd, message, wParam, lParam,
                (ULONG_PTR)&smto, FNID_SENDMESSAGEEX, fAnsi);
    }

    if (lpdwResult != NULL)
         *lpdwResult = smto.lSMTOResult;

    return smto.lSMTOReturn;
}

#ifdef LAME_BUTTON

PLAMEBTNPROC gpfnCommentReport;

VOID LoadCommentReportIfNeeded(
    VOID)
{
    if (gpfnCommentReport == NULL) {
        HMODULE hmod = LoadLibrary(L"LAMEBTN.DLL");

        if (hmod != NULL) {
            gpfnCommentReport = (PLAMEBTNPROC)GetProcAddress(hmod, "CommentReport");
            if (gpfnCommentReport == NULL) {
                FreeLibrary(hmod);
            }
        }
    }
}

VOID CallLameButtonHandler(
    PWND pwnd,
    HWND hwnd)
{
    UNREFERENCED_PARAMETER(pwnd);

    UserAssert(TestWF(pwnd, WEFLAMEBUTTON));

    LoadCommentReportIfNeeded();

    if (gpfnCommentReport != NULL) {
        (*gpfnCommentReport)(hwnd, GetProp(hwnd, MAKEINTATOM(gatomLameButton)));
    }
}
#endif // LAME_BUTTON

VOID CopyMsgMask(
    MSGMASK * pDest,
    MSGMASK * pSrc,
    BYTE * rgbLocal,
    DWORD cbMax)
{
    if ((pSrc->rgb != NULL) && (pSrc->cb > 0)) {
        pDest->rgb = rgbLocal;
        pDest->cb  = min(cbMax, pSrc->cb);
        CopyMemory(pDest->rgb, pSrc->rgb, pDest->cb);
    } else {
        pDest->rgb = NULL;
        pDest->cb  = 0;
    }
}


/***************************************************************************\
* InitUserApiHook
*
* This function gets called when the module that contains the UserApiHook's
* gets loaded. The UserApiHook is installed by calling
* RegisterUserApiHook and is loaded on demand by xxxCreateWindowEx and/or
* xxxDefWindowProc. The loading/unloading is controlled through the library
* management routines. The function calls the initialization function in the
* module and then sets up our global variables.
*
* We keep 2 reference counts. One counts calls to LoadLibrary/FreeLibrary. When
* this goes to zero, we can stop calling out to the substitute UserApiHook's.
* The other gets incremented when we do an actual callout to the substitute
* UserApiHook and decremented on return. We can't actually unload the module
* until this count goes to zero too (i.e. we aren't in a callout).
*
* History:
* 10-Mar-2000 JerrySh   Created.
* 16-May-2000 JStall    Changed to support uninitialize callback
* 12-Feb-2001 Mohamed   Added the check for read-only on reset ptr.
\***************************************************************************/
BOOL InitUserApiHook(
    HMODULE hmod,
    ULONG_PTR offPfnInitUserApiHook)
{
    INITUSERAPIHOOK pfnInitUserApi = NULL;
    USERAPIHOOK uahTemp;

    BOOL bUpdate= FALSE;
    BOOL retval = FALSE;

    /*
     * If we're loading for the first time, call the initialization routine.
     */
    ResetUserApiHook(&uahTemp);
    pfnInitUserApi = (INITUSERAPIHOOK)((ULONG_PTR)hmod + offPfnInitUserApiHook);
    bUpdate = pfnInitUserApi(UIAH_INITIALIZE, &uahTemp);

    /*
     * Check that the value of pfnForceResetUserApiHook hasn't been changed
     * by client since this should be treated as read-only.
     */
    if ((!bUpdate) || (uahTemp.cbSize <= 0) || (uahTemp.pfnForceResetUserApiHook != ForceResetUserApiHook)) {
        return FALSE;
    }

    RtlEnterCriticalSection(&gcsUserApiHook);

    /*
     * Need to check this again inside critical section.
     */
    if (ghmodUserApiHook == NULL) {
        UserAssertMsg0(gpfnInitUserApi == NULL, "Ensure gpfnInitUserApi not set");

        /*
         * Save the global state if the init routine succeeded.
         * Copy the hooked functions
         */
        UserAssert(gcLoadUserApiHook == 0);
        gcLoadUserApiHook   = 1;
        gfUserApiHook       = TRUE;     // Turn calling the hooks on
        ghmodUserApiHook    = hmod;
        gpfnInitUserApi     = pfnInitUserApi;

        CopyMemory(&guah, &uahTemp, uahTemp.cbSize);

        /*
         * Copy the message-filter bit-mask
         */
        CopyMsgMask(&guah.mmDWP, &uahTemp.mmDWP, grgbDwpLiteHookMsg, sizeof(grgbDwpLiteHookMsg));
        CopyMsgMask(&guah.uoiWnd.mm, &uahTemp.uoiWnd.mm, grgbWndLiteHookMsg, sizeof(grgbWndLiteHookMsg));
        CopyMsgMask(&guah.uoiDlg.mm, &uahTemp.uoiDlg.mm, grgbDlgLiteHookMsg, sizeof(grgbDlgLiteHookMsg));

        retval = TRUE;
    } else if (ghmodUserApiHook == hmod) {
        /*
         * This is the UserApiHook module, so bump up the reference count.
         */
        UserAssert(gcLoadUserApiHook < MAXLONG);
        UserAssertMsg0(gpfnInitUserApi == pfnInitUserApi, "Need to match from before");
        ++gcLoadUserApiHook;
        retval = TRUE;
    }

    RtlLeaveCriticalSection(&gcsUserApiHook);

    if (!retval) {
        /*
         * Initialization failed, so ClientLoadLibrary() is going to
         * FreeLibrary().  Notify before we do this.
         */
        RIPMSG2(RIP_WARNING, "Uninit from Init Load %lx Call %lx", gcLoadUserApiHook, gcCallUserApiHook);
        pfnInitUserApi(UIAH_UNINITIALIZE, NULL);
    }

    return retval;
}

/***************************************************************************\
* ClearUserApiHook
*
* This function gets called when the module that contains the UserApiHook
* is about to get unloaded. The unload happens when UnregisterUserApiHook
* is called or the process that registered it exits. If this is the last unload,
* we'll clear the globals containing the UserApiHook function addresses so we
* don't do any more callouts. If we're not currently doing a callout, we'll
* indicate that it's OK to unload the module. Otherwise, it'll get unloaded
* when the last callout completes.
*
* History:
* 10-Mar-2000 JerrySh   Created.
* 16-May-2000 JStall    Changed to support uninitialize callback
* 03-Apr-2001 Mohamed   Added support for UIAH_UNHOOK logic.
\***************************************************************************/
BOOL ClearUserApiHook(
    HMODULE hmod)
{
    INITUSERAPIHOOK pfnInitUserApi = NULL;
    INITUSERAPIHOOK pfnSignalInitUserApi = NULL;

    /*
     * If this is the last reference to the UserApiHook module, clear the
     * global state.
     */
    RtlEnterCriticalSection(&gcsUserApiHook);
    if (ghmodUserApiHook == hmod) {
        UserAssert(gcLoadUserApiHook > 0);
        UserAssertMsg0(gpfnInitUserApi != NULL, "Ensure gpfnInitUserApi properly set");
        UserAssertMsg0(ghmodUserApiHook != NULL, "Should still have valid ghmodUserApiHook");
        pfnInitUserApi = gpfnInitUserApi;

        if (--gcLoadUserApiHook == 0) {
            /*
             * Use the internal functions, so turn calling the hooks off.  It is
             * very important to set gfUserApiHook FALSE here so that new calls
             * do not increment gcCallUserApiHook and keep the DLL from being
             * unloaded.
             */
            gfUserApiHook = FALSE;
            ResetUserApiHook(&guah);

            if (gcCallUserApiHook == 0) {
                /*
                 * We're not calling into it, we can free the module.
                 *
                 * FreeLibrary() will be called on this DLL in
                 * ClientFreeLibrary() when this function returns.
                 */
                hmod = ghmodUserApiHook;
                ghmodUserApiHook = NULL;
                gpfnInitUserApi = NULL;
            } else {
                /*
                 * We're still calling into the module, so we can't free it yet.
                 * This means we have to delay the last callback with UIAH_UNINITIALIZE
                 * until we actually free the library.  This will occur in
                 * _EndUserApiHook().  However, we set pfnSignalInitUserApi to initiate
                 * a callback with UIAH_UNHOOK to alert the module to this fact.
                 */
                hmod = NULL;
                pfnInitUserApi = NULL;
                pfnSignalInitUserApi = gpfnInitUserApi;
                ++gcLoadUserApiHook;
            }
        } else {
            /*
             * This part of code should never be executed since we guard against
             * multiple loads of same DLL in xxxLoadUserApiHook.  However, since
             * this is a load count and could conceivably be greater than 1,
             * this warning message is inserted to signal such an event.
             */
            RIPMSG1(RIP_WARNING, " gcLoadUserApiHook: %lx > 1 in Clear Load", gcLoadUserApiHook);
        }
    }

    RtlLeaveCriticalSection(&gcsUserApiHook);

    /*
     * Signal that hooks have been uninitialized but DLL can't be unloaded due to outstanding calls.
     */
    if (pfnSignalInitUserApi != NULL) {
        RIPMSG2(RIP_WARNING, "Unhook from Clear Load %lx Call %lx", gcLoadUserApiHook, gcCallUserApiHook);
        pfnSignalInitUserApi(UIAH_UNHOOK, NULL);

        /*
         * After having returned from the DLL, we revalidate the state of the hooking world again.
         * The outstanding call that we were deferring in favor of, could have completed by now
         * and finding the load count greater than zero, it ignored completing the deferred cleanup
         * which we must now do at this point.
         */
        RtlEnterCriticalSection(&gcsUserApiHook);
        UserAssert(gcLoadUserApiHook > 0);
        UserAssertMsg0(gpfnInitUserApi != NULL, "Ensure gpfnInitUserApi properly set");
        UserAssertMsg0(ghmodUserApiHook != NULL, "Should still have valid ghmodUserApiHook");
        pfnInitUserApi = gpfnInitUserApi;

        if (--gcLoadUserApiHook == 0) {
            if (gcCallUserApiHook == 0) {
                /*
                 * The outstanding call has completed while we were
                 * calling back and we can now safely clean up.
                 * FreeLibrary() will be called on this DLL in
                 * ClientFreeLibrary() when this function returns.
                 */
                hmod = ghmodUserApiHook;
                ghmodUserApiHook = NULL;
                gpfnInitUserApi = NULL;
            } else {
                /*
                 * The outstanding call into the DLL hasn't returned.  However, we are done
                 * from this point.  The DLL has been notified of UNHOOK situation and the
                 * rest of the cleanup will be done in _EndUserApiHook when the last call
                 * into the DLL returns.
                 */
                hmod = NULL;
                pfnInitUserApi = NULL;
            }
        } else {
            /*
             * This part of code should never be executed since we guard against
             * multiple loads of same DLL in xxxLoadUserApiHook.  However, since
             * this is a load count and could conceivably be greater than 1,
             * this warning message is inserted to signal such an event.
             */
            RIPMSG1(RIP_WARNING, " gcLoadUserApiHook: %lx > 1 in Clear Load", gcLoadUserApiHook);
        }
        RtlLeaveCriticalSection(&gcsUserApiHook);
    }

    /*
     * This is called in the case where the outstanding call into the DLL was completed in between
     * the two critical sections and we have completed the full cleanup at this end.
     */
    if (pfnInitUserApi != NULL) {
        RIPMSG2(RIP_WARNING, "Uninit from Clear Load %lx Call %lx", gcLoadUserApiHook, gcCallUserApiHook);
        pfnInitUserApi(UIAH_UNINITIALIZE, NULL);
    }

    return (hmod != NULL);
}


/***************************************************************************\
* DefaultOWP
*
* This function provides an empty OWP implementation that can be safely
* called while the UserApiHook DLL is being unloaded and we are resetting
* the states.
*
* History:
* 27-Apr-2000 JStall   Created.
\***************************************************************************/
BOOL CALLBACK DefaultOWP(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT * pr, void ** pvCookie)
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(pr);
    UNREFERENCED_PARAMETER(pvCookie);

    return FALSE;
}


/***************************************************************************\
* MDIRedrawFrame
*
*
* History:
* 20-Apr-2001 Mohamed Created.
\***************************************************************************/
void MDIRedrawFrame(
    HWND hwndChild,
    BOOL fAdd)
{
    BEGIN_USERAPIHOOK()
        guah.pfnMDIRedrawFrame(hwndChild, fAdd);
    END_USERAPIHOOK()
}

void RealMDIRedrawFrame(
    HWND hwndChild,
    BOOL fAdd)
{
    UNREFERENCED_PARAMETER(fAdd);
    NtUserRedrawFrame(hwndChild);
}


/***************************************************************************\
* ResetUserApiHook
*
* This function gets called to reset the UserApiHook function pointers to
* the internal (default) implementations of the functions.  This is done
* when any installed UserApiHook is being removed by calling
* UnregisterUserApiHook().
*
* History:
* 28-Mar-2000 JStall   Created.
* 28-Oct-2000 mohamed  Added GetSystemMetrics and SystemParametersInfo hooks.
\***************************************************************************/
void ResetUserApiHook(USERAPIHOOK * puah)
{
    puah->cbSize                   = sizeof(USERAPIHOOK);
    puah->pfnDefWindowProcA        = RealDefWindowProcA;
    puah->pfnDefWindowProcW        = RealDefWindowProcW;
    puah->mmDWP.rgb                = NULL;
    puah->mmDWP.cb                 = 0;
    puah->pfnGetScrollInfo         = RealGetScrollInfo;
    puah->pfnSetScrollInfo         = RealSetScrollInfo;
    puah->pfnEnableScrollBar       = RealEnableScrollBar;
    puah->pfnAdjustWindowRectEx    = RealAdjustWindowRectEx;
    puah->pfnSetWindowRgn          = RealSetWindowRgn;
    puah->uoiWnd.pfnBeforeOWP      = DefaultOWP;
    puah->uoiWnd.pfnAfterOWP       = DefaultOWP;
    puah->uoiWnd.mm.rgb            = NULL;
    puah->uoiWnd.mm.cb             = 0;
    puah->uoiDlg.pfnBeforeOWP      = DefaultOWP;
    puah->uoiDlg.pfnAfterOWP       = DefaultOWP;
    puah->uoiDlg.mm.rgb            = NULL;
    puah->uoiDlg.mm.cb             = 0;
    puah->pfnGetSystemMetrics      = RealGetSystemMetrics;
    puah->pfnSystemParametersInfoA = RealSystemParametersInfoA;
    puah->pfnSystemParametersInfoW = RealSystemParametersInfoW;
    puah->pfnForceResetUserApiHook = ForceResetUserApiHook;
    puah->pfnDrawFrameControl      = RealDrawFrameControl;
    puah->pfnDrawCaption           = RealDrawCaption;
    puah->pfnMDIRedrawFrame        = RealMDIRedrawFrame;
}


/***************************************************************************\
* ForceResetUserApiHook
*
* NOTE : This is an API function that is called by external clients.
*
* This function gets called to force a reset of the UserApiHook function
* pointers.  This is done usually by the hooked DLL in the case when it is
* about to be unloaded by anyone other than WindowManager and is done to
* prevent future calls into that DLL.  It is to be noted however, that
* WindowManger still believes that it is hooked
*
*  Note:
*        1- This function is meant to be called only by hooking dll inside
*           DllMain when recieving a DLL_PROCESS_DETACH message.  A check is
*           made on the LoaderLock to verify.
*        2- No serialization is done based on the assumption that the call
*           is made during DLL_PROCESS_DETACH and hence there is only the
*           main thread.
*
* History:
* 02-Feb-2001 mohamed  Created.
\***************************************************************************/
BOOL
ForceResetUserApiHook(
    HMODULE hmod)
{
    /*
     * Verify that the calling module is indeed the same hooking module and that
     * we are indeed being called from DllMain by verifying that we are inside
     * the loader lock.
     */

    if (ghmodUserApiHook != hmod || !RtlIsThreadWithinLoaderCallout()){
        return FALSE;
    }

    /*
     * Reset the function pointers back to Window Manager native functions and
     * reset the global dll initialization function pointer to prevent calls
     * into hooked dll with un\initialization messages.
     */

    ResetUserApiHook(&guah);
    gpfnInitUserApi = NULL;
    return TRUE;
}


/***************************************************************************\
* _EndUserApiHook
*
* This function gets called after each hooked API function call from
* END_USERAPIHOOK().  This provides a common place to clean up resources
* that were delayed because they were in use during the hooked function
* call.
*
* History:
* 28-Mar-2000 JStall    Created.
* 16-May-2000 JStall    Changed to support uninitialize callback
\***************************************************************************/
void _EndUserApiHook()
{
    UserAssert(gcCallUserApiHook > 0);
    if (InterlockedDecrement(&gcCallUserApiHook) == 0) {
        /*
         * If the load count went to zero, free the library.
         */
        if (gcLoadUserApiHook == 0) {
            HMODULE hmod = NULL;
            INITUSERAPIHOOK pfnInitUserApi = NULL;

            RtlEnterCriticalSection(&gcsUserApiHook);
            if (gcLoadUserApiHook == 0) {
                UserAssertMsg0(ghmodUserApiHook != NULL, "Should still have valid ghmodUserApiHook");
                UserAssertMsg0(gpfnInitUserApi != NULL, "Should still have valid gpfnInitUserApi");

                hmod                = ghmodUserApiHook;
                pfnInitUserApi      = gpfnInitUserApi;
                ghmodUserApiHook    = NULL;
                gpfnInitUserApi     = NULL;
            }

            RtlLeaveCriticalSection(&gcsUserApiHook);

            /*
             * Make the callback that we delayed from ClearUserApiHook()
             * because there was still an outstanding API call.
             */
            if (pfnInitUserApi != NULL) {
                RIPMSG2(RIP_WARNING, "Uninit from End Load %lx Call %lx", gcLoadUserApiHook, gcCallUserApiHook);
                pfnInitUserApi(UIAH_UNINITIALIZE, NULL);
            }

            if (hmod != NULL) {
                FreeLibrary(hmod);
            }
        }
    }
}

/***************************************************************************\
* DefWindowProcWorker
*
* Handles any messages that can be dealt with wholly on the client and
* passes the rest to the server.
*
* 03-31-92 DarrinM      Created.
\***************************************************************************/

LRESULT DefWindowProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    if (ghmodUserApiHook) {
        if (fAnsi) {
            return DefWindowProcA(HWq(pwnd), message, wParam, lParam);
        } else {
            return DefWindowProcW(HWq(pwnd), message, wParam, lParam);
        }
    }
    return RealDefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
}

LRESULT RealDefWindowProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    int icolBack;
    int icolFore;
    PWND pwndParent;
    HWND hwndDefIme;
    PWND pwndDefIme;
    PIMEUI pimeui;

#if DBG
    if (!gfTurboDWP) {
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                FNID_DEFWINDOWPROC, fAnsi);
    } else {
#endif

    if (FDEFWINDOWMSG(message, DefWindowMsgs)) {
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                FNID_DEFWINDOWPROC, fAnsi);
    } else if (!FDEFWINDOWMSG(message, DefWindowSpecMsgs)) {
        return 0;
    }

    /*
     * Important:  If you add cases to the switch statement below,
     *             add the messages to server.c's gawDefWindowSpecMsgs.
     *             Similarly if you add cases to dwp.c's DefWindowProc
     *             which can come from the client, add the messages
     *             to gawDefWindowMsgs.
     */

    switch (message) {
#ifdef LAME_BUTTON
    case WM_NCLBUTTONDOWN:
        if (wParam == HTLAMEBUTTON && TestWF(pwnd, WEFLAMEBUTTON)) {
            CallLameButtonHandler(pwnd, hwnd);
        }
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                   FNID_DEFWINDOWPROC, fAnsi);

    case WM_SYSCHAR:
        if (wParam == LAMEBUTTONHOTKEY && (HIWORD(lParam) & SYS_ALTERNATE) &&
           TestWF(pwnd, WEFLAMEBUTTON)) {
           CallLameButtonHandler(pwnd, hwnd);
        }
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                   FNID_DEFWINDOWPROC, fAnsi);

    case WM_SYSCOMMAND:
        if (wParam == SC_LAMEBUTTON && TestWF(pwnd, WEFLAMEBUTTON)) {
            CallLameButtonHandler(pwnd, hwnd);
        }
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                   FNID_DEFWINDOWPROC, fAnsi);
#endif // LAME_BUTTON

    case WM_HELP:
        {
        PWND  pwndDest;

        /*
         * If this window is a child window, Help message must be passed on
         * to it's parent; Else, this must be passed on to the owner window.
         */
        pwndDest = (TestwndChild(pwnd) ? pwnd->spwndParent : pwnd->spwndOwner);
        if (pwndDest) {
            pwndDest = REBASEPTR(pwnd, pwndDest);
            if (pwndDest != _GetDesktopWindow())
                return SendMessageW(HWq(pwndDest), WM_HELP, wParam, lParam);;
        }
        return(0L);
        }

    case WM_MOUSEWHEEL:
        if (TestwndChild(pwnd)) {
            pwndParent = REBASEPWND(pwnd, spwndParent);
            SendMessageW(HW(pwndParent), WM_MOUSEWHEEL, wParam, lParam);
        }
        break;

    case WM_CONTEXTMENU:
        if (TestwndChild(pwnd)) {
            pwndParent = REBASEPWND(pwnd, spwndParent);
            SendMessageW(HW(pwndParent), WM_CONTEXTMENU,
                    (WPARAM)hwnd, lParam);
        }
        break;

    /*
     * Default handling for WM_CONTEXTMENU support
     */
    case WM_RBUTTONUP:
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            lParam = MAKELONG(pwnd->rcClient.right - GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) + pwnd->rcClient.top);
        } else {
            lParam = MAKELONG(GET_X_LPARAM(lParam) + pwnd->rcClient.left, GET_Y_LPARAM(lParam) + pwnd->rcClient.top);
        }
        SendMessageWorker(pwnd, WM_CONTEXTMENU, (WPARAM)hwnd, lParam, fAnsi);
        break;

    case WM_APPCOMMAND:
        if (TestwndChild(pwnd)) {
            /*
             * Bubble the message to the parent
             */
            pwndParent = REBASEPWND(pwnd, spwndParent);
            return SendMessageW(HW(pwndParent), WM_APPCOMMAND, wParam, lParam);
        } else {
            /*
             * Call the server side to send the shell hook HSHELL_APPCOMMAND
             */
            return CsSendMessage(hwnd, WM_APPCOMMAND, wParam, lParam, 0L, FNID_DEFWINDOWPROC, fAnsi);
        }
        break;

    /*
     * Default handling for WM_APPCOMMAND support
     */
    case WM_NCXBUTTONUP:
    case WM_XBUTTONUP:
        {
            WORD cmd;
            WORD keystate;
            LPARAM lParamAppCommand;

            switch (GET_XBUTTON_WPARAM(wParam)) {
            case XBUTTON1:
                cmd = APPCOMMAND_BROWSER_BACKWARD;
                break;

            case XBUTTON2:
                cmd = APPCOMMAND_BROWSER_FORWARD;
                break;

            default:
                cmd = 0;
                break;
            }

            if (cmd == 0) {
                break;
            }

            cmd |= FAPPCOMMAND_MOUSE;
            if (message == WM_XBUTTONUP) {
                keystate = GET_KEYSTATE_WPARAM(wParam);
            } else {
                keystate = GetMouseKeyState();
            }

            lParamAppCommand = MAKELPARAM(keystate, cmd);
            SendMessageWorker(pwnd, WM_APPCOMMAND, (WPARAM)hwnd, lParamAppCommand, fAnsi);
            break;
        }

    case WM_WINDOWPOSCHANGED: {
        PWINDOWPOS ppos = (PWINDOWPOS)lParam;

        if (!(ppos->flags & SWP_NOCLIENTMOVE)) {
            POINT pt = {pwnd->rcClient.left, pwnd->rcClient.top};
            pwndParent = REBASEPWND(pwnd, spwndParent);

            if (pwndParent != _GetDesktopWindow()) {
                pt.x -= pwndParent->rcClient.left;
                pt.y -= pwndParent->rcClient.top;
            }

            SendMessageWorker(pwnd, WM_MOVE, FALSE, MAKELPARAM(pt.x, pt.y), fAnsi);
        }

        if ((ppos->flags & SWP_STATECHANGE) || !(ppos->flags & SWP_NOCLIENTSIZE)) {
            UINT cmd;
            RECT rc;

            if (TestWF(pwnd, WFMINIMIZED))
                cmd = SIZEICONIC;
            else if (TestWF(pwnd, WFMAXIMIZED))
                cmd = SIZEFULLSCREEN;
            else
                cmd = SIZENORMAL;

        /*
         *  HACK ALERT:
         *  If the window is minimized then the real client width and height are
         *  zero. But, in win3.1 they were non-zero. Under Chicago, PrintShop
         *  Deluxe ver 1.2 hits a divide by zero. To fix this we fake the width
         *  and height for old apps to be non-zero values.
         *  GetClientRect does that job for us.
         */
            _GetClientRect(pwnd, &rc);
            SendMessageWorker(pwnd, WM_SIZE, cmd,
                    MAKELONG(rc.right - rc.left,
                    rc.bottom - rc.top), fAnsi);
        }
        return 0;
        }

    case WM_MOUSEACTIVATE: {
        PWND pwndT;
        LRESULT lt;

        /*
         * GetChildParent returns either a kernel pointer or NULL.
         */
        pwndT = GetChildParent(pwnd);
        if (pwndT != NULL) {
            pwndT = REBASEPTR(pwnd, pwndT);
            lt = SendMessageWorker(pwndT, WM_MOUSEACTIVATE, wParam, lParam, fAnsi);
            if (lt != 0)
                return lt;
        }

        /*
         * Moving, sizing or minimizing? Activate AFTER we take action.
         */
        return ((LOWORD(lParam) == HTCAPTION) && (HIWORD(lParam) == WM_LBUTTONDOWN )) ?
                (LONG)MA_NOACTIVATE : (LONG)MA_ACTIVATE;
        }

    case WM_CTLCOLORSCROLLBAR:
        if ((gpsi->BitCount < 8) ||
            (SYSRGB(3DHILIGHT) != SYSRGB(SCROLLBAR)) ||
            (SYSRGB(3DHILIGHT) == SYSRGB(WINDOW)))
        {
            /*
             * Remove call to UnrealizeObject().  GDI Handles this for
             * brushes on NT.
             *
             * UnrealizeObject(ghbrGray);
             */

            SetBkColor((HDC)wParam, SYSRGB(3DHILIGHT));
            SetTextColor((HDC)wParam, SYSRGB(3DFACE));
            return((LRESULT)gpsi->hbrGray);
        }

        icolBack = COLOR_3DHILIGHT;
        icolFore = COLOR_BTNTEXT;
        goto SetColor;

    case WM_CTLCOLORBTN:
        if (pwnd == NULL)
            goto ColorDefault;

        if (TestWF(pwnd, WFWIN40COMPAT)) {
            icolBack = COLOR_3DFACE;
            icolFore = COLOR_BTNTEXT;
        } else {
            goto ColorDefault;
        }
        goto SetColor;

    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORMSGBOX:
        // We want static controls in dialogs to have the 3D
        // background color, but statics in windows to inherit
        // their parents' background.

        if (pwnd == NULL)
            goto ColorDefault;

        if (TestWF(pwnd, WFWIN40COMPAT)) {
            icolBack = COLOR_3DFACE;
            icolFore = COLOR_WINDOWTEXT;
            goto SetColor;
        }
        // ELSE FALL THRU...

    case WM_CTLCOLOR:              // here for WOW only
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLOREDIT:
      ColorDefault:
        icolBack = COLOR_WINDOW;
        icolFore = COLOR_WINDOWTEXT;

      SetColor:
      {
        SetBkColor((HDC)wParam, gpsi->argbSystem[icolBack]);
        SetTextColor((HDC)wParam, gpsi->argbSystem[icolFore]);
        return (LRESULT)(SYSHBRUSH(icolBack));
      }

    case WM_NCHITTEST:
        return FindNCHit(pwnd, (LONG)lParam);

    case WM_GETTEXT:
        if (wParam != 0) {

            LPWSTR lpszText;
            UINT   cchSrc;

            if (pwnd->strName.Length) {

                lpszText = REBASE(pwnd, strName.Buffer);
                cchSrc = (UINT)pwnd->strName.Length / sizeof(WCHAR);

                if (fAnsi) {

                    LPSTR lpName = (LPSTR)lParam;

                    /*
                     * Non-zero retval means some text to copy out.  Do not
                     * copy out more than the requested byte count
                     * 'chMaxCount'.
                     */
                    cchSrc = WCSToMB(lpszText,
                                     cchSrc,
                                     (LPSTR *)&lpName,
                                     (UINT)(wParam - 1),
                                     FALSE);

                    lpName[cchSrc] = '\0';

                } else {

                    LPWSTR lpwName = (LPWSTR)lParam;

                    cchSrc = min(cchSrc, (UINT)(wParam - 1));
                    RtlCopyMemory(lpwName, lpszText, cchSrc * sizeof(WCHAR));
                    lpwName[cchSrc] = 0;
                }

                return cchSrc;
            }

            /*
             * else Null terminate the text buffer since there is no text.
             */
            if (fAnsi) {
                ((LPSTR)lParam)[0] = 0;
            } else {
                ((LPWSTR)lParam)[0] = 0;
            }
        }

        return 0;

    case WM_GETTEXTLENGTH:
        if (pwnd->strName.Length) {
            UINT cch;
            if (fAnsi) {
                RtlUnicodeToMultiByteSize(&cch,
                                          REBASE(pwnd, strName.Buffer),
                                          pwnd->strName.Length);
            } else {
                cch = pwnd->strName.Length / sizeof(WCHAR);
            }
            return cch;
        }
        return 0L;

    case WM_QUERYDRAGICON:
        /*
         * If the window is WIN40COMPAT or has a kernel side procedure
         * do not attempt to look into the instance module
         */
        if (TestWF(pwnd, WFWIN40COMPAT) || TestWF(pwnd, WFSERVERSIDEPROC)) {
            return 0;
        }
        /*
         * For old apps, like the VB3 ones, try to load the icon from resources
         * This is how Win95 does.
         */
        return (LRESULT)LoadIconW(KHANDLE_TO_HANDLE(pwnd->hModule), MAKEINTRESOURCE(1));

    case WM_QUERYOPEN:
    case WM_QUERYENDSESSION:
    case WM_DEVICECHANGE:
    case WM_POWERBROADCAST:
        return TRUE;

    case WM_KEYDOWN:
        if (wParam == VK_F10) {
            return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                    FNID_DEFWINDOWPROC, fAnsi);
        }
        break;

    case WM_SYSKEYDOWN:
        if ((HIWORD(lParam) & SYS_ALTERNATE) || (wParam == VK_F10) ||
                (wParam == VK_ESCAPE))
            return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                    FNID_DEFWINDOWPROC, fAnsi);
        break;

    case WM_UNICHAR:
        if (wParam == UNICODE_NOCHAR) {
            return FALSE;
        }
        break;

    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        /*
         * Do default processing for keystrokes into owner draw listboxes.
         */
        return -1;

    case WM_ACTIVATE:
        if (LOWORD(wParam))
            return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                    FNID_DEFWINDOWPROC, fAnsi);
        break;

    case WM_SHOWWINDOW:
        if (lParam != 0)
            return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                    FNID_DEFWINDOWPROC, fAnsi);
        break;

    case WM_DROPOBJECT:
       return DO_DROPFILE;

    case WM_WINDOWPOSCHANGING:
        /*
         * If the window's size is changing, adjust the passed-in size
         */
        #define ppos ((WINDOWPOS *)lParam)
        if (!(ppos->flags & SWP_NOSIZE))
            return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                    FNID_DEFWINDOWPROC, fAnsi);
        #undef ppos
        break;

    case WM_KLUDGEMINRECT:
        {
        SHELLHOOKINFO shi;
        LPRECT lprc = (LPRECT)lParam;

        shi.hwnd = (HWND)wParam;
        shi.rc.left = MAKELONG(lprc->left, lprc->top);
        shi.rc.top = MAKELONG(lprc->right, lprc->bottom);

        if (gpsi->uiShellMsg == 0)
            SetTaskmanWindow(NULL);
        if (SendMessageWorker(pwnd, gpsi->uiShellMsg, HSHELL_GETMINRECT,
                (LPARAM)&shi, fAnsi)) {
            //
            // Now convert the RECT back from two POINTS structures into two POINT
            // structures.
            //
            lprc->left   = (SHORT)LOWORD(shi.rc.left);  // Sign extend
            lprc->top    = (SHORT)HIWORD(shi.rc.left);  // Sign extend
            lprc->right  = (SHORT)LOWORD(shi.rc.top);   // Sign extend
            lprc->bottom = (SHORT)HIWORD(shi.rc.top);   // Sign extend
        }
        break;
        }

    case WM_NOTIFYFORMAT:
        if (lParam == NF_QUERY)
            return(TestWF(pwnd, WFANSICREATOR) ? NFR_ANSI : NFR_UNICODE);
        break;

    case WM_IME_KEYDOWN:
        if (fAnsi)
            PostMessageA(hwnd, WM_KEYDOWN, wParam, lParam);
        else
            PostMessageW(hwnd, WM_KEYDOWN, wParam, lParam);
        break;

    case WM_IME_KEYUP:
        if (fAnsi)
            PostMessageA(hwnd, WM_KEYUP, wParam, lParam);
        else
            PostMessageW(hwnd, WM_KEYUP, wParam, lParam);
        break;

    case WM_IME_CHAR:
        //if (TestCF(pwnd, CFIME))
        //    break;

        if ( fAnsi ) {
            if( IsDBCSLeadByteEx(THREAD_CODEPAGE(),(BYTE)(wParam >> 8)) ) {
                PostMessageA(hwnd,
                             WM_CHAR,
                             (WPARAM)((BYTE)(wParam >> 8)),   // leading byte
                             1L);
                PostMessageA(hwnd,
                             WM_CHAR,
                             (WPARAM)((BYTE)wParam),         // trailing byte
                             1L);
            }
            else
                PostMessageA(hwnd,
                             WM_CHAR,
                             (WPARAM)(wParam),
                             1L);
        } else {
            PostMessageW(hwnd, WM_CHAR, wParam, 1L);
        }
        break;

    case WM_IME_COMPOSITION:
        //if (TestCF(pwnd, CFIME))
        //    break;

        if (lParam & GCS_RESULTSTR) {
            HIMC  hImc;
            DWORD cbLen;

            if ((hImc = fpImmGetContext(hwnd)) == NULL_HIMC)
                goto dwpime_ToIMEWnd_withchk;

            if (fAnsi) {
                LPSTR pszBuffer, psz;

                /*
                 * ImmGetComposition returns the size of buffer needed in byte.
                 */
                if (!(cbLen = fpImmGetCompositionStringA(hImc, GCS_RESULTSTR, NULL, 0))) {
                    fpImmReleaseContext(hwnd, hImc);
                    goto dwpime_ToIMEWnd_withchk;
                }

                pszBuffer = psz = (LPSTR)UserLocalAlloc(HEAP_ZERO_MEMORY,
                                                        cbLen + sizeof(CHAR));

                if (pszBuffer == NULL) {
                    fpImmReleaseContext(hwnd, hImc);
                    goto dwpime_ToIMEWnd_withchk;
                }

                fpImmGetCompositionStringA(hImc, GCS_RESULTSTR, psz, cbLen);

                while (*psz) {
                    if (IsDBCSLeadByteEx(THREAD_CODEPAGE(),*psz)) {
                        if (*(psz+1)) {
                            SendMessageA( hwnd,
                                          WM_IME_CHAR,
                                          MAKEWPARAM(MAKEWORD(*(psz+1), *psz), 0),
                                          1L );
                            psz++;
                        }
                        psz++;
                    }
                    else
                        SendMessageA( hwnd,
                                      WM_IME_CHAR,
                                      MAKEWPARAM(MAKEWORD(*(psz++), 0), 0),
                                      1L );
                }

                UserLocalFree(pszBuffer);

                fpImmReleaseContext(hwnd, hImc);
            }
            else {
                LPWSTR pwszBuffer, pwsz;

                /*
                 * ImmGetComposition returns the size of buffer needed in byte
                 */
                if (!(cbLen = fpImmGetCompositionStringW(hImc, GCS_RESULTSTR, NULL, 0))) {
                    fpImmReleaseContext(hwnd, hImc);
                    goto dwpime_ToIMEWnd_withchk;
                }

                pwszBuffer = pwsz = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY,
                                                           cbLen + sizeof(WCHAR));

                if (pwszBuffer == NULL) {
                    fpImmReleaseContext(hwnd, hImc);
                    goto dwpime_ToIMEWnd_withchk;
                }

                fpImmGetCompositionStringW(hImc, GCS_RESULTSTR, pwsz, cbLen);

                while (*pwsz)
                    SendMessageW(hwnd, WM_IME_CHAR, MAKEWPARAM(*pwsz++, 0), 1L);

                UserLocalFree(pwszBuffer);

                fpImmReleaseContext(hwnd, hImc);
            }
        }

        /*
         * Fall through to send to Default IME Window with checking
         * activated hIMC.
         */

    case WM_IME_STARTCOMPOSITION:
    case WM_IME_ENDCOMPOSITION:
dwpime_ToIMEWnd_withchk:
        //if (TestCF(pwnd, CFIME))
        //    break;

        if (GetClientInfo()->dwTIFlags & TIF_DISABLEIME) {
            break;
        }
        /*
         * We assume this Wnd uses DefaultIMEWindow.
         * If this window has its own IME window, it have to call
         * ImmIsUIMessage()....
         */
        hwndDefIme = fpImmGetDefaultIMEWnd(hwnd);

        if (hwndDefIme == hwnd) {
            /*
             * VC++ 1.51 TLW0NCL.DLL subclass IME class window
             * and pass IME messages to DefWindowProc().
             */
            RIPMSG1(RIP_WARNING,
                "IME Class window is hooked and IME message [%X] are sent to DefWindowProc",
                message);
            ImeWndProcWorker(pwnd, message, wParam, lParam, fAnsi);
            break;
        }

        if ((pwndDefIme = ValidateHwndNoRip(hwndDefIme)) != NULL) {
            /*
             * If hImc of this window is not activated for IME window,
             * we don't send WM_IME_NOTIFY.
             */
            pimeui = ((PIMEWND)pwndDefIme)->pimeui;
            if (pimeui->hIMC == fpImmGetContext(hwnd))
                return SendMessageWorker(pwndDefIme, message, wParam, lParam, fAnsi);
            else
                RIPMSG1(RIP_WARNING,
                    "DefWindowProc can not send WM_IME_message [%X] now",
                    message);
        }
        break;

dwpime_ToTopLevel_withchk:
        //if (TestCF(pwnd, CFIME))
        //    break;

        /*
         * We assume this Wnd uses DefaultIMEWindow.
         * If this window has its own IME window, it have to call
         * ImmIsUIMessage()....
         */
        hwndDefIme = fpImmGetDefaultIMEWnd(hwnd);

        if (hwndDefIme == hwnd) {
            /*
             * VC++ 1.51 TLW0NCL.DLL subclass IME class window
             * and pass IME messages to DefWindowProc().
             */
            RIPMSG1(RIP_WARNING,
                "IME Class window is hooked and IME message [%X] are sent to DefWindowProc",
                message);
            ImeWndProcWorker(pwnd, message, wParam, lParam, fAnsi);
            break;
        }

        pwndDefIme = ValidateHwndNoRip(hwndDefIme);

        if ((pwndDefIme = ValidateHwndNoRip(hwndDefIme)) != NULL) {
            PWND pwndT, pwndParent;

            pwndT = pwnd;

            while (TestwndChild(pwndT)) {
                pwndParent = REBASEPWND(pwndT, spwndParent);
                if (GETPTI(pwndParent) != GETPTI(pwnd))
                    break;
                pwndT = pwndParent;
            }

            /*
             * If hImc of this window is not activated for IME window,
             * we don't send WM_IME_NOTIFY.
             */
            if (pwndT != pwnd) {
                pimeui = ((PIMEWND)pwndDefIme)->pimeui;
                if (pimeui->hIMC == fpImmGetContext(hwnd))
                    return SendMessageWorker(pwndT, message, wParam, lParam, fAnsi);
                else
                    RIPMSG1(RIP_WARNING,
                        "DefWindowProc can not send WM_IME_message [%X] now",
                        message);
            }
            else {
                /*
                 * Review !!
                 * If this is the toplevel window, we pass messages to
                 * the default IME window...
                 */
                return SendMessageWorker(pwndDefIme, message, wParam, lParam, fAnsi);
            }
        }
        break;

    case WM_IME_NOTIFY:
        switch (wParam) {
        case IMN_OPENSTATUSWINDOW:
        case IMN_CLOSESTATUSWINDOW:
#ifndef WKWOK_DEBUG
            goto dwpime_ToIMEWnd_withchk;
#endif
            goto dwpime_ToTopLevel_withchk;

        default:
            goto dwpime_ToIMEWnd_withchk;
        }
        break;

    case WM_IME_REQUEST:
        switch (wParam) {
        case IMR_QUERYCHARPOSITION:
            goto dwpime_ToIMEWnd_withchk;
        default:
            break;
        }
        break;

    case WM_IME_SYSTEM:
        if (wParam == IMS_SETACTIVECONTEXT) {
            RIPMSG0(RIP_WARNING, "DefWindowProc received unexpected WM_IME_SYSTEM");
            break;
        }

        /*
         * IMS_SETOPENSTATUS is depended on the activated input context.
         * It needs to be sent to only the activated system window.
         */
        if (wParam == IMS_SETOPENSTATUS)
            goto dwpime_ToIMEWnd_withchk;

        /*
         * Fall through to send to Default IME Window.
         */

    case WM_IME_SETCONTEXT:
        //if (TestCF(pwnd, CFIME))
        //    break;

        hwndDefIme = fpImmGetDefaultIMEWnd(hwnd);

        if (hwndDefIme == hwnd) {
            /*
             * VC++ 1.51 TLW0NCL.DLL subclass IME class window
             * and pass IME messages to DefWindowProc().
             */
            RIPMSG1(RIP_WARNING,
                "IME Class window is hooked and IME message [%X] are sent to DefWindowProc",
                message);
            ImeWndProcWorker(pwnd, message, wParam, lParam, fAnsi);
            break;
        }

        if ((pwndDefIme = ValidateHwndNoRip(hwndDefIme)) != NULL)
            return SendMessageWorker(pwndDefIme, message, wParam, lParam, fAnsi);

        break;

    case WM_IME_SELECT:
        RIPMSG0(RIP_WARNING, "DefWindowProc should not receive WM_IME_SELECT");
        break;

    case WM_IME_COMPOSITIONFULL:
        //if (TestCF(pwnd, CFIME))
        //    break;

        if (GETAPPVER() < VER40) {
            /*
             * This is a temporary solution for win31app.
             * FEREVIEW: For M5 this will call WINNLS message mapping logic
             *           -yutakan
             */
            return SendMessageWorker(pwnd, WM_IME_REPORT,
                             IR_FULLCONVERT, (LPARAM)0L, fAnsi);
        }
        break;

    case WM_CHANGEUISTATE:
        {
            WORD wAction = LOWORD(wParam);
            WORD wFlags = HIWORD(wParam);
            BOOL bRealChange = FALSE;

            /*
             * Validate parameters and determine the flags that should actually be changed.
             */
            if ((wFlags & ~UISF_VALID) || (wAction > UIS_LASTVALID) || lParam) {
                return 0;
            }

            if (wAction == UIS_INITIALIZE) {
                wFlags = 0;
                if (TEST_KbdCuesPUSIF) {
                    if (TEST_SRVIF(SRVIF_LASTRITWASKEYBOARD)) {
                        wAction = UIS_CLEAR;
                    } else {
                        wAction = UIS_SET;
                    }
                    wFlags = UISF_HIDEFOCUS | UISF_HIDEACCEL;
                    wParam = MAKEWPARAM(wAction, wFlags);
                }
            } else if (!TEST_KbdCuesPUSIF) {
                wFlags &= ~(UISF_HIDEFOCUS | UISF_HIDEACCEL);
            }

            if (wFlags == 0) {
                return 0;
            }

            UserAssert(wAction == UIS_SET || wAction == UIS_CLEAR);
            /*
             * If the state is not going to change, there's nothing to do here
             */
            if (wFlags & UISF_HIDEFOCUS) {
                bRealChange = (!!TestWF(pwnd, WEFPUIFOCUSHIDDEN)) ^ (wAction == UIS_SET);
            }
            if (wFlags & UISF_HIDEACCEL) {
                bRealChange |= (!!TestWF(pwnd, WEFPUIACCELHIDDEN)) ^ (wAction == UIS_SET);
            }
            if (wFlags & UISF_ACTIVE) {
                bRealChange |= (!!TestWF(pwnd, WEFPUIACTIVE)) ^ (wAction == UIS_SET);
            }

            if (!bRealChange) {
                break;
            }
            /*
             * Children pass this message up
             * Top level windows update send down to themselves WM_UPDATEUISTATE.
             * WM_UPDATEUISTATE will change the state bits and broadcast down the message
             */
            if (TestwndChild(pwnd)) {

                return SendMessageWorker(REBASEPWND(pwnd, spwndParent), WM_CHANGEUISTATE,
                              wParam, lParam, fAnsi);
            } else {
                return SendMessageWorker(pwnd, WM_UPDATEUISTATE, wParam, lParam, fAnsi);
            }

        }
        break;

    case WM_QUERYUISTATE:
        return (TestWF(pwnd, WEFPUIFOCUSHIDDEN) ? UISF_HIDEFOCUS : 0) |
               (TestWF(pwnd, WEFPUIACCELHIDDEN) ? UISF_HIDEACCEL : 0) |
               (TestWF(pwnd, WEFPUIACTIVE) ? UISF_ACTIVE : 0);
        break;
    }

    return 0;

#if DBG
    } // gfTurboDWP
#endif
}


/***************************************************************************\
* CallWindowProc
*
* Calls pfn with the passed message parameters. If pfn is a server-side
* window proc the server is called to deliver the message to the window.
* Currently we have the following restrictions:
*
* 04-17-91 DarrinM Created.
\***************************************************************************/

LRESULT WINAPI CallWindowProcAorW(
    WNDPROC pfn,
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL bAnsi)             // Denotes if input is Ansi or Unicode
{
    PCALLPROCDATA pCPD;
    PWND pwnd;

    /*
     * Raid# 78954: SPY++
     *
     * Under FE NT4.0 or NT5.0, the sytem sends WM_GETTEXTLENGTH
     * corresponding to WM_xxxGETTEXT to optimize buffer allocation.
     * This is really needed to avoid the buffer size inflation.
     * For some reasons, Spy++ passes NULL as pfn to CallWindowProc
     *
     */
    if (pfn == NULL) {
        RIPMSG0(RIP_WARNING, "CallWidowProcAorW(): pfn == NULL!");
        return 0L;
    }

// OPT!! check an ANSI\UNICODE table rather than fnDWORD
// OPT!! convert WM_CHAR family messages in line

    /*
     * Check if pfn is really a CallProcData Handle
     * if it is and there is no ANSI data then convert the handle
     * into an address; otherwise call the server for translation
     */
    if (ISCPDTAG(pfn)) {
        if (pCPD = HMValidateHandleNoRip((HANDLE)pfn, TYPE_CALLPROC)) {
            if ((message >= WM_USER) || !MessageTable[message].bThunkMessage) {
                pfn = (WNDPROC)pCPD->pfnClientPrevious;
            } else {
                return CsSendMessage(hwnd, message, wParam, lParam, (ULONG_PTR)pfn,
                        FNID_CALLWINDOWPROC, bAnsi);
            }
        } else {
            RIPMSG1(RIP_WARNING, "CallWindowProc tried using a deleted CPD %#p\n", pfn);
            return 0;
        }
    }

    pwnd = ValidateHwnd(hwnd);
    return UserCallWinProcCheckWow(PACTCTXT(pwnd), pfn, hwnd, message, wParam, lParam, NULL, FALSE);
}


FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, CallWindowProcA, WNDPROC, pfn, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI CallWindowProcA(
    WNDPROC pfn,
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return CallWindowProcAorW(pfn, hwnd, message, wParam, lParam, TRUE);
}

FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, CallWindowProcW, WNDPROC, pfn, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI CallWindowProcW(
    WNDPROC pfn,
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return CallWindowProcAorW(pfn, hwnd, message, wParam, lParam, FALSE);
}

/***************************************************************************\
* MenuWindowProc
*
* Calls the sever-side function xxxMenuWindowProc
*
* 07-27-92 Mikehar Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, MenuWindowProcW, HWND, hwnd, HWND, hwndMDIClient, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI MenuWindowProcW(
    HWND hwnd,
    HWND hwndMDIClient,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return CsSendMessage(hwnd, message, wParam, lParam,
        (ULONG_PTR)hwndMDIClient, FNID_MENU, FALSE);
}


FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, MenuWindowProcA, HWND, hwnd, HWND, hwndMDIClient, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI MenuWindowProcA(
    HWND hwnd,
    HWND hwndMDIClient,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return CsSendMessage(hwnd, message, wParam, lParam,
        (ULONG_PTR)hwndMDIClient, FNID_MENU, TRUE);
}

/***************************************************************************\
* _ClientGetListboxString
*
* This special function exists because LB_GETTEXT and CB_GETLBTEXT don't have
* buffer counts in them anywhere. Because there is no buffer count we have
* no idea how much room to reserved in the shared memory stack for this
* string to be copied into. The solution is to get the string length ahead
* of time, and send the message with this buffer length. Since this buffer
* length isn't a part of the original message, this routine is used for
* just this purpose.
*
* This routine gets called from the server.
*
* 04-13-91 ScottLu Created.
\***************************************************************************/

DWORD WINAPI _ClientGetListboxString(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPSTR lParam, // May be a unicode or ANSI string
    ULONG_PTR xParam,
    PROC xpfn)
{
    return ((DWORD)((GENERICPROC)xpfn)(pwnd, msg, wParam, (LPARAM)lParam, xParam));
}

/***************************************************************************\
* DispatchMessageWorker
*
* Handles any messages that can be dealt with wholly on the client and
* passes the rest to the server.
*
* 04-24-92 DarrinM      Created.
\***************************************************************************/
LRESULT DispatchMessageWorker(
    MSG *pmsg,
    BOOL fAnsi)
{
    PWND pwnd;
    WPARAM wParamSaved;
    LRESULT lRet;
    BOOL bDoDbcsMessaging = FALSE;

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (pmsg->message & RESERVED_MSG_BITS) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"pmsg->message\" (%ld) to DispatchMessageWorker",
                pmsg->message);

        return 0;
    }

    if (pmsg->hwnd != NULL) {
        pwnd = ValidateHwnd(pmsg->hwnd);
        if (pwnd == NULL) {
            return 0;
        }
        pmsg->hwnd = HWq(pwnd); // get full 32-bit HWND in case this came from WoW
    } else {
        pwnd = NULL;
    }

    /*
     * If this is a synchronous-only message (takes a pointer in wParam or
     * lParam), then don't allow this message to go through since those
     * parameters have not been thunked, and are pointing into outer-space
     * (which would case exceptions to occur).
     *
     * (This api is only called in the context of a message loop, and you
     * don't get synchronous-only messages in a message loop).
     */
    if (TESTSYNCONLYMESSAGE(pmsg->message, pmsg->wParam)) {
        /*
         * Fail if 32 bit app is calling.
         */
        if (!(GetClientInfo()->dwTIFlags & TIF_16BIT)) {
            RIPERR0(ERROR_MESSAGE_SYNC_ONLY, RIP_WARNING, "DispatchMessageWorker: must be sync only");
            return FALSE;
        }

        /*
         * For wow apps, allow it to go through (for compatibility). Change
         * the message id so our code doesn't understand the message - wow
         * will get the message and strip out this bit before dispatching
         * the message to the application.
         */
        pmsg->message |= MSGFLAG_WOW_RESERVED;
    }

    /*
     * Timer callbacks that don't go through window procs are sent with
     * the callback address in lParam.  Identify and dispatch those timers.
     */
    if ((pmsg->message == WM_TIMER) || (pmsg->message == WM_SYSTIMER)) {
        /*
         * Console windows use WM_TIMER for the caret. However, they don't
         * use a timer callback, so if this is CSRSS and there's a WM_TIMER
         * for us, the only way lParam would be non-zero is if someone's trying
         * to make us fault. No, this isn't a nice thing to do, but there
         * are bad, bad people out there. Windows Bug #361246.
         */
        if (pmsg->lParam != 0) {
            /*
             * System timers must be executed on the server's context.
             */
            if (pmsg->message == WM_SYSTIMER) {
                return NtUserDispatchMessage(pmsg);
            } else if (!gfServerProcess) {
                /*
                 * WM_TIMER with lParam could be an attack from
                 * malicious apps.  To make sure the call is legitimate,
                 * let the kernel side validates it.
                 */
                if (!NtUserValidateTimerCallback(pmsg->lParam)) {
                    RIPMSGF3(RIP_WARNING, "invalid timer: hwnd=%p, wParam=%p, lParam=%p", pmsg->hwnd, pmsg->wParam, pmsg->lParam);
                    return 0;
                }

                /*
                 * We can't really trust what's in lParam, so make sure we
                 * handle any exceptions that occur during this call.
                 */
                try {
                    /*
                     * Windows NT Bug #234292.
                     * Since the called window/dialog proc may have a different
                     * calling convention, we must wrap the call and, check esp
                     * and replace with a good esp when the call returns. This
                     * is what UserCallWinProc* does.
                     */
                    lRet = UserCallWinProc(PACTCTXT(pwnd),
                                           (WNDPROC)pmsg->lParam,
                                           pmsg->hwnd,
                                           pmsg->message,
                                           pmsg->wParam,
                                           NtGetTickCount());
                } except ((GetAppCompatFlags2(VER40) & GACF2_NO_TRYEXCEPT_CALLWNDPROC) ?
                          EXCEPTION_CONTINUE_SEARCH : W32ExceptionHandler(FALSE, RIP_WARNING)) {
                      /*
                       * Windows NT Bug #359866.
                       * Some applications like Hagaki Studio 2000 need to handle
                       * the exception in WndProc in their handler, even though it
                       * skips the API calls. For those apps, we have to honor the
                       * behavior of NT4, with no protection.
                       */
                    lRet = 0;
                }
                return lRet;
            }
        }
    }

    if (pwnd == NULL) {
        return 0;
    }

    /*
     * To be safe (in case some bizarre app wants to look at the message
     * again after dispatching it) save wParam so it can be restored after
     * RtlMBMessageWParamCharToWCS() or RtlWCSMessageToMB() mangle it.
     */
    wParamSaved = pmsg->wParam;

    /*
     * Pass messages intended for server-side windows over to the server.
     * WM_PAINTs are passed over so the WFPAINTNOTPROCESSED code can be
     * executed.
     */
    if (TestWF(pwnd, WFSERVERSIDEPROC) || (pmsg->message == WM_PAINT)) {
        if (fAnsi) {
            /*
             * Setup DBCS Messaging for WM_CHAR...
             */
            BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(pmsg->message,pmsg->wParam,TRUE);

            /*
             * Convert wParam to Unicode, if nessesary.
             */
            RtlMBMessageWParamCharToWCS(pmsg->message, &pmsg->wParam);
        }
        lRet = NtUserDispatchMessage(pmsg);
        pmsg->wParam = wParamSaved;
        return lRet;
    }

    /*
     * If the dispatcher and the receiver are both ANSI or both UNICODE
     * then no message translation is necessary.  NOTE: this test
     * assumes that fAnsi is FALSE or TRUE, not just zero or non-zero.
     */
    if (!fAnsi != !TestWF(pwnd, WFANSIPROC)) {
        // before: if (fAnsi != ((TestWF(pwnd, WFANSIPROC)) ? TRUE : FALSE)) {

        if (PtiCurrent() != GETPTI(pwnd)) {
            RIPMSG0(RIP_WARNING, "message belongs to a different Q");
            return 0;
        }

        if (fAnsi) {
            /*
             * Setup DBCS Messaging for WM_CHAR...
             */
            BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_CLIENTA(pmsg->message,pmsg->wParam,TRUE);

            /*
             * Convert wParam to Unicode, if nessesary.
             */
            RtlMBMessageWParamCharToWCS(pmsg->message, &pmsg->wParam);
        } else {
            /*
             * Convert wParam to ANSI...
             */
            RtlWCSMessageWParamCharToMB(pmsg->message, &pmsg->wParam);

            /*
             * Let's DBCS messaging for WM_CHAR....
             */
            BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_CLIENTW(
                pmsg->hwnd,pmsg->message,pmsg->wParam,pmsg->lParam,
                pmsg->time,pmsg->pt,bDoDbcsMessaging);
        }
    }

DispatchMessageAgain:
    lRet = UserCallWinProcCheckWow(pwnd->pActCtx, (WNDPROC)pwnd->lpfnWndProc, pmsg->hwnd, pmsg->message,
            pmsg->wParam, pmsg->lParam, &(pwnd->state), TRUE);

    /*
     * if we have DBCS TrailingByte that should be sent, send it here..
     */
    DISPATCH_DBCS_MESSAGE_IF_EXIST(pmsg->message,pmsg->wParam,bDoDbcsMessaging,DispatchMessage);

    pmsg->wParam = wParamSaved;
    return lRet;
}

/***************************************************************************\
* GetMessageTime (API)
*
* This API returns the time when the last message was read from
* the current message queue.
*
* History:
* 11-19-90 DavidPe      Created.
\***************************************************************************/

LONG GetMessageTime(VOID)
{
    return (LONG)NtUserGetThreadState(UserThreadStateMessageTime);
}

/***************************************************************************\
* GetMessageExtraInfo (API)
*
* History:
* 28-May-1991 mikeke
\***************************************************************************/

LPARAM GetMessageExtraInfo(VOID)
{
    return (LPARAM)NtUserGetThreadState(UserThreadStateExtraInfo);
}


FUNCLOG1(LOG_GENERAL, LPARAM, DUMMYCALLINGTYPE, SetMessageExtraInfo, LPARAM, lParam)
LPARAM SetMessageExtraInfo(LPARAM lParam)
{
    return (LPARAM)NtUserCallOneParam(lParam, SFI__SETMESSAGEEXTRAINFO);
}



/***********************************************************************\
* InSendMessage (API)
*
* This function determines if the current thread is preocessing a message
* from another application.
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

BOOL InSendMessage(VOID)
{
    PCLIENTTHREADINFO pcti = GetClientInfo()->pClientThreadInfo;

    if (pcti) {
        return TEST_BOOL_FLAG(pcti->CTIF_flags, CTIF_INSENDMESSAGE);
    }
    return NtUserGetThreadState(UserThreadStateInSendMessage) != ISMEX_NOSEND;
}
/***********************************************************************\
* InSendMessageEx (API)
*
* This function tells you what type of send message is being processed
*  by the application, if any
*
* History:
* 01/22/97 GerardoB Created
\***********************************************************************/


FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, InSendMessageEx, LPVOID, lpReserved)
DWORD InSendMessageEx(LPVOID lpReserved)
{
    PCLIENTTHREADINFO pcti = GetClientInfo()->pClientThreadInfo;
    UNREFERENCED_PARAMETER(lpReserved);

    if (pcti && !TEST_FLAG(pcti->CTIF_flags, CTIF_INSENDMESSAGE)) {
        return ISMEX_NOSEND;
    }
    return (DWORD)NtUserGetThreadState(UserThreadStateInSendMessage);
}

/***********************************************************************\
* GetCPD
*
* This function calls the server to allocate a CPD structure.
*
* History:
* 11-15-94 JimA         Created.
\***********************************************************************/

ULONG_PTR GetCPD(
    KERNEL_PVOID pWndOrCls,
    DWORD options,
    ULONG_PTR dwData)
{
    return NtUserGetCPD(HW(pWndOrCls), options, dwData);
}

#ifdef BUILD_WOW6432
/***********************************************************************\
* MapKernelClientFnToClientFn
*
* Maps a function pointer from what the kernel expects to what the
* client(user-mode) expects.
*
* History:
* 11-15-98 PeterHal         Created.
\***********************************************************************/
WNDPROC_PWND
MapKernelClientFnToClientFn(
    WNDPROC_PWND lpfnWndProc
    )
{
    KPKERNEL_ULONG_PTR pp;

    for (pp = (KPKERNEL_ULONG_PTR)&gpsi->apfnClientA; pp < (KPKERNEL_ULONG_PTR) (&gpsi->apfnClientA+1); pp ++) {
        if ((KERNEL_ULONG_PTR)lpfnWndProc == *pp) {
            return (WNDPROC_PWND)((KERNEL_ULONG_PTR*) &pfnClientA) [ (pp - (KPKERNEL_ULONG_PTR)&gpsi->apfnClientA) ];
        }
    }

    for (pp = (KPKERNEL_ULONG_PTR)&gpsi->apfnClientW; pp < (KPKERNEL_ULONG_PTR) (&gpsi->apfnClientW+1); pp ++) {
        if ((KERNEL_ULONG_PTR)lpfnWndProc == *pp) {
            return (WNDPROC_PWND)((KERNEL_ULONG_PTR*) &pfnClientW) [ (pp - (KPKERNEL_ULONG_PTR)&gpsi->apfnClientW) ];
        }
    }

    return lpfnWndProc;
}
#endif

#ifdef GENERIC_INPUT
LRESULT
APIENTRY
DefRawInputProc(
    PRAWINPUT* paRawInput,
    INT nInput,
    UINT cbSizeHeader)
{
    UNREFERENCED_PARAMETER(paRawInput);
    UNREFERENCED_PARAMETER(nInput);

    if (cbSizeHeader != sizeof(RAWINPUTHEADER)) {
        return (LRESULT)-1;
    }

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\cltxt.h ===
/**************************************************************************\
* Module Name: cltxt.h
*
* Neutral Client/Server call related routines involving text.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Created: 04-Dec-90
*
* History:
*   04-Dec-90 created by SMeans
*
\**************************************************************************/

#ifdef UNICODE
  #define IS_ANSI FALSE
#else
  #define IS_ANSI TRUE
  #if IS_ANSI != CW_FLAGS_ANSI
  # error("IS_ANSI != CW_FLAGS_ANSI)
  #endif
#endif
#include "ntsend.h"
#include "powrprof.h"

/***************************************************************************\
* CreateWindowEx (API)
*
* A complete Thank cannot be generated for CreateWindowEx because its last
* parameter (lpParam) is polymorphic depending on the window's class.  If
* the window class is "MDIClient" then lpParam points to a CLIENTCREATESTRUCT.
*
* History:
* 04-23-91 DarrinM      Created.
* 04-Feb-92 IanJa       Unicode/ANSI neutral
\***************************************************************************/

#ifdef UNICODE
FUNCLOG12(LOG_GENERAL, HWND, WINAPI, CreateWindowExW, DWORD, dwExStyle, LPCTSTR, lpClassName, LPCTSTR, lpWindowName, DWORD, dwStyle, int, X, int, Y, int, nWidth, int, nHeight, HWND, hWndParent, HMENU, hMenu, HINSTANCE, hModule, LPVOID, lpParam)
#else
FUNCLOG12(LOG_GENERAL, HWND, WINAPI, CreateWindowExA, DWORD, dwExStyle, LPCTSTR, lpClassName, LPCTSTR, lpWindowName, DWORD, dwStyle, int, X, int, Y, int, nWidth, int, nHeight, HWND, hWndParent, HMENU, hMenu, HINSTANCE, hModule, LPVOID, lpParam)
#endif // UNICODE
HWND WINAPI CreateWindowEx(
    DWORD dwExStyle,
    LPCTSTR lpClassName,
    LPCTSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hModule,
    LPVOID lpParam)
{
    return _CreateWindowEx(dwExStyle,
                           lpClassName,
                           lpWindowName,
                           dwStyle,
                           X,
                           Y,
                           nWidth,
                           nHeight,
                           hWndParent,
                           hMenu,
                           hModule,
                           lpParam,
                           IS_ANSI | CW_FLAGS_VERSIONCLASS);
}

/***************************************************************************\
* fnHkINLPCWPSTRUCT
*
* This gets thunked through the message thunks, so it has the format
* of a c/s message thunk call.
*
* 05-09-91 ScottLu      Created.
* 04-Feb-92 IanJa       Unicode/ANSI neutral
\***************************************************************************/

LRESULT TEXT_FN(fnHkINLPCWPSTRUCT)(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    CWPSTRUCT cwp;

    cwp.hwnd = HW(pwnd);
    cwp.message = message;
    cwp.wParam = wParam;
    cwp.lParam = lParam;

    return TEXT_FN(DispatchHook)(MAKELONG(HC_ACTION, WH_CALLWNDPROC),
            (GetClientInfo()->CI_flags & CI_INTERTHREAD_HOOK) != 0,
            (LPARAM)&cwp, (HOOKPROC)xParam);
}

LRESULT TEXT_FN(fnHkINLPCWPRETSTRUCT)(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    CWPRETSTRUCT cwp;
    PCLIENTINFO pci = GetClientInfo();

    cwp.hwnd = HW(pwnd);
    cwp.message = message;
    cwp.wParam = wParam;
    cwp.lParam = lParam;
    cwp.lResult = KERNEL_LRESULT_TO_LRESULT(pci->dwHookData);

    return TEXT_FN(DispatchHook)(MAKELONG(HC_ACTION, WH_CALLWNDPROCRET),
            (GetClientInfo()->CI_flags & CI_INTERTHREAD_HOOK) != 0,
            (LPARAM)&cwp, (HOOKPROC)xParam);
}

/***************************************************************************\
* DispatchHook
*
* This routine exists simply to remember the hook type in the CTI structure
* so that later inside of CallNextHookEx we know how to thunk the hook
* call.
*
* 05-09-91 ScottLu      Created.
* 04-Feb-92 IanJa       Unicode/ANSI neutral
\***************************************************************************/

LRESULT TEXT_FN(DispatchHook)(
    int dw,
    WPARAM wParam,
    LPARAM lParam,
    HOOKPROC pfn)
{
    int dwHookSave;
    LRESULT nRet;
    PCLIENTINFO pci;
#if IS_ANSI
    WPARAM wParamSave;
#endif
    /* -FE-
     * * THIS VARIABLE SHOULD BE THREAD AWARE *
     */
    static EVENTMSG CachedEvent = {0,0,0,(DWORD)0,(HWND)0};

    /*
     * First save the current hook stored in the CTI structure in case we're
     * being recursed into. dw contains MAKELONG(nCode, nFilterType).
     */
    pci = GetClientInfo();
    dwHookSave = pci->dwHookCurrent;
    pci->dwHookCurrent = (dw & 0xFFFF0000) | IS_ANSI;

#if IS_ANSI       // TEXT_FN(DispatchHook)()
    if (IS_DBCS_ENABLED()) {
        PMSG pMsg;
        PEVENTMSG pEMsg;
        switch (HIWORD(dw)) {
        case WH_JOURNALPLAYBACK:
            switch (LOWORD(dw)) {
            case HC_SKIP:
                CachedEvent.message = 0;
                break;
            case HC_GETNEXT:
            case HC_NOREMOVE:
                pEMsg = (PEVENTMSG)lParam;
                if (CachedEvent.message != 0 && pEMsg != NULL) {
                    RtlCopyMemory((PEVENTMSG)lParam,&CachedEvent,sizeof(EVENTMSG));
                    return 0;
                }
                break;
            }
            break;
        case WH_MSGFILTER:
        case WH_SYSMSGFILTER:
        case WH_GETMESSAGE:
            pMsg = (PMSG)lParam;
            if (pMsg) {
                /*
                 * Save original message.
                 */
                wParamSave = pMsg->wParam;
                switch (pMsg->message) {
                case WM_CHAR:
                case EM_SETPASSWORDCHAR:
                    /*
                     * Here... pMsg->wParam contains..
                     *
                     * HIWORD(wParam)         = Information for DBCS messgaing.
                     * HIBYTE(LOWORD(wParam)) = Dbcs LeadingByte Byte.
                     * LOBYTE(LOWORD(wParam)) = Dbcs TrailingByte or Sbcs character.
                     *
                     */
                    if (pMsg->wParam & WMCR_IR_DBCSCHAR) {
                        /*
                         * Mask off DBCS messaging infomation area.
                         * (Look up only DBCS character code data).
                         */
                        pMsg->wParam &= 0x0000FFFF;
                    } else {
                        if (IS_DBCS_MESSAGE(LOWORD(pMsg->wParam))) {
                            PKERNEL_MSG pDbcsMsg = GetCallBackDbcsInfo();
                            /*
                             * Copy this message to CLIENTINFO for next GetMessage
                             * or PeekMesssage() call.
                             */
                            COPY_MSG_TO_KERNELMSG(pDbcsMsg,pMsg);
                            /*
                             * Only Dbcs Trailingbyte is nessesary for pushed message. we'll
                             * pass this message when GetMessage/PeekMessage is called at next.
                             */
                            pDbcsMsg->wParam = (WPARAM)((pMsg->wParam & 0x0000FF00) >> 8);
                            /*
                             * Return DbcsLeading byte to Apps.
                             */
                            pMsg->wParam = (WPARAM)(pMsg->wParam & 0x000000FF);
                        } else {
                            /*
                             * This is SBCS char, make sure it.
                             */
                            pMsg->wParam &= 0x000000FF;
                        }
                    }
                }
            }
        }
GetNextHookData:
        ;
    }
#endif

    /*
     * Call the hook. dw contains MAKELONG(nCode, nFilterType).
     */
    nRet = pfn(LOWORD(dw), wParam, lParam);

#if IS_ANSI
    if (IS_DBCS_ENABLED()) {
        PMSG pMsg;
        PEVENTMSG pEMsg;
        switch (HIWORD(dw)) {
        case WH_JOURNALPLAYBACK:
            switch (LOWORD(dw)) {
            case HC_GETNEXT:
            case HC_NOREMOVE:
                pEMsg = (PEVENTMSG)lParam;
                if ((nRet == 0) && pEMsg) {
                    WPARAM dwAnsi = LOWORD(pEMsg->paramL);
                    switch(pEMsg->message) {
                    case WM_CHAR:
                    case EM_SETPASSWORDCHAR:
                        /*
                         * Chech wParam is DBCS character or not.
                         */
                        if (IS_DBCS_MESSAGE((dwAnsi))) {
                            /*
                             * DO NOT NEED TO MARK FOR IR_DBCSCHAR
                             */
                        } else {
                            PBYTE pchDbcsCF = GetDispatchDbcsInfo();

                            /*
                             * If we have cached Dbcs LeadingByte character,
                             * build a DBCS character with the TrailingByte
                             * in wParam.
                             */
                            if (*pchDbcsCF) {
                                WORD DbcsLeadChar = (WORD)(*pchDbcsCF);
                                /*
                                 * HIBYTE(LOWORD(dwAnsi)) = Dbcs LeadingByte.
                                 * LOBYTE(LOWORD(dwAnsi)) = Dbcs TrailingByte.
                                 */
                                dwAnsi |= (DbcsLeadChar << 8);

                                /*
                                 * Invalidate cached data.
                                 */
                                *pchDbcsCF = 0;
                            } else if (IsDBCSLeadByteEx(THREAD_CODEPAGE(),LOBYTE(dwAnsi))) {
                                /*
                                 * If this is DBCS LeadByte character, we
                                 * should wait DBCS TrailingByte to convert
                                 * this to Unicode. then we cache it here.
                                 */
                                *pchDbcsCF = LOBYTE(dwAnsi);

                                /*
                                 * Get DBCS TrailByte.
                                 */
                                pfn(HC_SKIP,0,0);
                                goto GetNextHookData;
                            }
                        }

                        /*
                         * Convert to Unicode.
                         */
                        RtlMBMessageWParamCharToWCS(pEMsg->message, &dwAnsi);

                        /*
                         * Restore converted Unicode to EVENTMSG.
                         */
                        pEMsg->paramL = (UINT)dwAnsi;

                        /*
                         * Keep this EVENTMSG to local buffer.
                         */
                        RtlCopyMemory(&CachedEvent, pEMsg, sizeof(EVENTMSG));
                    }
                }
            }
            break;
        case WH_MSGFILTER:
        case WH_SYSMSGFILTER:
        case WH_GETMESSAGE:
            pMsg = (PMSG)lParam;
            if (pMsg) {
                switch (pMsg->message) {
                case WM_CHAR:
                case EM_SETPASSWORDCHAR:
                    if (GetCallBackDbcsInfo()->wParam) {
                        PKERNEL_MSG pmsgDbcs = GetCallBackDbcsInfo();
                        /*
                         * Get pushed message.
                         *
                         * Backup current message. this backupped message will be used
                         * when Apps peek (or get) message from thier WndProc.
                         * (see GetMessageA(), PeekMessageA()...)
                         *
                         * pmsg->hwnd    = pmsgDbcs->hwnd;
                         * pmsg->message = pmsgDbcs->message;
                         * pmsg->wParam  = pmsgDbcs->wParam;
                         * pmsg->lParam  = pmsgDbcs->lParam;
                         * pmsg->time    = pmsgDbcs->time;
                         * pmsg->pt      = pmsgDbcs->pt;
                         */
                        COPY_KERNELMSG_TO_MSG(pMsg,pmsgDbcs);
                        /*
                         * Invalidate pushed message in CLIENTINFO.
                         */
                        pmsgDbcs->wParam = 0;
                        /*
                         * Call the hook with DBCS TrailByte..
                         */
                        nRet = pfn(LOWORD(dw), wParam, lParam);
                    }
                    /*
                     * Restore original message..
                     * #96571 [hiroyama]
                     * Other messages than WM_CHAR and EM_SETPASSWORDCHAR can be
                     * modifed by a hooker.
                     * Wparam for WM_CHAR and EM_SETPASSWORDCHAR must be restored.
                     * *by design*
                     */
                    pMsg->wParam = wParamSave;
                }
            }
        }
    }
#endif

    /*
     * Restore the hook number and return the return code.
     */
    pci->dwHookCurrent = dwHookSave;
    return nRet;
}


/***************************************************************************\
* GetWindowLong, SetWindowLong, GetClassLong
*
* History:
* 02-Feb-92 IanJa       Neutral version.
\***************************************************************************/

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, LONG_PTR, APIENTRY, GetWindowLongPtrW, HWND, hwnd, int, nIndex)
#else
FUNCLOG2(LOG_GENERAL, LONG_PTR, APIENTRY, GetWindowLongPtrA, HWND, hwnd, int, nIndex)
#endif // UNICODE
LONG_PTR APIENTRY GetWindowLongPtr(
    HWND hwnd,
    int nIndex)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return 0;
    }

    try {
        return _GetWindowLongPtr(pwnd, nIndex, IS_ANSI);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hwnd);
        return 0;
    }
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, LONG_PTR, APIENTRY, SetWindowLongPtrW, HWND, hWnd, int, nIndex, LONG_PTR, dwNewLong)
#else
FUNCLOG3(LOG_GENERAL, LONG_PTR, APIENTRY, SetWindowLongPtrA, HWND, hWnd, int, nIndex, LONG_PTR, dwNewLong)
#endif // UNICODE
LONG_PTR APIENTRY SetWindowLongPtr(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong)
{
    return _SetWindowLongPtr(hWnd, nIndex, dwNewLong, IS_ANSI);
}

#ifdef _WIN64
LONG APIENTRY GetWindowLong(
    HWND hwnd,
    int nIndex)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return 0;
    }

    try {
        return _GetWindowLong(pwnd, nIndex, IS_ANSI);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hwnd);
        return 0;
    }
}

LONG APIENTRY SetWindowLong(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong)
{
    return _SetWindowLong(hWnd, nIndex, dwNewLong, IS_ANSI);
}
#endif

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, ULONG_PTR, APIENTRY, GetClassLongPtrW, HWND, hWnd, int, nIndex)
#else
FUNCLOG2(LOG_GENERAL, ULONG_PTR, APIENTRY, GetClassLongPtrA, HWND, hWnd, int, nIndex)
#endif // UNICODE

ULONG_PTR APIENTRY GetClassLongPtr(
    HWND hWnd,
    int nIndex)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hWnd);
    if (pwnd == NULL) {
        return 0;
    }

    try {
        return _GetClassLongPtr(pwnd, nIndex, IS_ANSI);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hWnd);
        return 0;
    }
}

#ifdef _WIN64
DWORD  APIENTRY GetClassLong(HWND hWnd, int nIndex)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hWnd);

    if (pwnd == NULL)
        return 0;

    try {
        return _GetClassLong(pwnd, nIndex, IS_ANSI);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hWnd);
        return 0;
    }
}
#endif


#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, BOOL, APIENTRY, PeekMessageW, LPMSG, lpMsg, HWND, hWnd, UINT, wMsgFilterMin, UINT, wMsgFilterMax, UINT, wRemoveMsg)
#else
FUNCLOG5(LOG_GENERAL, BOOL, APIENTRY, PeekMessageA, LPMSG, lpMsg, HWND, hWnd, UINT, wMsgFilterMin, UINT, wMsgFilterMax, UINT, wRemoveMsg)

#endif // UNICODE

BOOL APIENTRY PeekMessage(
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg)
{
    CLIENTTHREADINFO *pcti;
    PCLIENTINFO pci;
    UINT fsWakeMaskFilter;
    UINT fsWakeMask;
    UINT cSpinLimit;

    pci = GetClientInfo();

    if (hWnd != NULL) {
        goto lbCallServer;
    }

#if IS_ANSI
    /*
     * If we have a DBCS TrailingByte that should be returned to App,
     * we should pass it, never can fail....
     */
    UserAssert(IS_DBCS_ENABLED() || GetCallBackDbcsInfo()->wParam == 0);
    if (GetCallBackDbcsInfo()->wParam) {    // accesses fs:xxx, but no speed penalty
        /*
         * Check message filter... WM_CHAR should be in the Range...
         */
        if ((!wMsgFilterMin && !wMsgFilterMax) ||
            (wMsgFilterMin <= WM_CHAR && wMsgFilterMax >=WM_CHAR)) {
            goto lbCallServer;
        }
    }
#endif

    if (   (pci->dwTIFlags & TIF_16BIT)
        && !(wRemoveMsg & PM_NOYIELD)
        && ((gpsi->nEvents != 0) || (pci->dwTIFlags & (TIF_FIRSTIDLE | TIF_DELAYEDEVENT)))) {

        goto lbCallServer;
    }

    /*
     * If we can't see the client thread info, we need to go to the kernel.
     */
    if ((pcti = CLIENTTHREADINFO(pci)) == NULL) {
        goto lbCallServer;
    }

    fsWakeMaskFilter = HIWORD(wRemoveMsg);

#if DBG
    /*
     * New for NT5: HIWORD(wRemoveMsg) contains a QS_ mask. This is
     * validated for real in the kernel side.
     */
    if (fsWakeMaskFilter & ~QS_VALID) {
        RIPMSG1(RIP_WARNING,
                "PeekMessage: Invalid QS_ bits: 0x%x",
                fsWakeMaskFilter);
    }
#endif

    /*
     * If any appropriate input is available, we need to go to the kernel.
     */
    if (wMsgFilterMax == 0 && fsWakeMaskFilter == 0) {
        fsWakeMask = (QS_ALLINPUT | QS_EVENT | QS_ALLPOSTMESSAGE);
    } else {
        fsWakeMask = CalcWakeMask(wMsgFilterMin, wMsgFilterMax, fsWakeMaskFilter);
    }
    if ((pcti->fsChangeBits | pcti->fsWakeBits) & fsWakeMask) {
        goto lbCallServer;
    }

    /*
     * If this thread has the queue locked, we have to go to the kernel or
     * other threads on the same queue may be prevented from getting input
     * messages.
     */
    if (pcti->CTIF_flags & CTIF_SYSQUEUELOCKED) {
        goto lbCallServer;
    }

    /*
     * This is the peek message count (not going idle count). If it gets
     * to be 100 or greater, call the server. This'll cause this app to be
     * put at background priority until it sleeps. This is really important
     * for compatibility because win3.1 peek/getmessage usually takes a trip
     * through the win3.1 scheduler and runs the next task.
     */
    pci->cSpins++;

    if ((pci->cSpins >= CSPINBACKGROUND) && !(pci->dwTIFlags & TIF_SPINNING)) {
        goto lbCallServer;
    }

    /*
     * We have to go to the server if someone is waiting on this event.
     * We used to just wait until the spin cound got large but for some
     * apps like terminal.  They always just call PeekMessage and after
     * just a few calls they would blink their caret which bonks the spincount
     */
    if (pci->dwTIFlags & TIF_WAITFORINPUTIDLE) {
        goto lbCallServer;
    }

    /*
     * Make sure we go to the kernel at least once a second so that
     * hung app painting won't occur.
     */
    if ((NtGetTickCount() - pcti->timeLastRead) > 1000) {
        NtUserGetThreadState(UserThreadStatePeekMessage);
    }

    /*
     * Determine the maximum number of spins before we yield. Yields
     * are performed more frequently for 16 bit apps.
     */
    if ((pci->dwTIFlags & TIF_16BIT) && !(wRemoveMsg & PM_NOYIELD)) {
        cSpinLimit = CSPINBACKGROUND / 10;
    } else {
        cSpinLimit = CSPINBACKGROUND;
    }

    /*
     * If the PeekMessage() is just spinning, then we should sleep
     * just enough so that we allow other processes to gain CPU time.
     * A problem was found when an OLE app tries to communicate to a
     * background app (via SendMessage) running at the same priority as a
     * background/spinning process.  This will starve the CPU from those
     * processes.  Sleep on every re-cycle of the spin-count.  This will
     * assure that apps doing peeks are degraded.
     *
     */
    if ((pci->dwTIFlags & TIF_SPINNING) && (pci->cSpins >= cSpinLimit)) {
        pci->cSpins = 0;
        NtYieldExecution();
    }

    return FALSE;

lbCallServer:

    return _PeekMessage(lpMsg,
                        hWnd,
                        wMsgFilterMin,
                        wMsgFilterMax,
                        wRemoveMsg,
                        IS_ANSI);
}


#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, LRESULT, APIENTRY, DefWindowProcW, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG4(LOG_GENERAL, LRESULT, APIENTRY, DefWindowProcA, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE
LRESULT APIENTRY DefWindowProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lRet;

    BEGIN_USERAPIHOOK()
        BOOL fOverride = IsMsgOverride(message, &guah.mmDWP);
        if (fOverride) {
            /*
             * This message is being overridden, so we need to callback to
             * the process. During this callback, the override may call the
             * real DWP for processing.
             */

#ifdef UNICODE
            lRet = guah.pfnDefWindowProcW(hwnd, message, wParam, lParam);
#else
            lRet = guah.pfnDefWindowProcA(hwnd, message, wParam, lParam);
#endif
        } else {
            /*
             * This message is not being overridden, so we can just call the
             * real DWP for processing.
             */

#ifdef UNICODE
            lRet = RealDefWindowProcW(hwnd, message, wParam, lParam);
#else
            lRet = RealDefWindowProcA(hwnd, message, wParam, lParam);
#endif
        }

    END_USERAPIHOOK()

    return lRet;
}


LRESULT APIENTRY TEXT_FN(RealDefWindowProc)(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        switch (message) {
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSTATIC:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORMSGBOX:

            /*
             * Draw default colors
             */
            break;
        default:
            return 0;
        }
    }

    return RealDefWindowProcWorker(pwnd, message, wParam, lParam, IS_ANSI);
}


LRESULT APIENTRY TEXT_FN(DispatchDefWindowProc)(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR pfn)
{
    HWND hwnd = KHWND_TO_HWND(GetClientInfo()->CallbackWnd.hwnd);

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(pfn);

    return DefWindowProc(hwnd, message, wParam, lParam);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, LRESULT, APIENTRY, SendMessageW, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG4(LOG_GENERAL, LRESULT, APIENTRY, SendMessageA, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE
LRESULT APIENTRY SendMessage(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (message & RESERVED_MSG_BITS) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"message\" (%ld) to SendMessage",
                message);

        return 0;
    }

    /*
     * Thunk through a special sendmessage for -1 hwnd's so that the general
     * purpose thunks don't allow -1 hwnd's.
     */
    if (hwnd == (HWND)-1 || hwnd == (HWND)0x0000FFFF) {
        /*
         * Get a real hwnd so the thunks will validation ok. Note that since
         * -1 hwnd is really rare, calling GetDesktopWindow() here is not a
         * big deal.
         */
        hwnd = GetDesktopWindow();

        /*
         * Always send broadcast requests straight to the server. Note: if
         * the xParam needs to be used, must update SendMsgTimeout,
         * FNID_SENDMESSAGEFF uses it to id who it is from.
         */
        return CsSendMessage(hwnd,
                             message,
                             wParam,
                             lParam,
                             0L,
                             FNID_SENDMESSAGEFF,
                             IS_ANSI);
    }

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return 0;
    }

    return SendMessageWorker(pwnd, message, wParam, lParam, IS_ANSI);
}


#ifdef UNICODE
FUNCLOG7(LOG_GENERAL, LRESULT, APIENTRY, SendMessageTimeoutW, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam, UINT, fuFlags, UINT, uTimeout, PULONG_PTR, lpdwResult)
#else
FUNCLOG7(LOG_GENERAL, LRESULT, APIENTRY, SendMessageTimeoutA, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam, UINT, fuFlags, UINT, uTimeout, PULONG_PTR, lpdwResult)
#endif // UNICODE
LRESULT APIENTRY SendMessageTimeout(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    PULONG_PTR lpdwResult)
{
    return SendMessageTimeoutWorker(hwnd,
                                    message,
                                    wParam,
                                    lParam,
                                    fuFlags,
                                    uTimeout,
                                    lpdwResult,
                                    IS_ANSI);
}


/***************************************************************************\
* SendDlgItemMessage
*
* Translates the message, calls SendDlgItemMessage on server side. The
* dialog item's ID is passed as the xParam. On the server side, a stub
* rearranges the parameters to put the ID where it belongs and calls
* xxxSendDlgItemMessage.
*
* 04-17-91 DarrinM Created.
\***************************************************************************/

#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, SendDlgItemMessageW, HWND, hwnd, int, id, UINT, message, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, SendDlgItemMessageA, HWND, hwnd, int, id, UINT, message, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE

LRESULT WINAPI SendDlgItemMessage(
    HWND hwnd,
    int id,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    if (hwnd == (HWND)-1 || hwnd == (HWND)0x0000FFFF) {
        return 0;
    }

    if (hwnd = GetDlgItem(hwnd, id)) {
        return SendMessage(hwnd, message, wParam, lParam);
    }

    return 0L;
}

/***************************************************************************\
* GetDlgItemText
*
* History:
*    04 Feb 1992 GregoryW  Neutral ANSI/Unicode version
\***************************************************************************/
#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetDlgItemTextW, HWND, hwnd, int, id, LPTSTR, lpch, int, cchMax)
#else
FUNCLOG4(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetDlgItemTextA, HWND, hwnd, int, id, LPTSTR, lpch, int, cchMax)
#endif // UNICODE

UINT GetDlgItemText(
    HWND hwnd,
    int id,
    LPTSTR lpch,
    int cchMax)
{
    if ((hwnd = GetDlgItem(hwnd, id)) != NULL) {
        return GetWindowText(hwnd, lpch, cchMax);
    }

    /*
     * If we couldn't find the window, just null terminate lpch so that the
     * app doesn't AV if it tries to run through the text.
     */
    if (cchMax) {
        *lpch = (TCHAR)0;
    }

    return 0;
}


/***************************************************************************\
* SetDlgItemText
*
* History:
*    04 Feb 1992 GregoryW  Neutral ANSI/Unicode version
\***************************************************************************/
#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetDlgItemTextW , HWND, hwnd, int, id, LPCTSTR, lpch)
#else
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetDlgItemTextA , HWND, hwnd, int, id, LPCTSTR, lpch)
#endif // UNICODE

BOOL SetDlgItemText(
    HWND hwnd,
    int id,
    LPCTSTR lpch)
{
    if ((hwnd = GetDlgItem(hwnd, id)) != NULL) {
        return SetWindowText(hwnd, lpch);
    }

    return FALSE;
}


#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, int, WINAPI, GetWindowTextW, HWND, hwnd, LPTSTR, lpName, int, nMaxCount)
#else
FUNCLOG3(LOG_GENERAL, int, WINAPI, GetWindowTextA, HWND, hwnd, LPTSTR, lpName, int, nMaxCount)
#endif // UNICODE

int WINAPI GetWindowText(
    HWND hwnd,
    LPTSTR lpName,
    int nMaxCount)
{
    PWND pwnd;

    /*
     * Don't try to fill a non-existent buffer
     */
    if (lpName == NULL || nMaxCount == 0) {
        return 0;
    }

    try {
        /*
         * Initialize string empty, in case SendMessage aborts validation
         */
        *lpName = TEXT('\0');

        /*
         * Make sure we have a valid window.
         */
        if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
            return 0;
        }

        /*
         * This process comparison is bogus, but it is what win3.1 does.
         */
        if (TestWindowProcess(pwnd)) {
            return (int)SendMessageWorker(pwnd, WM_GETTEXT, nMaxCount, (LPARAM)lpName, IS_ANSI);
        } else {
            return (int)DefWindowProcWorker(pwnd, WM_GETTEXT, nMaxCount, (LPARAM)lpName, IS_ANSI);
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hwnd);
        return 0;
    }
}

#ifdef UNICODE
FUNCLOG1(LOG_GENERAL, int, WINAPI, GetWindowTextLengthW, HWND, hwnd)
#else
FUNCLOG1(LOG_GENERAL, int, WINAPI, GetWindowTextLengthA, HWND, hwnd)
#endif // UNICODE
int WINAPI GetWindowTextLength(
    HWND hwnd)
{
    PWND pwnd;

    /*
     * Make sure we have a valid window.
     */
    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return 0;
    }

    /*
     * This process comparison is bogus, but it is what win3.1 does.
     */
    if (TestWindowProcess(pwnd)) {
        return (int)SendMessageWorker(pwnd, WM_GETTEXTLENGTH, 0, 0, IS_ANSI);
    } else {
        return (int)DefWindowProcWorker(pwnd, WM_GETTEXTLENGTH, 0, 0, IS_ANSI);
    }
}


#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, SetWindowTextW , HWND, hwnd, LPCTSTR, pString)
#else
FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, SetWindowTextA , HWND, hwnd, LPCTSTR, pString)
#endif // UNICODE
BOOL WINAPI SetWindowText(
    HWND hwnd,
    LPCTSTR pString)
{
    LRESULT lReturn;
    PWND pwnd;

    /*
     * Make sure we have a valid window.
     */
    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return FALSE;
    }

    /*
     * This process comparison is bogus, but it is what win3.1 does.
     */
    if (TestWindowProcess(pwnd)) {
        lReturn = SendMessageWorker(pwnd, WM_SETTEXT, 0, (LPARAM)pString, IS_ANSI);
    } else {
        lReturn = DefWindowProcWorker(pwnd, WM_SETTEXT, 0, (LPARAM)pString, IS_ANSI);
    }
    return (lReturn >= 0);
}


LRESULT APIENTRY DispatchMessage(CONST MSG *lpMsg)
{
    extern LRESULT DispatchMessageWorker(CONST MSG *lpMsg, BOOL fAnsi);

    return DispatchMessageWorker(lpMsg, IS_ANSI);
}

#if IS_ANSI
VOID CopyLogFontAtoW(
    PLOGFONTW pdest,
    PLOGFONTA psrc)
{
    LPSTR lpstrFont = (LPSTR)(&psrc->lfFaceName);
    LPWSTR lpstrFontW = (LPWSTR)(&pdest->lfFaceName);

    RtlCopyMemory((LPBYTE)pdest, psrc, sizeof(LOGFONTA) - LF_FACESIZE);
    RtlZeroMemory(pdest->lfFaceName, LF_FACESIZE * sizeof(WCHAR));
    MBToWCS(lpstrFont, -1, &lpstrFontW, LF_FACESIZE, FALSE);
}

VOID CopyLogFontWtoA(
    PLOGFONTA pdest,
    PLOGFONTW psrc)
{
    LPSTR lpstrFont = (LPSTR)(&pdest->lfFaceName);

    RtlCopyMemory((LPBYTE)pdest, (LPBYTE)psrc, sizeof(LOGFONTA) - LF_FACESIZE);
    RtlZeroMemory(pdest->lfFaceName, LF_FACESIZE);
    WCSToMB(psrc->lfFaceName, -1, &lpstrFont, LF_FACESIZE, FALSE);
}
#else

/**************************************************************************\
* SetVideoTimeout
*
* Updates the video timeout values in the current power profile.
*
* 15-Apr-1999 JerrySh   Created.
\**************************************************************************/

typedef BOOLEAN (*PFNGETACTIVEPWRSCHEME)(PUINT);
typedef BOOLEAN (*PFNSETACTIVEPWRSCHEME)(UINT, PGLOBAL_POWER_POLICY, PPOWER_POLICY);
typedef BOOLEAN (*PFNREADPWRSCHEME)(UINT, PPOWER_POLICY);

BOOL SetVideoTimeout(
    DWORD dwVideoTimeout)
{
    POWER_POLICY pp;
    UINT uiID;
    BOOL fRet = FALSE;

    if (GetActivePwrScheme(&uiID)) {
        if (ReadPwrScheme(uiID, &pp)) {
            pp.user.VideoTimeoutDc = dwVideoTimeout;
            pp.user.VideoTimeoutAc = dwVideoTimeout;

            fRet = SetActivePwrScheme(uiID, NULL, &pp);
        }
    }

    return fRet;
}
#endif

/***************************************************************************\
* SystemParametersInfo
*
*
\***************************************************************************/

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, SystemParametersInfoW, UINT, wFlag, UINT, wParam, PVOID, lParam, UINT, flags)
#else
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, SystemParametersInfoA, UINT, wFlag, UINT, wParam, PVOID, lParam, UINT, flags)
#endif // UINCODE
BOOL APIENTRY SystemParametersInfo(
    UINT wFlag,
    UINT wParam,
    PVOID lParam,
    UINT flags)
{
    BOOL bRet;

    BEGIN_USERAPIHOOK()
#ifdef UNICODE
        bRet = guah.pfnSystemParametersInfoW(wFlag, wParam, lParam, flags);
#else
        bRet = guah.pfnSystemParametersInfoA(wFlag, wParam, lParam, flags);
#endif
    END_USERAPIHOOK()

    return bRet;
}

BOOL APIENTRY TEXT_FN(RealSystemParametersInfo)(
    UINT wFlag,
    UINT wParam,
    PVOID lParam,
    UINT flags)
{
#if IS_ANSI
    NONCLIENTMETRICSW ClientMetricsW;
    ICONMETRICSW      IconMetricsW;
    LOGFONTW          LogFontW;
    WCHAR             szTemp[MAX_PATH];
    UINT              oldwParam = wParam;
#endif
    INTERNALSETHIGHCONTRAST ihc;
    IN_STRING         strlParam;
    PVOID             oldlParam = lParam;

    /*
     * Make sure cleanup will work successfully
     */
    strlParam.fAllocated = FALSE;

    BEGINCALL();

    switch (wFlag) {
    case SPI_SETSCREENSAVERRUNNING:     // same as SPI_SCREENSAVERRUNNING
        MSGERROR();

    case SPI_SETDESKPATTERN:
        if (wParam == 0x0000FFFF) {
            wParam = (UINT)-1;
        }

        /*
         * lParam not a string (and already copied).
         */
        if (wParam == (UINT)-1) {
            break;
        }

        /*
         * lParam is possibly 0 or -1 (filled in already) or a string.
         */
        if (lParam != (PVOID)0 && lParam != (PVOID)-1) {
            COPYLPTSTR(&strlParam, (LPTSTR)lParam);
            lParam = strlParam.pstr;
        }
        break;

    case SPI_SETDESKWALLPAPER: {

            /*
             * lParam is possibly 0, -1 or -2 (filled in already) or a string.
             * Get a pointer to the string so we can use it later.  We're
             * going to a bit of normalizing here for consistency.
             *
             * If the caller passes in 0, -1 or -2, we're going to set
             * the wParam to -1, and use the lParam to pass the string
             * representation of the wallpaper.
             */
            if ((lParam != (PVOID) 0) &&
                (lParam != (PVOID)-1) &&
                (lParam != (PVOID)-2)) {

                COPYLPTSTR(&strlParam, (LPTSTR)lParam);
                lParam = strlParam.pstr;
                wParam = 0;

            } else {
                wParam = (UINT)-1;
            }
        }
        break;

    /*
     * Bug 257718 - joejo
     * Add SPI_GETDESKWALLPAPER to SystemParametersInfo
     */
    case SPI_GETDESKWALLPAPER:
        if ((lParam == NULL) || (wParam == 0))
            MSGERROR();
#if IS_ANSI
        lParam = szTemp;
        wParam = ARRAY_SIZE(szTemp);
#else
        /*
         * Bug 283318 - joejo
         * Leave space for a null termination
         */
        wParam--;
#endif

        break;


    case SPI_GETANIMATION:
        if (lParam == NULL || *((DWORD *)(lParam)) != sizeof(ANIMATIONINFO)) {
            MSGERROR();
        }
        break;

    case SPI_GETNONCLIENTMETRICS:
#if IS_ANSI
        if (lParam == NULL || *((DWORD *)(lParam)) != sizeof(NONCLIENTMETRICSA)) {
            MSGERROR();
        }
        lParam = &ClientMetricsW;
#else
        if (lParam == NULL || *((DWORD *)(lParam)) != sizeof(NONCLIENTMETRICSW)) {
            MSGERROR();
        }
#endif
        break;

    case SPI_GETMINIMIZEDMETRICS:
        if (lParam == NULL || *((DWORD *)(lParam)) != sizeof(MINIMIZEDMETRICS)) {
            MSGERROR();
        }
        break;

    case SPI_GETICONMETRICS:
#if IS_ANSI
        if (lParam == NULL || *((DWORD *)(lParam)) != sizeof(ICONMETRICSA)) {
            MSGERROR();
        }
        lParam = &IconMetricsW;
#else
        if (lParam == NULL || *((DWORD *)(lParam)) != sizeof(ICONMETRICSW)) {
            MSGERROR();
        }
#endif
        break;

    case SPI_GETHIGHCONTRAST:
#if IS_ANSI
        {
            LPHIGHCONTRASTA pHC = (HIGHCONTRASTA *)lParam;
            if (!pHC || pHC->cbSize != sizeof(HIGHCONTRASTA)) {
                MSGERROR();
            }

            if (!pcHighContrastScheme) {
                pcHighContrastScheme = UserLocalAlloc(HEAP_ZERO_MEMORY,
                                                      MAX_SCHEME_NAME_SIZE * sizeof(WCHAR));
                if (!pcHighContrastScheme) {
                    MSGERROR();
                }
            }

            if (!pwcHighContrastScheme) {
                pwcHighContrastScheme = UserLocalAlloc(HEAP_ZERO_MEMORY,
                                                       MAX_SCHEME_NAME_SIZE * sizeof(WCHAR));
                if (!pwcHighContrastScheme) {
                    MSGERROR();
                }
            }
            ((LPHIGHCONTRASTW)(lParam))->lpszDefaultScheme = pwcHighContrastScheme;
        }
#else
        {
            LPHIGHCONTRASTW pHC = (HIGHCONTRASTW *)lParam;
            if (!pHC || (pHC->cbSize != sizeof(HIGHCONTRASTW))) {
                MSGERROR();
            }
            if (!pwcHighContrastScheme) {
                pwcHighContrastScheme = UserLocalAlloc(HEAP_ZERO_MEMORY,
                                                       MAX_SCHEME_NAME_SIZE * sizeof(WCHAR));
                if (!pwcHighContrastScheme) {
                    MSGERROR();
                }
            }
            pHC->lpszDefaultScheme = pwcHighContrastScheme;
        }
#endif

        break;

#if IS_ANSI
    case SPI_GETICONTITLELOGFONT:
        lParam = &LogFontW;
        break;
#endif

    case SPI_SETANIMATION:
        if (lParam == NULL || *((DWORD *)lParam) != sizeof(ANIMATIONINFO)) {
            MSGERROR();
        }
        break;

    case SPI_SETHIGHCONTRAST:
        ihc.cbSize = sizeof (HIGHCONTRASTW);
        {
            LPHIGHCONTRAST pHC = (HIGHCONTRAST *)lParam;
            if (lParam == NULL || pHC->cbSize != sizeof(HIGHCONTRAST)) {
                MSGERROR();
            }

            lParam = &ihc;
            ihc.dwFlags = pHC->dwFlags;
            COPYLPTSTR(&strlParam, pHC->lpszDefaultScheme);
            ihc.usDefaultScheme = *strlParam.pstr;
        }
        break;

    case SPI_SETNONCLIENTMETRICS:
        {
            PNONCLIENTMETRICS psrc = (PNONCLIENTMETRICS)lParam;

            if (lParam == NULL || *((DWORD *)(lParam)) != sizeof(NONCLIENTMETRICS)) {
                MSGERROR();
            }

            if (psrc->iCaptionWidth > 256) {
                psrc->iCaptionWidth = 256;
            }

            if (psrc->iCaptionHeight > 256) {
                psrc->iCaptionHeight = 256;
            }

#if IS_ANSI
            ClientMetricsW.cbSize           = psrc->cbSize;
            ClientMetricsW.iBorderWidth     = psrc->iBorderWidth;
            ClientMetricsW.iScrollWidth     = psrc->iScrollWidth;
            ClientMetricsW.iScrollHeight    = psrc->iScrollHeight;
            ClientMetricsW.iCaptionWidth    = psrc->iCaptionWidth;
            ClientMetricsW.iCaptionHeight   = psrc->iCaptionHeight;
            ClientMetricsW.iSmCaptionWidth  = psrc->iSmCaptionWidth;
            ClientMetricsW.iSmCaptionHeight = psrc->iSmCaptionHeight;
            ClientMetricsW.iMenuWidth       = psrc->iMenuWidth;
            ClientMetricsW.iMenuHeight      = psrc->iMenuHeight;

            CopyLogFontAtoW(&(ClientMetricsW.lfCaptionFont), &(psrc->lfCaptionFont));
            CopyLogFontAtoW(&(ClientMetricsW.lfSmCaptionFont), &(psrc->lfSmCaptionFont));
            CopyLogFontAtoW(&(ClientMetricsW.lfMenuFont), &(psrc->lfMenuFont));
            CopyLogFontAtoW(&(ClientMetricsW.lfStatusFont), &(psrc->lfStatusFont));
            CopyLogFontAtoW(&(ClientMetricsW.lfMessageFont), &(psrc->lfMessageFont));

            lParam = &ClientMetricsW;
#endif

            wParam = sizeof(NONCLIENTMETRICSW);
        }
        break;

    case SPI_SETMINIMIZEDMETRICS:
        if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(MINIMIZEDMETRICS)))
            MSGERROR();
        wParam = sizeof(MINIMIZEDMETRICS);
        break;

    case SPI_SETICONMETRICS:
#if IS_ANSI
        {
            PICONMETRICSA psrc = (PICONMETRICSA)lParam;

            if (lParam == NULL || *((DWORD *)(lParam)) != sizeof(ICONMETRICSA)) {
                MSGERROR();
            }

            RtlCopyMemory(&IconMetricsW, psrc, sizeof(ICONMETRICSA) - sizeof(LOGFONTA));

            CopyLogFontAtoW(&(IconMetricsW.lfFont), &(psrc->lfFont));
            lParam = &IconMetricsW;
        }
#else
        if (lParam == NULL || *((DWORD *)(lParam)) != sizeof(ICONMETRICSW)) {
            MSGERROR();
        }
#endif
        wParam = sizeof(ICONMETRICSW);
        break;

    case SPI_SETICONTITLELOGFONT:
#if IS_ANSI
        CopyLogFontAtoW(&LogFontW, lParam);
        lParam = &LogFontW;
#endif
        wParam = sizeof(LOGFONTW);
        break;

    case SPI_GETFILTERKEYS:
        {
            if ((((LPFILTERKEYS)lParam)->cbSize == 0) ||
                    (((LPFILTERKEYS)lParam)->cbSize) > sizeof(FILTERKEYS)) {
                MSGERROR();
            }
        }
        break;

    case SPI_GETSTICKYKEYS:
        {
            if ((((LPSTICKYKEYS)lParam)->cbSize == 0) ||
                    (((LPSTICKYKEYS)lParam)->cbSize) > sizeof(STICKYKEYS)) {
                MSGERROR();
            }
        }
        break;

    case SPI_GETTOGGLEKEYS:
        {
            if ((((LPTOGGLEKEYS)lParam)->cbSize == 0) ||
                    (((LPTOGGLEKEYS)lParam)->cbSize) > sizeof(TOGGLEKEYS)) {
                MSGERROR();
            }
        }
        break;

    case SPI_GETMOUSEKEYS:
        {
            if ((((LPMOUSEKEYS)lParam)->cbSize == 0) ||
                    (((LPMOUSEKEYS)lParam)->cbSize) > sizeof(MOUSEKEYS)) {
                MSGERROR();
            }
        }
        break;

    case SPI_GETACCESSTIMEOUT:
        {
            if ((((LPACCESSTIMEOUT)lParam)->cbSize == 0) ||
                    (((LPACCESSTIMEOUT)lParam)->cbSize) > sizeof(ACCESSTIMEOUT)) {
                MSGERROR();
            }
        }
        break;

    case SPI_GETSOUNDSENTRY:
        if ((((LPSOUNDSENTRY)lParam)->cbSize == 0) ||
                (((LPSOUNDSENTRY)lParam)->cbSize) > sizeof(SOUNDSENTRY)) {
            MSGERROR();
        }
        break;
    }

    retval = NtUserSystemParametersInfo(wFlag, wParam, lParam, flags);

    switch (wFlag) {
#if IS_ANSI
    case SPI_GETNONCLIENTMETRICS:
        {
            PNONCLIENTMETRICSA pdst = (PNONCLIENTMETRICSA)oldlParam;

            pdst->cbSize           = sizeof(NONCLIENTMETRICSA);
            pdst->iBorderWidth     = ClientMetricsW.iBorderWidth;
            pdst->iScrollWidth     = ClientMetricsW.iScrollWidth;
            pdst->iScrollHeight    = ClientMetricsW.iScrollHeight;
            pdst->iCaptionWidth    = ClientMetricsW.iCaptionWidth;
            pdst->iCaptionHeight   = ClientMetricsW.iCaptionHeight;
            pdst->iSmCaptionWidth  = ClientMetricsW.iSmCaptionWidth;
            pdst->iSmCaptionHeight = ClientMetricsW.iSmCaptionHeight;
            pdst->iMenuWidth       = ClientMetricsW.iMenuWidth;
            pdst->iMenuHeight      = ClientMetricsW.iMenuHeight;

            CopyLogFontWtoA(&(pdst->lfCaptionFont), &(ClientMetricsW.lfCaptionFont));
            CopyLogFontWtoA(&(pdst->lfSmCaptionFont), &(ClientMetricsW.lfSmCaptionFont));
            CopyLogFontWtoA(&(pdst->lfMenuFont), &(ClientMetricsW.lfMenuFont));
            CopyLogFontWtoA(&(pdst->lfStatusFont), &(ClientMetricsW.lfStatusFont));
            CopyLogFontWtoA(&(pdst->lfMessageFont), &(ClientMetricsW.lfMessageFont));
        }
        break;

    case SPI_GETICONMETRICS:
        {
            PICONMETRICSA pdst = (PICONMETRICSA)oldlParam;

            RtlCopyMemory(pdst, &IconMetricsW, sizeof(ICONMETRICSA) - sizeof(LOGFONTA));
            pdst->cbSize = sizeof(ICONMETRICSA);

            CopyLogFontWtoA(&(pdst->lfFont), &(IconMetricsW.lfFont));
        }
        break;

    case SPI_GETICONTITLELOGFONT:
        CopyLogFontWtoA((PLOGFONTA)oldlParam, &LogFontW);
        break;

    case SPI_GETHIGHCONTRAST:
        WCSToMB(pwcHighContrastScheme, -1, &pcHighContrastScheme, MAX_SCHEME_NAME_SIZE, FALSE);
        ((LPHIGHCONTRASTA)(lParam))->lpszDefaultScheme = pcHighContrastScheme;
        break;

#endif

    case SPI_GETDESKWALLPAPER:
        {
#if IS_ANSI
            INT cchAnsiCopy = WCSToMB(lParam,
                                      -1,
                                      (LPSTR*)&oldlParam,
                                      oldwParam - 1,
                                      FALSE);

            cchAnsiCopy = min(cchAnsiCopy, (INT)(oldwParam - 1));
            ((LPSTR)oldlParam)[cchAnsiCopy] = 0;
#else
            ((LPWSTR)oldlParam)[wParam] = (WCHAR)0;
#endif
            break;
        }
    case SPI_SETLOWPOWERTIMEOUT:
    case SPI_SETPOWEROFFTIMEOUT:
        if (retval && (flags & SPIF_UPDATEINIFILE)) {
            retval = SetVideoTimeout(wParam);
        }
        break;
    }

    ERRORTRAP(FALSE);
    CLEANUPLPTSTR(strlParam);
    ENDCALL(BOOL);
}


#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, HANDLE, APIENTRY, GetPropW, HWND, hwnd, LPCTSTR, pString)
#else
FUNCLOG2(LOG_GENERAL, HANDLE, APIENTRY, GetPropA, HWND, hwnd, LPCTSTR, pString)
#endif // UNICODE
HANDLE APIENTRY GetProp(HWND hwnd, LPCTSTR pString)
{
    PWND pwnd;
    int iString;

    if (IS_PTR(pString)) {
        iString = (int)GlobalFindAtom(pString);
        if (iString == 0)
            return NULL;
    } else
        iString = PTR_TO_ID(pString);

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return NULL;

    return _GetProp(pwnd, (LPWSTR)UIntToPtr( iString ), FALSE);
}


/***************************************************************************\
* RegisterClassW(API)
*
* History:
* 28-Jul-1992 ChandanC Created.
\***************************************************************************/
ATOM
WINAPI
TEXT_FN(RegisterClass)(
    CONST WNDCLASS *lpWndClass )
{
    WNDCLASSEX wc;

    /*
     * On 64-bit plaforms we'll have 32-bits of padding between style and
     * lpfnWndProc in WNDCLASS, so start the copy from the first 64-bit
     * aligned field and hand copy the rest.
     */
    RtlCopyMemory(&(wc.lpfnWndProc), &(lpWndClass->lpfnWndProc), sizeof(WNDCLASS) - FIELD_OFFSET(WNDCLASS, lpfnWndProc));
    wc.style = lpWndClass->style;
    wc.hIconSm = NULL;
    wc.cbSize = sizeof(WNDCLASSEX);

    return TEXT_FN(RegisterClassExWOW)(&wc, NULL, 0, CSF_VERSIONCLASS);
}

/***************************************************************************\
* RegisterClassExW(API)
*
* History:
* 28-Jul-1992 ChandanC Created.
\***************************************************************************/
ATOM
WINAPI
TEXT_FN(RegisterClassEx)(
    CONST WNDCLASSEX *lpWndClass)
{
    if (lpWndClass->cbSize != sizeof(WNDCLASSEX)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "RegisterClassEx: cbsize is wrong %lX",
                lpWndClass->cbSize);

        return 0;
    } else {
        return TEXT_FN(RegisterClassExWOW)((LPWNDCLASSEX)lpWndClass,
                NULL, 0, CSF_VERSIONCLASS);
    }
}

/***************************************************************************\
* GetMenuItemInfoInternal
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
BOOL TEXT_FN(GetMenuItemInfoInternal) (HMENU hMenu, UINT uID, BOOL fByPosition,
    LPMENUITEMINFOW lpInfo)
{
     PITEM pItem;
     PMENU pMenu;
     PMENU pMenuT;

     pMenu = VALIDATEHMENU(hMenu);
     if (pMenu == NULL) {
        VALIDATIONFAIL(hMenu);
     }

     pMenuT = pMenu;         // need to check the ORIGINAL menu if popup

     pItem = MNLookUpItem(pMenu, uID, fByPosition, &pMenu);
    if (pItem == NULL) {
        /*
         * Don't display a warning. The explorer makes a lot of calls
         *  that fail here.
         * VALIDATIONFAIL(uID);
         */
        SetLastError(ERROR_MENU_ITEM_NOT_FOUND);
        return FALSE;

    }

    if (lpInfo->fMask & MIIM_STATE) {
        lpInfo->fState = pItem->fState & MFS_MASK;
    }

    if (lpInfo->fMask & MIIM_ID) {
        lpInfo->wID = pItem->wID;
    }

    if ((lpInfo->fMask & MIIM_SUBMENU) && (pItem->spSubMenu != NULL)) {
        lpInfo->hSubMenu = PtoH(REBASEPTR(pMenu, pItem->spSubMenu));
    } else {
        lpInfo->hSubMenu = NULL;
    }

    if (lpInfo->fMask & MIIM_CHECKMARKS) {
        lpInfo->hbmpChecked  = KHBITMAP_TO_HBITMAP(pItem->hbmpChecked);
        lpInfo->hbmpUnchecked= KHBITMAP_TO_HBITMAP(pItem->hbmpUnchecked);
    }

    if (lpInfo->fMask & MIIM_DATA) {
       lpInfo->dwItemData = KERNEL_ULONG_PTR_TO_ULONG_PTR(pItem->dwItemData);
    }

    if (lpInfo->fMask & MIIM_FTYPE) {
        lpInfo->fType = pItem->fType & MFT_MASK;
        if (TestMF(pMenuT,MFRTL))
            lpInfo->fType |= MFT_RIGHTORDER;
    }

    if ( lpInfo->fMask & MIIM_BITMAP) {
        lpInfo->hbmpItem = KHBITMAP_TO_HBITMAP(pItem->hbmp);
    }

    if (lpInfo->fMask & MIIM_STRING) {
        if ((lpInfo->cch == 0)
            || (lpInfo->dwTypeData == NULL)

            /*
             * If this is an old caller (MIIM_TYPE set), and this item
             *  has a bitmap or it's ownerdraw, then don't attempt to
             *  copy a string since they probably didn't pass a pointer
            */

            || ((lpInfo->fMask & MIIM_TYPE)
                    && ((lpInfo->fType & MFT_OWNERDRAW)
                            /*
                             * Bug 278750 - jojoe
                             *
                             * Soemone forgot to check for separator in the list
                             * of menuitems that do NOT return string data!
                             */
                            || (lpInfo->fType & MFT_SEPARATOR)
                            || ((pItem->hbmp != NULL)  && ((pItem->hbmp < HBMMENU_POPUPFIRST) || (pItem->hbmp > HBMMENU_POPUPLAST)))))) {



            /*
             * When DBCS is enabled, one UNICODE character may occupy two bytes.
             * GetMenuItemInfoA should return the byte count, rather than the character count.
             * On NT5, pItem->lpstr is guaranteed to be a valid string, if it is not NULL.
             */
            if (IS_ANSI && IS_DBCS_ENABLED() && pItem->lpstr != NULL) {
                NTSTATUS Status;
                ULONG cch;

                Status = RtlUnicodeToMultiByteSize(&cch, REBASEPTR(pMenu, pItem->lpstr), pItem->cch * sizeof(WCHAR));
                UserAssert(NT_SUCCESS(Status)); // RtlUnicodeToMultiByteSize is not expected to fail
                lpInfo->cch = cch;
            } else {
                lpInfo->cch = pItem->cch;
            }
            lpInfo->dwTypeData = NULL;


        } else {
            int cch = 0;

            if (pItem->lpstr != NULL) {

                // originally:
                // cch = min(lpInfo->cch - 1, (pItem->cch * sizeof(WORD)));
                cch = pItem->cch;
                UserAssert(cch >= 0);
                if (IS_DBCS_ENABLED()) {
                    /* pItem->cch contains Unicode character counts,
                     * we guess max DBCS string size for the Unicode string.
                     */
                    cch *= DBCS_CHARSIZE;
                }
                cch = min(lpInfo->cch - 1, (DWORD)cch);

#if IS_ANSI
                cch = WCSToMB(REBASEPTR(pMenu, pItem->lpstr), pItem->cch,
                        (LPSTR *)&(lpInfo->dwTypeData), cch, FALSE);
#else
                wcsncpy(lpInfo->dwTypeData, (LPWSTR)REBASEPTR(pMenu, pItem->lpstr),
    cch);
#endif
            }

#if IS_ANSI
            *((LPSTR)lpInfo->dwTypeData + cch) = (CHAR)0;
#else
            *(lpInfo->dwTypeData + cch) = (WCHAR)0;
#endif
            lpInfo->cch = cch;
        }
     }

     return TRUE;

     VALIDATIONERROR(FALSE);

}
/***************************************************************************\
* GetMenuString()
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetMenuStringW, HMENU, hMenu, UINT, wID, LPTSTR, lpsz, int, cchMax, UINT, flags)
#else
FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetMenuStringA, HMENU, hMenu, UINT, wID, LPTSTR, lpsz, int, cchMax, UINT, flags)
#endif // UNICODE
int GetMenuString(HMENU hMenu, UINT wID, LPTSTR lpsz, int cchMax, UINT flags)
{
    MENUITEMINFOW    miiLocal;

    miiLocal.fMask      = MIIM_STRING;
    miiLocal.dwTypeData = (LPWSTR)lpsz;
    miiLocal.cch        = cchMax;

    if (cchMax != 0) {
        *lpsz = (TCHAR)0;
    }

    if (TEXT_FN(GetMenuItemInfoInternal)(hMenu, wID, (BOOL)(flags & MF_BYPOSITION), &miiLocal)) {
        return miiLocal.cch;
    } else {
        return 0;
    }
}

/***************************************************************************\
* GetMenuItemInfo
*
*  1) converts a MENUITEMINFO95 or a new-MENUITEMINFO-with-old-flags to a new
*     MENUITEMINFO -- this way all internal code can assume one look for the
*     structure
*  2) calls the internal GetMenuItemInfo which performs validation and work
*  3) converts the new MENUITEMINFO back to the original MENUITEMINFO
*
* History:
*  07-22-96 GerardoB - Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetMenuItemInfoW, HMENU, hMenu, UINT, wID, BOOL, fByPos, LPMENUITEMINFO, lpmii)
#else
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetMenuItemInfoA, HMENU, hMenu, UINT, wID, BOOL, fByPos, LPMENUITEMINFO, lpmii)
#endif // UNICODE

BOOL GetMenuItemInfo(HMENU hMenu, UINT wID, BOOL fByPos, LPMENUITEMINFO lpmii)
{
    UINT cbCallercbSize = lpmii->cbSize;
    MENUITEMINFOW miiLocal;


    if (!ValidateMENUITEMINFO((LPMENUITEMINFOW)lpmii, &miiLocal, MENUAPI_GET)) {
        return FALSE;
    }

    if (!TEXT_FN(GetMenuItemInfoInternal)(hMenu, wID, fByPos, &miiLocal)) {
        return FALSE;
    }

    /*
     * Copy the structure and map old flags back. Only requested fields were
     *   modified, so it's OK  to copy all fields back.
     */
    RtlCopyMemory(lpmii, &miiLocal, SIZEOFMENUITEMINFO95);
    lpmii->cbSize = cbCallercbSize;
    if (cbCallercbSize > SIZEOFMENUITEMINFO95) {
        lpmii->hbmpItem = miiLocal.hbmpItem;
    }

    if (lpmii->fMask & MIIM_TYPE) {
        if ((miiLocal.hbmpItem != NULL) && (miiLocal.dwTypeData == NULL)) {
            lpmii->fType |= MFT_BITMAP;
            lpmii->dwTypeData = (LPTSTR)miiLocal.hbmpItem;
        } else if (miiLocal.cch == 0) {
            lpmii->dwTypeData = NULL;
        }
        lpmii->fMask &= ~(MIIM_FTYPE | MIIM_BITMAP | MIIM_STRING);
    }

    return TRUE;
}
/***************************************************************************\
* SetMenuItemInfo
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetMenuItemInfoW, HMENU, hMenu, UINT, uID, BOOL, fByPosition, LPCMENUITEMINFO, lpmii)
#else
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetMenuItemInfoA, HMENU, hMenu, UINT, uID, BOOL, fByPosition, LPCMENUITEMINFO, lpmii)
#endif // UNICODE
BOOL SetMenuItemInfo(HMENU hMenu, UINT uID, BOOL fByPosition, LPCMENUITEMINFO lpmii)
{

    MENUITEMINFOW miiLocal;

    if (!ValidateMENUITEMINFO((LPMENUITEMINFOW)lpmii, &miiLocal, MENUAPI_SET)) {
        return FALSE;
    }

    return (ThunkedMenuItemInfo(hMenu, uID, fByPosition, FALSE, &miiLocal, IS_ANSI));
}
/***************************************************************************\
* InsertMenuItem
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
BOOL InsertMenuItem (HMENU hMenu, UINT uID, BOOL fByPosition, LPCMENUITEMINFO lpmii)
{

    MENUITEMINFOW miiLocal;

    if (!ValidateMENUITEMINFO((LPMENUITEMINFOW)lpmii, &miiLocal, MENUAPI_SET)) {
        return FALSE;
    }

    return (ThunkedMenuItemInfo(hMenu, uID, fByPosition, TRUE, &miiLocal, IS_ANSI));
}

/***************************************************************************\
* InsertMenu
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, InsertMenuW, HMENU, hMenu, UINT, uPosition, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#else
FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, InsertMenuA, HMENU, hMenu, UINT, uPosition, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#endif // UNICODE
BOOL InsertMenu(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCTSTR lpNewItem)
{
    MENUITEMINFOW miiLocal;

    SetMenuItemInfoStruct(hMenu, uFlags, uIDNewItem, (LPWSTR)lpNewItem, &miiLocal);
    return ThunkedMenuItemInfo(hMenu, uPosition, (BOOL) (uFlags & MF_BYPOSITION), TRUE, (LPMENUITEMINFOW)&miiLocal, IS_ANSI);
}

/***************************************************************************\
* AppendMenu
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, AppendMenuW, HMENU, hMenu, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#else
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, AppendMenuA, HMENU, hMenu, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#endif // UNICODE
BOOL AppendMenu(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCTSTR lpNewItem)
{
    MENUITEMINFOW miiLocal;

    SetMenuItemInfoStruct(hMenu, uFlags, uIDNewItem, (LPWSTR)lpNewItem, &miiLocal);
    return ThunkedMenuItemInfo(hMenu, MFMWFP_NOITEM, MF_BYPOSITION, TRUE, (LPMENUITEMINFOW)&miiLocal, IS_ANSI);
}
/***************************************************************************\
* ModifyMenu
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ModifyMenuW, HMENU, hMenu, UINT, uPosition, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#else
FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ModifyMenuA, HMENU, hMenu, UINT, uPosition, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#endif // UNICODE
BOOL ModifyMenu(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCTSTR lpNewItem)
{
    MENUITEMINFOW miiLocal;

    SetMenuItemInfoStruct(hMenu, uFlags, uIDNewItem, (LPWSTR)lpNewItem, &miiLocal);
    return ThunkedMenuItemInfo(hMenu, uPosition, (BOOL) (uFlags & MF_BYPOSITION), FALSE, (LPMENUITEMINFOW)&miiLocal, IS_ANSI);
}

#ifdef UNICODE
FUNCLOG6(LOG_GENERAL, LONG, WINUSERAPI, BroadcastSystemMessageExW, DWORD, dwFlags, LPDWORD, lpdwRecipients, UINT, uiMessage, WPARAM, wParam, LPARAM, lParam, PBSMINFO, pBSMInfo)
#else
FUNCLOG6(LOG_GENERAL, LONG, WINUSERAPI, BroadcastSystemMessageExA, DWORD, dwFlags, LPDWORD, lpdwRecipients, UINT, uiMessage, WPARAM, wParam, LPARAM, lParam, PBSMINFO, pBSMInfo)
#endif // UNICODE

/***************************************************************************\
* BroadcastSystemMessageEx
*
* History:
*
\***************************************************************************/
WINUSERAPI LONG BroadcastSystemMessageEx(
    DWORD dwFlags,
    LPDWORD lpdwRecipients,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pBSMInfo)
{
    return BroadcastSystemMessageWorker(dwFlags,
                                        lpdwRecipients,
                                        uiMessage,
                                        wParam,
                                        lParam,
                                        pBSMInfo,
                                        IS_ANSI);
}

#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, LONG, WINUSERAPI, BroadcastSystemMessageW, DWORD, dwFlags, LPDWORD, lpdwRecipients, UINT, uiMessage, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG5(LOG_GENERAL, LONG, WINUSERAPI, BroadcastSystemMessageA, DWORD, dwFlags, LPDWORD, lpdwRecipients, UINT, uiMessage, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE

/***************************************************************************\
* BroadcastSystemMessage
*
* History:
*  07-22-96 GerardoB - Added header
\***************************************************************************/
WINUSERAPI LONG BroadcastSystemMessage(
    DWORD dwFlags,
    LPDWORD lpdwRecipients,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam)
{
    return BroadcastSystemMessageWorker(dwFlags,
                                        lpdwRecipients,
                                        uiMessage,
                                        wParam,
                                        lParam,
                                        NULL,
                                        IS_ANSI);
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, UINT, WINUSERAPI, GetWindowModuleFileNameW, HWND, hwnd, LPTSTR, pszFileName, UINT, cchFileNameMax)
#else
FUNCLOG3(LOG_GENERAL, UINT, WINUSERAPI, GetWindowModuleFileNameA, HWND, hwnd, LPTSTR, pszFileName, UINT, cchFileNameMax)
#endif // UNICODE

WINUSERAPI UINT WINAPI
GetWindowModuleFileName(
    HWND hwnd,
    LPTSTR pszFileName,
    UINT cchFileNameMax)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL) {
        return 0;
    }

    return GetModuleFileName(KHANDLE_TO_HANDLE(pwnd->hModule),
                             pszFileName,
                             cchFileNameMax);
}

/***************************************************************************\
* RegisterDeviceNotification
*
* History:
*  01-23-97 PaulaT - Added header
\***************************************************************************/
WINUSERAPI HDEVNOTIFY WINAPI
RegisterDeviceNotification(
    IN HANDLE hRecipient,
    IN LPVOID NotificationFilter,
    IN DWORD Flags)
{
    extern HDEVNOTIFY RegisterDeviceNotificationWorker(IN HANDLE hRecipient,
                                                       IN LPVOID NotificationFilter,
                                                       IN DWORD Flags);

    // translate strings in NotificationFilter (if any)

    return RegisterDeviceNotificationWorker(hRecipient,
                                            NotificationFilter,
                                            Flags);
}



/***************************************************************************\
* GetMonitorInfo
*
* History:
* 31-Mar-1997 adams     Doesn't call into kernel.
* 06-Jul-1998 MCostea   Has to call into kernel #190510
\***************************************************************************/
#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, BOOL, WINUSERAPI, GetMonitorInfoW, HMONITOR, hMonitor, LPMONITORINFO, lpmi)
#else
FUNCLOG2(LOG_GENERAL, BOOL, WINUSERAPI, GetMonitorInfoA, HMONITOR, hMonitor, LPMONITORINFO, lpmi)
#endif // UNICODE

BOOL WINUSERAPI
GetMonitorInfo(HMONITOR hMonitor, LPMONITORINFO lpmi)
{
    PMONITOR    pMonitor;
    BOOL        bRetVal;
    int         cbSize;

    pMonitor = VALIDATEHMONITOR(hMonitor);
    if (!pMonitor) {
        return FALSE;
    }

    cbSize = lpmi->cbSize;
    if (cbSize == sizeof(MONITORINFO)) {
        /*
         * Check for this first, since it is the most
         * common size. All the work for filling in
         * MONITORINFO fields is done after the else-if
         * statements.
         */

    } else if (cbSize == sizeof(MONITORINFOEX)) {
        /*
         * The ANSI version has to translate the szDevice field
         */
        ULONG_PTR pName;
#if IS_ANSI
        WCHAR szDevice[CCHDEVICENAME];
        pName = (ULONG_PTR)szDevice;
#else
        pName = (ULONG_PTR)(((LPMONITORINFOEX)lpmi)->szDevice);
#endif
        bRetVal = (BOOL)NtUserCallTwoParam((ULONG_PTR)(hMonitor),
                           pName,
                           SFI_GETHDEVNAME);
        if (!bRetVal) {
            return FALSE;
        }
#if IS_ANSI
        WideCharToMultiByte(
            CP_ACP, 0,                                  // ANSI -> Unicode
            (LPWSTR)pName, -1,                          // source & length
            (LPSTR)((LPMONITORINFOEX)lpmi)->szDevice,   // destination & length
            ARRAY_SIZE(((LPMONITORINFOEX)lpmi)->szDevice),
            NULL, NULL);

#endif
    } else {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid lpmi->cbSize, %d", lpmi->cbSize);

        return FALSE;
    }

    lpmi->dwFlags = (pMonitor == GetPrimaryMonitor()) ? MONITORINFOF_PRIMARY : 0;
    lpmi->rcMonitor = pMonitor->rcMonitor;
    lpmi->rcWork = pMonitor->rcWork;

    return TRUE;
}

#ifdef GENERIC_INPUT
#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, UINT, WINUSERAPI, GetRawInputDeviceInfoW, HANDLE, hDevice, UINT, uiCommand, LPVOID, pData, PUINT, pcbSize)
#else
FUNCLOG4(LOG_GENERAL, UINT, WINUSERAPI, GetRawInputDeviceInfoA, HANDLE, hDevice, UINT, uiCommand, LPVOID, pData, PUINT, pcbSize)
#endif // UNICODE
UINT WINUSERAPI
GetRawInputDeviceInfo(
    HANDLE hDevice,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize)
{
#if IS_ANSI
    UINT uiRet;
    LPVOID lpParam = pData;
    WCHAR wszPath[MAX_PATH];
    UINT cbBufferSize = 0;

    if (uiCommand == RIDI_DEVICENAME) {
        if (pData) {
            lpParam = wszPath;
            cbBufferSize = *pcbSize;
        }
    }

    uiRet = NtUserGetRawInputDeviceInfo(hDevice, uiCommand, lpParam, pcbSize);
    if (uiCommand == RIDI_DEVICENAME) {
        if (uiRet == (UINT)-1 && pData != NULL) {
            /* Insufficient buffer */
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                *pcbSize *= DBCS_CHARSIZE;
            }
        } else if (uiRet == 0 && pData == NULL) {
            /* The app wants the buffer size for the device name */
            *pcbSize *= DBCS_CHARSIZE;
        } else {
            uiRet = WCSToMB(lpParam, uiRet, (LPSTR*)&pData, cbBufferSize, FALSE);

            /* TODO:
             * Handle the case if cbBufferSize was not enough.
             */
        }
    }

    return uiRet;
#else
    return NtUserGetRawInputDeviceInfo(hDevice, uiCommand, pData, pcbSize);
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\combodir.c ===
/**************************** Module Header ********************************\
* Module Name: combodir.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Directory Combo Box Routines
*
* History:
* ??-???-???? ??????    Ported from Win 3.0 sources
* 01-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#define CTLMGR
#define LSTRING

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxCBDir
*
* Supports the CB_DIR message which adds a list of files from the
* current directory to the combo box.
*
* History:
\***************************************************************************/

int xxxCBDir(
    PCBOX pcbox,
    UINT attrib,
    LPWSTR pFileName)
{
    PLBIV plb;
    int errorValue;
    TL tlpwnd;

    CheckLock(pcbox->spwnd);
    UserAssert(pcbox->spwndList);

    plb = ((PLBWND)pcbox->spwndList)->pLBIV;

    ThreadLock(plb->spwnd, &tlpwnd);
    errorValue = xxxLbDir(plb, attrib, pFileName);
    ThreadUnlock(&tlpwnd);

    switch (errorValue) {
    case LB_ERR:
        return CB_ERR;
        break;
    case LB_ERRSPACE:
        return CB_ERRSPACE;
        break;
    default:
        return errorValue;
        break;
    }
}

/***************************************************************************\
* DlgDirSelectComboBoxEx
*
* Retrieves the current selection from the listbox of a combobox.
* It assumes that the combo box was filled by xxxDlgDirListComboBox()
* and that the selection is a drive letter, a file, or a directory name.
*
* History:
* 12-05-90 IanJa    converted to internal version
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, int, DUMMYCALLINGTYPE, DlgDirSelectComboBoxExA, HWND, hwndDlg, LPSTR, pszOut, int, cchOut, int, idComboBox)
int DlgDirSelectComboBoxExA(
    HWND hwndDlg,
    LPSTR pszOut,
    int cchOut,
    int idComboBox)
{
    LPWSTR lpwsz;
    BOOL fRet;

    lpwsz = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchOut * sizeof(WCHAR));
    if (!lpwsz) {
        return FALSE;
    }

    fRet = DlgDirSelectComboBoxExW(hwndDlg, lpwsz, cchOut, idComboBox);

    WCSToMB(lpwsz, -1, &pszOut, cchOut, FALSE);

    UserLocalFree(lpwsz);

    return fRet;
}


FUNCLOG4(LOG_GENERAL, int, DUMMYCALLINGTYPE, DlgDirSelectComboBoxExW, HWND, hwndDlg, LPWSTR, pwszOut, int, cchOut, int, idComboBox)
int DlgDirSelectComboBoxExW(
    HWND hwndDlg,
    LPWSTR pwszOut,
    int cchOut,
    int idComboBox)
{
    PWND pwndDlg;
    PWND pwndComboBox;
    PCBOX pcbox;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return FALSE;

    pwndComboBox = _GetDlgItem(pwndDlg, idComboBox);
    if (pwndComboBox == NULL) {
        RIPERR0(ERROR_CONTROL_ID_NOT_FOUND, RIP_VERBOSE, "");
        return 0;
    }
    pcbox = ((PCOMBOWND)pwndComboBox)->pcbox;
    if (pcbox == NULL) {
        RIPERR0(ERROR_WINDOW_NOT_COMBOBOX, RIP_VERBOSE, "");
        return 0;
    }

    return DlgDirSelectHelper(pwszOut, cchOut, HWq(pcbox->spwndList));
}


/***************************************************************************\
* xxxDlgDirListComboBox
*
* History:
* 12-05-90 IanJa    converted to internal version
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, DlgDirListComboBoxA, HWND, hwndDlg, LPSTR, lpszPathSpecClient, int, idComboBox, int, idStaticPath, UINT, attrib)
int DlgDirListComboBoxA(
    HWND hwndDlg,
    LPSTR lpszPathSpecClient,
    int idComboBox,
    int idStaticPath,
    UINT attrib)
{
    LPWSTR lpszPathSpec;
    TL tlpwndDlg;
    PWND pwndDlg;
    BOOL fRet;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return FALSE;

    lpszPathSpec = NULL;
    if (lpszPathSpecClient) {
        if (!MBToWCS(lpszPathSpecClient, -1, &lpszPathSpec, -1, TRUE))
            return FALSE;
    }

    ThreadLock(pwndDlg, &tlpwndDlg);
    fRet = xxxDlgDirListHelper(pwndDlg, lpszPathSpec, lpszPathSpecClient,
            idComboBox, idStaticPath, attrib, FALSE);
    ThreadUnlock(&tlpwndDlg);

    if (lpszPathSpec) {
        if (fRet) {
            /*
             * Non-zero retval means some text to copy out.  Copy out up to
             * the nul terminator (buffer will be big enough).
             */
            WCSToMB(lpszPathSpec, -1, &lpszPathSpecClient, MAXLONG, FALSE);
        }
        UserLocalFree(lpszPathSpec);
    }

    return fRet;
}


FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, DlgDirListComboBoxW, HWND, hwndDlg, LPWSTR, lpszPathSpecClient, int, idComboBox, int, idStaticPath, UINT, attrib)
int DlgDirListComboBoxW(
    HWND hwndDlg,
    LPWSTR lpszPathSpecClient,
    int idComboBox,
    int idStaticPath,
    UINT attrib)
{
    LPWSTR lpszPathSpec;
    PWND pwndDlg;
    TL tlpwndDlg;
    BOOL fRet;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return FALSE;

    lpszPathSpec = lpszPathSpecClient;

    ThreadLock(pwndDlg, &tlpwndDlg);
    fRet = xxxDlgDirListHelper(pwndDlg, lpszPathSpec, (LPBYTE)lpszPathSpecClient,
            idComboBox, idStaticPath, attrib, FALSE);
    ThreadUnlock(&tlpwndDlg);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\clrect.c ===
/****************************** Module Header ******************************\
* Module Name: clrect.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the various rectangle manipulation APIs.
*
* History:
* 04-05-91 DarrinM Pulled these routines from RTL because they call GDI.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* DrawFocusRect (API)
*
* Draw a rectangle in the style used to indicate focus
* Since this is an XOR function, calling it a second time with the same
* rectangle removes the rectangle from the screen
*
* History:
* 19-Jan-1993 mikeke   Client side version
\***************************************************************************/

BOOL DrawFocusRect(
    HDC hDC,
    CONST RECT *pRect)
{
    UserAssert(ghdcGray != NULL);
    return ClientFrame(hDC, pRect, KHBRUSH_TO_HBRUSH(gpsi->hbrGray), PATINVERT,
            max(1, gpsi->aiSysMet[SM_CXFOCUSBORDER]), max(1, gpsi->aiSysMet[SM_CYFOCUSBORDER]));
}

/***************************************************************************\
* FrameRect (API)
*
* History:
*  01-25-91 DavidPe     Created.
\***************************************************************************/

int APIENTRY FrameRect(
    HDC hdc,
    CONST RECT *lprc,
    HBRUSH hbr)
{
    return ClientFrame(hdc, lprc, hbr, PATCOPY, 1, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\comboini.c ===
/**************************** Module Header ********************************\
* Module Name: comboini.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* All the (one time) initialization/destruction code used for combo boxes
*
* History:
* 12-05-90 IanJa        Ported
* 01-Feb-1991 mikeke    Added Revalidation code
* 20-Jan-1992 IanJa     ANSI/UNIOCDE netralization
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern LOOKASIDE ComboboxLookaside;

#define RECALC_CYDROP   -1

void xxxCBSetDroppedSize(PCBOX pcbox, LPRECT lprc);

/***************************************************************************\
* CBNcCreateHandler
*
* Allocates space for the CBOX structure and sets the window to point to it.
*
* History:
\***************************************************************************/

LONG CBNcCreateHandler(
    PCBOX pcbox,
    PWND pwnd)
{
    /*
     * Save the style bits so that we have them when we create the client area
     * of the combo box window.
     */
    pcbox->styleSave = pwnd->style & (WS_VSCROLL | WS_HSCROLL);

    if (!TestWF(pwnd, CBFOWNERDRAW))
        // Add in CBS_HASSTRINGS if the style is implied...
        SetWindowState(pwnd, CBFHASSTRINGS);

    UserAssert(HIBYTE(WFVSCROLL) == HIBYTE(WFHSCROLL));
    UserAssert(HIBYTE(WFHSCROLL) == HIBYTE(WFBORDER));
    ClearWindowState(pwnd, WFVSCROLL | WFHSCROLL | WFBORDER);

    //
    // If the window is 4.0 compatible or has a CLIENTEDGE, draw the combo
    // in 3D.  Otherwise, use a flat border.
    //
    if (TestWF(pwnd, WFWIN40COMPAT) || TestWF(pwnd, WEFCLIENTEDGE))
        pcbox->f3DCombo = TRUE;

    ClearWindowState(pwnd, WEFEDGEMASK);

    return (LONG)TRUE;
}

/***************************************************************************\
* xxxCBCreateHandler
*
* Creates all the child controls within the combo box
* Returns -1 if error
*
* History:
\***************************************************************************/

LRESULT xxxCBCreateHandler(
    PCBOX pcbox,
    PWND pwnd)
{
    LONG lStyleT;
    RECT rcList;
    HWND hwndList;
    HWND hwndEdit;
    DWORD lExStyle;

    CheckLock(pwnd);

    /*
     * Don't lock the combobox window: this would prevent WM_FINALDESTROY
     * being sent to it, so pwnd and pcbox wouldn't get freed (zombies)
     * until thread cleanup. (IanJa)  LATER: change name from spwnd to pwnd.
     * Lock(&pcbox->spwnd, pwnd); - caused a 'catch-22'
     */
    Lock(&(pcbox->spwndParent), REBASEPWND(pwnd, spwndParent));

    /*
     * Break out the style bits so that we will be able to create the listbox
     * and editcontrol windows.
     */

    if (TestWF(pwnd, CBFDROPDOWNLIST) == LOBYTE(CBFDROPDOWNLIST)) {
        pcbox->CBoxStyle = SDROPDOWNLIST;
        pcbox->fNoEdit = TRUE;
    } else if (TestWF(pwnd, CBFDROPDOWN))
        pcbox->CBoxStyle = SDROPDOWN;
    else
        pcbox->CBoxStyle = SSIMPLE;

    pcbox->fRtoLReading = (TestWF(pwnd, WEFRTLREADING) != 0);
    pcbox->fRightAlign  = (TestWF(pwnd, WEFRIGHT) != 0);

    if (TestWF(pwnd, CBFUPPERCASE))
        pcbox->fCase = UPPERCASE;
    else if (TestWF(pwnd, CBFLOWERCASE))
        pcbox->fCase = LOWERCASE;
    else
        pcbox->fCase = 0;

    // Listbox item flags.
    if (TestWF(pwnd, CBFOWNERDRAWVAR))
        pcbox->OwnerDraw = OWNERDRAWVAR;
    if (TestWF(pwnd, CBFOWNERDRAWFIXED)) {
        pcbox->OwnerDraw = OWNERDRAWFIXED;
    }

    /*
     * Get the size of the combo box rectangle.
     */
    // Get control sizes.
    pcbox->cxCombo = pwnd->rcWindow.right - pwnd->rcWindow.left;
    pcbox->cyDrop  = RECALC_CYDROP;
    pcbox->cxDrop  = 0;
    xxxCBCalcControlRects(pcbox, &rcList);

    //
    // We need to do this because listboxes, as of VER40, have stopped
    // reinflating themselves by CXBORDER and CYBORDER.
    //
    if (!TestWF(pwnd, WFWIN40COMPAT))
        InflateRect(&rcList, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

    /*
     * Note that we have to create the listbox before the editcontrol since the
     * editcontrol code looks for and saves away the listbox pwnd and the
     * listbox pwnd will be NULL if we don't create it first.  Also, hack in
     * some special +/- values for the listbox size due to the way we create
     * listboxes with borders.
     */
    lStyleT = pcbox->styleSave;

    lStyleT |= WS_CHILD | WS_VISIBLE | LBS_NOTIFY | LBS_COMBOBOX | WS_CLIPSIBLINGS;

    if (TestWF(pwnd, WFDISABLED))
        lStyleT |= WS_DISABLED;
    if (TestWF(pwnd, CBFNOINTEGRALHEIGHT))
        lStyleT |= LBS_NOINTEGRALHEIGHT;
    if (TestWF(pwnd, CBFSORT))
        lStyleT |= LBS_SORT;
    if (TestWF(pwnd, CBFHASSTRINGS))
        lStyleT |= LBS_HASSTRINGS;
    if (TestWF(pwnd, CBFDISABLENOSCROLL))
        lStyleT |= LBS_DISABLENOSCROLL;

    if (pcbox->OwnerDraw == OWNERDRAWVAR)
        lStyleT |= LBS_OWNERDRAWVARIABLE;
    else if (pcbox->OwnerDraw == OWNERDRAWFIXED)
        lStyleT |= LBS_OWNERDRAWFIXED;

    if (pcbox->CBoxStyle & SDROPPABLE)
        lStyleT |= WS_BORDER;

    lExStyle = pwnd->ExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);
    hwndList = _CreateWindowEx(lExStyle |
            ((pcbox->CBoxStyle & SDROPPABLE) ? WS_EX_TOOLWINDOW : WS_EX_CLIENTEDGE),
            MAKEINTRESOURCE(gpsi->atomSysClass[ICLS_COMBOLISTBOX]), NULL, lStyleT,
            rcList.left, rcList.top, rcList.right - rcList.left,
            rcList.bottom - rcList.top,
            HW(pwnd), (HMENU)CBLISTBOXID, KHANDLE_TO_HANDLE(pcbox->spwnd->hModule), NULL,
            0);
    Lock(&(pcbox->spwndList), ValidateHwnd(hwndList));

    if (!pcbox->spwndList) {
        return -1;
    }

    /*
     * Create either the edit control or the static text rectangle.
     */
    if (pcbox->fNoEdit) {

        /*
         * No editcontrol so we will draw text directly into the combo box
         * window.
         */
        /*
         * Don't lock the combobox window: this would prevent WM_FINALDESTROY
         * being sent to it, so pwnd and pcbox wouldn't get freed (zombies)
         * until thread cleanup. (IanJa)  LATER: change name from spwnd to pwnd.
         * Lock(&(pcbox->spwndEdit), pcbox->spwnd); - caused a 'catch-22'
         */
        pcbox->spwndEdit = pcbox->spwnd;
    } else {
        DWORD dwCsFlags;

        lStyleT = WS_CHILD | WS_VISIBLE | ES_COMBOBOX | ES_NOHIDESEL;
        if (TestWF(pwnd, WFDISABLED))
            lStyleT |= WS_DISABLED;
        if (TestWF(pwnd, CBFAUTOHSCROLL))
            lStyleT |= ES_AUTOHSCROLL;
        if (TestWF(pwnd, CBFOEMCONVERT))
            lStyleT |= ES_OEMCONVERT;
        if (pcbox->fCase)
            lStyleT |= (pcbox->fCase & UPPERCASE) ? ES_UPPERCASE : ES_LOWERCASE;

        /*
         * Edit control need to know whether original CreateWindow*() call
         * was ANSI or Unicode.
         */
        dwCsFlags = TestWF(pcbox->spwnd, WFANSICREATOR) ? CW_FLAGS_ANSI : 0L;
        if (lExStyle & WS_EX_RIGHT)
            lStyleT |= ES_RIGHT;

        hwndEdit = _CreateWindowEx(lExStyle,
            MAKEINTRESOURCE(gpsi->atomSysClass[ICLS_EDIT]), NULL, lStyleT,
            pcbox->editrc.left, pcbox->editrc.top,
            pcbox->editrc.right - pcbox->editrc.left, pcbox->editrc.bottom -
            pcbox->editrc.top, HW(pwnd), (HMENU)CBEDITID,
            KHANDLE_TO_HANDLE(pcbox->spwnd->hModule), NULL,
            dwCsFlags);
        Lock(&(pcbox->spwndEdit), ValidateHwnd(hwndEdit));
    }
    if (!pcbox->spwndEdit)
        return -1L;

    if (pcbox->CBoxStyle & SDROPPABLE) {

        NtUserShowWindow(hwndList, SW_HIDE);
        NtUserSetParent(hwndList, NULL);

        // We need to do this so dropped size works right
        if (!TestWF(pwnd, WFWIN40COMPAT))
            InflateRect(&rcList, SYSMET(CXBORDER), SYSMET(CYBORDER));

        xxxCBSetDroppedSize(pcbox, &rcList);
    }

    /*
     * return anything as long as it's not -1L (-1L == error)
     */
    return (LRESULT)pwnd;
}

/***************************************************************************\
* xxxCBCalcControlRects
*
* History:
\***************************************************************************/

void xxxCBCalcControlRects(PCBOX pcbox, LPRECT lprcList)
{
    HDC hdc;
    HANDLE hOldFont = NULL;
    int             dyEdit, dxEdit;
    MEASUREITEMSTRUCT mis;
    SIZE size;
    HWND hwnd = HWq(pcbox->spwnd);
    TL tlpwndParent;

    CheckLock(pcbox->spwnd);

    /*
     * Determine height of the edit control.  We can use this info to center
     * the button with recpect to the edit/static text window.  For example
     * this will be useful if owner draw and this window is tall.
     */
    hdc = NtUserGetDC(hwnd);
    if (pcbox->hFont) {
        hOldFont = SelectObject(hdc, pcbox->hFont);
    }

    // Add on CYEDGE just for some extra space in the edit field/static item.
    // It's really only for static text items, but we want static & editable
    // controls to be the same height.
    GetTextExtentPoint(hdc, szOneChar, 1, &size);
    dyEdit = size.cy + SYSMET(CYEDGE);

    if (hOldFont) {
        SelectObject(hdc, hOldFont);
    }

    /*
     * IanJa: was ReleaseDC(pcbox->hwnd, hdc);
     */
    NtUserReleaseDC(hwnd, hdc);

    if (pcbox->OwnerDraw) {
        // This is an ownerdraw combo.  Have the owner tell us how tall this
        // item is.
        int iOwnerDrawHeight;

        if (iOwnerDrawHeight = pcbox->editrc.bottom - pcbox->editrc.top) {
            dyEdit = iOwnerDrawHeight;
        } else {
            /*
             * No height has been defined yet for the static text window.  Send
             * a measure item message to the parent
             */
            mis.CtlType = ODT_COMBOBOX;
            mis.CtlID = PtrToUlong(pcbox->spwnd->spmenu);
            mis.itemID = (UINT)-1;
            mis.itemHeight = dyEdit;
            mis.itemData = 0;

            ThreadLock(pcbox->spwndParent, &tlpwndParent);
            SendMessage(HW(pcbox->spwndParent), WM_MEASUREITEM, mis.CtlID, (LPARAM)&mis);
            ThreadUnlock(&tlpwndParent);

            dyEdit = mis.itemHeight;
        }
    }
    /*
     * Set the initial width to be the combo box rect.  Later we will shorten it
     * if there is a dropdown button.
     */
    pcbox->cyCombo = 2*SYSMET(CYFIXEDFRAME) + dyEdit;
    dxEdit = pcbox->cxCombo - (2 * SYSMET(CXFIXEDFRAME));

    if (pcbox->cyDrop == RECALC_CYDROP)
    {
        // recompute the max height of the dropdown listbox -- full window
        // size MINUS edit/static height
        pcbox->cyDrop = max((pcbox->spwnd->rcWindow.bottom - pcbox->spwnd->rcWindow.top) - pcbox->cyCombo, 0);

        if (!TestWF(pcbox->spwnd, WFWIN40COMPAT) && (pcbox->cyDrop == 23))
            // This is VC++ 2.1's debug/release dropdown that they made super
            // small -- let's make 'em a wee bit bigger so the world can
            // continue to spin -- jeffbog -- 4/19/95 -- B#10029
            pcbox->cyDrop = 28;
    }

    /*
     * Determine the rectangles for each of the windows...  1.  Pop down button 2.
     * Edit control or generic window for static text or ownerdraw...  3.  List
     * box
     */

    // Is there a button?
    if (pcbox->CBoxStyle & SDROPPABLE) {
        // Determine button's rectangle.
        pcbox->buttonrc.top = SYSMET(CYEDGE);
        pcbox->buttonrc.bottom = pcbox->cyCombo - SYSMET(CYEDGE);
        if (pcbox->fRightAlign) {
            pcbox->buttonrc.left  = SYSMET(CXFIXEDFRAME);
            pcbox->buttonrc.right = pcbox->buttonrc.left + SYSMET(CXVSCROLL);
        } else {
            pcbox->buttonrc.right = pcbox->cxCombo - SYSMET(CXEDGE);
            pcbox->buttonrc.left  = pcbox->buttonrc.right - SYSMET(CXVSCROLL);
        }

        // Reduce the width of the edittext window to make room for the button.
        dxEdit = max(dxEdit - SYSMET(CXVSCROLL), 0);

    } else {

        /*
         * No button so make the rectangle 0 so that a point in rect will always
         * return false.
         */
        SetRectEmpty(KPRECT_TO_PRECT(&pcbox->buttonrc));
    }

    /*
     * So now, the edit rect is really the item area.
     */
    pcbox->editrc.left      = SYSMET(CXFIXEDFRAME);
    pcbox->editrc.right     = pcbox->editrc.left + dxEdit;
    pcbox->editrc.top       = SYSMET(CYFIXEDFRAME);
    pcbox->editrc.bottom    = pcbox->editrc.top + dyEdit;

    // Is there a right-aligned button?
    if ((pcbox->CBoxStyle & SDROPPABLE) && (pcbox->fRightAlign)) {
        pcbox->editrc.right   = pcbox->cxCombo - SYSMET(CXEDGE);
        pcbox->editrc.left    = pcbox->editrc.right - dxEdit;
    }

    lprcList->left          = 0;
    lprcList->top           = pcbox->cyCombo;
    lprcList->right         = max(pcbox->cxDrop, pcbox->cxCombo);
    lprcList->bottom        = pcbox->cyCombo + pcbox->cyDrop;
}

/***************************************************************************\
* xxxCBNcDestroyHandler
*
* Destroys the combobox and frees up all memory used by it
*
* History:
\***************************************************************************/

void xxxCBNcDestroyHandler(
    PWND pwnd,
    PCBOX pcbox)
{
    CheckLock(pwnd);

    /*
     * If there is no pcbox, there is nothing to clean up.
     */
    if (pcbox != NULL) {

        /*
         * [msadek, 02/04/2001] fInDestroy is used to prevent oing through destruction code twice.
         * This code happen when apps like Delphi 5 tries to destroy the combobox again during processing of 
         * WM_PARENTNOTIFY in the NtUserDestroyWindow call (below). Thus, we end up freeing the same lookaside entry twice.
         * Windows Bugs bug# 266084
         */ 
        if (!pcbox->fInDestroy) {    
            pcbox->fInDestroy = TRUE;
            /*
             * Destroy the list box here so that it'll send WM_DELETEITEM messages
             * before the combo box turns into a zombie.
             */
            if (pcbox->spwndList != NULL) {
                NtUserDestroyWindow(HWq(pcbox->spwndList));
                Unlock(&pcbox->spwndList);
            }

            pcbox->spwnd = NULL;
            Unlock(&pcbox->spwndParent);

            /*
             * If there is no editcontrol, spwndEdit is the combobox window which
             * isn't locked (that would have caused a 'catch-22').
             */
            if (pwnd != pcbox->spwndEdit) {
                Unlock(&pcbox->spwndEdit);
            }

            /*
             * Since a pointer and a handle to a fixed local object are the same.
             */
            FreeLookasideEntry(&ComboboxLookaside, KPVOID_TO_PVOID(pcbox));
        }
        else {
            RIPMSG1(RIP_WARNING, "Trying to destroy the same combobox %x twice. Ignoring", pcbox);
        }
    }

    /*
     * Set the window's fnid status so that we can ignore rogue messages
     */
    NtUserSetWindowFNID(HWq(pwnd), FNID_CLEANEDUP_BIT);
}

/***************************************************************************\
* xxxCBSetFontHandler
*
* History:
\***************************************************************************/

void xxxCBSetFontHandler(
    PCBOX pcbox,
    HANDLE hFont,
    BOOL fRedraw)
{
    TL tlpwndEdit;
    TL tlpwndList;

    CheckLock(pcbox->spwnd);

    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
    ThreadLock(pcbox->spwndList, &tlpwndList);

    pcbox->hFont = hFont;

    if (!pcbox->fNoEdit && pcbox->spwndEdit) {
        SendMessageWorker(pcbox->spwndEdit, WM_SETFONT, (WPARAM)hFont, FALSE, FALSE);
    }

    SendMessageWorker(pcbox->spwndList, WM_SETFONT, (WPARAM)hFont, FALSE, FALSE);

    // Recalculate the layout of controls.  This will hide the listbox also.
    xxxCBPosition(pcbox);

    if (fRedraw) {
        NtUserInvalidateRect(HWq(pcbox->spwnd), NULL, TRUE);
// LATER UpdateWindow(HW(pcbox->spwnd));
    }

    ThreadUnlock(&tlpwndList);
    ThreadUnlock(&tlpwndEdit);
}

/***************************************************************************\
* xxxCBSetEditItemHeight
*
* Sets the height of the edit/static item of a combo box.
*
* History:
* 06-27-91 DarrinM      Ported from Win 3.1.
\***************************************************************************/

LONG xxxCBSetEditItemHeight(
    PCBOX pcbox,
    int dyEdit)
{
    TL tlpwndEdit;
    TL tlpwndList;

    CheckLock(pcbox->spwnd);

    if (dyEdit > 255) {
        RIPERR0(ERROR_INVALID_EDIT_HEIGHT, RIP_VERBOSE, "");
        return CB_ERR;
    }

    pcbox->editrc.bottom = pcbox->editrc.top + dyEdit;
    pcbox->cyCombo = pcbox->editrc.bottom + SYSMET(CYFIXEDFRAME);

    if (pcbox->CBoxStyle & SDROPPABLE) {
        pcbox->buttonrc.bottom = pcbox->cyCombo - SYSMET(CYEDGE);
    }

    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
    ThreadLock(pcbox->spwndList, &tlpwndList);


    /*
     * Reposition the editfield.
     * Don't let spwndEdit or List of NULL go through; if someone adjusts
     * the height on a NCCREATE; same as not having
     * HW instead of HWq but we don't go to the kernel.
     */
    if (!pcbox->fNoEdit && pcbox->spwndEdit) {
        NtUserMoveWindow(HWq(pcbox->spwndEdit), pcbox->editrc.left, pcbox->editrc.top,
            pcbox->editrc.right-pcbox->editrc.left, dyEdit, TRUE);
    }

    /*
     * Reposition the list and combobox windows.
     */
    if (pcbox->CBoxStyle == SSIMPLE) {
        if (pcbox->spwndList != 0) {
            NtUserMoveWindow(HWq(pcbox->spwndList), 0, pcbox->cyCombo, pcbox->cxCombo,
                pcbox->cyDrop, FALSE);

            NtUserSetWindowPos(HWq(pcbox->spwnd), HWND_TOP, 0, 0,
                pcbox->cxCombo, pcbox->cyCombo +
                pcbox->spwndList->rcWindow.bottom - pcbox->spwndList->rcWindow.top,
                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
    } else {
        if (pcbox->spwndList != NULL) {
            NtUserMoveWindow(HWq(pcbox->spwndList), pcbox->spwnd->rcWindow.left,
                pcbox->spwnd->rcWindow.top + pcbox->cyCombo,
                max(pcbox->cxDrop, pcbox->cxCombo), pcbox->cyDrop, FALSE);
        }

        NtUserSetWindowPos(HWq(pcbox->spwnd), HWND_TOP, 0, 0,
            pcbox->cxCombo, pcbox->cyCombo,
            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    ThreadUnlock(&tlpwndList);
    ThreadUnlock(&tlpwndEdit);

    return CB_OKAY;
}


/***************************************************************************\
* xxxCBSizeHandler
*
* Recalculates the sizes of the internal controls in response to a
* resizing of the combo box window.  The app must size the combo box to its
* maximum open/dropped down size.
*
* History:
\***************************************************************************/

void xxxCBSizeHandler(
    PCBOX pcbox)
{
    CheckLock(pcbox->spwnd);

    /*
     * Assume listbox is visible since the app should size it to its maximum
     * visible size.
     */
    pcbox->cxCombo = pcbox->spwnd->rcWindow.right - pcbox->spwnd->rcWindow.left;
    // only recalc cyDrop if the drop down is not TOTALLY nuked by the sizing
    // -- Visio 1.0 -- B#13112
    if (((pcbox->spwnd->rcWindow.bottom - pcbox->spwnd->rcWindow.top) - pcbox->cyCombo) > 0)
        pcbox->cyDrop = RECALC_CYDROP;

    // Reposition everything.
    xxxCBPosition(pcbox);
}

/***************************************************************************\
*
*  CBPosition()
*
*  Repositions components of edit control.
*
\***************************************************************************/
void xxxCBPosition(PCBOX pcbox)
{
    RECT rcList;

    // Calculate placement of components--button, item, list
    xxxCBCalcControlRects(pcbox, &rcList);

    if (!pcbox->fNoEdit && pcbox->spwndEdit) {
        TL tlpwndEdit;

        ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
        NtUserMoveWindow(HWq(pcbox->spwndEdit), pcbox->editrc.left, pcbox->editrc.top,
            pcbox->editrc.right - pcbox->editrc.left,
            pcbox->editrc.bottom - pcbox->editrc.top, TRUE);
        ThreadUnlock(&tlpwndEdit);
    }

    // Recalculate drop height & width
    xxxCBSetDroppedSize(pcbox, &rcList);
}

/***************************************************************************\
*
*  CBSetDroppedSize()
*
*  Compute the drop down window's width and max height
*
\***************************************************************************/
void xxxCBSetDroppedSize(PCBOX pcbox, LPRECT lprc)
{
    TL tlpwndList;

    pcbox->fLBoxVisible = TRUE;
    xxxCBHideListBoxWindow(pcbox, FALSE, FALSE);

    ThreadLock(pcbox->spwndList, &tlpwndList);
    NtUserMoveWindow(HWq(pcbox->spwndList), lprc->left, lprc->top,
        lprc->right - lprc->left, lprc->bottom - lprc->top, FALSE);
    ThreadUnlock(&tlpwndList);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\clres.c ===
/****************************** Module Header ******************************\
* Module Name: clres.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Resource Loading/Creation Routines
*
* History:
* 24-Sep-1990 MikeKe    From win30
* 19-Sep-1995 ChrisWil  Win95/NT merge.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Constants.
 */
#define BPP01_MAXCOLORS     2
#define BPP04_MAXCOLORS    16
#define BPP08_MAXCOLORS   256
#define ICON_DEFAULTDEPTH   8
#define ICON_MAXWIDTH     256
#define ICON_MAXHEIGHT    256

#define RESCLR_BLACK      0x00000000
#define RESCLR_WHITE      0x00FFFFFF

typedef struct {
    ACCEL accel;
    WORD  padding;
} RESOURCE_ACCEL, *PRESOURCE_ACCEL;

/*
 * Bitmap resource IDs
 */
#define BMR_ICON    1
#define BMR_BITMAP  2
#define BMR_CURSOR  3

typedef struct _OLDCURSOR {
    BYTE bType;
    BYTE bFormat;
    WORD xHotSpot;  // 0 for icons
    WORD yHotSpot;  // 0 for icons
    WORD cx;
    WORD cy;
    WORD cxBytes;
    WORD wReserved2;
    BYTE abBitmap[1];
} OLDCURSOR, *POLDCURSOR;
typedef OLDCURSOR UNALIGNED *UPOLDCURSOR;

/*
 * Local Macros.
 */
#define GETINITDC() \
    (gfSystemInitialized ? NtUserGetDC(NULL) : CreateDCW(L"DISPLAY", L"", NULL, NULL))

#define RELEASEINITDC(hdc) \
    (gfSystemInitialized ? ReleaseDC(NULL, hdc) : DeleteDC(hdc))

#define ISRIFFFORMAT(p) \
    (((UNALIGNED RTAG *)(p))->ckID == FOURCC_RIFF)

#define MR_FAILFOR40    0x01
#define MR_MONOCHROME   0x02


typedef struct tagMAPRES {
    WORD idDisp;                // display driver ID
    WORD idUser;                // USER ID
    BYTE bFlags;                // Flags
    BYTE bReserved;             // unused
} MAPRES, *LPMAPRES, *PMAPRES;


HBITMAP CopyBmp(HBITMAP hbmpOrg, int cxNew, int cyNew, UINT LR_flags);

/***************************************************************************\
* SplFindResource
*
* Check whether the hInstance passed is that of the present display driver;
* if so, it will call the GetDriverResourceId() in the display to allow
* it to map the given id/name to a new id/name.  Then it will call
* FindResource9) in KERNEL.
*
* 13-Nov-1995 SanfordS  Added mapping for DEFAULT constants.
\***************************************************************************/

HANDLE SplFindResource(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    LPCWSTR   lpType)
{
    return FINDRESOURCEW(hmod, lpName, lpType);
}

/***************************************************************************\
* SplFreeResource
*
* Really frees a resource that is shared (won't be touched again unless
* LR_COPYFROMRESOURCE is used) or system.
*
* 13-Nov-1995 SanfordS  Added mapping for DEFAULT constants.
\***************************************************************************/
VOID SplFreeResource(
    HANDLE hRes,
    HINSTANCE hmod,
    UINT lrFlags)
{
    if (!FREERESOURCE(hRes, hmod) &&
        ((hmod == hmodUser) || (lrFlags & LR_SHARED))) {
        FREERESOURCE(hRes, hmod);
    }
}

/***********************************************************************\
* WowGetModuleFileName
*
* This converts a WOW or non-WOW module handle to a string form that
* can be restored even for WOW handles.
*
* Returns: fSuccess
*
* 29-Nov-1995 SanfordS  Created.
\***********************************************************************/

BOOL WowGetModuleFileName(
    HMODULE hModule,
    LPWSTR  pwsz,
    DWORD   cchMax)
{
    if (!GetModuleFileName(hModule, pwsz, cchMax)) {

        if (cchMax < 10) {
            RIPMSG0(RIP_WARNING, "WowGetModuleFileName: exceeded Char-Max");
            return FALSE;
        }

        wsprintf(pwsz, TEXT("\001%08lx"), hModule);
    }

    return TRUE;
}

/***********************************************************************\
* WowGetModuleHandle
*
* This restores the string form of a module handle created by
* WowGetModuleFileName to the original handle.
*
* Returns: fSuccess
*
* 29-Nov-1995 Created   SanfordS
\***********************************************************************/

HMODULE WowGetModuleHandle(
    LPCWSTR pwsz)
{
    HMODULE hMod = NULL;
    DWORD   digit;

    if (pwsz[0] == TEXT('\001')) {

        /*
         * Cant seem to link to swscanf without CRT0 problems so just
         * do it by hand.
         */
        while (*(++pwsz)) {

            if (*pwsz == TEXT(' '))
                continue;

            digit = *pwsz - TEXT('0');

            if (digit > 9)
                digit += (DWORD)(TEXT('0') - TEXT('a') + 10);

            (ULONG_PTR)hMod <<= 4;
            (ULONG_PTR)hMod += digit;
        }

    } else {

        hMod = GetModuleHandle(pwsz);
    }

    return hMod;
}

/***************************************************************************\
* CreateAcceleratorTableA (API)
*
* Creates an accel table, returns handle to accel table.
*
* 02-May-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HACCEL, WINAPI, CreateAcceleratorTableA, LPACCEL, paccel, int, cAccel)
HACCEL WINAPI CreateAcceleratorTableA(
    LPACCEL paccel,
    int     cAccel)
{
    int     nAccel = cAccel;
    LPACCEL pAccelT = paccel;

    /*
     * Convert any character keys from ANSI to Unicode.
     */
    while (nAccel--) {

        if ((pAccelT->fVirt & FVIRTKEY) == 0) {

            if (!NT_SUCCESS(RtlMultiByteToUnicodeN((LPWSTR)&(pAccelT->key),
                                                   sizeof(WCHAR),
                                                   NULL,
                                                   (LPSTR)&(pAccelT->key),
                                                   sizeof(CHAR)))) {
                pAccelT->key = 0xFFFF;
            }
        }

        pAccelT++;
    }

    return NtUserCreateAcceleratorTable(paccel, cAccel);
}

/***************************************************************************\
* CopyAcceleratorTableA (API)
*
* Copies an accel table
*
* 02-May-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, CopyAcceleratorTableA, HACCEL, hacc, LPACCEL, paccel, int, length)
int CopyAcceleratorTableA(
    HACCEL hacc,
    LPACCEL paccel,
    int length)
{
    int retval;

    retval = NtUserCopyAcceleratorTable(hacc, paccel, length);

    /*
     * If we are doing a copy and we succeeded then convert the accelerator
     */
    if ((paccel != NULL) && (retval > 0)) {

        /*
         * Translate UNICODE character keys to ANSI
         */
        int nAccel = retval;
        LPACCEL pAccelT = paccel;

        while (nAccel--) {
            if ((pAccelT->fVirt & FVIRTKEY) == 0) {
                if (!NT_SUCCESS(RtlUnicodeToMultiByteN((PCHAR)&(pAccelT->key),
                                                       sizeof(WCHAR),
                                                       NULL,
                                                       (PWSTR)&(pAccelT->key),
                                                        sizeof(pAccelT->key)))) {
                        pAccelT->key = 0;
                    }
                }
            pAccelT++;
        }
    }

    return retval;
}

/***************************************************************************\
* FindAccResource
*
* Resource accelerator tables are to be loaded only once to be compatible
*  with Win95. So we keep track of the addresses we've loaded tables from
*  and the corresponding handle.
*
* This function finds an entry in the table. It returns the address
*  of the pacNext pointer that contains the requested entry.
*
* 01/31/97 GerardoB     Created.
\***************************************************************************/
PACCELCACHE * FindAccResource (HACCEL hAccel, PVOID pRes)
{
     /************************************
     * The caller must own gcsAccelCache *
     *************************************/

    PACCELCACHE * ppacNext = &gpac;
    PACCELCACHE pac;

    /*
     * This is meant to search by handle or by pointer, not both
     * So at least one of the parameters must be NULL.
     */
    UserAssert(!(hAccel && pRes));
    /*
     * Walk the table
     */
    while (*ppacNext != NULL) {
        pac = *ppacNext;
        if ((pac->pRes == pRes) || (pac->hAccel == hAccel)) {
            /*
            * Found it. Validate this entry before returning.
            */
            UserAssert(pac->dwLockCount != 0);
            UserAssert(HMValidateHandleNoDesktop(pac->hAccel, TYPE_ACCELTABLE));
            break;
        }

        ppacNext = &(pac->pacNext);
    }

    return ppacNext;
}
/***************************************************************************\
* AddAccResource
*
* This is called everytime LoadAcc loads a new table. It adds an entry
* (handle and resource address) to the global list and sets the lock count
* to 1.
*
* 01/31/97 GerardoB     Created.
\***************************************************************************/
VOID AddAccResource(
    HACCEL hAccel,
    PVOID pRes)
{
    PACCELCACHE pac;

    UserAssert(HMValidateHandleNoDesktop(hAccel, TYPE_ACCELTABLE));
    UserAssert(pRes != NULL);

    /*
     * Allocate and initialize a new entry.
     */
    pac = (PACCELCACHE)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(ACCELCACHE));
    if (pac != NULL) {
        pac->dwLockCount = 1;
        pac->hAccel = hAccel;
        pac->pRes = pRes;

        /*
         * Make it the new head of the list
         */
        RtlEnterCriticalSection(&gcsAccelCache);
            pac->pacNext = gpac;
            gpac = pac;
        RtlLeaveCriticalSection(&gcsAccelCache);

    }
}

/***************************************************************************\
* DestroyAcceleratorTable
*
* 01/31/97 GerardoB     Created.
\***************************************************************************/
BOOL DestroyAcceleratorTable (HACCEL hAccel)
{
    BOOL fUnlocked = TRUE;
    PACCELCACHE *ppacNext, pac;

    /*
     * If we added this table to our list, decrement the lock count
     */
    RtlEnterCriticalSection(&gcsAccelCache);
        ppacNext = FindAccResource(hAccel, NULL);
        if (*ppacNext != NULL) {
            pac = *ppacNext;
            /*
             * Found it. Decrement lock count.
             */
            UserAssert(pac->dwLockCount != 0);
            fUnlocked = (--pac->dwLockCount == 0);
            /*
             * If noboby else wants this around, unlink it and nuke it.
             */
            if (fUnlocked) {
                *ppacNext = pac->pacNext;
                UserLocalFree(pac);
            }
        }
    RtlLeaveCriticalSection(&gcsAccelCache);

    /*
     * If not totally deref'ed, return FALSE (win95 compat).
     */
    if (fUnlocked) {
        return NtUserDestroyAcceleratorTable(hAccel);
    } else {
        return FALSE;
    }
}
/***************************************************************************\
* LoadAcc (Worker)
*
* This is the worker-routine for loading accelerator tables.
*
\***************************************************************************/

#define FACCEL_VALID (FALT | FCONTROL | FNOINVERT | FSHIFT | FVIRTKEY | FLASTKEY)

HANDLE LoadAcc(
    HINSTANCE hmod,
    HANDLE    hrl)
{
    PACCELCACHE * ppacNext;
    HANDLE handle = NULL;

    if (hrl != NULL) {

        if (hrl = LOADRESOURCE(hmod, hrl)) {

            PRESOURCE_ACCEL paccel;

            if ((paccel = (PRESOURCE_ACCEL)LOCKRESOURCE(hrl, hmod)) != NULL) {

                int nAccel = 0;
                int i;
                LPACCEL paccelT;

                /*
                 * Check if we've already loaded accelerators from this
                 *  same address
                 */
                RtlEnterCriticalSection(&gcsAccelCache);
                    ppacNext = FindAccResource(NULL, paccel);
                    if (*ppacNext != NULL) {
                        (*ppacNext)->dwLockCount++;
                        handle = (*ppacNext)->hAccel;
                    }
                RtlLeaveCriticalSection(&gcsAccelCache);
                /*
                 * If we found this table on the global list,
                 *  return the same handle (Win95 compat)
                 */
                if (handle != NULL) {
                    goto UnlockAndFree;
                }

                while (!((paccel[nAccel].accel.fVirt) & FLASTKEY)) {

                    if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {
                        RIPMSG0(RIP_WARNING, "LoadAcc: Invalid Parameter");
                        goto UnlockAndFree;
                    }

                    nAccel++;
                }

                if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {
                    RIPMSG0(RIP_WARNING, "LoadAcc: Invalid Parameter");
                    goto UnlockAndFree;
                }

                /*
                 * Since the accelerator table is coming from a resource, each
                 * element has an extra WORD of padding which we strip here
                 * to conform with the public (and internal) ACCEL structure.
                 */
                paccelT = UserLocalAlloc(0, sizeof(ACCEL) * (nAccel + 1));
                if (paccelT == NULL) {
                    goto UnlockAndFree;
                }
                for (i = 0; i < nAccel + 1; i++) {
                    paccelT[i] = paccel[i].accel;
                }

                handle = NtUserCreateAcceleratorTable(paccelT,
                                                      nAccel + 1);

                UserLocalFree(paccelT);

                /*
                 * Add this handle/address to the global table so
                 *  we won't load it twice.
                 */
                if (handle != NULL) {
                    AddAccResource(handle, paccel);
                }
UnlockAndFree:

                UNLOCKRESOURCE(hrl, hmod);
            }

            FREERESOURCE(hrl, hmod);
        }
    }

    return handle;
}

/***************************************************************************\
* LoadAcceleratorsA (API)
* LoadAcceleratorsW (API)
*
*
* 24-Sep-1990 MikeKe    From Win30
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HACCEL, WINAPI, LoadAcceleratorsA, HINSTANCE, hmod, LPCSTR, lpAccName)
HACCEL WINAPI LoadAcceleratorsA(
    HINSTANCE hmod,
    LPCSTR    lpAccName)
{
    HANDLE hRes;

    hRes = FINDRESOURCEA((HANDLE)hmod, lpAccName, (LPSTR)RT_ACCELERATOR);

    return (HACCEL)LoadAcc(hmod, hRes);
}


FUNCLOG2(LOG_GENERAL, HACCEL, WINAPI, LoadAcceleratorsW, HINSTANCE, hmod, LPCWSTR, lpAccName)
HACCEL WINAPI LoadAcceleratorsW(
    HINSTANCE hmod,
    LPCWSTR   lpAccName)
{
    HANDLE hRes;

    hRes = FINDRESOURCEW((HANDLE)hmod, lpAccName, RT_ACCELERATOR);

    return (HACCEL)LoadAcc(hmod, hRes);
}

/***************************************************************************\
* LoadStringA (API)
* LoadStringW (API)
*
*
* 05-Apr-1991 ScottLu   Fixed to work with client/server.
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, int, WINAPI, LoadStringA, HINSTANCE, hmod, UINT, wID, LPSTR, lpAnsiBuffer, int, cchBufferMax)
int WINAPI LoadStringA(
    HINSTANCE hmod,
    UINT      wID,
    LPSTR     lpAnsiBuffer,
    int       cchBufferMax)
{
    LPWSTR          lpUniBuffer;
    INT             cchUnicode;
    INT             cbAnsi = 0;

    /*
     * LoadStringOrError appends a NULL but does not include it in the
     * return count-of-bytes
     */
    cchUnicode = LoadStringOrError((HANDLE)hmod,
                                      wID,
                                      (LPWSTR)&lpUniBuffer,
                                      0,
                                      0);

    if (cchUnicode) {

        cbAnsi = WCSToMB(lpUniBuffer,
                         cchUnicode,
                         &lpAnsiBuffer,
                         cchBufferMax - 1,
                         FALSE);

        cbAnsi = min(cbAnsi, cchBufferMax - 1);
    }

    /*
     * Append a NULL but do not include it in the count returned
     */
    lpAnsiBuffer[cbAnsi] = 0;
    return cbAnsi;
}


FUNCLOG4(LOG_GENERAL, int, WINAPI, LoadStringW, HINSTANCE, hmod, UINT, wID, LPWSTR, lpBuffer, int, cchBufferMax)
int WINAPI LoadStringW(
    HINSTANCE hmod,
    UINT      wID,
    LPWSTR    lpBuffer,
    int       cchBufferMax)
{
    return LoadStringOrError((HANDLE)hmod,
                                wID,
                                lpBuffer,
                                cchBufferMax,
                                0);
}

/***************************************************************************\
* SkipIDorString
*
* Skips string (or ID) and returns the next aligned WORD.
*
\***************************************************************************/

PBYTE SkipIDorString(
    LPBYTE pb)
{
    if (*((LPWORD)pb) == 0xFFFF)
        return (pb + 4);

    while (*((PWCHAR)pb)++ != 0);

    return pb;
}

/***************************************************************************\
* GetSizeDialogTemplate
*
* This gets called by thank produced stubs. It returns the size of a
* dialog template.
*
* 07-Apr-1991 ScottLu   Created.
\***************************************************************************/

DWORD GetSizeDialogTemplate(
    HINSTANCE      hmod,
    LPCDLGTEMPLATE pdt)
{
    UINT           cdit;
    LPBYTE         pb;
    BOOL           fChicago;
    LPDLGTEMPLATE2 pdt2;

    if (HIWORD(pdt->style) == 0xFFFF) {

        pdt2 = (LPDLGTEMPLATE2)pdt;
        fChicago = TRUE;

        /*
         * Fail if the app is passing invalid style bits.
         */
        if (pdt2->style & ~(DS_VALID40 | 0xffff0000)) {
            RIPMSG0(RIP_WARNING, "Bad dialog style bits - please remove");
            return 0;
        }

        pb = (LPBYTE)(((LPDLGTEMPLATE2)pdt) + 1);

    } else {

        fChicago = FALSE;

        /*
         * Check if invalid style bits are being passed. Fail if the app
         * is a new app ( >= VER40).
         * This is to ensure that we are compatible with Chicago.
         */
        if ((pdt->style & ~(DS_VALID40 | 0xffff0000)) &&
                (GETEXPWINVER(hmod) >= VER40)) {

            /*
             * It's a new app with invalid style bits - fail.
             */
            RIPMSG0(RIP_WARNING, "Bad dialog style bits - please remove");
            return 0;
        }

        pb = (LPBYTE)(pdt + 1);
    }

    /*
     * If there is a menu ordinal, add 4 bytes skip it. Otherwise it is a
     * string or just a 0.
     */
    pb = SkipIDorString(pb);

    /*
     * Skip window class and window text, adjust to next word boundary.
     */
    pb = SkipIDorString(pb);
    pb = SkipIDorString(pb);

    /*
     * Skip font type, size and name, adjust to next dword boundary.
     */
    if ((fChicago ? pdt2->style : pdt->style) & DS_SETFONT) {
        pb += fChicago ? sizeof(DWORD) + sizeof(WORD): sizeof(WORD);
        pb = SkipIDorString(pb);
    }
    pb = (LPBYTE)(((ULONG_PTR)pb + 3) & ~3);

    /*
     * Loop through dialog items now...
     */
    cdit = fChicago ? pdt2->cDlgItems : pdt->cdit;

    while (cdit-- != 0) {

        UINT cbCreateParams;

        pb += fChicago ? sizeof(DLGITEMTEMPLATE2) : sizeof(DLGITEMTEMPLATE);

        /*
         * Skip the dialog control class name.
         */
        pb = SkipIDorString(pb);

        /*
         * Look at window text now.
         */
        pb = SkipIDorString(pb);

        cbCreateParams = *((LPWORD)pb);

        /*
         * skip any CreateParams which include the generated size WORD.
         */
        if (cbCreateParams)
            pb += cbCreateParams;

        pb += sizeof(WORD);

        /*
         * Point at the next dialog item. (DWORD aligned)
         */
        pb = (LPBYTE)(((ULONG_PTR)pb + 3) & ~3);
    }

    /*
     * Return template size.
     */
    return (DWORD)(pb - (LPBYTE)pdt);
}

/***************************************************************************\
* DialogBoxIndirectParamA (API)
* DialogBoxIndirectParamW (API)
*
* Creates the dialog and goes into a modal loop processing input for it.
*
* 05-Apr-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, INT_PTR, WINAPI, DialogBoxIndirectParamA, HINSTANCE, hmod, LPCDLGTEMPLATEA, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
INT_PTR WINAPI DialogBoxIndirectParamA(
    HINSTANCE       hmod,
    LPCDLGTEMPLATEA lpDlgTemplate,
    HWND            hwndOwner,
    DLGPROC         lpDialogFunc,
    LPARAM          dwInitParam)
{
    return DialogBoxIndirectParamAorW(hmod,
                                      (LPCDLGTEMPLATEW)lpDlgTemplate,
                                      hwndOwner,
                                      lpDialogFunc,
                                      dwInitParam,
                                      SCDLG_ANSI);
}


FUNCLOG5(LOG_GENERAL, INT_PTR, WINAPI, DialogBoxIndirectParamW, HINSTANCE, hmod, LPCDLGTEMPLATEW, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
INT_PTR WINAPI DialogBoxIndirectParamW(
    HINSTANCE       hmod,
    LPCDLGTEMPLATEW lpDlgTemplate,
    HWND            hwndOwner,
    DLGPROC         lpDialogFunc,
    LPARAM          dwInitParam)
{
    return DialogBoxIndirectParamAorW(hmod,
                                      lpDlgTemplate,
                                      hwndOwner,
                                      lpDialogFunc,
                                      dwInitParam,
                                      0);
}


FUNCLOG6(LOG_GENERAL, INT_PTR, WINAPI, DialogBoxIndirectParamAorW, HINSTANCE, hmod, LPCDLGTEMPLATEW, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam, UINT, fAnsiFlags)
INT_PTR WINAPI DialogBoxIndirectParamAorW(
    HINSTANCE       hmod,
    LPCDLGTEMPLATEW lpDlgTemplate,
    HWND            hwndOwner,
    DLGPROC         lpDialogFunc,
    LPARAM          dwInitParam,
    UINT            fAnsiFlags)
{
    DWORD cb;

    /*
     * The server routine destroys the menu if it fails.
     */
    cb = GetSizeDialogTemplate(hmod, lpDlgTemplate);

    if (!cb) {
        RIPMSG0(RIP_WARNING, "DialogBoxIndirectParam: Invalid Paramter");
        return -1;
    }

    return InternalDialogBox(hmod,
                            (LPDLGTEMPLATE)lpDlgTemplate,
                            hwndOwner,
                            lpDialogFunc,
                            dwInitParam,
                            SCDLG_CLIENT | (fAnsiFlags & (SCDLG_ANSI | SCDLG_16BIT)));
}

/***************************************************************************\
* CreateDialogIndirectParamA (API)
* CreateDialogIndirectParamW (API)
*
* Creates a dialog given a template and return s the window handle.
* fAnsi determines if the dialog has an ANSI or UNICODE lpDialogFunc
*
* 05-Apr-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, HWND, WINAPI, CreateDialogIndirectParamA, HINSTANCE, hmod, LPCDLGTEMPLATEA, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
HWND WINAPI CreateDialogIndirectParamA(
    HINSTANCE       hmod,
    LPCDLGTEMPLATEA lpDlgTemplate,
    HWND            hwndOwner,
    DLGPROC         lpDialogFunc,
    LPARAM          dwInitParam)
{
    return CreateDialogIndirectParamAorW(hmod,
                                         (LPCDLGTEMPLATE)lpDlgTemplate,
                                         hwndOwner,
                                         lpDialogFunc,
                                         dwInitParam,
                                         SCDLG_ANSI);
}


FUNCLOG5(LOG_GENERAL, HWND, WINAPI, CreateDialogIndirectParamW, HINSTANCE, hmod, LPCDLGTEMPLATEW, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
HWND WINAPI CreateDialogIndirectParamW(
    HINSTANCE       hmod,
    LPCDLGTEMPLATEW lpDlgTemplate,
    HWND            hwndOwner,
    DLGPROC         lpDialogFunc,
    LPARAM          dwInitParam)
{
    return CreateDialogIndirectParamAorW(hmod,
                                         (LPCDLGTEMPLATE)lpDlgTemplate,
                                         hwndOwner,
                                         lpDialogFunc,
                                         dwInitParam,
                                         0);
}


FUNCLOG6(LOG_GENERAL, HWND, WINAPI, CreateDialogIndirectParamAorW, HANDLE, hmod, LPCDLGTEMPLATE, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam, UINT, fAnsi)
HWND WINAPI CreateDialogIndirectParamAorW(
    HANDLE         hmod,
    LPCDLGTEMPLATE lpDlgTemplate,
    HWND           hwndOwner,
    DLGPROC        lpDialogFunc,
    LPARAM         dwInitParam,
    UINT           fAnsi)
{
    DWORD cb;
    HWND  hwndRet;

    /*
     * The server routine destroys the menu if it fails.
     */
    cb = GetSizeDialogTemplate(hmod, lpDlgTemplate);

    if (!cb) {
        RIPMSG0(RIP_WARNING, "CreateDialogIndirect: Invalid Parameter");
        return NULL;
    }

    hwndRet = InternalCreateDialog(hmod,
                                   (LPDLGTEMPLATE)lpDlgTemplate,
                                   cb,
                                   hwndOwner,
                                   lpDialogFunc,
                                   dwInitParam,
                                   SCDLG_CLIENT | (fAnsi & (SCDLG_ANSI|SCDLG_16BIT)));

    return hwndRet;
}

/***************************************************************************\
* DialogBoxParamA (API)
* DialogBoxParamW (API)
*
* Loads the resource, creates the dialog and goes into a modal loop processing
* input for it.
*
* 05-Apr-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, INT_PTR, WINAPI, DialogBoxParamA, HINSTANCE, hmod, LPCSTR, lpName, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
INT_PTR WINAPI DialogBoxParamA(
    HINSTANCE hmod,
    LPCSTR    lpName,
    HWND      hwndOwner,
    DLGPROC   lpDialogFunc,
    LPARAM    dwInitParam)
{
    HANDLE h;
    PVOID  p;
    INT_PTR i = -1;

    if (h = FINDRESOURCEA(hmod, (LPSTR)lpName, (LPSTR)RT_DIALOG)) {

        if (h = LOADRESOURCE(hmod, h)) {

            if (p = LOCKRESOURCE(h, hmod)) {

                i = DialogBoxIndirectParamAorW(hmod,
                                               p,
                                               hwndOwner,
                                               lpDialogFunc,
                                               dwInitParam,
                                               SCDLG_ANSI);

                UNLOCKRESOURCE(h, hmod);
            }

            FREERESOURCE(h, hmod);
        }
    }

    return i;
}


FUNCLOG5(LOG_GENERAL, INT_PTR, WINAPI, DialogBoxParamW, HINSTANCE, hmod, LPCWSTR, lpName, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
INT_PTR WINAPI DialogBoxParamW(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    HWND      hwndOwner,
    DLGPROC   lpDialogFunc,
    LPARAM    dwInitParam)
{
    HANDLE h;
    PVOID  p;
    INT_PTR i = -1;

    if (h = FINDRESOURCEW(hmod, lpName, RT_DIALOG)) {

        if (p = LoadResource(hmod, h)) {

            i = DialogBoxIndirectParamAorW(hmod,
                                           p,
                                           hwndOwner,
                                           lpDialogFunc,
                                           dwInitParam,
                                           0);
        }
    }

    return i;
}

/***************************************************************************\
* CreateDialogParamA (API)
* CreateDialogParamW (API)
*
* Loads the resource, creates a dialog from that template, return s the
* window handle.
*
* 05-Apr-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, HWND, WINAPI, CreateDialogParamA, HINSTANCE, hmod, LPCSTR, lpName, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
HWND WINAPI CreateDialogParamA(
    HINSTANCE hmod,
    LPCSTR    lpName,
    HWND      hwndOwner,
    DLGPROC   lpDialogFunc,
    LPARAM    dwInitParam)
{
    HANDLE         h;
    LPDLGTEMPLATEA p;
    HWND           hwnd = NULL;

    if (h = FINDRESOURCEA(hmod, lpName, (LPSTR)RT_DIALOG)) {

        if (h = LOADRESOURCE(hmod, h)) {

            if (p = (LPDLGTEMPLATEA)LOCKRESOURCE(h, hmod)) {

                hwnd = CreateDialogIndirectParamAorW(hmod,
                                                     (LPCDLGTEMPLATE)p,
                                                     hwndOwner,
                                                     lpDialogFunc,
                                                     dwInitParam,
                                                     SCDLG_ANSI);

                UNLOCKRESOURCE(h, hmod);
            }

            FREERESOURCE(h, hmod);
        }
    }

    return hwnd;
}


FUNCLOG5(LOG_GENERAL, HWND, WINAPI, CreateDialogParamW, HINSTANCE, hmod, LPCWSTR, lpName, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
HWND WINAPI CreateDialogParamW(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    HWND      hwndOwner,
    DLGPROC   lpDialogFunc,
    LPARAM    dwInitParam)
{
    HANDLE h;
    PVOID  p;
    HWND   hwnd = NULL;

    if (h = FINDRESOURCEW(hmod, lpName, RT_DIALOG)) {

        if (h = LOADRESOURCE(hmod, h)) {

            if (p = LOCKRESOURCE(h, hmod)) {

                hwnd = CreateDialogIndirectParamAorW(hmod,
                                                     p,
                                                     hwndOwner,
                                                     lpDialogFunc,
                                                     dwInitParam,
                                                     0);

                UNLOCKRESOURCE(h, hmod);
            }

            FREERESOURCE(h, hmod);
        }
    }

    return hwnd;
}

/***************************************************************************\
* DestroyCursor (API)
*
* Client wrapper for NtUserDestroyCursor.
*
* 28-Nov-1994 JimA      Created.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, DestroyCursor, HCURSOR, hcur)
BOOL WINAPI DestroyCursor(
    HCURSOR hcur)
{
    return NtUserDestroyCursor(hcur, CURSOR_CALLFROMCLIENT);
}

/***************************************************************************\
* CreateIcoCur
*
*
\***************************************************************************/

HICON CreateIcoCur(
    PCURSORDATA lpi)
{
    HCURSOR hcur;

    UserAssert(lpi->hbmColor || lpi->hbmMask);

    hcur = (HCURSOR)NtUserCallOneParam((lpi->CURSORF_flags & CURSORF_GLOBAL),
                                       SFI__CREATEEMPTYCURSOROBJECT);

    if (hcur == NULL)
        return NULL;

#if DBG
    {
        BITMAP bmMask;
        BITMAP bmColor;

        UserAssert(GetObject(KHBITMAP_TO_HBITMAP(lpi->hbmMask), sizeof(BITMAP), &bmMask));

        /* Bug 252902 - joejo
         * Since the width and height of the mask bitmap is set below
         * we really don't need to assert on the width/height check. Throwing
         * a warning should be good enough.
         */
        if (bmMask.bmWidth != (LONG)lpi->cx) {
           RIPMSG1(RIP_WARNING, "Mask width not equal to requested width: lpi %#p", lpi);
        }

        if (bmMask.bmHeight != (LONG)lpi->cy) {
           RIPMSG1(RIP_WARNING, "Mask height not equal to requested height: lpi %#p", lpi);
        }

        if (lpi->hbmColor) {
            UserAssert(GetObject(KHBITMAP_TO_HBITMAP(lpi->hbmColor), sizeof(BITMAP), &bmColor));
            UserAssert(bmMask.bmHeight == bmColor.bmHeight * 2);
            UserAssert(bmMask.bmWidth  == bmColor.bmWidth);
        }
    }
#endif

    if (_SetCursorIconData(hcur, lpi))
        return hcur;

    NtUserDestroyCursor(hcur, CURSOR_ALWAYSDESTROY);

    return NULL;
}

/***************************************************************************\
* CreateIcoCurIndirect
*
*
\***************************************************************************/
HCURSOR CreateIcoCurIndirect(
    PCURSORDATA pcurCreate,
    UINT cPlanes,
    UINT cBitsPixel,
    CONST BYTE *lpANDbits,
    CONST BYTE *lpXORbits)
{
    int cbBits;
    HCURSOR hcurNew;
    BOOL bColor;
    UINT cx;
    UINT cy;
    LPBYTE pBits = NULL;

    /*
     * Allocate CURSOR structure.
     */
    hcurNew = (HCURSOR)NtUserCallOneParam(0, SFI__CREATEEMPTYCURSOROBJECT);
    if (hcurNew == NULL) {
        return NULL;
    }

    /*
     * If there is no Color bitmap, create a single buffer that contains both
     * the AND and XOR bits.  The AND bitmap is always MonoChrome
     */
    bColor = (cPlanes | cBitsPixel) > 1;

    if (!bColor) {
        cbBits = (((pcurCreate->cx + 0x0F) & ~0x0F) >> 3) * pcurCreate->cy;

        pBits = (LPBYTE)UserLocalAlloc(HEAP_ZERO_MEMORY, cbBits * 2);
        if (pBits == NULL) {
            NtUserDestroyCursor(hcurNew, CURSOR_ALWAYSDESTROY);
            return NULL;
        }

        RtlCopyMemory(pBits, lpANDbits, cbBits);
        RtlCopyMemory(pBits + cbBits, lpXORbits, cbBits);
        lpANDbits = pBits;
    }

    /*
     * Create hbmMask (it's always MonoChrome).
     */
    cx = pcurCreate->cx;
    cy = pcurCreate->cy * 2;

    pcurCreate->hbmMask = CreateBitmap(cx, cy, 1, 1, lpANDbits);

    if (pcurCreate->hbmMask == NULL) {

        /*
         * If this is a COLOR icon/cursor, lpANDBits doesn't need to be
         * pcurCreate->cy * 2; indeed, we don't use this double height at all.
         * This is a bug that will be fixed post 4.0.
         * For now, let's try to handle the case where the CreateBitmap call
         * failed because the caller didn't pass in a double height AND mask
         * (Win95 doesn't have this bug)
         */
        if (bColor) {
            RIPMSG0(RIP_WARNING,
                    "CreateIcoCurIndirect: Retrying hbmMask creation.");

            cbBits = (((pcurCreate->cx + 0x0F) & ~0x0F) >> 3) * pcurCreate->cy;
            pBits = (LPBYTE)UserLocalAlloc(HEAP_ZERO_MEMORY, cbBits*2);
            if (pBits == NULL) {
                NtUserDestroyCursor(hcurNew, CURSOR_ALWAYSDESTROY);
                return NULL;
            }

            RtlCopyMemory(pBits, lpANDbits, cbBits);
            pcurCreate->hbmMask = CreateBitmap(cx, cy, 1, 1, pBits);
            UserLocalFree(pBits);

            pBits = NULL;
        }

        if (pcurCreate->hbmMask == NULL) {

            /*
             * CreateBitmap() failed.  Clean-up and get out of here.
             */
            NtUserDestroyCursor(hcurNew, CURSOR_ALWAYSDESTROY);

            if (pBits != NULL) {
                UserLocalFree(pBits);
            }

            return NULL;
        }
    }

    /*
     * Create hbmColor or NULL it so that CallOEMCursor doesn't think we are
     * color.
     */
    if (bColor) {
        pcurCreate->hbmColor = CreateBitmap(cx,
                                            cy / 2,
                                            cPlanes,
                                            cBitsPixel,
                                            lpXORbits);

        if (pcurCreate->hbmColor == NULL) {

            /*
             * CreateBitmap() failed.  Clean-up and get out of here.
             */
            DeleteObject(KHBITMAP_TO_HBITMAP(pcurCreate->hbmMask));
            NtUserDestroyCursor(hcurNew, CURSOR_ALWAYSDESTROY);
            return NULL;
        }

        pcurCreate->bpp = (cPlanes * cBitsPixel);

    } else {
        pcurCreate->hbmColor = NULL;
        pcurCreate->bpp      = 1;
    }

    /*
     * Load contents into the cursor/icon object
     */
    pcurCreate->cy            = cy;
    pcurCreate->lpModName     = NULL;
    pcurCreate->lpName        = NULL;
    pcurCreate->rt            = 0;
    pcurCreate->CURSORF_flags = 0;

    if (_SetCursorIconData(hcurNew, pcurCreate)) {
        if (pBits != NULL) {
            UserLocalFree(pBits);
        }
        return hcurNew;
    }

    /*
     * Could not set up cursor/icon, so free resources.
     */
    NtUserDestroyCursor(hcurNew, CURSOR_ALWAYSDESTROY);
    DeleteObject(KHBITMAP_TO_HBITMAP(pcurCreate->hbmMask));

    if (pcurCreate->hbmColor) {
        DeleteObject(KHBITMAP_TO_HBITMAP(pcurCreate->hbmColor));
    }

    if (pBits != NULL) {
        UserLocalFree(pBits);
    }

    return NULL;
}

/***************************************************************************\
* CreateCursor (API)
*
* History:
* 26-Feb-1991 MikeKe    Created.
* 01-Aug-1991 IanJa     Init cur.pszModname or DestroyCursor will work
\***************************************************************************/
HCURSOR WINAPI CreateCursor(
    HINSTANCE hModule,
    int       iXhotspot,
    int       iYhotspot,
    int       iWidth,
    int       iHeight,
    LPBYTE    lpANDplane,
    LPBYTE    lpXORplane)
{
    CURSORDATA cur;
    UNREFERENCED_PARAMETER(hModule);

    if ((iXhotspot < 0) || (iXhotspot > iWidth) ||
        (iYhotspot < 0) || (iYhotspot > iHeight)) {
        return 0;
    }

    RtlZeroMemory(&cur, sizeof(cur));
    cur.xHotspot = (SHORT)iXhotspot;
    cur.yHotspot = (SHORT)iYhotspot;
    cur.cx       = (DWORD)iWidth;
    cur.cy       = (DWORD)iHeight;

    return CreateIcoCurIndirect(&cur, 1, 1, lpANDplane, lpXORplane);
}

/***************************************************************************\
* CreateIcon (API)
*
* History:
* 26-Feb-1991 MikeKe    Created.
* 01-Aug-1991 IanJa     Init cur.pszModname so DestroyIcon will work
\***************************************************************************/
HICON WINAPI CreateIcon(
    HINSTANCE  hModule,
    int        iWidth,
    int        iHeight,
    BYTE       planes,
    BYTE       bpp,
    CONST BYTE *lpANDplane,
    CONST BYTE *lpXORplane)
{
    CURSORDATA cur;
    UNREFERENCED_PARAMETER(hModule);

    RtlZeroMemory(&cur, sizeof(cur));
    cur.xHotspot = (SHORT)(iWidth / 2);
    cur.yHotspot = (SHORT)(iHeight / 2);
    cur.cx       = (DWORD)iWidth;
    cur.cy       = (DWORD)iHeight;

    return CreateIcoCurIndirect(&cur, planes, bpp, lpANDplane, lpXORplane);
}

/***************************************************************************\
* CreateIconIndirect (API)
*
* Creates an icon or cursor from an ICONINFO structure. Does not destroy
* cursor/icon bitmaps.
*
* 24-Jul-1991 ScottLu   Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, HICON, WINAPI, CreateIconIndirect, PICONINFO, piconinfo)
HICON WINAPI CreateIconIndirect(
    PICONINFO piconinfo)
{
    HCURSOR    hcur;
    CURSORDATA cur;
    BITMAP     bmMask;
    BITMAP     bmColor;
    HBITMAP    hbmpBits2, hbmpMem;
    HDC        hdcMem;
    UINT       LR_flags = LR_DEFAULTCOLOR;

    /*
     * Make sure the bitmaps are real, and get their dimensions.
     */
    if (!GetObjectW(piconinfo->hbmMask, sizeof(BITMAP), &bmMask))
        return NULL;

    if (piconinfo->hbmColor != NULL) {
        if (GetObjectW(piconinfo->hbmColor, sizeof(BITMAP), &bmColor)) {
            if (bmColor.bmPlanes == 1 && bmColor.bmBitsPixel == 32) {
                /*
                 * The color bitmap is a single plane, 32bpp image.  As such,
                 * it might contain an alpha channel, so we have to preserve
                 * it as a DIB.
                 */
                LR_flags |= LR_CREATEREALDIB;
            }
        } else {
            return NULL;
        }
    }


    /*
     * Allocate CURSOR structure.
     */
    hcur = (HCURSOR)NtUserCallOneParam(0, SFI__CREATEEMPTYCURSOROBJECT);
    if (hcur == NULL)
        return NULL;

    /*
     * Internally, USER stores the height as 2 icons high - because when
     * loading bits from a resource, in both b/w and color icons, the
     * bits are stored on top of one another (AND/XOR mask, AND/COLOR bitmap).
     * When bitmaps are passed in to CreateIconIndirect(), they are passed
     * as two bitmaps in the color case, and one bitmap (with the stacked
     * masks) in the black and white case.  Adjust cur.cy so it is 2 icons
     * high in both cases.
     */

    RtlZeroMemory(&cur, sizeof(cur));
    cur.cx = bmMask.bmWidth;

    if (piconinfo->hbmColor == NULL) {

        cur.cy  = bmMask.bmHeight;
        cur.bpp = 1;

    } else {
        cur.cy       = bmMask.bmHeight * 2;
        cur.bpp      = (DWORD)(bmColor.bmBitsPixel * bmColor.bmPlanes);
        cur.hbmColor = CopyBmp(piconinfo->hbmColor, 0, 0, LR_flags);

        if (cur.hbmColor == NULL) {
            RIPMSG0(RIP_WARNING, "CreateIconIndirect: Failed to copy piconinfo->hbmColor");
            goto CleanUp;
        }
    }

    /*
     * hbmMask must always be double height, even for color icons.
     * So cy might be equal to bmMask.bmHeight * 2 at this point.
     * If this is the case, the second half of hbmMask won't be initilized;
     * nobody is supposed to use it but GDI expects it there when checking the
     * bitmap dimensions (for cursors)
     */
    cur.hbmMask  =  CreateBitmap(cur.cx, cur.cy, 1, 1, NULL);

    if (cur.hbmMask == NULL) {
        RIPMSG0(RIP_WARNING, "CreateIconIndirect: Failed to create cur.hbmMask");
        goto CleanUp;
    }

    RtlEnterCriticalSection(&gcsHdc);


    if (hdcMem = CreateCompatibleDC (ghdcBits2)) {

        hbmpMem = SelectObject(hdcMem, KHBITMAP_TO_HBITMAP(cur.hbmMask));
        hbmpBits2 = SelectObject(ghdcBits2, piconinfo->hbmMask);

        BitBlt(hdcMem,
               0,
               0,
               bmMask.bmWidth,
               bmMask.bmHeight,
               ghdcBits2,
               0,
               0,
               SRCCOPY);

        SelectObject(hdcMem, hbmpMem);
        SelectObject(ghdcBits2, hbmpBits2);
        DeleteDC (hdcMem);

    } else {

        RtlLeaveCriticalSection(&gcsHdc);
        RIPMSG0(RIP_WARNING, "CreateIconIndirect: CreateCompatibleDC failed");
        goto CleanUp;
    }

    RtlLeaveCriticalSection(&gcsHdc);

    /*
     * rt and Hotspot
     */
    if (piconinfo->fIcon) {
        cur.rt        = PTR_TO_ID(RT_ICON);
        cur.xHotspot = (SHORT)(cur.cx / 2);
        cur.yHotspot = (SHORT)(cur.cy / 4);
    } else {
        cur.rt        = PTR_TO_ID(RT_CURSOR);
        cur.xHotspot = ((SHORT)piconinfo->xHotspot);
        cur.yHotspot = ((SHORT)piconinfo->yHotspot);
    }


    if (_SetCursorIconData(hcur, &cur)) {
        return hcur;
    }

CleanUp:
    /*
     * Note that if this fails, the bitmaps have NOT been made public.
     */
    if (cur.hbmMask != NULL) {
        DeleteObject(KHBITMAP_TO_HBITMAP(cur.hbmMask));
    }
    if (cur.hbmColor != NULL) {
        DeleteObject(KHBITMAP_TO_HBITMAP(cur.hbmColor));
    }

    NtUserDestroyCursor(hcur, CURSOR_ALWAYSDESTROY);
    return NULL;
}

/***************************************************************************\
* GetIconInfo (API)
*
* Returns icon information, including bitmaps.
*
* 24-Jul-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, GetIconInfo, HICON, hicon, PICONINFO, piconinfo)
BOOL WINAPI GetIconInfo(
    HICON     hicon,
    PICONINFO piconinfo)
{
    return NtUserGetIconInfo(hicon, piconinfo, NULL, NULL, NULL, FALSE);
}

/***************************************************************************\
* GetCursorFrameInfo (API)
*
* Returns cursor information.
*
* 24-Jul-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, HCURSOR, WINAPI, GetCursorFrameInfo, HCURSOR, hcur, LPWSTR, lpName, int, iFrame, LPDWORD, pjifRate, LPINT, pccur)
HCURSOR WINAPI GetCursorFrameInfo(
    HCURSOR hcur,
    LPWSTR  lpName,
    int     iFrame,
    LPDWORD pjifRate,
    LPINT   pccur)
{
    /*
     * Caller wants us to return the version of this cursor that is stored
     * in the display driver.
     */
    if (hcur == NULL) {

        return LoadIcoCur(NULL,
                          lpName,
                          RT_CURSOR,
                          0,
                          0,
                          LR_DEFAULTSIZE);
    }

    return NtUserGetCursorFrameInfo(hcur, iFrame, pjifRate, pccur);
}

/***************************************************************************\
* _FreeResource   (API)
* _LockResource   (API)
* _UnlockResource (API)
*
* These are dummy routines that need to exist for the apfnResCallNative
* array, which is used when calling the run-time libraries.
*
\***************************************************************************/

BOOL WINAPI _FreeResource(
    HANDLE    hResData,
    HINSTANCE hModule)
{
    UNREFERENCED_PARAMETER(hResData);
    UNREFERENCED_PARAMETER(hModule);

    return FALSE;
}

LPSTR WINAPI _LockResource(
    HANDLE    hResData,
    HINSTANCE hModule)
{
    UNREFERENCED_PARAMETER(hModule);

    return (LPSTR)(hResData);
}

BOOL WINAPI _UnlockResource(
    HANDLE    hResData,
    HINSTANCE hModule)
{
    UNREFERENCED_PARAMETER(hResData);
    UNREFERENCED_PARAMETER(hModule);

    return TRUE;
}

/***************************************************************************\
* LookupIconIdFromDirectory (API)
*
* This searches through an icon directory for the icon that best fits the
* current display device.
*
* 24-07-1991 ScottLu    Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, int, WINAPI, LookupIconIdFromDirectory, PBYTE, presbits, BOOL, fIcon)
int WINAPI LookupIconIdFromDirectory(
    PBYTE presbits,
    BOOL  fIcon)
{
    return LookupIconIdFromDirectoryEx(presbits, fIcon, 0, 0, 0);
}

/***************************************************************************\
* LookupIconIdFromDirectoryEx (API)
*
*
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, int, WINAPI, LookupIconIdFromDirectoryEx, PBYTE, presbits, BOOL, fIcon, int, cxDesired, int, cyDesired, UINT, LR_flags)
int WINAPI LookupIconIdFromDirectoryEx(
    PBYTE           presbits,
    BOOL            fIcon,
    int             cxDesired,
    int             cyDesired,
    UINT            LR_flags)
{
    ConnectIfNecessary(0);

    return RtlGetIdFromDirectory(presbits,
                                 fIcon,
                                 cxDesired,
                                 cyDesired,
                                 LR_flags,
                                 NULL);
}
/***************************************************************************\
* LoadCursorIconFromResource (API)
*
* Loads animated icon/cursor from a pointer to a resource
*
* 02-20-1996 GerardoB    Created.
\***************************************************************************/
HANDLE LoadCursorIconFromResource(
    PBYTE   presbits,
    LPCWSTR lpName,
    int     cxDesired,
    int     cyDesired,
    UINT    LR_flags)
{
    BOOL     fAni;
    FILEINFO fi;
    LPWSTR   lpwszRT;

    fi.pFileMap = presbits;
    fi.pFilePtr = fi.pFileMap;
    fi.pFileEnd = fi.pFileMap + sizeof (RTAG) + ((RTAG *)presbits)->ckSize;
    fi.pszName  = lpName;

    return LoadCursorIconFromFileMap(&fi,
                                     &lpwszRT,
                                     cxDesired,
                                     cyDesired,
                                     LR_flags,
                                     &fAni);
}
/***************************************************************************\
* CreateIconFromResource (API)
*
* Takes resource bits and creates either an icon or cursor.
*
* 24-07-1991 ScottLu    Created.
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, HICON, WINAPI, CreateIconFromResource, PBYTE, presbits, DWORD, dwResSize, BOOL, fIcon, DWORD, dwVer)
HICON WINAPI CreateIconFromResource(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL  fIcon,
    DWORD dwVer)
{
    return CreateIconFromResourceEx(presbits,
                                    dwResSize,
                                    fIcon,
                                    dwVer,
                                    0,
                                    0,
                                    LR_DEFAULTSIZE | LR_SHARED);
}

/***************************************************************************\
* CreateIconFromResourceEx (API)
*
* Takes resource bits and creates either an icon or cursor.
*
* 30-Aug-1994 FritzS    Created
\***************************************************************************/


FUNCLOG7(LOG_GENERAL, HICON, WINAPI, CreateIconFromResourceEx, PBYTE, presbits, DWORD, dwResSize, BOOL, fIcon, DWORD, dwVer, int, cxDesired, int, cyDesired, UINT, LR_flags)
HICON WINAPI CreateIconFromResourceEx(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL  fIcon,
    DWORD dwVer,
    int   cxDesired,
    int   cyDesired,
    UINT  LR_flags)
{
    UNREFERENCED_PARAMETER(dwResSize);

    /*
     * NT Specific code to validate the version.
     */
    if ((dwVer < 0x00020000) || (dwVer > 0x00030000)) {
        RIPMSG0(RIP_WARNING, "CreateIconFromResourceEx: Invalid Paramter");
        return NULL;
    }

    /*
     * Set desired size of resource based on flags and/or true
     * dimensions passed in.
     */
    cxDesired = GetIcoCurWidth(cxDesired , fIcon, LR_flags, 0);
    cyDesired = GetIcoCurHeight(cyDesired, fIcon, LR_flags, 0);

    if (ISRIFFFORMAT(presbits)) {
        return LoadCursorIconFromResource (presbits, NULL, cxDesired, cyDesired, LR_flags);
    } else {
        return ConvertDIBIcon((LPBITMAPINFOHEADER)presbits,
                              NULL,
                              NULL,
                              fIcon,
                              cxDesired,
                              cyDesired,
                              LR_flags);
    }
}

/***************************************************************************\
* Convert1BppToMonoBitmap
*
* This routine converts a 1bpp bitmap to a true monochrome surface.  This
* is done for bitmaps which need to do foreground/background color matching
* at output time.  Otherwise, a 1bpp will just match to its palette.
*
* NOTE: This routine deletes the original bitmap if successful.  If failure
*       we'll return the original bitmap.
*
* History:
* 17-Apr-1996 ChrisWil  Created
\***************************************************************************/

HBITMAP Convert1BppToMonoBitmap(
    HDC     hdcSrc,
    HBITMAP hbm1Bpp)
{
    HBITMAP hbmMono = hbm1Bpp;
    HBITMAP hbmDst;
    HBITMAP hbmS;
    HBITMAP hbmD;
    HDC     hdcDst;
    BITMAP  bm;

    if (hdcDst = CreateCompatibleDC(hdcSrc)) {

        GetObject(hbm1Bpp, sizeof(BITMAP), &bm);

        if (hbmDst = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL)) {

            hbmS = SelectBitmap(hdcSrc, hbm1Bpp);
            hbmD = SelectBitmap(hdcDst, hbmDst);

            BitBlt(hdcDst,
                   0,
                   0,
                   bm.bmWidth,
                   bm.bmHeight,
                   hdcSrc,
                   0,
                   0,
                   SRCCOPY);

            SelectBitmap(hdcSrc, hbmS);
            SelectBitmap(hdcDst, hbmD);

            hbmMono = hbmDst;
            DeleteObject(hbm1Bpp);
        }

        DeleteDC(hdcDst);
    }

    return hbmMono;
}

/***************************************************************************\
* CreateScreenBitmap
*
* This routine creates a screen bitmap.  We use the CreateDIBitmap call
* to do compatible color-matching with Win95.  Also, note that this
* routine takes in WORD aligned bits.
*
\***************************************************************************/

HBITMAP CreateScreenBitmap(
    int    cx,
    int    cy,
    UINT   planes,
    UINT   bpp,
    LPSTR  lpBits,
    LPBOOL pf1Bpp)
{
    HDC     hdcScreen;
    HBITMAP hbm = NULL;
    DWORD   dwCount;

    static struct {
        BITMAPINFOHEADER bi;
        DWORD            ct[16];
    } dib4Vga = {{sizeof(BITMAPINFOHEADER),
                  0,
                  0,
                  1,
                  4,
                  BI_RGB,
                  0,
                  0,
                  0,
                  16,
                  0
                 },
                 {0x00000000,
                  0x00800000,
                  0x00008000,
                  0x00808000,
                  0x00000080,
                  0x00800080,
                  0x00008080,
                  0x00C0C0C0,
                  0x00808080,
                  0x00FF0000,
                  0x0000FF00,
                  0x00FFFF00,
                  0x000000FF,
                  0x00FF00FF,
                  0x0000FFFF,
                  0x00FFFFFF
                 }
                };

    static struct {
        BITMAPINFOHEADER bi;
        DWORD            ct[2];
    } dib1Vga = {{sizeof(BITMAPINFOHEADER),
                  0,
                  0,
                  1,
                  1,
                  BI_RGB,
                  0,
                  0,
                  0,
                  2,
                  0
                 },
                 {0x00000000,
                  0x00FFFFFF
                 }
                };


    /*
     * Create the surface.
     */
    if (hdcScreen = GETINITDC()) {

        /*
         * This appears to mess up color to mono conversion by losing all
         * the data and forcing all non-forground colors to black.
         * (try copyimage with IDC_WARNING_DEFAULT)
         * This is what win95 does but their system works.  The scary thing
         * (according to marke) is that win95 may have changed GDI to make
         * this work.
         *
         * In order to get nearest-color-matching compatible with Win95,
         * we're going to need to use the CreateDIBitmap() for mono-surfaces.
         * This code-path will do nearest-color, rather than color-matching.
         */
        if ((bpp == 1) && (planes == 1)) {

            dib1Vga.bi.biWidth  = cx;
            dib1Vga.bi.biHeight = cy;

            hbm = CreateDIBitmap(hdcScreen,
                                 (LPBITMAPINFOHEADER)&dib1Vga,
                                 CBM_CREATEDIB,
                                 NULL,
                                 (LPBITMAPINFO)&dib1Vga,
                                 DIB_RGB_COLORS);

            *pf1Bpp = TRUE;

        } else {

            if (((planes == 0) || (planes == gpsi->Planes)) &&
                ((bpp == 0) || (bpp == gpsi->BitsPixel))) {

                hbm = CreateCompatibleBitmap(hdcScreen, cx, cy);

            } else {

                dib4Vga.bi.biBitCount = planes * bpp ? planes * bpp : gpsi->BitCount;

#if 0 // We use to do the dib-section create, but this breaks icons
      // when they are made public (can't make a dibsection public). So
      // we now wil create this as a real-dib.
      //
                {
                DWORD dwDummy;

                dib4Vga.bi.biWidth    =  cx;
                dib4Vga.bi.biHeight   = -cy;     // top-down DIB (like a DDB)

                hbm = CreateDIBSection(hdcScreen,
                                       (LPBITMAPINFO)&dib4Vga,
                                       DIB_RGB_COLORS,
                                       (LPVOID)&dwDummy,
                                       0,
                                       0);
                }
#else
                dib4Vga.bi.biWidth  = cx;
                dib4Vga.bi.biHeight = cy;

                hbm = CreateDIBitmap(hdcScreen,
                                     (LPBITMAPINFOHEADER)&dib4Vga,
                                     CBM_CREATEDIB,
                                     NULL,
                                     (LPBITMAPINFO)&dib4Vga,
                                     DIB_RGB_COLORS);
#endif
            }
        }

        RELEASEINITDC(hdcScreen);
    }

    if (hbm && lpBits) {

        BITMAP bm;

        GetObject(hbm, sizeof(BITMAP), &bm);
        dwCount = (DWORD)(UINT)(bm.bmWidthBytes * bm.bmPlanes) * (DWORD)(UINT)cy;
        SetBitmapBits(hbm, dwCount, lpBits);
    }

    return hbm;
}

/***************************************************************************\
* LoadBmp (Worker)
*
* This routine decides whether the bitmap to be loaded is in old or new (DIB)
* format and calls appropriate handlers.
*
* History:
* 24-Sep-1990 MikeKe    From Win30.
* 18-Jun-1991 ChuckWh   Added local bitmap handle support.
* 05-Sep-1995 ChrisWil  Port/Change for Chicago functionality.
\***************************************************************************/
HBITMAP LoadBmp(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    int       cxDesired,
    int       cyDesired,
    UINT      flags)
{
    HBITMAP hbmp = NULL;
    BOOL fFree = FALSE, f1Bpp = FALSE;

/***************************************************************************\
* Bitmap Resource Table
*
* As of WIN4.0, most system bitmaps are rendered instead of grabbed from the
* display driver.  However, a lot of apps, especially those that fake their
* own MDI, do LoadBitmap(NULL, OBM_...) to grab a system bitmap.  So we
* hook those requests here and copy our rendered bitmaps into a newly-
* created bitmap.  Note that this is actually faster than loading from a
* resource table!
*
* BOGUS -- give 'em old close buttons, not new cool X's
*
\***************************************************************************/
#define MAX_BMPMAP  32

    CONST static MAPRES MapOemBmp[MAX_BMPMAP] = {

        {OBM_BTNCORNERS , OBI_RADIOMASK      ,               },
        {OBM_BTSIZE     , OBI_NCGRIP         ,               },
        {OBM_CHECK      , OBI_MENUCHECK      , MR_MONOCHROME },
        {OBM_CHECKBOXES , OBI_CHECK          ,               },
        {OBM_COMBO      , OBI_DNARROW        ,               },
        {OBM_DNARROW    , OBI_DNARROW        ,               },
        {OBM_DNARROWD   , OBI_DNARROW_D      ,               },
        {OBM_DNARROWI   , OBI_DNARROW_I      ,               },
        {OBM_LFARROW    , OBI_LFARROW        ,               },
        {OBM_LFARROWD   , OBI_LFARROW_D      ,               },
        {OBM_LFARROWI   , OBI_LFARROW_I      ,               },

        /*
         * Use MONO bitmaps in future once flat/mono controls are worked out.
         */
        {OBM_OLD_DNARROW, OBI_DNARROW        , MR_FAILFOR40  },
        {OBM_OLD_LFARROW, OBI_LFARROW        , MR_FAILFOR40  },
        {OBM_OLD_REDUCE , OBI_REDUCE_MBAR    , MR_FAILFOR40  },
        {OBM_OLD_RESTORE, OBI_RESTORE_MBAR   , MR_FAILFOR40  },
        {OBM_OLD_RGARROW, OBI_RGARROW        , MR_FAILFOR40  },
        {OBM_OLD_UPARROW, OBI_UPARROW        , MR_FAILFOR40  },
        {OBM_OLD_ZOOM   , OBI_ZOOM           , MR_FAILFOR40  },

        {OBM_MNARROW    , OBI_MENUARROW      , MR_MONOCHROME },
        {OBM_REDUCE     , OBI_REDUCE_MBAR    ,               },
        {OBM_REDUCED    , OBI_REDUCE_MBAR_D  ,               },
        {OBM_RESTORE    , OBI_RESTORE_MBAR   ,               },
        {OBM_RESTORED   , OBI_RESTORE_MBAR_D ,               },
        {OBM_RGARROW    , OBI_RGARROW        ,               },
        {OBM_RGARROWD   , OBI_RGARROW_D      ,               },
        {OBM_RGARROWI   , OBI_RGARROW_I      ,               },
        {OBM_SIZE       , OBI_NCGRIP         ,               },
        {OBM_UPARROW    , OBI_UPARROW        ,               },
        {OBM_UPARROWD   , OBI_UPARROW_D      ,               },
        {OBM_UPARROWI   , OBI_UPARROW_I      ,               },
        {OBM_ZOOM       , OBI_ZOOM           ,               },
        {OBM_ZOOMD      , OBI_ZOOM_D         ,               }
    };


    /*
     * If hmod is valid, load the client-side bits.
     */
    if (hmod == NULL) {

        HBITMAP hOldBmp;
        WORD    bm;
        WORD    wID;
        BOOL    fCombo;
        BOOL    fCheckBoxes;
        int     i;
        RECT    rc;
        BOOL    fSysMenu = FALSE;
        BOOL    fMenu = FALSE;
        BOOL    fMono = FALSE;

        hmod = hmodUser;

        /*
         * Since the resource is coming from USER32, we only
         * deal with ID types.
         */
        wID = PTR_TO_ID(lpName);

        switch(wID) {
        case OBM_OLD_CLOSE:
            if (GETAPPVER() >= VER40) {
                goto FailOldLoad;
            }

            /*
             * fall through to the Close case.
             */

        case OBM_CLOSE:
            /* the new look for the system menu is to use the window's
             * class icon -- but since here we don't know which window
             * they'll be using this for, fall back on the good ole'
             * windows logo icon
             */
            cxDesired = (SYSMET(CXMENUSIZE) + SYSMET(CXEDGE)) * 2;
            cyDesired = SYSMET(CYMENUSIZE) + (2 * SYSMET(CYEDGE));
            fSysMenu  = TRUE;
            break;

        case OBM_TRUETYPE: {

                PVOID  p;
                HANDLE h;
                int    nOffset;

                /*
                 * Offset into resource.
                 */
                if (gpsi->dmLogPixels == 120) {
                    nOffset = OFFSET_120_DPI;
                } else {
                    nOffset = OFFSET_96_DPI;
                }

                lpName = (LPWSTR)(MAX_RESOURCE_INDEX -
                        ((ULONG_PTR)lpName) + nOffset);

                if (h = FINDRESOURCEW(hmod, (LPWSTR)lpName, RT_BITMAP)) {

                    if (h = LOADRESOURCE(hmod, h)) {

                        if (p = LOCKRESOURCE(h, hmod)) {


                            hbmp = (HBITMAP)ObjectFromDIBResource(hmod,
                                                                  lpName,
                                                                  RT_BITMAP,
                                                                  cxDesired,
                                                                  cyDesired,
                                                                  flags);

                            UNLOCKRESOURCE(h, hmod);
                        }

                        FREERESOURCE(h, hmod);
                    }
                }

                goto LoadBmpDone;
            }
            break;

        default:
            fCombo      = (wID == OBM_COMBO);
            fCheckBoxes = (wID == OBM_CHECKBOXES);

            /*
             * hard loop to check for mapping.
             */
            for (i=0; (i < MAX_BMPMAP) && (MapOemBmp[i].idDisp != wID); i++);

            if (i == MAX_BMPMAP)
                goto LoadForReal;

            if ((MapOemBmp[i].bFlags & MR_FAILFOR40) &&
                    (GETAPPVER() >= VER40)) {

FailOldLoad:
                RIPMSG0(RIP_WARNING, "LoadBitmap: old IDs not allowed for 4.0 apps");
                return NULL;
            }

            if (MapOemBmp[i].bFlags & MR_MONOCHROME)
                fMono = TRUE;

            bm = MapOemBmp[i].idUser;

            if ((bm == OBI_REDUCE_MBAR) || (bm == OBI_RESTORE_MBAR))
                fMenu = TRUE;

            cxDesired = gpsi->oembmi[bm].cx;
            cyDesired = gpsi->oembmi[bm].cy;

            if (fMenu)
                cyDesired += (2 * SYSMET(CYEDGE));

            if (fCheckBoxes) {
                cxDesired *= NUM_BUTTON_STATES;
                cyDesired *= NUM_BUTTON_TYPES;
            } else if (fCombo) {
                cxDesired -= (2 * SYSMET(CXEDGE));
                cyDesired -= (2 * SYSMET(CYEDGE));
            }
            break;
        }

        /*
         * Creates DIB section or color compatible.
         */
        if (fMono) {

            /*
             * Create mono-bitmaps as DIBs on NT.  On Win95 this is
             * called as:
             *
             *   hbmp = CreateBitmap(cxDesired, cyDesired, 1, 1, NULL);
             *
             * However, due to color-matching differences, we need to
             * use dibs to get the nearest-color-matching.  At the
             * end of this routine we will convert to a true-mono so that
             * foreground/background matching can be performed normally.
             */
            hbmp = CreateScreenBitmap(cxDesired, cyDesired, 1, 1, NULL, &f1Bpp);

        } else {

            hbmp = CreateScreenBitmap(cxDesired, cyDesired, 0, 0, NULL, &f1Bpp);
        }

        if (hbmp == NULL)
            goto LoadBmpDone;

        RtlEnterCriticalSection(&gcsHdc);
        hOldBmp = SelectBitmap(ghdcBits2, hbmp);
        UserAssert(GetBkColor(ghdcBits2) == RGB(255,255,255));
        UserAssert(GetTextColor(ghdcBits2) == RGB(0, 0, 0));

        rc.top    = 0;
        rc.left   = 0;
        rc.bottom = cyDesired;
        rc.right  = cxDesired;

        if (fMono) {
            PatBlt(ghdcBits2, 0, 0, cxDesired, cyDesired, WHITENESS);
        } else {
            FillRect(ghdcBits2,
                     &rc,
                     ((fMenu | fSysMenu) ? SYSHBR(MENU) : SYSHBR(WINDOW)));
        }

        if (fSysMenu) {
            int x = SYSMET(CXEDGE);

            cxDesired /= 2;

            for (i = 0; i < 2; i++) {

                DrawIconEx(ghdcBits2,
                           x,
                           SYSMET(CYEDGE),
                           KHICON_TO_HICON(gpsi->hIconSmWindows),
                           cxDesired - 2 * SYSMET(CXEDGE),
                           SYSMET(CYMENUSIZE) - SYSMET(CYEDGE),
                           0,
                           NULL,
                           DI_NORMAL);

                x += cxDesired;
            }
        } else if (fCombo) {
            /*
             * Revisit when we start using TTF -- that'll take care of this
             * hack.
             */
            rc.top     = -SYSMET(CYEDGE);
            rc.bottom +=  SYSMET(CYEDGE);
            rc.left    = -SYSMET(CXEDGE);
            rc.right  +=  SYSMET(CXEDGE);

            DrawFrameControl(ghdcBits2,
                             &rc,
                             DFC_SCROLL,
                             DFCS_SCROLLDOWN);

        } else if (fCheckBoxes) {
            int wType, wState, x;
            DWORD clrTextSave, clrBkSave;
            int y = 0;

            for (wType = 0; wType < NUM_BUTTON_TYPES; wType++) {
                x = 0;

                cxDesired = gpsi->oembmi[bm].cx;
                cyDesired = gpsi->oembmi[bm].cy;

                if (wType == 1) {

                    /*
                     * BOGUS UGLINESS -- will be fixed once the Graphics dudes
                     * get me the icon TTF -- I'll revisit this then and make
                     * REAL
                     */
                    clrTextSave = SetTextColor(ghdcBits2, RESCLR_BLACK);
                    clrBkSave   = SetBkColor  (ghdcBits2, RESCLR_WHITE);

                    for (wState = 0; wState < NUM_BUTTON_STATES; wState++) {
                        NtUserBitBltSysBmp(ghdcBits2,
                                           x,
                                           y,
                                           cxDesired,
                                           cyDesired,
                                           gpsi->oembmi[OBI_RADIOMASK].x,
                                           gpsi->oembmi[OBI_RADIOMASK].y,
                                           SRCAND);

                        NtUserBitBltSysBmp(ghdcBits2,
                                           x,
                                           y,
                                           cxDesired,
                                           cyDesired,
                                           gpsi->oembmi[bm].x,
                                           gpsi->oembmi[bm].y,
                                           SRCINVERT);
                        x += cxDesired;
                        bm++;
                    }

                    SetTextColor(ghdcBits2, clrTextSave);
                    SetBkColor(ghdcBits2, clrBkSave);
                } else {
                    for (wState = 0; wState < NUM_BUTTON_STATES; wState++) {

                        BitBltSysBmp(ghdcBits2, x, y, bm);
                        x += cxDesired;
                        bm++;
                    }

                    /*
                     * Skip OBI_*_CDI.
                     */
                    bm++;
                }

                y += cyDesired;
            }
        } else {
            BitBltSysBmp(ghdcBits2, 0, fMenu ? SYSMET(CYEDGE) : 0, bm);
        }

        SelectBitmap(ghdcBits2, hOldBmp);

        /*
         * If the bitmap was created as a 1bpp, we need to convert to a
         * true mono-bitmap.  GDI performs different color-matching depending
         * upon this case.
         */
        if (f1Bpp && hbmp)
            hbmp = Convert1BppToMonoBitmap(ghdcBits2, hbmp);

        RtlLeaveCriticalSection(&gcsHdc);

    } else {

LoadForReal:

        hbmp = (HBITMAP)ObjectFromDIBResource(hmod,
                                              lpName,
                                              RT_BITMAP,
                                              cxDesired,
                                              cyDesired,
                                              flags);
    }

LoadBmpDone:

    return hbmp;
}

/***************************************************************************\
* LoadBitmapA (API)
* LoadBitmapW (API)
*
* Loads a bitmap from client.  If hmod == NULL, loads a bitmap from the
* system.
*
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HBITMAP, WINAPI, LoadBitmapA, HINSTANCE, hmod, LPCSTR, lpName)
HBITMAP WINAPI LoadBitmapA(
    HINSTANCE hmod,
    LPCSTR    lpName)
{
    LPWSTR  lpUniName;
    HBITMAP hRet;

    if (ID(lpName))
        return LoadBmp(hmod, (LPCWSTR)lpName, 0, 0, 0);

    if (!MBToWCS(lpName, -1, &lpUniName, -1, TRUE))
        return NULL;

    hRet = LoadBmp(hmod, lpUniName, 0, 0, 0);

    UserLocalFree(lpUniName);

    return hRet;
}


FUNCLOG2(LOG_GENERAL, HBITMAP, WINAPI, LoadBitmapW, HINSTANCE, hmod, LPCWSTR, lpName)
HBITMAP WINAPI LoadBitmapW(
    HINSTANCE hmod,
    LPCWSTR   lpName)
{
    return LoadBmp(hmod, lpName, 0, 0, 0);
}

/***************************************************************************\
* LoadCursorA (API)
* LoadCursorW (API)
*
* Loads a cursor from client.  If hmod == NULL, loads a cursor from the
* system.
*
* 05-Apr-1991 ScottLu   Rewrote to work with client server.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HCURSOR, WINAPI, LoadCursorA, HINSTANCE, hmod, LPCSTR, lpName)
HCURSOR WINAPI LoadCursorA(
    HINSTANCE hmod,
    LPCSTR    lpName)
{
    HCURSOR hRet;
    LPWSTR  lpUniName;

    if (ID(lpName))
        return LoadCursorW(hmod, (LPWSTR)lpName);

    if (!MBToWCS(lpName, -1, &lpUniName, -1, TRUE))
        return NULL;

    hRet = LoadCursorW(hmod, lpUniName);

    UserLocalFree(lpUniName);

    return hRet;
}


FUNCLOG2(LOG_GENERAL, HCURSOR, WINAPI, LoadCursorW, HINSTANCE, hmod, LPCWSTR, lpName)
HCURSOR WINAPI LoadCursorW(
    HINSTANCE hmod,
    LPCWSTR   lpName)
{

    return LoadIcoCur(hmod,
                      lpName,
                      RT_CURSOR,
                      0,
                      0,
                      LR_DEFAULTSIZE | LR_SHARED);

}

/***************************************************************************\
* LoadIconA (API)
* LoadIconW (API)
*
* Loads an icon from client.  If hmod == NULL, loads an icon from the
* system.
*
* 05-Apr-1991 ScottLu   Rewrote to work with client server.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HICON, WINAPI, LoadIconA, HINSTANCE, hmod, LPCSTR, lpName)
HICON WINAPI LoadIconA(
    HINSTANCE hmod,
    LPCSTR    lpName)
{
    HICON  hRet;
    LPWSTR lpUniName;

    if (ID(lpName))
        return LoadIconW(hmod, (LPWSTR)lpName);

    if (!MBToWCS(lpName, -1, &lpUniName, -1, TRUE))
        return NULL;

    hRet = LoadIconW(hmod, lpUniName);

    UserLocalFree(lpUniName);

    return hRet;
}


FUNCLOG2(LOG_GENERAL, HICON, WINAPI, LoadIconW, HINSTANCE, hmod, LPCWSTR, lpName)
HICON WINAPI LoadIconW(
    HINSTANCE hmod,
    LPCWSTR   lpName)
{
    return LoadIcoCur(hmod,
                      lpName,
                      RT_ICON,
                      0,
                      0,
                      LR_DEFAULTSIZE | LR_SHARED);
}

/***************************************************************************\
* LoadImageA (API)
* LoadImageW (API)
*
* Loads a bitmap, icon or cursor resource from client.  If hmod == NULL,
* then it will load from system-resources.
*
\***************************************************************************/


FUNCLOG6(LOG_GENERAL, HANDLE, WINAPI, LoadImageA, HINSTANCE, hmod, LPCSTR, lpName, UINT, type, int, cxDesired, int, cyDesired, UINT, flags)
HANDLE WINAPI LoadImageA(
    HINSTANCE hmod,
    LPCSTR    lpName,
    UINT      type,
    int       cxDesired,
    int       cyDesired,
    UINT      flags)
{
    LPWSTR lpUniName;
    HANDLE hRet;

    if (ID(lpName))
        return LoadImageW(hmod,
                          (LPCWSTR)lpName,
                          type,
                          cxDesired,
                          cyDesired,
                          flags);

    if (!MBToWCS(lpName, -1, &lpUniName, -1, TRUE))
        return NULL;

    hRet = LoadImageW(hmod, lpUniName, type, cxDesired, cyDesired, flags);

    UserLocalFree(lpUniName);

    return hRet;
}


FUNCLOG6(LOG_GENERAL, HANDLE, WINAPI, LoadImageW, HINSTANCE, hmod, LPCWSTR, lpName, UINT, IMAGE_code, int, cxDesired, int, cyDesired, UINT, flags)
HANDLE WINAPI LoadImageW(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    UINT      IMAGE_code,
    int       cxDesired,
    int       cyDesired,
    UINT      flags)
{
    /*
     * If we specified LR_LOADFROMFILE, then we can tweak the
     * flags to turn off LR_SHARED.
     */
    if (flags & LR_LOADFROMFILE)
        flags &= ~LR_SHARED;

    switch (IMAGE_code) {
    case IMAGE_BITMAP:
        return (HANDLE)LoadBmp(hmod, lpName, cxDesired, cyDesired, flags);

    case IMAGE_CURSOR:
#if 0 //CHRISWIL : oemInfo.fColorCursors doesn't exist on NT.
        if (!oemInfo.fColorCursors)
            flags |= LR_MONOCHROME;
#endif

    case IMAGE_ICON:

        /*
         * On WinNT 3.51, an app can successfully load a
         * USER icon without specifying LR_SHARED. We enable
         * these apps to succeed, but make 4.0 apps conform to
         * Windows95 behavior.
         */

        if (!hmod && GETEXPWINVER(NULL) < VER40) {
            flags |= LR_SHARED;
        }

        return (HANDLE)LoadIcoCur(hmod,
                                  lpName,
                                  ((IMAGE_code == IMAGE_ICON) ? RT_ICON : RT_CURSOR),
                                  cxDesired,
                                  cyDesired,
                                  flags);

    default:
        RIPMSG0(RIP_WARNING, "LoadImage: invalid IMAGE_code");
        return NULL;
    }
}

/***************************************************************************\
* GetIconIdEx
*
* This one accepts width, height, and other flags.  Just not exported right
* now.
*
\***************************************************************************/

UINT GetIconIdEx(
    HINSTANCE hmod,
    HANDLE    hrsd,
    LPCWSTR   lpszType,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags)
{
    int         idIcon = 0;
    LPNEWHEADER lpnh;

    if (lpnh = (LPNEWHEADER)LOCKRESOURCE(hrsd, hmod)) {

        /*
         * Do a sanity check on this data structure.  Otherwise we'll GP FAULT
         * when extracting an icon from a corrupted area.  Fix for B#9290.
         * SANKAR, 08/13/91
         */
        if ((lpnh->Reserved == 0) &&
            ((lpnh->ResType == IMAGE_ICON) || (lpnh->ResType == IMAGE_CURSOR))) {

            idIcon = LookupIconIdFromDirectoryEx((PBYTE)lpnh,
                                                 (lpszType == RT_ICON),
                                                 cxDesired,
                                                 cyDesired,
                                                 LR_flags);
        }

        UNLOCKRESOURCE(hrsd, hmod);
    }

    return idIcon;
}

/***************************************************************************\
* LoadDib (Worker)
*
* This is the worker-routine for loading a resource and returning a handle
* to the object as a dib.
*
\***************************************************************************/

HANDLE LoadDIB(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    LPWSTR    type,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags)
{
    HANDLE  hDir;
    UINT    idIcon;
    LPWSTR  lpszGroupType;
    HANDLE  hRes = NULL;

    switch (PTR_TO_ID(type)) {

    case PTR_TO_ID(RT_ICON):
    case PTR_TO_ID(RT_CURSOR):

        lpszGroupType = RT_GROUP_CURSOR + (type - RT_CURSOR);

        /*
         * For WOW support, OIC_ICON and OIC_SIZE need to be supported.
         * Since these resources match other existing resources, we map
         * them here so we produce results that emulates
         * behavor as if we had the actual resources in USER.
         *
         * Note that obsolete mapping of lpName in LoadIcoCur prevents
         * win4.0 apps from getting here.
         */
        if (hmod == hmodUser) {

            switch ((ULONG_PTR)lpName) {
            case OCR_SIZE:
                lpName = (LPCWSTR)OCR_SIZEALL_DEFAULT;
                break;

            case OCR_ICON:
                lpName = (LPCWSTR)OCR_ICON_DEFAULT;
                break;
            }
        }
        /*
         * The resource is actually a directory which contains multiple
         * individual image resources we must choose from.
         * Locate the directory
         */
        if (hDir = SplFindResource(hmod, lpName, (LPCWSTR)lpszGroupType)) {

            /*
             * Load the directory.
             */
            if (hDir = LOADRESOURCE(hmod, hDir)) {

                /*
                 * Get the name of the best individual image.
                 */
                if (idIcon = GetIconIdEx(hmod,
                                         hDir,
                                         type,
                                         cxDesired,
                                         cyDesired,
                                         LR_flags)) {

                    /*
                     * NOTE: Don't free the directory resource!!! - ChipA.
                     * We can't call SplFindResource here, because idIcon
                     * is internal to us and GetDriverResourceId()
                     * doesn't know how to map it.
                     */
                    hRes = FINDRESOURCEW(hmod, MAKEINTRESOURCE(idIcon), type);
                }

                /*
                 * BOGUS:
                 * It would be very cool if we could loop through all the
                 * items in the directory and free 'em too.  Free the ones
                 * except for the one we're about to load, that is.
                 *
                 * Free directory resources TWICE so they get really freed.
                 */
                SplFreeResource(hDir, hmod, LR_flags);
            }
        } else {
            /*
             * Failed to load a regular icon\cursor.
             * Try to load an animated icon/cursor with the same name
             */
            hRes = SplFindResource(hmod, lpName,
                    PTR_TO_ID(type) == PTR_TO_ID(RT_CURSOR) ? RT_ANICURSOR : RT_ANIICON);
        }
        break;

    case PTR_TO_ID(RT_BITMAP):
        hRes = SplFindResource(hmod, lpName, RT_BITMAP);
        break;

    default:
        RIPMSG0(RIP_WARNING, "LoadDIB: Invalid resource type");
        break;
    }

    if (hRes)
        hRes = LOADRESOURCE(hmod, hRes);

    return hRes;
}

/***************************************************************************\
* LoadIcoCur (Worker)
*
*
\***************************************************************************/

HICON LoadIcoCur(
    HINSTANCE hmod,
    LPCWSTR   pszResName,
    LPWSTR    type,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags)
{
    HICON     hico;
    LPWSTR    pszModName;
    WCHAR     achModName[MAX_PATH];

    ConnectIfNecessary(0);

    /*
     * Setup module name and handles for lookup.
     */
    if (hmod == NULL)  {

        hmod = hmodUser;
        pszModName = szUSER32;

    } else {

        WowGetModuleFileName(hmod,
                             achModName,
                             sizeof(achModName) / sizeof(WCHAR));

        pszModName = achModName;
    }

    if (LR_flags & LR_CREATEDIBSECTION)
        LR_flags = (LR_flags & ~LR_CREATEDIBSECTION) | LR_CREATEREALDIB;

    /*
     * Setup defaults.
     */
    if ((hmod == hmodUser) && !IS_PTR(pszResName)) {

        int      imapMax;
        LPMAPRES lpMapRes;

        /*
         * Map some old OEM IDs for people.
         */
        if (type == RT_ICON) {

            static MAPRES MapOemOic[] = {
                {OCR_ICOCUR, OIC_WINLOGO, MR_FAILFOR40}
            };

            lpMapRes = MapOemOic;
            imapMax  = 1;

        } else {

            static MAPRES MapOemOcr[] = {
                {OCR_ICON, OCR_ICON, MR_FAILFOR40},
                {OCR_SIZE, OCR_SIZE, MR_FAILFOR40}
            };

            lpMapRes = MapOemOcr;
            imapMax  = 2;
        }

        while (--imapMax >= 0) {

            if (lpMapRes->idDisp == PTR_TO_ID(pszResName)) {

                if ((lpMapRes->bFlags & MR_FAILFOR40) &&
                    GETAPPVER() >= VER40) {

                    RIPMSG1(RIP_WARNING,
                          "LoadIcoCur: Old ID 0x%x not allowed for 4.0 apps",
                          PTR_TO_ID(pszResName));

                    return NULL;
                }

                pszResName = MAKEINTRESOURCE(lpMapRes->idUser);
                break;
            }

            ++lpMapRes;
        }
    }

    /*
     * Determine size of requested object.
     */
    cxDesired = GetIcoCurWidth(cxDesired , (type == RT_ICON), LR_flags, 0);
    cyDesired = GetIcoCurHeight(cyDesired, (type == RT_ICON), LR_flags, 0);

    /*
     * See if this is a cached icon/cursor, and grab it if we have one
     * already.
     */
    if (LR_flags & LR_SHARED) {

        CURSORFIND cfSearch;

        /*
         * Note that win95 fails to load any USER resources unless
         * LR_SHARED is specified - so we do too.  Also, win95 will
         * ignore your cx, cy and LR_flag parameters and just give
         * you whats in the cache so we do too.
         * A shame but thats life...
         *
         * Setup search criteria.  Since this is a load, we will have
         * no source-cursor to lookup.  Find something respectable.
         */
        cfSearch.hcur = (HCURSOR)NULL;
        cfSearch.rt   = PtrToUlong(type);

        if (hmod == hmodUser) {

            cfSearch.cx  = 0;
            cfSearch.cy  = 0;
            cfSearch.bpp = 0;

        } else {

            cfSearch.cx  = cxDesired;
            cfSearch.cy  = cyDesired;

/*
 * On NT we have a more strict cache-lookup.  By passing in (zero), we
 * will tell the cache-lookup to ignore the bpp.  This fixes a problem
 * in Crayola Art Studio where the coloring-book cursor was being created
 * as an invisible cursor.  This lookup is compatible with Win95.
 */
#if 0
            cfSearch.bpp = GetIcoCurBpp(LR_flags);
#else
            cfSearch.bpp = 0;
#endif
        }

        hico = FindExistingCursorIcon(pszModName, pszResName, &cfSearch);

        if (hico != NULL)
            goto IcoCurFound;
    }

#ifdef LATER // SanfordS
    /*
     * We need to handle the case where a configurable icon has been
     * loaded from some arbitrary module or file and someone now wants
     * to load the same thing in a different size or color content.
     *
     * A cheezier alternative is to just call CopyImage on what we
     * found.
     */
    if (hmod == hmodUser) {
        hico = FindExistingCursorIcon(NULL,
                                      szUSER,
                                      type,
                                      pszResName,
                                      0,
                                      0,
                                      0);
        if (hico != NULL) {
            /*
             * Find out where the original came from and load it.
             * This may require some redesign to remember the
             * filename that LR_LOADFROMFILE images came from.
             */
            _GetIconInfo(....);
            return LoadIcoCur(....);
        }
    }
#endif

    hico = (HICON)ObjectFromDIBResource(hmod,
                                        pszResName,
                                        type,
                                        cxDesired,
                                        cyDesired,
                                        LR_flags);

IcoCurFound:

    return hico;
}

/***************************************************************************\
* ObjectFromDIBResource
*
*
\***************************************************************************/
HANDLE ObjectFromDIBResource(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    LPWSTR    type,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags)
{
    HANDLE  hObj = NULL;

    if (LR_flags & LR_LOADFROMFILE) {

        hObj = RtlLoadObjectFromDIBFile(lpName,
                                        type,
                                        cxDesired,
                                        cyDesired,
                                        LR_flags);
    } else {

        HANDLE hdib;

        hdib = LoadDIB(hmod, lpName, type, cxDesired, cyDesired, LR_flags);

        if (hdib != NULL) {

            LPBITMAPINFOHEADER lpbih;

            /*
             * We cast the resource-bits to a BITMAPINFOHEADER.  If the
             * resource is a CURSOR type, then there are actually two
             * WORDs preceeding the BITMAPINFOHDEADER indicating the
             * hot-spot.  Be careful in assuming you have a real
             * dib in this case.
             */
            if(lpbih = (LPBITMAPINFOHEADER)LOCKRESOURCE(hdib, hmod)) {

                switch (PTR_TO_ID(type)) {
                case PTR_TO_ID(RT_BITMAP):
                    /*
                     * Create a physical bitmap from the DIB.
                     */
                    hObj = ConvertDIBBitmap(lpbih,
                                            cxDesired,
                                            cyDesired,
                                            LR_flags,
                                            NULL,
                                            NULL);
                    break;

                case PTR_TO_ID(RT_ICON):
                case PTR_TO_ID(RT_CURSOR):
                case PTR_TO_ID(RT_ANICURSOR):
                case PTR_TO_ID(RT_ANIICON):
                    /*
                     * Animated icon\cursors resources use the RIFF format
                     */
                    if (ISRIFFFORMAT(lpbih)) {
                        hObj = LoadCursorIconFromResource ((PBYTE)lpbih, lpName, cxDesired, cyDesired, LR_flags);
                    } else {
                        /*
                         * Create the object from the DIB.
                         */
                        hObj = ConvertDIBIcon(lpbih,
                                              hmod,
                                              lpName,
                                              (type == RT_ICON),
                                              cxDesired,
                                              cyDesired,
                                              LR_flags);
                    }
                    break;
                }

                UNLOCKRESOURCE(hdib, hmod);
            }

            /*
             * DO THIS TWICE!  The resource compiler always makes icon images
             * (RT_ICON) in a group icon discardable, whether the group dude
             * is or not!  So the first free won't really free the thing;
             * it'll just set the ref count to 0 and let the discard logic
             * go on its merry way.
             *
             * We take care of shared guys, so we don't need this dib no more.
             * Don't need this DIB no more no more, no more no more no more
             * don't need this DIB no more.
             */
            SplFreeResource(hdib, hmod, LR_flags);
        }
    }

    return hObj;
}

/***************************************************************************\
* BitmapFromDIB
*
* Creates a bitmap-handle from a DIB-Spec.  This function supports the
* LR_CREATEDIBSECTION flag, sets proper color depth, and stretches the
* DIBs as requested.
*
\***************************************************************************/

HBITMAP BitmapFromDIB(
    int          cxNew,
    int          cyNew,
    WORD         bPlanesNew,
    WORD         bBitsPixelNew,
    UINT         LR_flags,
    int          cxOld,
    int          cyOld,
    LPSTR        lpBits,
    LPBITMAPINFO lpbi,
    HPALETTE     hpal)
{
    HBITMAP hbmpNew = NULL;
    BOOL    fStretch;
    BOOL    f1Bpp = FALSE;

    RtlEnterCriticalSection(&gcsHdc);

    if (cxNew == 0)
        cxNew = cxOld;

    if (cyNew == 0)
        cyNew = cyOld;

    fStretch = ((cxNew != cxOld) || (cyNew != cyOld));

    /*
     * If LR_flags indicate DIB-Section, then return that as the
     * bitmap handle.
     */
    if (LR_flags & (LR_CREATEDIBSECTION | LR_CREATEREALDIB)) {

        int   cxTemp;
        int   cyTemp;
        BOOL  fOldFormat;
        LPVOID dwDummy;
        DWORD dwTemp;

#define lpbch ((LPBITMAPCOREHEADER)lpbi)

        fOldFormat = ((WORD)lpbi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER));

        if (fOldFormat) {

            cxTemp = lpbch->bcWidth;
            cyTemp = lpbch->bcHeight;

            lpbch->bcWidth  = (WORD)cxNew;
            lpbch->bcHeight = (WORD)cyNew;

        } else {

            cxTemp = lpbi->bmiHeader.biWidth;
            cyTemp = lpbi->bmiHeader.biHeight;
            dwTemp = lpbi->bmiHeader.biCompression;

            lpbi->bmiHeader.biWidth  = cxNew;
            lpbi->bmiHeader.biHeight = cyNew;

            if (dwTemp != BI_BITFIELDS)
                lpbi->bmiHeader.biCompression = BI_RGB;
        }

        if (LR_flags & LR_CREATEREALDIB) {
            hbmpNew = CreateDIBitmap(ghdcBits2,
                                     (LPBITMAPINFOHEADER)lpbi,
                                     CBM_CREATEDIB,
                                     NULL,
                                     lpbi,
                                     DIB_RGB_COLORS);
        } else {
            hbmpNew = CreateDIBSection(ghdcBits2,
                                       lpbi,
                                       DIB_RGB_COLORS,
                                       &dwDummy,
                                       0,
                                       0);
        }

        if (fOldFormat) {
            lpbch->bcWidth  = (WORD)cxTemp;
            lpbch->bcHeight = (WORD)cyTemp;
        } else {
            lpbi->bmiHeader.biWidth       = cxTemp;
            lpbi->bmiHeader.biHeight      = cyTemp;
            lpbi->bmiHeader.biCompression = dwTemp;
        }
#undef lpbch
    }

    if (hbmpNew == NULL) {

        hbmpNew = CreateScreenBitmap(cxNew,
                                     cyNew,
                                     bPlanesNew,
                                     bBitsPixelNew,
                                     NULL,
                                     &f1Bpp);
    }

    if (hbmpNew) {

        int     nStretchMode;
        DWORD   rgbBk;
        DWORD   rgbText;
        HBITMAP hbmpT;
        BOOL    fFail;

        /*
         * We need to select in appropriate bitmap immediately!  That way,
         * if we need to handle palette realization, the color matching
         * will work properly.
         */
        hbmpT = SelectBitmap(ghdcBits2, hbmpNew);

        /*
         * Setup for stretching
         */
        if (fStretch) {
            nStretchMode = SetBestStretchMode(ghdcBits2,
                                              bPlanesNew,
                                              bBitsPixelNew);
        }

        rgbBk   = SetBkColor(ghdcBits2, RESCLR_WHITE);
        rgbText = SetTextColor(ghdcBits2, RESCLR_BLACK);

        /*
         * Realize the palette.
         */
        if (hpal) {
#if DBG
            UserAssert(TEST_PUSIF(PUSIF_PALETTEDISPLAY));
#endif // DBG

            hpal = SelectPalette(ghdcBits2, hpal, FALSE);
            RealizePalette(ghdcBits2);
        }

        if (fStretch) {

            fFail = SmartStretchDIBits(ghdcBits2,
                               0,
                               0,
                               cxNew,
                               cyNew,
                               0,
                               0,
                               cxOld,
                               cyOld,
                               lpBits,
                               lpbi,
                               DIB_RGB_COLORS,
                               SRCCOPY) <= 0;
        } else {

            fFail = SetDIBits(ghdcBits2,
                      hbmpNew,
                      0,
                      cyNew,
                      lpBits,
                      lpbi,
                      DIB_RGB_COLORS) <= 0;
        }

        /*
         * Unrealize the palette
         */
        if (hpal) {
            SelectPalette(ghdcBits2, hpal, TRUE);
            RealizePalette(ghdcBits2);
        }

        /*
         * Cleanup after stretching
         */
        SetTextColor(ghdcBits2, rgbText);
        SetBkColor(ghdcBits2, rgbBk);
        if (fStretch)
            SetStretchBltMode(ghdcBits2, nStretchMode);

        SelectBitmap(ghdcBits2, hbmpT);

        /*
         * If the SetDIBits() of StretchDIBits() failed, it is probably because
         * GDI or the driver did not like the DIB format.  This may happen if
         * the file is truncated and we are using a memory mapped file to read
         * the DIB in.  In this case, an exception gets thrown in GDI, that it
         * traps and will return failure from the GDI call.
         */

        if (fFail) {
            DeleteObject(hbmpNew);
            hbmpNew = NULL;
        }
    }

    /*
     * If the bitmap was created as a 1bpp, we need to convert to a
     * true mono-bitmap.  GDI performs different color-matching depending
     * upon this case.
     */
    if (f1Bpp && hbmpNew)
        hbmpNew = Convert1BppToMonoBitmap(ghdcBits2, hbmpNew);

    RtlLeaveCriticalSection(&gcsHdc);
    return hbmpNew;
}

/***************************************************************************\
* HowManyColors
*
* Aug-01-2000 DwayneN - Fixed high color support
\***************************************************************************/

DWORD HowManyColors(
    IN  UPBITMAPINFOHEADER upbih,
    IN  BOOL               fOldFormat,
    OUT OPTIONAL LPBYTE    *ppColorTable)
{
#define upbch ((UPBITMAPCOREHEADER)upbih)

    if (fOldFormat) {
        if (ppColorTable != NULL) {
            *ppColorTable = (LPBYTE)(upbch + 1);
        }
        if (upbch->bcBitCount <= 8)
            return (1 << upbch->bcBitCount);
    } else {
        if (ppColorTable != NULL) {
            *ppColorTable = (LPBYTE)(upbih + 1);
        }

        if (upbih->biClrUsed) {
            /*
             * If the bitmap header explicitly provides the number of colors
             * in the color table, use it.
             */
            return (DWORD)upbih->biClrUsed;
        } else if (upbih->biBitCount <= 8) {
            /*
             * If the bitmap header describes a pallete-bassed bitmap
             * (8bpp or less) then the color table must be big enough
             * to hold all palette indecies.
             */
            return (1 << upbih->biBitCount);
        } else {
            /*
             * Finally, if the bitmap header describes a highcolor+ bitmap
             * (anything over 8bpp, but typically 16bpp, 24bpp, or 32bpp)
             * there isn't a need for a color table.  However, 16bpp and
             * 32bpp bitmaps are special cases since it is not obvious how
             * they should be split into triplets (Red, Green, and Blue).  For
             * instance, 16bpp bitmaps can have 6 red bits, 5 green bits, and
             * 5 blue bits.  Or some other combination.  To specify this, the
             * 16bpp and 32bpp bitmaps provide BI_BITFIELDS in the 
             * biCompression field.  This indicates that the color table will
             * have 3 DWORDS that describe the masks for the red, green, and
             * blue components of entry in the bitmap.  If this isn't 
             * specified, then GDI assumes "555" for 16bpp and "XBGR" for
             * 32bpp.  24bpp bitmaps are always "XBGR" and consume a 32-bit
             * entry in the form of an RGBQUAD.
             */
            if (upbih->biCompression == BI_BITFIELDS) {
                if ((upbih->biBitCount != 16) && (upbih->biBitCount != 32)) {
                    RIPMSG1(RIP_WARNING, "HowManyColors: biCompression==BI_BITFIELDS on a %dbpp bitmap!", upbih->biBitCount);
                }

                return 3;
            }
        }
    }

    /*
     * Evidently, there is no color table.
     */
    return 0;

#undef upbch
}

/***************************************************************************\
* ChangeDibColors
*
* Given a DIB, processes LR_MONOCHROME, LR_LOADTRANSPARENT and
* LR_LOADMAP3DCOLORS flags on the given header and colortable.
*
*
\***************************************************************************/
VOID ChangeDibColors(
    IN LPBITMAPINFOHEADER lpbih,
    IN UINT LR_flags)
{
    LPDWORD lpColorTable;
    DWORD rgb;
    UINT iColor;
    UINT cColors;

    cColors = HowManyColors(lpbih, FALSE, &(LPBYTE)lpColorTable);

    /*
     * NT Bug 366661: Don't check the color count here b/c we will do different
     * things depending on what type of change we are performing.  For example,
     * when loading hi-color/true-color icons, we always need to do the
     * monochrome conversion in order to properly get an icon-mask.
     */

    /*
     * LR_MONOCHROME is the only option that handles PM dibs.
     */
    if (LR_flags & LR_MONOCHROME) {
        /*
         * LR_MONOCHROME is the only option that handles PM dibs.
         *
         * DO THIS NO MATTER WHETHER WE HAVE A COLOR TABLE!  We need
         * to do this for mono conversion and for > 8 BPP
         * icons/cursors.  In CopyDibHdr, we already made a copy of
         * the header big enough to hold 2 colors even on high-color+
         * bpp images.
         */
        lpbih->biBitCount = lpbih->biPlanes = 1;
        lpbih->biCompression = 0;
        lpColorTable[0] = RESCLR_BLACK;
        lpColorTable[1] = RESCLR_WHITE;
    } else if (LR_flags & LR_LOADTRANSPARENT) {

        LPBYTE pb;

        /*
         * No color table!  Do nothing.
         */
        if (cColors == 0) {
            RIPMSG0(RIP_WARNING, "ChangeDibColors: DIB doesn't have a color table");
            return;
        }

        pb = (LPBYTE)(lpColorTable + cColors);

        /*
         * Change the first pixel's color table entry to RGB_WINDOW
         * Gosh, I love small-endian
         */
        if (lpbih->biCompression == 0)
            iColor = (UINT)pb[0];
        else
            /*
             * RLE bitmap, will start with cnt,clr  or  0,cnt,clr
             */
            iColor = (UINT)(pb[0] == 0 ? pb[2] : pb[1]);

        switch (cColors) {
        case BPP01_MAXCOLORS:
            iColor &= 0x01;
            break;

        case BPP04_MAXCOLORS:
            iColor &= 0x0F;
            break;

        case BPP08_MAXCOLORS:
            iColor &= 0xFF;
            break;
        }

        rgb = (LR_flags & LR_LOADMAP3DCOLORS ? SYSRGB(3DFACE) : SYSRGB(WINDOW));

        lpColorTable[iColor] = RGBX(rgb);

    } else  if (LR_flags & LR_LOADMAP3DCOLORS) {

        /*
         * Fix up the color table, mapping shades of grey to the current
         * 3D colors.
         */
        for (iColor = 0; iColor < cColors; iColor++) {

            switch (*lpColorTable & 0x00FFFFFF) {

            case RGBX(RGB(223, 223, 223)):
                rgb = SYSRGB(3DLIGHT);
                goto ChangeColor;

            case RGBX(RGB(192, 192, 192)):
                rgb = SYSRGB(3DFACE);
                goto ChangeColor;

            case RGBX(RGB(128, 128, 128)):
                rgb = SYSRGB(3DSHADOW);

                /*
                 * NOTE: byte-order is different in DIBs than in RGBs
                 */
ChangeColor:
                *lpColorTable = RGBX(rgb);
                break;
            }
            lpColorTable++;
        }
    }
}

/***************************************************************************\
* ConvertDIBIcon
*
* Called when a cursor/icon in DIB format is loaded.  This converts the
* cursor/icon into the old format and returns the resource handle.  IE,
* grabs the DIB bits and transforms them into physical bitmap bits.
*
*
* DIB Formats for icons/cursors 101
*
* Old Win 3.0 format icons/cursors start with an OLDICON/OLDCURSOR header
* followed by a double high monochrome DIB.  The height refered to in the
* header is the icon/cursor height, not the DIB height which is twice as
* high.  The XOR mask is in the first-half of the DIB bits.
*
* Old PM format icons/cursors start with a BITMAPCOREHEADER and
* are identical to the current win 3.1/NT format thereafter.
*
* Current NT/Chicago/Win 3.1 format icons/cursors start with
* a BITAMPINFOHEADER.  The height of this header refers to the height
* of the first bitmap which may either be color or truely monochrome.
* If its color, it is followed by the monochrome AND mask bits imediately
* after the color bits.  If it is truely monochrome, the AND and XOR
* masks are totally contained in the first DIB bits and no more bits
* follow.
*
* 5-Oct-1994 SanfordS   Recreated
\***************************************************************************/

HICON ConvertDIBIcon(
    LPBITMAPINFOHEADER lpbih,
    HINSTANCE          hmod,
    LPCWSTR            lpName,
    BOOL               fIcon,
    DWORD              cxNew,
    DWORD              cyNew,
    UINT               LR_flags)
{
    LPBITMAPINFOHEADER lpbihNew = NULL;
    LPSTR              lpBitsNextMask = NULL;
    HICON              hicoNew = NULL;
    BOOL               fOldFormat = FALSE;
    CURSORDATA         cur;
    WCHAR              achModName[MAX_PATH];

    /*
     * Because Icons/Cursors always get public bitmaps, we cannot use
     * LR_CREATEDIBSECTION on them.
     */
    if (LR_flags & LR_CREATEDIBSECTION) {
        LR_flags = (LR_flags & ~LR_CREATEDIBSECTION) | LR_CREATEREALDIB;
    }

    RtlZeroMemory(&cur, sizeof(cur));

    if (!fIcon) {
        /*
         * Cursors have an extra two words preceeding the BITMAPINFOHEADER
         * indicating the hot-spot.  After doing the increments, the
         * pointer should be at the dib-header.
         */
        cur.xHotspot = (short)(int)*(((LPWORD)lpbih)++);
        cur.yHotspot = (short)(int)*(((LPWORD)lpbih)++);
    }

    /*
     * If the color bitmap is a single plane, 32bpp image, it might
     * contain an alpha channel, so we have to preserve it as a DIB.
     */
    if (lpbih->biPlanes == 1 && lpbih->biBitCount == 32) {
        LR_flags |= LR_CREATEREALDIB;
    }

    /*
     * Get the XOR/Color mask.
     * The XOR bits are first in the DIB because the header info
     * pertains to them.
     * The AND mask is always monochrome.
     */
    lpBitsNextMask = NULL;  // not passing lpBits in.
    cur.hbmColor = ConvertDIBBitmap(lpbih,
                                    cxNew,
                                    cyNew,
                                    LR_flags,
                                    &lpbihNew,
                                    &lpBitsNextMask);
    if (cur.hbmColor == NULL)
        return NULL;

    if (hmod == NULL) {
        cur.lpModName = NULL;
    } else {
        cur.CURSORF_flags = CURSORF_FROMRESOURCE;
        if (hmod == hmodUser) {
            cur.lpModName     = szUSER32;
        } else  {
            WowGetModuleFileName(hmod,
                              achModName,
                              sizeof(achModName) / sizeof(WCHAR));
            cur.lpModName = achModName;
        }
    }
    cur.rt     = (fIcon ? PTR_TO_ID(RT_ICON) : PTR_TO_ID(RT_CURSOR));
    cur.lpName = (LPWSTR)lpName;
    cur.bpp    = lpbihNew->biBitCount * lpbihNew->biPlanes;

    if (cxNew == 0)
        cxNew = lpbihNew->biWidth;

    if (cyNew == 0)
        cyNew = lpbihNew->biHeight / 2;

    if (!fIcon) {

        cur.xHotspot = MultDiv(cur.xHotspot,
                               cxNew,
                               lpbihNew->biWidth);
        cur.yHotspot = MultDiv(cur.yHotspot,
                               cyNew,
                               lpbihNew->biHeight / 2);
    } else {

        /*
         * For an icon the hot spot is the center of the icon
         */
        cur.xHotspot = (INT)(cxNew) / 2;
        cur.yHotspot = (INT)(cyNew) / 2;
    }

    /*
     * Setup header for monochrome DIB.  Note that we use the COPY.
     */
    ChangeDibColors(lpbihNew, LR_MONOCHROME);

    if (lpBitsNextMask != NULL) {
        cur.hbmMask = BitmapFromDIB(cxNew,
                                    cyNew * 2,
                                    1,
                                    1,
                                    0,
                                    lpbihNew->biWidth,
                                    lpbihNew->biHeight,
                                    lpBitsNextMask,
                                    (LPBITMAPINFO)lpbihNew,
                                    NULL);

        if (cur.hbmMask == NULL) {
            DeleteObject(KHBITMAP_TO_HBITMAP(cur.hbmColor));
            UserLocalFree(lpbihNew);
            return NULL;
        }

    } else {
        cur.hbmMask = cur.hbmColor;
        cur.hbmColor = NULL;
    }

    cur.cx = cxNew;
    cur.cy = cyNew * 2;

    /*
     * Free our dib header copy allocated by ConvertDIBBitmap
     */
    UserLocalFree(lpbihNew);

    if (LR_flags & LR_SHARED)
        cur.CURSORF_flags |= CURSORF_LRSHARED;

    if (LR_flags & LR_GLOBAL)
        cur.CURSORF_flags |= CURSORF_GLOBAL;

    if (LR_flags & LR_ACONFRAME)
        cur.CURSORF_flags |= CURSORF_ACONFRAME;

    return CreateIcoCur(&cur);
}

/***************************************************************************\
* TrulyMonochrome
*
* Checks to see if a DIB colro table is truly monochrome.  ie: the color
* table has black & white entries only.
*
\***************************************************************************/

BOOL TrulyMonochrome(
    LPVOID lpColorTable,
    BOOL   fOldFormat)
{
    #define lpRGB  ((UNALIGNED LONG *)lpColorTable)
    #define lpRGBw ((UNALIGNED WORD *)lpColorTable)

    if (fOldFormat) {

        /*
         * Honey - its triplets.
         */
        if (lpRGBw[0] == 0x0000)
            return (lpRGBw[1] == 0xFF00) && (lpRGBw[2] == 0xFFFF);
        else if (lpRGBw[0] == 0xFFFF)
            return (lpRGBw[1] == 0x00FF) && (lpRGBw[2] == 0x0000);

    } else {

        /*
         * Honey - its quadruplets!
         */
        if (lpRGB[0] == RESCLR_BLACK)
            return (lpRGB[1] == RESCLR_WHITE);
        else if (lpRGB[0] == RESCLR_WHITE)
            return (lpRGB[1] == RESCLR_BLACK);
    }

    #undef lpRGB
    #undef lpRGBw

    return FALSE;
}

/***************************************************************************\
* CopyDibHdr
*
* Copies and converts a DIB resource header
*
* Handles conversion of OLDICON, OLDCURSOR and BITMAPCOREHEADER
* structures to BITMAPINFOHEADER headers.
*
* Note: fSingleHeightMasks is set for OLDICON and OLDCURSOR formats.
*       This identifies that a monochrome AND/Color mask
*       is NOT double height as it is in the newer formats.
*
* NOTE:  On the off chance that LR_LOADTRANSPARENT is used, we want to
*     copy a DWORD of the bits.  Since DIB bits are DWORD aligned, we know
*     at least a DWORD is there, even if the thing is a 1x1 mono bmp.
*
* The returned buffer is allocated in this function and needs to be
* freed by the caller.
*
* 22-Oct-1995 SanfordS  Revised
\***************************************************************************/

LPBITMAPINFOHEADER CopyDibHdr(
    IN  UPBITMAPINFOHEADER upbih,
    OUT LPSTR             *lplpBits,
    OUT LPBOOL             lpfMono)
{

#define upbch ((UPBITMAPCOREHEADER)upbih)
    DWORD              cColors;
    DWORD              cMinColors;
    DWORD              i;
    LPBITMAPINFOHEADER lpbihNew;
    DWORD              cbAlloc;
    LPBYTE             lpColorTable;
    struct  {
        BITMAPINFOHEADER   bih;
        DWORD              rgb[256];
        DWORD              dwBuffer;
    } Fake;

    switch (upbih->biSize) {
    case sizeof(BITMAPINFOHEADER):
        /*
         * Cool.  No conversion needed.
         */
        cColors   = HowManyColors(upbih, FALSE, &lpColorTable);
        *lplpBits = (LPSTR)(((LPDWORD)lpColorTable) + cColors);
        break;

    case sizeof(BITMAPCOREHEADER):
        /*
         * Convert the BITMAPCOREHEADER to a BITMAPINFOHEADER
         */
        Fake.bih.biSize          = sizeof(BITMAPINFOHEADER);
        Fake.bih.biWidth         = upbch->bcWidth;
        Fake.bih.biHeight        = upbch->bcHeight;
        Fake.bih.biPlanes        = upbch->bcPlanes;
        Fake.bih.biBitCount      = upbch->bcBitCount;
        Fake.bih.biCompression   =
        Fake.bih.biXPelsPerMeter =
        Fake.bih.biYPelsPerMeter =
        Fake.bih.biClrImportant  = 0;
        Fake.bih.biClrUsed       = cColors = HowManyColors(upbih, TRUE, &lpColorTable);
        Fake.bih.biSizeImage     = BitmapWidth(Fake.bih.biWidth, Fake.bih.biBitCount) * Fake.bih.biHeight;

        /*
         * Copy and convert tripplet color table to rgbQuad color table.
         */
        for (i = 0; i < cColors; i++, lpColorTable += 3) {

            Fake.rgb[i] = lpColorTable[0]        +
                          (lpColorTable[1] << 8) +
                          (lpColorTable[2] << 16);
        }

        Fake.rgb[i] = *(DWORD UNALIGNED *)lpColorTable;  // For LR_LOADTRANSPARENT
        upbih       = (UPBITMAPINFOHEADER)&Fake;
        *lplpBits   = lpColorTable;
        break;

    default:

#define upOldIcoCur ((UPOLDCURSOR)upbih)

        if (upOldIcoCur->bType == BMR_ICON ||
                upOldIcoCur->bType == BMR_CURSOR) {
            /*
             * Convert OLDICON/OLDCURSOR header to BITMAPINFHEADER
             */
            RIPMSG0(RIP_WARNING, "USER32:Converting a OLD header. - email sanfords if you see this");
            Fake.bih.biSize          = sizeof(BITMAPINFOHEADER);
            Fake.bih.biWidth         = upOldIcoCur->cx;
            Fake.bih.biHeight        = upOldIcoCur->cy * 2;
            Fake.bih.biPlanes        =
            Fake.bih.biBitCount      = 1;
            Fake.bih.biCompression   =
            Fake.bih.biXPelsPerMeter =
            Fake.bih.biYPelsPerMeter =
            Fake.bih.biClrImportant  = 0;
            Fake.bih.biClrUsed       = cColors = BPP01_MAXCOLORS;
            Fake.bih.biSizeImage     = BitmapWidth(upOldIcoCur->cx, 1) * upOldIcoCur->cy;
            Fake.rgb[0]              = RESCLR_BLACK;
            Fake.rgb[1]              = RESCLR_WHITE;
            upbih                    = (LPBITMAPINFOHEADER)&Fake;
            *lplpBits                = upOldIcoCur->abBitmap;
            Fake.rgb[2]              = *((LPDWORD)*lplpBits);  // For LR_LOADTRANSPARENT

        } else {

            RIPMSG0(RIP_WARNING, "ConvertDIBBitmap: not a valid format");
            return NULL;
        }

#undef pOldIcoCur

        break;
    }

    *lpfMono = (cColors == BPP01_MAXCOLORS) &&
            TrulyMonochrome((LPBYTE)upbih + sizeof(BITMAPINFOHEADER), FALSE);

    /*
     * Note: We have to allocate at least 2 color entries so that we have
     * room in the color table to define black and white for monochrome
     * conversions.  See ChangeDibColors() and ConvertDIBIcon().
     */
    cMinColors = cColors >= 2 ? cColors : 2;

    /*
     * LR_LOADTRANSPARENT needs to examine the first pixel to determine the
     * transparent color.  This routine splits the bitmap header away
     * from the actual bitmap bits.  However, the routines that process the
     * LR_LOADTRANSPARENT style expect the first pixel to immediately follow
     * the bitmap header.  Above we copied the first pixel of the bitmap
     * bits right after the color table.  Now we just need to make room for
     * it in our buffer.
     */
    cMinColors++;

    cbAlloc = sizeof(BITMAPINFOHEADER) + (cMinColors * sizeof(RGBQUAD));

    if (lpbihNew = UserLocalAlloc(0, cbAlloc)) {
        RtlCopyMemory(lpbihNew, upbih, cbAlloc);
    }

    return lpbihNew;

#undef upbch

}

/***************************************************************************\
* ConvertDIBBitmap
*
* This takes a BITMAPCOREHEADER, OLDICON, OLDCURSOR or BITMAPINFOHEADER DIB
* specification and creates a physical object from it.
* Handles Color fixups, DIB sections, color depth, and stretching options.
*
* Passes back: (if lplpbih is not NULL)
*   lplpbih = copy of given header converted to BITMAPINFOHEADER form.
*   lplpBits = pointer to next mask bits, or NULL if no second mask.
*   Caller must free lplpbih returned.
*
* If lplpBits is not NULL and points to a non-NULL value, it supplies
* the location of the DIB bits allowing the header to be from a different
* location.
*
* 04-Oct-1995 SanfordS  Recreated.
\***************************************************************************/

HBITMAP ConvertDIBBitmap(
    IN  UPBITMAPINFOHEADER           upbih,
    IN  DWORD                        cxDesired,
    IN  DWORD                        cyDesired,
    IN  UINT                         LR_flags,
    OUT OPTIONAL LPBITMAPINFOHEADER *lplpbih,
    IN OUT OPTIONAL LPSTR           *lplpBits)
{
    LPBITMAPINFOHEADER lpbihNew;
    BOOL               fMono, fMonoGiven;
    BYTE               bPlanesDesired;
    BYTE               bppDesired;
    LPSTR              lpBits;
    HBITMAP            hBmpRet;

    /*
     * Make a copy of the DIB-Header.  This returns a pointer
     * which was allocated, so it must be freed later.
     * The also converts the header to BITMAPINFOHEADER format.
     */
    if ((lpbihNew = CopyDibHdr(upbih, &lpBits, &fMono)) == NULL) {
        return NULL;
    }

    /*
     * When loading a DIB file, we may need to use a different
     * bits pointer.  See RtlRes.c/RtlLoadObjectFromDIBFile.
     */
    if (lplpBits && *lplpBits) {
        lpBits = *lplpBits;
    }

    fMonoGiven = fMono;

    if (!fMono) {

        if (LR_flags & (LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS))
            ChangeDibColors(lpbihNew, LR_flags & ~LR_MONOCHROME);

        if (LR_flags & LR_CREATEREALDIB) {
            bPlanesDesired = (BYTE) lpbihNew->biPlanes;
            bppDesired = (BYTE) lpbihNew->biBitCount;
        } else {
            bPlanesDesired = gpsi->Planes;
            bppDesired = gpsi->BitsPixel;
        }

        fMono = LR_flags & LR_MONOCHROME;
    }

    if (fMono) {
        bPlanesDesired =
        bppDesired     = 1;
    }

    /*
     * HACK area
     */
    if (lplpbih != NULL) {

        /*
         * pass back the translated/copied header
         */
        *lplpbih = lpbihNew;

        /*
         * When loading icon/cursors on a system with multiple monitors
         * with different color depths, always convert to VGA color.
         *
         * dwaynen - 1/12/2001
         * Note: This used to also check the SM_SAMEDISPLAYFORMAT metric.  If
         * the display formats (on a multi-mon system) were different, it
         * would force the bpp to 4,  We have removed this code because we
         * suspect that it isn't really needed.
         * Refer to bug 258022.
         *
        if (!fMono && !SYSMET(SAMEDISPLAYFORMAT)) {
            bPlanesDesired = 1;
            bppDesired = 4;
        }
        */

        /*
         * Return a ponter to the bits following this set of bits
         * if there are any there.
         *
         * Note that the header given with an ICON DIB always reflects
         * twice the height of the icon desired but the COLOR bitmap
         * (if there is one) will only be half that high.  We need to
         * fixup cyDesired for monochrome icons so that the mask isnt
         * stretched to half the height its supposed to be.  Color
         * bitmaps, however, must have the header corrected to reflect
         * the bits actual height which is half what the header said.
         * The correction must later be backed out so that the returned
         * header reflects the dimensions of the XOR mask that immediately
         * follows the color mask.
         */
        if (fMonoGiven) {

            *lplpBits = NULL;

            if (cyDesired)
                cyDesired <<= 1;    // mono icon bitmaps are double high.

        } else {

            UserAssert(!(lpbihNew->biHeight & 1));
            lpbihNew->biHeight >>= 1;  // color icon headers are off by 2

            /*
             * Gross calculation!  We subtract the XOR part of the mask
             * for this calculation so that we submit a double-high mask.
             * The first half of this is garbage, but for icons its not
             * used.  This may be a bug for cursor use of icons.
             */
            *lplpBits = lpBits +
                    (BitmapWidth(lpbihNew->biWidth, lpbihNew->biBitCount) -
                    BitmapWidth(lpbihNew->biWidth, 1)) *
                    lpbihNew->biHeight;
        }
    }

    if (cxDesired == 0)
        cxDesired = lpbihNew->biWidth;

    if (cyDesired == 0)
        cyDesired = lpbihNew->biHeight;

    hBmpRet = BitmapFromDIB(cxDesired,
                            cyDesired,
                            bPlanesDesired,
                            bppDesired,
                            LR_flags,
                            lpbihNew->biWidth,
                            lpbihNew->biHeight,
                            lpBits,
                            (LPBITMAPINFO)lpbihNew,
                            NULL);

    if (lplpbih == NULL || hBmpRet == NULL) {
        UserLocalFree(lpbihNew);
    } else if (!fMonoGiven) {
        lpbihNew->biHeight <<= 1;   // restore header for next mask
    }

    return hBmpRet;
}

/***************************************************************************\
* MyAbs
*
* Calcules my weighted absolute value of the difference between 2 nums.
* This of course normalizes values to >= zero.  But it can also "punish" the
* returned value by a factor of two if valueHave < valueWant.  This is
* because you get worse results trying to extrapolate from less info up then
* interpolating from more info down.
*
\***************************************************************************/

UINT MyAbs(
    int valueHave,
    int valueWant,
    BOOL fPunish)
{
    int diff = (valueHave - valueWant);

    if (diff < 0)
        diff = (fPunish ? -2 : -1) * diff;

    return (UINT)diff;
}

/***************************************************************************\
* Magnitude
*
* Used by the color-delta calculations.  The reason is that num colors is
* always a power of 2.  So we use the log 2 of the want vs. have values
* to avoid having weirdly huge sets.
*
\***************************************************************************/

UINT Magnitude(
    int nValue)
{
    if (nValue < 4)
        return 1;
    else if (nValue < 8)
        return 2;
    else if (nValue < 16)
        return 3;
    else if (nValue < 256)
        return 4;
    else
        return 8;
}

/***************************************************************************\
* GetResourceBpp
*
* Extract the bpp for a icon/cursor resource.  Handle low and high-color
* formats.
*
\***************************************************************************/
UINT GetResourceBpp(LPRESDIR lprd, BOOL fIcon)
{
    UINT bpp = 0;

    if (fIcon) {
        if (lprd->Icon.ColorCount != 0) {
            bpp = Magnitude(lprd->Icon.ColorCount);
            TAGMSG2(DBGTAG_Icon, "GetResourceBpp: icon color count = %d, bpp = %d", lprd->Icon.ColorCount, bpp);
        } else {
            bpp = lprd->BitCount;
            TAGMSG1(DBGTAG_Icon, "GetResourceBpp: icon bpp = %d", bpp);
        }
    } else {
        /*
         * NTRAID#NTBUG9-360375-2001/04/05-dwaynen  
         * This seems really suspicious to me.
         * Forcing bppNew to 1.
         *    Cursors provide a hotspot where an icon provides bit-depth
         *    information.  So we just set the bppNew to 1, since we don't
         *    have any better ideas.  We just hope that there is only
         *    one cursor candidate, otherwise our scoring logic is broken.
         *    Also this is broken when we try to load a cursor resource
         *    as an icon.  We won't match color depth properly!
         */
        bpp = 1;
        TAGMSG1(DBGTAG_Icon, "GetResourceBpp: cursor bpp = %d", bpp);
    }

    /*
     * Nothing has 0 bpp.
     */
    if(bpp == 0) {
        bpp = ICON_DEFAULTDEPTH;
        TAGMSG1(DBGTAG_Icon, "GetResourceBpp: icon color depth unknown!  Assuming %d!", bpp);
    }

    return bpp;
}

/***************************************************************************\
* MatchImage
*
* This function takes LPINTs for width & height in case of "real size".
* For this option, we use dimensions of 1st icon in resdir as size to
* load, instead of system metrics.
*
* Returns a number that measures how "far away" the given image is
* from a desired one.  The value is 0 for an exact match.  Note that our
* formula has the following properties:
*     (1) Differences in width/height count much more than differences in
*         color format.
*     (2) Bigger images are better than smaller, since shrinking produces
*         better results than stretching.
*     (3) Color matching is done by the difference in bit depth.  No
*         preference is given to having a candidate equally different
*         above and below the target.
*
* The formula is the sum of the following terms:
*     abs(bppCandidate - bppTarget)
*     abs(cxCandidate - cxTarget), times 2 if the image is
*         narrower than what we'd like.  This is because we will get a
*         better result when consolidating more information into a smaller
*         space, than when extrapolating from less information to more.
*     abs(cxCandidate - cxTarget), times 2 if the image is
*         shorter than what we'd like.  This is for the same reason as
*         the width.
*
* Let's step through an example.  Suppose we want a 4bpp (16 color),
* 32x32 image.  We would choose the various candidates in the following order:
* 
* Candidate     Score   Formula
*
* 32x32x4bpp  = 0       abs(32-32)*1 + abs(32-32)*1 + 2*abs(4-4)*1
* 32x32x2bpp  = 4
* 32x32x8bpp  = 8
* 32x32x16bpp = 24
* 48x48x4bpp  = 32
* 48x48x2bpp  = 36
* 48x48x8bpp  = 40
* 32x32x32bpp = 56
* 48x48x16bpp = 56      abs(48-32)*1 + abs(48-32)*1 + 2*abs(16-4)*1
* 16x16x4bpp  = 64
* 16x16x2bpp  = 68      abs(16-32)*2 + abs(16-32)*2 + 2*abs(2-4)*1
* 16x16x8bpp  = 72
* 48x48x32bpp = 88      abs(48-32)*1 + abs(48-32)*1 + 2*abs(32-4)*1
* 16x16x16bpp = 88
* 16x16x32bpp = 104
*
\***************************************************************************/

UINT MatchImage(
    LPRESDIR lprd,
    LPINT    lpcxWant,
    LPINT    lpcyWant,
    UINT     bppWant,
    BOOL     fIcon)
{
    UINT bppNew;
    int  cxNew;
    int  cyNew;
    UINT score;

    cxNew = lprd->Icon.Width;
    cyNew = lprd->Icon.Height;
    bppNew = GetResourceBpp(lprd, fIcon);

    if (!fIcon) {
        /*
         * NTRAID#NTBUG9-360375-2001/04/05-dwaynen  
         *
         * This seems really suspicious to me.
         * Cutting the height in half.
         *    This is because cursors store a 2X height for legacy reasons.
         *    Unfortunately, this code path can also be used to load an
         *    icon resource AS a cursor.  Maybe we should only do this for
         *    cursor resources.  But how to tell?
         */
        cyNew >>= 1;
    }

    /*
     * 0 really means maximum size (256) or colors (256).
     */
    if (!cxNew) {
        cxNew = ICON_MAXWIDTH;
        TAGMSG1(DBGTAG_Icon, "MatchImage: icon width unknown!  Assuming %d!", cxNew);
    }

    if (!*lpcxWant) {
        *lpcxWant = cxNew;
    }

    if (!cyNew) {
        cyNew = ICON_MAXHEIGHT;
        TAGMSG1(DBGTAG_Icon, "MatchImage: icon height unknown!  Assuming %d!", cyNew);
    }

    if (!*lpcyWant) {
        *lpcyWant = cyNew;
    }

    /*
     * Here are the rules for our "match" formula:
     *      (1) A close size match is much preferable to a color match
     *      (2) Bigger icons are better than smaller
     *      (3) The smaller the difference in bit depths the better
     */
    score = 2*MyAbs(bppNew, bppWant, FALSE) +
            MyAbs(cxNew, *lpcxWant, TRUE) +
            MyAbs(cyNew, *lpcyWant, TRUE);

    TAGMSG4(DBGTAG_Icon, "MatchImage: Candidate Summary: cx=%d, cy=%d, bpp=%d, score=%d", cxNew, cyNew, bppNew, score);

    return score;
}

/***************************************************************************\
* GetBestImage
*
* Among the different forms of images, choose the one that best matches the
* color format & dimensions of the request.
*
* Here are the rules for our "match" formula:
*      (1) A close size match is much preferable to a color match
*      (2) Bigger icons are better than smaller
*      (3) Closer bit depths are better
*
* Here are some additional rules:
*      (4) A tie is broken by choosing the one with the largest bpp.
*      (5) A further tie is broken by choosing the first in the resource.
*      (6) If we find an identical match, we return immediately.
*
\***************************************************************************/

UINT GetBestImage(
    LPRESDIR lprd,
    UINT     uCount,
    int      cxDesired,
    int      cyDesired,
    UINT     bppDesired,
    BOOL     fIcon)
{
    UINT i;
    UINT iBest = 0;
    UINT score;
    UINT scoreBest = (UINT)-1;
    UINT bppBest;
    UINT bppCandidate;

    TAGMSG0(DBGTAG_Icon, "GetBestImage: Icon dir has %d candidates.");
    TAGMSG4(DBGTAG_Icon, "GetBestImage: Looking for cx=%d, cy=%d, bpp=%d, fIcon=%s", cxDesired, cyDesired, bppDesired, fIcon ? "TRUE" : "FALSE");

    /*
     * If the bpp was not specified, grab the primary monitor's color depth.
     */
    if (bppDesired == 0) {
        bppDesired = (UINT)gpsi->BitCount;
        TAGMSG1(DBGTAG_Icon, "GetBestImage: Using screen bpp=%d", bppDesired);
    }

    /*
     * 10/18/2000 - dwaynen
     *
     * We no longer do the following, because we now pass along the
     * actuall bpp, instead of a color count.  The old code (commented out
     * below) used to crop the supported bpp to 8, and to convert the bpp
     * into an actual color count.  We used to pass the color count because
     * the resource format (see ICONDIR) stores the color count in a byte,
     * and we would simply compare the desired colors against the available
     * colors.  If an icon had 256 colors, it actually just stored a 0 in
     * the ICONDIR::ColorCount field.  The problem is obvious, what about
     * icons/cursors with more than 256 colors?
     *
     * Fortunately, the resource format also stores the bits-per-pixel (bpp).
     * So, we now pass along the desired bpp, instead of the desired color
     * count, to do our matching against.  
     *
     * Old code and comments below:
     * --------
     *
     * Get desired number of colors in # value, not bits value.  Note that
     * we do NOT allow you to have  16- or 32- or 24- bit color icons.
     *
     * the icon resources can be 16, 24, 32 bpp, but the restable only has
     * a color count, so a HiColor icon would have a max value in the
     * restable.  we treat a 0 in the color count as "max colors"
     *
     
    if (bpp > 8)
        bpp = 8;

    bpp = 1 << bpp;
    */

    /*
     * Loop through resource entries, saving the "closest" item so far.  Most
     * of the real work is in MatchImage(), which uses a fabricated formula
     * to give us the results that we desire.  Namely, an image as close in
     * size to what we want preferring bigger over smaller, then an image
     * with the right color format
     */
    for (i = 0; i < uCount; i++, lprd++) {
        TAGMSG1(DBGTAG_Icon, "GetBestImage: Checking candidate %d...", i);
        bppCandidate = GetResourceBpp(lprd, fIcon);

        /*
         * Get "matching" value.  How close are we to what we want?
         */
        score = MatchImage(lprd, &cxDesired, &cyDesired, bppDesired, fIcon);

        TAGMSG0(DBGTAG_Icon, "---------------------------------------------");

        if (score == 0) {
            /*
             * We've found an exact match!
             */
            TAGMSG1(DBGTAG_Icon, "GetBestImage: Found exact match: candidate=%d", i);
            iBest = i;
            break;
        } else if (score < scoreBest) {
            /*
             * We've found a better match than the current alternative.
             */
            scoreBest = score;
            iBest = i;
            bppBest = bppCandidate;
        } else if (score == scoreBest) {
            /*
             * Tie breaker: choose the higher color depth.  If that fails, choose first one.
             */
            if (bppBest < bppCandidate) {
                iBest = i;
                bppBest = bppCandidate;
            }
        }
    }

    TAGMSG2(DBGTAG_Icon, "GetBestImage: Using best match: candidate=%d, score=%d", iBest, scoreBest);
    return iBest;
}

/***************************************************************************\
* GetIcoCurWidth
*
* When zero is passed in for a dimension, calculates what size we should
* really used.  Done in a couple o' places, so made it a FN().
*
\***************************************************************************/

_inline DWORD GetIcoCurWidth(
    DWORD cxOrg,
    BOOL  fIcon,
    UINT  lrFlags,
    DWORD cxDes)
{
    if (cxOrg) {
        return cxOrg;
    } else if (lrFlags & LR_DEFAULTSIZE) {
        return (fIcon ? SYSMET(CXICON) : SYSMET(CXCURSOR));
    } else {
        return cxDes;
    }
}

/***************************************************************************\
* GetIcoCurHeight
*
* Vertical counterpart to GetWidth().
*
\***************************************************************************/

_inline DWORD GetIcoCurHeight(
    DWORD cyOrg,
    BOOL  fIcon,
    UINT  lrFlags,
    DWORD cyDes)
{
    if (cyOrg) {
        return cyOrg;
    } else if (lrFlags & LR_DEFAULTSIZE) {
        return (fIcon ? SYSMET(CYICON) : SYSMET(CYCURSOR));
    } else {
        return cyDes;
    }
}

/***************************************************************************\
* GetIcoCurBpp
*
* Returns best match Bpp based on lr-flags.
*
\***************************************************************************/

_inline DWORD GetIcoCurBpp(
    UINT lrFlags)
{
    if (lrFlags & LR_MONOCHROME) {

#if DBG
        if (lrFlags & LR_VGACOLOR) {
            RIPMSG0(RIP_WARNING, "lrFlags has both MONOCHROME and VGACOLOR; assuming MONOCHROME");
        }
#endif
        return 1;

    } else if (TEST_PUSIF(PUSIF_PALETTEDISPLAY) || (lrFlags & LR_VGACOLOR)) {
        /*
         * dwaynen - 1/12/2001
         * Note: This used to also check the SM_SAMEDISPLAYFORMAT metric.  If
         * the display formats (on a multi-mon system) were different, it
         * would also return 4,  We have removed this code because we suspect
         * that it isn't really needed.
         * Refer to bug 258022.
         *
         * || !SYSMET(SAMEDISPLAYFORMAT)
         *
         */

        return 4;
    } else {
        return 0;
    }
}

/***************************************************************************\
* WOWFindResourceExWCover
*
* The WOW FindResource routines expect an ansi string so we have to
* convert the calling string IFF it is not an ID
*
\***************************************************************************/

HANDLE WOWFindResourceExWCover(
    HANDLE  hmod,
    LPCWSTR rt,
    LPCWSTR lpUniName,
    WORD    LangId)
{
    LPSTR  lpAnsiName;
    HANDLE hRes;

    if (ID(lpUniName))
        return FINDRESOURCEEXA(hmod, (LPSTR)lpUniName, (LPSTR)rt, LangId);

    /*
     * Otherwise convert the name of the menu then call LoadMenu
     */
    if (!WCSToMB(lpUniName, -1, &lpAnsiName, -1, TRUE))
        return NULL;

    hRes = FINDRESOURCEEXA(hmod, lpAnsiName, (LPSTR)rt, LangId);

    UserLocalFree(lpAnsiName);

    return hRes;
}

/***************************************************************************\
* WOWLoadBitmapA
*
*
\***************************************************************************/

HBITMAP WOWLoadBitmapA(
    HINSTANCE hmod,
    LPCSTR    lpName,
    LPBYTE    pResData,
    DWORD     cbResData)
{
    LPWSTR  lpUniName;
    HBITMAP hRet;

    UNREFERENCED_PARAMETER(cbResData);

    if (pResData == NULL) {

        if (ID(lpName))
            return LoadBmp(hmod, (LPCWSTR)lpName, 0, 0, 0);

        if (!MBToWCS(lpName, -1, &lpUniName, -1, TRUE))
            return NULL;

        hRet = LoadBmp(hmod, lpUniName, 0, 0, 0);

        UserLocalFree(lpUniName);

    } else {

        hRet = ConvertDIBBitmap((LPBITMAPINFOHEADER)pResData,
                                0,
                                0,
                                LR_DEFAULTSIZE,
                                NULL,
                                NULL);
    }

    return hRet;
}

/***************************************************************************\
*
* WOWServerLoadCreateCursorIcon
*
\***************************************************************************/

HICON WowServerLoadCreateCursorIcon(
    HANDLE  hmod,
    LPWSTR  pszModName,
    DWORD   dwExpWinVer,
    LPCWSTR lpName,
    DWORD   cb,
    PVOID   pResData,
    LPWSTR  type,
    BOOL    fClient)
{
    HICON hRet;
    BOOL  fIcon = (type == RT_ICON);
    UINT  LR_Flags = LR_SHARED;

    UNREFERENCED_PARAMETER(pszModName);
    UNREFERENCED_PARAMETER(dwExpWinVer);
    UNREFERENCED_PARAMETER(cb);
    UNREFERENCED_PARAMETER(fClient);

    if (!fIcon)
        LR_Flags |= LR_MONOCHROME;

    if (pResData == NULL) {

        hRet = LoadIcoCur(hmod,
                          lpName,
                          type,
                          0,
                          0,
                          LR_Flags | LR_DEFAULTSIZE);

    } else {

        hRet = ConvertDIBIcon((LPBITMAPINFOHEADER)pResData,
                              hmod,
                              lpName,
                              fIcon,
                              GetIcoCurWidth(0 , fIcon, LR_DEFAULTSIZE, 0),
                              GetIcoCurHeight(0, fIcon, LR_DEFAULTSIZE, 0),
                              LR_Flags);
    }

    return hRet;
}

/***************************************************************************\
* WOWServerLoadCreateMenu
*
*
\***************************************************************************/
HMENU WowServerLoadCreateMenu(
    HANDLE hMod,
    LPCSTR lpName,
    CONST  LPMENUTEMPLATE pmt,
    DWORD  cb,
    BOOL   fCallClient)
{
    UNREFERENCED_PARAMETER(cb);
    UNREFERENCED_PARAMETER(fCallClient);

    if (pmt == NULL) {
        return LoadMenuA(hMod, lpName);
    } else
        return CreateMenuFromResource(pmt);
}

/***********************************************************************\
* DIBFromBitmap()
*
*  Creates a memory block with DIB information from a physical bitmap tagged
*  to a specific DC.
*
*  A DIB block consists of a BITMAPINFOHEADER + RGB colors + DIB bits.
*
* Returns: UserLocalAlloc pointer to DIB info.
*
* 03-Nov-1995 SanfordS  Created.
\***********************************************************************/

PVOID DIBFromBitmap(
    HBITMAP hbmp,
    HDC     hdc)
{
    BITMAP             bmp;
    LPBITMAPINFOHEADER lpbi;
    DWORD              cbBits;
    DWORD              cbPalette;
    DWORD              cbTotal;
    WORD               cBits;

    UserAssert(hbmp);
    UserAssert(hdc);

    if (GetObject(hbmp, sizeof(BITMAP), &bmp) == 0)
        return NULL;

    cBits = ((WORD)bmp.bmPlanes * (WORD)bmp.bmBitsPixel);

TrySmallerDIB:

    cbBits = (DWORD)WIDTHBYTES((WORD)bmp.bmWidth * cBits) * (DWORD)bmp.bmHeight;

    cbPalette = 0;
    if (cBits <= 8)
        cbPalette = (1 << cBits) * sizeof(RGBQUAD);
    else
        cbPalette = 3 * sizeof(RGBQUAD);

    cbTotal  = sizeof(BITMAPINFOHEADER) + cbPalette + cbBits;
    lpbi = (LPBITMAPINFOHEADER)UserLocalAlloc(HEAP_ZERO_MEMORY, cbTotal);
    if (lpbi == NULL) {

        /*
         * Try a smaller DIB, if we can.  We can't if the DIB is mono.
         */
        switch (cBits) {
        case 4:
            cBits = 1;
            break;

        case 8:
            cBits = 4;
            break;

        case 16:
            cBits = 8;
            break;

        case 24:
            cBits = 16;
            break;

        case 32:
            cBits = 24;
            break;

        default:
            return NULL;   // 1 or wierd.
        }

        RIPMSG1(RIP_WARNING, "Not enough memory to create large color DIB, trying %d bpp.", cBits);
        goto TrySmallerDIB;
    }

    RtlZeroMemory(lpbi, sizeof(BITMAPINFOHEADER));
    lpbi->biSize        = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth       = bmp.bmWidth;
    lpbi->biHeight      = bmp.bmHeight;
    lpbi->biPlanes      = 1;
    lpbi->biBitCount    = cBits;

    /*
     * Get old bitmap's DIB bits, using the current DC.
     */
    GetDIBits(hdc,
              hbmp,
              0,
              lpbi->biHeight,
              ((LPSTR)lpbi) + lpbi->biSize + cbPalette,
              (LPBITMAPINFO)lpbi,
              DIB_RGB_COLORS);

    lpbi->biClrUsed   = cbPalette / sizeof(RGBQUAD);
    lpbi->biSizeImage = cbBits;

    return lpbi;
}

/***************************************************************************\
* CopyBmp
*
* Creates a new bitmap and copies the given bitmap to the new one,
* stretching and color-converting the bits if desired.
*
* 03-Nov-1995 SanfordS  Created.
\***************************************************************************/

HBITMAP CopyBmp(
    HBITMAP hbmpOrg,
    int     cxNew,
    int     cyNew,
    UINT    LR_flags)
{
    HBITMAP hbmNew = NULL;
    LPBITMAPINFOHEADER pdib;

    RtlEnterCriticalSection(&gcsHdc);

    if (pdib = DIBFromBitmap(hbmpOrg, ghdcBits2)) {

#if 0  // Win-9x comments this code out
        if (LR_flags & LR_COPYRETURNORG) {

            DWORD bpp = GetIcoCurBpp(LR_flags);

            if ((cxNew == 0 || cxNew == pdib->biWidth)  &&
                (cyNew == 0 || cyNew == pdib->biHeight) &&
                (bpp == 0 || bpp == pdib->biBitCount)) {

                hbmNew = hbmpOrg;
            }
        }

        if (hbmNew == NULL)
            hbmNew = ConvertDIBBitmap(pdib, cxNew, cyNew, LR_flags, NULL, NULL);
#endif

        hbmNew = ConvertDIBBitmap(pdib, cxNew, cyNew, LR_flags, NULL, NULL);

        UserLocalFree(pdib);
    }

    RtlLeaveCriticalSection(&gcsHdc);

    if ((LR_flags & LR_COPYDELETEORG) && hbmNew && (hbmNew != hbmpOrg))
        DeleteObject(hbmpOrg);

    return hbmNew;
}

/***********************************************************************\
* CopyImageFromRes
*
* This is used by the LR_COPYFROMRESOURCE option.  We assume that the
* icon/cursor passed in is among the process list of loaded shared
* icons.  If we find it there, we can attempt to load the icon from
* the resource to get an image that looks better than a stretched or
* compressed one.
*
* That way we will not stretch a 32x32 icon to 16x16 if someone added
* a 16x16 image to their class icon--a simple way for apps to jazz up
* their appearance.
*
* 12-Mar-1996 ChrisWil  Created.
\***********************************************************************/

HICON CopyImageFromRes(
    LPWSTR      pszModName,
    LPWSTR      pszResName,
    PCURSORFIND pcfSearch,
    UINT        LR_flags)
{
    HINSTANCE hmod;
    HICON     hicoDst = NULL;

    /*
     * Override the search-criteria if this is the user-module.  By
     * setting these to zero, we are basically saying "don't care" for
     * these attributes.
     */
    hmod = (pszModName ? WowGetModuleHandle(pszModName) : hmodUser);

    if (hmod == hmodUser) {

        pcfSearch->cx  = 0;
        pcfSearch->cy  = 0;
        pcfSearch->bpp = 0;

        pszModName = szUSER32;
    }

    /*
     * If a resource has been found with this name/bpp, then attempt
     * to load the resource with the desired dimensions.
     */
    if (FindExistingCursorIcon(pszModName, pszResName, pcfSearch)) {

        hicoDst = LoadIcoCur(hmod,
                             pszResName,
                             (LPWSTR)ULongToPtr( pcfSearch->rt ),
                             pcfSearch->cx,
                             pcfSearch->cy,
                             LR_flags);
    }

    return hicoDst;
}

/***********************************************************************\
*  CopyIcoCur()
*
*  Allocates a new icon resource and transmogrifies the old icon into the
*  newly desired format.
*
*  Note that if we have to stretch the icon, the hotspot area changes.  For
*  icons, the hotspot is set to be the middle of the icon.
*
* Returns:
*
* 01-Nov-1995 SanfordS  Created.
* 12-Mar-1996 ChrisWil  Added lookup for existing icon/cursor.
\***********************************************************************/

HICON CopyIcoCur(
    HICON hicoSrc,
    BOOL  fIcon,
    int   cxNew,
    int   cyNew,
    UINT  LR_flags)
{
    HBITMAP        hbmMaskNew;
    HBITMAP        hbmColorNew;
    int            cx;
    int            cy;
    DWORD          bpp;
    DWORD          bppDesired;
    HICON          hicoDst = NULL;
    ICONINFO       ii;
    CURSORDATA     cur;
    UNICODE_STRING strModName;
    UNICODE_STRING strResName;
    WCHAR          awszModName[MAX_PATH];
    WCHAR          awszResName[MAX_PATH];

    /*
     * Extract needed info from existing icon/cursor from the kernel
     */
    if (!NtUserGetIconSize(hicoSrc, 0, &cx, &cy))
        return NULL;

    cy >>= 1;

    if (LR_flags & LR_CREATEDIBSECTION)
        LR_flags = (LR_flags & ~LR_CREATEDIBSECTION) | LR_CREATEREALDIB;

    /*
     * Setup unicode-strings for calls to kernel-side.
     */
    strModName.Length        = 0;
    strModName.MaximumLength = MAX_PATH;
    strModName.Buffer        = awszModName;

    strResName.Length        = 0;
    strResName.MaximumLength = MAX_PATH;
    strResName.Buffer        = awszResName;

    /*
     * Note: this creates copies of hbmMask and hbmColor that need to be
     * freed before we leave.
     */
    if (!NtUserGetIconInfo(hicoSrc,
                           &ii,
                           &strModName,
                           &strResName,
                           &bpp,
                           TRUE)) {

        return NULL;
    }

    cxNew = GetIcoCurWidth(cxNew, fIcon, LR_flags, cx);
    cyNew = GetIcoCurHeight(cyNew, fIcon, LR_flags, cy);

    if (LR_flags & LR_COPYFROMRESOURCE) {

        CURSORFIND cfSearch;
        LPWSTR     pszModName;

        /*
         * Setup the search criteria.
         */
        cfSearch.hcur = hicoSrc;
        cfSearch.rt   = PtrToUlong((fIcon ? RT_ICON : RT_CURSOR));
        cfSearch.cx   = cxNew;
        cfSearch.cy   = cyNew;
        cfSearch.bpp  = bpp;

        /*
         * Copy the image.  This performs a lookup for the hicoSrc.  If
         * it is not found in the process and shared caches, then we
         * will proceed with copying the hicoSrc.  If an icon is found
         * in the cache, then we will attempt to reload the image for
         * the best resolution possible.
         */
        pszModName = (strModName.Length ? strModName.Buffer : NULL);

        hicoDst = CopyImageFromRes(pszModName,
                                   strResName.Buffer,
                                   &cfSearch,
                                   LR_flags);

        if (hicoDst)
            goto CleanupExit;
    }

    bppDesired = GetIcoCurBpp(LR_flags);

    if ((cxNew != cx) ||
        (cyNew != cy) ||
        ((bpp != 1) && (bppDesired != 0) && (bppDesired != bpp))) {

        /*
         * Since we have to stretch or maybe fixup the colors just get
         * the DIB bits and let ConverDIBBitmap do all the magic.
         */
        hbmMaskNew = CopyBmp(ii.hbmMask, cxNew, cyNew * 2, LR_MONOCHROME);

        if (hbmMaskNew == NULL)
            goto CleanupExit;

        hbmColorNew = NULL;

        if (ii.hbmColor) {

            hbmColorNew = CopyBmp(ii.hbmColor, cxNew, cyNew, LR_flags);

            if (hbmColorNew == NULL) {
                DeleteObject(hbmMaskNew);
                goto CleanupExit;
            }
        }

        /*
         * Replace ii.hbmxxx guys with our fixed up copies and delete the old.
         */
        DeleteObject(ii.hbmMask);
        ii.hbmMask = hbmMaskNew;

        if (ii.hbmColor && (ii.hbmColor != hbmColorNew)) {
            DeleteObject(ii.hbmColor);
            ii.hbmColor = hbmColorNew;
        }

        /*
         * tweak the hotspots for changes in size.
         */
        if (cxNew != cx)
            ii.xHotspot = MultDiv(ii.xHotspot, cxNew, cx);

        if (cyNew != cy)
            ii.yHotspot = MultDiv(ii.yHotspot, cyNew, cy);

    } else if (LR_flags & LR_COPYRETURNORG) {

        hicoDst = hicoSrc;

CleanupExit:

        /*
         * Free up the bitmaps which were created by GetIconInfo().
         */
        DeleteObject(ii.hbmMask);

        if (ii.hbmColor)
            DeleteObject(ii.hbmColor);

        goto Exit;
    }

    /*
     * Build the icon/cursor object from the info.  The bitmaps
     * are not freed in this case.
     */
    hicoDst = (HICON)NtUserCallOneParam(0, SFI__CREATEEMPTYCURSOROBJECT);

    if (hicoDst == NULL)
        goto CleanupExit;

    RtlZeroMemory(&cur, sizeof(cur));
    cur.lpName    = strResName.Length ? strResName.Buffer : NULL;
    cur.lpModName = strModName.Length ? strModName.Buffer : NULL;
    cur.rt        = ii.fIcon ? PTR_TO_ID(RT_ICON) : PTR_TO_ID(RT_CURSOR);
    cur.bpp       = bpp;
    cur.cx        = cxNew;
    cur.cy        = cyNew * 2;
    cur.xHotspot  = (short)ii.xHotspot;
    cur.yHotspot  = (short)ii.yHotspot;
    cur.hbmMask   = ii.hbmMask;
    cur.hbmColor  = ii.hbmColor;

    if (!_SetCursorIconData(hicoDst, &cur)) {
        NtUserDestroyCursor(hicoDst, CURSOR_ALWAYSDESTROY);
        return NULL;
    }

Exit:

    /*
     * destroy the original if asked to.
     */
    if (hicoDst != hicoSrc && (LR_flags & LR_COPYDELETEORG))
        DestroyCursor(hicoSrc);

    return hicoDst;
}

/***********************************************************************\
* CopyImage
*
* Allocates a new icon resource and copies the attributes of the old icon
* to the new icon.
*
* Returns: hIconNew
*
* 01-Nov-1995 SanfordS  Created.
\***********************************************************************/


FUNCLOG5(LOG_GENERAL, HANDLE, WINAPI, CopyImage, HANDLE, hImage, UINT, IMAGE_flag, int, cxNew, int, cyNew, UINT, LR_flags)
HANDLE WINAPI CopyImage(
    HANDLE hImage,
    UINT   IMAGE_flag,
    int    cxNew,
    int    cyNew,
    UINT   LR_flags)
{
    if (LR_flags & ~LR_VALID) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "CopyImage: bad LR_flags.");
        return NULL;
    }

    return InternalCopyImage(hImage, IMAGE_flag, cxNew, cyNew, LR_flags);
}

/***********************************************************************\
* InternalCopyImage
*
* Performs the copyimage work.  This is called from the callback-thunk.
*
\***********************************************************************/

HANDLE InternalCopyImage(
    HANDLE hImage,
    UINT   IMAGE_flag,
    int    cxNew,
    int    cyNew,
    UINT   LR_flags)
{
    switch (IMAGE_flag) {

    case IMAGE_BITMAP:
        if (GetObjectType(hImage) != OBJ_BITMAP) {
            RIPERR0(ERROR_INVALID_HANDLE, RIP_WARNING, "CopyImage: invalid bitmap");
            return NULL;
        }

        return (HICON)CopyBmp(hImage, cxNew, cyNew, LR_flags);

    case IMAGE_CURSOR:
    case IMAGE_ICON:

        return CopyIcoCur(hImage,
                          (IMAGE_flag == IMAGE_ICON),
                          cxNew,
                          cyNew,
                          LR_flags);
    }

    RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "CopyImage: bad IMAGE_flag.");

    return NULL;
}

/***************************************************************************\
* RtlGetIdFromDirectory
*
* History:
* 06-Apr-1991 ScottLu   Cleaned up, make work with client/server.
* 16-Nov-1995 SanfordS  Now uses LookupIconIdFromDirectoryEx
\***************************************************************************/

int RtlGetIdFromDirectory(
    PBYTE  presbits,
    BOOL   fIcon,
    int    cxDesired,
    int    cyDesired,
    DWORD  LR_flags,
    PDWORD pdwResSize)
{
    LPNEWHEADER lpnh;
    LPRESDIR    lprsd;
    UINT        iImage;
    UINT        cImage;
    UINT        bpp;

    /*
     * Make sure this is pointing to valid resource bits.
     */
    if (presbits == NULL)
        return 0;

    lpnh = (LPNEWHEADER)presbits;

    /*
     * Fill in defaults.
     */
    cxDesired = GetIcoCurWidth(cxDesired, fIcon, LR_flags, 0);
    cyDesired = GetIcoCurHeight(cyDesired, fIcon, LR_flags, 0);

    bpp = GetIcoCurBpp(LR_flags);

    /*
     * We'll use the first image in the directory if we can't find one
     * that's appropriate.
     */
    cImage = lpnh->ResCount;
    lprsd  = (LPRESDIR)(lpnh + 1);

    iImage = GetBestImage(lprsd, cImage, cxDesired, cyDesired, bpp, fIcon);

    if (iImage == cImage)
        iImage = 0;

    if (pdwResSize != NULL)
        *pdwResSize = (lprsd + iImage)->BytesInRes;

    return ((LPRESDIR)(lprsd + iImage))->idIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\connect.c ===
/****************************** Module Header ******************************\
* Module Name: connect.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager conversation connection functions
*
* Created: 11/3/91 Sanford Staab
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include "nddeagnt.h"

//#define TESTING
#ifdef TESTING
ULONG
DbgPrint(
    PCH Format,
    ...
    );
VOID
DbgUserBreakPoint(
    VOID
    );

BOOL ValidateConvList(
HCONVLIST hConvList)
{
    PCONVLIST pcl;
    PCL_CONV_INFO pci;
    PXACT_INFO pxi;
    int i;
    BOOL fMatch;

    if (hConvList == 0) {
        return(TRUE);
    }
    pcl = (PCONVLIST)ValidateCHandle((HANDLE)hConvList,
                                     HTYPE_CONVERSATION_LIST,
                                     HINST_ANY);
    for (i = 0; i < pcl->chwnd; i++) {
        /*
         * all windows in the list are valid
         */
        if (!IsWindow(pcl->ahwnd[i])) {
            DebugBreak();
        }
        pci = (PCL_CONV_INFO)GetWindowLongPtr(pcl->ahwnd[i], GWLP_PCI);
       /*
        * All windows have at least one convinfo associated with them.
        */
        if (pci == NULL) {
            DebugBreak();
        }
        fMatch = FALSE;
        while (pci != NULL) {
            /*
             * All non-zombie conversations have hConvList set correctly.
             */
            if (pci->hConvList != hConvList &&
                    TypeFromHandle(pci->ci.hConv) != HTYPE_ZOMBIE_CONVERSATION) {
                DebugBreak();
            }
            /*
             * All conversations have hConvList clear or set correctly.
             */
            if (pci->hConvList != 0 && pci->hConvList != hConvList) {
                DebugBreak();
            }
            /*
             * At least 1 of the conversations references the list
             */
            if (pci->hConvList == hConvList) {
                fMatch = TRUE;
            }
            for (pxi = pci->ci.pxiOut; pxi; pxi = pxi->next) {
                if ((PCL_CONV_INFO)pxi->pcoi != pci) {
                    DebugBreak();
                }
            }
            pci = (PCL_CONV_INFO)pci->ci.next;
        }
        if (!fMatch) {
            /*
             * At least 1 of the conversations references the list
             */
            DebugBreak;
        }
    }
    return(TRUE);
}

VOID ValidateAllConvLists()
{
    ApplyFunctionToObjects(HTYPE_CONVERSATION_LIST, HINST_ANY,
            (PFNHANDLEAPPLY)ValidateConvList);
}

#else // TESTING
#define ValidateConvList(h)
#define ValidateAllConvLists()
#endif // TESTING

CONVCONTEXT TempConvContext;
CONVCONTEXT DefConvContext = {
    sizeof(CONVCONTEXT),
    0,
    0,
    CP_WINANSI,
    0L,
    0L,
    {
        sizeof(SECURITY_QUALITY_OF_SERVICE),
        SecurityImpersonation,
        SECURITY_STATIC_TRACKING,
        TRUE
    }
};

typedef struct tagINIT_ENUM {
    HWND hwndClient;
    HWND hwndSkip;
    LONG lParam;
    LATOM laServiceRequested;
    LATOM laTopic;
    HCONVLIST hConvList;
    DWORD clst;
} INIT_ENUM, *PINIT_ENUM;


BOOL InitiateEnumerationProc(HWND hwndTarget, PINIT_ENUM pie);
VOID DisconnectConv(PCONV_INFO pcoi);


/***************************************************************************\
* DdeConnect (DDEML API)
*
* Description:
* Initiates a DDE conversation.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, HCONV, DUMMYCALLINGTYPE, DdeConnect, DWORD, idInst, HSZ, hszService, HSZ, hszTopic, PCONVCONTEXT, pCC)
HCONV DdeConnect(
    DWORD idInst,
    HSZ hszService,
    HSZ hszTopic,
    PCONVCONTEXT pCC)
{
    PCL_INSTANCE_INFO pcii;
    PCL_CONV_INFO pci;
    HCONV hConvRet = 0;
    HWND hwndTarget = 0;
    LATOM aNormalSvcName = 0;

    EnterDDECrit;

    if (!ValidateConnectParameters((HANDLE)LongToHandle( idInst ), &pcii, &hszService, hszTopic,
            &aNormalSvcName, &pCC, &hwndTarget, 0)) {
        goto Exit;
    }
    pci = ConnectConv(pcii, LATOM_FROM_HSZ(hszService), LATOM_FROM_HSZ(hszTopic),
            hwndTarget,
            (pcii->afCmd & CBF_FAIL_SELFCONNECTIONS) ? pcii->hwndMother : 0,
            pCC, 0, CLST_SINGLE_INITIALIZING);
    if (pci == NULL) {
        SetLastDDEMLError(pcii, DMLERR_NO_CONV_ESTABLISHED);
        goto Exit;
    } else {
        hConvRet = pci->ci.hConv;
    }

Exit:
    if (aNormalSvcName) {
        GlobalDeleteAtom(aNormalSvcName);
    }
    LeaveDDECrit;
    return (hConvRet);
}



/***************************************************************************\
* DdeConnectList (DDEML API)
*
* Description:
* Initiates DDE conversations with multiple servers or adds unique servers
* to an existing conversation list.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG5(LOG_GENERAL, HCONVLIST, DUMMYCALLINGTYPE, DdeConnectList, DWORD, idInst, HSZ, hszService, HSZ, hszTopic, HCONVLIST, hConvList, PCONVCONTEXT, pCC)
HCONVLIST DdeConnectList(
    DWORD idInst,
    HSZ hszService,
    HSZ hszTopic,
    HCONVLIST hConvList,
    PCONVCONTEXT pCC)
{
    PCL_INSTANCE_INFO pcii;
    PCONV_INFO pcoi, pcoiNew, pcoiExisting, pcoiNext;
    HCONVLIST hConvListRet = 0;
    HWND hwndTarget = 0;
    LATOM aNormalSvcName = 0;
    PCONVLIST pcl = NULL, pclTemp = NULL;
    HCONVLIST hConvListOld;
    int i;

    CheckDDECritOut;

    EnterDDECrit;

    if (!ValidateConnectParameters((HANDLE)LongToHandle( idInst ), &pcii, &hszService, hszTopic,
            &aNormalSvcName, &pCC, &hwndTarget, hConvList)) {
        goto Exit;
    }

    ValidateConvList(hConvList);

    hConvListOld = hConvList;
    pcoi = (PCONV_INFO)ConnectConv(pcii,
            LATOM_FROM_HSZ(hszService),
            LATOM_FROM_HSZ(hszTopic),
            hwndTarget,
            (pcii->afCmd & (CBF_FAIL_SELFCONNECTIONS | CBF_FAIL_CONNECTIONS)) ?
                pcii->hwndMother : 0,
            pCC,
            hConvListOld,
            CLST_MULT_INITIALIZING);

    if (pcoi == NULL) {
        /*
         * no new connections made
         */
        SetLastDDEMLError(pcii, DMLERR_NO_CONV_ESTABLISHED);
        hConvListRet = hConvListOld;
        goto Exit;
    }

    /*
     * allocate or reallocate the hConvList hwnd list for later addition
     * If we already have a valid list, reuse the handle so we don't have
     * to alter the preexisting pcoi->hConvList values.
     */
    if (hConvListOld == 0) {
        pcl = (PCONVLIST)DDEMLAlloc(sizeof(CONVLIST));
        if (pcl == NULL) {
            SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
            DisconnectConv(pcoi);
            goto Exit;
        }
        // pcl->chwnd = 0; LPTR zero inits.

        hConvList = (HCONVLIST)CreateHandle((ULONG_PTR)pcl,
                HTYPE_CONVERSATION_LIST, InstFromHandle(pcii->hInstClient));
        if (hConvList == 0) {
            DDEMLFree(pcl);
            SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
            DisconnectConv(pcoi);
            goto Exit;
        }
    } else {
        pcl = (PCONVLIST)GetHandleData((HANDLE)hConvList);
        pclTemp = DDEMLReAlloc(pcl, sizeof(CONVLIST) + sizeof(HWND) * pcl->chwnd);
        if (pclTemp == NULL) {
            SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
            hConvListRet = hConvListOld;
            DisconnectConv(pcoi);
            goto Exit;
        }
        pcl = pclTemp;
        SetHandleData((HANDLE)hConvList, (ULONG_PTR)pcl);
    }

    ValidateConvList(hConvListOld);

    if (hConvListOld) {
        /*
         * remove duplicates from new conversations
         *
         * Although we tried to prevent duplicates from happening
         * within the initiate enumeration code, wild initiates or
         * servers responding with different service names than
         * requested could cause duplicates.
         */

        /* For each client window... */

        for (i = 0; i < pcl->chwnd; i++) {

        /* For each existing conversation in that window... */

            for (pcoiExisting = (PCONV_INFO)
                        GetWindowLongPtr(pcl->ahwnd[i], GWLP_PCI);
                    pcoi != NULL && pcoiExisting != NULL;
                    pcoiExisting = pcoiExisting->next) {

                if (!(pcoiExisting->state & ST_CONNECTED))
                    continue;

        /* For each new conversation... */

                for (pcoiNew = pcoi; pcoiNew != NULL; pcoiNew = pcoiNext) {

                    pcoiNext = pcoiNew->next;

        /* see if the new conversation duplicates the existing one */

                    if (!(pcoiNew->state & ST_CONNECTED))
                        continue;

                    UserAssert(((PCL_CONV_INFO)pcoiExisting)->hwndReconnect);
                    UserAssert(((PCL_CONV_INFO)pcoiNew)->hwndReconnect);

                    if (((PCL_CONV_INFO)pcoiExisting)->hwndReconnect ==
                                ((PCL_CONV_INFO)pcoiNew)->hwndReconnect &&
                            pcoiExisting->laTopic == pcoiNew->laTopic &&
                            pcoiExisting->laService == pcoiNew->laService) {
                        /*
                         * duplicate conversation - disconnection causes an unlink
                         */
                        if (pcoiNew == pcoi) {
                            /*
                             * We are freeing up the head of the list,
                             * Reset the head to the next guy.
                             */
                            pcoi = pcoiNext;
                        }
                        ValidateConvList(hConvList);
                        ShutdownConversation(pcoiNew, FALSE);
                        ValidateConvList(hConvList);
                        break;
                    }
                }
            }
        }

        for (pcoiExisting = pcoi; pcoiExisting != NULL; pcoiExisting = pcoiExisting->next) {
            /*
             * if these are all zombies - we DONT want to link it in!
             * This is possible because ShutdownConversation() leaves the critical section
             * and could allow responding terminates to come through.
             */
            if (pcoiExisting->state & ST_CONNECTED) {
                goto FoundOne;
            }
        }
        pcoi = NULL;    // abandon this guy - he will clean up in time.
FoundOne:
        /*
         * add new pcoi (if any are left) hwnd to ConvList hwnd list.
         */
        if (pcoi != NULL) {
            UserAssert(pcoi->hwndConv);
            pcl->ahwnd[pcl->chwnd] = pcoi->hwndConv;
            pcl->chwnd++;
            hConvListRet = hConvList;
        } else {
            hConvListRet = hConvListOld;
            if (!hConvListOld) {
                DestroyHandle((HANDLE)hConvList);
            }
        }


    } else {    // no hConvListOld

        UserAssert(pcoi->hwndConv);
        pcl->ahwnd[0] = pcoi->hwndConv;
        pcl->chwnd = 1;
        hConvListRet = hConvList;
    }

    if (pcoi != NULL) {
        /*
         * set hConvList field for all remaining new conversations.
         */
        UserAssert(hConvListRet);
        for (pcoiNew = pcoi; pcoiNew != NULL; pcoiNew = pcoiNew->next) {
            if (pcoiNew->state & ST_CONNECTED) {
                ((PCL_CONV_INFO)pcoiNew)->hConvList = hConvListRet;
            }
        }
    }

Exit:
    if (aNormalSvcName) {
        DeleteAtom(aNormalSvcName);
    }
    ValidateConvList(hConvListRet);
    LeaveDDECrit;
    return (hConvListRet);
}




/***************************************************************************\
* DdeReconnect (DDEML API)
*
* Description:
* Attempts to reconnect an externally (from the server) terminated
* client side conversation.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, HCONV, DUMMYCALLINGTYPE, DdeReconnect, HCONV, hConv)
HCONV DdeReconnect(
    HCONV hConv)
{
    PCL_INSTANCE_INFO pcii;
    PCL_CONV_INFO pci, pciNew;
    HCONV hConvRet = 0;
    CONVCONTEXT cc;

    EnterDDECrit;

    pcii = PciiFromHandle((HANDLE)hConv);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    pci = (PCL_CONV_INFO)ValidateCHandle((HANDLE)hConv,
            HTYPE_CLIENT_CONVERSATION, HINST_ANY);
    if (pci == NULL) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (pci->ci.state & ST_CONNECTED) {
        goto Exit;
    }

    GetConvContext(pci->ci.hwndConv, (LONG *)&cc);
    pciNew = ConnectConv(pcii, pci->ci.laService, pci->ci.laTopic,
            pci->hwndReconnect, 0, &cc, 0, CLST_SINGLE_INITIALIZING);
    if (pciNew == NULL) {
        SetLastDDEMLError(pcii, DMLERR_NO_CONV_ESTABLISHED);
        goto Exit;
    } else {
        hConvRet = pciNew->ci.hConv;
        if (pci->ci.cLinks) {
            PXACT_INFO pxi;
            int iLink;
            PADVISE_LINK paLink;

            /*
             * reestablish advise links
             */

            for (paLink = pci->ci.aLinks, iLink = pci->ci.cLinks;
                    iLink; paLink++, iLink--) {

                pxi = (PXACT_INFO)DDEMLAlloc(sizeof(XACT_INFO));
                if (pxi == NULL) {
                    break;              // abort relinking
                }
                pxi->pcoi = (PCONV_INFO)pciNew;
                pxi->gaItem = LocalToGlobalAtom(paLink->laItem); // pxi copy
                pxi->wFmt = paLink->wFmt;
                pxi->wType = (WORD)((paLink->wType >> 12) | XTYP_ADVSTART);
                if (ClStartAdvise(pxi)) {
                    pxi->flags |= XIF_ABANDONED;
                } else {
                    GlobalDeleteAtom(pxi->gaItem);
                    DDEMLFree(pxi);
                }
            }
        }
    }

Exit:
    LeaveDDECrit;
    return (hConvRet);
}


/***************************************************************************\
* ValidateConnectParameters
*
* Description:
* worker function to handle common validation code.
*
* Note that paNormalSvcName is set to the atom value created upon extracting
* a normal HSZ from an InstanceSpecific HSZ.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL ValidateConnectParameters(
    HANDLE hInst,
    PCL_INSTANCE_INFO *ppcii, // set if valid hInst
    HSZ *phszService, // altered if InstSpecific HSZ
    HSZ hszTopic,
    LATOM *plaNormalSvcName, // set to atom that needs freeing when done
    PCONVCONTEXT *ppCC, // set to point to DefConvContext if NULL
    HWND *phwndTarget, // set if hszService is InstSpecific
    HCONVLIST hConvList)
{
    DWORD hszType;
    BOOL fError = FALSE;

    *ppcii = ValidateInstance(hInst);
    if (*ppcii == NULL) {
        return (FALSE);
    }
    hszType = ValidateHSZ(*phszService);
    if (hszType == HSZT_INVALID || ValidateHSZ(hszTopic) == HSZT_INVALID) {
        SetLastDDEMLError(*ppcii, DMLERR_INVALIDPARAMETER);
        return (FALSE);
    }
    if (hszType == HSZT_INST_SPECIFIC) {
        *phwndTarget = ParseInstSpecificAtom(LATOM_FROM_HSZ(*phszService),
            plaNormalSvcName);
        if (*plaNormalSvcName == 0) {
            SetLastDDEMLError(*ppcii, DMLERR_SYS_ERROR);
            return (FALSE);
        }
        *phszService = NORMAL_HSZ_FROM_LATOM(*plaNormalSvcName);
    }
    if (*ppCC == NULL) {
        *ppCC = &DefConvContext;
        if ((*ppcii)->flags & IIF_UNICODE) {
            (*ppCC)->iCodePage = CP_WINUNICODE;
        } else {
            (*ppCC)->iCodePage = CP_WINANSI;
        }
    } else try {
        if ((*ppCC)->cb > sizeof(CONVCONTEXT)) {
            SetLastDDEMLError(*ppcii, DMLERR_INVALIDPARAMETER);
            fError = TRUE;
        } else if ((*ppCC)->cb < sizeof(CONVCONTEXT)) {
            TempConvContext = DefConvContext;
            /*
             * we can use this static temp because we are synchronized.
             */
            RtlCopyMemory(&TempConvContext, *ppCC, (*ppCC)->cb);
            *ppCC = &TempConvContext;
        }
    } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
        SetLastDDEMLError(*ppcii, DMLERR_INVALIDPARAMETER);
        fError = TRUE;
    }
    if (fError) {
        return(FALSE);
    }
    if (hConvList != 0 &&
            !ValidateCHandle((HANDLE)hConvList, HTYPE_CONVERSATION_LIST,
            (DWORD)InstFromHandle((*ppcii)->hInstClient))) {
        return (FALSE);
    }
    return (TRUE);
}



/***************************************************************************\
* ConnectConv
*
* Description:
* Work function for all Connect cases.
*
* Method:
*
* To reduce the number of windows we use and to simplify how client
* windows handle multiple WM_DDE_ACK messages during initiation, a
* single client window can handle many conversations, each with
* a different server window.
*
* The client window is created and set to a initiation state via the
* GWL_CONVSTATE window word. Initiates are then sent to enumerated server
* window candidates.
* The GWL_CONVSTATE value is used by the DDEML mother windows
* to determine if only one or several ACKs are desired to minimize
* unnessary message traffic.
*
* The client window GWL_CONVCONTEXT? window words are also used by
* Event Windows to pass context information.
*
* Note that all client and server windows are children of the mother
* window. This reduces the number of top level windows that
* WM_DDE_INITIATES need to hit.
*
* Each WM_DDE_ACK that is received by a client window while in the
* initiation state causes it to create a CL_CONV_INFO structure,
* partially initialize it, and link it into its list of CL_CONV_INFO
* structures. The head of the list is pointed to by the GWLP_PCI
* client window word.
*
* After each WM_DDE_INITIALIZE is sent, the GWLP_PCI value is checked
* to see if it exists and needs initialization to be completed. If
* this is the case the init code knows that at least one ACK was
* received in response to the WM_DDE_INITIALIZE send. The
* initialization of each CL_CONV_INFO struct that needs it is then completed.
*
* Once the broadcasting of WM_DDE_INITIALIZE is done, the init code
* then sets the GWL_CONVSTATE value in the client window to indicate that
* initialization is complete.
*
* Returns:
* The head pci to the client window or NULL if no connections made it.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
PCL_CONV_INFO ConnectConv(
    PCL_INSTANCE_INFO pcii,
    LATOM laService,
    LATOM laTopic,
    HWND hwndTarget, // 0 implies broadcast
    HWND hwndSkip, // 0 implies no skips - avoids self-connections.
    PCONVCONTEXT pCC,
    HCONVLIST hConvList,
    DWORD clst)
{
    INIT_ENUM ie;
    PCL_CONV_INFO pci;
    PCONV_INFO pcoi;
    GATOM gaService, gaTopic;

    CheckDDECritIn;

    if (hwndTarget && hwndTarget == hwndSkip) {
        return(NULL);
    }

    LeaveDDECrit;
    CheckDDECritOut;

    if (pcii->flags & IIF_UNICODE) {
        ie.hwndClient = CreateWindowW((LPWSTR)(gpsi->atomSysClass[ICLS_DDEMLCLIENTW]),
                                     L"",
                                     WS_CHILD,
                                     0, 0, 0, 0,
                                     pcii->hwndMother,
                                     (HMENU)0,
                                     (HANDLE)0,
                                     (LPVOID)NULL);
    } else {
        ie.hwndClient = CreateWindowA((LPSTR)(gpsi->atomSysClass[ICLS_DDEMLCLIENTA]),
                                     "",
                                     WS_CHILD,
                                     0, 0, 0, 0,
                                     pcii->hwndMother,
                                     (HMENU)0,
                                     (HANDLE)0,
                                     (LPVOID)NULL);
    }

    EnterDDECrit;

    if (ie.hwndClient == 0) {
        return (NULL);
    }

    if (pCC != NULL) {
        if (!NtUserDdeSetQualityOfService(ie.hwndClient, &(pCC->qos), NULL)) {
            SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
            goto Error;
        }
    }
    /*
     * Note that a pci will be created and allocated for each ACK recieved.
     */
    SetConvContext(ie.hwndClient, (LONG *)pCC);
    SetWindowLong(ie.hwndClient, GWL_CONVSTATE, clst);
    SetWindowLongPtr(ie.hwndClient, GWLP_SHINST, (LONG_PTR)pcii->hInstServer);
    SetWindowLongPtr(ie.hwndClient, GWLP_CHINST, (LONG_PTR)pcii->hInstClient);

    gaService = LocalToGlobalAtom(laService);
    gaTopic = LocalToGlobalAtom(laTopic);
    ie.lParam = MAKELONG(gaService, gaTopic);
    if (!hwndTarget) {
        ie.hwndSkip = hwndSkip;
        ie.laServiceRequested = laService;
        ie.laTopic = laTopic;
        ie.hConvList = hConvList;
        ie.clst = clst;
    }

    LeaveDDECrit;

    if (hwndTarget) {
        SendMessage(hwndTarget, WM_DDE_INITIATE, (WPARAM)ie.hwndClient,
                ie.lParam);
    } else {
        /*
         * Send this message to the nddeagnt app first so it can start
         * the netdde services BEFORE we do an enumeration of windows.
         * This lets things work the first time.  NetDDEAgent caches
         * service status so this is the fastest way to do this.
         */
        HWND hwndAgent = FindWindowW(SZ_NDDEAGNT_CLASS, SZ_NDDEAGNT_TITLE);
        if (hwndAgent) {
            SendMessage(hwndAgent,
                WM_DDE_INITIATE, (WPARAM)ie.hwndClient, ie.lParam);
        }
        EnumWindows((WNDENUMPROC)InitiateEnumerationProc, (LPARAM)&ie);
    }

    EnterDDECrit;
    /*
     * hConvList may have been destroyed during the enumeration but we are
     * done with it now so no need to revalidate.
     */

#if DBG
    {
        WCHAR sz[10];

        if (gaService && GlobalGetAtomName(gaService, sz, 10) == 0) {
            RIPMSG1(RIP_ERROR, "Bad Service Atom after Initiate phase: %lX", (DWORD)gaService);
        }
        if (gaTopic && GlobalGetAtomName(gaTopic, sz, 10) == 0) {
            RIPMSG1(RIP_ERROR, "Bad Topic Atom after Initiate phase: %lX", (DWORD)gaTopic);
        }
    }
#endif // DBG

    GlobalDeleteAtom(gaService);
    GlobalDeleteAtom(gaTopic);

    //
    // Get the first pci allocated when a WM_DDE_ACK was recieved.
    //
    pci = (PCL_CONV_INFO)GetWindowLongPtr(ie.hwndClient, GWLP_PCI);
    if (pci == NULL) {
Error:
        LeaveDDECrit;
        NtUserDestroyWindow(ie.hwndClient);
        EnterDDECrit;
        return (NULL);
    }

    SetWindowLong(ie.hwndClient, GWL_CONVSTATE, CLST_CONNECTED);
    if (hwndTarget) {
        /*
         * If hwndTarget was NULL, the enumeration proc took care of this.
         */
        pci->hwndReconnect = hwndTarget;
        UserAssert(pci->ci.next == NULL);
        pci->ci.laServiceRequested = laService;
        IncLocalAtomCount(laService); // pci copy
    }

    if (pcii->MonitorFlags & MF_CONV) {
        for (pcoi = (PCONV_INFO)pci; pcoi; pcoi = pcoi->next) {
            MONCONV(pcoi, TRUE);
        }
    }
    return (pci);
}


/*
 * Undoes the work of ConnectConv()
 */
VOID DisconnectConv(
PCONV_INFO pcoi)
{
    PCONV_INFO pcoiNext;

    for (; pcoi; pcoi = pcoiNext) {
        pcoiNext = pcoi->next;
        ShutdownConversation(pcoi, FALSE);
    }
}


/***************************************************************************\
* InitiateEnumerationProc (FILE LOCAL)
*
* Description:
* Function used via EnumWindows to enumerate all server window candidates
* during DDE initiation. The enumeration allows DDEML to know what
* window WM_DDE_INITIATE was sent to so that it can be remembered for
* possible reconnection later. (The window that receives the WM_DDE_INITIATE
* message is not necessarily going to be the server window.)
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
BOOL InitiateEnumerationProc(
    HWND hwndTarget,
    PINIT_ENUM pie)
{
    PCL_CONV_INFO pci;

    CheckDDECritOut;

    if (hwndTarget == pie->hwndSkip) {
        return (TRUE);
    }

    if (pie->hConvList && pie->laTopic && pie->laServiceRequested) {
        /*
         * Head off duplicates BEFORE we send the WM_DDE_INITIATE messages!
         */
        PCONVLIST pcl;
        PCONV_INFO pcoiExisting;
        int i;

        EnterDDECrit;
        /*
         * We revalidate hConvList here because we left the critical section.
         */
        pcl = (PCONVLIST)ValidateCHandle((HANDLE)pie->hConvList,
                HTYPE_CONVERSATION_LIST, HINST_ANY);
        if (pcl != NULL) {
            for (i = 0; i < pcl->chwnd; i++) {
                for (pcoiExisting = (PCONV_INFO)GetWindowLongPtr(pcl->ahwnd[i], GWLP_PCI);
                        pcoiExisting != NULL;
                        pcoiExisting = pcoiExisting->next) {
                    if (pcoiExisting->state & ST_CONNECTED &&
                            ((PCL_CONV_INFO)pcoiExisting)->hwndReconnect == hwndTarget &&
                            pcoiExisting->laTopic == pie->laTopic &&
                            pcoiExisting->laService == pie->laServiceRequested) {
                        LeaveDDECrit;
                        return(TRUE);
                    }
                }
            }
        }
        LeaveDDECrit;
    }

    CheckDDECritOut;

    SendMessage(hwndTarget, WM_DDE_INITIATE, (WPARAM)pie->hwndClient,
            pie->lParam);

    EnterDDECrit;

    //
    // During the initiate process, any acks received cause more pci's
    // to become linked together under the same hwndClient. Once
    // the SendMessage() returns, we set the parts of the new pci's
    // that hold initiate context information.
    //
    pci = (PCL_CONV_INFO)GetWindowLongPtr(pie->hwndClient, GWLP_PCI);
    if (pci == NULL) {
        LeaveDDECrit;
        return (TRUE);
    }

    while (pci != NULL) {
        if (pci->hwndReconnect == 0) {  // this one needs updating
            pci->hwndReconnect = hwndTarget;
            if (pie->laServiceRequested) {
                pci->ci.laServiceRequested = pie->laServiceRequested;
                IncLocalAtomCount(pie->laServiceRequested); // pci copy
            }
        }
        if (pie->clst == CLST_SINGLE_INITIALIZING) {
            break;
        }
        pci = (PCL_CONV_INFO)pci->ci.next;
    }
    LeaveDDECrit;
    return (pie->clst == CLST_MULT_INITIALIZING);
}




/***************************************************************************\
* SetCommonStateFlags()
*
* Description:
*   Common client/server worker function
*
* History:
* 05-12-91 sanfords Created.
\***************************************************************************/
VOID SetCommonStateFlags(
HWND hwndUs,
HWND hwndThem,
PWORD pwFlags)
{
    DWORD pidUs, pidThem;

    GetWindowThreadProcessId(hwndUs, &pidUs);
    GetWindowThreadProcessId(hwndThem, &pidThem);
    if (pidUs == pidThem) {
        *pwFlags |= ST_INTRA_PROCESS;
    }

    if (IsWindowUnicode(hwndUs) && IsWindowUnicode(hwndThem)) {
        *pwFlags |= ST_UNICODE_EXECUTE;
    }
}




/***************************************************************************\
* DdeQueryNextServer (DDEML API)
*
* Description:
* Enumerates conversations within a list.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, HCONV, DUMMYCALLINGTYPE, DdeQueryNextServer, HCONVLIST, hConvList, HCONV, hConvPrev)
HCONV DdeQueryNextServer(
    HCONVLIST hConvList,
    HCONV hConvPrev)
{
    HCONV hConvRet = 0;
    PCONVLIST pcl;
    HWND *phwnd;
    int i;
    PCL_CONV_INFO pci;
    PCL_INSTANCE_INFO pcii;

    EnterDDECrit;

    pcl = (PCONVLIST)ValidateCHandle((HANDLE)hConvList,
            HTYPE_CONVERSATION_LIST, HINST_ANY);
    if (pcl == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (!pcl->chwnd) {      // empty list
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hConvList);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    pcii->LastError = DMLERR_NO_ERROR;

    do {

        hConvRet = 0;

        if (hConvPrev == 0) {
            pci = (PCL_CONV_INFO)GetWindowLongPtr(pcl->ahwnd[0], GWLP_PCI);
            if (pci == NULL) {
                goto Exit;  // Must have all conversations zombied.
            }
            hConvPrev = hConvRet = pci->ci.hConv;
            continue;
        }

        pci = (PCL_CONV_INFO)ValidateCHandle((HANDLE)hConvPrev,
                HTYPE_CLIENT_CONVERSATION, InstFromHandle(hConvList));
        if (pci == NULL) {
            pci = (PCL_CONV_INFO)ValidateCHandle((HANDLE)hConvPrev,
                    HTYPE_ZOMBIE_CONVERSATION, InstFromHandle(hConvList));
            if (pci == NULL) {
                SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
                break;
            } else {
                goto ZombieSkip;
            }
        }

        if (pci->hConvList != hConvList) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            break;
        }

ZombieSkip:

        if (pci->ci.next == NULL) {

            /*
             * end of list for this window, go to next window
             */
            for (phwnd = pcl->ahwnd, i = 0; (i + 1) < pcl->chwnd; i++) {
                if (phwnd[i] == pci->ci.hwndConv) {
                    pci = (PCL_CONV_INFO)GetWindowLongPtr(phwnd[i + 1], GWLP_PCI);
                    if (pci == NULL) {
                        break;
                    }
                    hConvPrev = hConvRet = pci->ci.hConv;
                    break;
                }
            }
        } else {

            hConvPrev = hConvRet = pci->ci.next->hConv; // next conv for this window.
        }

    } while (hConvRet && TypeFromHandle(hConvRet) == HTYPE_ZOMBIE_CONVERSATION);
Exit:
    LeaveDDECrit;
    return (hConvRet);
}





/***************************************************************************\
* DdeDisconnect (DDEML API)
*
* Description:
* Terminates a conversation.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeDisconnect, HCONV, hConv)
BOOL DdeDisconnect(
    HCONV hConv)
{
    BOOL fRet = FALSE;
    PCONV_INFO pcoi;
    PCL_INSTANCE_INFO pcii;

    CheckDDECritOut;
    EnterDDECrit;

    pcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
            HTYPE_CLIENT_CONVERSATION, HINST_ANY);
    if (pcoi == NULL) {
        pcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
                HTYPE_SERVER_CONVERSATION, HINST_ANY);
    }
    if (pcoi == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hConv);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (pcoi->state & ST_CONNECTED) {
        ShutdownConversation(pcoi, FALSE);
    }
    fRet = TRUE;

Exit:
    LeaveDDECrit;
    return (fRet);
}


/***************************************************************************\
* DdeDisconnectList (DDEML API)
*
* Description:
* Terminates all conversations in a conversation list and frees the list.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeDisconnectList, HCONVLIST, hConvList)
BOOL DdeDisconnectList(
    HCONVLIST hConvList)
{
    BOOL fRet = FALSE;
    PCL_INSTANCE_INFO pcii;
    PCONVLIST pcl;
    PCONV_INFO pcoi, pcoiNext;
    int i;

    CheckDDECritOut;
    EnterDDECrit;

    pcl = (PCONVLIST)ValidateCHandle((HANDLE)hConvList,
            HTYPE_CONVERSATION_LIST, HINST_ANY);
    if (pcl == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    ValidateConvList(hConvList);
    pcii = PciiFromHandle((HANDLE)hConvList);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    for(i = pcl->chwnd - 1; i >= 0; i--) {
        pcoi = (PCONV_INFO)GetWindowLongPtr(pcl->ahwnd[i], GWLP_PCI);
        while (pcoi != NULL && pcoi->state & ST_CONNECTED) {
            pcoiNext = pcoi->next;
            ShutdownConversation(pcoi, FALSE);  // may unlink pcoi!
            pcoi = pcoiNext;
        }
    }

    DestroyHandle((HANDLE)hConvList);
    DDEMLFree(pcl);
    fRet = TRUE;

Exit:
    LeaveDDECrit;
    return (fRet);
}




/***************************************************************************\
* ShutdownConversation
*
* Description:
* This function causes an imediate termination of the given conversation
* and generates apropriate callbacks to notify the application.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID ShutdownConversation(
    PCONV_INFO pcoi,
    BOOL fMakeCallback)
{
    CheckDDECritIn;

    if (pcoi->state & ST_CONNECTED) {
        pcoi->state &= ~ST_CONNECTED;

        if (IsWindow(pcoi->hwndPartner)) {
            PostMessage(pcoi->hwndPartner, WM_DDE_TERMINATE,
                    (WPARAM)pcoi->hwndConv, 0);
        }
        if (fMakeCallback && !(pcoi->pcii->afCmd & CBF_SKIP_DISCONNECTS)) {
            DoCallback(pcoi->pcii, (WORD)XTYP_DISCONNECT, 0, pcoi->hConv,
                    0, 0, 0, 0, (pcoi->state & ST_ISSELF) ? 1L : 0L);
        }
        MONCONV(pcoi, FALSE);
    }

    FreeConversationResources(pcoi);
}



/***************************************************************************\
* UnlinkConvFromOthers
*
* Description:
*
* Helper function to handle ugly cross dependency removal.  If we are
* unlinking a conversation that is going zombie, fGoingZombie is TRUE;
*
* Conversations that are going zombie are in phase 1 of a 2 phase unlink.
* Phase 1 unlinks do not remove the pcoi from its hwnd's list.
* All unlinks should result in:
*   pcoi->hConvList = 0;
*   hConvList/aServerLookup no longer refrences pcoi->hwndConv unless
*       one of the pcoi's related to hwndConv is still active.
*
*
* History:
*  3-2-92 sanfords Created.
\***************************************************************************/
VOID UnlinkConvFromOthers(
PCONV_INFO pcoi,
BOOL gGoingZombie)
{
    PCONV_INFO pcoiPrev, pcoiFirst, pcoiNow;
    PCONVLIST pcl;
    int i, cActiveInList = 0;
#ifdef TESTING
    DWORD path = 0;
#define ORPATH(x) path |= x;
#else
#define ORPATH(x)
#endif // TESTING

    CheckDDECritIn;

    /*
     * Scan pcoi linked list to get key pointers.
     */
    pcoiPrev = NULL;
    pcoiFirst = pcoiNow = (PCONV_INFO)GetWindowLongPtr(pcoi->hwndConv, GWLP_PCI);

#ifdef TESTING
    /*
     * verify that pcoi is in the conv list for this window.
     */
    while (pcoiNow != NULL) {
        if (pcoiNow == pcoi) {
            goto FoundIt;
        }
        pcoiNow = pcoiNow->next;
    }
    DebugBreak();
FoundIt:
    pcoiNow = pcoiFirst;
#endif // TESTING

    UserAssert(pcoiFirst);
    while (pcoiNow != NULL) {
        if (TypeFromHandle(pcoiNow->hConv) != HTYPE_ZOMBIE_CONVERSATION) {
            ORPATH(1);
            cActiveInList++;
        }
        if (pcoiNow->next == pcoi) {
            pcoiPrev = pcoiNow;
        }
        pcoiNow = pcoiNow->next;
    }

    ValidateAllConvLists();

    /*
     * Unlink conversation unless its going Zombie.
     */
    if (!gGoingZombie) {
        ORPATH(2);
        if (TypeFromHandle(pcoi->hConv) != HTYPE_ZOMBIE_CONVERSATION) {
            ORPATH(4);
            cActiveInList--;
        }

        if (pcoiPrev == NULL) {
            ORPATH(8);
            pcoiFirst = pcoi->next;
            SetWindowLongPtr(pcoi->hwndConv, GWLP_PCI, (LONG_PTR)pcoiFirst);
        } else {
            pcoiPrev->next = pcoi->next;
        }
    }

    UserAssert(pcoiFirst != NULL || !cActiveInList);

    if (cActiveInList == 0) {
        ORPATH(0x10);
        if (pcoi->state & ST_CLIENT) {
            ORPATH(0x20);
            if (((PCL_CONV_INFO)pcoi)->hConvList) {
                /*
                 * Remove pcoi's hwnd from its hConvList.
                 */
                pcl = (PCONVLIST)GetHandleData((HANDLE)((PCL_CONV_INFO)pcoi)->hConvList);
                for (i = 0; i < pcl->chwnd; i++) {
                    if (pcl->ahwnd[i] == pcoi->hwndConv) {
                        ORPATH(0x40);
                        pcl->chwnd--;
                        UserAssert(pcl->ahwnd[pcl->chwnd]);
                        pcl->ahwnd[i] = pcl->ahwnd[pcl->chwnd];
                        ValidateConvList(((PCL_CONV_INFO)pcoi)->hConvList);
                        break;
                    }
                }
                ORPATH(0x80);
            }
        } else {  // SERVER
            /*
             * remove server window from the service/topic lookup table.
             */
            ORPATH(0x100);
            for (i = 0; i < pcoi->pcii->cServerLookupAlloc; i++) {
                if (pcoi->pcii->aServerLookup[i].hwndServer == pcoi->hwndConv) {
                    ORPATH(0x200);
                    
                    /*
                     * Check for appcompat hack
                     */
                    if (GetAppCompatFlags2(VERMAX) & GACF2_DDE) {
                        DeleteAtom(pcoi->pcii->aServerLookup[i].laService); // delete laService
                        DeleteAtom(pcoi->pcii->aServerLookup[i].laTopic);   // delete laTopic
                    }
                    
                    if (--(pcoi->pcii->cServerLookupAlloc)) {
                        ORPATH(0x400);
                        pcoi->pcii->aServerLookup[i] =
                                pcoi->pcii->aServerLookup[pcoi->pcii->cServerLookupAlloc];
                    } else {
                        DDEMLFree(pcoi->pcii->aServerLookup);
                        pcoi->pcii->aServerLookup = NULL;
                    }
                    break;
                }
            }
        }
    }
#ifdef TESTING
      else {
        /*
         * make sure at this point we have at least one non-zombie
         */
        pcoiNow = pcoiFirst;
        while (pcoiNow != NULL) {
            if (TypeFromHandle(pcoiNow->hConv) != HTYPE_ZOMBIE_CONVERSATION) {
                goto Out;
            }
            pcoiNow = pcoiNow->next;
        }
        DebugBreak();
Out:
        ;
    }
#endif // TESTING

    ValidateAllConvLists();
    ORPATH(0x800);

    /*
     * In any case remove hConvList references from client conversation.
     */
    if (pcoi->state & ST_CLIENT) {
#ifdef TESTING
        /*
         * Verify that the hConvList that is being removed, doesn't reference
         * this window.
         */
        if (((PCL_CONV_INFO)pcoi)->hConvList && !cActiveInList) {
            BOOL fFound = FALSE;

            pcl = (PCONVLIST)GetHandleData((HANDLE)((PCL_CONV_INFO)pcoi)->hConvList);
            for (i = 0; i < pcl->chwnd; i++) {
                if (pcl->ahwnd[i] == pcoi->hwndConv) {
                    fFound = TRUE;
                    break;
                }
            }
            UserAssert(!fFound);
        }
#endif // TESTING
        ((PCL_CONV_INFO)pcoi)->hConvList = 0;
        pcoi->state &= ~ST_INLIST;
    }

    /*
     * last one out turns out the lights.
     */
    if (pcoiFirst == NULL) {
        /*
         * If the pcoi list is empty, this window can go away.
         */
        LeaveDDECrit;
        NtUserDestroyWindow(pcoi->hwndConv);
        EnterDDECrit;
    }
}





/***************************************************************************\
* FreeConversationResources
*
* Description:
* Used when: Client window is disconnected by app, Server window is
* disconnected by either side, or when a conversation is disconnected
* at Uninitialize time.
*
* This function releases all resources held by the pcoi and unlinks it
* from its host window pcoi chian. pcoi is freed once this return s.
*
* History:
* 12-21-91 sanfords Created.
\***************************************************************************/
VOID FreeConversationResources(
    PCONV_INFO pcoi)
{
    PADVISE_LINK paLink;
    PDDE_MESSAGE_QUEUE pdmq;
    PXACT_INFO pxi;

    CheckDDECritIn;

    /*
     * Don't free resources on locked conversations.
     */
    if (pcoi->cLocks > 0) {
        pcoi->state |= ST_FREE_CONV_RES_NOW;
        return;
    }

    /*
     * Don't free resources if a synchronous transaction is in effect!
     */
    pxi = pcoi->pxiOut;
    while (pxi != NULL) {
        if (pxi->flags & XIF_SYNCHRONOUS) {
            /*
             * This conversation is in a synchronous transaction.
             * Shutdown the modal loop FIRST, then call this when
             * the loop exits.
             */
            PostMessage(pcoi->hwndConv, WM_TIMER, TID_TIMEOUT, 0);
            pcoi->state |= ST_FREE_CONV_RES_NOW;
            return;
        }
        pxi = pxi->next;
    }

    /*
     * If this is an Intra-Process conversation that hasn't yet received
     * a terminate message, make it a zombie.  We will call this routine
     * again once the terminate arrives or when WaitForZombieTerminate() has
     * timed out waiting.
     */
    if (pcoi->state & ST_INTRA_PROCESS && !(pcoi->state & ST_TERMINATE_RECEIVED)) {
        DestroyHandle((HANDLE)pcoi->hConv);
        pcoi->hConv = (HCONV)CreateHandle((ULONG_PTR)pcoi, HTYPE_ZOMBIE_CONVERSATION,
                InstFromHandle(pcoi->hConv));
        UnlinkConvFromOthers(pcoi, TRUE);
        return;
    }

    /*
     * remove any transactions left in progress
     */
    while (pcoi->pxiOut != NULL) {
        (pcoi->pxiOut->pfnResponse)(pcoi->pxiOut, 0, 0);
    }

    /*
     * Throw away any incoming queued DDE messages.
     */
    while (pcoi->dmqOut != NULL) {

        pdmq = pcoi->dmqOut;
        DumpDDEMessage(!(pcoi->state & ST_INTRA_PROCESS), pdmq->msg, pdmq->lParam);
        pcoi->dmqOut = pcoi->dmqOut->next;
        if (pcoi->dmqOut == NULL) {
            pcoi->dmqIn = NULL;
        }
        DDEMLFree(pdmq);
    }

    //
    // Remove all link info
    //
    paLink = pcoi->aLinks;
    while (pcoi->cLinks) {
        if (pcoi->state & ST_CLIENT) {
            MONLINK(pcoi->pcii, FALSE, paLink->wType & XTYPF_NODATA,
                    pcoi->laService, pcoi->laTopic,
                    LocalToGlobalAtom(paLink->laItem),
                    paLink->wFmt, FALSE,
                    (HCONV)pcoi->hwndPartner, (HCONV)pcoi->hwndConv);
        } else {
            MONLINK(pcoi->pcii, FALSE, paLink->wType & XTYPF_NODATA,
                    pcoi->laService, pcoi->laTopic,
                    LocalToGlobalAtom(paLink->laItem),
                    paLink->wFmt, TRUE,
                    (HCONV)pcoi->hwndConv, (HCONV)pcoi->hwndPartner);
        }
        if (!(pcoi->state & ST_CLIENT)) {
            DeleteLinkCount(pcoi->pcii, paLink->pLinkCount);
        }
        DeleteAtom(paLink->laItem); // link structure copy
        paLink++;
        pcoi->cLinks--;
    }
    if (pcoi->aLinks) {
        DDEMLFree(pcoi->aLinks);
    }

    //
    // free atoms associated with this conv
    //
    DeleteAtom(pcoi->laService);
    DeleteAtom(pcoi->laTopic);
    if (pcoi->laServiceRequested) {
        DeleteAtom(pcoi->laServiceRequested);
    }

    UnlinkConvFromOthers(pcoi, FALSE);

    /*
     * invalidate app's conversation handle
     */
    DestroyHandle((HANDLE)pcoi->hConv);

    DDEMLFree(pcoi);
}



BOOL WaitForZombieTerminate(
HANDLE hData)
{
    PCONV_INFO pcoi;
    MSG msg;
    HWND hwnd;
    BOOL fTerminated;
    DWORD fRet = 0;

    CheckDDECritOut;
    EnterDDECrit;

    fTerminated = FALSE;
    while ((pcoi = (PCONV_INFO)ValidateCHandle(hData,
            HTYPE_ZOMBIE_CONVERSATION, InstFromHandle(hData))) != NULL &&
            !(pcoi->state & ST_TERMINATE_RECEIVED)) {
        hwnd = pcoi->hwndConv;
        LeaveDDECrit;
        while (PeekMessage(&msg, hwnd, WM_DDE_FIRST, WM_DDE_LAST, PM_REMOVE)) {
            DispatchMessage(&msg);
            if (msg.message == WM_DDE_TERMINATE) {
                fTerminated = TRUE;
            }
        }
        if (!fTerminated) {
            fRet = MsgWaitForMultipleObjectsEx(0, NULL, 100, QS_POSTMESSAGE, 0);
            if (fRet == 0xFFFFFFFF) {
                RIPMSG0(RIP_WARNING, "WaitForZombieTerminate: I give up - faking terminate.");
                ProcessTerminateMsg(pcoi, pcoi->hwndPartner);
                EnterDDECrit;
                return(FALSE);
            }
        }
        EnterDDECrit;
    }
    LeaveDDECrit;
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\combo.c ===
/**************************** Module Header ********************************\
* Module Name: combo.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* The WndProc for combo boxes and other often used combo routines
*
* History:
* ??-???-???? ??????    Ported from Win 3.0 sources
* 01-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

LOOKASIDE ComboboxLookaside;

BOOL NtUserTrackMouseEvent(TRACKMOUSEEVENT *ptme);
LONG xxxCBGetTextLengthHelper(PCBOX pcbox, BOOL fAnsi);
LONG xxxCBGetTextHelper(PCBOX pcbox, int len, LPWSTR lpstr, BOOL fAnsi);

/***************************************************************************\
*
*  PressButton()
*
*  Pops combobox button back up.
*
\***************************************************************************/
void xxxPressButton(PCBOX pcbox, BOOL fPress)
{
    //
    // Publisher relies on getting a WM_PAINT message after the combo list
    // pops back up.  On a WM_PAINT they change the focus, which causes
    // toolbar combos to send CBN_SELENDCANCEL notifications.  On this
    // notification they apply the font/pt size change you made to the
    // selection.
    //
    // This happened in 3.1 because the dropdown list overlapped the button
    // on the bottom or top by a pixel.  Since we'd end up painting under
    // the list SPB, when it went away USER would reinvalidate the dirty
    // area.  This would cause a paint message.
    //
    // In 4.0, this doesn't happen because the dropdown doesn't overlap.  So
    // we need to make sure Publisher gets a WM_PAINT anyway.  We do this
    // by changing where the dropdown shows up for 3.x apps
    //
    //

    if ((pcbox->fButtonPressed != 0) != (fPress != 0)) {

        HWND hwnd = HWq(pcbox->spwnd);

        pcbox->fButtonPressed = (fPress != 0);
        if (pcbox->f3DCombo)
            NtUserInvalidateRect(hwnd, KPRECT_TO_PRECT(&pcbox->buttonrc), TRUE);
        else
        {
            RECT    rc;

            CopyRect(&rc, KPRECT_TO_PRECT(&pcbox->buttonrc));
            InflateRect(&rc, 0, SYSMET(CYEDGE));
            NtUserInvalidateRect(hwnd, &rc, TRUE);
        }
        UpdateWindow(hwnd);

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
    }
}

/***************************************************************************\
* HotTrack
*
* If we're not already hot-tracking and the mouse is over the combobox,
* turn on hot-tracking and invalidate the drop-down button.
*
\***************************************************************************/

#ifdef COLOR_HOTTRACKING

void HotTrack(PCBOX pcbox)
{
    if (!pcbox->fButtonHotTracked && !pcbox->fMouseDown) {
        HWND hwnd = HWq(pcbox->spwnd);
        TRACKMOUSEEVENT tme = {sizeof(TRACKMOUSEEVENT), TME_LEAVE, hwnd, 0};
        if (NtUserTrackMouseEvent(&tme)) {
            pcbox->fButtonHotTracked = TRUE;
            NtUserInvalidateRect(hwnd, &pcbox->buttonrc, TRUE);
        }
    }
}

#endif // COLOR_HOTTRACKING

/***************************************************************************\
* xxxComboBoxDBCharHandler
*
* Double Byte character handler for ANSI ComboBox
*
* History:
\***************************************************************************/

LRESULT ComboBoxDBCharHandler(
    PCBOX pcbox,
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    WORD w;
    PWND pwndSend;

    w = DbcsCombine(hwnd, (BYTE)wParam);
    if (w == 0) {
        return CB_ERR;  // Failed to assemble DBCS
    }

    UserAssert(pcbox->spwndList);
    if (pcbox->fNoEdit) {
        pwndSend = pcbox->spwndList;
    } else if (pcbox->spwndEdit) {
        RIPMSG1(RIP_WARNING, "ComboBoxWndProcWorker: WM_CHAR is posted to Combobox itself(%08x).",
                hwnd);
        pwndSend = pcbox->spwndEdit;
    } else {
        return CB_ERR;
    }

    RIPMSG1(RIP_VERBOSE, "ComboBoxWndProcWorker: sending WM_CHAR %04x", w);

    if (!TestWF(pwndSend, WFANSIPROC)) {
        //
        // If receiver is not ANSI WndProc (may be subclassed?),
        // send a UNICODE message.
        //
        WCHAR wChar;
        LPWSTR lpwstr = &wChar;

        if (MBToWCSEx(THREAD_CODEPAGE(), (LPCSTR)&w, 2, &lpwstr, 1, FALSE) == 0) {
            RIPMSG1(RIP_WARNING, "ComboBoxWndProcWorker: cannot convert 0x%04x to UNICODE.", w);
            return CB_ERR;
        }
        return SendMessageWorker(pwndSend, message, wChar, lParam, FALSE);
    }

    /*
     * Post the Trailing byte to the target
     * so that they can peek the second WM_CHAR
     * message later.
     * Note: it's safe since sender is A and receiver is A,
     * translation layer does not perform any DBCS combining and cracking.
     */
    PostMessageA(HWq(pwndSend), message, CrackCombinedDbcsTB(w), lParam);
    return SendMessageWorker(pwndSend, message, wParam, lParam, TRUE);
}

BOOL ComboBoxMsgOKInInit(UINT message, LRESULT* plRet)
{
    switch (message) {
    default:
        break;
    case WM_SIZE:
        *plRet = 0;
        return FALSE;
    case WM_STYLECHANGED:
    case WM_GETTEXT:
    case WM_GETTEXTLENGTH:
    case WM_PRINT:
    case WM_COMMAND:
    case CBEC_KILLCOMBOFOCUS:
    case WM_PRINTCLIENT:
    case WM_SETFONT:
    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_MOUSEWHEEL:
    case WM_CAPTURECHANGED:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
    case WM_SETFOCUS:
    case WM_KILLFOCUS:
    case WM_SETREDRAW:
    case WM_ENABLE:
    case CB_SETDROPPEDWIDTH:
    case CB_DIR:
    case CB_ADDSTRING:
        /*
         * Cannot handle those messages yet. Bail out.
         */
        *plRet = CB_ERR;
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* xxxComboBoxCtlWndProc
*
* Class procedure for all combo boxes
*
* History:
\***************************************************************************/

LRESULT APIENTRY ComboBoxWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    PCBOX pcbox;
    POINT pt;
    TL tlpwndEdit;
    TL tlpwndList;
    PAINTSTRUCT ps;
    LPWSTR lpwsz = NULL;
    LRESULT lReturn;
    static BOOL fInit = TRUE;
    int  i;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, FNID_COMBOBOX);
    INITCONTROLLOOKASIDE(&ComboboxLookaside, CBOX, spwnd, 8);

    /*
     * Get the pcbox for the given window now since we will use it a lot in
     * various handlers.  This is stored by NtUserSetWindowLongPtr() in the
     * INITCONTROLLOOKASIDE macro above.
     */
    pcbox = ((PCOMBOWND)pwnd)->pcbox;

    /*
     * Protect the combobox during the initialization.
     */
    if (pcbox->spwndList == NULL) {
        LRESULT lRet;

        if (!ComboBoxMsgOKInInit(message, &lRet)) {
            RIPMSG2(RIP_WARNING, "ComboBoxWndProcWorker: msg=%04x is sent to hwnd=%08x in the middle of initialization.",
                    message, hwnd);
            return lRet;
        }
    }

    /*
     * Dispatch the various messages we can receive
     */
    switch (message) {
    case CBEC_KILLCOMBOFOCUS:

        /*
         * Private message coming from editcontrol informing us that the combo
         * box is losing the focus to a window which isn't in this combo box.
         */
        xxxCBKillFocusHelper(pcbox);
        break;

    case WM_COMMAND:

        /*
         * So that we can handle notification messages from the listbox and
         * edit control.
         */
        return xxxCBCommandHandler(pcbox, (DWORD)wParam, (HWND)lParam);

    case WM_STYLECHANGED:
        UserAssert(pcbox->spwndList != NULL);
        {
            LONG OldStyle;
            LONG NewStyle = 0;

            pcbox->fRtoLReading = (TestWF(pwnd, WEFRTLREADING) != 0);
            pcbox->fRightAlign  = (TestWF(pwnd, WEFRIGHT) != 0);
            if (pcbox->fRtoLReading)
                NewStyle |= (WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);
            if (pcbox->fRightAlign)
                NewStyle |= WS_EX_RIGHT;

            ThreadLock(pcbox->spwndList, &tlpwndList);
            OldStyle = GetWindowLong(HWq(pcbox->spwndList), GWL_EXSTYLE) & ~(WS_EX_RIGHT|WS_EX_RTLREADING|WS_EX_LEFTSCROLLBAR);
            SetWindowLong(HWq(pcbox->spwndList), GWL_EXSTYLE, OldStyle|NewStyle);
            ThreadUnlock(&tlpwndList);

            if (!pcbox->fNoEdit && pcbox->spwndEdit) {
                ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
                OldStyle = GetWindowLong(HWq(pcbox->spwndEdit), GWL_EXSTYLE) & ~(WS_EX_RIGHT|WS_EX_RTLREADING|WS_EX_LEFTSCROLLBAR);
                SetWindowLong(HWq(pcbox->spwndEdit), GWL_EXSTYLE, OldStyle|NewStyle);
                ThreadUnlock(&tlpwndEdit);
            }
            xxxCBPosition(pcbox);
            NtUserInvalidateRect(hwnd, NULL, FALSE);
        }
        break;

    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOR:
        //
        // Causes compatibility problems for 3.X apps.  Forward only
        // for 4.0
        //
        if (TestWF(pwnd, WFWIN40COMPAT)) {
            TL tlpwndParent;
            LRESULT ret;
            PWND pwndParent;

            pwndParent = REBASEPWND(pwnd, spwndParent);
            ThreadLock(pwndParent, &tlpwndParent);
            ret = SendMessage(HW(pwndParent), message, wParam, lParam);
            ThreadUnlock(tlpwndParent);
            return ret;
        } else
            return(DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi));
        break;

    case WM_GETTEXT:
        if (pcbox->fNoEdit) {
            return xxxCBGetTextHelper(pcbox, (int)wParam, (LPWSTR)lParam, fAnsi);
        }
        goto CallEditSendMessage;
        break;

    case WM_GETTEXTLENGTH:

        /*
         * If the is not edit control, CBS_DROPDOWNLIST, then we have to
         * ask the list box for the size
         */

        if (pcbox->fNoEdit) {
            return xxxCBGetTextLengthHelper(pcbox, fAnsi);
        }

        // FALL THROUGH

    case WM_CLEAR:
    case WM_CUT:
    case WM_PASTE:
    case WM_COPY:
    case WM_SETTEXT:
        goto CallEditSendMessage;
        break;

    case WM_CREATE:

        /*
         * wParam - not used
         * lParam - Points to the CREATESTRUCT data structure for the window.
         */
        return xxxCBCreateHandler(pcbox, pwnd);

    case WM_ERASEBKGND:

        /*
         * Just return 1L so that the background isn't erased
         */
        return 1L;

    case WM_GETFONT:
        return (LRESULT)pcbox->hFont;

    case WM_PRINT:
        if (!DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi))
            return(FALSE);

        if ((lParam & PRF_OWNED) && (pcbox->CBoxStyle & SDROPPABLE) &&
            TestWF(pcbox->spwndList, WFVISIBLE)) {
            TL tpwndList;
            int iDC = SaveDC((HDC) wParam);
            OffsetWindowOrgEx((HDC) wParam, 0, pwnd->rcWindow.top - pcbox->spwndList->rcWindow.top, NULL);
            lParam &= ~PRF_CHECKVISIBLE;
            ThreadLock(pcbox->spwndList, &tpwndList);
            SendMessageWorker(pcbox->spwndList, WM_PRINT, wParam, lParam, FALSE);
            RestoreDC((HDC) wParam, iDC);
        }
        return TRUE;

    case WM_PRINTCLIENT:
        xxxCBPaint(pcbox, (HDC) wParam);
        break;

    case WM_PAINT: {
        HDC hdc;

        /*
         * wParam - perhaps a hdc
         */
        hdc = (wParam) ? (HDC) wParam : NtUserBeginPaint(hwnd, &ps);

        if (IsComboVisible(pcbox))
            xxxCBPaint(pcbox, hdc);

        if (!wParam)
            NtUserEndPaint(hwnd, &ps);
        break;
    }
    case WM_GETDLGCODE:

        /*
         * wParam - not used
         * lParam - not used
         */
        {
            LRESULT code = DLGC_WANTCHARS | DLGC_WANTARROWS;

            // If the listbox is dropped and the ENTER key is pressed,
            // we want this message so we can close up the listbox
            if ((lParam != 0) &&
                (((LPMSG)lParam)->message == WM_KEYDOWN) &&
                pcbox->fLBoxVisible &&
                ((wParam == VK_RETURN) || (wParam == VK_ESCAPE)))
            {
                code |= DLGC_WANTMESSAGE;
            }
            return code;
        }
        /*
         * No fall through
         */

    case WM_SETFONT:
        xxxCBSetFontHandler(pcbox, (HANDLE)wParam, LOWORD(lParam));
        break;

    case WM_SYSKEYDOWN:
        if (lParam & 0x20000000L)  /* Check if the alt key is down */ {

            /*
             * Handle Combobox support.  We want alt up or down arrow to behave
             * like F4 key which completes the combo box selection
             */
            if (lParam & 0x1000000) {

                /*
                 * This is an extended key such as the arrow keys not on the
                 * numeric keypad so just drop the combobox.
                 */
                if (wParam == VK_DOWN || wParam == VK_UP)
                    goto DropCombo;

                goto CallDWP;
            }

            if (GetKeyState(VK_NUMLOCK) & 0x1) {
                /*
                 * If numlock down, just send all system keys to dwp
                 */
                goto CallDWP;
            } else {

                /*
                 * We just want to ignore keys on the number pad...
                 */
                if (!(wParam == VK_DOWN || wParam == VK_UP))
                    goto CallDWP;
            }
DropCombo:
            if (!pcbox->fLBoxVisible) {

                /*
                 * If the listbox isn't visible, just show it
                 */
                xxxCBShowListBoxWindow(pcbox, TRUE);
            } else {

                /*
                 * Ok, the listbox is visible.  So hide the listbox window.
                 */
                if (!xxxCBHideListBoxWindow(pcbox, TRUE, TRUE))
                    return(0L);
            }
        }
        goto CallDWP;
        break;

    case WM_KEYDOWN:
        /*
         * If the listbox is dropped and the ENTER key is pressed,
         * close up the listbox successfully.  If ESCAPE is pressed,
         * close it up like cancel.
         */
        if (pcbox->fLBoxVisible) {
            if ((wParam == VK_RETURN) || (wParam == VK_ESCAPE)) {
                xxxCBHideListBoxWindow(pcbox, TRUE, (wParam != VK_ESCAPE));
                break;
            }
        }
        // FALL THROUGH

    case WM_CHAR:
        if (fAnsi && IS_DBCS_ENABLED() && IsDBCSLeadByteEx(THREAD_CODEPAGE(), (BYTE)wParam)) {
            return ComboBoxDBCharHandler(pcbox, hwnd, message, wParam, lParam);
        }

        if (pcbox->fNoEdit) {
            goto CallListSendMessage;
        }
        else
            goto CallEditSendMessage;
        break;

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:

#ifdef COLOR_HOTTRACKING
        pcbox->fButtonHotTracked = FALSE;
#endif // COLOR_HOTTRACKING

        /*
         * Set the focus to the combo box if we get a mouse click on it.
         */
        if (!pcbox->fFocus) {
            NtUserSetFocus(hwnd);
            if (!pcbox->fFocus) {

                /*
                 * Don't do anything if we still don't have the focus.
                 */
                break;
            }
        }

        /*
         * If user clicked in button rect and we are a combobox with edit, then
         * drop the listbox.  (The button rect is 0 if there is no button so the
         * ptinrect will return false.) If a drop down list (no edit), clicking
         * anywhere on the face causes the list to drop.
         */

        POINTSTOPOINT(pt, lParam);
        if ((pcbox->CBoxStyle == SDROPDOWN &&
                PtInRect(KPRECT_TO_PRECT(&pcbox->buttonrc), pt)) ||
                pcbox->CBoxStyle == SDROPDOWNLIST) {

            /*
             * Set the fMouseDown flag so that we can handle clicking on
             * the popdown button and dragging into the listbox (when it just
             * dropped down) to make a selection.
             */
            pcbox->fButtonPressed = TRUE;
            if (pcbox->fLBoxVisible) {
                if (pcbox->fMouseDown) {
                    pcbox->fMouseDown = FALSE;
                    NtUserReleaseCapture();
                }
                xxxPressButton(pcbox, FALSE);

                if (!xxxCBHideListBoxWindow(pcbox, TRUE, TRUE))
                    return(0L);
            } else {
                xxxCBShowListBoxWindow(pcbox, FALSE);

                // Setting and resetting this flag must always be followed
                // imediately by SetCapture or ReleaseCapture
                //
                pcbox->fMouseDown = TRUE;
                NtUserSetCapture(hwnd);
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
            }
        }
        break;

    case WM_MOUSEWHEEL:
        /*
         * Handle only scrolling.
         */
        if (wParam & (MK_CONTROL | MK_SHIFT))
            goto CallDWP;

        /*
         * If the listbox is visible, send it the message to scroll.
         */
        if (pcbox->fLBoxVisible)
            goto CallListSendMessage;

        /*
         * If we're in extended UI mode or the edit control isn't yet created,
         * bail.
         */
        if (pcbox->fExtendedUI || pcbox->spwndEdit == NULL)
            return TRUE;

        /*
         * Emulate arrow up/down messages to the edit control.
         */
        i = abs(((short)HIWORD(wParam))/WHEEL_DELTA);
        wParam = ((short)HIWORD(wParam) > 0) ? VK_UP : VK_DOWN;

        ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
        while (i-- > 0) {
            SendMessageWorker(
                    pcbox->spwndEdit, WM_KEYDOWN, wParam, 0, fAnsi);
        }
        ThreadUnlock(&tlpwndEdit);
        return TRUE;

    case WM_CAPTURECHANGED:
        if (!(TestWF(pwnd, WFWIN40COMPAT)))
            return 0;

        if ((pcbox->fMouseDown)) {
            pcbox->fMouseDown = FALSE;
            xxxPressButton(pcbox, FALSE);

            //
            // Pop combo listbox back up, canceling.
            //
            if (pcbox->fLBoxVisible)
                xxxCBHideListBoxWindow(pcbox, TRUE, FALSE);
        }
        break;

    case WM_LBUTTONUP:
        xxxPressButton(pcbox, FALSE);

        /*
         * Clear this flag so that mouse moves aren't sent to the listbox
         */
        if (pcbox->fMouseDown) {
            pcbox->fMouseDown = FALSE;

            if (pcbox->CBoxStyle == SDROPDOWN) {
                // If an item in the listbox matches the text in the edit
                // control, scroll it to the top of the listbox. Select the
                // item only if the mouse button isn't down otherwise we
                // will select the item when the mouse button goes up.
                xxxCBUpdateListBoxWindow(pcbox, TRUE);
                xxxCBCompleteEditWindow(pcbox);
            }
            NtUserReleaseCapture();

            // Now, we want listbox to track mouse moves while mouse up
            // until mouse down, and select items as though they were
            // clicked on.
            if (TestWF(pwnd, WFWIN40COMPAT)) {

                ThreadLock(pcbox->spwndList, &tlpwndList);
                SendMessageWorker(pcbox->spwndList, LBCB_STARTTRACK, FALSE, 0, FALSE);
                ThreadUnlock(&tlpwndList);
            }
        }
#ifdef COLOR_HOTTRACKING
        HotTrack(pcbox);
        break;

    case WM_MOUSELEAVE:
        pcbox->fButtonHotTracked = FALSE;
        NtUserInvalidateRect(hwnd, &pcbox->buttonrc, TRUE);
#endif // COLOR_HOTTRACKING
        break;

    case WM_MOUSEMOVE:
        if (pcbox->fMouseDown) {
            POINTSTOPOINT(pt, lParam);

            // Note conversion of INT bit field to BOOL (1 or 0)

            if (PtInRect(KPRECT_TO_PRECT(&pcbox->buttonrc), pt) != !!pcbox->fButtonPressed) {
                xxxPressButton(pcbox, (pcbox->fButtonPressed == 0));
            }

            _ClientToScreen(pwnd, &pt);
            if (PtInRect(KPRECT_TO_PRECT(&pcbox->spwndList->rcClient), pt)) {

                /*
                 * This handles dropdown comboboxes/listboxes so that clicking
                 * on the dropdown button and dragging into the listbox window
                 * will let the user make a listbox selection.
                 */
                pcbox->fMouseDown = FALSE;
                NtUserReleaseCapture();

                if (pcbox->CBoxStyle & SEDITABLE) {

                    /*
                     * If an item in the listbox matches the text in the edit
                     * control, scroll it to the top of the listbox.  Select the
                     * item only if the mouse button isn't down otherwise we
                     * will select the item when the mouse button goes up.
                     */

                    /*
                     * We need to select the item which matches the editcontrol
                     * so that if the user drags out of the listbox, we don't
                     * cancel back to his origonal selection
                     */
                    xxxCBUpdateListBoxWindow(pcbox, TRUE);
                }

                /*
                 * Convert point to listbox coordinates and send a buttondown
                 * message to the listbox window.
                 */
                _ScreenToClient(pcbox->spwndList, &pt);
                lParam = POINTTOPOINTS(pt);
                message = WM_LBUTTONDOWN;
                goto CallListSendMessage;
            }
        }
#ifdef COLOR_HOTTRACKING
        HotTrack(pcbox);
#endif // COLOR_HOTTRACKING
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        xxxCBNcDestroyHandler(pwnd, pcbox);
        break;

    case WM_SETFOCUS:
        if (pcbox->fNoEdit) {

            /*
             * There is no editcontrol so set the focus to the combo box itself.
             */
            xxxCBGetFocusHelper(pcbox);
        } else if (pcbox->spwndEdit) {
            /*
             * Set the focus to the edit control window if there is one
             */
            ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
            NtUserSetFocus(HWq(pcbox->spwndEdit));
            ThreadUnlock(&tlpwndEdit);
        }
        break;

    case WM_KILLFOCUS:

        /*
         * wParam has the new focus hwnd
         */
        if (wParam != 0)
            wParam = (WPARAM)ValidateHwnd((HWND)wParam);
        if ((wParam == 0) || !_IsChild(pwnd, (PWND)wParam)) {

            /*
             * We only give up the focus if the new window getting the focus
             * doesn't belong to the combo box.
             */
            xxxCBKillFocusHelper(pcbox);
        }

        UserAssert(pcbox->spwndList);
        {
            PLBIV plb = ((PLBWND)pcbox->spwndList)->pLBIV;

            if ((plb != NULL) && (plb != (PLBIV)-1)) {
                plb->iTypeSearch = 0;
                if (plb->pszTypeSearch) {
                    UserLocalFree(plb->pszTypeSearch);
                    plb->pszTypeSearch = NULL;
                }
            }
        }
        break;

    case WM_SETREDRAW:

        /*
         * wParam - specifies state of the redraw flag.  nonzero = redraw
         * lParam - not used
         */

        /*
         * effects: Sets the state of the redraw flag for this combo box
         * and its children.
         */
        pcbox->fNoRedraw = (UINT)!((BOOL)wParam);

        /*
         * Must check pcbox->spwnEdit in case we get this message before
         * WM_CREATE - PCBOX won't be initialized yet. (Eudora does this)
         */
        if (!pcbox->fNoEdit && pcbox->spwndEdit) {
            ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
            SendMessageWorker(pcbox->spwndEdit, message, wParam, lParam, FALSE);
            ThreadUnlock(&tlpwndEdit);
        }
        goto CallListSendMessage;
        break;

    case WM_ENABLE:

        /*
         * Invalidate the rect to cause it to be drawn in grey for its
         * disabled view or ungreyed for non-disabled view.
         */
        NtUserInvalidateRect(hwnd, NULL, FALSE);
        if ((pcbox->CBoxStyle & SEDITABLE) && pcbox->spwndEdit) {

            /*
             * Enable/disable the edit control window
             */
            ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
            NtUserEnableWindow(HWq(pcbox->spwndEdit), (TestWF(pwnd, WFDISABLED) == 0));
            ThreadUnlock(&tlpwndEdit);
        }

        /*
         * Enable/disable the listbox window
         */
        UserAssert(pcbox->spwndList);
        ThreadLock(pcbox->spwndList, &tlpwndList);
        NtUserEnableWindow(HWq(pcbox->spwndList), (TestWF(pwnd, WFDISABLED) == 0));
        ThreadUnlock(&tlpwndList);
      break;

    case WM_SIZE:

        /*
         * wParam - defines the type of resizing fullscreen, sizeiconic,
         *          sizenormal etc.
         * lParam - new width in LOWORD, new height in HIGHUINT of client area
         */
        UserAssert(pcbox->spwndList);
        if (LOWORD(lParam) == 0 || HIWORD(lParam) == 0) {

            /*
             * If being sized to a zero width or to a zero height or we aren't
             * fully initialized, just return.
             */
            return 0;
        }

        // OPTIMIZATIONS -- first check if old and new widths are the same
        if (pcbox->cxCombo == pwnd->rcWindow.right - pwnd->rcWindow.left) {
            int iNewHeight = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

            // now check if new height is the dropped down height
            if (pcbox->fLBoxVisible) {
                // Check if new height is the full size height
                if (pcbox->cyDrop + pcbox->cyCombo == iNewHeight)
                    return(0L);
            } else {
                // Check if new height is the closed up height
                if (pcbox->cyCombo == iNewHeight)
                    return(0L);
            }
        }

        xxxCBSizeHandler(pcbox);
        break;

    case CB_GETDROPPEDSTATE:

        /*
         * returns 1 if combo is dropped down else 0
         * wParam - not used
         * lParam - not used
         */
        return pcbox->fLBoxVisible;

    case CB_GETDROPPEDCONTROLRECT:

        /*
         * wParam - not used
         * lParam - lpRect which will get the dropped down window rect in
         *          screen coordinates.
         */
        ((LPRECT)lParam)->left      = pwnd->rcWindow.left;
        ((LPRECT)lParam)->top       = pwnd->rcWindow.top;
        ((LPRECT)lParam)->right     = pwnd->rcWindow.left + max(pcbox->cxDrop, pcbox->cxCombo);
        ((LPRECT)lParam)->bottom    = pwnd->rcWindow.top + pcbox->cyCombo + pcbox->cyDrop;
        break;

    case CB_SETDROPPEDWIDTH:
        if (pcbox->CBoxStyle & SDROPPABLE) {
            if (wParam) {
                wParam = max(wParam, (UINT)pcbox->cxCombo);

                if (wParam != (UINT) pcbox->cxDrop)
                {
                    pcbox->cxDrop = (int)wParam;
                    xxxCBPosition(pcbox);
                }
            }
        }
        // fall thru

    case CB_GETDROPPEDWIDTH:
        if (pcbox->CBoxStyle & SDROPPABLE)
            return((LRESULT) max(pcbox->cxDrop, pcbox->cxCombo));
        else
            return(CB_ERR);
        break;

    case CB_DIR:
        /*
         * wParam - Dos attribute value.
         * lParam - Points to a file specification string
         */
        if (fAnsi && lParam != 0) {
            if (MBToWCS((LPSTR)lParam, -1, &lpwsz, -1, TRUE) == 0)
                return CB_ERR;
            lParam = (LPARAM)lpwsz;
        }
        lReturn = xxxCBDir(pcbox, LOWORD(wParam), (LPWSTR)lParam);
        if (fAnsi && lParam != 0) {
            UserLocalFree(lpwsz);
        }
        return lReturn;

    case CB_SETEXTENDEDUI:

        /*
         * wParam - specifies state to set extendui flag to.
         * Currently only 1 is allowed.  Return CB_ERR (-1) if
         * failure else 0 if success.
         */
        if (pcbox->CBoxStyle & SDROPPABLE) {
            if (!wParam) {
                pcbox->fExtendedUI = 0;
                return 0;
            }

            if (wParam == 1) {
              pcbox->fExtendedUI = 1;
              return 0;
            }

            RIPERR1(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "Invalid parameter \"wParam\" (%ld) to ComboBoxWndProcWorker",
                    wParam);

        } else {
            RIPERR1(ERROR_INVALID_MESSAGE,
                    RIP_WARNING,
                    "Invalid message (%ld) sent to ComboBoxWndProcWorker",
                    message);
        }

        return CB_ERR;

    case CB_GETEXTENDEDUI:
        if (pcbox->CBoxStyle & SDROPPABLE) {
            if (pcbox->fExtendedUI)
                return TRUE;
        }
        return FALSE;

    case CB_GETEDITSEL:

        /*
         * wParam - not used
         * lParam - not used
         * effects: Gets the selection range for the given edit control.  The
         * starting BYTE-position is in the low order word.  It contains the
         * the BYTE-position of the first nonselected character after the end
         * of the selection in the high order word.  Returns CB_ERR if no
         * editcontrol.
         */
        message = EM_GETSEL;
        goto CallEditSendMessage;
        break;

    case CB_LIMITTEXT:

        /*
         * wParam - max number of bytes that can be entered
         * lParam - not used
         * effects: Specifies the maximum number of bytes of text the user may
         * enter.  If maxLength is 0, we may enter MAXINT number of BYTES.
         */
        message = EM_LIMITTEXT;
        goto CallEditSendMessage;
        break;

    case CB_SETEDITSEL:

        /*
         * wParam - ichStart
         * lParam - ichEnd
         *
         */
        message = EM_SETSEL;

        wParam = (int)(SHORT)LOWORD(lParam);
        lParam = (int)(SHORT)HIWORD(lParam);
        goto CallEditSendMessage;
        break;

    case CB_ADDSTRING:

        /*
         * wParam - not used
         * lParam - Points to null terminated string to be added to listbox
         */
        if (!pcbox->fCase)
            message = LB_ADDSTRING;
        else
            message = (pcbox->fCase & UPPERCASE) ? LB_ADDSTRINGUPPER : LB_ADDSTRINGLOWER;
        goto CallListSendMessage;
        break;

    case CB_DELETESTRING:

        /*
         * wParam - index to string to be deleted
         * lParam - not used
         */
        message = LB_DELETESTRING;
        goto CallListSendMessage;
        break;

    case CB_INITSTORAGE:
        // wParamLo - number of items
        // lParam - number of bytes of string space
        message = LB_INITSTORAGE;
        goto CallListSendMessage;

    case CB_SETTOPINDEX:
        // wParamLo - index to make top
        // lParam - not used
        message = LB_SETTOPINDEX;
        goto CallListSendMessage;

    case CB_GETTOPINDEX:
        // wParamLo / lParam - not used
        message = LB_GETTOPINDEX;
        goto CallListSendMessage;

    case CB_GETCOUNT:

        /*
         * wParam - not used
         * lParam - not used
         */
        message = LB_GETCOUNT;
        goto CallListSendMessage;
        break;

    case CB_GETCURSEL:

        /*
         * wParam - not used
         * lParam - not used
         */
        message = LB_GETCURSEL;
        goto CallListSendMessage;
        break;

    case CB_GETLBTEXT:

        /*
         * wParam - index of string to be copied
         * lParam - buffer that is to receive the string
         */
        message = LB_GETTEXT;
        goto CallListSendMessage;
        break;

    case CB_GETLBTEXTLEN:

        /*
         * wParam - index to string
         * lParam - now used for cbANSI
         */
        message = LB_GETTEXTLEN;
        goto CallListSendMessage;
        break;

    case CB_INSERTSTRING:

        /*
         * wParam - position to receive the string
         * lParam - points to the string
         */
        if (!pcbox->fCase)
            message = LB_INSERTSTRING;
        else
            message = (pcbox->fCase & UPPERCASE) ? LB_INSERTSTRINGUPPER : LB_INSERTSTRINGLOWER;
        goto CallListSendMessage;
        break;

    case CB_RESETCONTENT:

        /*
         * wParam - not used
         * lParam - not used
         * If we come here before WM_CREATE has been processed,
         * pcbox->spwndList will be NULL.
         */
        UserAssert(pcbox->spwndList);
        ThreadLock(pcbox->spwndList, &tlpwndList);
        SendMessageWorker(pcbox->spwndList, LB_RESETCONTENT, 0, 0, FALSE);
        ThreadUnlock(&tlpwndList);
        xxxCBInternalUpdateEditWindow(pcbox, NULL);
        break;

    case CB_GETHORIZONTALEXTENT:
        message = LB_GETHORIZONTALEXTENT;
        goto CallListSendMessage;

    case CB_SETHORIZONTALEXTENT:
        message = LB_SETHORIZONTALEXTENT;
        goto CallListSendMessage;

    case CB_FINDSTRING:

        /*
         * wParam - index of starting point for search
         * lParam - points to prefix string
         */
        message = LB_FINDSTRING;
        goto CallListSendMessage;
        break;

    case CB_FINDSTRINGEXACT:

        /*
         * wParam - index of starting point for search
         * lParam - points to a exact string
         */
        message = LB_FINDSTRINGEXACT;
        goto CallListSendMessage;
        break;

    case CB_SELECTSTRING:

        /*
         * wParam - index of starting point for search
         * lParam - points to prefix string
         */
        UserAssert(pcbox->spwndList);
        ThreadLock(pcbox->spwndList, &tlpwndList);
        lParam = SendMessageWorker(pcbox->spwndList, LB_SELECTSTRING,
                wParam, lParam, fAnsi);
        ThreadUnlock(&tlpwndList);
        xxxCBInternalUpdateEditWindow(pcbox, NULL);
        return lParam;

    case CB_SETCURSEL:

        /*
         * wParam - Contains index to be selected
         * lParam - not used
         * If we come here before WM_CREATE has been processed,
         * pcbox->spwndList will be NULL.
         */

        UserAssert(pcbox->spwndList);

        ThreadLock(pcbox->spwndList, &tlpwndList);
        lParam = SendMessageWorker(pcbox->spwndList, LB_SETCURSEL, wParam, lParam, FALSE);
        if (lParam != -1) {
            SendMessageWorker(pcbox->spwndList, LB_SETTOPINDEX, wParam, 0, FALSE);
        }
        ThreadUnlock(&tlpwndList);
        xxxCBInternalUpdateEditWindow(pcbox, NULL);
        return lParam;

    case CB_GETITEMDATA:
        message = LB_GETITEMDATA;
        goto CallListSendMessage;
        break;

    case CB_SETITEMDATA:
        message = LB_SETITEMDATA;
        goto CallListSendMessage;
        break;

    case CB_SETITEMHEIGHT:
        if (wParam == -1) {
            if (HIWORD(lParam) != 0)
                return CB_ERR;
            return xxxCBSetEditItemHeight(pcbox, LOWORD(lParam));
        }

        message = LB_SETITEMHEIGHT;
        goto CallListSendMessage;
        break;

    case CB_GETITEMHEIGHT:
        if (wParam == -1)
            return pcbox->editrc.bottom - pcbox->editrc.top;

        message = LB_GETITEMHEIGHT;
        goto CallListSendMessage;
        break;

    case CB_SHOWDROPDOWN:

        /*
         * wParam - True then drop down the listbox if possible else hide it
         * lParam - not used
         */
        if (wParam && !pcbox->fLBoxVisible) {
            xxxCBShowListBoxWindow(pcbox, TRUE);
        } else {
            if (!wParam && pcbox->fLBoxVisible) {
                xxxCBHideListBoxWindow(pcbox, TRUE, FALSE);
            }
        }
        break;

    case CB_SETLOCALE:

        /*
         * wParam - locale id
         * lParam - not used
         */
        message = LB_SETLOCALE;
        goto CallListSendMessage;
        break;

    case CB_GETLOCALE:

        /*
         * wParam - not used
         * lParam - not used
         */
        message = LB_GETLOCALE;
        goto CallListSendMessage;
        break;

    case CB_GETCOMBOBOXINFO:
        return NtUserGetComboBoxInfo(hwnd, (PCOMBOBOXINFO)lParam);

    case WM_MEASUREITEM:
    case WM_DELETEITEM:
    case WM_DRAWITEM:
    case WM_COMPAREITEM:
        return xxxCBMessageItemHandler(pcbox, message, (LPVOID)lParam);

    case WM_NCCREATE:

        /*
         * wParam - Contains a handle to the window being created
         * lParam - Points to the CREATESTRUCT data structure for the window.
         */
        return CBNcCreateHandler(pcbox, pwnd);

    case WM_PARENTNOTIFY:
        if (LOWORD(wParam) == WM_DESTROY) {
            if ((HWND)lParam == HW(pcbox->spwndEdit)) {
                pcbox->CBoxStyle &= ~SEDITABLE;
                pcbox->fNoEdit = TRUE;
                pcbox->spwndEdit = pwnd;
            } else if ((HWND)lParam == HW(pcbox->spwndList)) {
                pcbox->CBoxStyle &= ~SDROPPABLE;
                pcbox->spwndList = NULL;
            }
        }
        break;

    case WM_UPDATEUISTATE:
        /*
         * Propagate the change to the list control, if any
         */
        UserAssert(pcbox->spwndList);
        ThreadLock(pcbox->spwndList, &tlpwndList);
        SendMessageWorker(pcbox->spwndList, WM_UPDATEUISTATE,
                          wParam, lParam, fAnsi);
        ThreadUnlock(&tlpwndList);
        goto CallDWP;

    case WM_HELP:
        {
            LPHELPINFO lpHelpInfo;

            /*
             * Check if this message is from a child of this combo
             */
            if ((lpHelpInfo = (LPHELPINFO)lParam) != NULL &&
                ((pcbox->spwndEdit && lpHelpInfo->iCtrlId == (SHORT)(PTR_TO_ID(pcbox->spwndEdit->spmenu))) ||
                 lpHelpInfo->iCtrlId == (SHORT)(PTR_TO_ID(pcbox->spwndList->spmenu)) )) {

                /*
                 * Make it look like the WM_HELP is coming form this combo.
                 * Then DefWindowProcWorker will pass it up to our parent,
                 * who can do whatever he wants with it.
                 */
                lpHelpInfo->iCtrlId = (SHORT)(PTR_TO_ID(pwnd->spmenu));
                lpHelpInfo->hItemHandle = hwnd;
                lpHelpInfo->dwContextId = GetContextHelpId(pwnd);
            }
        }
        /*
         * Fall through to DefWindowProc
         */

    default:

        if (SYSMET(PENWINDOWS) &&
                (message >= WM_PENWINFIRST && message <= WM_PENWINLAST))
            goto CallEditSendMessage;

CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }  /* switch (message) */

    return TRUE;

/*
 * The following forward messages off to the child controls.
 */
CallEditSendMessage:
    if (!pcbox->fNoEdit && pcbox->spwndEdit) {
        /*
         * pcbox->spwndEdit will be NULL if we haven't done WM_CREATE yet!
         */
        ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
        lReturn = SendMessageWorker(pcbox->spwndEdit, message,
                wParam, lParam, fAnsi);
        ThreadUnlock(&tlpwndEdit);
    }
    else {
        RIPERR0(ERROR_INVALID_COMBOBOX_MESSAGE, RIP_VERBOSE, "");
        lReturn = CB_ERR;
    }
    return lReturn;

CallListSendMessage:
    /*
     * pcbox->spwndList will be NULL if we haven't done WM_CREATE yet!
     */
    UserAssert(pcbox->spwndList);
    ThreadLock(pcbox->spwndList, &tlpwndList);
    lReturn = SendMessageWorker(pcbox->spwndList, message,
            wParam, lParam, fAnsi);
    ThreadUnlock(&tlpwndList);
    return lReturn;

}  /* ComboBoxWndProcWorker */


/***************************************************************************\
\***************************************************************************/

LRESULT WINAPI ComboBoxWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_COMBOBOX) &&
            !(SYSMET(PENWINDOWS) &&
                    (message >= WM_PENWINFIRST && message <= WM_PENWINLAST)))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, TRUE);

    return ComboBoxWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI ComboBoxWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_COMBOBOX) &&
            !(SYSMET(PENWINDOWS) &&
                    (message >= WM_PENWINFIRST && message <= WM_PENWINLAST)))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, FALSE);

    return ComboBoxWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}


/***************************************************************************\
* xxxCBMessageItemHandler
*
* Handles WM_DRAWITEM,WM_MEASUREITEM,WM_DELETEITEM,WM_COMPAREITEM
* messages from the listbox.
*
* History:
\***************************************************************************/

LRESULT xxxCBMessageItemHandler(
    PCBOX pcbox,
    UINT message,
    LPVOID lpfoo)  /* Actually can be any of the structs below */
{
    LRESULT lRet;
    TL tlpwndParent;

    CheckLock(pcbox->spwnd);

    /*
     * Send the <foo>item message back to the application after changing some
     * parameters to their combo box specific versions.
     */
    ((LPMEASUREITEMSTRUCT)lpfoo)->CtlType = ODT_COMBOBOX;
    ((LPMEASUREITEMSTRUCT)lpfoo)->CtlID = PtrToUlong(pcbox->spwnd->spmenu);
    if (message == WM_DRAWITEM)
        ((LPDRAWITEMSTRUCT)lpfoo)->hwndItem = HWq(pcbox->spwnd);
    else if (message == WM_DELETEITEM)
        ((LPDELETEITEMSTRUCT)lpfoo)->hwndItem = HWq(pcbox->spwnd);
    else if (message == WM_COMPAREITEM)
        ((LPCOMPAREITEMSTRUCT)lpfoo)->hwndItem = HWq(pcbox->spwnd);

    ThreadLock(pcbox->spwndParent, &tlpwndParent);
    lRet = SendMessage(HW(pcbox->spwndParent), message,
            (WPARAM)pcbox->spwnd->spmenu, (LPARAM)lpfoo);
    ThreadUnlock(&tlpwndParent);

    return lRet;
}


/***************************************************************************\
* xxxCBPaint
*
* History:
\***************************************************************************/

void xxxCBPaint(
    PCBOX pcbox,
    HDC hdc)
{
    RECT rc;
    UINT msg;
    HBRUSH hbr;

    CheckLock(pcbox->spwnd);

    rc.left = rc.top = 0;
    rc.right = pcbox->cxCombo;
    rc.bottom = pcbox->cyCombo;
    if (pcbox->f3DCombo)
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
    else
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST | BF_FLAT | BF_MONO);

    if (pcbox->buttonrc.left != 0) {
    // Draw in the dropdown arrow button
        DrawFrameControl(hdc, KPRECT_TO_PRECT(&pcbox->buttonrc), DFC_SCROLL,
            DFCS_SCROLLCOMBOBOX |
            (pcbox->fButtonPressed ? DFCS_PUSHED | DFCS_FLAT : 0) |
            (TestWF(pcbox->spwnd, WFDISABLED) ? DFCS_INACTIVE : 0));
#ifdef COLOR_HOTTRACKING
            (pcbox->fButtonHotTracked ? DFCS_HOT: 0)));
#endif // COLOR_HOTTRACKING
        if (pcbox->fRightAlign )
            rc.left = pcbox->buttonrc.right;
        else
            rc.right = pcbox->buttonrc.left;
    }

    // Erase the background behind the edit/static item.  Since a combo
    // is an edit field/list box hybrid, we use the same coloring
    // conventions.
    msg = WM_CTLCOLOREDIT;
    if (TestWF(pcbox->spwnd, WFWIN40COMPAT)) {
        if (TestWF(pcbox->spwnd, WFDISABLED) ||
            (!pcbox->fNoEdit && pcbox->spwndEdit && TestWF(pcbox->spwndEdit, EFREADONLY)))
            msg = WM_CTLCOLORSTATIC;
    } else
        msg = WM_CTLCOLORLISTBOX;

    hbr = GetControlBrush(HWq(pcbox->spwnd), hdc, msg);

    if (pcbox->fNoEdit)
        xxxCBInternalUpdateEditWindow(pcbox, hdc);
    else
        FillRect(hdc, &rc, hbr);
}


/***************************************************************************\
* xxxCBCommandHandler
*
* Check the various notification codes from the controls and do the
* proper thing.
* always returns 0L
*
* History:
\***************************************************************************/

long xxxCBCommandHandler(
    PCBOX pcbox,
    DWORD wParam,
    HWND hwndControl)
{

    CheckLock(pcbox->spwnd);

    /*
     * Check the edit control notification codes.  Note that currently, edit
     * controls don't send EN_KILLFOCUS messages to the parent.
     */
    if (!pcbox->fNoEdit &&
            SAMEWOWHANDLE(hwndControl, HWq(pcbox->spwndEdit))) {

        /*
         * Edit control notification codes
         */
        switch (HIWORD(wParam)) {
        case EN_SETFOCUS:
            if (!pcbox->fFocus) {

                /*
                 * The edit control has the focus for the first time which means
                 * this is the first time the combo box has received the focus
                 * and the parent must be notified that we have the focus.
                 */
                xxxCBGetFocusHelper(pcbox);
            }
            break;

        case EN_CHANGE:
            xxxCBNotifyParent(pcbox, CBN_EDITCHANGE);
            xxxCBUpdateListBoxWindow(pcbox, FALSE);
            break;

        case EN_UPDATE:
            xxxCBNotifyParent(pcbox, CBN_EDITUPDATE);
            break;

        case EN_ERRSPACE:
            xxxCBNotifyParent(pcbox, CBN_ERRSPACE);
            break;
        }
    }

    /*
     * Check listbox control notification codes
     */
    if (SAMEWOWHANDLE(hwndControl, HWq(pcbox->spwndList))) {

        /*
         * Listbox control notification codes
         */
        switch ((int)HIWORD(wParam)) {
        case LBN_DBLCLK:
            xxxCBNotifyParent(pcbox, CBN_DBLCLK);
            break;

        case LBN_ERRSPACE:
            xxxCBNotifyParent(pcbox, CBN_ERRSPACE);
            break;

        case LBN_SELCHANGE:
        case LBN_SELCANCEL:
            if (!pcbox->fKeyboardSelInListBox) {

                /*
                 * If the selchange is caused by the user keyboarding through,
                 * we don't want to hide the listbox.
                 */
                if (!xxxCBHideListBoxWindow(pcbox, TRUE, TRUE))
                    return(0L);
            } else {
                pcbox->fKeyboardSelInListBox = FALSE;
            }

            xxxCBNotifyParent(pcbox, CBN_SELCHANGE);
            xxxCBInternalUpdateEditWindow(pcbox, NULL);
        
            /*
             * If this combobox doesn't have an edit control, it needs to send
             * this notification itself when the user is cycling through the
             * items with the keyboard.
             * See bug #54766.
             */
            if (pcbox->fNoEdit) {
                NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, HWq(pcbox->spwnd), OBJID_CLIENT, INDEX_COMBOBOX);
            }
            break;
        }
    }

    return 0L;
}


/***************************************************************************\
* xxxCBNotifyParent
*
* Sends the notification code to the parent of the combo box control
*
* History:
\***************************************************************************/

void xxxCBNotifyParent(
    PCBOX pcbox,
    short notificationCode)
{
    PWND pwndParent;            // Parent if it exists
    TL tlpwndParent;

    CheckLock(pcbox->spwnd);

    if (pcbox->spwndParent)
        pwndParent = pcbox->spwndParent;
    else
        pwndParent = pcbox->spwnd;

    /*
     * wParam contains Control ID and notification code.
     * lParam contains Handle to window
     */
    ThreadLock(pwndParent, &tlpwndParent);
    SendMessageWorker(pwndParent, WM_COMMAND,
            MAKELONG(PTR_TO_ID(pcbox->spwnd->spmenu), notificationCode),
            (LPARAM)HWq(pcbox->spwnd), FALSE);
    ThreadUnlock(&tlpwndParent);
}

/***************************************************************************\
*
*
* Completes the text in the edit box with the closest match from the
* listbox.  If a prefix match can't be found, the edit control text isn't
* updated. Assume a DROPDOWN style combo box.
*
*
* History:
\***************************************************************************/
void xxxCBCompleteEditWindow(
    PCBOX pcbox)
{
    int cchText;
    int cchItemText;
    int itemNumber;
    LPWSTR pText;
    TL tlpwndEdit;
    TL tlpwndList;

    CheckLock(pcbox->spwnd);

    /*
     * Firstly check the edit control.
     */
    if (pcbox->spwndEdit == NULL) {
        return;
    }

    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
    ThreadLock(pcbox->spwndList, &tlpwndList);

    /*
     * +1 for null terminator
     */
    cchText = (int)SendMessageWorker(pcbox->spwndEdit, WM_GETTEXTLENGTH, 0, 0, FALSE);

    if (cchText) {
        cchText++;
        if (!(pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchText*sizeof(WCHAR))))
            goto Unlock;

        /*
         * We want to be sure to free the above allocated memory even if
         * the client dies during callback (xxx) or some of the following
         * window revalidation fails.
         */
        try {
            SendMessageWorker(pcbox->spwndEdit, WM_GETTEXT, cchText, (LPARAM)pText, FALSE);
            itemNumber = (int)SendMessageWorker(pcbox->spwndList,
                    LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pText, FALSE);
            if (itemNumber == -1)
                itemNumber = (int)SendMessageWorker(pcbox->spwndList,
                        LB_FINDSTRING, (WPARAM)-1, (LPARAM)pText, FALSE);
        } finally {
            UserLocalFree((HANDLE)pText);
        }

        if (itemNumber == -1) {

            /*
             * No close match.  Blow off.
             */
            goto Unlock;
        }

        cchItemText = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXTLEN,
                itemNumber, 0, FALSE);
        if (cchItemText) {
            cchItemText++;
            if (!(pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchItemText*sizeof(WCHAR))))
                goto Unlock;

            /*
             * We want to be sure to free the above allocated memory even if
             * the client dies during callback (xxx) or some of the following
             * window revalidation fails.
             */
            try {
                SendMessageWorker(pcbox->spwndList, LB_GETTEXT,
                        itemNumber, (LPARAM)pText, FALSE);
                SendMessageWorker(pcbox->spwndEdit, WM_SETTEXT,
                        0, (LPARAM)pText, FALSE);
            } finally {
                UserLocalFree((HANDLE)pText);
            }

            SendMessageWorker(pcbox->spwndEdit, EM_SETSEL, 0, MAXLONG, !!TestWF(pcbox->spwnd, WFANSIPROC));
        }
    }

Unlock:
    ThreadUnlock(&tlpwndList);
    ThreadUnlock(&tlpwndEdit);
}


/***************************************************************************\
* xxxCBHideListBoxWindow
*
* Hides the dropdown listbox window if it is a dropdown style.
*
* History:
\***************************************************************************/

BOOL xxxCBHideListBoxWindow(
    PCBOX pcbox,
    BOOL fNotifyParent,
    BOOL fSelEndOK)
{
    HWND hwnd = HWq(pcbox->spwnd);
    HWND hwndList = HWq(pcbox->spwndList);
    TL tlpwndList;


    CheckLock(pcbox->spwnd);

    // For 3.1+ apps, send CBN_SELENDOK to all types of comboboxes but only
    // allow CBN_SELENDCANCEL to be sent for droppable comboboxes
    if (fNotifyParent && TestWF(pcbox->spwnd, WFWIN31COMPAT) &&
        ((pcbox->CBoxStyle & SDROPPABLE) || fSelEndOK)) {
        if (fSelEndOK)
        {
            xxxCBNotifyParent(pcbox, CBN_SELENDOK);
        }
        else
        {
            xxxCBNotifyParent(pcbox, CBN_SELENDCANCEL);
        }
        if (!IsWindow(hwnd))
            return(FALSE);
    }

    /*
     * return, we don't hide simple combo boxes.
     */
    if (!(pcbox->CBoxStyle & SDROPPABLE)) {
        return TRUE;
    }

    /*
     * Send a faked buttonup message to the listbox so that it can release
     * the capture and all.
     */
    ThreadLock(pcbox->spwndList, &tlpwndList);

    SendMessageWorker(pcbox->spwndList, LBCB_ENDTRACK, fSelEndOK, 0, FALSE);

    if (pcbox->fLBoxVisible) {
        WORD swpFlags = SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE;

        if (!TestWF(pcbox->spwnd, WFWIN31COMPAT))
            swpFlags |= SWP_FRAMECHANGED;

        pcbox->fLBoxVisible = FALSE;

        /*
         * Hide the listbox window
         */
        NtUserShowWindow(hwndList, SW_HIDE);

        //
        // Invalidate the item area now since SWP() might update stuff.
        // Since the combo is CS_VREDRAW/CS_HREDRAW, a size change will
        // redraw the whole thing, including the item rect.  But if it
        // isn't changing size, we still want to redraw the item anyway
        // to show focus/selection.
        //
        if (!(pcbox->CBoxStyle & SEDITABLE))
            NtUserInvalidateRect(hwnd, KPRECT_TO_PRECT(&pcbox->editrc), TRUE);

        NtUserSetWindowPos(hwnd, HWND_TOP, 0, 0,
                pcbox->cxCombo, pcbox->cyCombo, swpFlags);

        // In case size didn't change
        UpdateWindow(hwnd);

        if (pcbox->CBoxStyle & SEDITABLE) {
            xxxCBCompleteEditWindow(pcbox);
        }

        if (fNotifyParent) {

            /*
             * Notify parent we will be popping up the combo box.
             */
            xxxCBNotifyParent(pcbox, CBN_CLOSEUP);
            if (!IsWindow(hwnd))
                return(FALSE);
        }
    }

    ThreadUnlock(&tlpwndList);

    return(TRUE);
}

/***************************************************************************\
* xxxCBShowListBoxWindow
*
* Lowers the dropdown listbox window.
*
* History:
\***************************************************************************/

void xxxCBShowListBoxWindow(
    PCBOX pcbox, BOOL fTrack)
{
    RECT        editrc;
    int         itemNumber;
    int         iHeight;
    int         yTop;
    DWORD       dwMult;
    int         cyItem;
    HWND        hwnd = HWq(pcbox->spwnd);
    HWND        hwndList = HWq(pcbox->spwndList);
    BOOL        fAnimPos;
    TL          tlpwndList;
    PMONITOR    pMonitor;

    //
    // THIS FUNCTION IS ONLY CALLED FOR DROPPABLE LIST COMBOBOXES
    //
    UserAssert(pcbox->CBoxStyle & SDROPPABLE);

    CheckLock(pcbox->spwnd);

    ThreadLock(pcbox->spwndList, &tlpwndList);

    /*
     * Notify parent we will be dropping down the combo box.
     */

    xxxCBNotifyParent(pcbox, CBN_DROPDOWN);
    /*
     * Invalidate the button rect so that the depressed arrow is drawn.
     */
    NtUserInvalidateRect(hwnd, KPRECT_TO_PRECT(&pcbox->buttonrc), TRUE);

    pcbox->fLBoxVisible = TRUE;

    if (pcbox->CBoxStyle == SDROPDOWN) {

        /*
         * If an item in the listbox matches the text in the edit control,
         * scroll it to the top of the listbox.  Select the item only if the
         * mouse button isn't down otherwise we will select the item when the
         * mouse button goes up.
         */
        xxxCBUpdateListBoxWindow(pcbox, !pcbox->fMouseDown);
        if (!pcbox->fMouseDown)
            xxxCBCompleteEditWindow(pcbox);
    } else {

        /*
         * Scroll the currently selected item to the top of the listbox.
         */
        itemNumber = (int)SendMessageWorker(pcbox->spwndList, LB_GETCURSEL,
                0, 0, FALSE);
        if (itemNumber == -1) {
            itemNumber = 0;
        }
        SendMessageWorker(pcbox->spwndList, LB_SETTOPINDEX, itemNumber, 0, FALSE);
        SendMessageWorker(pcbox->spwndList, LBCB_CARETON, 0, 0, FALSE);

        /*
         * We need to invalidate the edit rect so that the focus frame/invert
         * will be turned off when the listbox is visible.  Tandy wants this for
         * his typical reasons...
         */
        NtUserInvalidateRect(hwnd, KPRECT_TO_PRECT(&pcbox->editrc), TRUE);
    }

    //
    // Figure out where to position the dropdown listbox.  We want it just
    // touching the edge around the edit rectangle.  Note that since the
    // listbox is a popup, we need the position in screen coordinates.
    //

    // We want the dropdown to pop below or above the combo

    // Get screen coords
    editrc.left   = pcbox->spwnd->rcWindow.left;
    editrc.top    = pcbox->spwnd->rcWindow.top;
    editrc.right  = pcbox->spwnd->rcWindow.left + pcbox->cxCombo;
    editrc.bottom = pcbox->spwnd->rcWindow.top  + pcbox->cyCombo;

    // List area
    cyItem = (int)SendMessageWorker(pcbox->spwndList, LB_GETITEMHEIGHT, 0, 0, FALSE);

    if (cyItem == 0) {
        // Make sure that it's not 0
        RIPMSG0( RIP_WARNING, "LB_GETITEMHEIGHT is returning 0\n" );

        cyItem = gpsi->cySysFontChar;
    }

    //  we shoulda' just been able to use cyDrop here, but thanks to VB's need
    //  to do things their OWN SPECIAL WAY, we have to keep monitoring the size
    //  of the listbox 'cause VB changes it directly (jeffbog 03/21/94)
    iHeight = max(pcbox->cyDrop, pcbox->spwndList->rcWindow.bottom -
                                 pcbox->spwndList->rcWindow.top);

    if (dwMult = (DWORD)SendMessageWorker(pcbox->spwndList, LB_GETCOUNT, 0, 0, FALSE)) {
        dwMult = (DWORD)(LOWORD(dwMult) * cyItem);
        dwMult += SYSMET(CYEDGE);

        if (dwMult < 0x7FFF)
            iHeight = min(LOWORD(dwMult), iHeight);
    }

    if (!TestWF(pcbox->spwnd, CBFNOINTEGRALHEIGHT)) {
        UserAssert(cyItem);
        iHeight = ((iHeight - SYSMET(CYEDGE)) / cyItem) * cyItem + SYSMET(CYEDGE);
    }

    //
    // Other 1/2 of old app combo fix.  Make dropdown overlap combo window
    // a little.  That way we can have a chance of invalidating the overlap
    // and causing a repaint to help out Publisher 2.0's toolbar combos.
    // See comments for PressButton() above.
    //
    pMonitor = _MonitorFromWindow(pcbox->spwnd, MONITOR_DEFAULTTOPRIMARY);
    if (editrc.bottom + iHeight <= pMonitor->rcMonitor.bottom) {
        yTop = editrc.bottom;
        if (!pcbox->f3DCombo)
            yTop -= SYSMET(CYBORDER);

        fAnimPos = TRUE;
    } else {
        yTop = max(editrc.top - iHeight, pMonitor->rcMonitor.top);
        if (!pcbox->f3DCombo)
            yTop += SYSMET(CYBORDER);

        fAnimPos = FALSE;
    }

    if ( ! TestWF( pcbox->spwnd, WFWIN40COMPAT) )
    {
      // fix for Winword B#7504, Combo-ListBox text gets
      // truncated by a small width, this is do to us
      // now setting size here in SetWindowPos, rather than
      // earlier where we did this in Win3.1

      if ( (pcbox->spwndList->rcWindow.right - pcbox->spwndList->rcWindow.left ) >
            pcbox->cxDrop )

            pcbox->cxDrop = pcbox->spwndList->rcWindow.right - pcbox->spwndList->rcWindow.left;
    }

    NtUserSetWindowPos(hwndList, HWND_TOPMOST, editrc.left,
        yTop, max(pcbox->cxDrop, pcbox->cxCombo), iHeight, SWP_NOACTIVATE);

    /*
     * Get any drawing in the combo box window out of the way so it doesn't
     * invalidate any of the SPB underneath the list window.
     */
    UpdateWindow(hwnd);

    if (!(TEST_EffectPUSIF(PUSIF_COMBOBOXANIMATION))
        || (GetAppCompatFlags2(VER40) & GACF2_ANIMATIONOFF)) {
        NtUserShowWindow(hwndList, SW_SHOWNA);
    } else {
        AnimateWindow(hwndList, CMS_QANIMATION, (fAnimPos ? AW_VER_POSITIVE :
                AW_VER_NEGATIVE) | AW_SLIDE);
    }

#ifdef LATER
//
// we don't have sys modal windows.
//
    if (pwndSysModal) {

        /*
         * If this combo is in a system modal dialog box, we need to explicitly
         * call update window otherwise we won't automatically send paint
         * messages to the toplevel listbox window.  This is especially
         * noticeable in the File Open/Save sys modal dlgs which are put up at
         * ExitWindows time.
         */
        UpdateWindow(hwndList);
    }
#endif

    /*
     * Restart search buffer from first char
     */
    {
    PLBIV plb = ((PLBWND)pcbox->spwndList)->pLBIV;

        if ((plb != NULL) && (plb != (PLBIV)-1)) {
            plb->iTypeSearch = 0;
        }
    }

    if (fTrack && TestWF(pcbox->spwnd, WFWIN40COMPAT))
        SendMessageWorker(pcbox->spwndList, LBCB_STARTTRACK, FALSE, 0, FALSE);

    ThreadUnlock(&tlpwndList);
}

/***************************************************************************\
* xxxCBInternalUpdateEditWindow
*
* Updates the editcontrol/statictext window so that it contains the text
* given by the current selection in the listbox.  If the listbox has no
* selection (ie. -1), then we erase all the text in the editcontrol.
*
* hdcPaint is from WM_PAINT messages Begin/End Paint hdc. If null, we should
* get our own dc.
*
* History:
\***************************************************************************/

void xxxCBInternalUpdateEditWindow(
    PCBOX pcbox,
    HDC hdcPaint)
{
    int cchText = 0;
    LPWSTR pText = NULL;
    int sItem;
    HDC hdc;
    UINT msg;
    HBRUSH hbrSave;
    HBRUSH hbrControl;
    HANDLE hOldFont;
    DRAWITEMSTRUCT dis;
    RECT rc;
    HWND hwnd = HWq(pcbox->spwnd);
    TL tlpwndList;
    TL tlpwndEdit;
    TL tlpwndParent;

    CheckLock(pcbox->spwnd);

    /* This check is also commented out in Win3.1 and Win95 */
    // if (!TestWF(pcbox->spwnd, WFVISIBLE)) {
    //    return;
    // }

    ThreadLock(pcbox->spwndParent, &tlpwndParent);
    ThreadLock(pcbox->spwndList, &tlpwndList);
    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);

    sItem = (int)SendMessageWorker(pcbox->spwndList, LB_GETCURSEL, 0, 0, FALSE);

    /*
     * This 'try-finally' block ensures that the allocated 'pText' will
     * be freed no matter how this routine is exited.
     */
    try {
        if (sItem != -1) {
            cchText = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXTLEN,
                    (DWORD)sItem, 0, FALSE);
            if ((pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, (cchText+1) * sizeof(WCHAR)))) {
                cchText = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXT,
                        (DWORD)sItem, (LPARAM)pText, FALSE);
            }
        }

        if (!pcbox->fNoEdit) {

            if (pcbox->spwndEdit) {
                if (TestWF(pcbox->spwnd, CBFHASSTRINGS))
                    SetWindowText(HWq(pcbox->spwndEdit), pText ? pText : TEXT(""));

                if (pcbox->fFocus) {
                    /*
                     * Only hilite the text if we have the focus.
                     */
                    SendMessageWorker(pcbox->spwndEdit, EM_SETSEL, 0, MAXLONG, !!TestWF(pcbox->spwnd, WFANSIPROC));
                }
            }
        } else if (IsComboVisible(pcbox)) {
            if (hdcPaint) {
                hdc = hdcPaint;
            } else {
                hdc = NtUserGetDC(hwnd);
            }

            SetBkMode(hdc, OPAQUE);
            if (TestWF(pcbox->spwnd, WFWIN40COMPAT)) {
                if (TestWF(pcbox->spwnd, WFDISABLED))
                    msg = WM_CTLCOLORSTATIC;
                else
                    msg = WM_CTLCOLOREDIT;
            } else
                msg = WM_CTLCOLORLISTBOX;

            hbrControl = GetControlBrush(hwnd, hdc, msg);
            hbrSave = SelectObject(hdc, hbrControl);

            CopyInflateRect(&rc, KPRECT_TO_PRECT(&pcbox->editrc), SYSMET(CXBORDER), SYSMET(CYBORDER));
            PatBlt(hdc, rc.left, rc.top, rc.right - rc.left,
                rc.bottom - rc.top, PATCOPY);
            InflateRect(&rc, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

            if (pcbox->fFocus && !pcbox->fLBoxVisible) {
                //
                // Fill in the selected area
                //


                // only do the FillRect if we know its not
                // ownerdraw item, otherwise we mess up people up
                // BUT: for Compat's sake we still do this for Win 3.1 guys

                if (!TestWF( pcbox->spwnd, WFWIN40COMPAT) || !pcbox->OwnerDraw)
                    FillRect(hdc, &rc, SYSHBR(HIGHLIGHT));

                SetBkColor(hdc, SYSRGB(HIGHLIGHT));
                SetTextColor(hdc, SYSRGB(HIGHLIGHTTEXT));
            } else if (TestWF(pcbox->spwnd, WFDISABLED) && !pcbox->OwnerDraw) {
                if ((COLORREF)SYSRGB(GRAYTEXT) != GetBkColor(hdc))
                    SetTextColor(hdc, SYSRGB(GRAYTEXT));
            }

            if (pcbox->hFont != NULL)
                hOldFont = SelectObject(hdc, pcbox->hFont);

            if (pcbox->OwnerDraw) {

                /*
                 * Let the app draw the stuff in the static text box.
                 */
                dis.CtlType = ODT_COMBOBOX;
                dis.CtlID = PtrToUlong(pcbox->spwnd->spmenu);
                dis.itemID = sItem;
                dis.itemAction = ODA_DRAWENTIRE;
                dis.itemState = (UINT)
                    ((pcbox->fFocus && !pcbox->fLBoxVisible ? ODS_SELECTED : 0) |
                    (TestWF(pcbox->spwnd, WFDISABLED) ? ODS_DISABLED : 0) |
                    (pcbox->fFocus && !pcbox->fLBoxVisible ? ODS_FOCUS : 0) |
                    (TestWF(pcbox->spwnd, WFWIN40COMPAT) ? ODS_COMBOBOXEDIT : 0) |
                    (TestWF(pcbox->spwnd, WEFPUIFOCUSHIDDEN) ? ODS_NOFOCUSRECT : 0) |
                    (TestWF(pcbox->spwnd, WEFPUIACCELHIDDEN) ? ODS_NOACCEL : 0));

                dis.hwndItem = hwnd;
                dis.hDC = hdc;
                CopyRect(&dis.rcItem, &rc);

                // Don't let ownerdraw dudes draw outside of the combo client
                // bounds.
                IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

                dis.itemData = (ULONG_PTR)SendMessageWorker(pcbox->spwndList,
                        LB_GETITEMDATA, (UINT)sItem, 0, FALSE);

                SendMessage(HW(pcbox->spwndParent), WM_DRAWITEM, dis.CtlID,
                        (LPARAM)&dis);
            } else {

                /*
                 * Start the text one pixel within the rect so that we leave a
                 * nice hilite border around the text.
                 */

                int x ;
                UINT align ;

                if (pcbox->fRightAlign ) {
                    align = TA_RIGHT;
                    x = rc.right - SYSMET(CXBORDER);
                } else {
                    x = rc.left + SYSMET(CXBORDER);
                    align = 0;
                }

                if (pcbox->fRtoLReading )
                    align |= TA_RTLREADING;

                if (align)
                    SetTextAlign(hdc, GetTextAlign(hdc) | align);

                // Draw the text, leaving a gap on the left & top for selection.
                ExtTextOut(hdc, x, rc.top + SYSMET(CYBORDER), ETO_CLIPPED | ETO_OPAQUE,
                       &rc, pText ? pText : TEXT(""), cchText, NULL);
                if (pcbox->fFocus && !pcbox->fLBoxVisible) {
                    if (!TestWF(pcbox->spwnd, WEFPUIFOCUSHIDDEN)) {
                        DrawFocusRect(hdc, &rc);
                    }
                }
            }

            if (pcbox->hFont && hOldFont) {
                SelectObject(hdc, hOldFont);
            }

            if (hbrSave) {
                SelectObject(hdc, hbrSave);
            }

            if (!hdcPaint) {
                NtUserReleaseDC(hwnd, hdc);
            }
        }

    } finally {
        if (pText != NULL)
            UserLocalFree((HANDLE)pText);
    }

    ThreadUnlock(&tlpwndEdit);
    ThreadUnlock(&tlpwndList);
    ThreadUnlock(&tlpwndParent);
}

/***************************************************************************\
* xxxCBInvertStaticWindow
*
* Inverts the static text/picture window associated with the combo
* box.  Gets its own hdc, if the one given is null.
*
* History:
\***************************************************************************/

void xxxCBInvertStaticWindow(
    PCBOX pcbox,
    BOOL fNewSelectionState,  /* True if inverted else false */
    HDC hdc)
{
    BOOL focusSave = pcbox->fFocus;

    CheckLock(pcbox->spwnd);

    pcbox->fFocus = (UINT)fNewSelectionState;
    xxxCBInternalUpdateEditWindow(pcbox, hdc);

    pcbox->fFocus = (UINT)focusSave;
}

/***************************************************************************\
* xxxCBUpdateListBoxWindow
*
* matches the text in the editcontrol. If fSelectionAlso is false, then we
* unselect the current listbox selection and just move the caret to the item
* which is the closest match to the text in the editcontrol.
*
* History:
\***************************************************************************/

void xxxCBUpdateListBoxWindow(
    PCBOX pcbox,
    BOOL fSelectionAlso)
{
    int cchText;
    int sItem, sSel;
    LPWSTR pText = NULL;
    TL tlpwndEdit;
    TL tlpwndList;

    if (pcbox->spwndEdit == NULL) {
        return;
    }

    CheckLock(pcbox->spwnd);

    ThreadLock(pcbox->spwndList, &tlpwndList);
    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);

    /*
     * +1 for null terminator
     */

    cchText = (int)SendMessageWorker(pcbox->spwndEdit, WM_GETTEXTLENGTH, 0, 0, FALSE);

    if (cchText) {
        cchText++;
        pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchText*sizeof(WCHAR));
        if (pText != NULL) {
            try {
                SendMessageWorker(pcbox->spwndEdit, WM_GETTEXT, cchText, (LPARAM)pText, FALSE);
                sItem = (int)SendMessageWorker(pcbox->spwndList, LB_FINDSTRING,
                        (WPARAM)-1L, (LPARAM)pText, FALSE);
            } finally {
                UserLocalFree((HANDLE)pText);
            }
        }
    }
    else
        sItem = -1;

    if (fSelectionAlso) {
        sSel = sItem;
    } else {
        sSel = -1;
    }

    if (sItem == -1)
    {
        sItem = 0;

        //
        // Old apps:  w/ editable combos, selected 1st item in list even if
        // it didn't match text in edit field.  This is not desirable
        // behavior for 4.0 dudes esp. with cancel allowed.  Reason:
        //      (1) User types in text that doesn't match list choices
        //      (2) User drops combo
        //      (3) User pops combo back up
        //      (4) User presses OK in dialog that does stuff w/ combo
        //          contents.
        // In 3.1, when the combo dropped, we'd select the 1st item anyway.
        // So the last CBN_SELCHANGE the owner got would be 0--which is
        // bogus because it really should be -1.  In fact if you type anything
        // into the combo afterwards it will reset itself to -1.
        //
        // 4.0 dudes won't get this bogus 0 selection.
        //
        if (fSelectionAlso && !TestWF(pcbox->spwnd, WFWIN40COMPAT))
            sSel = 0;
    }


    SendMessageWorker(pcbox->spwndList, LB_SETCURSEL, (DWORD)sSel, 0, FALSE);
    SendMessageWorker(pcbox->spwndList, LB_SETCARETINDEX, (DWORD)sItem, 0, FALSE);
    SendMessageWorker(pcbox->spwndList, LB_SETTOPINDEX, (DWORD)sItem, 0, FALSE);

    ThreadUnlock(&tlpwndEdit);
    ThreadUnlock(&tlpwndList);
}

/***************************************************************************\
* xxxCBGetFocusHelper
*
* Handles getting the focus for the combo box
*
* History:
\***************************************************************************/

void xxxCBGetFocusHelper(
    PCBOX pcbox)
{
    TL tlpwndList;
    TL tlpwndEdit;

    CheckLock(pcbox->spwnd);

    if (pcbox->fFocus)
        return;

    ThreadLock(pcbox->spwndList, &tlpwndList);
    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);

    /*
     * The combo box has gotten the focus for the first time.
     */

    /*
     * First turn on the listbox caret
     */

    if (pcbox->CBoxStyle == SDROPDOWNLIST)
       SendMessageWorker(pcbox->spwndList, LBCB_CARETON, 0, 0, FALSE);

    /*
     * and select all the text in the editcontrol or static text rectangle.
     */

    if (pcbox->fNoEdit) {

        /*
         * Invert the static text rectangle
         */
        xxxCBInvertStaticWindow(pcbox, TRUE, (HDC)NULL);
    } else if (pcbox->spwndEdit) {
        UserAssert(pcbox->spwnd);
        SendMessageWorker(pcbox->spwndEdit, EM_SETSEL, 0, MAXLONG, !!TestWF(pcbox->spwnd, WFANSIPROC));
    }

    pcbox->fFocus = TRUE;

    /*
     * Notify the parent we have the focus
     */
    xxxCBNotifyParent(pcbox, CBN_SETFOCUS);

    ThreadUnlock(&tlpwndEdit);
    ThreadUnlock(&tlpwndList);
}

/***************************************************************************\
* xxxCBKillFocusHelper
*
* Handles losing the focus for the combo box.
*
* History:
\***************************************************************************/

void xxxCBKillFocusHelper(
    PCBOX pcbox)
{
    TL tlpwndList;
    TL tlpwndEdit;

    CheckLock(pcbox->spwnd);

    if (!pcbox->fFocus || pcbox->spwndList == NULL)
        return;

    ThreadLock(pcbox->spwndList, &tlpwndList);
    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);

    /*
     * The combo box is losing the focus.  Send buttonup clicks so that
     * things release the mouse capture if they have it...  If the
     * pwndListBox is null, don't do anything.  This occurs if the combo box
     * is destroyed while it has the focus.
     */
    SendMessageWorker(pcbox->spwnd, WM_LBUTTONUP, 0L, 0xFFFFFFFFL, FALSE);
     if (!xxxCBHideListBoxWindow(pcbox, TRUE, FALSE))
         return;

    /*
     * Turn off the listbox caret
     */

    if (pcbox->CBoxStyle == SDROPDOWNLIST)
       SendMessageWorker(pcbox->spwndList, LBCB_CARETOFF, 0, 0, FALSE);

    if (pcbox->fNoEdit) {

        /*
         * Invert the static text rectangle
         */
        xxxCBInvertStaticWindow(pcbox, FALSE, (HDC)NULL);
    } else if (pcbox->spwndEdit) {
        SendMessageWorker(pcbox->spwndEdit, EM_SETSEL, 0, 0, !!TestWF(pcbox->spwnd, WFANSIPROC));
    }

    pcbox->fFocus = FALSE;
    xxxCBNotifyParent(pcbox, CBN_KILLFOCUS);

    ThreadUnlock(&tlpwndEdit);
    ThreadUnlock(&tlpwndList);
}


/***************************************************************************\
* xxxCBGetTextLengthHelper
*
* For the combo box without an edit control, returns size of current selected
* item
*
* History:
\***************************************************************************/

LONG xxxCBGetTextLengthHelper(
    PCBOX pcbox,
    BOOL fAnsi)
{
    int item;
    int cchText;
    TL tlpwndList;

    ThreadLock(pcbox->spwndList, &tlpwndList);
    item = (int)SendMessageWorker(pcbox->spwndList, LB_GETCURSEL, 0, 0, fAnsi);

    if (item == LB_ERR) {

        /*
         * No selection so no text.
         */
        cchText = 0;
    } else {
        cchText = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXTLEN,
                item, 0, fAnsi);
    }

    ThreadUnlock(&tlpwndList);

    return cchText;
}

/***************************************************************************\
* xxxCBGetTextHelper
*
* For the combo box without an edit control, copies cbString bytes of the
* string in the static text box to the buffer given by pString.
*
* History:
\***************************************************************************/

LONG xxxCBGetTextHelper(
    PCBOX pcbox,
    int cchString,
    LPWSTR pString,
    BOOL fAnsi)
{
    int item;
    int cchText;
    LPWSTR pText;
    DWORD dw;
    TL tlpwndList;

    CheckLock(pcbox->spwnd);

    if (!cchString || !pString)
        return 0;

    /*
     * Null the buffer to be nice.
     */
    if (fAnsi) {
        *((LPSTR)pString) = 0;
    } else {
        *((LPWSTR)pString) = 0;
    }

    ThreadLock(pcbox->spwndList, &tlpwndList);
    item = (int)SendMessageWorker(pcbox->spwndList, LB_GETCURSEL, 0, 0, fAnsi);

    if (item == LB_ERR) {

        /*
         * No selection so no text.
         */
        ThreadUnlock(&tlpwndList);
        return 0;
    }

    cchText = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXTLEN, item, 0, fAnsi);

    cchText++;
    if ((cchText <= cchString) ||
            (!TestWF(pcbox->spwnd, WFWIN31COMPAT) && cchString == 2)) {
        /*
         * Just do the copy if the given buffer size is large enough to hold
         * everything.  Or if old 3.0 app.  (Norton used to pass 2 & expect 3
         * chars including the \0 in 3.0; Bug #7018 win31: vatsanp)
         */
        dw = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXT, item,
                (LPARAM)pString, fAnsi);
        ThreadUnlock(&tlpwndList);
        return dw;
    }

    if (!(pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchText*sizeof(WCHAR)))) {

        /*
         * Bail.  Not enough memory to chop up the text.
         */
        ThreadUnlock(&tlpwndList);
        return 0;
    }

    try {
        SendMessageWorker(pcbox->spwndList, LB_GETTEXT, item, (LPARAM)pText, fAnsi);
        if (fAnsi) {
            RtlCopyMemory((PBYTE)pString, (PBYTE)pText, cchString);
            ((LPSTR)pString)[cchString - 1] = 0;
        } else {
            RtlCopyMemory((PBYTE)pString, (PBYTE)pText, cchString * sizeof(WCHAR));
            ((LPWSTR)pString)[cchString - 1] = 0;
        }
    } finally {
        UserLocalFree((HANDLE)pText);
    }

    ThreadUnlock(&tlpwndList);
    return cchString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\crecv.c ===
/****************************** Module Header ******************************\
* Module Name: crecv.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Client side receiving stubs
*
* 07-06-91 ScottLu Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <dbt.h>

#define CALLBACKPROC 1
#define CLIENTSIDE 1

#include "callback.h"

/*
 * Receive setup and control macros
 */
#define RECVSIDE 1

#define RECVCALL(lower, upper) \
    DWORD __ ## lower (upper *pmsg)

#define BEGINRECV(err, p, cb) \
    CALLBACKSTATUS CallbackStatus;      \
    NTSTATUS Status = STATUS_SUCCESS;   \
    ULONG_PTR retval = (ULONG_PTR)err;    \
    CallbackStatus.cbOutput = cb;       \
    CallbackStatus.pOutput = p;

#define FIXUPPOINTERS() \
    if (pmsg->CaptureBuf.cCapturedPointers &&           \
            pmsg->CaptureBuf.pvVirtualAddress == NULL)  \
        FixupCallbackPointers(&pmsg->CaptureBuf);

#if defined(_X86_) && !defined(BUILD_WOW6432)

NTSTATUS
FASTCALL
XyCallbackReturn(
    IN PVOID Buffer,
    IN ULONG Length,
    IN NTSTATUS Status
    );

#define ENDRECV() \
    goto errorexit;                                                     \
errorexit:                                                              \
    CallbackStatus.retval = retval;                                     \
    return XyCallbackReturn(&CallbackStatus, sizeof(CallbackStatus),    \
            Status)

#else

#define ENDRECV() \
    goto errorexit;                                                     \
errorexit:                                                              \
    CallbackStatus.retval = retval;                                     \
    return NtCallbackReturn(&CallbackStatus, sizeof(CallbackStatus),    \
            Status)

#endif

#define MSGERROR() \
    goto errorexit

#define MSGERRORCODE(code) { \
    RIPERR0(code, RIP_WARNING, "Unspecified error"); \
    goto errorexit; }

#define MSGNTERRORCODE(code) { \
    RIPNTERR0(code, RIP_WARNING, "Unspecified error"); \
    goto errorexit; }

/*
 * Callback parameter fixup macros
 */
//#undef CALLPROC
//#define CALLPROC(p) FNID(p)

#define CALLDATA(x) (pmsg->x)
#define PCALLDATA(x) (&(pmsg->x))
#define PCALLDATAOPT(x) (pmsg->p ## x ? (PVOID)&(pmsg->x) : NULL)
#define FIRSTFIXUP(x) (pmsg->x)
#define FIXUPOPT(x) (pmsg->x)
#define FIRSTFIXUPOPT(x) FIXUPOPT(x)
#define FIXUP(x) (pmsg->x)
#define FIXUPID(x) (pmsg->x)
#define FIXUPIDOPT(x) (pmsg->x)
#define FIXUPSTRING(x) (pmsg->x.Buffer)
#define FIXUPSTRINGID(x) (pmsg->x.Buffer)
#define FIXUPSTRINGIDOPT(x) (pmsg->x.Buffer)

/***************************************************************************\
* FixupCallbackPointers
*
* Fixes up captured callback pointers.
*
* 03-13-95 JimA             Created.
\***************************************************************************/

VOID FixupCallbackPointers(
    PCAPTUREBUF pcb)
{
    DWORD i;
    LPDWORD lpdwOffset;
    PVOID *ppFixup;

    lpdwOffset = (LPDWORD)((PBYTE)pcb + pcb->offPointers);
    for (i = 0; i < pcb->cCapturedPointers; ++i, ++lpdwOffset) {
        ppFixup = (PVOID *)((PBYTE)pcb + *lpdwOffset);
        *ppFixup = (PBYTE)pcb + (LONG_PTR)*ppFixup;
    }
}

/**************************************************************************\
*
* include the stub definition file
*
\**************************************************************************/

#include "ntcb.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\csenda.c ===
/**************************************************************************\
* Module Name: csenda.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client side sending stubs for ANSI text
*
* History:
* 06-Jan-1992 IanJa
\**************************************************************************/

#define CLIENTSIDE 1

#undef UNICODE

#define NONTOSPINTERLOCK
#include <ntosp.h>

#include <ntrtl.h>
#include <nturtl.h>
#include "ntcsrdll.h"
#include "usercli.h"
#include <stdlib.h>

/**************************************************************************\
*
* include the stub definition file
*
\**************************************************************************/

#include "ntcftxt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\csendw.c ===
/**************************************************************************\
* Module Name: csendw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client side sending stubs for UNICODE text
*
* History:
* 06-Jan-1992 IanJa
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CLIENTSIDE 1

#ifndef UNICODE
#define UNICODE
#endif

/**************************************************************************\
*
* include the stub definition file
*
\**************************************************************************/

#include "ntcftxt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\ctxapi.c ===
/****************************** Module Header ******************************\
* Module Name: ctxapi.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/**************************************************************
* CtxUserGetWinstationInfo
*
* This functin is called to get the winstation information such as Protocol name,
* Audio driver name etc. .All these information are passed in by client at
* connection time.
*
*
****************************************************************/

BOOL
CtxUserGetWinstationInfo(PWINSTATIONINFO pInfo)
{
   NTSTATUS status;

   status = NtUserRemoteGetWinstationInfo((PWSXINFO)pInfo);

   if (NT_SUCCESS(status)) {
      return TRUE;
   }
   else {
      return FALSE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\ddemlwp.c ===
/****************************** Module Header ******************************\
* Module Name: ddemlwp.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager client side window procedures
*
* Created: 11/3/91 Sanford Staab
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

VOID ProcessDDEMLInitiate(PCL_INSTANCE_INFO pcii, HWND hwndClient,
        GATOM aServer, GATOM aTopic);

/***************************************************************************\
* DDEMLMotherWndProc
*
* Description:
* Handles WM_DDE_INITIATE messages for DDEML and holds all the other windows
* for a DDEML instance.
*
* History:
* 12-29-92 sanfords Created.
\***************************************************************************/
LRESULT DDEMLMotherWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message) {
    case UM_REGISTER:
    case UM_UNREGISTER:
        return(ProcessRegistrationMessage(hwnd, message, wParam, lParam));

    case WM_DDE_INITIATE:
        ProcessDDEMLInitiate((PCL_INSTANCE_INFO)GetWindowLongPtr(hwnd, GWLP_PCI),
                (HWND)wParam, (ATOM)LOWORD(lParam), (ATOM)HIWORD(lParam));
        return(0);

    }
    return(DefWindowProc(hwnd, message, wParam, lParam));
}



/***************************************************************************\
* ProcessDDEMLInitiate
*
* Description:
*
*   WM_DDE_INITIATE messages are processed here.
*
* History:
* 12-29-92   sanfords    Created.
\***************************************************************************/
VOID ProcessDDEMLInitiate(
PCL_INSTANCE_INFO pcii,
HWND hwndClient,
GATOM aServer,
GATOM aTopic)
{
    CONVCONTEXT cc = {
        sizeof(CONVCONTEXT),
        0,
        0,
        CP_WINANSI,
        0L,
        0L,
        {
            sizeof(SECURITY_QUALITY_OF_SERVICE),
            SecurityImpersonation,
            SECURITY_STATIC_TRACKING,
            TRUE
        }
    };
    BOOL flags = ST_INLIST;
    BOOL fWild;
    HDDEDATA hData;
    HWND hwndServer;
    PSERVER_LOOKUP psl;
    PHSZPAIR php;
    HSZPAIR hp[2];
    LATOM laService, laFree1 = 0;
    LATOM laTopic, laFree2 = 0;
    PSVR_CONV_INFO psi;
    LATOM *plaNameService;
    PWND pwndClient;
    PCLS pcls;

    if (pcii == NULL) {
        return;     // we aren't done being initiated yet.
    }

    EnterDDECrit;

    if (pcii->afCmd & CBF_FAIL_CONNECTIONS || !IsWindow(hwndClient)) {
        goto Exit;
    }

    pwndClient = ValidateHwnd(hwndClient);
    if (pwndClient == NULL) goto Exit;

    pcls = (PCLS)REBASEALWAYS(pwndClient, pcls);
    if (!TestWF(pwndClient, WFANSIPROC)) {
        if (pcls->atomClassName == gpsi->atomSysClass[ICLS_DDEMLCLIENTW]) {
            flags |= ST_ISLOCAL;
        }
    } else {
        if (pcls->atomClassName == gpsi->atomSysClass[ICLS_DDEMLCLIENTA]) {
            flags |= ST_ISLOCAL;
        }
    }

    if (flags & ST_ISLOCAL) {
        /*
         * Make sure other guy allows self-connections if that's what this is.
         */
        if (pcii->hInstServer == (HANDLE)GetWindowLongPtr(hwndClient, GWLP_SHINST)) {
            if (pcii->afCmd & CBF_FAIL_SELFCONNECTIONS) {
                goto Exit;
            }
            flags |= ST_ISSELF;
        }

        GetConvContext(hwndClient, (LONG *)&cc);
        if (GetWindowLong(hwndClient, GWL_CONVSTATE) & CLST_SINGLE_INITIALIZING) {
            flags &= ~ST_INLIST;
        }
    } else {
        NtUserDdeGetQualityOfService(hwndClient, NULL, &cc.qos);
    }

/***************************************************************************\
*
* Server window creation is minimized by only creating one window per
* Instance/Service/Topic set. This should be all that is needed and
* duplicate connections (ie where the server/client window pair is identical
* to another conversation) should not happen. However, if some dumb
* server app attempts to create a duplicate conversation by having
* duplicate service/topic pairs passed back from a XTYP_WILD_CONNECT
* callback we will not honor the request.
*
* The INSTANCE_INFO structure holds a pointer to an array of SERVERLOOKUP
* structures each entry of which references the hwndServer that supports
* all conversations on that service/topic pair. The hwndServer windows
* in turn have window words that reference the first member in a linked
* list of SVR_CONV_INFO structures, one for each conversation on that
* service/topic pair.
*
\***************************************************************************/

    laFree1 = laService = GlobalToLocalAtom(aServer);
    laFree2 = laTopic = GlobalToLocalAtom(aTopic);

    plaNameService = pcii->plaNameService;
    if (!laService && pcii->afCmd & APPCMD_FILTERINITS && *plaNameService == 0) {
        /*
         * no WILDCONNECTS to servers with no registered names while filtering.
         */
        goto Exit;
    }
    if ((pcii->afCmd & APPCMD_FILTERINITS) && laService) {
        /*
         * if we can't find the aServer in this instance's service name
         * list, don't bother the server.
         */
        while (*plaNameService != 0 && *plaNameService != laService) {
            plaNameService++;
        }
        if (*plaNameService == 0) {
            goto Exit;
        }
    }
    hp[0].hszSvc = NORMAL_HSZ_FROM_LATOM(laService);
    hp[0].hszTopic = NORMAL_HSZ_FROM_LATOM(laTopic);
    hp[1].hszSvc = 0;
    hp[1].hszTopic = 0;
    fWild = !laService || !laTopic;

    hData = DoCallback(pcii,
        (WORD)(fWild ? XTYP_WILDCONNECT : XTYP_CONNECT),
        0,
        (HCONV)0,
        hp[0].hszTopic,
        hp[0].hszSvc,
        (HDDEDATA)0,
        flags & ST_ISLOCAL ? (ULONG_PTR)&cc : 0,
        (DWORD)(flags & ST_ISSELF) ? 1 : 0);

    if (!hData) {
        goto Exit;
    }

    if (fWild) {
        php = (PHSZPAIR)DdeAccessData(hData, NULL);
        if (php == NULL) {
            goto Exit;
        }
    } else {
        php = hp;
    }

    while (php->hszSvc && php->hszTopic) {

        psi = (PSVR_CONV_INFO)DDEMLAlloc(sizeof(SVR_CONV_INFO));
        if (psi == NULL) {
            break;
        }

        laService = LATOM_FROM_HSZ(php->hszSvc);
        laTopic = LATOM_FROM_HSZ(php->hszTopic);

        hwndServer = 0;
        if (pcii->cServerLookupAlloc) {
            int i;
            /*
             * See if there already exists a server window for this
             * aServer/aTopic pair
             */
            for (i = pcii->cServerLookupAlloc; i; i--) {
                if (pcii->aServerLookup[i - 1].laService == laService &&
                        pcii->aServerLookup[i - 1].laTopic == laTopic) {
                    PSVR_CONV_INFO psiT;
                    PCONV_INFO pcoi;

                    hwndServer = pcii->aServerLookup[i - 1].hwndServer;
                    /*
                     * Now make sure this window isn't someone
                     * trying to create a second conversation from the
                     * same client window that is already talking to
                     * our existing server window.
                     */
                    psiT = (PSVR_CONV_INFO)GetWindowLongPtr(hwndServer, GWLP_PSI);
                    for (pcoi = &psiT->ci; pcoi != NULL; pcoi = pcoi->next) {
                        if (pcoi->hwndPartner == hwndClient) {
                            hwndServer = NULL;
                            break;
                        }
                    }
                    break;
                }
            }
        }

        if (hwndServer == 0) {

            // no server window exists - make one.

            LeaveDDECrit;
            if (pcii->flags & IIF_UNICODE) {
                hwndServer = CreateWindowW((LPWSTR)(gpsi->atomSysClass[ICLS_DDEMLSERVERW]),
                                          L"",
                                          WS_CHILD,
                                          0, 0, 0, 0,
                                          pcii->hwndMother,
                                          (HMENU)0,
                                          0,
                                          (LPVOID)NULL);
            } else {
                hwndServer = CreateWindowA((LPSTR)(gpsi->atomSysClass[ICLS_DDEMLSERVERA]),
                                          "",
                                          WS_CHILD,
                                          0, 0, 0, 0,
                                          pcii->hwndMother,
                                          (HMENU)0,
                                          0,
                                          (LPVOID)NULL);
            }
            EnterDDECrit;

            if (hwndServer == 0) {
                DDEMLFree(psi);
                break;
            }
            // SetWindowLongPtr(hwndServer, GWLP_PSI, (LONG)NULL); // Zero init.

            // put the window into the lookup list

            if (pcii->aServerLookup == NULL) {
                psl = (PSERVER_LOOKUP)DDEMLAlloc(sizeof(SERVER_LOOKUP));
            } else {
                psl = (PSERVER_LOOKUP)DDEMLReAlloc(pcii->aServerLookup,
                        sizeof(SERVER_LOOKUP) * (pcii->cServerLookupAlloc + 1));
            }
            if (psl == NULL) {
                RIPMSG1(RIP_WARNING, "ProcessDDEMLInitiate:hwndServer (%x) destroyed due to low memory.", hwndServer);
                NtUserDestroyWindow(hwndServer);
                DDEMLFree(psi);
                break;
            }

            IncLocalAtomCount(laService); // for SERVER_LOOKUP
            psl[pcii->cServerLookupAlloc].laService = laService;
            IncLocalAtomCount(laTopic); // for SERVER_LOOKUP
            psl[pcii->cServerLookupAlloc].laTopic = laTopic;
            psl[pcii->cServerLookupAlloc].hwndServer = hwndServer;
            pcii->aServerLookup = psl;
            pcii->cServerLookupAlloc++;
            // DumpServerLookupTable("After addition:", hwndServer, psl, pcii->cServerLookupAlloc);
        }

        psi->ci.next = (PCONV_INFO)GetWindowLongPtr(hwndServer, GWLP_PSI);
        SetWindowLongPtr(hwndServer, GWLP_PSI, (LONG_PTR)psi);
        psi->ci.pcii = pcii;
        // psi->ci.hUser = 0;
        psi->ci.hConv = (HCONV)CreateHandle((ULONG_PTR)psi,
                HTYPE_SERVER_CONVERSATION, InstFromHandle(pcii->hInstClient));
        psi->ci.laService = laService;
        IncLocalAtomCount(laService); // for server window
        psi->ci.laTopic = laTopic;
        IncLocalAtomCount(laTopic); // for server window
        psi->ci.hwndPartner = hwndClient;
        psi->ci.hwndConv = hwndServer;
        psi->ci.state = (WORD)(flags | ST_CONNECTED | pcii->ConvStartupState);
        SetCommonStateFlags(hwndClient, hwndServer, &psi->ci.state);
        psi->ci.laServiceRequested = laFree1;
        IncLocalAtomCount(psi->ci.laServiceRequested); // for server window
        // psi->ci.pxiIn = NULL;
        // psi->ci.pxiOut = NULL;
        // psi->ci.dmqIn = NULL;
        // psi->ci.dmqOut = NULL;
        // psi->ci.aLinks = NULL;
        // psi->ci.cLinks = 0;
        // psi->ci.cLocks = 0;

        LeaveDDECrit;
        CheckDDECritOut;
        SendMessage(hwndClient, WM_DDE_ACK, (WPARAM)hwndServer,
                MAKELONG(LocalToGlobalAtom(laService), LocalToGlobalAtom(laTopic)));
        EnterDDECrit;

        if (!(pcii->afCmd & CBF_SKIP_CONNECT_CONFIRMS)) {
            DoCallback(pcii,
                    (WORD)XTYP_CONNECT_CONFIRM,
                    0,
                    psi->ci.hConv,
                    (HSZ)laTopic,
                    (HSZ)laService,
                    (HDDEDATA)0,
                    0,
                    (flags & ST_ISSELF) ? 1L : 0L);
        }

        MONCONV((PCONV_INFO)psi, TRUE);

        if (!(flags & ST_INLIST)) {
            break;      // our partner's only gonna take the first one anyway.
        }
        php++;
    }

    if (fWild) {
        DdeUnaccessData(hData);
        InternalFreeDataHandle(hData, FALSE);
    }

Exit:
    DeleteAtom(laFree1);
    DeleteAtom(laFree2);
    LeaveDDECrit;
    return;
}

/***************************************************************************\
* DDEMLClientWndProc
*
* Description:
* Handles DDE client messages for DDEML.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
LRESULT DDEMLClientWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCL_CONV_INFO pci, pciNew;
    LONG lState;
    LRESULT lRet = 0;
    PWND pwnd;
    PCLS pcls;

    EnterDDECrit;

    pci = (PCL_CONV_INFO)GetWindowLongPtr(hwnd, GWLP_PCI);
    UserAssert(pci == NULL || pci->ci.hwndConv == hwnd);

    switch (message) {
    case WM_DDE_ACK:
        lState = GetWindowLong(hwnd, GWL_CONVSTATE);
        if (lState != CLST_CONNECTED) {

            // Initiation mode

            pciNew = (PCL_CONV_INFO)DDEMLAlloc(sizeof(CL_CONV_INFO));
            if (pciNew == NULL ||
                    (pci != NULL && lState == CLST_SINGLE_INITIALIZING)) {
                PostMessage((HWND)wParam, WM_DDE_TERMINATE, (WPARAM)hwnd, 0);
                goto Exit;
            }

            // PCL_CONV_INFO initialization

            pciNew->ci.pcii = ValidateInstance((HANDLE)GetWindowLongPtr(hwnd, GWLP_CHINST));

            if (pciNew->ci.pcii == NULL) {
                DDEMLFree(pciNew);
                goto Exit;
            }

            pciNew->ci.next = (PCONV_INFO)pci; // pci may be NULL
            //
            // Seting GWLP_PCI gives feedback to ConnectConv() which issued
            // the WM_DDE_INITIATE message.
            //
            SetWindowLongPtr(hwnd, GWLP_PCI, (LONG_PTR)pciNew);
            // pciNew->hUser = 0; // Zero init.

            // BUG: If this fails we can have some nasty problems
            pciNew->ci.hConv = (HCONV)CreateHandle((ULONG_PTR)pciNew,
                    HTYPE_CLIENT_CONVERSATION, InstFromHandle(pciNew->ci.pcii->hInstClient));

            pciNew->ci.laService = GlobalToLocalAtom(LOWORD(lParam)); // pci copy
            GlobalDeleteAtom(LOWORD(lParam));
            pciNew->ci.laTopic = GlobalToLocalAtom(HIWORD(lParam)); // pci copy
            GlobalDeleteAtom(HIWORD(lParam));
            pciNew->ci.hwndPartner = (HWND)wParam;
            pciNew->ci.hwndConv = hwnd;
            pciNew->ci.state = (WORD)(ST_CONNECTED | ST_CLIENT |
                    pciNew->ci.pcii->ConvStartupState);
            SetCommonStateFlags(hwnd, (HWND)wParam, &pciNew->ci.state);

            pwnd = ValidateHwnd((HWND)wParam);

            if (pwnd == NULL) goto Exit;
            pcls = (PCLS)REBASEALWAYS(pwnd, pcls);

            if (!TestWF(pwnd, WFANSIPROC)) {
                if (pcls->atomClassName == gpsi->atomSysClass[ICLS_DDEMLSERVERW]) {
                    pciNew->ci.state |= ST_ISLOCAL;
                }
            } else {
                if (pcls->atomClassName == gpsi->atomSysClass[ICLS_DDEMLSERVERA]) {
                    pciNew->ci.state |= ST_ISLOCAL;
                }
            }

            // pciNew->ci.laServiceRequested = 0; // Set by InitiateEnumerationProc()
            // pciNew->ci.pxiIn = 0;
            // pciNew->ci.pxiOut = 0;
            // pciNew->ci.dmqIn = 0;
            // pciNew->ci.dmqOut = 0;
            // pciNew->ci.aLinks = NULL;
            // pciNew->ci.cLinks = 0;
            // pciNew->ci.cLocks = 0;
            goto Exit;
        }
        // fall through to handle posted messages here.

    case WM_DDE_DATA:
        ProcessAsyncDDEMsg((PCONV_INFO)pci, message, (HWND)wParam, lParam);
        goto Exit;

    case WM_DDE_TERMINATE:
    case WM_DESTROY:
        {
            ProcessTerminateMsg((PCONV_INFO)pci, (HWND)wParam);
            break;
        }
    }

    lRet = DefWindowProc(hwnd, message, wParam, lParam);

Exit:
    LeaveDDECrit;
    return (lRet);
}




/***************************************************************************\
* DDEMLServerWndProc
*
* Description:
* Handles DDE server messages.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
LRESULT DDEMLServerWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PSVR_CONV_INFO psi;
    LRESULT lRet = 0;

    EnterDDECrit;

    psi = (PSVR_CONV_INFO)GetWindowLongPtr(hwnd, GWLP_PSI);
    UserAssert(psi == NULL || psi->ci.hwndConv == hwnd);

    switch (message) {
    case WM_DDE_REQUEST:
    case WM_DDE_POKE:
    case WM_DDE_ADVISE:
    case WM_DDE_EXECUTE:
    case WM_DDE_ACK:
    case WM_DDE_UNADVISE:
        ProcessAsyncDDEMsg((PCONV_INFO)psi, message, (HWND)wParam, lParam);
        goto Exit;

    case WM_DDE_TERMINATE:
    case WM_DESTROY:
        ProcessTerminateMsg((PCONV_INFO)psi, (HWND)wParam);
        break;
    }
    lRet = DefWindowProc(hwnd, message, wParam, lParam);
Exit:
    LeaveDDECrit;
    return (lRet);
}




/***************************************************************************\
* ProcessTerminateMsg
*
* Description:
* Handles WM_DDE_TERMINATE messages for both sides.
*
* History:
* 11-26-91 sanfords Created.
\***************************************************************************/
PCONV_INFO ProcessTerminateMsg(
PCONV_INFO pcoi,
HWND hwndFrom)
{
    while (pcoi != NULL && pcoi->hwndPartner != hwndFrom) {
        pcoi = pcoi->next;
    }
    if (pcoi != NULL) {
        pcoi->state |= ST_TERMINATE_RECEIVED;
        ShutdownConversation(pcoi, TRUE);
    }
    return (pcoi);
}



/***************************************************************************\
* ProcessAsyncDDEMsg
*
* Description:
* Handles incoming DDE messages by either calling ProcessSyncDDEMessage()
* if the conversation is able to handle callbacks, or by queuing the
* incoming message into the conversations message queue. Doing this
* allows simpler code in that no message is processed unless the code
* can perform synchronous callbacks.
*
* History:
* 11-26-91 sanfords Created.
\***************************************************************************/
VOID ProcessAsyncDDEMsg(
PCONV_INFO pcoi,
UINT msg,
HWND hwndFrom,
LPARAM lParam)
{
    PDDE_MESSAGE_QUEUE pdmq;
#if DBG
    HWND hwndT = pcoi->hwndConv;
#endif // DBG

    while (pcoi != NULL && pcoi->hwndPartner != hwndFrom) {
        pcoi = pcoi->next;
    }
    if (pcoi == NULL) {
        RIPMSG3(RIP_WARNING,
                "Bogus DDE message %x received from %x by %x. Dumping.",
                msg, hwndFrom, hwndT);
        DumpDDEMessage(FALSE, msg, lParam);
        return ;
    }
    if (pcoi->state & ST_CONNECTED) {

        if (pcoi->dmqOut == NULL &&
                !(pcoi->state & ST_BLOCKED)
//                && !PctiCurrent()->cInDDEMLCallback
                ) {

            if (ProcessSyncDDEMessage(pcoi, msg, lParam)) {
                return; // not blocked, ok to return.
            }
        }

        // enter into queue

        pdmq = DDEMLAlloc(sizeof(DDE_MESSAGE_QUEUE));
        if (pdmq == NULL) {

            // insufficient memory - we can't process this msg - we MUST
            // terminate.

            if (pcoi->state & ST_CONNECTED) {
                PostMessage(pcoi->hwndPartner, WM_DDE_TERMINATE,
                        (WPARAM)pcoi->hwndConv, 0);
                pcoi->state &= ~ST_CONNECTED;
            }
            DumpDDEMessage(!(pcoi->state & ST_INTRA_PROCESS), msg, lParam);
            return ;
        }
        pdmq->pcoi = pcoi;
        pdmq->msg = msg;
        pdmq->lParam = lParam;
        pdmq->next = NULL;

        // dmqOut->next->next->next->dmqIn->NULL

        if (pcoi->dmqIn != NULL) {
            pcoi->dmqIn->next = pdmq;
        }
        pcoi->dmqIn = pdmq;
        if (pcoi->dmqOut == NULL) {
            pcoi->dmqOut = pcoi->dmqIn;
        }
        pcoi->cLocks++;
        CheckForQueuedMessages(pcoi);
        pcoi->cLocks--;
        if (pcoi->cLocks == 0 && pcoi->state & ST_FREE_CONV_RES_NOW) {
            FreeConversationResources(pcoi);
        }
    } else {
        DumpDDEMessage(!(pcoi->state & ST_INTRA_PROCESS), msg, lParam);
    }
}







/***************************************************************************\
* CheckForQueuedMessages
*
* Description:
* Handles processing of DDE messages held in the given conversaion's
* DDE message queue.
*
* Returns: fProcessed.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL CheckForQueuedMessages(
PCONV_INFO pcoi)
{
    PDDE_MESSAGE_QUEUE pdmq;
    BOOL fRet = FALSE;
    PCLIENTINFO pci;

    CheckDDECritIn;

    if (pcoi->state & ST_PROCESSING) {      // recursion prevention
        return(FALSE);
    }

    UserAssert(pcoi->cLocks);

    pci = GetClientInfo();

    pcoi->state |= ST_PROCESSING;
    while (!(pcoi->state & ST_BLOCKED) &&
                pcoi->dmqOut != NULL &&
                !pci->cInDDEMLCallback) {
        pci->CI_flags |= CI_PROCESSING_QUEUE;
        if (ProcessSyncDDEMessage(pcoi, pcoi->dmqOut->msg, pcoi->dmqOut->lParam)) {
            fRet = TRUE;
            pdmq = pcoi->dmqOut;
            pcoi->dmqOut = pcoi->dmqOut->next;
            if (pcoi->dmqOut == NULL) {
                pcoi->dmqIn = NULL;
            }
            DDEMLFree(pdmq);
        }
        pci->CI_flags &= ~CI_PROCESSING_QUEUE;
    }
    pcoi->state &= ~ST_PROCESSING;
    return(fRet);
}




/***************************************************************************\
* DumpDDEMessage
*
* Description:
* Used to clean up resources referenced by DDE messages that for some
* reason could not be processed.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID DumpDDEMessage(
BOOL fFreeData,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;

    RIPMSG2(RIP_WARNING, "Dump DDE msg %x lParam %x", msg, lParam);

    switch (msg) {
    case WM_DDE_ACK:
    case WM_DDE_DATA:
    case WM_DDE_POKE:
    case WM_DDE_ADVISE:
        UnpackDDElParam(msg, lParam, &uiLo, &uiHi);
        switch (msg) {
        case WM_DDE_DATA:
        case WM_DDE_POKE:
            if (uiLo) {
                if (fFreeData) {
                    FreeDDEData((HANDLE)uiLo, FALSE, TRUE);
                }
                GlobalDeleteAtom((ATOM)uiHi);
            }
            break;

        case WM_DDE_ADVISE:
            if (uiLo) {
                if (fFreeData) {
                    FreeDDEData((HANDLE)uiLo, FALSE, TRUE);
                }
                GlobalDeleteAtom((ATOM)uiHi);
            }
            break;

        case WM_DDE_ACK:
            // could be EXEC Ack - cant know what to do exactly.
            break;
        }
        FreeDDElParam(msg, lParam);
        break;

    case WM_DDE_EXECUTE:
        if (fFreeData) {
            WOWGLOBALFREE((HANDLE)lParam);
        }
        break;

    case WM_DDE_REQUEST:
    case WM_DDE_UNADVISE:
        GlobalDeleteAtom((ATOM)HIWORD(lParam));
        break;
    }
}




/***************************************************************************\
* ProcessSyncDDEMessage
*
* Description:
* Handles processing of a received DDE message. TRUE is returned if
* the message was handled. FALSE implies CBR_BLOCK.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ProcessSyncDDEMessage(
PCONV_INFO pcoi,
UINT msg,
LPARAM lParam)
{
    BOOL fNotBlocked = TRUE;
    PCL_INSTANCE_INFO pcii;
    ENABLE_ENUM_STRUCT ees;
    BOOL fRet;

    CheckDDECritIn;

    /*
     * lock the conversation so its resources don't go away till we are
     * done with them.  This function could generate a callback which could
     * disconnect the conversation.
     */
    pcoi->cLocks++;

    if (pcoi->state & ST_BLOCKNEXT) {
        pcoi->state ^= ST_BLOCKNEXT | ST_BLOCKED;
    }
    if (pcoi->state & ST_BLOCKALLNEXT) {
        ees.pfRet = &fRet;
        ees.wCmd = EC_DISABLE;
        ees.wCmd2 = 0;
        EnumChildWindows(pcoi->pcii->hwndMother, (WNDENUMPROC)EnableEnumProc,
                (LPARAM)&ees);
    }

    if (pcoi->state & ST_CONNECTED) {
        if (pcoi->pxiOut == NULL) {
            if (pcoi->state & ST_CLIENT) {
                fNotBlocked = SpontaneousClientMessage((PCL_CONV_INFO)pcoi, msg, lParam);
            } else {
                fNotBlocked = SpontaneousServerMessage((PSVR_CONV_INFO)pcoi, msg, lParam);
            }
        } else {
            UserAssert(pcoi->pxiOut->hXact == (HANDLE)0 ||
                    ValidateCHandle(pcoi->pxiOut->hXact, HTYPE_TRANSACTION,
                    HINST_ANY)
                    == (ULONG_PTR)pcoi->pxiOut);
            fNotBlocked = (pcoi->pxiOut->pfnResponse)(pcoi->pxiOut, msg, lParam);
        }
    } else {
        DumpDDEMessage(!(pcoi->state & ST_INTRA_PROCESS), msg, lParam);
    }
    if (!fNotBlocked) {
        pcoi->state |= ST_BLOCKED;
        pcoi->state &= ~ST_BLOCKNEXT;
    }

    pcii = pcoi->pcii;  // save this incase unlocking makes pcoi go away.

    pcoi->cLocks--;
    if (pcoi->cLocks == 0 && pcoi->state & ST_FREE_CONV_RES_NOW) {
        FreeConversationResources(pcoi);
    }

    /*
     * Because callbacks are capable of blocking DdeUninitialize(), we check
     * before exit to see if it needs to be called.
     */
    if (pcii->afCmd & APPCMD_UNINIT_ASAP &&
            !(pcii->flags & IIF_IN_SYNC_XACT) &&
            !pcii->cInDDEMLCallback) {
        DdeUninitialize(HandleToUlong(pcii->hInstClient));
        return(FALSE);
    }
    return (fNotBlocked);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\ddetrack.c ===
/****************************** Module Header ******************************\
* Module Name: ddetrack.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client sied DDE tracking routines
*
* 10-22-91 sanfords created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#if defined(BUILD_WOW6432)
#define DDEDATA_WITH_HANDLE_SIZE  (sizeof (DDEDATA_WOW6432))
#else
#define DDEDATA_WITH_HANDLE_SIZE  (sizeof (DDE_DATA))
#endif


DWORD _ClientCopyDDEIn1(
    HANDLE hClient, // client handle to dde data or ddepack data
    PINTDDEINFO pi) // info for transfer
{
    PBYTE pData;
    DWORD flags;

    //
    // zero out everything but the flags
    //
    flags = pi->flags;
    RtlZeroMemory(pi, sizeof(INTDDEINFO));
    pi->flags = flags;
    USERGLOBALLOCK(hClient, pData);

    if (pData == NULL) {                            // bad hClient
        RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:GlobalLock failed.");
        return (FAIL_POST);
    }

    if (flags & XS_PACKED) {

        if (UserGlobalSize(hClient) < sizeof(DDEPACK)) {
            /*
             * must be a low memory condition. fail.
             */
            return(FAIL_POST);
        }

        pi->DdePack = *(PDDEPACK)pData;
        USERGLOBALUNLOCK(hClient);
        UserGlobalFree(hClient);    // packed data handles are not WOW matched.
        hClient = NULL;

        if (!(flags & (XS_LOHANDLE | XS_HIHANDLE))) {
            if (flags & XS_EXECUTE && flags & XS_FREESRC) {
                /*
                 * free execute ACK data
                 */
                WOWGLOBALFREE((HANDLE)pi->DdePack.uiHi);
            }
            return (DO_POST); // no direct data
        }

        if (flags & XS_LOHANDLE) {
            pi->hDirect = (HANDLE)pi->DdePack.uiLo;
        } else {
            pi->hDirect = (HANDLE)pi->DdePack.uiHi;
        }

        if (pi->hDirect == 0) {
            return (DO_POST); // must be warm link
        }

        USERGLOBALLOCK(pi->hDirect, pi->pDirect);
        if (pi->pDirect == NULL) {
            RIPMSG1(RIP_ERROR, "_ClientCopyDDEIn1:GlobalLock failed for hDirect %p.",pi->hDirect);
            return FAILNOFREE_POST;
        }
        pData = pi->pDirect;
        pi->cbDirect = (UINT)UserGlobalSize(pi->hDirect);

    } else {    // not packed - must be execute data or we wouldn't be called

        UserAssert(flags & XS_EXECUTE);

        pi->cbDirect = (UINT)UserGlobalSize(hClient);
        pi->hDirect = hClient;
        pi->pDirect = pData;
        hClient = NULL;
    }

    if (flags & XS_DATA) {
        PDDE_DATA pDdeData = (PDDE_DATA)pData;

        /*
         * Assert that the hClient has been freed. If not this code will return
         * the wrong thing on failure
         */
        UserAssert(flags & XS_PACKED);

        //
        // check here for indirect data
        //

        switch (pDdeData->wFmt) {
        case CF_BITMAP:
        case CF_DSPBITMAP:
            //
            // Imediately following the dde data header is a bitmap handle.
            //
            UserAssert(pi->cbDirect >= DDEDATA_WITH_HANDLE_SIZE);
            pi->hIndirect = (HANDLE)pDdeData->Data;
            if (pi->hIndirect == 0) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:GdiConvertBitmap failed");
                return(FAILNOFREE_POST);
            }
            // pi->cbIndirect = 0; // zero init.
            // pi->pIndirect = NULL; // zero init.
            pi->flags |= XS_BITMAP;
            break;

        case CF_DIB:
            //
            // Imediately following the dde data header is a global data handle
            // to the DIB bits.
            //
            UserAssert(pi->cbDirect >= DDEDATA_WITH_HANDLE_SIZE);
            pi->flags |= XS_DIB;
            pi->hIndirect = (HANDLE)pDdeData->Data;
            USERGLOBALLOCK(pi->hIndirect, pi->pIndirect);
            if (pi->pIndirect == NULL) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:CF_DIB GlobalLock failed.");
                return (FAILNOFREE_POST);
            }
            pi->cbIndirect = (UINT)UserGlobalSize(pi->hIndirect);
            break;

        case CF_PALETTE:
            UserAssert(pi->cbDirect >= DDEDATA_WITH_HANDLE_SIZE);
            pi->hIndirect = (HANDLE) pDdeData->Data;
            if (pi->hIndirect == 0) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:GdiConvertPalette failed.");
                return(FAILNOFREE_POST);
            }
            // pi->cbIndirect = 0; // zero init.
            // pi->pIndirect = NULL; // zero init.
            pi->flags |= XS_PALETTE;
            break;

        case CF_DSPMETAFILEPICT:
        case CF_METAFILEPICT:
            //
            // This format holds a global data handle which contains
            // a METAFILEPICT structure that in turn contains
            // a GDI metafile.
            //
            UserAssert(pi->cbDirect >= DDEDATA_WITH_HANDLE_SIZE);
            pi->hIndirect = GdiConvertMetaFilePict((HANDLE)pDdeData->Data);
            if (pi->hIndirect == 0) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:GdiConvertMetaFilePict failed");
                return(FAILNOFREE_POST);
            }
            // pi->cbIndirect = 0; // zero init.
            // pi->pIndirect = NULL; // zero init.
            pi->flags |= XS_METAFILEPICT;
            break;

        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
            UserAssert(pi->cbDirect >= DDEDATA_WITH_HANDLE_SIZE);
            pi->hIndirect = GdiConvertEnhMetaFile((HENHMETAFILE)pDdeData->Data);
            if (pi->hIndirect == 0) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:GdiConvertEnhMetaFile failed");
                return(FAILNOFREE_POST);
            }
            // pi->cbIndirect = 0; // zero init.
            // pi->pIndirect = NULL; // zero init.
            pi->flags |= XS_ENHMETAFILE;
            break;
        }
    }

    return (DO_POST);
}


/*
 * unlocks and frees DDE data pointers as appropriate
 */
VOID _ClientCopyDDEIn2(
    PINTDDEINFO pi)
{
    if (pi->cbDirect) {
        USERGLOBALUNLOCK(pi->hDirect);
        if (pi->flags & XS_FREESRC) {
            WOWGLOBALFREE(pi->hDirect);
        }
    }

    if (pi->cbIndirect) {
        USERGLOBALUNLOCK(pi->hIndirect);
        if (pi->flags & XS_FREESRC) {
            WOWGLOBALFREE(pi->hIndirect);
        }
    }
}



/*
 * returns fHandleValueChanged.
 */
BOOL FixupDdeExecuteIfNecessary(
HGLOBAL *phCommands,
BOOL fNeedUnicode)
{
    UINT cbLen;
    UINT cbSrc = (UINT)GlobalSize(*phCommands);
    LPVOID pstr;
    HGLOBAL hTemp;
    BOOL fHandleValueChanged = FALSE;

    USERGLOBALLOCK(*phCommands, pstr);

    if (cbSrc && pstr != NULL) {
        BOOL fIsUnicodeText;
#ifdef ISTEXTUNICODE_WORKS
        int flags;

        flags = (IS_TEXT_UNICODE_UNICODE_MASK |
                IS_TEXT_UNICODE_REVERSE_MASK |
                (IS_TEXT_UNICODE_NOT_UNICODE_MASK &
                (~IS_TEXT_UNICODE_ILLEGAL_CHARS)) |
                IS_TEXT_UNICODE_NOT_ASCII_MASK);
        fIsUnicodeText = RtlIsTextUnicode(pstr, cbSrc - 2, &flags);
#else
        fIsUnicodeText = ((cbSrc >= sizeof(WCHAR)) && (((LPSTR)pstr)[1] == '\0'));
#endif
        if (!fIsUnicodeText && fNeedUnicode) {
            LPWSTR pwsz;
            /*
             * Contents needs to be UNICODE.
             */
            cbLen = strlen(pstr) + 1;
            cbSrc = min(cbSrc, cbLen);
            pwsz = UserLocalAlloc(HEAP_ZERO_MEMORY, cbSrc * sizeof(WCHAR));
            if (pwsz != NULL) {
                if (NT_SUCCESS(RtlMultiByteToUnicodeN(
                        pwsz,
                        cbSrc * sizeof(WCHAR),
                        NULL,
                        (PCHAR)pstr,
                        cbSrc))) {
                    USERGLOBALUNLOCK(*phCommands);
                    if ((hTemp = GlobalReAlloc(
                            *phCommands,
                            cbSrc * sizeof(WCHAR),
                            GMEM_MOVEABLE)) != NULL) {
                        fHandleValueChanged = (hTemp != *phCommands);
                        *phCommands = hTemp;
                        USERGLOBALLOCK(*phCommands, pstr);
                        pwsz[cbSrc - 1] = L'\0';
                        wcscpy(pstr, pwsz);
                    }
                }
                UserLocalFree(pwsz);
            }
        } else if (fIsUnicodeText && !fNeedUnicode) {
            LPSTR psz;
            /*
             * Contents needs to be ANSI.
             */
            cbLen = (wcslen(pstr) + 1) * sizeof(WCHAR);
            cbSrc = min(cbSrc, cbLen);
            psz = UserLocalAlloc(HEAP_ZERO_MEMORY, cbSrc);
            if (psz != NULL) {
                if (NT_SUCCESS(RtlUnicodeToMultiByteN(
                        psz,
                        cbSrc,
                        NULL,
                        (PWSTR)pstr,
                        cbSrc))) {
                    USERGLOBALUNLOCK(*phCommands);
                    if ((hTemp = GlobalReAlloc(
                            *phCommands,
                            cbSrc / sizeof(WCHAR),
                            GMEM_MOVEABLE)) != NULL) {
                        fHandleValueChanged = (hTemp != *phCommands);
                        *phCommands = hTemp;
                        USERGLOBALLOCK(*phCommands, pstr);
                        UserAssert(pstr);
                        psz[cbSrc - 1] = '\0';
                        strcpy(pstr, psz);
                    }
                }
                UserLocalFree(psz);
            }
        }
        USERGLOBALUNLOCK(*phCommands);
    }
    return(fHandleValueChanged);
}



/*
 * Allocates and locks global handles as appropriate in preperation
 * for thunk copying.
 */
HANDLE _ClientCopyDDEOut1(
    PINTDDEINFO pi)
{
    HANDLE hDdePack = NULL;
    PDDEPACK pDdePack = NULL;

    if (pi->flags & XS_PACKED) {
        /*
         * make a wrapper for the data
         */
        hDdePack = UserGlobalAlloc(GMEM_DDESHARE | GMEM_FIXED,
                sizeof(DDEPACK));
        pDdePack = (PDDEPACK)hDdePack;
        if (pDdePack == NULL) {
            RIPMSG0(RIP_WARNING, "_ClientCopyDDEOut1:Couldn't allocate DDEPACK");
            return (NULL);
        }
        *pDdePack = pi->DdePack;
    }

    if (pi->cbDirect) {
        pi->hDirect = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, pi->cbDirect);
        if (pi->hDirect == NULL) {
            RIPMSG0(RIP_WARNING, "_ClientCopyDDEOut1:Couldn't allocate hDirect");
            if (hDdePack) {
                UserGlobalFree(hDdePack);
            }
            return (NULL);
        }

        USERGLOBALLOCK(pi->hDirect, pi->pDirect);
        UserAssert(pi->pDirect);

        // fixup packed data reference to direct data

        if (pDdePack != NULL) {
            if (pi->flags & XS_LOHANDLE) {
                pDdePack->uiLo = (UINT_PTR)pi->hDirect;
                UserAssert((ULONG_PTR)pDdePack->uiLo == (ULONG_PTR)pi->hDirect);
            } else if (pi->flags & XS_HIHANDLE) {
                pDdePack->uiHi = (UINT_PTR)pi->hDirect;
                UserAssert((ULONG_PTR)pDdePack->uiHi == (ULONG_PTR)pi->hDirect);
            }
        }

        if (pi->cbIndirect) {
            pi->hIndirect = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE,
                    pi->cbIndirect);
            if (pi->hIndirect == NULL) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEOut1:Couldn't allocate hIndirect");
                USERGLOBALUNLOCK(pi->hDirect);
                UserGlobalFree(pi->hDirect);
                if (hDdePack) {
                    UserGlobalFree(hDdePack);
                }
                return (NULL);
            }
            USERGLOBALLOCK(pi->hIndirect, pi->pIndirect);
            UserAssert(pi->pIndirect);
        }
    }

    if (hDdePack) {
        return (hDdePack);
    } else {
        return (pi->hDirect);
    }
}



/*
 * Fixes up internal poniters after thunk copy and unlocks handles.
 */
BOOL _ClientCopyDDEOut2(
    PINTDDEINFO pi)
{
    BOOL fSuccess = TRUE;
    /*
     * done with copies - now fixup indirect references
     */
    if (pi->hIndirect) {
        PDDE_DATA pDdeData = (PDDE_DATA)pi->pDirect;

        switch (pDdeData->wFmt) {
        case CF_BITMAP:
        case CF_DSPBITMAP:
        case CF_PALETTE:
            pDdeData->Data = (KERNEL_PVOID)pi->hIndirect;
            fSuccess = (pDdeData->Data != NULL);
            break;

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
            pDdeData->Data = (KERNEL_PVOID)GdiCreateLocalMetaFilePict(pi->hIndirect);
            fSuccess = (pDdeData->Data != NULL);
            break;

        case CF_DIB:
            pDdeData->Data = (KERNEL_PVOID)pi->hIndirect;
            fSuccess = (pDdeData->Data != NULL);
            USERGLOBALUNLOCK(pi->hIndirect);
            break;

        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
            pDdeData->Data = (KERNEL_PVOID)GdiCreateLocalEnhMetaFile(pi->hIndirect);
            fSuccess = (pDdeData->Data != NULL);
            break;

        default:
            RIPMSG0(RIP_WARNING, "_ClientCopyDDEOut2:Unknown format w/indirect data.");
            fSuccess = FALSE;
            USERGLOBALUNLOCK(pi->hIndirect);
        }
    }

    UserAssert(pi->hDirect); // if its null, we didn't need to call this function.
    USERGLOBALUNLOCK(pi->hDirect);
    if (pi->flags & XS_EXECUTE) {
        /*
         * Its possible that in RAW DDE cases where the app allocated the
         * execute data as non-moveable, we have a different hDirect
         * than we started with.  This needs to be noted and passed
         * back to the server. (Very RARE case)
         */
        FixupDdeExecuteIfNecessary(&pi->hDirect,
                pi->flags & XS_UNICODE);
    }
    return fSuccess;
}



/*
 * This routine is called by the tracking layer when it frees DDE objects
 * on behalf of a client.   This cleans up the LOCAL objects associated
 * with the DDE objects.  It should NOT remove truely global objects such
 * as bitmaps or palettes except in the XS_DUMPMSG case which is for
 * faked Posts.
 */

#if DBG
    /*
     * Help track down a bug where I suspect the xxxFreeListFree is
     * freeing a handle already freed by some other means which has
     * since been reallocated and is trashing the client heap. (SAS)
     */
    HANDLE DDEHandleLastFreed = 0;
#endif

BOOL _ClientFreeDDEHandle(
HANDLE hDDE,
DWORD flags)
{
    PDDEPACK pDdePack;
    HANDLE hNew;

    if (flags & XS_PACKED) {
        pDdePack = (PDDEPACK)hDDE;
        if (pDdePack == NULL) {
            return (FALSE);
        }
        if (flags & XS_LOHANDLE) {
            hNew = (HANDLE)pDdePack->uiLo;
        } else {
            hNew = (HANDLE)pDdePack->uiHi;

        }
        WOWGLOBALFREE(hDDE);
        hDDE = hNew;

    }

   /*
    * Do a range check and call GlobalFlags to validate, just to prevent heap checking
    * from complaining during the GlobalSize call.
    * Is this leaking atoms??
    */
    if ((hDDE <= (HANDLE)0xFFFF)
        || (GlobalFlags(hDDE) == GMEM_INVALID_HANDLE)
        || !GlobalSize(hDDE)) {
            /*
             * There may be cases where apps improperly freed stuff
             * when they shouldn't have so make sure this handle
             * is valid by the time it gets here.
             *
             * See SvSpontAdvise; it posts a message with an atom in uiHi. Then from _PostMessage
             *  in the kernel side, we might end up here. So it's not only for apps...
             */
            return(FALSE);
    }

    if (flags & XS_DUMPMSG) {
        if (flags & XS_PACKED) {
            if (!IS_PTR(hNew)) {
                GlobalDeleteAtom(LOWORD((ULONG_PTR)hNew));
                if (!(flags & XS_DATA)) {
                    return(TRUE);     // ACK
                }
            }
        } else {
            if (!(flags & XS_EXECUTE)) {
                GlobalDeleteAtom(LOWORD((ULONG_PTR)hDDE));   // REQUEST, UNADVISE
                return(TRUE);
            }
        }
    }
    if (flags & XS_DATA) {
        // POKE, DATA
#if DBG
        DDEHandleLastFreed = hDDE;
#endif
        FreeDDEData(hDDE,
                (flags & XS_DUMPMSG) ? FALSE : TRUE,    // fIgnorefRelease
                (flags & XS_DUMPMSG) ? TRUE : FALSE);    // fDestroyTruelyGlobalObjects
    } else {
        // ADVISE, EXECUTE
#if DBG
        DDEHandleLastFreed = hDDE;
#endif
        WOWGLOBALFREE(hDDE);   // covers ADVISE case (fmt but no data)
    }
    return (TRUE);
}


DWORD _ClientGetDDEFlags(
HANDLE hDDE,
DWORD flags)
{
    PDDEPACK pDdePack;
    PWORD pw;
    HANDLE hData;
    DWORD retval = 0;

    pDdePack = (PDDEPACK)hDDE;
    if (pDdePack == NULL) {
        return (0);
    }

    if (flags & XS_DATA) {
        if (pDdePack->uiLo) {
            hData = (HANDLE)pDdePack->uiLo;
            USERGLOBALLOCK(hData, pw);
            if (pw != NULL) {
                retval = (DWORD)*pw; // first word is hData is wStatus
                USERGLOBALUNLOCK(hData);
            }
        }
    } else {
        retval = (DWORD)pDdePack->uiLo;
    }

    return (retval);
}



FUNCLOG3(LOG_GENERAL, LPARAM, APIENTRY, PackDDElParam, UINT, msg, UINT_PTR, uiLo, UINT_PTR, uiHi)
LPARAM APIENTRY PackDDElParam(
UINT msg,
UINT_PTR uiLo,
UINT_PTR uiHi)
{
    PDDEPACK pDdePack;
    HANDLE h;

    switch (msg) {
    case WM_DDE_EXECUTE:
        return((LPARAM)uiHi);

    case WM_DDE_ACK:
    case WM_DDE_ADVISE:
    case WM_DDE_DATA:
    case WM_DDE_POKE:
        h = UserGlobalAlloc(GMEM_DDESHARE | GMEM_FIXED, sizeof(DDEPACK));
        pDdePack = (PDDEPACK)h;
        if (pDdePack == NULL) {
            return(0);
        }
        pDdePack->uiLo = uiLo;
        pDdePack->uiHi = uiHi;
        return((LPARAM)h);

    default:
        return(MAKELONG((WORD)uiLo, (WORD)uiHi));
    }
}




FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, UnpackDDElParam, UINT, msg, LPARAM, lParam, PUINT_PTR, puiLo, PUINT_PTR, puiHi)
BOOL APIENTRY UnpackDDElParam(
UINT msg,
LPARAM lParam,
PUINT_PTR puiLo,
PUINT_PTR puiHi)
{
    PDDEPACK pDdePack;

    switch (msg) {
    case WM_DDE_EXECUTE:
        if (puiLo != NULL) {
            *puiLo = 0L;
        }
        if (puiHi != NULL) {
            *puiHi = (UINT_PTR)lParam;
        }
        return(TRUE);

    case WM_DDE_ACK:
    case WM_DDE_ADVISE:
    case WM_DDE_DATA:
    case WM_DDE_POKE:
        pDdePack = (PDDEPACK)lParam;
        if (pDdePack == NULL || !GlobalHandle(pDdePack)) {
            if (puiLo != NULL) {
                *puiLo = 0L;
            }
            if (puiHi != NULL) {
                *puiHi = 0L;
            }
            return(FALSE);
        }
        if (puiLo != NULL) {
            *puiLo = pDdePack->uiLo;
        }
        if (puiHi != NULL) {
            *puiHi = pDdePack->uiHi;
        }
        return(TRUE);

    default:
        if (puiLo != NULL) {
            *puiLo = (UINT)LOWORD(lParam);
        }
        if (puiHi != NULL) {
            *puiHi = (UINT)HIWORD(lParam);
        }
        return(TRUE);
    }
}




FUNCLOG2(LOG_GENERAL, BOOL, APIENTRY, FreeDDElParam, UINT, msg, LPARAM, lParam)
BOOL APIENTRY FreeDDElParam(
UINT msg,
LPARAM lParam)
{
    switch (msg) {
    case WM_DDE_ACK:
    case WM_DDE_ADVISE:
    case WM_DDE_DATA:
    case WM_DDE_POKE:
        /*
         * Do a range check and call GlobalFlags to validate,
         * just to prevent heap checking from complaining
         */
        if ((lParam > (LPARAM)0xFFFF) && GlobalFlags((HANDLE)lParam) != GMEM_INVALID_HANDLE) {
            if (GlobalHandle((HANDLE)lParam))
                return(UserGlobalFree((HANDLE)lParam) == NULL);
        }

    default:
        return(TRUE);
    }
}



FUNCLOG5(LOG_GENERAL, LPARAM, APIENTRY, ReuseDDElParam, LPARAM, lParam, UINT, msgIn, UINT, msgOut, UINT_PTR, uiLo, UINT_PTR, uiHi)
LPARAM APIENTRY ReuseDDElParam(
LPARAM lParam,
UINT msgIn,
UINT msgOut,
UINT_PTR uiLo,
UINT_PTR uiHi)
{
    PDDEPACK pDdePack;

    switch (msgIn) {
    case WM_DDE_ACK:
    case WM_DDE_DATA:
    case WM_DDE_POKE:
    case WM_DDE_ADVISE:
        //
        // Incoming message was packed...
        //
        switch (msgOut) {
        case WM_DDE_EXECUTE:
            FreeDDElParam(msgIn, lParam);
            return((LPARAM)uiHi);

        case WM_DDE_ACK:
        case WM_DDE_ADVISE:
        case WM_DDE_DATA:
        case WM_DDE_POKE:
            /*
             * This must be a valid handle
             */
            UserAssert(GlobalFlags((HANDLE)lParam) != GMEM_INVALID_HANDLE);
            UserAssert(GlobalSize((HANDLE)lParam) == sizeof(DDEPACK));
            //
            // Actual cases where lParam can be reused.
            //
            pDdePack = (PDDEPACK)lParam;
            if (pDdePack == NULL) {
                return(0);          // the only error case
            }
            pDdePack->uiLo = uiLo;
            pDdePack->uiHi = uiHi;
            return(lParam);


        default:
            FreeDDElParam(msgIn, lParam);
            return(MAKELONG((WORD)uiLo, (WORD)uiHi));
        }

    default:
        //
        // Incoming message was not packed ==> PackDDElParam()
        //
        return(PackDDElParam(msgOut, uiLo, uiHi));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\csrstubs.c ===
/***************************** Module Header ******************************\
* Module Name: csrstubs.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Routines to call CSR
*
* 02-27-95 JimA             Created.
*
* Note: This file has been partitioned with #if defines so that the LPC
* marshalling code can be inside 64bit code when running under wow64 (32bit on
* 64bit NT). In wow64, the system DLLs for 32bit processes are 32bit.
*
* The marshalling code can only be depedent on functions in NTDLL.
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "csrmsg.h"
#include "csrhlpr.h"
#include "strid.h"
#include <dbt.h>
#include <regstr.h>
#include <winsta.h>     // for WinStationGetTermSrvCountersValue
#include <allproc.h>    // for TS_COUNTER

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

CONST WCHAR gszReliabilityKey[] = L"\\Registry\\Machine\\" REGSTR_PATH_RELIABILITY;
CONST WCHAR gszReliabilityPolicyKey[] = L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows NT\\Reliability";

#if defined(BUILD_CSRWOW64)

#undef RIPERR0
#undef RIPNTERR0
#undef RIPMSG0

#define RIPNTERR0(status, flags, szFmt) {if (NtCurrentTeb()) NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError(status);}
#define RIPERR0(idErr, flags, szFmt) {if (NtCurrentTeb()) NtCurrentTeb()->LastErrorValue = (idErr);}
#define RIPMSG0(flags, szFmt)

#endif

#define SET_LAST_ERROR_RETURNED()   if (a->dwLastError) RIPERR0(a->dwLastError, RIP_VERBOSE, "")

#if !defined(BUILD_WOW6432)

NTSTATUS
APIENTRY
CallUserpExitWindowsEx(
    IN UINT uFlags,
    OUT PBOOL pfSuccess)
{

    USER_API_MSG m;
    PEXITWINDOWSEXMSG a = &m.u.ExitWindowsEx;

    a->uFlags = uFlags;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                              UserpExitWindowsEx
                                            ),
                         sizeof( *a )
                       );

    if (NT_SUCCESS( m.ReturnValue ) || m.ReturnValue == STATUS_CANT_WAIT) {
        SET_LAST_ERROR_RETURNED();
        *pfSuccess = a->fSuccess;
    } else {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "");
        *pfSuccess = FALSE;
    }

    return m.ReturnValue;

}

#endif

#if !defined(BUILD_CSRWOW64)

typedef struct _EXITWINDOWSDATA {
    UINT uFlags;
} EXITWINDOWSDATA, *PEXITWINDOWSDATA;

__inline void GetShutdownType(LPWSTR pszBuff, int cch, DWORD dwFlags)
{
    if ((dwFlags & (EWX_POWEROFF | EWX_WINLOGON_OLD_POWEROFF)) != 0) {
        LoadString(hmodUser, STR_SHUTDOWN_POWEROFF, pszBuff, cch);
    } else if ((dwFlags & (EWX_REBOOT | EWX_WINLOGON_OLD_REBOOT)) != 0) {
        LoadString(hmodUser, STR_SHUTDOWN_REBOOT, pszBuff, cch);
    } else if ((dwFlags & (EWX_SHUTDOWN | EWX_WINLOGON_OLD_SHUTDOWN)) != 0) {
        LoadString(hmodUser, STR_SHUTDOWN_SHUTDOWN, pszBuff, cch);
    } else {
        LoadString(hmodUser, STR_UNKNOWN, pszBuff, cch);
    }
}

/***************************************************************************\
* CsrTestShutdownPrivilege
*
* Looks at the user token to determine if they have shutdown privilege
*
* Returns TRUE if the user has the privilege, otherwise FALSE
*
\***************************************************************************/
BOOL
CsrTestShutdownPrivilege(
    HANDLE UserToken
    )
{
    NTSTATUS    Status;
    LUID        LuidPrivilege = RtlConvertLongToLuid(SE_SHUTDOWN_PRIVILEGE);
    LUID        TokenPrivilege;
    ULONG       BytesRequired;
    ULONG       i;
    BOOL        bHasPrivilege = FALSE;
    BOOL        bNetWork = FALSE;
    PSID        NetworkSid = NULL;
    PTOKEN_PRIVILEGES Privileges = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    Status = RtlAllocateAndInitializeSid(&NtAuthority,
                                          1, SECURITY_NETWORK_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &NetworkSid );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    // Ok for this call to fail, in that case we assume local shutdown.
    if (CheckTokenMembership(UserToken, NetworkSid, &bNetWork)) {
        if (bNetWork) {
            LuidPrivilege = RtlConvertLongToLuid(SE_REMOTE_SHUTDOWN_PRIVILEGE);
        }
    }

    Status = NtQueryInformationToken(
                 UserToken,
                 TokenPrivileges,
                 NULL,
                 0,
                 &BytesRequired
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        goto Cleanup;
    }

    Privileges = (PTOKEN_PRIVILEGES)UserLocalAlloc(HEAP_ZERO_MEMORY,
                                                   BytesRequired);
    if (Privileges == NULL) {
        goto Cleanup;
    }

    Status = NtQueryInformationToken(
                 UserToken,
                 TokenPrivileges,
                 Privileges,
                 BytesRequired,
                 &BytesRequired
                 );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    for (i=0; i<Privileges->PrivilegeCount; i++) {
        TokenPrivilege = *((LUID UNALIGNED *) &Privileges->Privileges[i].Luid);
        if (RtlEqualLuid(&TokenPrivilege, &LuidPrivilege)) {
            bHasPrivilege = TRUE;
            break;
        }
    }

Cleanup:
    if (NetworkSid) {
        RtlFreeSid(NetworkSid);
    }

    if (Privileges) {
        UserLocalFree(Privileges);
    }
    return bHasPrivilege;
}

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, RecordShutdownReason, PSHUTDOWN_REASON, psr)
BOOL RecordShutdownReason(
    PSHUTDOWN_REASON psr)
{
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
    HANDLE  hToken = NULL;
    DWORD   dwEventID;
    DWORD   dwTotalLen = 0;     // length for the capture buffer.
    DWORD   dwCntPointers = 0;  // number of message pointers for the capture buffer.
    DWORD   dwProcessNameLen = MAX_PATH + 1;
    DWORD   dwShutdownTypeLen = SHUTDOWN_TYPE_LEN;
    BOOL    bRet = FALSE;
    LPWSTR  lpszBuf = NULL;
    USER_API_MSG m;
    NTSTATUS status;
    PRECORDSHUTDOWNREASONMSG a = &(m.u.RecordShutdownReason);

    // Check privilege. We dont want a user without shutdown privilege to call this.
    status = NtOpenThreadToken(NtCurrentThread(),TOKEN_QUERY, FALSE, &hToken);
    if (!NT_SUCCESS(status)) {
        status = NtOpenThreadToken(NtCurrentThread(),TOKEN_QUERY, TRUE, &hToken);
        if (!NT_SUCCESS(status)) {
            status = NtOpenProcessToken(NtCurrentProcess(),TOKEN_QUERY, &hToken);
            if (!NT_SUCCESS(status)) {
                RIPNTERR0(status, RIP_WARNING, "Cannot get token in RecordShutdownReason");
                goto Cleanup;
            }
        }
    }

    if (!CsrTestShutdownPrivilege(hToken)) {
        NtClose(hToken);
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Access denied in RecordShutdownReason");
        goto Cleanup;
    }
    NtClose(hToken);

    // Validate the structure
    if (psr == NULL || psr->cbSize != sizeof(SHUTDOWN_REASON)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Bad psr %p in RecordShutdownReason", psr);
        goto Cleanup;
    }

    dwCntPointers = 3;
    dwTotalLen = dwProcessNameLen * sizeof(WCHAR) + dwShutdownTypeLen * sizeof(WCHAR) + sizeof(SHUTDOWN_REASON);

    // Initialize all lengthes to 0
    a->dwProcessNameLen = a->dwShutdownTypeLen = a->dwCommentLen = 0;

    // Add Comment if we have one.
    if (psr->lpszComment && wcslen(psr->lpszComment)) {
        dwCntPointers++;
        a->dwCommentLen = wcslen(psr->lpszComment) + 1;
        dwTotalLen += a->dwCommentLen * sizeof(WCHAR);
    }

    // Adjust for the possible round up.
    dwTotalLen += dwCntPointers * (sizeof(PVOID) - 1);

    CaptureBuffer = CsrAllocateCaptureBuffer(dwCntPointers, dwTotalLen);
    if (CaptureBuffer == NULL) {
        goto Cleanup;
    }

    // lpszBuf is shared for both process name and shutdown type.
    // Make sure the len is the maximum of all of them.
    lpszBuf = (LPWSTR)UserLocalAlloc(0, (dwProcessNameLen >= dwShutdownTypeLen ?
                            dwProcessNameLen : dwShutdownTypeLen) * sizeof(WCHAR));
    if (!lpszBuf) {
        goto Cleanup;
    }

    // Fill the process name
    if (!GetCurrentProcessName(lpszBuf, dwProcessNameLen)) {
        RIPMSG0(RIP_WARNING, "Failed to GetCurrentProcessName in RecordShutdownReason");
        goto Cleanup;
    }
    lpszBuf[MAX_PATH] = 0;
    a->dwProcessNameLen = wcslen(lpszBuf)+1;
    CsrAllocateMessagePointer(CaptureBuffer, ALIGN_UP(a->dwProcessNameLen * sizeof(WCHAR), PVOID), &a->pwchProcessName);
    wcscpy(a->pwchProcessName, lpszBuf);

    // Fill the shutdown type.
    GetShutdownType(lpszBuf, dwShutdownTypeLen, psr->uFlags);
    lpszBuf[SHUTDOWN_TYPE_LEN-1] = 0;
    a->dwShutdownTypeLen = wcslen(lpszBuf)+1;
    CsrAllocateMessagePointer(CaptureBuffer, ALIGN_UP(a->dwShutdownTypeLen * sizeof(WCHAR), PVOID), &a->pwchShutdownType);
    wcscpy(a->pwchShutdownType, lpszBuf);

    // copy over the SHUTDOWN_REASON.
    CsrAllocateMessagePointer(CaptureBuffer, ALIGN_UP(sizeof(SHUTDOWN_REASON), PVOID), &a->psr);
    memcpy(a->psr, psr, sizeof(SHUTDOWN_REASON));

    if (psr->lpszComment && !wcslen(psr->lpszComment)) {
        a->psr->lpszComment = NULL;
    }

    if (psr->lpszComment && wcslen(psr->lpszComment)){
        CsrAllocateMessagePointer(CaptureBuffer, ALIGN_UP(a->dwCommentLen * sizeof(WCHAR), PVOID), &a->pwchComment);
        wcscpy(a->pwchComment, psr->lpszComment);
    }

    switch (psr->dwEventType) {
    case SR_EVENT_EXITWINDOWS:
        if (psr->fShutdownCancelled) {
            dwEventID = WARNING_EW_SHUTDOWN_CANCELLED;
        } else {
            dwEventID = STATUS_SHUTDOWN_CLEAN;
        }
        break;
    case SR_EVENT_INITIATE_CLEAN:
        dwEventID = STATUS_SHUTDOWN_CLEAN;
        break;
    case SR_EVENT_INITIATE_CLEAN_ABORT:
        dwEventID = WARNING_ISSE_SHUTDOWN_CANCELLED;
        break;
    case SR_EVENT_DIRTY:
        dwEventID = WARNING_DIRTY_REBOOT;
        break;
    default:
        goto Cleanup;
    }

    a->dwEventID = dwEventID;
    a->dwEventType = psr->dwEventType;
    a->fShutdownCancelled = psr->fShutdownCancelled;

    status = CsrClientCallServer((PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX,
                                              UserpRecordShutdownReason
                                            ),
                         sizeof(*a)
                       );

    bRet = NT_SUCCESS(status);

Cleanup:
    if (CaptureBuffer) {
        CsrFreeCaptureBuffer(CaptureBuffer);
    }

    if (lpszBuf) {
        UserLocalFree(lpszBuf);
    }

    return bRet;
}

UINT GetLoggedOnUserCount(
    VOID)
{
    int iCount = 0;
    BOOLEAN bSuccess;

    TS_COUNTER TSCountersDyn[2];

    TSCountersDyn[0].counterHead.dwCounterID = TERMSRV_CURRENT_DISC_SESSIONS;
    TSCountersDyn[1].counterHead.dwCounterID = TERMSRV_CURRENT_ACTIVE_SESSIONS;

    // access the termsrv counters to find out how many users are logged onto the system
    bSuccess = WinStationGetTermSrvCountersValue(SERVERNAME_CURRENT, 2, TSCountersDyn);

    if (bSuccess) {
        if (TSCountersDyn[0].counterHead.bResult)
            iCount += TSCountersDyn[0].dwValue;

        if (TSCountersDyn[1].counterHead.bResult)
            iCount += TSCountersDyn[1].dwValue;
    }

    return iCount;
}

BOOL IsSeShutdownNameEnabled()
{
    BOOL bRet = FALSE;  // assume the privilege is not held
    NTSTATUS Status;
    HANDLE hToken;

    // try to get the thread token
    Status = NtOpenThreadToken(GetCurrentThread(),
                               TOKEN_QUERY,
                               FALSE,
                               &hToken);
    if (!NT_SUCCESS(Status)) {
        // try the process token if we failed to get the thread token
        Status = NtOpenProcessToken(GetCurrentProcess(),
                                    TOKEN_QUERY,
                                    &hToken);
    }

    if (NT_SUCCESS(Status)) {
        DWORD cbSize = 0;
        TOKEN_PRIVILEGES* ptp;

        NtQueryInformationToken(hToken,
                                TokenPrivileges,
                                NULL,
                                0,
                                &cbSize);
        if (cbSize) {
            ptp = (TOKEN_PRIVILEGES*)UserLocalAlloc(0, cbSize);
        } else {
            ptp = NULL;
        }

        if (ptp) {
            Status = NtQueryInformationToken(hToken,
                                             TokenPrivileges,
                                             ptp,
                                             cbSize,
                                             &cbSize);
            if (NT_SUCCESS(Status)) {
                DWORD i;
                for (i = 0; i < ptp->PrivilegeCount; i++) {
                    if (((ptp->Privileges[i].Luid.HighPart == 0) && (ptp->Privileges[i].Luid.LowPart == SE_SHUTDOWN_PRIVILEGE)) &&
                        (ptp->Privileges[i].Attributes & (SE_PRIVILEGE_ENABLED_BY_DEFAULT | SE_PRIVILEGE_ENABLED))) {
                        // found the privilege and it is enabled
                        bRet = TRUE;
                        break;
                    }
                }
            }

            UserLocalFree(ptp);
        }

        NtClose(hToken);
    }

    return bRet;
}

BOOL NeedsDisplayWarning (UINT uNumUsers, UINT uExitWindowsFlags)
{

    //  If EWX_SYSTEM_CALLER then there's nobody on this session.
    //  Add one from the number of users.

    if ((uExitWindowsFlags & EWX_SYSTEM_CALLER) && (uNumUsers > 0))
    {
        ++uNumUsers;
    }

    //  If number of users > 1 or EWX_WINLOGON_CALLER display warning.

    return (uNumUsers > 1) || (uExitWindowsFlags & EWX_WINLOGON_CALLER);
}

FUNCLOG1(LOG_GENERAL, BOOL, APIENTRY, DisplayExitWindowsWarnings, UINT, uExitWindowsFlags)
BOOL APIENTRY DisplayExitWindowsWarnings(UINT uExitWindowsFlags)
{
    BOOL bContinue = TRUE;
    BOOL fIsRemote = ISREMOTESESSION();
    UINT uNumUsers = GetLoggedOnUserCount();
    UINT uID = 0;

    // it would be nice to check the HKCU\ControlPanel\Desktop\AutoEndTask value and not display any UI if it is set,
    // but since we are called from services it is probably better to not go mucking about in the per-user hive

    if (uExitWindowsFlags & (EWX_POWEROFF | EWX_WINLOGON_OLD_POWEROFF | EWX_SHUTDOWN | EWX_WINLOGON_OLD_SHUTDOWN)) {
        if (fIsRemote) {
            if (NeedsDisplayWarning(uNumUsers, uExitWindowsFlags)) {
                // Warn the user if remote shut down w/ active users
                uID = IDS_SHUTDOWN_REMOTE_OTHERUSERS;
            } else {
                // Warn the user of remote shut down (cut our own legs off!)
                uID = IDS_SHUTDOWN_REMOTE;
            }
        }  else {
            if (NeedsDisplayWarning(uNumUsers, uExitWindowsFlags)) {
                //  Warn the user if more than one user session active
                uID = IDS_SHUTDOWN_OTHERUSERS;
            }
        }
    } else if (uExitWindowsFlags & (EWX_REBOOT | EWX_WINLOGON_OLD_REBOOT)) {
        //  Warn the user if more than one user session active.
        if (NeedsDisplayWarning(uNumUsers, uExitWindowsFlags)) {
            uID = IDS_RESTART_OTHERUSERS;
        }
    }

    if (uID != 0) {
        TCHAR szTitle[MAX_PATH];
        TCHAR szMessage[MAX_PATH];
        DWORD dwTimeout = INFINITE;
        UNICODE_STRING UnicodeString;
        extern CONST WCHAR szWindowsKey[];
        static CONST WCHAR szTimeout[] = L"ShutdownWarningDialogTimeout";
        OBJECT_ATTRIBUTES OA;
        HANDLE hKey;
        DWORD cbSize;
        struct {
            KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
            DWORD dwTimeout;
        } KeyTimeout;

        RtlInitUnicodeString(&UnicodeString, szWindowsKey);
        InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

        if (NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &OA))) {
            NTSTATUS rc;

            RtlInitUnicodeString(&UnicodeString, szTimeout);

            rc = NtQueryValueKey(hKey,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 &KeyTimeout,
                                 sizeof KeyTimeout,
                                 &cbSize);
            if (NT_SUCCESS(rc)) {
                dwTimeout = *((PDWORD)KeyTimeout.KeyInfo.Data);
                RIPMSGF1(RIP_VERBOSE, "ShutdownWarningTimeout: set by the reg: %d", dwTimeout);
            }

            NtClose(hKey);
        }

        LoadString(hmodUser, IDS_EXITWINDOWS_TITLE, szTitle, sizeof(szTitle)/sizeof(szTitle[0]));
        LoadString(hmodUser, uID, szMessage, sizeof(szMessage)/sizeof(szMessage[0]));

        // We want to display the message box to be displayed to the user, and since this can be called from winlogon/services
        // we need to pass the MB_SERVICE_NOTIFICATION flag.
        if (MessageBoxTimeout(NULL, szMessage, szTitle,
                              MB_ICONEXCLAMATION | MB_YESNO | MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_SETFOREGROUND,
                              0, dwTimeout) == IDNO) {
            bContinue = FALSE;
        }
    }

    return bContinue;
}

DWORD ExitWindowsThread(PVOID pvParam);

BOOL WINAPI ExitWindowsWorker(
    UINT uFlags,
    BOOL fSecondThread)
{
    EXITWINDOWSDATA ewd;
    HANDLE hThread;
    DWORD dwThreadId;
    DWORD dwExitCode;
    DWORD idWait;
    MSG msg;
    BOOL fSuccess;
    NTSTATUS Status;

    /*
     * Force a connection so apps will have a windowstation
     * to log off of.
     */
    if (PtiCurrent() == NULL) {
        return FALSE;
    }

    /*
     * Check for UI restrictions
     */
    if (!NtUserCallOneParam((ULONG_PTR)uFlags, SFI_PREPAREFORLOGOFF)) {
        RIPMSG0(RIP_WARNING, "ExitWindows called by a restricted thread\n");
        return FALSE;
    }

    Status = CallUserpExitWindowsEx(uFlags, &fSuccess);

    if (NT_SUCCESS( Status )) {
        return fSuccess;
    } else if (Status == STATUS_CANT_WAIT && !fSecondThread) {
        ewd.uFlags = uFlags;
        hThread = CreateThread(NULL, 0, ExitWindowsThread, &ewd,
                0, &dwThreadId);
        if (hThread == NULL) {
            return FALSE;
        }

        while (1) {
            idWait = MsgWaitForMultipleObjectsEx(1, &hThread,
                    INFINITE, QS_ALLINPUT, 0);

            /*
             * If the thread was signaled, we're done.
             */
            if (idWait == WAIT_OBJECT_0) {
                break;
            }

            /*
             * Process any waiting messages
             */
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                DispatchMessage(&msg);
            }
        }
        GetExitCodeThread(hThread, &dwExitCode);
        NtClose(hThread);
        if (dwExitCode == ERROR_SUCCESS) {
            return TRUE;
        } else {
            RIPERR0(dwExitCode, RIP_VERBOSE, "");
            return FALSE;
        }
    } else {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return FALSE;
    }
}

DWORD ExitWindowsThread(
    PVOID pvParam)
{
    PEXITWINDOWSDATA pewd = pvParam;
    DWORD dwExitCode;

    if (ExitWindowsWorker(pewd->uFlags, TRUE)) {
        dwExitCode = 0;
    } else {
        dwExitCode = GetLastError();
    }

    ExitThread(dwExitCode);
    return 0;
}

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, ExitWindowsEx, UINT, uFlags, DWORD, dwReasonCode)
BOOL WINAPI ExitWindowsEx(
    UINT uFlags,
    DWORD dwReasonCode)
{
    BOOL bSuccess;
    BOOL bShutdown = (uFlags & SHUTDOWN_FLAGS) != 0;
    SHUTDOWN_REASON sr;

    /*
     * Check to see if we should bring up UI warning that there are other
     * Terminal Server users connected to this machine. We only do this if the
     * caller has not specified the EWX_FORCE option.
     */
    if (bShutdown && !(uFlags & EWX_FORCE)) {
        /*
         * We don't want to display the warning dialog twice! (this function
         * can be called by an application and again by winlogon in response to
         * the first call)
         */
        if (!gfLogonProcess || (uFlags & EWX_WINLOGON_INITIATED)) {
            /*
             * Don't put up UI if termsrv is our caller. Termsrv uses this api to shutdown winlogon
             * on session 0 when a shutdown was initiated from a different session.
             */
            if (!(uFlags & EWX_TERMSRV_INITIATED)) {
                /*
                 * There are a bunch of lame apps (including InstallShield v5.1) that call ExitWindowsEx and then when it fails
                 * they go and enable the SE_SHUTDOWN_NAME privilege and then us call again. The problem is that we end up prompting the
                 * user twice in these cases. So before we put up any UI we check for the SE_SHUTDOWN_NAME privilege.
                 */
                if (IsSeShutdownNameEnabled()) {
                    if (!DisplayExitWindowsWarnings(uFlags & ~(EWX_WINLOGON_CALLER | EWX_SYSTEM_CALLER))) {
                        /*
                         * We need to log a cancel event if SET is enabled.
                         */
                        if (IsSETEnabled()) {
                            SHUTDOWN_REASON sr;
                            sr.cbSize = sizeof(SHUTDOWN_REASON);
                            sr.uFlags = uFlags;
                            sr.dwReasonCode = 0;
                            sr.fShutdownCancelled = TRUE;
                            sr.dwEventType = SR_EVENT_EXITWINDOWS;
                            sr.lpszComment = NULL;
                            RecordShutdownReason(&sr);
                        }

                        /*
                         * We only want to return the real error code if our caller was winlogon. We lie
                         * to everyone else and tell them that everything succeeded. If we return failure
                         * when the user cancel's the operation, a some of apps just call ExitWindowsEx
                         * again, causing another dialog.
                         */
                        if (uFlags & EWX_WINLOGON_INITIATED) {
                            SetLastError(ERROR_CANCELLED);
                            return FALSE;
                        } else {
                            return TRUE;
                        }
                    }
                }
            }
        }
    }

    sr.cbSize = sizeof(SHUTDOWN_REASON);
    sr.uFlags = uFlags;
    sr.dwReasonCode = dwReasonCode;
    sr.fShutdownCancelled = FALSE;
    sr.dwEventType = SR_EVENT_EXITWINDOWS;
    sr.lpszComment = NULL;

    /*
     * If this is winlogon initiating the shutdown, we need to log before
     * calling ExitWindowsWorker. Otherwise, if the user or an app cancels the
     * shutdown, the cancel event will be logged before the initial shutdown
     * event.
     */
    if (gfLogonProcess && bShutdown && (uFlags & EWX_WINLOGON_INITIATED) != 0) {
        if (IsSETEnabled()) {
            RecordShutdownReason(&sr);
        }
    }

    bSuccess = ExitWindowsWorker(uFlags, FALSE);

    /*
     * Log this shutdown if:
     * 1) We're not winlogon (if we are, we might have logged above).
     * 2) The shutdown (inititally, at least) succeeded.
     * 3) We're actually shutting down (i.e., not logging off).
     * 4) The registry key telling us to log is set.
     */
    if (!gfLogonProcess && bSuccess && bShutdown && IsSETEnabled()) {
        RecordShutdownReason(&sr);
    }

    return bSuccess;
}

#endif

#if !defined(BUILD_WOW6432)

BOOL WINAPI EndTask(
    HWND hwnd,
    BOOL fShutdown,
    BOOL fForce)
{
    USER_API_MSG m;
    PENDTASKMSG a = &m.u.EndTask;

    UNREFERENCED_PARAMETER(fShutdown);
    a->hwnd = hwnd;
    a->fForce = fForce;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                              UserpEndTask
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        SET_LAST_ERROR_RETURNED();
        return a->fSuccess;
    } else {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "");
        return FALSE;
    }
}

VOID
APIENTRY
Logon(
    BOOL fLogon)
{
    USER_API_MSG m;
    PLOGONMSG a = &m.u.Logon;

    a->fLogon = fLogon;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                              UserpLogon
                                            ),
                         sizeof(*a)
                       );
}

NTSTATUS
APIENTRY
CallUserpRegisterLogonProcess(
    IN DWORD dwProcessId)
{

    USER_API_MSG m;
    PLOGONMSG a = &m.u.Logon;
    NTSTATUS Status;

    m.u.IdLogon = dwProcessId;
    Status = CsrClientCallServer( (PCSR_API_MSG)&m,
                                  NULL,
                                  CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                                       UserpRegisterLogonProcess),
                                  sizeof(*a));

    return Status;
}

#endif

#if !defined(BUILD_CSRWOW64)

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, RegisterLogonProcess, DWORD, dwProcessId, BOOL, fSecure)
BOOL RegisterLogonProcess(
    DWORD dwProcessId,
    BOOL fSecure)
{
    gfLogonProcess = (BOOL)NtUserCallTwoParam(dwProcessId, fSecure,
            SFI__REGISTERLOGONPROCESS);

    /*
     * Now, register the logon process into winsrv.
     */
    if (gfLogonProcess) {
        CallUserpRegisterLogonProcess(dwProcessId);
    }

    return gfLogonProcess;
}

#endif

#if !defined(BUILD_WOW6432)

BOOL
WINAPI
RegisterServicesProcess(
    DWORD dwProcessId)
{
    USER_API_MSG m;
    PREGISTERSERVICESPROCESSMSG a = &m.u.RegisterServicesProcess;

    a->dwProcessId = dwProcessId;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                              UserpRegisterServicesProcess
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        SET_LAST_ERROR_RETURNED();
        return a->fSuccess;
    } else {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "");
        return FALSE;
    }
}

HDESK WINAPI GetThreadDesktop(
    DWORD dwThreadId)
{
    USER_API_MSG m;
    PGETTHREADCONSOLEDESKTOPMSG a = &m.u.GetThreadConsoleDesktop;

    a->dwThreadId = dwThreadId;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                              UserpGetThreadConsoleDesktop
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return NtUserGetThreadDesktop(dwThreadId, a->hdeskConsole);
    } else {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "");
        return NULL;
    }
}


/**************************************************************************\
* DeviceEventWorker
*
* This is a private (not publicly exported) interface that the user-mode
* pnp manager calls when it needs to send a WM_DEVICECHANGE message to a
* specific window handle. The user-mode pnp manager is a service within
* services.exe and as such is not on the interactive window station and
* active desktop, so it can't directly call SendMessage. For broadcasted
* messages (messages that go to all top-level windows), the user-mode pnp
* manager calls BroadcastSystemMessage directly.
*
* PaulaT 06/04/97
*
\**************************************************************************/
ULONG
WINAPI
DeviceEventWorker(
    IN HWND    hWnd,
    IN WPARAM  wParam,
    IN LPARAM  lParam,
    IN DWORD   dwFlags,
    OUT PDWORD pdwResult)
{
    USER_API_MSG m;
    PDEVICEEVENTMSG a = &m.u.DeviceEvent;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
    int cb = 0;

    a->hWnd     = hWnd;
    a->wParam   = wParam;
    a->lParam   = lParam;
    a->dwFlags  = dwFlags;
    a->dwResult = 0;

    //
    // If lParam is specified, it must be marshalled (see the defines
    // for this structure in dbt.h - the structure always starts with
    // DEV_BROADCAST_HDR structure).
    //

    if (lParam) {

        cb = ((PDEV_BROADCAST_HDR)lParam)->dbch_size;

        CaptureBuffer = CsrAllocateCaptureBuffer(1, cb);
        if (CaptureBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }

        CsrCaptureMessageBuffer(CaptureBuffer,
                                (PCHAR)lParam,
                                cb,
                                (PVOID *)&a->lParam);

        //
        // This ends up calling SrvDeviceEvent routine in the server.
        //

        CsrClientCallServer((PCSR_API_MSG)&m,
                            CaptureBuffer,
                            CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX,
                                                UserpDeviceEvent),
                            sizeof(*a));

        CsrFreeCaptureBuffer(CaptureBuffer);

    } else {

        //
        // This ends up calling SrvDeviceEvent routine in the server.
        //

        CsrClientCallServer((PCSR_API_MSG)&m,
                            NULL,
                            CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX,
                                                UserpDeviceEvent),
                            sizeof(*a));
    }


    if (NT_SUCCESS(m.ReturnValue)) {
        *pdwResult = (DWORD)a->dwResult;
    } else {
        RIPMSG0(RIP_WARNING, "DeviceEventWorker failed.");
    }

    return m.ReturnValue;
}


#if DBG

VOID
APIENTRY
CsrWin32HeapFail(
    IN DWORD dwFlags,
    IN BOOL  bFail)
{
    USER_API_MSG m;
    PWIN32HEAPFAILMSG a = &m.u.Win32HeapFail;

    a->dwFlags = dwFlags;
    a->bFail = bFail;

    CsrClientCallServer((PCSR_API_MSG)&m,
                        NULL,
                        CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX,
                                            UserpWin32HeapFail),
                        sizeof(*a));

    if (!NT_SUCCESS(m.ReturnValue)) {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "UserpWin32HeapFail failed");
    }
}

UINT
APIENTRY
CsrWin32HeapStat(
    PDBGHEAPSTAT    phs,
    DWORD   dwLen)
{
    USER_API_MSG m;
    PWIN32HEAPSTATMSG a = &m.u.Win32HeapStat;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

    a->dwLen = dwLen;

    CaptureBuffer = CsrAllocateCaptureBuffer(1, dwLen);
    if (CaptureBuffer == NULL) {
        return 0;
    }

    CsrCaptureMessageBuffer(CaptureBuffer,
                            (PCHAR)phs,
                            dwLen,
                            (PVOID *)&a->phs);

    CsrClientCallServer((PCSR_API_MSG)&m,
                        CaptureBuffer,
                        CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX,
                                            UserpWin32HeapStat),
                        sizeof(*a));

    if (!NT_SUCCESS(m.ReturnValue)) {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "UserpWin32HeapStat failed");
        a->dwMaxTag = 0;
        goto ErrExit;
    }
    RtlMoveMemory(phs, a->phs, dwLen);

ErrExit:
    CsrFreeCaptureBuffer(CaptureBuffer);

    return a->dwMaxTag;
}

#endif // DBG


#endif

#if !defined(BUILD_CSRWOW64)

/******************************************************************************\
* CsrBroadcastSystemMessageExW
*
* Routine Description:
*
*   This function is a private API used by the csrss server
*
*   This function converts the csrss server thread into a GUI thread, then
*   performs a BroadcastSystemMessageExW(), and finally restore the thread's
*   desktop.
*
* Arguments:
*
*   dwFlags - Broadcast System message flags
*
*   lpdwRecipients - Intended recipients of the message
*
*   uiMessage - Message type
*
*   wParam - first message parameter
*
*   lParam - second message parameter
*
*   pBSMInfo - BroadcastSystemMessage information
*
* Return Value:
*
*   Appropriate NTSTATUS code
*
\******************************************************************************/
FUNCLOG6(LOG_GENERAL, NTSTATUS, APIENTRY, CsrBroadcastSystemMessageExW, DWORD, dwFlags, LPDWORD, lpdwRecipients, UINT, uiMessage, WPARAM, wParam, LPARAM, lParam, PBSMINFO, pBSMInfo)
NTSTATUS
APIENTRY
CsrBroadcastSystemMessageExW(
    DWORD dwFlags,
    LPDWORD lpdwRecipients,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pBSMInfo
    )
{
    USERTHREAD_USEDESKTOPINFO utudi;
    long result;
    NTSTATUS Status;

    /*
     * Caller must be from the csrss server
     */
    if ( !gfServerProcess ) {
        return( STATUS_ACCESS_DENIED );
    }

    /*
     * Since this thread is a csrss thread, the thread is not a
     * GUI thread and does not have a desktop associated with it.
     * Must set the thread's desktop to the active desktop in
     * order to call BroadcastSystemMessageExW
     */

    utudi.hThread = NULL;
    utudi.drdRestore.pdeskRestore = NULL;

    Status = NtUserSetInformationThread( NtCurrentThread(),
                                         UserThreadUseActiveDesktop,
                                         &utudi,
                                         sizeof(utudi) );

    if ( NT_SUCCESS( Status ) ) {
        result = BroadcastSystemMessageExW(
                        dwFlags,
                        lpdwRecipients,
                        uiMessage,
                        wParam,
                        lParam,
                        pBSMInfo );

        /*
         * Restore the previous desktop of the thread
         */
        Status = NtUserSetInformationThread( NtCurrentThread(),
                                             UserThreadUseDesktop,
                                             &utudi,
                                             sizeof(utudi) );

        if ( NT_SUCCESS( Status ) && ( result <= 0 ) ) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    return( Status );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\ddemlcli.c ===
/****************************** Module Header ******************************\
* Module Name: ddemlcli.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager main client side module
*
* Created: 10/3/91 Sanford Staab
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

// DDEML globals

PCL_INSTANCE_INFO pciiList = NULL;
RTL_CRITICAL_SECTION gcsDDEML;
#if DBG
PVOID gpDDEMLHeap;
#endif

/***************************************************************************\
* DdeInitialize (DDEML API)
*
* Description:
* Used two different ways:
* 1) First time call (*pidInst == 0) - causes a DDEML instance to be
* created for the calling process/thread. Creates a server side
* event window, server side instance structure, DDE Access Object,
* and client side instance structure. The callback function address
* and filter flags (afCmd) are placed into these structures.
* 2) Subsequent call (*pidInst == hInst) - updates filter flags in
* client and server side structures.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, DdeInitializeA, LPDWORD, pidInst, PFNCALLBACK, pfnCallback, DWORD, afCmd, DWORD, ulRes)
UINT DdeInitializeA(
LPDWORD pidInst,
PFNCALLBACK pfnCallback,
DWORD afCmd,
DWORD ulRes)
{
    if (ulRes != 0) {
        return (DMLERR_INVALIDPARAMETER);
    }
    return (InternalDdeInitialize(pidInst, pfnCallback, afCmd, 0));
}



FUNCLOG4(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, DdeInitializeW, LPDWORD, pidInst, PFNCALLBACK, pfnCallback, DWORD, afCmd, DWORD, ulRes)
UINT DdeInitializeW(
LPDWORD pidInst,
PFNCALLBACK pfnCallback,
DWORD afCmd,
DWORD ulRes)
{
    if (ulRes != 0) {
        return (DMLERR_INVALIDPARAMETER);
    }
    return (InternalDdeInitialize(pidInst, pfnCallback, afCmd, 1));
}


UINT InternalDdeInitialize(
LPDWORD pidInst,
PFNCALLBACK pfnCallback,
DWORD afCmd,
BOOL fUnicode)
{
    UINT uiRet = DMLERR_MEMORY_ERROR;
    register PCL_INSTANCE_INFO pcii;

    if (afCmd & APPCLASS_MONITOR) {
        afCmd |= CBF_MONMASK;
    }

    if (afCmd & APPCMD_CLIENTONLY) {
        afCmd |= CBF_FAIL_CONNECTIONS;
    }

    EnterDDECrit;

    if (*pidInst != 0) {
        pcii = ValidateInstance((HANDLE)LongToHandle( *pidInst ));
        if (pcii == NULL) {
            uiRet = DMLERR_INVALIDPARAMETER;
            goto Exit;
        }

        // only allow certain bits to be changed on reinitialize call

        pcii->afCmd = (pcii->afCmd & ~(CBF_MASK | MF_MASK)) |
                (afCmd & (CBF_MASK | MF_MASK));

        LeaveDDECrit;
        NtUserUpdateInstance(pcii->hInstServer, &pcii->MonitorFlags, afCmd);
        return (DMLERR_NO_ERROR);
    }

    pcii = (PCL_INSTANCE_INFO)DDEMLAlloc(sizeof(CL_INSTANCE_INFO));
    if (pcii == NULL) {
        uiRet = DMLERR_MEMORY_ERROR;
        goto Exit;
    }

    pcii->plaNameService = (LATOM *)DDEMLAlloc(sizeof(LATOM));
    if (pcii->plaNameService == NULL) {
        uiRet = DMLERR_MEMORY_ERROR;
        goto Backout3;
    }
    // *pcii->plaNameService = 0; // zero init takes care of this
    pcii->cNameServiceAlloc = 1;


    /*
     * Flag this window as being create from a diff hmod as the app so
     * hotkeys don't take it as the first window created in the app and
     * assign it as the hotkey.
     */
    pcii->hwndMother =  _CreateWindowEx(0, (LPTSTR)(gpsi->atomSysClass[ICLS_DDEMLMOTHER]), L"",
            WS_POPUP, 0, 0, 0, 0, (HWND)0,
            (HMENU)0, 0, (LPVOID)NULL, CW_FLAGS_DIFFHMOD);

    if (pcii->hwndMother == 0) {
        uiRet = DMLERR_SYS_ERROR;
        goto Backout2;
    }
    SetWindowLongPtr(pcii->hwndMother, GWLP_INSTANCE_INFO, (LONG_PTR)pcii);

    pcii->afCmd = afCmd | APPCMD_FILTERINITS;
    pcii->pfnCallback = pfnCallback;
    // pcii->LastError = DMLERR_NO_ERROR; // zero init
    pcii->tid = GetCurrentThreadId();
    // pcii->aServerLookup = NULL;          // zero init
    // pcii->cServerLookupAlloc = 0;        // zero init
    // pcii->ConvStartupState = 0;          // zero init - Not blocked.
    // pcii->flags = 0;                     // zero init
    // pcii->cInDDEMLCallback = 0;          // zero init
    // pcii->pLinkCounts = NULL;            // zero init

    // Do this last when the client side is ready for whatever events
    // flying around may come charging in.

    LeaveDDECrit;
    uiRet = NtUserDdeInitialize(&pcii->hInstServer,
                            &pcii->hwndEvent,
                            &pcii->MonitorFlags,
                            pcii->afCmd,
                            pcii);
    EnterDDECrit;

    if (uiRet != DMLERR_NO_ERROR) {
Backout:
        NtUserDestroyWindow(pcii->hwndMother);
Backout2:
        DDEMLFree(pcii->plaNameService);
Backout3:
        DDEMLFree(pcii);
        goto Exit;
    }
    pcii->hInstClient = AddInstance(pcii->hInstServer);
    *pidInst = HandleToUlong(pcii->hInstClient);
    if (pcii->hInstClient == 0) {
        LeaveDDECrit;
        NtUserCallOneParam((ULONG_PTR)pcii->hInstServer, SFI__CSDDEUNINITIALIZE);
        EnterDDECrit;
        uiRet = DMLERR_MEMORY_ERROR;
        goto Backout;
    }
    SetHandleData(pcii->hInstClient, (ULONG_PTR)pcii);

    pcii->next = pciiList;
    pciiList = pcii;
    if (fUnicode) {
        pcii->flags |= IIF_UNICODE;
    }
    uiRet = DMLERR_NO_ERROR;

Exit:
    LeaveDDECrit;
    return (uiRet);
}



/***************************************************************************\
* DdeUninitialize (DDEML API)
*
* Description:
* Shuts down a DDEML instance and frees all associated resources.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeUninitialize, DWORD, idInst)
BOOL DdeUninitialize(
DWORD idInst)
{
    PCL_INSTANCE_INFO pcii, pciiPrev;
    BOOL fRet = FALSE;

    CheckDDECritOut;
    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    /*
     * If this thread is in the middle of a synchronous transaction or
     * a callback, we need to back out of those first.
     */
    if ((pcii->flags & IIF_IN_SYNC_XACT) || pcii->cInDDEMLCallback) {
        pcii->afCmd |= APPCMD_UNINIT_ASAP;
        fRet = TRUE;
        goto Exit;
    }

    ApplyFunctionToObjects(HTYPE_CONVERSATION_LIST, InstFromHandle(pcii->hInstClient),
            (PFNHANDLEAPPLY)DdeDisconnectList);
    ApplyFunctionToObjects(HTYPE_CLIENT_CONVERSATION, InstFromHandle(pcii->hInstClient),
            (PFNHANDLEAPPLY)DdeDisconnect);
    ApplyFunctionToObjects(HTYPE_SERVER_CONVERSATION, InstFromHandle(pcii->hInstClient),
            (PFNHANDLEAPPLY)DdeDisconnect);
    ApplyFunctionToObjects(HTYPE_ZOMBIE_CONVERSATION, InstFromHandle(pcii->hInstClient),
            (PFNHANDLEAPPLY)WaitForZombieTerminate);
    ApplyFunctionToObjects(HTYPE_DATA_HANDLE, InstFromHandle(pcii->hInstClient),
            (PFNHANDLEAPPLY)ApplyFreeDataHandle);

    LeaveDDECrit;
    NtUserCallOneParam((ULONG_PTR)pcii->hInstServer, SFI__CSDDEUNINITIALIZE);
    NtUserDestroyWindow(pcii->hwndMother);
    EnterDDECrit;

    DDEMLFree(pcii->plaNameService);
    DestroyInstance(pcii->hInstClient);

    // unlink pcii from pciiList

    if (pciiList == pcii) {
        pciiList = pciiList->next;
    } else {
        for (pciiPrev = pciiList; pciiPrev != NULL && pciiPrev->next != pcii;
                pciiPrev = pciiPrev->next) {
            ;
        }
        if (pciiPrev != NULL) {
            pciiPrev->next = pcii->next;
        }
    }
    DDEMLFree(pcii);
    fRet = TRUE;

Exit:
    LeaveDDECrit;
    return (fRet);
}



/***************************************************************************\
* DdeNameService (DDEML API)
*
* Description:
* Registers, and Unregisters service names and sets the Initiate filter
* state for an instance.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
HDDEDATA DdeNameService(
DWORD idInst,
HSZ hsz1, // service name
HSZ hsz2, // reserved for future enhancements
UINT afCmd) // DNS_ flags.
{
    BOOL fRet = TRUE;
    LATOM *plaNameService;
    PCL_INSTANCE_INFO pcii;

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        fRet = FALSE;
        goto Exit;
    }

    if ((hsz1 && ValidateHSZ(hsz1) == HSZT_INVALID) || hsz2 != 0) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        fRet = FALSE;
        goto Exit;
    }

    if (afCmd & DNS_FILTERON && !(pcii->afCmd & APPCMD_FILTERINITS)) {
        pcii->afCmd |= APPCMD_FILTERINITS;
        NtUserUpdateInstance(pcii->hInstServer, &pcii->MonitorFlags, pcii->afCmd);
    }
    if (afCmd & DNS_FILTEROFF && (pcii->afCmd & APPCMD_FILTERINITS)) {
        pcii->afCmd &= ~APPCMD_FILTERINITS;
        NtUserUpdateInstance(pcii->hInstServer, &pcii->MonitorFlags, pcii->afCmd);
    }

    if (afCmd & (DNS_REGISTER | DNS_UNREGISTER)) {
        GATOM ga;

        if (pcii->afCmd & APPCMD_CLIENTONLY) {
            SetLastDDEMLError(pcii, DMLERR_DLL_USAGE);
            fRet = FALSE;
            goto Exit;
        }

        if (hsz1 == 0) {
            if (afCmd & DNS_REGISTER) {

                /*
                 * registering NULL is not allowed!
                 */
                SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
                fRet = FALSE;
                goto Exit;
            }

            /*
             * unregistering NULL is just like unregistering each
             * registered name.
             *
             * 10/19/90 - made this a synchronous event so that hsz
             * can be freed by calling app after this call completes
             * without us having to keep a copy around forever.
             */
            plaNameService = pcii->plaNameService;
            while (*plaNameService != 0) {
                ga = LocalToGlobalAtom(*plaNameService);
                DeleteAtom(*plaNameService);
                LeaveDDECrit;
                RegisterService(FALSE, ga, pcii->hwndMother);
                EnterDDECrit;
                GlobalDeleteAtom(ga);
                plaNameService++;
            }
            pcii->cNameServiceAlloc = 1;
            *pcii->plaNameService = 0;
            goto Exit;
        }

        if (afCmd & DNS_REGISTER) {
            plaNameService = (LATOM *)DDEMLReAlloc(pcii->plaNameService,
                    sizeof(LATOM) * ++pcii->cNameServiceAlloc);
            if (plaNameService == NULL) {
                SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
                pcii->cNameServiceAlloc--;
                fRet = FALSE;
                goto Exit;
            } else {
                pcii->plaNameService = plaNameService;
            }
            IncLocalAtomCount(LATOM_FROM_HSZ(hsz1)); // NameService copy
            plaNameService[pcii->cNameServiceAlloc - 2] = LATOM_FROM_HSZ(hsz1);
            plaNameService[pcii->cNameServiceAlloc - 1] = 0;

        } else { // DNS_UNREGISTER
            plaNameService = pcii->plaNameService;
            while (*plaNameService != 0 && *plaNameService != LATOM_FROM_HSZ(hsz1)) {
                plaNameService++;
            }
            if (*plaNameService == 0) {
                goto Exit; // not found just exit
            }
            //
            // fill empty slot with last entry and fill last entry with 0
            //
            pcii->cNameServiceAlloc--;
            *plaNameService = pcii->plaNameService[pcii->cNameServiceAlloc - 1];
            pcii->plaNameService[pcii->cNameServiceAlloc - 1] = 0;
        }

        ga = LocalToGlobalAtom(LATOM_FROM_HSZ(hsz1));
        LeaveDDECrit;
        RegisterService((afCmd & DNS_REGISTER) ? TRUE : FALSE, ga,
            pcii->hwndMother);
        EnterDDECrit;
        GlobalDeleteAtom(ga);
    }

Exit:
    LeaveDDECrit;
    return ((HDDEDATA)IntToPtr( fRet ));
}



/***************************************************************************\
* DdeGetLastError (DDEML API)
*
* Description:
* Returns last error code set for the instance given.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, DdeGetLastError, DWORD, idInst)
UINT DdeGetLastError(
DWORD idInst)
{
    UINT uiRet = 0;
    PCL_INSTANCE_INFO pcii;

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        uiRet = DMLERR_INVALIDPARAMETER;
        goto Exit;
    }
    uiRet = pcii->LastError;
    pcii->LastError = DMLERR_NO_ERROR;

Exit:
    LeaveDDECrit;
    return (uiRet);
}



/***************************************************************************\
* DdeImpersonateClient()
*
* Description:
*   Does security impersonation for DDEML server apps.
*   This API should only be called with server side hConvs;
*
* History:
* 5-4-92 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeImpersonateClient, HCONV, hConv)
BOOL DdeImpersonateClient(
HCONV hConv)
{
    PCONV_INFO pcoi;
    PCL_INSTANCE_INFO pcii;
    BOOL fRet = FALSE;

    EnterDDECrit;

    pcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
            HTYPE_SERVER_CONVERSATION, HINST_ANY);
    if (pcoi == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hConv);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    fRet = NtUserImpersonateDdeClientWindow(pcoi->hwndPartner, pcoi->hwndConv);
Exit:
    LeaveDDECrit;
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\ddemlcli.h ===
/****************************** Module Header ******************************\
* Module Name: ddemlcli.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains stuff used by client side ddeml code.
*
* History:
* 10-28-91 Sanfords     Created
\***************************************************************************/
#if DBG
#define DDEMLAlloc(cb)          RtlAllocateHeap(gpDDEMLHeap, HEAP_ZERO_MEMORY, (cb))
#define DDEMLReAlloc(p, cb)     RtlReAllocateHeap(gpDDEMLHeap, HEAP_ZERO_MEMORY, (p), (cb))
#define DDEMLFree(p)            RtlFreeHeap(gpDDEMLHeap, 0, (p))
#else
#define DDEMLAlloc(cb)          LocalAlloc(LPTR, cb)
#define DDEMLReAlloc(p, cb)     LocalReAlloc(p, cb, LHND)
#define DDEMLFree(p)            LocalFree(p);
#endif


// general typedefs

typedef    ATOM    LATOM;
typedef    ATOM    GATOM;

// monitor stuff ------------------------------------------

#define MONHSZ(pcii, hsz, type)     if ((pcii->MonitorFlags & MF_HSZ_INFO) && hsz) \
                                        MonitorStringHandle(pcii, hsz, type)
#define MONLINK(pcii, fEst, fNoD, aS, aT, aI, wFmt, fSvr, hConvS, hConvC) \
        if (pcii->MonitorFlags & MF_LINKS) \
            MonitorLink(pcii, fEst, fNoD, aS, aT, aI, \
            wFmt, fSvr, hConvS, hConvC)

#define MONCONV(pcoi, fConn) \
        if (((pcoi)->pcii->MonitorFlags & MF_CONV) && \
                ((((pcoi)->state & ST_ISLOCAL) && (pcoi)->state & ST_CLIENT) || \
                !((pcoi)->state & ST_ISLOCAL))) \
            MonitorConv(pcoi, fConn);

// critical section stuff ---------------------------------

extern RTL_CRITICAL_SECTION gcsDDEML;
#if DBG
extern PVOID gpDDEMLHeap;
#endif
#define EnterDDECrit       RtlEnterCriticalSection(&gcsDDEML);
#define LeaveDDECrit       RtlLeaveCriticalSection(&gcsDDEML);
#if DBG
#define CheckDDECritIn     if (GetCurrentThreadId() != HandleToUlong(gcsDDEML.OwningThread)) { \
                               RIPMSG0(RIP_ERROR, "CheckDDECritIn failed"); \
                           }
#define CheckDDECritOut    if (GetCurrentThreadId() == HandleToUlong(gcsDDEML.OwningThread)) { \
                               RIPMSG0(RIP_ERROR, "CheckDDECritoUT failed"); \
                           }
#else
#define CheckDDECritIn     ;
#define CheckDDECritOut    ;
#endif

// String handle stuff -------------------------------------

// return values for ValidateHSZ macro
#define HSZT_INVALID        0
#define HSZT_NORMAL         1
#define HSZT_INST_SPECIFIC  2

#define LATOM_FROM_HSZ(hsz)             (LATOM)(ULONG_PTR)(hsz)
#define NORMAL_HSZ_FROM_LATOM(a)        (HSZ)(ULONG_PTR)(a)
#define INST_SPECIFIC_HSZ_FROM_LATOM(a) (HSZ)LongToHandle( MAKELONG(a, 1) )

// Handle manager stuff ------------------------------------------

typedef struct tagCHANDLEENTRY {
   HANDLE handle;
   ULONG_PTR dwData;
} CHANDLEENTRY, *PCHANDLEENTRY;

typedef BOOL (*PFNHANDLEAPPLY)(HANDLE);

#define MASK_ID      0xFF000000     // 256 uniqueness
#define SHIFT_ID     24
#define MASK_INDEX   0x00FFFC00     // 16K handles per process max
#define SHIFT_INDEX  10
#define MASK_TYPE    0x00000380     // 8 types max
#define SHIFT_TYPE   7
#define MASK_INST    0x0000007F     // 128 instances per process max
#define SHIFT_INST   0
#define MAX_INST     MASK_INST

#define IdFromHandle(h)    (DWORD)(((ULONG_PTR)(h) & MASK_ID)     >> SHIFT_ID)
#define IndexFromHandle(h) (DWORD)(((ULONG_PTR)(h) & MASK_INDEX)  >> SHIFT_INDEX)
#define TypeFromHandle(h)  (DWORD)(((ULONG_PTR)(h) & MASK_TYPE)   >> SHIFT_TYPE)
#define InstFromHandle(h)  (DWORD)(((ULONG_PTR)(h) & MASK_INST)   >> SHIFT_INST)

#define HandleFromId(h)    (((DWORD)(h)) << SHIFT_ID)
#define HandleFromIndex(h) (((DWORD)(h)) << SHIFT_INDEX)
#define HandleFromType(h)  (((DWORD)(h)) << SHIFT_TYPE)
#define HandleFromInst(h)  (((DWORD)(h)) << SHIFT_INST)

#define HTYPE_EMPTY                    0
#define HTYPE_INSTANCE                 1
#define HTYPE_SERVER_CONVERSATION      2
#define HTYPE_CLIENT_CONVERSATION      3
#define HTYPE_CONVERSATION_LIST        4
#define HTYPE_TRANSACTION              5
#define HTYPE_DATA_HANDLE              6
#define HTYPE_ZOMBIE_CONVERSATION      7

#define HTYPE_ANY                      (DWORD)(-1)
#define HINST_ANY                      (DWORD)(-1)

// transaction stuff -------------------------------------------

typedef struct tagXACT_INFO *PXACT_INFO;

typedef BOOL (* FNRESPONSE)(PXACT_INFO, UINT, LPARAM);

typedef struct tagXACT_INFO {
    struct tagXACT_INFO *next;
    struct tagCONV_INFO *pcoi;
    DWORD_PTR           hUser;
    HANDLE              hXact;
    FNRESPONSE          pfnResponse;
    GATOM               gaItem;
    WORD                wFmt;
    WORD                wType;                // for DdeQueryConvInfo only
    WORD                wStatus;              // see DDE_F flags
    WORD                flags;                // see XIF_ flags
    WORD                state;                // see XST_ state values (ddeml.h)
    HANDLE              hDDESent;             // in case NACK is returned.
    HANDLE              hDDEResult;
} XACT_INFO;

#define     XIF_SYNCHRONOUS         0x1
#define     XIF_COMPLETE            0x2
#define     XIF_ABANDONED           0x4

#define     TID_TIMEOUT             1

// Advise link tracking stuff -----------------------------------

typedef struct tagLINK_COUNT *PLINK_COUNT;
typedef struct tagADVISE_LINK {
    struct tagLINK_COUNT *pLinkCount;
    LATOM   laItem;
    WORD    wFmt;
    WORD    wType;          // XTYP_ and XTYPF_ constants
    WORD    state;          // ADVST_ constant
} ADVISE_LINK, *PADVISE_LINK;

#define ADVST_WAITING   0x0080
#define ADVST_CHANGED   0x0040

// DDE message handling stuff -----------------------------------

typedef struct tagDDE_MESSAGE_QUEUE {
    struct tagDDE_MESSAGE_QUEUE    *next;
    struct tagCONV_INFO            *pcoi;
    UINT                            msg;
    LPARAM                          lParam;
} DDE_MESSAGE_QUEUE, *PDDE_MESSAGE_QUEUE;

// instance info stuff -------------------------------------------

typedef struct tagSERVER_LOOKUP {
    LATOM           laService;
    LATOM           laTopic;
    HWND            hwndServer;
} SERVER_LOOKUP, *PSERVER_LOOKUP;

typedef struct tagLINK_COUNT {
    struct tagLINK_COUNT *next;
    LATOM laTopic;
    GATOM gaItem;
    LATOM laItem;
    WORD  wFmt;
    short Total;
    short Count;
} LINK_COUNT;

typedef struct tagCL_INSTANCE_INFO {
    struct tagCL_INSTANCE_INFO *next;
    HANDLE                      hInstServer;
    HANDLE                      hInstClient;
    DWORD                       MonitorFlags;
    HWND                        hwndMother;
    HWND                        hwndEvent;
    HWND                        hwndTimeout;
    DWORD                       afCmd;
    PFNCALLBACK                 pfnCallback;
    DWORD                       LastError;
    DWORD                       tid;
    LATOM                      *plaNameService;
    WORD                        cNameServiceAlloc;
    PSERVER_LOOKUP              aServerLookup;
    short                       cServerLookupAlloc;
    WORD                        ConvStartupState;
    WORD                        flags;              // IIF_ flags
    short                       cInDDEMLCallback;
    PLINK_COUNT                 pLinkCount;
} CL_INSTANCE_INFO, *PCL_INSTANCE_INFO;

#define IIF_IN_SYNC_XACT    0x0001
#define IIF_UNICODE         0x8000

// conversation stuff ---------------------------------------------

typedef struct tagCONV_INFO {
    struct tagCONV_INFO    *next;
    PCL_INSTANCE_INFO       pcii;
    DWORD_PTR               hUser;
    HCONV                   hConv;
    LATOM                   laService;
    LATOM                   laTopic;
    HWND                    hwndPartner;
    HWND                    hwndConv;
    WORD                    state;                 // ST_ flags
    LATOM                   laServiceRequested;
    PXACT_INFO              pxiIn;
    PXACT_INFO              pxiOut;
    PDDE_MESSAGE_QUEUE      dmqIn;
    PDDE_MESSAGE_QUEUE      dmqOut;
    PADVISE_LINK            aLinks;
    int                     cLinks;
    int                     cLocks;
} CONV_INFO, *PCONV_INFO;

typedef struct tagCL_CONV_INFO {
    CONV_INFO               ci;
    HWND                    hwndReconnect;
    HCONVLIST               hConvList;
} CL_CONV_INFO, *PCL_CONV_INFO;

typedef struct tagSVR_CONV_INFO {
    CONV_INFO               ci;
} SVR_CONV_INFO, *PSVR_CONV_INFO;

typedef struct tagCONVLIST {
    int                     chwnd;      // number of client windows in this list
    HWND                    ahwnd[1];   // windows in list.
} CONVLIST, *PCONVLIST;

extern CONVCONTEXT DefConvContext;  // global from connect.c

typedef struct tagENABLE_ENUM_STRUCT{
    BOOL                   *pfRet;
    WORD                    wCmd;
    WORD                    wCmd2;
} ENABLE_ENUM_STRUCT, *PENABLE_ENUM_STRUCT;

// memory management stuff -------------------------------------

typedef struct tagDDEMLDATA {
    HANDLE  hDDE;                // Global data handle or data token
    DWORD   flags;               // See HDATA_ constants
} DDEMLDATA, *PDDEMLDATA;

// DDEML client side Globals -----------------------------------

extern PHANDLE aInstance;
extern DWORD gWM_REGISTERCALLBACK;

// prototypes --------------------------------------------------

// handles.c

HANDLE CreateHandle(ULONG_PTR dwData, DWORD type, DWORD  inst);
ULONG_PTR DestroyHandle(HANDLE h);
ULONG_PTR GetHandleData(HANDLE h);
VOID SetHandleData(HANDLE h, ULONG_PTR dwData);
ULONG_PTR ValidateCHandle(HANDLE h, DWORD ExpectedType, DWORD ExpectedInstance);
PCL_INSTANCE_INFO PciiFromHandle(HANDLE h);
HANDLE FindIstanceHandleFromHandle(HANDLE h);
VOID ApplyFunctionToObjects(DWORD ExpectedType, DWORD ExpectedInstance,
    PFNHANDLEAPPLY pfn);
VOID BestSetLastDDEMLError(DWORD error);

// ddemlcli.c

UINT InternalDdeInitialize(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd,
    BOOL fUnicode);
// DDEML API DdeInitializeA
// DDEML API DdeInitializeW
// DDEML API DdeUninitialize
// DDEML API DdeNameService
// DDEML API DdeGetLastError

// instance.c

HANDLE AddInstance(HANDLE hInst);
HANDLE DestroyInstance(HANDLE hInst);
PCL_INSTANCE_INFO ValidateInstance(HANDLE hInst);
BOOL CsClearSecurityForAck(HANDLE hInst, HWND hwndServer, HWND hwndClient);
VOID SetLastDDEMLError(PCL_INSTANCE_INFO pcii, DWORD error);

// hsz.c

HSZ InternalDdeCreateStringHandle(DWORD idInst, PVOID psz, int iCodePage);
// DDEML API DdeCreateStringHandleA
// DDEML API DdeCreateStringHandleW
DWORD InternalDdeQueryString(DWORD idInst, HSZ hsz, PVOID psz, DWORD cchMax,
    INT iCodePage);
// DDEML API DdeQueryStringA
// DDEML API DdeQueryStringW
// DDEML API DdeFreeStringHandle
// DDEML API DdeKeepStringHandle
// DDEML API DdeCmpStringHandles

DWORD ValidateHSZ(HSZ hsz);
LATOM MakeInstSpecificAtom(LATOM la, HWND hwnd);
HWND ParseInstSpecificAtom(LATOM la, LATOM *plaNormal);
GATOM LocalToGlobalAtom(LATOM la);
LATOM GlobalToLocalAtom(GATOM ga);
GATOM IncGlobalAtomCount(GATOM la);
LATOM IncLocalAtomCount(LATOM la);

// connect.c

// DDEML API DdeConnect
// DDEML API DdeConnectList
// DDEML API DdeReconnect
BOOL ValidateConnectParameters(HANDLE hInst, PCL_INSTANCE_INFO *ppcii,
    HSZ *phszService, HSZ hszTopic, LATOM *plaNormalSvcName,
    PCONVCONTEXT *ppCC, HWND *phwndTarget, HCONVLIST hConvList);
PCL_CONV_INFO ConnectConv(PCL_INSTANCE_INFO pcii, LATOM laService,
    LATOM laTopic, HWND hwndTarget, HWND hwndSkip,
    PCONVCONTEXT pCC, HCONVLIST hConvList, DWORD clst);
VOID SetCommonStateFlags(HWND hwndUs, HWND hwndThem, PWORD pwFlags);
// DDEML API DdeQueryNextServer
// DDEML API DdeDisconnect
// DDEML API DdeDisconnectList
VOID ShutdownConversation(PCONV_INFO pcoi, BOOL fMakeCallback);
VOID FreeConversationResources(PCONV_INFO pcoi);
BOOL WaitForZombieTerminate(HANDLE hData);

// xact.c

VOID GetConvContext(HWND hwnd, LONG *pl);
VOID SetConvContext(HWND hwnd, LONG *pl);
// DDEML API DdeClientTransaction
// DDEML API DdeQueryConvInfo
// DDEML API DdeSetUserHandle
// DDEML API DdeAbandonTransaction
BOOL
UpdateLinkIfChanged(
    PADVISE_LINK paLink,
    PXACT_INFO pxi,
    PCONV_INFO pcoi,
    PADVISE_LINK paLinkLast,
    PBOOL pfSwapped,
    DWORD cLinksToGo);

// DDEML API DdePostAdvise
VOID LinkTransaction(PXACT_INFO pxi);
VOID UnlinkTransaction(PXACT_INFO pxi);
BOOL ValidateTransaction(HCONV hConv, HANDLE hXact, PCONV_INFO *ppcoi,
    PXACT_INFO *ppxi);


// hdata.c

// DDEML API DdeCreateDataHandle
HDDEDATA InternalCreateDataHandle(PCL_INSTANCE_INFO pcii, LPBYTE pSrc, DWORD cb,
    DWORD cbOff, DWORD flags, WORD wStatus, WORD wFmt);
// DDEML API DdeAddData
// DDEML API DdeGetData
// DDEML API DdeAccessData
// DDEML API DdeUnaccessData
// DDEML API DdeFreeDataHandle
BOOL ApplyFreeDataHandle(HANDLE hData);
BOOL InternalFreeDataHandle(HDDEDATA hData, BOOL fIgnorefRelease);
VOID FreeDDEData(HANDLE hDDE, BOOL fIgnorefRelease, BOOL fFreeTruelyGlobalObjects);
HANDLE CopyDDEData(HANDLE hDDE, BOOL fExec);

// callback.c

HDDEDATA DoCallback(PCL_INSTANCE_INFO pcii, WORD wType, WORD wFmt, HCONV hConv,
    HSZ hsz1, HSZ hsz2, HDDEDATA hData, ULONG_PTR dw1, ULONG_PTR dw2);
DWORD _ClientEventCallback(PCL_INSTANCE_INFO pcii, PEVENT_PACKET pep);
// DDEML API DdeEnableCallback
BOOL SetEnableState(PCONV_INFO pcoi, UINT wCmd);
DWORD _ClientGetDDEHookData(UINT message, LPARAM lParam,
        PDDEML_MSG_HOOK_DATA pdmhd);
DWORD _ClientGetDDEFlags(HANDLE hClient, DWORD flags);
BOOL EnableEnumProc(HWND hwnd, PENABLE_ENUM_STRUCT pees);

// ddemlwp.c

LRESULT DDEMLMotherWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT DDEMLClientWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT DDEMLServerWndProc(HWND, UINT, WPARAM, LPARAM);
PCONV_INFO ProcessTerminateMsg(PCONV_INFO pcoi, HWND hwndFrom);
VOID ProcessAsyncDDEMsg(PCONV_INFO pcoi, UINT msg, HWND hwndFrom, LPARAM lParam);
BOOL CheckForQueuedMessages(PCONV_INFO pcoi);
VOID DumpDDEMessage(BOOL fFreeData, UINT msg, LPARAM lParam);
BOOL ProcessSyncDDEMessage(PCONV_INFO pcoi, UINT msg, LPARAM lParam);

// stdptcl.c

BOOL ClStartAdvise(PXACT_INFO pxi);
BOOL SvSpontAdvise(PSVR_CONV_INFO psi, LPARAM lParam);
BOOL ClRespAdviseAck(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL SvStartAdviseUpdate(PXACT_INFO pxi, DWORD cLinksToGo);
BOOL ClSpontAdviseData(PCL_CONV_INFO pci, LPARAM lParam);
BOOL SvRespAdviseDataAck(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL ClStartUnadvise(PXACT_INFO pxi);
BOOL SvSpontUnadvise(PSVR_CONV_INFO psi, LPARAM lParam);
BOOL ClRespUnadviseAck(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL ClStartExecute(PXACT_INFO pxi);
BOOL ClRespExecuteAck(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL ClStartPoke(PXACT_INFO pxi);
BOOL SvSpontPoke(PSVR_CONV_INFO psi, LPARAM lParam);
BOOL ClRespPokeAck(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL ClStartRequest(PXACT_INFO pxi);
BOOL SvSpontRequest(PSVR_CONV_INFO psi, LPARAM lParam);
BOOL ClRespRequestData(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL SpontaneousClientMessage(PCL_CONV_INFO pci, UINT msg, LPARAM lParam);
BOOL SpontaneousServerMessage(PSVR_CONV_INFO psi, UINT msg, LPARAM lParam);
HANDLE AllocAndSetDDEData(LPBYTE pSrc, DWORD cb, WORD wStatus, WORD wFmt);
DWORD PackAndPostMessage(HWND hwndTo, UINT msgIn, UINT msgOut, HWND hwndFrom,
    LPARAM lParam, UINT_PTR uiLo, UINT_PTR uiHi);
BOOL ExtractDDEDataInfo(HANDLE hDDE, LPWORD pwStatus, LPWORD pwFmt);
BOOL TransactionComplete(PXACT_INFO pxi, HDDEDATA hData);
HANDLE UnpackAndFreeDDEMLDataHandle(HDDEDATA hData, BOOL fExec);

// util.c

BOOL AddLink(PCONV_INFO pcoi, GATOM gaItem, WORD wFmt, WORD wType);
VOID DeleteLinkCount(PCL_INSTANCE_INFO pcii, PLINK_COUNT pLinkCountDelete);

// monitor.c

VOID MonitorStringHandle(PCL_INSTANCE_INFO pcii, HSZ hsz, DWORD fsAction);
VOID MonitorLink(PCL_INSTANCE_INFO pcii, BOOL fEstablished, BOOL fNoData,
        LATOM laSvc, LATOM laTopic, GATOM gaItem, WORD wFmt, BOOL fServer,
        HCONV hConvServer, HCONV hConvClient);
VOID MonitorConv(PCONV_INFO pcoi, BOOL fConnect);

// register.c

VOID RegisterService(BOOL fRegister, GATOM gaApp, HWND hwndListen);
LRESULT ProcessRegistrationMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\dlgbegin.c ===
/***************************************************************************\
*
*  DLGBEGIN.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Dialog Initialization Routines
*
* ??-???-???? mikeke    Ported from Win 3.0 sources
* 12-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL ValidateCallback(HANDLE h);

CONST WCHAR szEDITCLASS[] = TEXT("Edit");

/*
 * Fixed, hard coded literal for Dialog hacks
 */
const WCHAR gwszShellFont[]  = L"MS Shell Dlg";
const WCHAR gwszShellFont2[] = L"MS Shell Dlg 2";


/***************************************************************************\
* DefShortToInt
*
* Avoid sign extending 16 bit CW2_USEDEFAULT. We need this because the
*  dialog resource template uses SHORT fields to store the coordinates
*  but CreateWindow wants INT values.
*
* History:
* 12/04/96 GerardoB Created
\***************************************************************************/
__inline int DefShortToInt (short s)
{
    if (s == (short)CW2_USEDEFAULT) {
        return (int)(DWORD)(WORD)CW2_USEDEFAULT;
    } else {
        return (int)s;
    }
}
/***************************************************************************\
* BYTE FAR *SkipSz(lpsz)
*
* History:
\***************************************************************************/

PBYTE SkipSz(
    UTCHAR *lpsz)
{
    if (*lpsz == 0xFF)
        return (PBYTE)lpsz + 4;

    while (*lpsz++ != 0) ;

    return (PBYTE)lpsz;
}

PBYTE WordSkipSz(
    UTCHAR *lpsz)
{
    PBYTE pb = SkipSz(lpsz);
    return NextWordBoundary(pb);
}

PBYTE DWordSkipSz(
    UTCHAR *lpsz)
{
    PBYTE pb = SkipSz(lpsz);
    return NextDWordBoundary(pb);
}


/***************************************************************************\
*
* IsFontNotGood()
*
* If this is a low res device, we need to check if the
* font we're creating is smaller than the system font.
*
\***************************************************************************/
__inline BOOLEAN IsFontNotGood(LPWSTR szTempBuffer, LPCWSTR lpStrSubst, TEXTMETRIC* ptm)
{
    //
    // For FarEast version, we will allow the font smaller than system font.
    //
    return _wcsicmp(szTempBuffer, lpStrSubst) ||
                (!IS_ANY_DBCS_CHARSET(ptm->tmCharSet) &&
                    (SYSMET(CXICON) < 32 || SYSMET(CYICON) < 32) &&
                    ptm->tmHeight < gpsi->cySysFontChar);
}

// --------------------------------------------------------------------------
//  GetCharsetEnumProc()
//
//  This gets the best asian font for a dialog box.
//
//  1996-Sep-11 hideyukn     Port from Win95-FE
// --------------------------------------------------------------------------
int CALLBACK GetCharsetEnumProc(
    LPLOGFONT     lpLogFont,
    LPTEXTMETRIC  lptm,
    DWORD         nType,
    LPARAM        lpData)
{
    UNREFERENCED_PARAMETER(lptm);
    UNREFERENCED_PARAMETER(nType);

    //
    // Use other than FIXED pitch sysfont when the face name isn't specified.
    //
    if ((lpLogFont->lfPitchAndFamily & 3) == FIXED_PITCH)
    {
        if (!lstrcmpi(lpLogFont->lfFaceName,L"System") ||
            !lstrcmpi(lpLogFont->lfFaceName,L"@System"))
            return TRUE; // try to get another system font metric
    }

    ((LPLOGFONT)lpData)->lfCharSet = lpLogFont->lfCharSet;
    ((LPLOGFONT)lpData)->lfPitchAndFamily = lpLogFont->lfPitchAndFamily;
    return FALSE;
}

/*
 * Get a character set based on System's ANSI CODEPAGE
 */
UINT GetACPCharSet()
{
    static UINT charset = (UINT)~0;
    CHARSETINFO csInfo;

    if (charset != (UINT)~0) {
        return charset;
    }

    // Sundown: In the TCI_SRCCODEPAGE case, the GetACP() return value is zero-extended.
    if (!TranslateCharsetInfo((DWORD*)UIntToPtr( GetACP() ), &csInfo, TCI_SRCCODEPAGE)) {
        return DEFAULT_CHARSET;
    }
    charset = csInfo.ciCharset;
    UserAssert(charset != (UINT)~0);
    return csInfo.ciCharset;
}

#if 0
BYTE GetCharsetFromResourceLang(LCID lcid)
{
    CHARSETINFO csInfo;

    if (!TranslateCharsetInfo((DWORD *)lcid, &csInfo, TCI_SRCLOCALE))
        return DEFAULT_CHARSET;
    return csInfo.ciCharset;
}
#endif

/***************************************************************************\
*
* CreateDlgFont()
*
* Create the dialog font described at the given location in a resource
*
\***************************************************************************/

#define GET_DESKTOP_CHARSET()   (GetTextCharset(hdcDlg))

//
// Reserved Dlg resource version number
//
#define DLGRSC_VER_NT5COMPAT_RESERVE    10

BOOL FixupDlgLogFont(
        HDC hdcDlg,
        LPLOGFONT lpLogFont,
        LPDLGTEMPLATE2 lpdt,
        BOOLEAN fUseShellFont2,
        BOOLEAN* pfWillTryDefaultCharset)
{
    switch (lpdt->wDlgVer) {
    case 0:
        // DIALOG statement, which only has a facename.
        // The new applications are not supposed to use DIALOG statement,
        // they should use DIALOGEX instead.
        lpLogFont->lfWeight  = FW_BOLD;
        if (!fUseShellFont2) {
            lpLogFont->lfCharSet = (BYTE)GET_DESKTOP_CHARSET();
            *pfWillTryDefaultCharset = TRUE;
        }
        break;
    case 1:
        //
        // Win4 compatible DLG template
        //
        if (!fUseShellFont2) {
            if (IS_DBCS_ENABLED()) {
                if (lpLogFont->lfCharSet == ANSI_CHARSET) {
                    //
                    // When resource compiler generates dialog resource data
                    // from DIALOGEX template, it can specify 'charset'. but
                    // optional, if it is not specified, it will be filled
                    // with 0 (ANSI charset). But, on localized version,
                    // User might guess the default will be localized-charset
                    //
                    // [Dialog Resource File]
                    //
                    // DIALOGEX ...
                    // ...
                    // FONT pointsize, typeface, [weight], [italic], [charset]
                    //
                    // #100182
                    // Bogus hack:
                    // Some FE fonts started to have ANSI_CHARSET so the first attept would succeed.
                    // We should enumerate the charset from the beginning.
                    lpLogFont->lfCharSet = DEFAULT_CHARSET;
                    RIPMSG0(RIP_VERBOSE, "No proper CharSet information in DIALOGEX");
                }
            }
            /*
             * Note: Dialog resource version 2.0 or later has not been supported on
             * Windows 95 and 98. As of Apr/98 we decided not to deploy this new feature
             * in the standard tools. Still, NT 5 supports this new feature, preparing
             * the future transition to do the right thing.
             */
            else if (lpLogFont->lfCharSet == ANSI_CHARSET) {
                // If the first attempt fail, we'll enumerate the charset for the given facename
                *pfWillTryDefaultCharset = TRUE;
            }
            else if (lpLogFont->lfCharSet == DEFAULT_CHARSET) {
                lpLogFont->lfCharSet = (BYTE)GET_DESKTOP_CHARSET();
            }
        }
        break;
    default:
        if (lpdt->wDlgVer <= DLGRSC_VER_NT5COMPAT_RESERVE) {
            // we do nothing for the new resource compiler (>= 2.0),
            // since this version of dialogs are guarunteed to have
            // the proper character set for the dialog font.
        }
        else {
            RIPMSG1(RIP_WARNING, "Version %d resource is not supported.", lpdt->wDlgVer);
            return FALSE;
        }
        break;
    }

    return TRUE;
}

VOID FixupDlgFaceName(
        LPLOGFONT lpLogFont,
        BOOLEAN fUseShellFont,
        BOOLEAN fUseShellFont2,
        LPCWSTR lpStrSubst)
{
    if (fUseShellFont2) {
        //
        // OK, we use "MS Shell Dlg 2" as a face name.
        //
        wcsncpycch(lpLogFont->lfFaceName, gwszShellFont2, ARRAY_SIZE(gwszShellFont2));
    }
    else {
        //
        // Otherwise, get the face name from the dialog template.
        //
        wcsncpycch(lpLogFont->lfFaceName, lpStrSubst, sizeof(lpLogFont->lfFaceName) / sizeof(WCHAR));
    }

    //
    // "MS Shell Dlg" and "MS Shell Dlg2" should have native character set ---
    //
    if (fUseShellFont || fUseShellFont2) {
        lpLogFont->lfCharSet = (BYTE)GetACPCharSet();
    }
}


HFONT CreateDlgFont(HDC hdcDlg, LPWORD FAR *lplpstr, LPDLGTEMPLATE2 lpdt, DWORD dwExpWinVer, UINT fSCDLGFlags)
{
    LOGFONT     LogFont;
    int         fontheight, fheight;
    HFONT       hOldFont, hFont;
    WCHAR       szTempBuffer[LF_FACESIZE];
    LPCWSTR     lpStrSubst;
    TEXTMETRIC  tm;
    // Font hacks
    BOOLEAN     fDeleteFont;
    BOOLEAN     fWillTryDefaultCharset = FALSE;
    BOOLEAN     fUseShellFont, fUseShellFont2;

    UNREFERENCED_PARAMETER(dwExpWinVer);
    UNREFERENCED_PARAMETER(fSCDLGFlags);

    fheight = fontheight = (SHORT)(*((WORD *) *lplpstr)++);

    if (fontheight == 0x7FFF) {
        // a 0x7FFF height is our special code meaning use the message box font
        GetObject(KHFONT_TO_HFONT(gpsi->hMsgFont), sizeof(LOGFONT), &LogFont);
        return CreateFontIndirect(&LogFont);
    }

    //
    // The dialog template contains a font description! Use it.
    //

    // Fill the LogFont with default values
    RtlZeroMemory(&LogFont, sizeof(LOGFONT));

    fontheight = -MultDiv(fontheight, gpsi->dmLogPixels, 72);
    LogFont.lfHeight = fontheight;

    if (lpdt->wDlgVer) {
        //
        // If it's DIALOGEX, additional info should be read from
        // the template.
        //
        LogFont.lfWeight  = *((WORD FAR *) *lplpstr)++;
        LogFont.lfItalic  = *((BYTE FAR *) *lplpstr)++;
        LogFont.lfCharSet = *((BYTE FAR *) *lplpstr)++;
    }

    //
    // Per shell team request, the dialog who has DS_SETFONT
    // *and* DS_FIXEDSYS (=> DS_SHELLFONT2) should have a font
    // "MS Shell Dlg 2".
    //
    lpStrSubst = *lplpstr;

    //
    // Set the pointer to the next item.
    //
    *lplpstr = (WORD*)DWordSkipSz(*lplpstr);

    fUseShellFont = _wcsicmp(lpStrSubst, gwszShellFont) == 0;

    //
    // Later shell team request again, to use "Dlg 2" font only
    // when facename in the dialog template is "MS Shell Dlg".
    //
    fUseShellFont2 = fUseShellFont &&
        (lpdt->style & DS_SHELLFONT) == DS_SHELLFONT && Is400Compat(dwExpWinVer) && lpdt->wDlgVer != 0;

    if (fUseShellFont2) {
        TAGMSG0(DBGTAG_IMM, "CreateDlgFont: fUseShellFont2=TRUE");
    }

    //
    // Prepare the font character set.
    //
    if (!FixupDlgLogFont(hdcDlg, &LogFont, lpdt, fUseShellFont2, &fWillTryDefaultCharset)) {
        return NULL;
    }

    //
    // Prepare the font facename.
    //
    FixupDlgFaceName(&LogFont, fUseShellFont, fUseShellFont2, lpStrSubst);

    if (lpdt->wDlgVer < 2 && lpdt->style & DS_3DLOOK)
        LogFont.lfWeight = FW_NORMAL;

TryDefaultCharset:
    if (LogFont.lfCharSet == DEFAULT_CHARSET) {
        //
        // Get character set for given facename.
        //
        EnumFonts(hdcDlg, LogFont.lfFaceName,
                  (FONTENUMPROC)GetCharsetEnumProc, (LPARAM)(&LogFont));
        //
        // We already tried default charset.
        //
        fWillTryDefaultCharset = FALSE;
    }

    //
    // [Windows 3.1 FarEast version did this...]
    //
    // Use FW_NORMAL as default for DIALOG template. For DIALOGEX
    // template, we need to respect the value in the template.
    //
    if ((!(lpdt->wDlgVer)) && // not DIALOGEX template ?
        (IS_ANY_DBCS_CHARSET(LogFont.lfCharSet)) && // any FarEast font ?
        (LogFont.lfWeight != FW_NORMAL)) { // already FW_NORMAL ?

        //
        // Set weight to FW_NORMAL.
        //
        LogFont.lfWeight = FW_NORMAL;
    }

    if (!(hFont = CreateFontIndirect((LPLOGFONT) &LogFont)))
        return(NULL);

    fDeleteFont = FALSE;

    if ((hOldFont = SelectFont(hdcDlg, hFont)) == NULL) {
        fDeleteFont = TRUE;
    }
    else {
        //
        // If this dialog has DS_SHELLFONT style, or the font is
        // "MS Shell Dlg", we don't judge the font integrity,
        // for they have been given the ACP based character set.
        //
        if (!fUseShellFont) {
            if (!GetTextMetrics(hdcDlg, &tm)) {
                RIPMSG0(RIP_WARNING, "CreateDlgFont: GetTextMetrics failed");
                fDeleteFont = TRUE;
            }
            else {
                GetTextFaceAliasW(hdcDlg, sizeof(szTempBuffer)/sizeof(WCHAR), szTempBuffer);

                //
                // If this is a low res device, we need to check if the
                // font we're creating is smaller than the system font.
                // If so, just use the system font.
                //
                if (IsFontNotGood(szTempBuffer, lpStrSubst, &tm)) {
                    //
                    // Couldn't find a font with the height or facename
                    // the app wanted so use the system font instead. Note
                    // that we need to make sure the app knows it is
                    // getting the system font via the WM_SETFONT message
                    // so we still need to act as if a new font is being
                    // sent to the dialog box.
                    //
                    fDeleteFont = TRUE;
                }
            }
        }

        UserAssert(hOldFont != NULL);
        SelectFont(hdcDlg, hOldFont);
    }

    if (fDeleteFont) {
        DeleteFont(hFont);
        //
        // Font is deleted, Prepare for reTry...
        //
        hFont = NULL;
    }

    // Font hack:
    //
    // 1. We fail to create font.
    // 2. We did *NOT* try to enumerate charset, yet.
    // 3. We want to try to enumerate charset
    //
    // if all of answer is 'Yes', we will try...
    //
    if (hFont == NULL && fWillTryDefaultCharset) {
        //
        // Try DEFAULT_CHARSET.
        //
        LogFont.lfCharSet = DEFAULT_CHARSET;
        goto TryDefaultCharset;
    }

    return hFont;
}

#undef GET_DESKTOP_CHARSET

#define CD_VISIBLE          0x01
#define CD_GLOBALEDIT       0x02
#define CD_USERFONT         0x04
#define CD_SETFOREGROUND    0x08
#define CD_USEDEFAULTX      0x10
#define CD_USEDEFAULTCX     0x20


/***************************************************************************\
* GetDialogMonitor
*
* Gets the monitor a dialog should be created on.
*
* Params:
*     hwndOwner - the owner of the dialog. May be NULL.
*
* History:
* 10-Oct-1996 adams     Created.
\***************************************************************************/

PMONITOR
GetDialogMonitor(HWND hwndOwner, DWORD dwFlags)
{
    PMONITOR    pMonitor;
    PWND        pwnd;
    HWND        hwndForeground;
    DWORD       pid;

    UserAssert(dwFlags == MONITOR_DEFAULTTONULL ||
               dwFlags == MONITOR_DEFAULTTOPRIMARY);

    pMonitor = NULL;
    if (hwndOwner) {
        pwnd = ValidateHwnd(hwndOwner);
        if (pwnd && GETFNID(pwnd) != FNID_DESKTOP) {
            pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
        }
    } else {
        /*
         * HACK!  They passed in no owner and are creating a top level
         * dialog window.  Does this process own the foreground window?
         * If so, pin to that window's monitor.  That way 16-bit apps
         * will work mostly as expected, and old multithreaded dudes just
         * might too.  Especially the shell, for whom many system UI pieces
         * pop up random dialogs inside of API calls.
         */

        hwndForeground = NtUserGetForegroundWindow();
        if (hwndForeground) {
            GetWindowThreadProcessId(hwndForeground, &pid);
            if (pid == HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) {
                pwnd = ValidateHwnd(hwndForeground);
                if (pwnd) {
                    pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
                }
            }
        }
    }

    if (!pMonitor && dwFlags == MONITOR_DEFAULTTOPRIMARY) {
        pMonitor = GetPrimaryMonitor();
    }

    return pMonitor;
}


/***************************************************************************\
* InternalCreateDialog
*
* Creates a dialog from a template. Uses passed in menu if there is one,
* destroys menu if creation failed. Server portion of
* CreateDialogIndirectParam.
*
* WARNING: This function cannot create any windows before creating the dialog
*           window. Otherwise, MFC apps will break because their hook assumes
*           the dialog is the first window to be created.
*
* History:
* 04-10-91 ScottLu
* 04-17-91 Mikehar Win31 Merge
\***************************************************************************/


HWND InternalCreateDialog(
    HANDLE hmod,
    LPDLGTEMPLATE lpdt,
    DWORD cb,
    HWND hwndOwner,
    DLGPROC lpfnDialog,
    LPARAM lParam,
    UINT fSCDLGFlags)
{
    HWND                hwnd;
    HWND                hwnd2;
    PWND                pwnd;
    HWND                hwndNewFocus;
    HWND                hwndEditFirst = NULL;
    RECT                rc;
    WORD                w;
    UTCHAR              *lpszMenu,
                        *lpszClass,
                        *lpszText,
                        *lpCreateParams,
                        *lpStr;
    int                 cxChar,
                        cyChar;
    BOOL                f40Compat;
    HFONT               hNewFont = NULL;
    HFONT               hOldFont;
    LPDLGITEMTEMPLATE   lpdit;
    HMENU               hMenu;
    BOOL                fSuccess;
    BOOL                fWowWindow;
    HANDLE              hmodCreate;
    LPBYTE              lpCreateParamsData;
    DLGTEMPLATE2        dt;
    DLGITEMTEMPLATE2    dit;
    DWORD               dwExpWinVer;
    DWORD               dsStyleOld;
    DWORD               bFlags = 0;
    HDC                 hdcDlg;
    LARGE_STRING        strClassName;
    PLARGE_STRING       pstrClassName;
    LARGE_STRING        strWindowName;
    PMONITOR            pMonitor;

    UNREFERENCED_PARAMETER(cb);

    ConnectIfNecessary(0);

    UserAssert(!(fSCDLGFlags & ~(SCDLG_CLIENT|SCDLG_ANSI|SCDLG_NOREVALIDATE|SCDLG_16BIT)));    // These are the only valid flags

    /*
     * If the app is a Wow app then the LOWORD of the hmod (properly masked
     * with LDR_DATAFILE_TO_VIEW) will be non-zero.
     */
    if (LOWORD(LDR_DATAFILE_TO_VIEW(hmod)) == 0) {
        fWowWindow = FALSE;
    } else {
        fWowWindow = TRUE;
    }

    /*
     * Is this a Win4 extended dialog?
     */
    if (((LPDLGTEMPLATE2)lpdt)->wSignature == 0xffff) {
        UserAssert(((LPDLGTEMPLATE2)lpdt)->wDlgVer <= DLGRSC_VER_NT5COMPAT_RESERVE);
        RtlCopyMemory(&dt, lpdt, sizeof dt);
    } else {
        dt.wDlgVer = 0;
        dt.wSignature = 0;
        dt.dwHelpID = 0;
        dt.dwExStyle = lpdt->dwExtendedStyle;
        dt.style = lpdt->style;
        dt.cDlgItems = lpdt->cdit;
        dt.x = lpdt->x;
        dt.y = lpdt->y;
        dt.cx = lpdt->cx;
        dt.cy = lpdt->cy;
    }

    /*
     * If this is called from wow code, then the fWowWindow is TRUE.
     * In this case, allow any DS_ style bits that were passed in win3.1
     * to be legal in win32. Case in point: 16 bit quark xpress passes the
     * same bit as the win32 style DS_SETFOREGROUND. Also, VC++ sample
     * "scribble" does the same thing.
     *
     * For win32 apps test the DS_SETFOREGROUND bit; wow apps are not set
     * foreground (this is the new NT semantics)
     * We have to let no "valid" bits through because apps depend on them
     * bug 5232.
     */
    dsStyleOld = LOWORD(dt.style);

    /*
     * If the app is Win4 or greater, require correct dialog style bits.
     * Prevents conflicts with new bits introduced in Chicago
     */
    dwExpWinVer = GETEXPWINVER(hmod) | CW_FLAGS_VERSIONCLASS;

    if ( f40Compat = Is400Compat(dwExpWinVer) ) {
        dt.style &= (DS_VALID40 | 0xffff0000);

        //
        // For old applications:
        //      If DS_COMMONDIALOG isn't set, don't touch DS_3DLOOK style
        // bit.  If it's there, it stays there.  If not, not.  That way old
        // apps which pass in their own templates, not commdlg's, don't get
        // forced 3D.
        //      If DS_COMMONDIALOG is there, remove DS_3DLOOK.
        //
        // For new applications:
        //      Force 3D always.
        //
        if (GETAPPVER() < VER40) {
            if (dt.style & DS_COMMONDIALOG) {
                dt.style &= ~DS_3DLOOK;
                dsStyleOld &= ~DS_3DLOOK;
            }
        } else {
            dt.style |= DS_3DLOOK;
            dsStyleOld |= DS_3DLOOK;
        }
    } else {
#if DBG
        if (dt.style != (dt.style & (DS_VALID31 | DS_3DLOOK | 0xffff0000))) {
            RIPMSG1(RIP_WARNING, "CreateDialog: stripping invalid bits %lX", dt.style);
        }
#endif // DBG


        /*
         * Don't strip off bits for old apps, they depend on this.  Especially 16 bit MFC apps!
         *
         * dt.dwStyle &= (DS_VALID31 | 0xffff0000);
         */
    }

    if (!fWowWindow) {
        if (dt.style & DS_SETFOREGROUND)
            bFlags |= CD_SETFOREGROUND;
    }

    if (dsStyleOld != LOWORD(dt.style))
    {

        RIPMSG1(f40Compat ? RIP_ERROR : RIP_WARNING,
                "Bad dialog style bits (%x) - please remove.",
                LOWORD(dt.style));
        // Fail new apps that pass in bogus bits!

        if (f40Compat) {
            return NULL;
        }
    }

    if ( dt.style & DS_MODALFRAME) {
        dt.dwExStyle |= WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE;
    }

    if (( dt.style & DS_CONTEXTHELP) && f40Compat) {
        dt.dwExStyle |= WS_EX_CONTEXTHELP;
    }

    if (dt.style & DS_CONTROL) {
        // Captions and system menus aren't allowed on "control" dialogs.
        // And strip DS_SYSMODAL.
        dt.style &= ~(WS_CAPTION | WS_SYSMENU | DS_SYSMODAL);
    } else if (dt.style & WS_DLGFRAME) {
        // Add on window edge same way that CreateWindowEx() will
        dt.dwExStyle |= WS_EX_WINDOWEDGE;
    }

    if (dt.style & DS_SYSMODAL) {
        dt.dwExStyle |= WS_EX_TOPMOST;
    }

    if (!(dt.style & WS_CHILD) || (dt.style & DS_CONTROL)) {
        // only a control parent if it's not a child dialog or if it's
        // explicitly marked as a recursive dialog
        dt.dwExStyle |= WS_EX_CONTROLPARENT;
    }

    if (dt.x == (short)CW2_USEDEFAULT) {
        bFlags |= CD_USEDEFAULTX;
        dt.x = 0;
    }

    if (dt.cx == (short)CW2_USEDEFAULT) {
        bFlags |= CD_USEDEFAULTCX;
        dt.cx = 0;
    } else if (dt.cx < 0) {
        dt.cx = 0;
    }

    if (dt.cy < 0) {
        dt.cy = 0;
    }


    // If there's a menu name string, load it.
    lpszMenu = (LPWSTR)(((PBYTE)(lpdt)) + (dt.wDlgVer ? sizeof(DLGTEMPLATE2):sizeof(DLGTEMPLATE)));

    /*
     * If the menu id is expressed as an ordinal and not a string,
     * skip all 4 bytes to get to the class string.
     */
    w = *(LPWORD)lpszMenu;

    /*
     * If there's a menu name string, load it.
     */
    if (w != 0) {
        if ((hMenu = LoadMenu(hmod, (w == 0xFFFF) ?
                MAKEINTRESOURCE(*(WORD *)((PBYTE)lpszMenu + 2)) : lpszMenu)) == NULL) {
            RIPMSG0(RIP_WARNING, "ServerCreateDialog() failed: couldn't load menu");
            goto DeleteFontAndMenuAndFail;
        }
    } else {
        hMenu = NULL;
    }

    if (w == 0xFFFF) {
        lpszClass = (LPWSTR)((LPBYTE)lpszMenu + 4);
    } else {
        lpszClass = (UTCHAR *)WordSkipSz(lpszMenu);
    }

    lpszText = (UTCHAR *)WordSkipSz(lpszClass);

    lpStr = (UTCHAR *)WordSkipSz(lpszText);

    hdcDlg = CreateCompatibleDC(NULL);
    if (hdcDlg == NULL)
        goto DeleteFontAndMenuAndFail;

    if (dt.style & DS_SETFONT) {
        hNewFont = CreateDlgFont(hdcDlg, &lpStr, &dt, dwExpWinVer, fSCDLGFlags);
        bFlags |= CD_USERFONT;
        lpdit = (LPDLGITEMTEMPLATE) NextDWordBoundary(lpStr);
    } else if (Is400Compat(dwExpWinVer) && (dt.style & DS_FIXEDSYS)) {

        //
        // B#2078 -- WISH for fixed width system font in dialog.  We need
        // to tell the dialog that it's using a font different from the
        // standard system font, so set CD_USERFONT bit.
        //
        // We need the 400 compat. check for CorelDraw, since they use
        // this style bit for their own purposes.
        //
        hNewFont = GetStockObject(SYSTEM_FIXED_FONT);
        bFlags |= CD_USERFONT;
        lpdit = (LPDLGITEMTEMPLATE)NextDWordBoundary(lpStr);
    } else {
        lpdit = (LPDLGITEMTEMPLATE)NextDWordBoundary(lpStr);
    }

    /*
     * If the application requested a particular font and for some
     * reason we couldn't find it, we just use the system font.  BUT we
     * need to make sure we tell him he gets the system font.  Dialogs
     * which never request a particular font get the system font and we
     * don't bother telling them this (via the WM_SETFONT message).
     */

    // Is it anything other than the default system font?  If we can't get
    // enough memory to select in the new font specified, just use the system
    // font.
    if (hNewFont && (hOldFont = SelectFont(hdcDlg, hNewFont))) {
        // Get the ave character width and height to be used
        cxChar = GdiGetCharDimensions(hdcDlg, NULL, &cyChar);

        SelectFont(hdcDlg, hOldFont);
        if (cxChar == 0) {
            RIPMSG0(RIP_WARNING, "InternalCreateDialog: GdiGetCharDimensions failed");
            goto UseSysFontMetrics;
        }
    }
    else
    {
        if (hNewFont || (bFlags & CD_USERFONT))
            hNewFont = ghFontSys;

UseSysFontMetrics:
        cxChar = gpsi->cxSysFontChar;
        cyChar = gpsi->cySysFontChar;
    }
    DeleteDC(hdcDlg);

    if (dt.style & WS_VISIBLE) {
        bFlags |= CD_VISIBLE;
        dt.style &= ~WS_VISIBLE;
    }

    if (!(dt.style & DS_LOCALEDIT)) {
        bFlags |= CD_GLOBALEDIT;
    }

    /* Figure out dimensions of real window
     *
     * NOTE: We need to call the _Real_ AdjustWindowRectEx() function and not
     * the hooked one because Themes uses the initial size that the dialog comes
     * up to determine how much to enlarge it by.
     */
    rc.left = rc.top = 0;
    rc.right = XPixFromXDU(dt.cx, cxChar);
    rc.bottom = YPixFromYDU(dt.cy, cyChar);

    RealAdjustWindowRectEx(&rc, dt.style, w, dt.dwExStyle);

    dt.cx = (SHORT)(rc.right - rc.left);
    dt.cy = (SHORT)(rc.bottom - rc.top);

    if ((dt.style & DS_CENTERMOUSE) && SYSMET(MOUSEPRESENT) && f40Compat) {
        pMonitor = _MonitorFromPoint(gpsi->ptCursor, MONITOR_DEFAULTTONULL);
        UserAssert(pMonitor);
        *((LPPOINT)&rc.left) = gpsi->ptCursor;
        rc.left -= (dt.cx / 2);
        rc.top  -= (dt.cy / 2);
    } else {
        BOOL fNoDialogMonitor;

        pMonitor = GetDialogMonitor(hwndOwner, MONITOR_DEFAULTTONULL);
        fNoDialogMonitor = pMonitor ? FALSE : TRUE;
        if (!pMonitor) {
            pMonitor = GetPrimaryMonitor();
        }

        if ((dt.style & (DS_CENTER | DS_CENTERMOUSE)) && f40Compat) {
            /*
             * Center to the work area of the owner monitor.
             */
            rc.left = (pMonitor->rcWork.left + pMonitor->rcWork.right - dt.cx) / 2;
            rc.top  = (pMonitor->rcWork.top + pMonitor->rcWork.bottom - dt.cy) / 2;
        } else {
            rc.left = XPixFromXDU(dt.x, cxChar);
            rc.top = YPixFromYDU(dt.y, cyChar);

            if (!(dt.style & DS_ABSALIGN) && hwndOwner) {
                /*
                 * Offset relative coordinates to the owner window. If it is
                 * a child window, there is nothing to do.
                 */
                if ((HIWORD(dt.style) & MaskWF(WFTYPEMASK)) != MaskWF(WFCHILD)) {
                    //This is will considre rc.left form the right hand side of the owner window if it a mirrored one.
                    ClientToScreen(hwndOwner, (LPPOINT)&rc.left);

                    //It is not chiled then do Visual ClientToScreen
                    //i.e. rc.left it is form the left hand side of the owner window
                    if (MIRRORED_HWND(hwndOwner)) {
                        rc.left -= dt.cx;
                    }
                }
            } else {
                /*
                 * Position the dialog in screen coordinates. If the dialog's
                 * owner is on a different monitor than specified in the
                 * template, move the dialog to the owner window. If the owner
                 * doesn't exist, then use the monitor from the dialog's
                 * template.
                 */

                PMONITOR    pMonitorTemplate;
                RECT        rcTemplate;

                rcTemplate.left  = rc.left;
                rcTemplate.top   = rc.top;
                rcTemplate.right  = rc.left + dt.cx;
                rcTemplate.bottom = rc.top + dt.cy;

                pMonitorTemplate = _MonitorFromRect(&rcTemplate, MONITOR_DEFAULTTOPRIMARY);
                if (fNoDialogMonitor) {
                    pMonitor = pMonitorTemplate;
                } else if (pMonitorTemplate != pMonitor) {
                    rc.left += pMonitor->rcMonitor.left - pMonitorTemplate->rcMonitor.left;
                    rc.top  += pMonitor->rcMonitor.top  - pMonitorTemplate->rcMonitor.top;
                }
            }
        }
    }

    rc.right  = rc.left + dt.cx;
    rc.bottom = rc.top  + dt.cy;

    // If the right or bottom coordinate has overflowed, then pin it back to
    // a valid rectangle.  Likely to happen if a minimized window is the owner of
    // the dialog.
    if (rc.left > rc.right || rc.top > rc.bottom) {
        OffsetRect(&rc, -dt.cx, -dt.cy);
    }

   //
    // Need to do this for ALL dialogs, not just top-level, since we used
    // to in 3.1.
    //

    // Clip top level dialogs within working area
    // Start child dialogs at least at (0, 0)
    RepositionRect(pMonitor, &rc, dt.style, dt.dwExStyle);

    dt.x  = (SHORT)((bFlags & CD_USEDEFAULTX) ? CW2_USEDEFAULT : rc.left);
    dt.y  = (SHORT)(rc.top);
    dt.cx = (SHORT)((bFlags & CD_USEDEFAULTCX) ? CW2_USEDEFAULT : rc.right - rc.left);
    dt.cy = (SHORT)(rc.bottom - rc.top);

    if (*lpszClass != 0) {
        if (IS_PTR(lpszClass)) {
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strClassName,
                    lpszClass, (UINT)-1);
            pstrClassName = &strClassName;
        } else {
            pstrClassName = (PLARGE_STRING)lpszClass;
        }
    } else {
        pstrClassName = (PLARGE_STRING)DIALOGCLASS;
    }

    RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strWindowName,
            lpszText, (UINT)-1);

    UserAssert((dt.dwExStyle & WS_EX_MDICHILD) == 0);
    hwnd = VerNtUserCreateWindowEx(
            dt.dwExStyle | ((fSCDLGFlags & SCDLG_ANSI) ? WS_EX_ANSICREATOR : 0),
            pstrClassName,
            &strWindowName,
            dt.style,
            DefShortToInt(dt.x),
            dt.y,
            DefShortToInt(dt.cx),
            dt.cy,
            hwndOwner,
            hMenu,
            hmod,
            (LPVOID)NULL,
            dwExpWinVer);

    if (hwnd == NULL) {
        RIPMSG0(RIP_WARNING, "CreateDialog() failed: couldn't create window");
DeleteFontAndMenuAndFail:
        if (hMenu != NULL)
            NtUserDestroyMenu(hMenu);
        /*
         * Only delete the font if we didn't grab it
         * from the dialog font cache.
         */
        if ((hNewFont != NULL)) {
            DeleteObject(hNewFont);
        }
        return NULL;
    }

    pwnd = ValidateHwnd(hwnd);

    // tell WOW the hDlg of the Window just created BEFORE they get any messages
    // at WOW32!w32win16wndprocex
    if(fSCDLGFlags & SCDLG_16BIT) {
        TellWOWThehDlg(hwnd);
    }

    /*
     * Before anything happens with this window, we need to mark it as a
     * dialog window!!!! So do that.
     */
    if (pwnd == NULL || !ValidateDialogPwnd(pwnd))
        goto DeleteFontAndMenuAndFail;

    if (dt.dwHelpID) {
        NtUserSetWindowContextHelpId(hwnd, dt.dwHelpID);
    }

    /*
     * Set up the system menu on this dialog box if it has one.
     */
    if (TestWF(pwnd, WFSYSMENU)) {

        /*
         * For a modal dialog box with a frame and caption, we want to
         * delete the unselectable items from the system menu.
         */
        UserAssert(HIBYTE(WFSIZEBOX) == HIBYTE(WFMINBOX));
        UserAssert(HIBYTE(WFMINBOX) == HIBYTE(WFMAXBOX));
        if (!TestWF(pwnd, WFSIZEBOX | WFMINBOX | WFMAXBOX)) {

            NtUserCallHwndLock(hwnd, SFI_XXXSETDIALOGSYSTEMMENU);
        } else {

            /*
             * We have to give this dialog its own copy of the system menu
             * in case it modifies the menu.
             */
            NtUserGetSystemMenu(hwnd, FALSE);
        }
    }

    /*
     * Set fDisabled to FALSE so EndDialog will Enable if dialog is ended
     * before returning to DialogBox (or if modeless).
     */
    PDLG(pwnd)->fDisabled = FALSE;

    PDLG(pwnd)->cxChar = cxChar;
    PDLG(pwnd)->cyChar = cyChar;
    PDLG(pwnd)->lpfnDlg = lpfnDialog;
    PDLG(pwnd)->fEnd = FALSE;
    PDLG(pwnd)->result = IDOK;

    /*
     * Need to remember Unicode status.
     */
    if (fSCDLGFlags & SCDLG_ANSI) {
        PDLG(pwnd)->flags |= DLGF_ANSI;
    }

    /*
     * If a user defined font is used, save the handle so that we can delete
     * it when the dialog is destroyed.
     */
    if (bFlags & CD_USERFONT) {

        PDLG(pwnd)->hUserFont = hNewFont;

        if (lpfnDialog != NULL) {
            /*
             * Tell the dialog that it will be using this font...
             */
            SendMessageWorker(pwnd, WM_SETFONT, (WPARAM)hNewFont, 0L, FALSE);
        }
    }

    if (!dt.wDlgVer) {
        dit.dwHelpID = 0;
    }

    /*
     * Loop through the dialog controls, doing a CreateWindowEx() for each of
     * them.
     */
    while (dt.cDlgItems-- != 0) {
        DWORD dwExpWinVer2;

        if (dt.wDlgVer) {
            RtlCopyMemory(&dit, lpdit, sizeof dit);
        } else {
            dit.dwHelpID = 0;
            dit.dwExStyle = lpdit->dwExtendedStyle;
            dit.style = lpdit->style;
            dit.x = lpdit->x;
            dit.y = lpdit->y;
            dit.cx = lpdit->cx;
            dit.cy = lpdit->cy;
            dit.dwID = lpdit->id;
        }

        dit.x = XPixFromXDU(dit.x, cxChar);
        dit.y = YPixFromYDU(dit.y, cyChar);
        dit.cx = XPixFromXDU(dit.cx, cxChar);
        dit.cy = YPixFromYDU(dit.cy, cyChar);

        lpszClass = (LPWSTR)(((PBYTE)(lpdit)) + (dt.wDlgVer ? sizeof(DLGITEMTEMPLATE2):sizeof(DLGITEMTEMPLATE)));

        /*
         * If the first WORD is 0xFFFF the second word is the encoded class name index.
         * Use it to look up the class name string.
         */
        if (*(LPWORD)lpszClass == 0xFFFF) {
            lpszText = lpszClass + 2;
            lpszClass = (LPWSTR)(gpsi->atomSysClass[*(((LPWORD)lpszClass)+1) & ~CODEBIT]);
        } else {
            lpszText = (UTCHAR *)SkipSz(lpszClass);
        }
        lpszText = (UTCHAR *)NextWordBoundary(lpszText); // UINT align lpszText

        dit.dwExStyle |= WS_EX_NOPARENTNOTIFY;

        //
        // Replace flat borders with 3D ones for DS_3DLOOK dialogs
        // We test the WINDOW style, not the template style now.  This is so
        // that 4.0 apps--who get 3D stuff automatically--can turn it off on
        // create if they want.
        //

        //
        // HACK!
        // Treat DS_3DLOOK combos like they have a WS_EX_CLIENTEDGE.  Why
        // should we have to draw the borders of a combobox ourselves?
        // We can't do the same thing for WS_BORDER though becaues of
        // PC Fools--they use the presence of WS_BORDER to distinguish
        // between lists and combos.
        //

        if (TestWF(pwnd, DF3DLOOK)) {
            if (    (dit.style & WS_BORDER) ||
                    (lpszClass == MAKEINTRESOURCE(gpsi->atomSysClass[ICLS_COMBOBOX]))) {

                dit.style &= ~WS_BORDER;
                dit.dwExStyle |= WS_EX_CLIENTEDGE;
            }
        }

        /*
         * Get pointer to additional data.  lpszText can point to an encoded
         * ordinal number for some controls (e.g.  static icon control) so
         * we check for that here.
         */
        if (*(LPWORD)lpszText == 0xFFFF) {
            lpCreateParams = (LPWSTR)((PBYTE)lpszText + 4);
            strWindowName.Buffer = lpszText;
            strWindowName.Length = 4;
            strWindowName.MaximumLength = 4;
            strWindowName.bAnsi = FALSE;
        } else {
            lpCreateParams = (LPWSTR)((PBYTE)WordSkipSz(lpszText));
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strWindowName,
                    lpszText, (UINT)-1);
        }

        /*
         * If control is edit control and caller wants global storage
         * of edit text, allocate object in WOW and pass instance
         * handle to CreateWindowEx().
         */
        if (fWowWindow && (bFlags & CD_GLOBALEDIT) &&
               ((!IS_PTR(lpszClass) &&
                    PTR_TO_ID(lpszClass) == (ATOM)(gpsi->atomSysClass[ICLS_EDIT])) ||
               (IS_PTR(lpszClass) &&
                    (wcscmp(lpszClass, szEDITCLASS) == 0)))) {

            /*
             * Allocate only one global object (first time we see editctl.)
             */
            if (!(PDLG(pwnd)->hData)) {
                PDLG(pwnd)->hData = GetEditDS();
                if (!(PDLG(pwnd)->hData))
                    goto NoCreate;
            }

            hmodCreate = KHANDLE_TO_HANDLE(PDLG(pwnd)->hData);
            dwExpWinVer2 = GETEXPWINVER(hmodCreate) | CW_FLAGS_VERSIONCLASS;
        } else {
            hmodCreate = hmod;
            dwExpWinVer2 = dwExpWinVer;
        }

#if DBG
        if ((dit.dwExStyle & WS_EX_ANSICREATOR) != 0) {
            RIPMSG1(RIP_WARNING, "Bad WS_EX_ style 0x%x for a control in the dialog",
                    dit.dwExStyle);
        }
#endif // DBG

        /*
         * Get pointer to additional data.
         *
         * For WOW, instead of pointing lpCreateParams at the CreateParams
         * data, set lpCreateParams to whatever DWORD is stored in the 32-bit
         * DLGTEMPLATE's CreateParams.  WOW has already made sure that that
         * 32-bit value is indeed a 16:16 pointer to the CreateParams in the
         * 16-bit DLGTEMPLATE.
         */

        if (*lpCreateParams) {
            lpCreateParamsData = (LPBYTE)lpCreateParams;
            if (fWowWindow || fSCDLGFlags & SCDLG_16BIT) {
                lpCreateParamsData =
                    (LPBYTE)ULongToPtr( *(UNALIGNED DWORD *) /* Sundown WOW: zero-extension */
                    (lpCreateParamsData + sizeof(WORD)) );
            }
        } else {
            lpCreateParamsData = NULL;
        }

        /*
         * If the dialog template specifies a menu ID then TestwndChild(pwnd)
         * must be TRUE or CreateWindowEx will think the ID is an hMenu rather
         * than an ID (in a dialog template you'll never have an hMenu).
         * However for compatibility reasons we let it go if the ID = 0.
         */
        if (dit.dwID) {
            /*
             * This makes TestwndChild(pwnd) on this window return TRUE.
             */
            dit.style |= WS_CHILD;
            dit.style &= ~WS_POPUP;
        }

        if (IS_PTR(lpszClass)) {
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strClassName,
                    lpszClass, (UINT)-1);
            pstrClassName = &strClassName;
        } else {
            pstrClassName = (PLARGE_STRING)lpszClass;
        }

        UserAssert((dit.dwExStyle & WS_EX_MDICHILD) == 0);

        hwnd2 = VerNtUserCreateWindowEx(
                dit.dwExStyle | ((fSCDLGFlags & SCDLG_ANSI) ? WS_EX_ANSICREATOR : 0),
                pstrClassName,
                &strWindowName,
                dit.style,
                DefShortToInt(dit.x),
                dit.y,
                DefShortToInt(dit.cx),
                dit.cy,
                hwnd,
                (HMENU)LongToHandle( dit.dwID ),
                hmodCreate,
                lpCreateParamsData,
                dwExpWinVer2);

        if (hwnd2 == NULL) {
NoCreate:
            /*
             * Couldn't create the window -- return NULL.
             */
            if (!TestWF(pwnd, DFNOFAILCREATE)) {
                RIPMSG0(RIP_WARNING, "CreateDialog() failed: couldn't create control");
                NtUserDestroyWindow(hwnd);
                return NULL;
            }
        } else {

            if (dit.dwHelpID) {
                NtUserSetWindowContextHelpId(hwnd2, dit.dwHelpID);
            }

        /*
         * If it is a not a default system font, set the font for all the
         * child windows of the dialogbox.
         */
            if (hNewFont != NULL) {
                SendMessage(hwnd2, WM_SETFONT, (WPARAM)hNewFont, 0L);
            }

        /*
         * Result gets ID of last (hopefully only) defpushbutton.
         */
            if (SendMessage(hwnd2, WM_GETDLGCODE, 0, 0L) & DLGC_DEFPUSHBUTTON) {
                PDLG(pwnd)->result = dit.dwID;
            }
        }

        /*
         * Point at next item template
         */
        lpdit = (LPDLGITEMTEMPLATE)NextDWordBoundary(
                (LPBYTE)(lpCreateParams + 1) + *lpCreateParams);
    }

    if (!TestWF(pwnd, DFCONTROL)) {
        PWND pwndT = _GetNextDlgTabItem(pwnd, NULL, FALSE);
        hwndEditFirst = HW(pwndT);
    }

    if (lpfnDialog != NULL) {
        fSuccess = (BOOL)SendMessageWorker(pwnd, WM_INITDIALOG,
                               (WPARAM)hwndEditFirst, lParam, FALSE);

        //
        // Make sure the window didn't get nuked during WM_INITDIALOG
        //
        if (!RevalidateHwnd(hwnd)) {
            goto CreateDialogReturn;
        }
        if (fSuccess && !PDLG(pwnd)->fEnd) {

            //
            // To remove the two-default-push-buttons problem, we must make
            // sure CheckDefPushButton() will remove default from other push
            // buttons.  This happens only if hwndEditFirst != hwndNewFocus;
            // So, we make it NULL here. This breaks Designer's install
            // program(which can't take a DM_GETDEFID.  So, we do a version
            // check here.
            //
            if (!TestWF(pwnd, DFCONTROL)) {
                PWND pwndT;
                if (!IsWindow(hwndEditFirst) || TestWF(pwnd, WFWIN40COMPAT))
                    hwndEditFirst = NULL;

                //
                // They could have disabled hwndEditFirst during WM_INITDIALOG.
                // So, let use obtain the First Tab again.
                //
                pwndT = _GetNextDlgTabItem(pwnd, NULL, FALSE);
                if (hwndNewFocus = HW(pwndT)) {
                    DlgSetFocus(hwndNewFocus);
                }

                xxxCheckDefPushButton(pwnd, hwndEditFirst, hwndNewFocus);
            }
        }
    }

    if (!IsWindow(hwnd))
    {
        // Omnis7 relies on a nonzero return even though they nuked this
        // dialog during processing of the WM_INITDIALOG message
        // -- jeffbog -- 2/24/95 -- Win95B B#12368
        if (GETAPPVER() < VER40) {
            return(hwnd);
        }

        return(NULL);
    }

    /*
     * UISTATE: if keyboard indicators are on and this is a topmost dialog
     * set the internal bit.
     */
    if (TEST_KbdCuesPUSIF) {
        /*
         * If property page, UISTATE bits were copied from parent when I was created
         * Top level dialogs act as containers and initialize their state based on
         * the type of the last input event, after sending UIS_INITIALIZE
         */
        if (!TestwndChild(pwnd)) {
            SendMessageWorker(pwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0, FALSE);
        }
    }

    /*
     * Bring this dialog into the foreground
     * if DS_SETFOREGROUND is set.
     */
    if (bFlags & CD_SETFOREGROUND) {
        NtUserSetForegroundWindow(hwnd);
        if (!IsWindow(hwnd)) {
            hwnd = NULL;
            goto CreateDialogReturn;
        }
    }

    if ((bFlags & CD_VISIBLE) && !PDLG(pwnd)->fEnd && (!TestWF(pwnd, WFVISIBLE))) {
        NtUserShowWindow(hwnd, SHOW_OPENWINDOW);
        UpdateWindow(hwnd);
    }

CreateDialogReturn:

    /*
     * 17609 Gupta's SQLWin deletes the window before CreateDialog returns
     * but still expects non-zero return value from CreateDialog so we will
     * do like win 3.1 and not revalidate for 16 bit apps
     */
    if (!(fSCDLGFlags & SCDLG_NOREVALIDATE) && !RevalidateHwnd(hwnd)) {
        hwnd = NULL;
    }

    return hwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\dlgend.c ===
/***************************************************************************\
*
*  DLGEND.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Dialog Destruction Routines
*
* ??-???-???? mikeke    Ported from Win 3.0 sources
* 12-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* EndDialog
*
* History:
* 11-Dec-1990 mikeke  ported from win30
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EndDialog, HWND, hwnd, INT_PTR, result)
BOOL EndDialog(
    HWND hwnd,
    INT_PTR result)
{
    PWND pwnd;
    PWND pwndOwner;
    HWND hwndOwner;
    BOOL fWasActive = FALSE;
#ifdef SYSMODALWINDOWS
    HWND hwndOldSysModal;
#endif

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    CheckLock(pwnd);

    /*
     * Must do special validation here to make sure pwnd is a dialog window.
     */
    if (!ValidateDialogPwnd(pwnd))
        return 0;

    if (SAMEWOWHANDLE(hwnd, GetActiveWindow())) {
        fWasActive = TRUE;
    }

    /*
     * GetWindowCreator returns either a kernel address or NULL.
     */
    pwndOwner = GetWindowCreator(pwnd);

    if (pwndOwner != NULL) {

        /*
         * Hide the window.
         */
        pwndOwner = REBASEPTR(pwnd, pwndOwner);
        hwndOwner = HWq(pwndOwner);
        if (!PDLG(pwnd)->fDisabled) {
            NtUserEnableWindow(hwndOwner, TRUE);
        }
    } else {
        hwndOwner = NULL;
    }

    /*
     * Terminate Mode Loop.
     */
    PDLG(pwnd)->fEnd = TRUE;
    PDLG(pwnd)->result = result;

    if (fWasActive && IsChild(hwnd, GetFocus())) {

        /*
         * Set focus to the dialog box so that any control which has the focus
         * can do an kill focus processing.  Most useful for combo boxes so that
         * they can popup their dropdowns before destroying/hiding the dialog
         * box window.  Note that we only do this if the focus is currently at a
         * child of this dialog box.  We also need to make sure we are the active
         * window because this may be happening while we are in a funny state.
         * ie.  the activation is in the middle of changing but the focus hasn't
         * changed yet.  This happens with TaskMan (or maybe with other apps that
         * change the focus/activation at funny times).
         */
        NtUserSetFocus(hwnd);
    }

    NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                       SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOMOVE |
                       SWP_NOSIZE | SWP_NOZORDER);

#ifdef SYSMODALWINDOWS

    /*
     * If this guy was sysmodal, set the sysmodal flag to previous guy so we
     * won't have a hidden sysmodal window that will mess things
     * up royally...
     */
    if (pwnd == gspwndSysModal) {
        hwndOldSysModal = PDLG(pwnd)->hwndSysModalSave;
        if (hwndOldSysModal && !IsWindow(hwndOldSysModal))
            hwndOldSysModal = NULL;

        SetSysModalWindow(hwndOldSysModal);

        // If there was a previous system modal window, we want to
        // activate it instead of this window's owner.
        //
        if (hwndOldSysModal)
            hwndOwner = hwndOldSysModal;
    }
#endif

    /*
     * Don't do any activation unless we were previously active.
     */
    if (fWasActive && hwndOwner) {
        NtUserSetActiveWindow(hwndOwner);
    } else {

        /*
         * If at this point we are still the active window it means that
         * we have fallen into the black hole of being the only visible
         * window in the system when we hid ourselves.  This is a bug and
         * needs to be fixed better later on.  For now, though, just
         * set the active and focus window to NULL.
         */
        if (SAMEWOWHANDLE(hwnd, GetActiveWindow())) {
//     The next two lines are *not* the equivalent of the two Unlock
//      statements that were in Daytona server-side dlgend.c.  So, we
//      need to go over to server/kernel and do it right.  This fixes
//      a problem in Visual Slick, which had the MDI window lose focus
//      when a message box was dismissed.  FritzS
//            SetActiveWindow(NULL);
//            SetFocus(NULL);
            NtUserCallNoParam(SFI_ZAPACTIVEANDFOCUS);
        }
    }

#ifdef SYSMODALWINDOWS

    /*
     * If this guy was sysmodal, set the sysmodal flag to previous guy so we
     * won't have a hidden sysmodal window that will mess things
     * up
     * See comments for Bug #134; SANKAR -- 08-25-89 --;
     */
    if (pwnd == gspwndSysModal) {

        /*
         * Check if the previous Sysmodal guy is still valid?
         */
        hwndOldSysModal = PDLG(pwnd)->hwndSysModalSave;
        if (hwndOldSysModal && !IsWindow(hwndOldSysModal))
            hwndOldSysModal = NULL;
        SetSysModalWindow(hwndOldSysModal);
    }
#endif

    /*
     * Make sure the dialog loop will wake and destroy the window.
     * The dialog loop is waiting on posted events (WaitMessage). If
     * EndDialog is called due to a sent message from another thread the
     * dialog loop will keep waiting for posted events and not destroy
     * the window. This happens when the dialog is obscured.
     * This is a problem with winfile and its copy/move dialog.
     */
    PostMessage(hwnd, WM_NULL, 0, 0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\dlgmgr2.c ===
/***************************************************************************\
*
*  DLGMGR2.C
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Dialog Management Routines
*
* ??-???-???? mikeke    Ported from Win 3.0 sources
* 12-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxRemoveDefaultButton
*
* Scan through all the controls in the dialog box and remove the default
* button style from any button that has it.  This is done since at times we
* do not know who has the default button.
*
* History:
*
* Bug 19449 - joejo
*
*   Stop infinite loop when pwnd != pwndStart but pwnd == pwnd after calling
*   _NextControl!
\***************************************************************************/

void xxxRemoveDefaultButton(
    PWND pwndRoot,
    PWND pwndStart)
{
    UINT code;
    PWND pwnd;
    PWND pwndDup;
    TL tlpwnd;

    CheckLock(pwndRoot);
    CheckLock(pwndStart);

    if (!pwndStart || TestWF(pwndStart, WEFCONTROLPARENT))
        pwndStart = _NextControl(pwndRoot, NULL, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);
    else
        pwndStart = _GetChildControl(pwndRoot, pwndStart);

    if (!pwndStart)
        return;

    pwnd = pwndStart;
    do {
        pwndDup = pwnd;
        
        ThreadLock(pwnd, &tlpwnd);

        code = (UINT)SendMessage(HWq(pwnd), WM_GETDLGCODE, 0, 0L);

        if (code & DLGC_DEFPUSHBUTTON) {
            SendMessage(HWq(pwnd), BM_SETSTYLE, BS_PUSHBUTTON, (LONG)TRUE);
        }

        pwnd = _NextControl(pwndRoot, pwnd, 0);

        ThreadUnlock(&tlpwnd);

    } while (pwnd && (pwnd != pwndStart) && (pwnd != pwndDup));
    
#if DBG
    if (pwnd && (pwnd != pwndStart) && (pwnd != pwndDup)) {
        RIPMSG0(RIP_WARNING, "xxxRemoveDefaultButton bailing potential infinite loop!");
    }
#endif
    
}


/***************************************************************************\
* xxxCheckDefPushButton
*
* History:
\***************************************************************************/

void xxxCheckDefPushButton(
    PWND pwndDlg,
    HWND hwndOldFocus,
    HWND hwndNewFocus)
{
    PWND pwndNewFocus;
    PWND pwndOldFocus;
    TL tlpwndT;
    PWND pwndT;
    UINT codeNewFocus = 0;
    UINT styleT;
    LONG lT;
    int id;

    if (hwndNewFocus)
        pwndNewFocus = ValidateHwnd(hwndNewFocus);
    else
        pwndNewFocus = NULL;

     if (hwndOldFocus)
         pwndOldFocus = ValidateHwnd(hwndOldFocus);
     else
         pwndOldFocus = NULL;

    CheckLock(pwndDlg);
    CheckLock(pwndNewFocus);
    CheckLock(pwndOldFocus);

    if (pwndNewFocus)
    {
        // Do nothing if clicking on dialog background or recursive dialog
        // background.
        if (TestWF(pwndNewFocus, WEFCONTROLPARENT))
            return;

        codeNewFocus = (UINT)SendMessage(hwndNewFocus, WM_GETDLGCODE, 0, 0L);
    }

    if (SAMEWOWHANDLE(hwndOldFocus, hwndNewFocus)) {
        //
        // NEW FOR 4.0:
        //
        // There is a very common frustrating scenario for ISVs who try to
        // set the default ID.  Our dialog manager assumes that if a push
        // button has the focus, it is the default button also.  As such
        // it passes in the focus window to this routine.  If someone tries
        // to change the focus or set the def ID such that they reside with
        // two different push buttons, the double-default-push button case
        // will result shortly.
        //
        // As such, for 4.0 dialogs, we will go check the def ID and see if
        // is the same as hwndOldFocus' ID.  If not, then we will find IT
        // and use that dude as hwndOldFocus
        //
        if (codeNewFocus & DLGC_UNDEFPUSHBUTTON)
        {
           if (TestWF(pwndDlg, WFWIN40COMPAT) && hwndOldFocus)
           {
               lT = (LONG)SendMessage(HWq(pwndDlg), DM_GETDEFID, 0, 0L);
               id = (HIWORD(lT) == DC_HASDEFID ? LOWORD(lT) : IDOK);
               lT = MAKELONG(id, 0);

               if (lT != PtrToLong(pwndNewFocus->spmenu))
               {
                   if (pwndOldFocus = _FindDlgItem(pwndDlg, lT))
                   {
                       hwndOldFocus = HW(pwndOldFocus);
                       if (SendMessage(hwndOldFocus, WM_GETDLGCODE, 0, 0L) & DLGC_DEFPUSHBUTTON)
                       {
                           xxxRemoveDefaultButton(pwndDlg, pwndOldFocus);
                           goto SetNewDefault;
                       }
                   }
               }
           }

           SendMessage(hwndNewFocus, BM_SETSTYLE, BS_DEFPUSHBUTTON, (LONG)TRUE);
        }
        return;
    }

    /*
     * If the focus is changing to or from a pushbutton, then remove the
     * default style from the current default button
     */
    if ((hwndOldFocus != NULL && (SendMessage(hwndOldFocus, WM_GETDLGCODE,
                0, 0) & (DLGC_DEFPUSHBUTTON | DLGC_UNDEFPUSHBUTTON))) ||
            (hwndNewFocus != NULL &&
                (codeNewFocus & (DLGC_DEFPUSHBUTTON | DLGC_UNDEFPUSHBUTTON)))) {
        xxxRemoveDefaultButton(pwndDlg, pwndNewFocus);
    }

SetNewDefault:
    /*
     * If moving to a button, make that button the default.
     */
    if (codeNewFocus & DLGC_UNDEFPUSHBUTTON) {
        SendMessage(hwndNewFocus, BM_SETSTYLE, BS_DEFPUSHBUTTON, (LONG)TRUE);
    } else {

        /*
         * Otherwise, make sure the original default button is default
         * and no others.
         */

        /*
         * Get the original default button handle
         */
        lT = (LONG)SendMessage(HWq(pwndDlg), DM_GETDEFID, 0, 0L);
        id = (HIWORD(lT) == DC_HASDEFID ? LOWORD(lT) : IDOK);
        pwndT = _FindDlgItem(pwndDlg, id);

        if (pwndT == NULL)
            return;
        ThreadLockAlways(pwndT, &tlpwndT);

        /*
         * If it already has the default button style, do nothing.
         */
        if ((styleT = (UINT)SendMessage(HWq(pwndT), WM_GETDLGCODE, 0, 0L)) & DLGC_DEFPUSHBUTTON) {
            ThreadUnlock(&tlpwndT);
            return;
        }

        /*
         * Also check to make sure it is really a button.
         */
        if (!(styleT & DLGC_UNDEFPUSHBUTTON)) {
            ThreadUnlock(&tlpwndT);
            return;
        }

        if (!TestWF(pwndT, WFDISABLED)) {
            SendMessage(HWq(pwndT), BM_SETSTYLE, BS_DEFPUSHBUTTON, (LONG)TRUE);
        }
        ThreadUnlock(&tlpwndT);
    }
}


/***************************************************************************\
* IsDialogMessage (API)
*
* History:
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsDialogMessageA, HWND, hwndDlg, LPMSG, lpmsg)
BOOL IsDialogMessageA(
    HWND hwndDlg,
    LPMSG lpmsg)
{
    WPARAM wParamSaved = lpmsg->wParam;
    BOOL bRet;

    switch (lpmsg->message) {
#ifdef FE_SB // IsDialogMessageA()
    case WM_CHAR:
    case EM_SETPASSWORDCHAR:
        /*
         * BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_CLIENTA() macro will return TRUE
         * for DBCS leadbyte message everytime, then we check there is some
         * possibility the return value become FALSE, here.
         *
         * These code originally come from IsDialogMessageW().
         */
         if (IS_DBCS_ENABLED()) {
            PWND pwndDlg, pwnd;
            TL tlpwndDlg;
            BOOL fLockDlg = FALSE;

            if ((pwndDlg = ValidateHwndNoRip(hwndDlg)) == NULL) {
                return FALSE;
            }

            if (lpmsg->hwnd == NULL) {
                return FALSE;
            }

            pwnd = ValidateHwnd(lpmsg->hwnd);
            //
            // THIS IS FOR MFC.
            //
            // This solves many problems with apps that use MFC but want to take
            // advantage of DS_CONTROL.  MFC blindly passes in child dialogs sometimes
            // to IsDialogMessage, which can mess up tabbing etc.
            //
            if (TestWF(pwndDlg, WEFCONTROLPARENT) && TestWF(pwndDlg, WFCHILD)) {
                pwndDlg = GetParentDialog(pwndDlg);
                ThreadLock(pwndDlg, &tlpwndDlg);
                fLockDlg = TRUE;
                hwndDlg = HWq(pwndDlg);
            }

            if (pwnd != pwndDlg && !_IsChild(pwndDlg, pwnd)) {
                if (fLockDlg)
                    ThreadUnlock(&tlpwndDlg);
                return FALSE;
            }

            /*
             * Build DBCS-aware message.
             */
            BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_CLIENTA(lpmsg->message,lpmsg->wParam,TRUE);

            /*
             * Fall through.....
             */
        }
#else
    case WM_CHAR:
    case EM_SETPASSWORDCHAR:
#endif // FE_SB
    case WM_CHARTOITEM:
    case WM_DEADCHAR:
    case WM_SYSCHAR:
    case WM_SYSDEADCHAR:
    case WM_MENUCHAR:
#ifdef FE_IME // IsDialogMessageA()
    case WM_IME_CHAR:
    case WM_IME_COMPOSITION:
#endif // FE_IME

        RtlMBMessageWParamCharToWCS(lpmsg->message, &lpmsg->wParam);
    }

    bRet = IsDialogMessageW(hwndDlg, lpmsg);

    /*
     * Restore the original ANSI char.
     */
    lpmsg->wParam = wParamSaved;
    return bRet;
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsDialogMessageW, HWND, hwndDlg, LPMSG, lpMsg)
BOOL IsDialogMessageW(
    HWND hwndDlg,
    LPMSG lpMsg)
{
    PWND pwndDlg;
    PWND pwnd;
    PWND pwnd2;
    HWND hwnd2;
    HWND hwndFocus;
    int iOK;
    BOOL fBack;
    UINT code;
    LONG lT;
    TL tlpwnd;
    TL tlpwndDlg;
    BOOL fLockDlg = FALSE;
    TL tlpwnd2;
    WORD langID;

    langID = PRIMARYLANGID(LANGIDFROMLCID(GetUserDefaultLCID()));

    if ((pwndDlg = ValidateHwndNoRip(hwndDlg)) == NULL) {
        return FALSE;
    }

    CheckLock(pwndDlg);

    /*
     * If this is a synchronous-only message (takes a pointer in wParam or
     * lParam), then don't allow this message to go through since those
     * parameters have not been thunked, and are pointing into outer-space
     * (which would case exceptions to occur).
     *
     * (This api is only called in the context of a message loop, and you
     * don't get synchronous-only messages in a message loop).
     */
    if (TESTSYNCONLYMESSAGE(lpMsg->message, lpMsg->wParam)) {
        /*
         * Fail if 32 bit app is calling.
         */
        if (!(GetClientInfo()->dwTIFlags & TIF_16BIT)) {
            RIPERR0(ERROR_MESSAGE_SYNC_ONLY, RIP_WARNING, "IsDialogMessage: must be sync only");
            return FALSE;
        }

        /*
         * For wow apps, allow it to go through (for compatibility). Change
         * the message id so our code doesn't understand the message - wow
         * will get the message and strip out this bit before dispatching
         * the message to the application.
         */
        lpMsg->message |= MSGFLAG_WOW_RESERVED;
    }

    if (CallMsgFilter(lpMsg, MSGF_DIALOGBOX))
        return TRUE;

    if (lpMsg->hwnd == NULL) {
        return FALSE;
    }

    pwnd = ValidateHwnd(lpMsg->hwnd);
    //
    // THIS IS FOR MFC.
    //
    // This solves many problems with apps that use MFC but want to take
    // advantage of DS_CONTROL.  MFC blindly passes in child dialogs sometimes
    // to IsDialogMessage, which can mess up tabbing etc.
    //
    if (TestWF(pwndDlg, WEFCONTROLPARENT) && TestWF(pwndDlg, WFCHILD)) {
        pwndDlg = GetParentDialog(pwndDlg);
        ThreadLock(pwndDlg, &tlpwndDlg);
        fLockDlg = TRUE;
        hwndDlg = HWq(pwndDlg);
    }

    if (pwnd != pwndDlg && !_IsChild(pwndDlg, pwnd)) {
        if (fLockDlg)
            ThreadUnlock(&tlpwndDlg);
        return FALSE;
    }
    ThreadLock(pwnd, &tlpwnd);

    fBack = FALSE;
    iOK = IDCANCEL;
    switch (lpMsg->message) {
    case WM_LBUTTONDOWN:

        /*
         * Move the default button styles around on button clicks in the
         * same way as TABs.
         */
        if ((pwnd != pwndDlg) && ((hwndFocus = GetFocus()) != NULL)) {
            xxxCheckDefPushButton(pwndDlg, hwndFocus, lpMsg->hwnd);
        }
        break;

    case WM_SYSCHAR:

        /*
         * If no control has focus, and Alt not down, then ignore.
         */
        if ((GetFocus() == NULL) && (GetKeyState(VK_MENU) >= 0)) {
            if (lpMsg->wParam == VK_RETURN && TestWF(pwnd, WFMINIMIZED)) {

                /*
                 * If this is an iconic dialog box window and the user hits
                 * return, send the message off to DefWindowProc so that it
                 * can be restored.  Especially useful for apps whose top
                 * level window is a dialog box.
                 */
                goto CallDefWindowProcAndReturnTrue;
            } else {
                NtUserMessageBeep(0);
            }

            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;
        }

        /*
         * If alt+menuchar, process as menu.
         */
        if (lpMsg->wParam == MENUSYSMENU) {
            DefWindowProcWorker(pwndDlg, lpMsg->message, lpMsg->wParam,
                    lpMsg->lParam, FALSE);
            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;
        }

    /*
     *** FALL THRU **
     */

    case WM_CHAR:

        /*
         * Ignore chars sent to the dialog box (rather than the control).
         */
        if (pwnd == pwndDlg) {
            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;
        }

        code = (UINT)SendMessage(lpMsg->hwnd, WM_GETDLGCODE, lpMsg->wParam,
                (LPARAM)lpMsg);

        /*
         * If the control wants to process the message, then don't check for
         * possible mnemonic key.
         */
        if ((lpMsg->message == WM_CHAR) && (code & (DLGC_WANTCHARS | DLGC_WANTMESSAGE)))
            break;

        /* If the control wants tabs, then don't let tab fall thru here
         */
        if ((lpMsg->wParam == VK_TAB) && (code & DLGC_WANTTAB))
            break;


        /*
         * HACK ALERT
         *
         * If ALT is held down (i.e., SYSCHARs), then ALWAYS do mnemonic
         * processing.  If we do away with SYSCHARS, then we should
         * check key state of ALT instead.
         */

        /*
         * Space is not a valid mnemonic, but it IS the char that toggles
         * button states.  Don't look for it as a mnemonic or we will
         * beep when it is typed....
         */
        if (lpMsg->wParam == VK_SPACE) {
            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;
        }

        if (!(pwnd2 = xxxGotoNextMnem(pwndDlg, pwnd, (WCHAR)lpMsg->wParam))) {

            if (code & DLGC_WANTMESSAGE)
                break;

            /*
             * No mnemonic could be found so we will send the sys char over
             * to xxxDefWindowProc so that any menu bar on the dialog box is
             * handled properly.
             */
            if (lpMsg->message == WM_SYSCHAR) {
CallDefWindowProcAndReturnTrue:
                DefWindowProcWorker(pwndDlg, lpMsg->message, lpMsg->wParam,
                        lpMsg->lParam, FALSE);

                ThreadUnlock(&tlpwnd);
                if (fLockDlg)
                    ThreadUnlock(&tlpwndDlg);
                return TRUE;
            }
            NtUserMessageBeep(0);
        } else {

            /*
             * pwnd2 is 1 if the mnemonic took us to a pushbutton.  We
             * don't change the default button status here since doing this
             * doesn't change the focus.
             */
            if (pwnd2 != (PWND)1) {
                ThreadLockAlways(pwnd2, &tlpwnd2);
                xxxCheckDefPushButton(pwndDlg, lpMsg->hwnd, HWq(pwnd2));
                ThreadUnlock(&tlpwnd2);
            }
        }

        ThreadUnlock(&tlpwnd);
        if (fLockDlg)
            ThreadUnlock(&tlpwndDlg);
        return TRUE;

    case WM_SYSKEYDOWN:
        /*
         * If Alt is down, deal with keyboard cues
         */
        if ((HIWORD(lpMsg->lParam) & SYS_ALTERNATE) && TEST_KbdCuesPUSIF) {
            if (TestWF(pwnd, WEFPUIFOCUSHIDDEN) || (TestWF(pwnd, WEFPUIACCELHIDDEN))) {
                    SendMessageWorker(pwndDlg, WM_CHANGEUISTATE,
                                      MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS), 0, FALSE);
                }
        }
        break;

    case WM_KEYDOWN:
        code = (UINT)SendMessage(lpMsg->hwnd, WM_GETDLGCODE, lpMsg->wParam,
                (LPARAM)lpMsg);
        if (code & (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE))
            break;

        switch (lpMsg->wParam) {
        case VK_TAB:
            if (code & DLGC_WANTTAB)
                break;
            pwnd2 = _GetNextDlgTabItem(pwndDlg, pwnd,
                    (GetKeyState(VK_SHIFT) & 0x8000));

            if (TEST_KbdCuesPUSIF) {
                if (TestWF(pwnd, WEFPUIFOCUSHIDDEN)) {
                    SendMessageWorker(pwndDlg, WM_CHANGEUISTATE,
                                          MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0, FALSE);
                }
            }

            if (pwnd2 != NULL) {
                hwnd2 = HWq(pwnd2);
                ThreadLockAlways(pwnd2, &tlpwnd2);
                DlgSetFocus(hwnd2);
                xxxCheckDefPushButton(pwndDlg, lpMsg->hwnd, hwnd2);
                ThreadUnlock(&tlpwnd2);
            }
            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;

        /*
         * For Arabic and Hebrew locales the arrow keys are reversed. Also reverse them if
         * the dialog is RTL mirrored.
         */
        case VK_LEFT:
            if ((((langID == LANG_ARABIC) || (langID == LANG_HEBREW)) && TestWF(pwndDlg,WEFRTLREADING))
                    ^ (!!TestWF(pwndDlg, WEFLAYOUTRTL))) {

                goto DoKeyStuff;
            }
        case VK_UP:
            fBack = TRUE;
            goto DoKeyStuff;

        /*
         *** FALL THRU **
         */
        case VK_RIGHT:
            if ((((langID == LANG_ARABIC) || (langID == LANG_HEBREW)) && TestWF(pwndDlg,WEFRTLREADING)) 
                     ^ (!!TestWF(pwndDlg, WEFLAYOUTRTL))) {

                fBack = TRUE;
            }
        case VK_DOWN:
DoKeyStuff:
            if (code & DLGC_WANTARROWS)
                break;

            if (TEST_KbdCuesPUSIF) {
                if (TestWF(pwnd, WEFPUIFOCUSHIDDEN)) {
                        SendMessageWorker(pwndDlg, WM_CHANGEUISTATE,
                                          MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0, FALSE);
                    }
            }

            pwnd2 = _GetNextDlgGroupItem(pwndDlg, pwnd, fBack);
            if (pwnd2 == NULL) {
                ThreadUnlock(&tlpwnd);
                if (fLockDlg)
                    ThreadUnlock(&tlpwndDlg);
                return TRUE;
            }
            hwnd2 = HWq(pwnd2);
            ThreadLockAlways(pwnd2, &tlpwnd2);

            code = (UINT)SendMessage(hwnd2, WM_GETDLGCODE, lpMsg->wParam,
                    (LPARAM)lpMsg);

            /*
             * We are just moving the focus rect around! So, do not send
             * BN_CLICK messages, when WM_SETFOCUSing.  Fix for Bug
             * #4358.
             */
            if (code & (DLGC_UNDEFPUSHBUTTON | DLGC_DEFPUSHBUTTON)) {
                PBUTN pbutn;
                BOOL fIsNTButton = IS_BUTTON(pwnd2);
                if (fIsNTButton) {
                    pbutn = ((PBUTNWND)pwnd2)->pbutn;
                    BUTTONSTATE(pbutn) |= BST_DONTCLICK;
                }
                DlgSetFocus(hwnd2);
                if (fIsNTButton) {
                    BUTTONSTATE(pbutn) &= ~BST_DONTCLICK;
                }
                xxxCheckDefPushButton(pwndDlg, lpMsg->hwnd, hwnd2);
            } else if (code & DLGC_RADIOBUTTON) {
                DlgSetFocus(hwnd2);
                xxxCheckDefPushButton(pwndDlg, lpMsg->hwnd, hwnd2);
                if (TestWF(pwnd2, BFTYPEMASK) == LOBYTE(BS_AUTORADIOBUTTON)) {

                    /*
                     * So that auto radio buttons get clicked on
                     */
                    if (!SendMessage(hwnd2, BM_GETCHECK, 0, 0L)) {
                        SendMessage(hwnd2, BM_CLICK, TRUE, 0L);
                    }
                }
            } else if (!(code & DLGC_STATIC)) {
                DlgSetFocus(hwnd2);
                xxxCheckDefPushButton(pwndDlg, lpMsg->hwnd, hwnd2);
            }
            ThreadUnlock(&tlpwnd2);
            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;

        case VK_EXECUTE:
        case VK_RETURN:

            /*
             * Guy pressed return - if button with focus is
             * defpushbutton, return its ID.  Otherwise, return id
             * of original defpushbutton.
             */
            if (!(hwndFocus = GetFocus()))
                code = 0;
            else
            {
                code = (WORD)(DWORD)SendMessage(hwndFocus, WM_GETDLGCODE,
                    0, 0L);
            }

            if (code & DLGC_DEFPUSHBUTTON)
            {
                iOK = GetDlgCtrlID(hwndFocus);
                pwnd2 = ValidateHwnd(hwndFocus);
                goto HaveWindow;
            }
            else
            {
                lT = (LONG)SendMessage(hwndDlg, DM_GETDEFID, 0, 0L);
                iOK = MAKELONG(
                    (HIWORD(lT)==DC_HASDEFID ? LOWORD(lT) : IDOK),
                    0);
            }
            // FALL THRU

        case VK_ESCAPE:
        case VK_CANCEL:

            /*
             * Make sure button is not disabled.
             */
            pwnd2 = _FindDlgItem(pwndDlg, iOK);
HaveWindow:
            if (pwnd2 != NULL && TestWF(pwnd2, WFDISABLED)) {
                NtUserMessageBeep(0);
            } else {
                SendMessage(hwndDlg, WM_COMMAND,
                        MAKELONG(iOK, BN_CLICKED), (LPARAM)HW(pwnd2));
            }

            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;
        }
        break;
    }

    ThreadUnlock(&tlpwnd);
    if (fLockDlg)
        ThreadUnlock(&tlpwndDlg);

    TranslateMessage(lpMsg);
    DispatchMessage(lpMsg);

    return TRUE;
}

/***************************************************************************\
*
* FindDlgItem32()
*
* Given a dialog, finds the window with the given ID anywhere w/in the
* descendant chain.
*
\***************************************************************************/

PWND _FindDlgItem(PWND pwndParent, DWORD id)
{
    PWND    pwndChild;
    PWND    pwndOrig;

    // QUICK TRY:
    pwndChild = _GetDlgItem(pwndParent, id);
    if (pwndChild || !TestWF(pwndParent, WFWIN40COMPAT))
        return(pwndChild);

    pwndOrig = _NextControl(pwndParent, NULL, CWP_SKIPINVISIBLE);
    if (pwndOrig == pwndParent)
        return(NULL);

    pwndChild = pwndOrig;

//    VerifyWindow(pwndChild);

    do
    {
        if (PtrToUlong(pwndChild->spmenu) == id)
            return(pwndChild);

        pwndChild = _NextControl(pwndParent, pwndChild, CWP_SKIPINVISIBLE);
    }
    while (pwndChild && (pwndChild != pwndOrig));

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\dlgmgrc.c ===
/****************************** Module Header ******************************\
* Module Name: dlgmgrc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains client side dialog functionality
*
* History:
* 15-Dec-1993 JohnC      Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* UT_PrevGroupItem
*
* History:
\***************************************************************************/

PWND UT_PrevGroupItem(
    PWND pwndDlg,
    PWND pwndCurrent)
{
    PWND pwnd, pwndPrev;

    if (pwndCurrent == NULL || !TestWF(pwndCurrent, WFGROUP))
        return _PrevControl(pwndDlg, pwndCurrent, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);

    pwndPrev = pwndCurrent;

    while (TRUE) {
        pwnd = _NextControl(pwndDlg, pwndPrev, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);

        if (TestWF(pwnd, WFGROUP) || pwnd == pwndCurrent)
            return pwndPrev;

        pwndPrev = pwnd;
    }
}


/***************************************************************************\
* UT_NextGroupItem
*
* History:
\***************************************************************************/

PWND UT_NextGroupItem(
    PWND pwndDlg,
    PWND pwndCurrent)
{
    PWND pwnd, pwndNext;

    pwnd = _NextControl(pwndDlg, pwndCurrent, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);

    if (pwndCurrent == NULL || !TestWF(pwnd, WFGROUP))
        return pwnd;

    pwndNext = pwndCurrent;

    while (!TestWF(pwndNext, WFGROUP)) {
        pwnd = _PrevControl(pwndDlg, pwndNext, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);
        if (pwnd == pwndCurrent)
            return pwndNext;
        pwndNext = pwnd;
    }

    return pwndNext;
}

/***************************************************************************\
* _PrevControl
*
* History:
\***************************************************************************/
PWND _PrevControl(
    PWND pwndRoot,
    PWND pwndStart,
    UINT uFlags)
{
    BOOL fFirstFound;
    PWND pwndNext;
    PWND pwnd, pwndFirst;

    if (!pwndStart)
        return(NULL);

    UserAssert(pwndRoot != pwndStart);
    UserAssert(!TestWF(pwndStart, WEFCONTROLPARENT));

    pwnd = _NextControl(pwndRoot, NULL, uFlags);

    pwndFirst = pwnd;
    fFirstFound = FALSE;
    while (pwndNext = _NextControl(pwndRoot, pwnd, uFlags)) {

        if (pwndNext == pwndStart)
            break;

        if (pwndNext == pwndFirst) {
            if (fFirstFound) {
                RIPMSG0(RIP_WARNING, "_PrevControl: Loop Detected");
                break;
            } else {
                fFirstFound = TRUE;
            }
        }

        pwnd = pwndNext;
    }

    return pwnd;
}
/***************************************************************************\
*
*  GetChildControl()
*
*  Gets valid ancestor of given window.
*  A valid dialog control is a direct descendant of a "form" control.
*
\***************************************************************************/

PWND  _GetChildControl(PWND pwndRoot, PWND pwndChild) {
    PWND    pwndControl = NULL;

    while (pwndChild && TestwndChild(pwndChild) && (pwndChild != pwndRoot)) {
        pwndControl = pwndChild;
        pwndChild = REBASEPWND(pwndChild, spwndParent);

        if (TestWF(pwndChild, WEFCONTROLPARENT))
            break;
    }

    return(pwndControl);
}

/***************************************************************************\
*
*  _NextSibblingOrAncestor
*
* Called by _NextControl. It returns the next control to pwndStart. If there
* is a next window (pwndStart->spwndNext), then that is it.
* Otherwise, the next control is up the parent chain. However, if it's already
* at the top of the chain (pwndRoot == pwndStart->spwndParent), then the next
* control is the first child of pwndRoot. But if it's not at the top of the chain,
* then the next control is pwndStart->spwndParent or an ancestor.
*
\***************************************************************************/
PWND _NextSibblingOrAncestor (PWND pwndRoot, PWND pwndStart)
{
    PWND pwndParent;
#if DBG
    PWND pwndNext;
#endif

    // If there is a sibbling, go for it
    if (pwndStart->spwndNext != NULL) {
        return (REBASEALWAYS(pwndStart, spwndNext));
    }

    // If it cannot go up the parent chain, then return the first sibbling.
    pwndParent = REBASEALWAYS(pwndStart, spwndParent);
    if (pwndParent == pwndRoot) {
        // Note that if pwndStart doesn't have any sibblings,
        //  this will return pwndStart again
        return (REBASEALWAYS(pwndParent, spwndChild));
    }


    // Otherwise walk up the parent chain looking for the first window with
    // a WS_EX_CONTROLPARENT parent.

#if DBG
    pwndNext =
#else
    return
#endif
        _GetChildControl(pwndRoot, pwndParent);

#if DBG
    if ((pwndNext != pwndParent) || !TestWF(pwndParent, WEFCONTROLPARENT)) {
        // Code looping through the controls in a dialog might go into an infinite
        //  loop because of this (i.e., xxxRemoveDefaultButton, _GetNextDlgTabItem,..)
        // We've walked up the parent chain but will never walk down the child chain again
        //  because there is a NON WS_EX_CONTROLPARENT parent window somewhere in the chain.
        RIPMSG0 (RIP_ERROR, "_NextSibblingOrAncestor: Non WS_EX_CONTROLPARENT window in parent chain");
    }
    return pwndNext;
#endif
}
/***************************************************************************\
*
*  _NextControl()
*
* It searches for the next NON WS_EX_CONTROLPARENT control following pwndStart.
* If pwndStart is NULL, the search begins with pwndRoot's first child;
* otherwise, it starts with the control next to pwndStart.
* This is a depth-first search that can start anywhere in the window tree.
* uFlags determine what WS_EX_CONTROLPARENT windows should be skipped or recursed into.
* If skipping a window, the search moves to the next control (see _NextSibblingOrAncestor);
* otherwise, the search walks down the child chain (recursive call).
* If the search fails, it returns pwndRoot.
*
\***************************************************************************/
PWND _NextControl(
    PWND pwndRoot,
    PWND pwndStart,
    UINT uFlags)
{
    BOOL fSkip, fAncestor;
    PWND pwndLast, pwndSibblingLoop;
    /* Bug 272874 - joejo
     *
     * Stop infinite loop by only looping a finite number of times and
     * then bailing.
     */
    int nLoopCount = 0;
    
    UserAssert (pwndRoot != NULL);

    if (pwndStart == NULL) {
        // Start with pwndRoot's first child
        pwndStart = REBASEPWND(pwndRoot, spwndChild);
        pwndLast = pwndStart;
        fAncestor = FALSE;
    } else {
        UserAssert ((pwndRoot != pwndStart) && _IsDescendant(pwndRoot, pwndStart));

        // Save starting handle and get next one
        pwndLast = pwndStart;
        pwndSibblingLoop = pwndStart;
        fAncestor = TRUE;
        goto TryNextOne;
    }


    // If no more controls, game over
    if (pwndStart == NULL) {
        return pwndRoot;
    }

    // Search for a non WS_EX_CONTROLPARENT window; if a window should be skipped,
    // try its spwndNext; otherwise, walk down its child chain.
    pwndSibblingLoop = pwndStart;
    do {
        
        //If not WS_EX_CONTROLPARENT parent, done.
        if (!TestWF(pwndStart, WEFCONTROLPARENT)) {
            return pwndStart;
        }

        // Do they want to skip this window?
        fSkip = ((uFlags & CWP_SKIPINVISIBLE) && !TestWF(pwndStart, WFVISIBLE))
                || ((uFlags & CWP_SKIPDISABLED) && TestWF(pwndStart, WFDISABLED));


        // Remember the current window
        pwndLast = pwndStart;

        // Walk down child chain?
        if (!fSkip && !fAncestor) {
            pwndStart = _NextControl (pwndStart, NULL, uFlags);
            // If it found one, done.
            if (pwndStart != pwndLast) {
                return pwndStart;
            }
        }

TryNextOne:
        // Try the next one.
        pwndStart = _NextSibblingOrAncestor (pwndRoot, pwndStart);
        if (pwndStart == NULL) {
            break;
        }

        // If parents are the same, we are still in the same sibbling chain
        if (pwndLast->spwndParent == pwndStart->spwndParent) {
            // If we had just moved up the parent chain last time around,
            //  mark this as the beginning of the new sibbling chain.
            // Otherwise, check if we've looped through all sibblings already.
            if (fAncestor) {
                // Beggining of new sibbling chain.
                pwndSibblingLoop = pwndStart;
            } else if (pwndStart == pwndSibblingLoop) {
                // Already visited all sibblings, so done.
                break;
            }
            fAncestor = FALSE;
        } else {
            // We must have moved up the parent chain, so don't
            //  walk down the child chain right away (try the next window first)
            // Eventhough we are on a new sibbling chain, we don't update
            // pwndSibblingLoop yet; this is because we must walk down this
            // child chain again to make sure we visit all the descendents
            fAncestor = TRUE;
        }

    /* Bug 272874 - joejo
     *
     * Stop infinite loop by only looping a finite number of times and
     * then bailing.
     */
    } while (nLoopCount++ < 256 * 4);

    // It couldn't find one...
    return pwndRoot;
}

/***************************************************************************\
* GetNextDlgTabItem
*
* History:
* 19-Feb-1991 JimA      Added access check
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, HWND, WINAPI, GetNextDlgTabItem, HWND, hwndDlg, HWND, hwnd, BOOL, fPrev)
HWND WINAPI GetNextDlgTabItem(
    HWND hwndDlg,
    HWND hwnd,
    BOOL fPrev)
{

    PWND pwnd;
    PWND pwndDlg;
    PWND pwndNext;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return NULL;

    if (hwnd != (HWND)0) {
        pwnd = ValidateHwnd(hwnd);

        if (pwnd == NULL)
            return NULL;

    } else {
        pwnd = (PWND)NULL;
    }

    pwndNext = _GetNextDlgTabItem(pwndDlg, pwnd, fPrev);

    return (HW(pwndNext));
}

PWND _GetNextDlgTabItem(
    PWND pwndDlg,
    PWND pwnd,
    BOOL fPrev)
{
    PWND pwndSave;

    if (pwnd == pwndDlg)
        pwnd = NULL;
    else
    {
        pwnd = _GetChildControl(pwndDlg, pwnd);
        if (pwnd && !_IsDescendant(pwndDlg, pwnd))
            return(NULL);
    }

    //
    // BACKWARD COMPATIBILITY
    //
    // Note that the result when there are no tabstops of
    // IGetNextDlgTabItem(pwndDlg, NULL, FALSE) was the last item, now
    // will be the first item.  We could put a check for fRecurse here
    // and do the old thing if not set.
    //

    // We are going to bug out if we hit the first child a second time.

    pwndSave = pwnd;

    pwnd = (fPrev ? _PrevControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED) :
                    _NextControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED));

    if (!pwnd)
        goto AllOver;

    while ((pwnd != pwndSave) && (pwnd != pwndDlg)) {
        UserAssert(pwnd);

        if (!pwndSave)
            pwndSave = pwnd;

        if ((pwnd->style & (WS_TABSTOP | WS_VISIBLE | WS_DISABLED))  == (WS_TABSTOP | WS_VISIBLE))
            // Found it.
            break;

        pwnd = (fPrev ? _PrevControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED) :
                        _NextControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED));
    }

AllOver:
    return pwnd;
}

/***************************************************************************\
*
*  _GetNextDlgGroupItem()
*
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetNextDlgGroupItem, HWND, hwndDlg, HWND, hwndCtl, BOOL, bPrevious)
HWND GetNextDlgGroupItem(
    HWND hwndDlg,
    HWND hwndCtl,
    BOOL bPrevious)
{
    PWND pwndDlg;
    PWND pwndCtl;
    PWND pwndNext;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return 0;


    if (hwndCtl != (HWND)0) {
        pwndCtl = ValidateHwnd(hwndCtl);

        if (pwndCtl == NULL)
            return 0;
    } else {
        pwndCtl = (PWND)NULL;
    }

    if (pwndCtl == pwndDlg)
        pwndCtl = pwndDlg;

    pwndNext = _GetNextDlgGroupItem(pwndDlg, pwndCtl, bPrevious);

    return (HW(pwndNext));
}

PWND _GetNextDlgGroupItem(
    PWND pwndDlg,
    PWND pwnd,
    BOOL fPrev)
{
    PWND pwndCurrent;
    BOOL fOnceAround = FALSE;

    pwnd = pwndCurrent = _GetChildControl(pwndDlg, pwnd);

    do {
        pwnd = (fPrev ? UT_PrevGroupItem(pwndDlg, pwnd) :
                        UT_NextGroupItem(pwndDlg, pwnd));

        if (pwnd == pwndCurrent)
            fOnceAround = TRUE;

        if (!pwndCurrent)
            pwndCurrent = pwnd;
    }
    while (!fOnceAround && ((TestWF(pwnd, WFDISABLED) || !TestWF(pwnd, WFVISIBLE))));

    return pwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\dlgmgr.c ===
/***************************************************************************\
*
*  DLGMGR.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Dialog Box Manager Routines
*
* ??-???-???? mikeke    Ported from Win 3.0 sources
* 12-Feb-1991 mikeke    Added Revalidation code
* 19-Feb-1991 JimA      Added access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define UNICODE_MINUS_SIGN 0x2212


LOOKASIDE DialogLookaside;

BOOL ValidateCallback(HANDLE h);

#define IsInForegroundQueue(hwnd) \
    (NtUserQueryWindow(hwnd, WindowIsForegroundThread) != NULL)
#define IsCurrentThreadForeground() \
    ((BOOL)NtUserGetThreadState(UserThreadStateIsForeground))

/***************************************************************************\
*
* GetParentDialog()
*
* Gets top level window, not a control parent.  If not a dialog, then use
* "highest" control parent guy.
*
* BOGUS
* Need a way to mark a window as a dialog.  If it ever comes into
* DefDlgProc(), set an internal flag.  Will be used by thunking and
* CallDlgProc() optimizations also!
*
\***************************************************************************/

PWND GetParentDialog(PWND pwndDialog)
{
    PWND    pwndParent;

    pwndParent = pwndDialog;

    //
    // Walk up the parent chain.  We're looking for the top-most dialog
    // window.  Most cases, the window is a top level one.  But in case of
    // backup app, the window will be a child of some other window.
    //
    for (; pwndDialog; pwndDialog = REBASEPWND(pwndDialog, spwndParent))
    {
        if (TestWF(pwndDialog, WFDIALOGWINDOW))
        {
            //
            // For old guys:  If not DS_RECURSE, then stop here.
            // that way old apps which try to do the nested dialog
            // stuff in their old limited way don't die.
            //
            if (TestWF(pwndDialog, WEFCONTROLPARENT))
                pwndParent = pwndDialog;
            else if (!TestWF(pwndDialog, DFCONTROL))
                break;
        }

        if (!TestWF(pwndDialog, WFCHILD))
            break;
    }

    return(pwndParent);
}

/***************************************************************************\
* xxxSaveDlgFocus
*
* History:
* 02-18-92 JimA             Ported from Win31 sources
\***************************************************************************/

BOOL xxxSaveDlgFocus(
    PWND pwnd)
{
    HWND hwndFocus = GetFocus();

    CheckLock(pwnd);

    if (hwndFocus != NULL && IsChild(HWq(pwnd), hwndFocus) &&
            PDLG(pwnd)->hwndFocusSave == NULL) {
        PDLG(pwnd)->hwndFocusSave = hwndFocus;
        xxxRemoveDefaultButton(pwnd, ValidateHwnd(hwndFocus));
        return TRUE;
    }
    return FALSE;
}

/***************************************************************************\
* xxxRestoreDlgFocus
*
* History:
* 02-18-92 JimA             Ported from Win31 sources
* 01-01-2001 Mohamed        Need to re-validate the window before cleanup.
\***************************************************************************/

// LATER
// 21-Mar-1992 mikeke
// does pwndFocusSave need to be unlocked when the dialog is destroyed?

BOOL xxxRestoreDlgFocus(
    PWND pwnd)
{
    HWND hwndFocus;
    HWND hwndFocusSave;
    BOOL fRestored = FALSE;

    CheckLock(pwnd);
    

    if (PDLG(pwnd)->hwndFocusSave && !TestWF(pwnd, WFMINIMIZED)) {

        hwndFocus = GetFocus();
        hwndFocusSave = KHWND_TO_HWND(PDLG(pwnd)->hwndFocusSave);

        if (IsWindow(hwndFocusSave)) {
            xxxCheckDefPushButton(pwnd, hwndFocus, hwndFocusSave);
            fRestored = (NtUserSetFocus(hwndFocusSave) != NULL);
        }
            //
            // After calling SetFocus(), we need to re-validate
            // the window. PDLG(pwnd) might be NULL.
            //

        if (ValidateDialogPwnd(pwnd)) {
            PDLG(pwnd)->hwndFocusSave = NULL;
        }
    }

    return fRestored;
}


/***************************************************************************\
* DlgSetFocus
*
* History:
\***************************************************************************/

void DlgSetFocus(
    HWND hwnd)
{
    if (((UINT)SendMessage(hwnd, WM_GETDLGCODE, 0, 0)) & DLGC_HASSETSEL) {
        SendMessage(hwnd, EM_SETSEL, 0, MAXLONG);
    }

    NtUserSetFocus(hwnd);
}



FUNCLOG1(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetDlgCtrlID, HWND, hwnd)
int GetDlgCtrlID(
    HWND hwnd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL)
        return 0;

    return PtrToLong(pwnd->spmenu);
}



/***************************************************************************\
* ValidateDialogPwnd
*
* Under Win3, DLGWINDOWEXTRA is 30 bytes. We cannot change that for 16 bit
* compatibility reasons. Problem is there is no way to tell if a given
* 16 bit window depends on byte count. If there was, this would be easy.
* The only way to tell is when a window is about to be used as a dialog
* window. This window may be of the class DIALOGCLASS, but again it may
* not!! So we keep dialog window words at 30 bytes, and allocate another
* structure for the real dialog structure fields. Problem is that this
* structure has to be created lazily! And that's what we're doing here.
*
* 05-21-91 ScottLu      Created.
\***************************************************************************/

BOOL ValidateDialogPwnd(
    PWND pwnd)
{
    static BOOL sfInit = TRUE;
    PDLG pdlg;

    /*
     * This bit is set if we've already run through this initialization and
     * have identified this window as a dialog window (able to withstand
     * peeks into window words at random moments in time).
     */
    if (TestWF(pwnd, WFDIALOGWINDOW))
        return TRUE;

    if (pwnd->cbwndExtra < DLGWINDOWEXTRA) {
        RIPERR0(ERROR_WINDOW_NOT_DIALOG, RIP_VERBOSE, "");
        return FALSE;
    }

    /*
     * See if the pdlg was destroyed and this is a rogue message to be ignored
     */
    if (pwnd->fnid & FNID_STATUS_BITS) {
        return FALSE;
    }

    /*
     * If the lookaside buffer has not been initialized, do it now.
     */
    if (sfInit) {
        if (!NT_SUCCESS(InitLookaside(&DialogLookaside, sizeof(DLG), 2))) {
            return FALSE;
        }
        sfInit = FALSE;
    }

    if ((pdlg = (PDLG)AllocLookasideEntry(&DialogLookaside)) == NULL) {
        return FALSE;
    }

    NtUserCallHwndParam(HWq(pwnd), (ULONG_PTR)pdlg, SFI_SETDIALOGPOINTER);

    return TRUE;
}


/***************************************************************************\
* CvtDec
*
* LATER!!! convert to itoa?
*
* History:
\***************************************************************************/

void CvtDec(
    int u,
    LPWSTR *lplpch)
{
    if (u >= 10) {
        CvtDec(u / 10, lplpch);
        u %= 10;
    }

    *(*lplpch)++ = (WCHAR)(u + '0');
}


/***************************************************************************\
* SetDlgItemInt
*
* History:
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetDlgItemInt, HWND, hwnd, int, item, UINT, u, BOOL, fSigned)
BOOL SetDlgItemInt(
    HWND hwnd,
    int item,
    UINT u,
    BOOL fSigned)
{
    LPWSTR lpch;
    WCHAR rgch[16];

    lpch = rgch;
    if (fSigned) {
        if ((int)u < 0) {
            *lpch++ = TEXT('-');
            u = (UINT)(-(int)u);
        }
    } else {
        if (u & 0x80000000) {
            CvtDec(u / 10, (LPWSTR FAR *)&lpch);
            u = u % 10;
        }
    }

    CvtDec(u, (LPWSTR FAR *)&lpch);
    *lpch = 0;

    return SetDlgItemTextW(hwnd, item, rgch);
}


/***************************************************************************\
* CheckDlgButton
*
* History:
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CheckDlgButton, HWND, hwnd, int, id, UINT, cmdCheck)
BOOL CheckDlgButton(
    HWND hwnd,
    int id,
    UINT cmdCheck)
{
    if ((hwnd = GetDlgItem(hwnd, id)) == NULL) {
        return FALSE;
    }

    SendMessage(hwnd, BM_SETCHECK, cmdCheck, 0);

    return TRUE;
}

/***************************************************************************\
* GetDlgItemInt
*
* History:
\***************************************************************************/

UINT GetDlgItemInt(
    HWND hwnd,
    int item,
    BOOL FAR *lpfValOK,
    BOOL fSigned)
{
    int i, digit, ch;
    int maxTens, maxUnits;
    BOOL fOk, fNeg;
    LPWSTR lpch;
    WCHAR rgch[48];
    WCHAR rgchDigits[48];

    fOk = FALSE;
    if (lpfValOK != NULL)
        *lpfValOK = FALSE;

    if (!GetDlgItemTextW(hwnd, item, rgch, sizeof(rgch)/sizeof(WCHAR) - 1))
        return 0;

    lpch = rgch;

    /*
     * Skip leading white space.
     */
    while (*lpch == TEXT(' '))
        lpch++;

    fNeg = FALSE;
    while (fSigned && ((*lpch == L'-') || (*lpch == UNICODE_MINUS_SIGN))) {
        lpch++;
        fNeg ^= TRUE;
    }

    if (fSigned) {
        maxTens = INT_MAX/10;
        maxUnits = INT_MAX%10;
    } else {
        maxTens = UINT_MAX/10;
        maxUnits = UINT_MAX%10;
    }
    /*
     * Convert all decimal digits to ASCII Unicode digits 0x0030 - 0x0039
     */
    FoldStringW(MAP_FOLDDIGITS, lpch, -1, rgchDigits,
            sizeof(rgchDigits)/sizeof(rgchDigits[0]));
    lpch = rgchDigits;

    i = 0;
    while (ch = *lpch++) {
        digit = ch - TEXT('0');
        if (digit < 0 || digit > 9) {
            break;
        }
        if ((UINT)i >= (UINT)maxTens) {
            /*
             * We need to special case INT_MIN as the i = -i
             * would damage it
             */
            if (i == maxTens) {
                if (digit == maxUnits+1 && fNeg && (*lpch) == 0) {
                    i = INT_MIN;
                    goto HaveResult;
                } else if (digit > maxUnits) {
                    return 0;
                }
            } else {
                return 0;
            }
        }
        fOk = TRUE;
        i = ((UINT)i * 10) + digit;
    }

    if (fNeg)
        i = -i;
HaveResult:
    if (lpfValOK != NULL)
        *lpfValOK = ((ch == 0) && fOk);

    return (UINT)i;
}

/***************************************************************************\
* CheckRadioButton
*
* History:
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CheckRadioButton, HWND, hwnd, int, idFirst, int, idLast, int, id)
BOOL CheckRadioButton(
    HWND hwnd,
    int idFirst,
    int idLast,
    int id)
{
    PWND pwnd, pwndDialog;
    BOOL    fCheckOn;

    pwndDialog = ValidateHwnd(hwnd);
    if (pwndDialog == NULL)
        return 0;

    for (pwnd = REBASE(pwndDialog, spwndChild); pwnd; pwnd = REBASE(pwnd, spwndNext)) {

        if ((PtrToLong(pwnd->spmenu) >= idFirst) &&
            (PtrToLong(pwnd->spmenu) <= idLast)) {

            fCheckOn = (PtrToLong(pwnd->spmenu) == id);
            SendMessage(PtoHq(pwnd), BM_SETCHECK, fCheckOn, 0L);
        }
    }

    return TRUE;
}


/***************************************************************************\
* IsDlgButtonChecked
*
* History:
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, IsDlgButtonChecked, HWND, hwnd, int, id)
UINT IsDlgButtonChecked(
    HWND hwnd,
    int id)
{
    if ((hwnd = GetDlgItem(hwnd, id)) != NULL) {
        return (UINT)SendMessage(hwnd, BM_GETCHECK, 0, 0);
    }

    return FALSE;
}


/***************************************************************************\
* DefDlgProc
*
* History:
\***************************************************************************/

LRESULT DefDlgProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    TL tlpwndT1, tlpwndT2, tlpwndT3, tlpwndTop;
    PWND pwndT;
    PWND pwndT1, pwndT2, pwndT3, pwndTop;
    HWND hwndT1;
    LRESULT result;
    BOOL fSetBit;
    DLGPROC pfn;

    CheckLock(pwnd);

    /*
     * use the Win 3.1 documented size
     */
    VALIDATECLASSANDSIZE(pwnd, FNID_DIALOG);

    /*
     * Must do special validation here to make sure pwnd is a dialog window.
     */
    if (!ValidateDialogPwnd(pwnd))
        return 0;

    if (((PDIALOG)pwnd)->resultWP != 0)
        NtUserSetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0, FALSE);
    result = 0;   // no dialog proc

    if (message == WM_FINALDESTROY) {
        goto DoCleanup;
    }

    if ((pfn = PDLG(pwnd)->lpfnDlg) != NULL) {
        /* Bug 234292 - joejo
         * Since the called window/dialog proc may have a different calling
         * convention, we must wrap the call and, check esp and replace with
         * a good esp when the call returns. This is what UserCallWinProc* does.
        */
        if (UserCallDlgProcCheckWow(pwnd->pActCtx, pfn, hwnd, message, wParam, lParam, &(pwnd->state), &result)) {
            return result;
        }

        /*
         * Get out if the window was destroyed in the dialog proc.
         */
        if ((RevalidateHwnd(hwnd)==NULL) || (pwnd->fnid & FNID_STATUS_BITS))
            return result;
    }

    /*
     * SPECIAL CASED ... and DOCUMENTED that way !!!
     * These 6, and ONLY these 6, should be hacked in this fashion.
     * Anybody who needs the REAL return value to a message should
     * use SetDlgMsgResult in WINDOWSX.H
     */

    switch (message)
    {
        case WM_COMPAREITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_INITDIALOG:
        case WM_QUERYDRAGICON:
            return ((LRESULT)(DWORD)result);

        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
            // QuarkXPress doesn't like finding the WM_CTLCOLOR result in
            // resultWP -- we should never be setting resultWP -- that's meant
            // as a pass-thru return value -- so let's go back to doing it the
            // old way -- Win95B B#21269 -- 03/13/95 -- tracysh (cr: jeffbog)
            if (result)
                return result;
            break;
    }

    if (!result) {

        /*
         * Save the result value in case our private memory is freed
         * before we return
         */
//        result = PDLG(pwnd)->resultWP;

        switch (message) {
        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        {
            //
            // HACK OF DEATH:
            // To get 3D colors for non 4.0 apps who use 3DLOOK,
            // we temporarily add on the 4.0 compat bit, pass this
            // down to DWP, and clear it.
            //
            // Use "result" var for bool saying we have to add/clear 4.0
            // compat bit.

            fSetBit = (TestWF(pwnd, DF3DLOOK)!= 0) &&
                     (TestWF(pwnd, WFWIN40COMPAT) == 0);

            if (fSetBit)
                SetWindowState(pwnd, WFWIN40COMPAT);

            result = DefWindowProcWorker(pwnd, message,
                    wParam, lParam, fAnsi);

            if (fSetBit)
                ClearWindowState(pwnd, WFWIN40COMPAT);
            return result;
        }

        case WM_ERASEBKGND:
            FillWindow(hwnd, hwnd, (HDC)wParam, (HBRUSH)CTLCOLOR_DLG);
            return TRUE;

        case WM_SHOWWINDOW:

            /*
             * If hiding the window, save the focus.  If showing the window
             * by means of a SW_* command and the fEnd bit is set, do not
             * pass to DWP so it won't get shown.
             */
            if (GetParentDialog(pwnd) == pwnd) {
                if (!wParam) {
                    xxxSaveDlgFocus(pwnd);
                } else {

                    if (LOWORD(lParam) != 0 && PDLG(pwnd)->fEnd)
                        break;

                    /*
                     * Snap the cursor to the center of the default button.
                     * Only do this if the current thread is in the foreground.
                     * The _ShowCursor() code is added to work around a
                     * problem with hardware cursors.  If change is done
                     * in the same refresh cycle, the display of the cursor
                     * would not reflect the new position.
                     */
                    if (TEST_PUSIF(PUSIF_SNAPTO) &&
                            IsInForegroundQueue(hwnd)) {
                        hwndT1 = GetDlgItem(hwnd, (int)PDLG(pwnd)->result);
                        if (hwndT1) {
                            RECT rc;

                            NtUserShowCursor(FALSE);

                            GetWindowRect(hwndT1, &rc);
                            NtUserSetCursorPos(rc.left + ((rc.right - rc.left)/2),
                                         rc.top + ((rc.bottom - rc.top)/2));

                            NtUserShowCursor(TRUE);
                        }
                    }
                }
            }
            goto CallDWP;

        case WM_SYSCOMMAND:
            if (GetParentDialog(pwnd) == pwnd) {
                /*
                 * If hiding the window, save the focus.  If showing the window
                 * by means of a SW_* command and the fEnd bit is set, do not
                 * pass to DWP so it won't get shown.
                 */
                if ((int)wParam == SC_MINIMIZE)
                    xxxSaveDlgFocus(pwnd);
            }
            goto CallDWP;

        case WM_ACTIVATE:
            pwndT1 = GetParentDialog(pwnd);
            if ( pwndT1 != pwnd) {

                /*
                 * This random bit is used during key processing - bit
                 * 08000000 of WM_CHAR messages is set if a dialog is currently
                 * active.
                 */
                NtUserSetThreadState(wParam ? QF_DIALOGACTIVE : 0, QF_DIALOGACTIVE);
            }

            ThreadLock(pwndT1, &tlpwndT1);
            if (wParam != 0)
                xxxRestoreDlgFocus(pwndT1);
            else
                xxxSaveDlgFocus(pwndT1);

            ThreadUnlock(&tlpwndT1);
            break;

        case WM_SETFOCUS:
            pwndT1 = GetParentDialog(pwnd);
            if (!PDLG(pwndT1)->fEnd && !xxxRestoreDlgFocus(pwndT1)) {

                pwndT = _GetNextDlgTabItem(pwndT1, NULL, FALSE);
                DlgSetFocus(HW(pwndT));
            }
            break;

        case WM_CLOSE:
            /*
             * Make sure cancel button is not disabled before sending the
             * IDCANCEL.  Note that we need to do this as a message instead
             * of directly calling the dlg proc so that any dialog box
             * filters get this.
             */
            pwndT1 = _GetDlgItem(pwnd, IDCANCEL);
            if (pwndT1 && TestWF(pwndT1, WFDISABLED))
                NtUserMessageBeep(0);
            else
                PostMessage(hwnd, WM_COMMAND, MAKELONG(IDCANCEL, BN_CLICKED),
                        (LPARAM)HW(pwndT1));
            break;

        case WM_NCDESTROY:
        case WM_FINALDESTROY:
DoCleanup:
            NtUserSetThreadState(0, QF_DIALOGACTIVE);
            if (!(pwnd->style & DS_LOCALEDIT)) {
                if (PDLG(pwnd)->hData) {
                    ReleaseEditDS(KHANDLE_TO_HANDLE(PDLG(pwnd)->hData));
                    PDLG(pwnd)->hData = NULL;
                }
            }

            /*
             * Delete the user defined font if any
             */
            if (PDLG(pwnd)->hUserFont) {
                DeleteObject(KHFONT_TO_HFONT(PDLG(pwnd)->hUserFont));
                PDLG(pwnd)->hUserFont = NULL;
            }

            /*
             * Free the dialog memory and mark this as a non-dialog window
             */
            FreeLookasideEntry(&DialogLookaside, KPVOID_TO_PVOID(PDLG(pwnd)));
            NtUserCallHwndParam(hwnd, 0, SFI_SETDIALOGPOINTER);
            break;

        case DM_REPOSITION:
            {
                RECT        rc;
                PMONITOR    pMonitor;

                // DAT recorder APP sends it's own private message 0x402
                // through and we mistake it to be DM_REPOSITION. To avoid
                // this confusion, we do the following check.
                // Fix for Bug#25747 -- 9/29/94 --
                if (!TestWF(pwnd, WEFCONTROLPARENT) ||
                    (GETFNID(pwnd) != FNID_DESKTOP &&
                     GETFNID(REBASEPWND(pwnd, spwndParent)) != FNID_DESKTOP)) {

                    goto CallDWP;
                }

                CopyRect(&rc, KPRECT_TO_PRECT(&pwnd->rcWindow));
                pMonitor = _MonitorFromRect(&rc, MONITOR_DEFAULTTOPRIMARY);
                RepositionRect(pMonitor, &rc, pwnd->style, pwnd->ExStyle);
                NtUserSetWindowPos(hwnd, HWND_TOP, rc.left, rc.top,
                             rc.right-rc.left, rc.bottom-rc.top,
                             SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
            }
            break;

        case DM_SETDEFID:
            pwndT1 = GetParentDialog(pwnd);
            ThreadLock(pwndT1, &tlpwndT1);

            if (!(PDLG(pwndT1)->fEnd)) {

                pwndT2 = NULL;
                if (PDLG(pwndT1)->result != 0)
                    pwndT2 = _FindDlgItem(pwndT1, (int)PDLG(pwndT1)->result);

                pwndT3 = NULL;
                if (wParam != 0) {
                    pwndT3 = _GetDlgItem(pwnd, (UINT)wParam);
                }

                ThreadLock(pwndT2, &tlpwndT2);
                ThreadLock(pwndT3, &tlpwndT3);

                xxxCheckDefPushButton(pwndT1, HW(pwndT2), HW(pwndT3));

                ThreadUnlock(&tlpwndT3);
                ThreadUnlock(&tlpwndT2);

                PDLG(pwndT1)->result = (UINT)wParam;
//                if (PDLG(pwnd)->spwndFocusSave) {
//                    Lock(&(PDLG(pwnd)->spwndFocusSave), pwndT2);
//                }

                NotifyWinEvent(EVENT_OBJECT_DEFACTIONCHANGE, HW(pwndT1), OBJID_CLIENT, INDEXID_CONTAINER);
            }
            ThreadUnlock(&tlpwndT1);
            return TRUE;

        case DM_GETDEFID:
            pwndT1 = GetParentDialog(pwnd);

            if (!PDLG(pwndT1)->fEnd && PDLG(pwndT1)->result)
                return(MAKELONG(PDLG(pwndT1)->result, DC_HASDEFID));
            else
                return 0;
            break;

        /*
         * This message was added so that user defined controls that want
         * tab keys can pass the tab off to the next/previous control in the
         * dialog box.  Without this, all they could do was set the focus
         * which didn't do the default button stuff.
         */
        case WM_NEXTDLGCTL:
            pwndTop = GetParentDialog(pwnd);
            ThreadLock(pwndTop, &tlpwndTop);

            hwndT1 = GetFocus();
            pwndT2 = ValidateHwndNoRip(hwndT1);
            if (LOWORD(lParam)) {
                if (pwndT2 == NULL)
                    pwndT2 = pwndTop;

                /*
                 * wParam contains the pwnd of the ctl to set focus to.
                 */
                if ((pwndT1 = ValidateHwnd((HWND)wParam)) == NULL) {
                    ThreadUnlock(&tlpwndTop);
                    return TRUE;
                }
            } else {
                if (pwndT2 == NULL) {

                    /*
                     * Set focus to the first tab item.
                     */
                    pwndT1 = _GetNextDlgTabItem(pwndTop, NULL, FALSE);
                    pwndT2 = pwndTop;
                } else {

                    /*
                     * If window with focus not a dlg ctl, ignore message.
                     */
                    if (!_IsChild(pwndTop, pwndT2)) {
                        ThreadUnlock(&tlpwndTop);
                        return TRUE;
                    }
                    /*
                     * wParam = TRUE for previous, FALSE for next
                     */
                    pwndT1 = _GetNextDlgTabItem(pwndTop, pwndT2, (wParam != 0));

                    /*
                     * If there is no next item, ignore the message.
                     */
                    if (pwndT1 == NULL) {
                        ThreadUnlock(&tlpwndTop);
                        return TRUE;
                    }
                }
            }

            ThreadLock(pwndT1, &tlpwndT1);
            ThreadLock(pwndT2, &tlpwndT2);

            DlgSetFocus(HW(pwndT1));
            xxxCheckDefPushButton(pwndTop, HW(pwndT2), HW(pwndT1));

            ThreadUnlock(&tlpwndT2);
            ThreadUnlock(&tlpwndT1);
            ThreadUnlock(&tlpwndTop);

            return TRUE;

        case WM_ENTERMENULOOP:

            /*
             * We need to pop up the combo box window if the user brings
             * down a menu.
             *
             * ...  FALL THROUGH...
             */

        case WM_LBUTTONDOWN:
        case WM_NCLBUTTONDOWN:
            hwndT1 = GetFocus();
            if (hwndT1 != NULL) {
                pwndT1 = ValidateHwndNoRip(hwndT1);

                if (GETFNID(pwndT1) == FNID_COMBOBOX) {

                    /*
                     * If user clicks anywhere in dialog box and a combo box (or
                     * the editcontrol of a combo box) has the focus, then hide
                     * it's listbox.
                     */
                    ThreadLockAlways(pwndT1, &tlpwndT1);
                    SendMessage(HWq(pwndT1), CB_SHOWDROPDOWN, FALSE, 0);
                    ThreadUnlock(&tlpwndT1);

                } else {
                    PWND pwndParent;

                    /*
                     * It's a subclassed combo box.  See if the listbox and edit
                     * boxes exist (this is a very cheezy evaluation - what if
                     * these controls are subclassed too? NOTE: Not checking
                     * for EditWndProc: it's a client proc address.
                     */
                    pwndParent = REBASEPWND(pwndT1, spwndParent);
                    if (GETFNID(pwndParent) == FNID_COMBOBOX) {
                        pwndT1 = pwndParent;
                        ThreadLock(pwndT1, &tlpwndT1);
                        SendMessage(HWq(pwndT1), CB_SHOWDROPDOWN, FALSE, 0);
                        ThreadUnlock(&tlpwndT1);
                    }
                }
            }

            /*
             * Always send the message off to DefWndProc
             */
            goto CallDWP;

        case WM_GETFONT:
            return (LRESULT)PDLG(pwnd)->hUserFont;

        case WM_VKEYTOITEM:
        case WM_COMPAREITEM:
        case WM_CHARTOITEM:
        case WM_INITDIALOG:

            /*
             * We need to return the 0 the app may have returned for these
             * items instead of calling defwindow proc.
             */
            return result;

        case WM_NOTIFYFORMAT:
            if (lParam == NF_QUERY)
                return((PDLG(pwnd)->flags & DLGF_ANSI ) ? NFR_ANSI : NFR_UNICODE);
            return result;

        case WM_INPUTLANGCHANGEREQUEST:
            if (IS_IME_ENABLED()) {
                /*
                 * #115190
                 * For dialogbox itself, buttons/static controls on top of
                 * dialogbox, we'll simply discard this message. B#3843-win95c
                 */
                break;
            }
            if (PDLG(pwnd)->lpfnDlg == MB_DlgProc) {
                break;
            }
            goto CallDWP;

        default:
CallDWP:
            return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
        }
    } else if ((message == WM_SHOWWINDOW) && result) {

        /*
         * For a visible-case we want to snap the cursor regardless of
         * what was returned from the dialog-handler on the client.  If
         * we're going visible, snap the cursor to the dialog-button.
         */
        if (GetParentDialog(pwnd) == pwnd) {

            if (wParam && ((LOWORD(lParam) == 0) || !PDLG(pwnd)->fEnd)) {

                /*
                 * Snap the cursor to the center of the default button.
                 * Only do this if the current thread is in the foreground.
                 * The _ShowCursor() code is added to work around a
                 * problem with hardware cursors.  If change is done
                 * in the same refresh cycle, the display of the cursor
                 * would not reflect the new position.
                 */
                if (TEST_PUSIF(PUSIF_SNAPTO) &&
                        IsInForegroundQueue(hwnd)) {
                    hwndT1 = GetDlgItem(hwnd, (int)PDLG(pwnd)->result);
                    if (hwndT1) {
                        RECT rc;

                        NtUserShowCursor(FALSE);

                        GetWindowRect(hwndT1, &rc);
                        NtUserSetCursorPos(rc.left + ((rc.right - rc.left)/2),
                                     rc.top + ((rc.bottom - rc.top)/2));

                        NtUserShowCursor(TRUE);
                    }
                }
            }
        }
    }


    /*
     * If this is still marked as a dialog window then return the real
     * result. Otherwise, we've already processed the WM_NCDESTROY message
     * and freed our private memory so return the stored value.
     */
    if (TestWF(pwnd, WFDIALOGWINDOW))
        return KERNEL_LRESULT_TO_LRESULT(((PDIALOG)pwnd)->resultWP);
    else
        return result;
}


/***************************************************************************\
* DefDlgProc
*
* Translates the message, calls DefDlgProc on server side.  DefDlgProc
* is the default WindowProc for dialogs (NOT the dialog's dialog proc)
*
* 04-11-91 ScottLu Created.
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, LRESULT, WINAPI, DefDlgProcW, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefDlgProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    return DefDlgProcWorker(pwnd, message, wParam, lParam, FALSE);
}


FUNCLOG4(LOG_GENERAL, LRESULT, WINAPI, DefDlgProcA, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefDlgProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    return DefDlgProcWorker(pwnd, message, wParam, lParam, TRUE);
}


/***************************************************************************\
* DialogBox2
*
* History:
\***************************************************************************/

INT_PTR DialogBox2(
    HWND hwnd,
    HWND hwndOwner,
    BOOL fDisabled,
    BOOL fOwnerIsActiveWindow)
{
    MSG msg;
    INT_PTR result;
    BOOL fShown;
    BOOL fWantIdleMsgs;
    BOOL fSentIdleMessage = FALSE;
    HWND hwndCapture;
    PWND pwnd;

    if (hwnd) {
        pwnd = ValidateHwnd(hwnd);
    } else {
        pwnd = NULL;
    }

    CheckLock(pwnd);

    if (pwnd == NULL) {
        if ((hwndOwner != NULL) && !fDisabled && IsWindow(hwndOwner)) {
            NtUserEnableWindow(hwndOwner, TRUE);
            if (fOwnerIsActiveWindow) {

                /*
                 * The dialog box failed but we disabled the owner in
                 * xxxDialogBoxIndirectParam and if it had the focus, the
                 * focus was set to NULL.  Now, when we enable the window, it
                 * doesn't get the focus back if it had it previously so we
                 * need to correct this.
                 */
                NtUserSetFocus(hwndOwner);
            }
        }
        return -1;
    }

    hwndCapture = GetCapture();
    if (hwndCapture != NULL) {
        SendMessage(hwndCapture, WM_CANCELMODE, 0, 0);
    }

    /*
     * Set the 'parent disabled' flag for EndDialog().
     * convert BOOL to definite bit 0 or 1
     */
    PDLG(pwnd)->fDisabled = !!fDisabled;

    fShown = TestWF(pwnd, WFVISIBLE);

    /*
     * Should the WM_ENTERIDLE messages be sent?
     */
    fWantIdleMsgs = !(pwnd->style & DS_NOIDLEMSG);

    if ((SYSMET(SLOWMACHINE) & 1) && !fShown && !PDLG(pwnd)->fEnd)
        goto ShowIt;

    while (PDLG(pwnd) && (!PDLG(pwnd)->fEnd)) {
        if (!PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
ShowIt:
            if (!fShown) {
                fShown = TRUE;

#ifdef SYSMODALWINDOWS
                if (pwnd == gspwndSysModal) {
                    /*
                     * Make this a topmost window
                     */
                    NtUserSetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0,
                               SWP_NOSIZE | SWP_NOMOVE |
                               SWP_NOREDRAW | SWP_NOACTIVATE);
                }
#endif

                NtUserShowWindow(hwnd, SHOW_OPENWINDOW);
                UpdateWindow(hwnd);

                NotifyWinEvent(EVENT_SYSTEM_DIALOGSTART, hwnd, OBJID_WINDOW, INDEXID_CONTAINER);
            } else {
                /*
                 * Make sure window still exists
                 */
                if (hwndOwner && !IsWindow(hwndOwner))
                    hwndOwner = NULL;

                if (hwndOwner && fWantIdleMsgs && !fSentIdleMessage) {
                    fSentIdleMessage = TRUE;

                    SendMessage(hwndOwner, WM_ENTERIDLE, MSGF_DIALOGBOX, (LPARAM)hwnd);
                } else {
                    if ((RevalidateHwnd(hwnd)==NULL) || (pwnd->fnid & FNID_STATUS_BITS))
                        break;

                    NtUserWaitMessage();
                }
            }

        } else {
            /*
             * We got a real message.  Reset fSentIdleMessage so that we send
             * one next time things are calm.
             */
            fSentIdleMessage = FALSE;

            if (msg.message == WM_QUIT) {
                PostQuitMessage((int)msg.wParam);
                break;
            }

            /*
             * If pwnd is a message box, allow Ctrl-C and Ctrl-Ins
             * to copy its content to the clipboard.
             * Fall through in case hooking apps look for these keys.
             */
            if (TestWF(pwnd, WFMSGBOX)) {
                if ( (msg.message == WM_CHAR && LOBYTE(msg.wParam) == 3) ||
                     (msg.message == WM_KEYDOWN && LOBYTE(msg.wParam) == VK_INSERT && GetKeyState(VK_CONTROL) < 0)) {
                        /*
                         * Send the WM_COPY message and let the original message fall through
                         * as some apps might want it
                         */
                        SendMessage(hwnd, WM_COPY, 0, 0);
                }
            }

            /*
             * Moved the msg filter hook call to IsDialogMessage to allow
             * messages to be hooked for both modal and modeless dialog
             * boxes.
             */
            if (!IsDialogMessage(hwnd, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            /*
             * If we get a timer message, go ahead and show the window.
             * We may continuously get timer msgs if there are zillions of
             * apps running.
             *
             * If we get a syskeydown message, show the dialog box because
             * the user may be bringing down a menu and we want the dialog
             * box to become visible.
             */
            if (!fShown && (msg.message == WM_TIMER ||
                    msg.message == WM_SYSTIMER || msg.message == WM_SYSKEYDOWN))
                goto ShowIt;
        }

        if (!RevalidateHwnd(hwnd)) {
            /*
             * Bogus case - we've already been destroyed somehow (by app,
             * GP, etc.)
             */
            RIPMSG0(RIP_WARNING,
               "Dialog should be dismissed with EndDialog, not DestroyWindow");
            break;
        }
    }

    NotifyWinEvent(EVENT_SYSTEM_DIALOGEND, hwnd, OBJID_WINDOW, INDEXID_CONTAINER);

    /*
     * Make sure the window still exists
     */
    if (!RevalidateHwnd(hwnd)) {
        return 0;
    }

    if (PDLG(pwnd))
        result = KERNEL_INT_PTR_TO_INT_PTR(PDLG(pwnd)->result);
    else
        result = 0;

    NtUserDestroyWindow(hwnd);

    /*
     * If the owner window belongs to another thread, the reactivation
     * of the owner may have failed within DestroyWindow().  Therefore,
     * if the current thread is in the foreground and the owner is not
     * in the foreground we can safely set the foreground back
     * to the owner.
     */
    if (hwndOwner != NULL) {
        if (IsCurrentThreadForeground() &&
            !IsInForegroundQueue(hwndOwner)) {
            NtUserSetForegroundWindow(hwndOwner);
        }
    }

    return result;
}


/***************************************************************************\
* InternalDialogBox
*
* Server portion of DialogBoxIndirectParam.
*
* 04-05-91 ScottLu      Created.
\***************************************************************************/

INT_PTR InternalDialogBox(
    HANDLE hModule,
    LPDLGTEMPLATE lpdt,
    HWND hwndOwner,
    DLGPROC pfnDialog,
    LPARAM lParam,
    UINT fSCDLGFlags)
{
    INT_PTR i;
    BOOL fDisabled = FALSE;
    HWND hwnd;
    PWND pwndOwner;
    BOOL fOwnerIsActiveWindow = FALSE;
    TL tlpwndOwner;
    BOOL fUnlockOwner;

    UserAssert(!(fSCDLGFlags & ~(SCDLG_CLIENT|SCDLG_ANSI|SCDLG_16BIT)));    // These are the only valid flags

    /*
     * If hwndOwner == HWNDESKTOP, change it to NULL.  This way the desktop
     * (and all its children) won't be disabled if the dialog is modal.
     */
    if (hwndOwner && SAMEWOWHANDLE(hwndOwner, GetDesktopWindow()))
        hwndOwner = NULL;

    /*
     * We return 0 if the ValidateHwnd fails in order to match Win 3.1
     * validation layer which always returns 0 for invalid hwnds even
     * if the function is spec'ed to return -1.  Autocad setup bug #3615
     */
    if (hwndOwner) {
        if ((pwndOwner = ValidateHwnd(hwndOwner)) == NULL) {
            return (0L);
        }
    } else {
        pwndOwner = NULL;
    }

    CheckLock(pwndOwner);

    fUnlockOwner = FALSE;
    if (pwndOwner != NULL) {

        /* The following fixes an AV in Corel Photo-Paint 6.0.  It passes a
         * 16-bit HWND in, and croaks at some point when it gets 16-bit hwnds
         * back in send messages. FritzS -- fixing bug 12531
         */
        hwndOwner = PtoHq(pwndOwner);

        /*
         * Make sure the owner is a top level window.
         */
        if (TestwndChild(pwndOwner)) {
            pwndOwner = GetTopLevelWindow(pwndOwner);
            hwndOwner = HWq(pwndOwner);
            ThreadLock(pwndOwner, &tlpwndOwner);
            fUnlockOwner = TRUE;
        }

        /*
         * Remember if window was originally disabled (so we can set
         * the correct state when the dialog goes away.
         */
        fDisabled = TestWF(pwndOwner, WFDISABLED);
        fOwnerIsActiveWindow = (SAMEWOWHANDLE(hwndOwner, GetActiveWindow()));

        /*
         * Disable the window.
         */
        NtUserEnableWindow(hwndOwner, FALSE);
    }

    /*
     * Don't show cursors on a mouseless system. Put up an hour glass while
     * the dialog comes up.
     */
    if (SYSMET(MOUSEPRESENT)) {
        NtUserSetCursor(LoadCursor(NULL, IDC_WAIT));
    }

    /*
     * Creates the dialog.  Frees the menu if this routine fails.
     */
    hwnd = InternalCreateDialog(hModule, lpdt, 0, hwndOwner,
            pfnDialog, lParam, fSCDLGFlags);

    if (hwnd == NULL) {

        /*
         * The dialog creation failed.  Re-enable the window, destroy the
         * menu, ie., fail gracefully.
         */
        if (!fDisabled && hwndOwner != NULL)
            NtUserEnableWindow(hwndOwner, TRUE);

        if (fUnlockOwner)
            ThreadUnlock(&tlpwndOwner);
        return -1;
    }

    i = DialogBox2(hwnd, hwndOwner, fDisabled, fOwnerIsActiveWindow);

    if (fUnlockOwner)
        ThreadUnlock(&tlpwndOwner);
    return i;
}

/***************************************************************************\
**
**  RepositionRect()
**
**  Used to ensure that toplevel dialogs are still visible within the
**  desktop area after they've resized.
**
\***************************************************************************/

void
RepositionRect(
        PMONITOR    pMonitor,
        LPRECT      lprc,
        DWORD       dwStyle,
        DWORD       dwExStyle)
{
    LPRECT      lprcClip;
    int         y;

    UserAssert(lprc);
    UserAssert(pMonitor);

    if (dwStyle & WS_CHILD) {
        if (dwExStyle & WS_EX_CONTROLPARENT)
            return;

        /*
         * Old style 3.1 child dialogs--do this nonsense anyway.  Keeps
         * FedEx happy.
         */
        pMonitor = GetPrimaryMonitor();
        lprcClip = KPRECT_TO_PRECT(&pMonitor->rcMonitor);
    } else if (dwExStyle & WS_EX_TOOLWINDOW) {
        lprcClip = KPRECT_TO_PRECT(&pMonitor->rcMonitor);
    } else {
        lprcClip = KPRECT_TO_PRECT(&pMonitor->rcWork);
    }

    UserAssert(lprc);

    y = lprcClip->bottom - (SYSMET(CYEDGE) * 2 + SYSMET(CYKANJIWINDOW));

    if (lprc->bottom > y) {
        OffsetRect(lprc, 0, y - lprc->bottom);
    }

    if (lprc->top < lprcClip->top) {
        OffsetRect(lprc, 0, lprcClip->top - lprc->top);
    }

    if (lprc->right > lprcClip->right) {
        OffsetRect(lprc, lprcClip->right - lprc->right, 0);
    }

    if (lprc->left < lprcClip->left) {
        OffsetRect(lprc, lprcClip->left - lprc->left, 0);
    }
}

/***************************************************************************\
* MapDialogRect
*
* History:
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, MapDialogRect, HWND, hwnd, LPRECT, lprc)
BOOL MapDialogRect(
    HWND hwnd,
    LPRECT lprc)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return FALSE;
    }

    /*
     * Must do special validation here to make sure pwnd is a dialog window.
     */
    if (!ValidateDialogPwnd(pwnd))
        return FALSE;

    lprc->left = XPixFromXDU(lprc->left, PDLG(pwnd)->cxChar);
    lprc->right = XPixFromXDU(lprc->right, PDLG(pwnd)->cxChar);
    lprc->top = YPixFromYDU(lprc->top, PDLG(pwnd)->cyChar);
    lprc->bottom = YPixFromYDU(lprc->bottom, PDLG(pwnd)->cyChar);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\dmmnem.c ===
/***************************************************************************\
*
*  DMMNEM.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Mnemonic Character Processing Routines
*
* ??-???-???? mikeke    Ported from Win 3.0 sources
* 12-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * There are several loops that we could get stuck in that we just forcibly
 * break by a max iteration count. Ugly, but its legacy DialogManager
 * issues.
 */
#define INFINITE_LOOP_CURE 1024

/***************************************************************************\
* FindMnemChar
*
* Returns: 0x00 if no matching char,
*          0x01 if menmonic char is matching,
*          0x80 if first char is matching
*
* History:
*   11-18-90 JimA       Created.
\***************************************************************************/

int FindMnemChar(
    LPWSTR lpstr,
    WCHAR ch,
    BOOL fFirst,
    BOOL fPrefix)
{
    WCHAR chc;
    WCHAR chFirst;

    while (*lpstr == TEXT(' '))
        lpstr++;

    ch = (WCHAR)(ULONG_PTR)CharLowerW((LPWSTR)ULongToPtr( (DWORD)(UTCHAR)ch ));
    chFirst = (WCHAR)(ULONG_PTR)CharLowerW((LPWSTR)ULongToPtr( (DWORD)(UTCHAR)(*lpstr) ));

    if (fPrefix) {
        WORD wvch, xvkey;
        //
        // get OEM-dependent virtual key code
        //
        if (IS_DBCS_ENABLED() && (wvch = VkKeyScanW(ch)) != -1)
            wvch &= 0x00FF;

        while (chc = *lpstr++) {
            //
            // This should think about KOREA & TAIWAN case. But probably OK.
            //
            if ((chc == CH_PREFIX) || (chc == CH_ENGLISHPREFIX && IS_DBCS_ENABLED())) {

                WORD chnext = (WCHAR)(ULONG_PTR)CharLowerW((LPWSTR)ULongToPtr( (DWORD)(UTCHAR)*lpstr ));

                if (chnext == CH_PREFIX) {
                    //
                    // Two CH_PREFIX in the resrc string results in one "&" in the text displayed
                    //
                    lpstr++;
                } else {
                    if (chnext == ch) {
                        return 0x01;
                    }
                    if (IS_DBCS_ENABLED()) {
                        //
                        // Compare should be done with virtual key in Kanji menu mode
                        // in order to accept Digit shortcut key and save English
                        // windows applications!
                        //
                        xvkey = VkKeyScanW(chnext);
                        if (xvkey != 0xFFFF && ((xvkey & 0x00FF) == wvch)) {
                            return 0x01;
                        }
                   }
                   return 0x00;
                }
            }
        }
    }
#if 0   // the original US code on NT4
    if (fPrefix) {
        while (chc = *lpstr++) {
            if (((WCHAR)CharLower((LPWSTR)(DWORD)(UTCHAR)chc) == CH_PREFIX)) {
                chnext = (WCHAR)CharLowerW((LPWSTR)(DWORD)(UTCHAR)*lpstr);

                if (chnext == CH_PREFIX)
                    lpstr++;
                else if (chnext == ch)
                    return 0x01;
                else {
                    return 0x00;
                }
            }
        }
    }
#endif // FE_SB

    if (fFirst && (ch == chFirst))
        return 0x80;

    return 0x00;
}


/***************************************************************************\
* xxxFindNextMnem
*
* This function returns NULL if no control with the specified mnemonic
* can be found.
*
* History:
\***************************************************************************/

PWND xxxGNM_FindNextMnem(
    PWND pwndDlg,
    PWND pwnd,
    WCHAR ch)
{
    PWND pwndStart;
    PWND pwndT;
    WCHAR rgchText[256];
    int i = 0;
    TL tlpwndStart;
    TL tlpwnd;
    DWORD dwDlgCode;

    CheckLock(pwndDlg);
    CheckLock(pwnd);

    /*
     * Check if we are in a group box so we can find local mnemonics.
     */

    pwndStart = _GetChildControl(pwndDlg, pwnd);
    ThreadLock(pwndStart, &tlpwndStart);

    while (TRUE) {

        pwndT = _GetNextDlgGroupItem(pwndDlg, pwndStart, FALSE);

        ThreadUnlock(&tlpwndStart);

        i++;
        if (pwndT == NULL || pwndT == pwnd || i > INFINITE_LOOP_CURE) {

            /*
             * If we have returned to our starting window or if we have gone
             * through INFINITE_LOOP_CURE iterations, let's exit.  There are
             * no local mnemonics that match.  We have to check for 
             * INFINITE_LOOP_CURE iterations (or so) because we run into
             * problems with WS_GROUP not being properly defined in rc files
             * that we never reach this same starting window again....
             */
            break;
        }

        pwndStart = pwndT;

        /*
         * Only check for matching mnemonic if control doesn't want characters
         * and control isn't a static control with SS_NOPREFIX
         */
        ThreadLock(pwndStart, &tlpwndStart);

        dwDlgCode = (DWORD)SendMessage(HWq(pwndT), WM_GETDLGCODE, 0, 0L);
        if (!(dwDlgCode & DLGC_WANTCHARS) &&
                (!(dwDlgCode & DLGC_STATIC) || !(pwndT->style & SS_NOPREFIX))) {
            GetWindowText(HWq(pwndT), rgchText, sizeof(rgchText)/sizeof(WCHAR));
            if (FindMnemChar(rgchText, ch, FALSE, TRUE) != 0) {
                ThreadUnlock(&tlpwndStart);
                return pwndT;
            }
        }
    }

    pwnd = pwndStart = _GetChildControl(pwndDlg, pwnd);
    i = 0;

    ThreadLock(pwnd, &tlpwnd);
    while (TRUE) {

        /*
         * Start with next so we see multiples of same mnemonic.
         */
        pwnd = _NextControl(pwndDlg, pwnd, TRUE);
        ThreadUnlock(&tlpwnd);
        ThreadLock(pwnd, &tlpwnd);

        /*
         * Only check for matching mnemonic if control doesn't want characters
         * and control isn't a static control with SS_NOPREFIX
         */
        dwDlgCode = (DWORD)SendMessage(HW(pwnd), WM_GETDLGCODE, 0, 0L);
        if (!(dwDlgCode & DLGC_WANTCHARS) &&
                (!(dwDlgCode & DLGC_STATIC) || !(pwnd->style & SS_NOPREFIX))) {
            GetWindowText(HW(pwnd), rgchText, sizeof(rgchText)/sizeof(WCHAR));
            if (FindMnemChar(rgchText, ch, FALSE, TRUE) != 0)
                break;
        }

        i++;
        if (pwnd == pwndStart || i > INFINITE_LOOP_CURE) {
            pwnd = NULL;
            break;
        }
    }
    ThreadUnlock(&tlpwnd);

    return pwnd;
}

/***************************************************************************\
* xxxGotoNextMnem
*
* History:
\***************************************************************************/

PWND xxxGotoNextMnem(
    PWND pwndDlg,
    PWND pwnd,
    WCHAR ch)
{
    UINT code;
    PWND pwndFirstFound = NULL;
    int count = 0;
    TL tlpwnd;
    PWND pwndT;
    HWND hwnd;

    CheckLock(pwndDlg);
    CheckLock(pwnd);

    ThreadLock(pwnd, &tlpwnd);

    /*
     * Loop for a long time but not long enough so we hang...
     */
    while (count < INFINITE_LOOP_CURE) {

        /*
         * If the dialog box doesn't has the mnemonic specified, return NULL.
         */
        if ((pwnd = xxxGNM_FindNextMnem(pwndDlg, pwnd, ch)) == NULL) {
            ThreadUnlock(&tlpwnd);
            return NULL;
        }
        hwnd = HWq(pwnd);

        ThreadUnlock(&tlpwnd);
        ThreadLock(pwnd, &tlpwnd);

        code = (UINT)SendMessage(hwnd, WM_GETDLGCODE, 0, 0L);

        /*
         * If a non-disabled static item, then jump ahead to nearest tabstop.
         */
        if (code & DLGC_STATIC && !TestWF(pwnd, WFDISABLED)) {
            pwndT = _GetNextDlgTabItem(pwndDlg, pwnd, FALSE);

            /*
             * If there is no other tab item, keep looking
             */
            if (pwndT == NULL)
                continue;
            pwnd = pwndT;
            hwnd = HWq(pwnd);

            ThreadUnlock(&tlpwnd);
            ThreadLock(pwnd, &tlpwnd);

            /*
             * I suppose we should do a getdlgcode here, but who is going to
             * label a button with a static control?  The setup guys, that's
             * who...  Also, generally useful for ownerdraw buttons which are
             * labeled with a static text item.
             */
            code = (UINT)SendMessage(hwnd, WM_GETDLGCODE, 0, 0L);
        }

        if (!TestWF(pwnd, WFDISABLED)) {

            /*
             * Is it a Pushbutton?
             */
            if (!(code & DLGC_BUTTON)) {

                /*
                 * No, simply give it the focus.
                 */
                DlgSetFocus(hwnd);
            } else {

                /*
                 * Yes, click it, but don't give it the focus.
                 */
                if ((code & DLGC_DEFPUSHBUTTON) || (code & DLGC_UNDEFPUSHBUTTON)) {

                    /*
                     * Flash the button.
                     */
                    SendMessage(hwnd, BM_SETSTATE, TRUE, 0L);

                    /*
                     * Delay
                     */
#ifdef LATER
// JimA - 2/19/92
// There oughta be a better way of doing this...
                    for (i = 0; i < 10000; i++)
                        ;
#else
                    Sleep(1);
#endif

                    /*
                     * Un-Flash it.
                     */
                    SendMessage(hwnd, BM_SETSTATE, FALSE, 0L);

                    /*
                     * Send the WM_COMMAND message.
                     */
                    pwndT = REBASEPWND(pwnd, spwndParent);
                    SendMessage(HW(pwndT), WM_COMMAND,
                            MAKELONG(PTR_TO_ID(pwnd->spmenu), BN_CLICKED), (LPARAM)hwnd);
                    ThreadUnlock(&tlpwnd);
                    return (PWND)1;
                } else {

                    /*
                     * Because BM_CLICK processing will result in BN_CLICK msg,
                     * xxxSetFocus must be prevented from sending the same msg;
                     * Otherwise, it will notify parent twice!
                     * Fix for Bug #3024 -- SANKAR -- 09-22-89 --
                     */
                    BOOL fIsNTButton;
                    PBUTN pbutn;

                    fIsNTButton = IS_BUTTON(pwnd);
                    if (fIsNTButton) {
                      pbutn = ((PBUTNWND)pwnd)->pbutn;
                      BUTTONSTATE(pbutn) |= BST_DONTCLICK;
                    } else {
                     RIPMSG0(RIP_WARNING, "xxxGotoNextMnem: fnid != FNID_BUTTON");
                    }

                    DlgSetFocus(hwnd);

                    if (fIsNTButton) {
                      BUTTONSTATE(pbutn) &= ~BST_DONTCLICK;
                    }

                    /*
                     * Send click message if button has a UNIQUE mnemonic
                     */
                    if (xxxGNM_FindNextMnem(pwndDlg, pwnd, ch) == pwnd) {
                        SendMessage(hwnd, BM_CLICK, TRUE, 0L);
                    }
                }
            }

            ThreadUnlock(&tlpwnd);
            return pwnd;
        } else {

            /*
             * Stop if we've looped back to the first item we checked
             */
            if (pwnd == pwndFirstFound) {
                ThreadUnlock(&tlpwnd);
                return NULL;
            }

            if (pwndFirstFound == NULL)
                pwndFirstFound = pwnd;
        }

        count++;

    }  /* Loop for a long time */

    ThreadUnlock(&tlpwnd);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\draw.c ===
/****************************** Module Header ******************************\
* Module Name: draw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the DrawFrameControl API
*
* History:
* 12-12-93  FritzS  Ported from Chicago
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* PaintRect
*
* History:
* 11-15-90 DarrinM  Ported from Win 3.0 sources.
* 01-21-91 IanJa    Prefix '_' denoting exported function (although not API)
* 12-12-94 JerrySh  Copied from server - make sure to keep in sync
\***************************************************************************/

BOOL PaintRect(
    HWND hwndBrush,
    HWND hwndPaint,
    HDC hdc,
    HBRUSH hbr,
    LPRECT lprc)
{
    POINT ptOrg;
    PWND pwndBrush;
    PWND pwndPaint;
    HWND    hwndDesktop;

    hwndDesktop = GetDesktopWindow();
    if (hwndBrush == NULL) {
        hwndBrush = hwndDesktop;
    }

    if (hwndBrush != hwndPaint) {
        pwndBrush = ValidateHwnd(hwndBrush);
        if (pwndBrush == NULL) {
            RIPMSG1(RIP_WARNING, "PaintRect: invalid Brush window %lX", hwndBrush);
            return FALSE;
        }

        pwndPaint = ValidateHwnd(hwndPaint);
        if (pwndPaint == NULL) {
            RIPMSG1(RIP_WARNING, "PaintRect: invalid Paint window %lX", hwndBrush);
            return FALSE;
        }


        if (hwndBrush != hwndDesktop) {
            SetBrushOrgEx(
                    hdc,
                    pwndBrush->rcClient.left - pwndPaint->rcClient.left,
                    pwndBrush->rcClient.top - pwndPaint->rcClient.top,
                    &ptOrg);
        } else {
            SetBrushOrgEx(hdc, 0, 0, &ptOrg);
        }
    }

    /*
     * If hbr < CTLCOLOR_MAX, it isn't really a brush but is one of our
     * special color values.  Translate it to the appropriate WM_CTLCOLOR
     * message and send it off to get back a real brush.  The translation
     * process assumes the CTLCOLOR*** and WM_CTLCOLOR*** values map directly.
     */
    if (hbr < (HBRUSH)CTLCOLOR_MAX) {
        hbr = GetControlColor(hwndBrush, hwndPaint, hdc,
                HandleToUlong(hbr) + WM_CTLCOLORMSGBOX);
    }

    FillRect(hdc, lprc, hbr);

    if (hwndBrush != hwndPaint) {
        SetBrushOrgEx(hdc, ptOrg.x, ptOrg.y, NULL);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\drawtext.c ===
/****************************** Module Header ******************************\
* Module Name: drawtext.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains common text drawing functions.
*
* History:
* 02-12-92 mikeke   Moved Drawtext to the client side
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CR 13
#define LF 10

#define DT_HFMTMASK 0x03

/***************************************************************************\
* IsMetaFile
*
* History:
* 30-Nov-1992 mikeke    Created
\***************************************************************************/

BOOL IsMetaFile(
    HDC hdc)
{
    DWORD dwType = GetObjectType(hdc);
    return (dwType == OBJ_METAFILE ||
            dwType == OBJ_METADC ||
            dwType == OBJ_ENHMETAFILE ||
            dwType == OBJ_ENHMETADC);
}

/***************************************************************************\
* DrawTextA (API)
*
* History:
* 30-11-92 mikeke      Created
\***************************************************************************/


CONST WCHAR gwszNullStr[] = L"";


FUNCLOG6(LOG_GENERAL, int, DUMMYCALLINGTYPE, DrawTextExA, HDC, hdc, LPSTR, lpchText, int, cchText, LPRECT, lprc, UINT, format, LPDRAWTEXTPARAMS, lpdtp)
int DrawTextExA(
    HDC hdc,
    LPSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format,
    LPDRAWTEXTPARAMS lpdtp)
{
    LPWSTR lpwstr;
    int iRet;
    int iUniString;
    WORD wCodePage = (WORD)GdiGetCodePage(hdc);

    if (cchText == -1) {
        // USER_AWCONV_COUNTSTRINGSZ does not count/convert trailing \0.
        cchText = USER_AWCONV_COUNTSTRINGSZ;
    } else if (cchText < -1) {
        return 0;
    }

    if ((iUniString = MBToWCSEx(wCodePage, lpchText, cchText, &lpwstr, -1, TRUE)) == 0) {
        if (cchText == USER_AWCONV_COUNTSTRINGSZ) {
            lpwstr = (LPWSTR)gwszNullStr;
            format &= ~DT_MODIFYSTRING;
        } else {
            return 0;
        }
    }

    /*
     * Grow the buffer to accomodate the ellipsis (see AddEllipsisAndDrawLine)
     */
    if (format & DT_MODIFYSTRING) {
        int iNewLen = (iUniString + CCHELLIPSIS + 1) * sizeof(*lpwstr);
        LPWSTR lpwstrNew = UserLocalReAlloc(lpwstr, iNewLen, HEAP_ZERO_MEMORY);
        if (lpwstrNew == NULL) {
            UserLocalFree((HANDLE)lpwstr);
            return FALSE;
        }
        lpwstr = lpwstrNew;
    }

    iRet = DrawTextExWorker(hdc, lpwstr, iUniString, lprc, format, lpdtp, GetTextCharset(hdc));

    if (format & DT_MODIFYSTRING) {
        /*
         * Note that if the buffer grew and the caller provided the string size,
         *  then we won't return the additional characters... fixing this
         *  might break some apps so let's leave it alone until some one complains
         */
        if (cchText < 0) {
            UserAssert(cchText == USER_AWCONV_COUNTSTRINGSZ);
            // Guess how many bytes we can put in the buffer...
            // We can safely assume the maximum bytes available.
            // At worst, even for DBCS, the buffer size required
            // will be smaller than or equal to the orignal size,
            // because some DBCS characters would be substituted
            // to SBC ".", which is one byte each.
            // On the other hand, the number of characters converted
            // is limited by both iUniString and cchText.
            //
            if (IS_DBCS_ENABLED()) {
                cchText = iUniString * DBCS_CHARSIZE;
            } else {
                cchText = iUniString * sizeof(CHAR);
            }
        }
        WCSToMBEx(wCodePage, lpwstr, iUniString, &lpchText, cchText, FALSE);
    }

    if (lpwstr != gwszNullStr) {
        UserLocalFree((HANDLE)lpwstr);
    }

    return iRet;
}

/***************************************************************************\
* DrawTextW (API)
*
* History:
* 30-11-92 mikeke      Created
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, DrawTextW, HDC, hdc, LPCWSTR, lpchText, int, cchText, LPRECT, lprc, UINT, format)
int DrawTextW(
    HDC hdc,
    LPCWSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format)
{
    DRAWTEXTPARAMS      DTparams;
    LPDRAWTEXTPARAMS    lpDTparams = NULL;

    /* v-ronaar: fix bug #24985
     * Disallow negative string lengths, except -1 (which has special meaning).
     */
    if (cchText < -1)
        return(0);

    if (format & DT_TABSTOP)
    {
        DTparams.cbSize      = sizeof(DRAWTEXTPARAMS);
        DTparams.iLeftMargin = DTparams.iRightMargin = 0;
        DTparams.iTabLength  = (format & 0xff00) >> 8;
        lpDTparams           = &DTparams;
        format              &= 0xffff00ff;
    }

    return DrawTextExW(hdc, (LPWSTR)lpchText, cchText, lprc, format, lpDTparams);
}

/***************************************************************************\
* DrawTextA (API)
*
* History:
* 30-11-92 mikeke      Created
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, DrawTextA, HDC, hdc, LPCSTR, lpchText, int, cchText, LPRECT, lprc, UINT, format)
int DrawTextA(
    HDC hdc,
    LPCSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format)
{
    DRAWTEXTPARAMS   DTparams;
    LPDRAWTEXTPARAMS lpDTparams = NULL;

    /* v-ronaar: fix bug #24985
     * Disallow negative string lengths, except -1 (which has special meaning).
     */
    if (cchText < -1)
        return(0);

    if (format & DT_TABSTOP) {
        DTparams.cbSize      = sizeof(DRAWTEXTPARAMS);
        DTparams.iLeftMargin = DTparams.iRightMargin = 0;
        DTparams.iTabLength  = (format & 0xff00) >> 8;
        lpDTparams           = &DTparams;
        format              &= 0xffff00ff;
    }

    return DrawTextExA(hdc, (LPSTR)lpchText, cchText, lprc, format, lpDTparams);
}

/***************************************************************************\
* ClientTabTheTextOutForWimps
*
* effects: Outputs the tabbed text if fDrawTheText is TRUE and returns the
* textextent of the tabbed text.
*
* nCount                    Count of bytes in string
* nTabPositions             Count of tabstops in tabstop array
* lpintTabStopPositions     Tab stop positions in pixels
* iTabOrigin                Tab stops are with respect to this
*
* History:
* 19-Jan-1993 mikeke   Client side
* 13-Sep-1996 GregoryW This routine now calls the LPK(s) to handle text out.
*                      If no LPKs are installed, this defaults to calling
*                      UserLpkTabbedTextOut (identical behavior to what we
*                      had before supporting LPKs).
\***************************************************************************/

LONG TabTextOut(
    HDC hdc,
    int x,
    int y,
    LPCWSTR lpstring,
    int nCount,
    int nTabPositions,
    CONST INT *lpTabPositions,
    int iTabOrigin,
    BOOL fDrawTheText,
    int iCharset)
{
    int     cxCharWidth;
    int     cyCharHeight = 0;

    if (nCount == -1 && lpstring) {
        nCount = wcslen(lpstring);
    }
    if (!lpstring || nCount < 0 || nTabPositions < 0)
        return 0;


    // Check if it is SysFont AND the mapping mode is MM_TEXT;
    // Fix made in connection with Bug #8717 --02-01-90  --SANKAR--
    if (IsSysFontAndDefaultMode(hdc))
    {
        cxCharWidth  = gpsi->cxSysFontChar;
        cyCharHeight = gpsi->cySysFontChar;
    } else {
        cxCharWidth  = GdiGetCharDimensions(hdc, NULL, &cyCharHeight);
        if (cxCharWidth == 0) {
            RIPMSG0(RIP_WARNING, "TabTextOut: GdiGetCharDimensions failed");
            return 0;
        }
    }

    return (*fpLpkTabbedTextOut)(hdc, x, y, lpstring, nCount, nTabPositions,
                                 lpTabPositions, iTabOrigin, fDrawTheText,
                                 cxCharWidth, cyCharHeight, iCharset);
}

LONG UserLpkTabbedTextOut(
    HDC hdc,
    int x,
    int y,
    LPCWSTR lpstring,
    int nCount,
    int nTabPositions,
    CONST INT *lpTabPositions,
    int iTabOrigin,
    BOOL fDrawTheText,
    int cxCharWidth,
    int cyCharHeight,
    int iCharset)
{
    SIZE textextent, viewextent, windowextent;
    int     initialx = x;
    int     cch;
    LPCWSTR  lp;
    int     iOneTab = 0;
    RECT rc;
    UINT uOpaque = (GetBkMode(hdc) == OPAQUE) ? ETO_OPAQUE : 0;
    BOOL    fStrStart = TRUE;
    int     ySign = 1; //Assume y increases in down direction.

    UNREFERENCED_PARAMETER(iCharset);   //Needed by lpk, but not us
    /*
     * If no tabstop positions are specified, then use a default of 8 system
     * font ave char widths or use the single fixed tab stop.
     */
    if (!lpTabPositions) {
       // no tab stops specified -- default to a tab stop every 8 characters
        iOneTab = 8 * cxCharWidth;
    } else if (nTabPositions == 1) {
        // one tab stop specified -- treat value as the tab increment, one
        // tab stop every increment
            iOneTab = lpTabPositions[0];

        if (!iOneTab)
             iOneTab = 1;
    }

    // Calculate if the y increases or decreases in the down direction using
    // the ViewPortExtent and WindowExtents.
    // If this call fails, hdc must be invalid
    if (!GetViewportExtEx(hdc, &viewextent))
        return 0;
    GetWindowExtEx(hdc, &windowextent);
    if ((viewextent.cy ^ windowextent.cy) & 0x80000000)
         ySign = -1;

    rc.left = initialx;
    rc.top = y;
    rc.bottom = rc.top + (ySign * cyCharHeight);

    while (TRUE) {
        // count the number of characters until the next tab character
        // this set of characters (substring) will be the working set for
        // each iteration of this loop
        for (cch = nCount, lp = lpstring; cch && (*lp != TEXT('\t')); lp++, cch--)
        {
        }

        // Compute the number of characters to be drawn with textout.
        cch = nCount - cch;

        // Compute the number of characters remaining.
        nCount -= cch + 1;

        // get height and width of substring
        if (cch == 0) {
            textextent.cx = 0;
            textextent.cy = cyCharHeight;
        } else
            GetTextExtentPointW(hdc, lpstring, cch, &textextent);

        if (fStrStart)
            // first iteration should just spit out the first substring
            // no tabbing occurs until the first tab character is encountered
            fStrStart = FALSE;
        else
        {
           // not the first iteration -- tab accordingly

            int xTab;
            int i;

            if (!iOneTab)
            {
                // look thru tab stop array for next tab stop after existing
                // text to put this substring
                for (i = 0; i < nTabPositions; i++)
                {
                    xTab = lpTabPositions[i];

                    if (xTab < 0)
                        // calc length needed to use this right justified tab
                        xTab = (iTabOrigin - xTab) - textextent.cx;
                    else
                        // calc length needed to use this left  justified tab
                        xTab = iTabOrigin + xTab;

                    if (x < xTab)
                    {
                        // we found a tab with enough room -- let's use it
                        x = xTab;
                        break;
                    }
                }

                if (i == nTabPositions)
                    // we've exhausted all of the given tab positions
                    // go back to default of a tab stop every 8 characters
                    iOneTab = 8 * cxCharWidth;
            }

            // we have to recheck iOneTab here (instead of just saying "else")
            // because iOneTab will be set if we've run out of tab stops
            if (iOneTab)
            {
                if (iOneTab < 0)
                {
                    // calc next available right justified tab stop
                    xTab = x + textextent.cx - iTabOrigin;
                    xTab = ((xTab / iOneTab) * iOneTab) - iOneTab - textextent.cx + iTabOrigin;
                }
                else
                {
                    // calc next available left justified tab stop
                    xTab = x - iTabOrigin;
                    xTab = ((xTab / iOneTab) * iOneTab) + iOneTab + iTabOrigin;
                }
                x = xTab;
            }
        }

        if (fDrawTheText) {

            /*
             * Output all text up to the tab (or end of string) and get its
             * extent.
             */
            rc.right = x + textextent.cx;
            ExtTextOutW(
                    hdc, x, y, uOpaque, &rc, (LPWSTR)lpstring,
                    cch, NULL);
            rc.left = rc.right;
        }

        // Skip over the tab and the characters we just drew.
        x += textextent.cx;

        // Skip over the characters we just drew.
        lpstring += cch;

        // See if we have more to draw OR see if this string ends in
        // a tab character that needs to be drawn.
        if((nCount > 0) || ((nCount == 0) && (*lpstring == TEXT('\t'))))
        {

            lpstring++;  // Skip over the tab
            continue;
        }
        else
            break;        // Break from the loop.
    }
    return MAKELONG((x - initialx), (short)textextent.cy);
}



/***************************************************************************\
*  TabbedTextOutW
*
* effects: Outputs the tabbed text and returns the
* textextent of the tabbed text.
*
* nCount                    Count of bytes in string
* nTabPositions             Count of tabstops in tabstop array
* lpintTabStopPositions     Tab stop positions in pixels
* iTabOrigin                Tab stops are with respect to this
*
* History:
* 19-Jan-1993 mikeke   Client side
\***************************************************************************/

LONG TabbedTextOutW(
    HDC hdc,
    int x,
    int y,
    LPCWSTR lpstring,
    int cchChars,
    int nTabPositions,
    CONST INT *lpintTabStopPositions,
    int iTabOrigin)
{
    return TabTextOut(hdc, x, y, lpstring, cchChars,
        nTabPositions, lpintTabStopPositions, iTabOrigin, TRUE, -1);
}

/***************************************************************************\
* TabbedTextOutA (API)
*
* History:
* 30-11-92 mikeke      Created
\***************************************************************************/

LONG TabbedTextOutA(
    HDC hdc,
    int x,
    int y,
    LPCSTR pString,
    int chCount,
    int nTabPositions,
    CONST INT *pnTabStopPositions,
    int nTabOrigin)
{
    LPWSTR lpwstr;
    BOOL bRet;
    WORD wCodePage = (WORD)GdiGetCodePage(hdc);
    int  iUniString;

    if (chCount == -1) {
        chCount = USER_AWCONV_COUNTSTRINGSZ;
    }

    if ((iUniString = MBToWCSEx(wCodePage, pString, chCount, &lpwstr, -1, TRUE)) == 0) {
        if (chCount == USER_AWCONV_COUNTSTRINGSZ) {
            lpwstr = (LPWSTR)gwszNullStr;
        } else {
            return FALSE;
        }
    }

    bRet = TabTextOut(
            hdc, x, y, lpwstr, iUniString, nTabPositions,
            pnTabStopPositions, nTabOrigin, TRUE, GetTextCharset(hdc));

    if (lpwstr != gwszNullStr) {
        UserLocalFree((HANDLE)lpwstr);
    }

    return bRet;
}

DWORD GetTabbedTextExtentW(
    HDC hdc,
    LPCWSTR pString,
    int chCount,
    int nTabPositions,
    CONST INT *pnTabStopPositions)
{
    return TabTextOut(hdc, 0, 0, pString, chCount,
        nTabPositions, pnTabStopPositions, 0, FALSE, -1);
}

DWORD GetTabbedTextExtentA(
    HDC hdc,
    LPCSTR pString,
    int chCount,
    int nTabPositions,
    CONST INT *pnTabStopPositions)
{
    LPWSTR lpwstr;
    BOOL bRet;
    WORD wCodePage = (WORD)GdiGetCodePage(hdc);
    int iUniString;

    if (chCount == -1) {
        chCount = USER_AWCONV_COUNTSTRINGSZ;
    }
    if ((iUniString = MBToWCSEx(wCodePage, pString, chCount, &lpwstr, -1, TRUE)) == 0) {
        if (chCount == USER_AWCONV_COUNTSTRINGSZ) {
            lpwstr = (LPWSTR)gwszNullStr;
        } else {
            return FALSE;
        }
    }

    bRet = TabTextOut(hdc, 0, 0, lpwstr, iUniString,
        nTabPositions, pnTabStopPositions, 0, FALSE, GetTextCharset(hdc));

    if (lpwstr != gwszNullStr) {
        UserLocalFree((HANDLE)lpwstr);
    }

    return bRet;
}


/***************************************************************************\
* PSMTextOut
*
* Outputs the text and puts and _ below the character with an &
* before it. Note that this routine isn't used for menus since menus
* have their own special one so that it is specialized and faster...
*
* History:
* 11-13-90 JimA         Ported to NT.
* 30-Nov-1992 mikeke    Client side version
* 7-Apr-1998 MCostea    Added dwFlags
\***************************************************************************/

void PSMTextOut(
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR lpsz,
    int cch,
    DWORD dwFlags)
{
    /*
     * By default this is just a call to UserLpkPSMTextOut.  If an
     * LPK is installed, this calls out to the LPK.  The LPK calls
     * UserLpkPSMTextOut, if necessary.
     */
    (*fpLpkPSMTextOut)(hdc, xLeft, yTop, lpsz, cch, dwFlags);
    return;
}

/***************************************************************************\
* UserLpkPSMTextOut
*
* NOTE: A very similar routine (xxxPSMTextOut) exists on the kernel
*       side in text.c.  Any changes to this routine most likely need
*       to be made in xxxPSMTextOut as well.
*
\***************************************************************************/

FUNCLOGVOID6(LOG_GENERAL, DUMMYCALLINGTYPE, UserLpkPSMTextOut, HDC, hdc, int, xLeft, int, yTop, LPWSTR, lpsz, int, cch, DWORD, dwFlags)
void UserLpkPSMTextOut(
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR lpsz,
    int cch,
    DWORD dwFlags)
{
   int cx;
   LONG textsize, result;
   WCHAR achWorkBuffer[255];
   WCHAR *pchOut = achWorkBuffer;
   TEXTMETRICW textMetric;
   SIZE size;
   RECT rc;
   COLORREF color;

   if (cch > sizeof(achWorkBuffer)/sizeof(WCHAR)) {
       pchOut = (WCHAR*)UserLocalAlloc(HEAP_ZERO_MEMORY, (cch+1) * sizeof(WCHAR));
       if (pchOut == NULL)
           return;
   }

   result = GetPrefixCount(lpsz, cch, pchOut, cch);
   /*
    * DT_PREFIXONLY is a new 5.0 option used when switching from keyboard cues off
    *  to on.
    */
   if (!(dwFlags & DT_PREFIXONLY)) {
       TextOutW(hdc, xLeft, yTop, pchOut, cch - HIWORD(result));
   }

   /*
    * Any true prefix characters to underline?
    */
   if (LOWORD(result) == 0xFFFF || dwFlags & DT_HIDEPREFIX) {
       if (pchOut != achWorkBuffer)
           UserLocalFree(pchOut);
       return;
   }

   if (!GetTextMetricsW(hdc, &textMetric)) {
       textMetric.tmOverhang = 0;
       textMetric.tmAscent = 0;
   }

   /*
    * For proportional fonts, find starting point of underline.
    */
   if (LOWORD(result) != 0) {

       /*
        * How far in does underline start (if not at 0th byte.).
        */
       GetTextExtentPointW(hdc, pchOut, LOWORD(result), &size);
       xLeft += size.cx;

       /*
        * Adjust starting point of underline if not at first char and there is
        * an overhang.  (Italics or bold fonts.)
        */
       xLeft = xLeft - textMetric.tmOverhang;
   }

   /*
    * Adjust for proportional font when setting the length of the underline and
    * height of text.
    */
   GetTextExtentPointW(hdc, pchOut + LOWORD(result), 1, &size);
   textsize = size.cx;

   /*
    * Find the width of the underline character.  Just subtract out the overhang
    * divided by two so that we look better with italic fonts.  This is not
    * going to effect embolded fonts since their overhang is 1.
    */
   cx = LOWORD(textsize) - textMetric.tmOverhang / 2;

   /*
    * Get height of text so that underline is at bottom.
    */
   yTop += textMetric.tmAscent + 1;

   /*
    * Draw the underline using the foreground color.
    */
   SetRect(&rc, xLeft, yTop, xLeft+cx, yTop+1);
   color = SetBkColor(hdc, GetTextColor(hdc));
   ExtTextOutW(hdc, xLeft, yTop, ETO_OPAQUE, &rc, TEXT(""), 0, NULL);
   SetBkColor(hdc, color);

   if (pchOut != achWorkBuffer) {
       UserLocalFree(pchOut);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\eckanji.c ===
/****************************************************************************/
/* */
/* ECKANJI.C -                                                                    */
/* */
/* Copyright (c) 1985 - 1999, Microsoft Corporation */
/* */
/* Kanji Support Routines */
/* */
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef KANJI

/***************************************************************************\
* SysHasKanji
*
* <brief description>
*
* History:
\***************************************************************************/

BOOL SysHasKanji(
    )
{
  return (*(WORD *)&keybdInfo.Begin_First_range != 0x0FEFF ||
          *(WORD *)&keybdInfo.Begin_Second_range != 0x0FEFF);
}

/***************************************************************************\
* KAlign
*
* Make sure the given char isn't the index of the second byte of a Kanji word.
*
* History:
\***************************************************************************/

int KAlign(
     PED ped,
    int ichIn)
{
   int ichCheck;
  int ichOut;
  LPSTR lpch;

  /*
   * ichOut chases ichCheck until ichCheck > ichIn
   */
  if (ped->fSingle)
      ichOut = ichCheck = 0;
  else
      ichOut = ichCheck = ped->mpilich[IlFromIch(ped, ichIn)];

  lpch = ECLock(ped) + ichCheck;
  while (ichCheck <= ichIn) {
      ichOut = ichCheck;
      if (IsTwoByteCharPrefix(*(unsigned char *)lpch))
    {
          lpch++;
          ichCheck++;
        }

      lpch++;
      ichCheck++;
    }
  ECUnlock(ped);
  return (ichOut);
}

/***************************************************************************\
* KBump
*
* If ichMaxSel references Kanji prefix, bump dch by cxChar to bypass prefix
* char. This routine is called only from DoKey in ea1.asm.
*
* History:
\***************************************************************************/

int KBump(
     PED ped,
    int dch)
{
  unsigned char *pch;

  pch = ECLock(ped) + ped->ichMaxSel;
  if (IsTwoByteCharPrefix(*pch))
      dch += ped->cxChar;
  ECUnlock(ped);

  return (dch);
}

/***************************************************************************\
* KCombine
*
* Kanji prefix byte was found in bytestream queue. Get next byte and combine.
*
* History:
\***************************************************************************/

int KCombine(
    HWND hwnd,
    int ch)
{
    MSG msg;
    int i;

    /*
     * Loop counter to avoid the infinite loop.
     */
    i = 10;

    while (!PeekMessage(&msg, hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) {
        if (--i == 0)
            return 0;
        Yield();
    }

    return (UINT)ch | ((UINT)msg.wParam << 8);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\editml.c ===
/***************************************************************************\
* editml.c - Edit controls rewrite. Version II of edit controls.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Multi-Line Support Routines
*
* Created: 24-Jul-88 davidds
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Number of lines to bump when reallocating index buffer
 */
#define LINEBUMP 32

/*
 * Code to catch bug #202678, please remove it get resolved.
 */
#define CHECK_LINE_NUMBER(iLine, ped)                                                       \
    if (((int)iLine < 0) || ((ICH)iLine >= ped->cLines)) {                                       \
        FRE_RIPMSG0(RIP_ERROR, "Line # is < 0 or >= ped->cLines, Please check this out!");  \
    }

/*
 * Used for ML scroll updates
 */
#define ML_REFRESH  0xffffffff

__inline void MLSanityCheck(PED ped)
{
    UNREFERENCED_PARAMETER(ped);    // For free build

    UserAssert(ped->cch >= ped->chLines[ped->cLines - 1]);
}


/***************************************************************************\
*
*  MLGetLineWidth()
*
*  Returns the max width in a line.  ECTabTheTextOut() ensures that max
*  width won't overflow.
*
\***************************************************************************/
UINT MLGetLineWidth(HDC hdc, LPSTR lpstr, int nCnt, PED ped)
{
    return(ECTabTheTextOut(hdc, 0, 0, 0, 0, lpstr, nCnt, 0, ped, 0, ECT_CALC, NULL));
}

/***************************************************************************\
*
*  MLSize()
*
*  Handles resizing of the edit control window and updating thereof.
*
*  Sets the edit field's formatting area given the passed in "client area".
*  We fudge it if it doesn't seem reasonable.
*
\***************************************************************************/

void   MLSize(PED ped, BOOL fRedraw)
{
    // Calculate the # of lines we can fit in our rectangle.
    ped->ichLinesOnScreen = (ped->rcFmt.bottom - ped->rcFmt.top) / ped->lineHeight;

    // Make the format rectangle height an integral number of lines
    ped->rcFmt.bottom = ped->rcFmt.top + ped->ichLinesOnScreen * ped->lineHeight;

    // Rebuild the line array
    if (ped->fWrap) {
        MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);
        MLUpdateiCaretLine(ped);
    } else {
        MLScroll(ped, TRUE,  ML_REFRESH, 0, fRedraw);
        MLScroll(ped, FALSE, ML_REFRESH, 0, fRedraw);
    }
}

/***************************************************************************\
* MLCalcXOffset AorW
*
* Calculates the horizontal offset (indent) required for centered
* and right justified lines.
*
* History:
*
* Not used if language pack loaded.
\***************************************************************************/

int MLCalcXOffset(
    PED ped,
    HDC hdc,
    int lineNumber)
{
    PSTR pText;
    ICH lineLength;
    ICH lineWidth;

    if (ped->format == ES_LEFT)
        return (0);

    lineLength = MLLine(ped, lineNumber);

    if (lineLength) {

        pText = ECLock(ped) + ped->chLines[lineNumber] * ped->cbChar;
        hdc = ECGetEditDC(ped, TRUE);
        lineWidth = MLGetLineWidth(hdc, pText, lineLength, ped);
        ECReleaseEditDC(ped, hdc, TRUE);
        ECUnlock(ped);
    } else {
        lineWidth = 0;
    }

    /*
     * If a SPACE or a TAB was eaten at the end of a line by MLBuildchLines
     * to prevent a delimiter appearing at the begining of a line, the
     * the following calculation will become negative causing this bug.
     * So, now, we take zero in such cases.
     * Fix for Bug #3566 --01/31/91-- SANKAR --
     */
    lineWidth = max(0, (int)(ped->rcFmt.right-ped->rcFmt.left-lineWidth));

    if (ped->format == ES_CENTER)
        return (lineWidth / 2);

    if (ped->format == ES_RIGHT) {

        /*
         * Subtract 1 so that the 1 pixel wide cursor will be in the visible
         * region on the very right side of the screen.
         */
        return max(0, (int)(lineWidth-1));
    }

    return 0;
}

/***************************************************************************\
* MLMoveSelection AorW
*
* Moves the selection character in the direction indicated. Assumes
* you are starting at a legal point, we decrement/increment the ich. Then,
* This decrements/increments it some more to get past CRLFs...
*
* History:
\***************************************************************************/

ICH MLMoveSelection(
    PED ped,
    ICH ich,
    BOOL fLeft)
{

    if (fLeft && ich > 0) {

        /*
         * Move left
         */
        ich = ECPrevIch( ped, NULL, ich );
        if (ich) {
            if (ped->fAnsi) {
                LPSTR pText;

                /*
                 * Check for CRLF or CRCRLF
                 */
                pText = ECLock(ped) + ich;

                /*
                 * Move before CRLF or CRCRLF
                 */
                if (*(WORD UNALIGNED *)(pText - 1) == 0x0A0D) {
                    ich--;
                    if (ich && *(pText - 2) == 0x0D)
                        ich--;
                }
                ECUnlock(ped);
            } else { // !fAnsi
                LPWSTR pwText;

                /*
                 * Check for CRLF or CRCRLF
                 */
                pwText = (LPWSTR)ECLock(ped) + ich;

                /*
                 * Move before CRLF or CRCRLF
                 */
                if (*(pwText - 1) == 0x0D && *pwText == 0x0A) {
                    ich--;
                    if (ich && *(pwText - 2) == 0x0D)
                        ich--;
                }
                ECUnlock(ped);
            }
        }
    } else if (!fLeft && ich < ped->cch) {
        /*
         * Move right.
         */
        ich = ECNextIch( ped, NULL, ich );
        if (ich < ped->cch) {
            if (ped->fAnsi) {
                LPSTR pText;
                pText = ECLock(ped) + ich;

                /*
                 * Move after CRLF
                 */
                if (*(WORD UNALIGNED *)(pText - 1) == 0x0A0D)
                    ich++;
                else {

                    /*
                     * Check for CRCRLF
                     */
                    if (ich && *(WORD UNALIGNED *)pText == 0x0A0D && *(pText - 1) == 0x0D)
                        ich += 2;
                }
                ECUnlock(ped);
            } else { // !fAnsi
                LPWSTR pwText;
                pwText = (LPWSTR)ECLock(ped) + ich;

                /*
                 * Move after CRLF
                 */
                if (*(pwText - 1) == 0x0D && *pwText == 0x0A)
                    ich++;
                else {

                    /*
                     * Check for CRCRLF
                     */
                    if (ich && *(pwText - 1) == 0x0D && *pwText == 0x0D &&
                            *(pwText + 1) == 0x0A)
                        ich += 2;
                }
                ECUnlock(ped);
            }
        }
    }
    return (ich);
}

/***************************************************************************\
* MLMoveSelectionRestricted AorW
*
* Moves the selection like MLMoveSelection, but also obeys limitations
* imposed by some languages such as Thai, where the cursor cannot stop
* between a character and it's attached vowel or tone marks.
*
* Only called if the language pack is loaded.
*
\***************************************************************************/

/***************************************************************************\
* MLMoveSelectionRestricted AorW
*
* Moves the selection like MLMoveSelection, but also obeys limitations
* imposed by some languages such as Thai, where the cursor cannot stop
* between a character and it's attached vowel or tone marks.
*
* Only called if the language pack is loaded.
*
\***************************************************************************/

ICH MLMoveSelectionRestricted(
    PED  ped,
    ICH  ich,
    BOOL fLeft)
{
    PSTR pText;
    HDC  hdc;
    ICH  ichResult;

    pText = ECLock(ped);
    hdc = ECGetEditDC(ped, TRUE);
    ichResult = ped->pLpkEditCallout->EditMoveSelection(ped, hdc, pText, ich, fLeft);
    ECReleaseEditDC(ped, hdc, TRUE);
    ECUnlock(ped);

    return ichResult;
}


/***************************************************************************\
* MLSetCaretPosition AorW
*
* If the window has the focus, find where the caret belongs and move
* it there.
*
* History:
\***************************************************************************/

void MLSetCaretPosition(
    PED ped,
    HDC hdc)
{
    POINT position;
    BOOL prevLine;
    int  x = -20000;
    int  y = -20000;

    /*
     * We will only position the caret if we have the focus since we don't want
     * to move the caret while another window could own it.
     */
    if (!ped->fFocus || !_IsWindowVisible(ped->pwnd))
         return;

    /*
     * Find the position of the caret
     */
    if (!ped->fCaretHidden &&
        ((ICH) ped->iCaretLine >= ped->ichScreenStart) &&
        ((ICH) ped->iCaretLine <  (ped->ichScreenStart + ped->ichLinesOnScreen))) {

        RECT    rcRealFmt;

        if (ped->f40Compat)
        {
            GetClientRect(ped->hwnd, &rcRealFmt);
            IntersectRect(&rcRealFmt, &rcRealFmt, &ped->rcFmt);
        } else {
            CopyRect(&rcRealFmt, &ped->rcFmt);
        }

        if (ped->cLines - 1 != ped->iCaretLine && ped->ichCaret == ped->chLines[ped->iCaretLine + 1]) {
            prevLine = TRUE;
        } else {
            prevLine = FALSE;
        }

        MLIchToXYPos(ped, hdc, ped->ichCaret, prevLine, &position);

        if ( (position.y >= rcRealFmt.top) &&
             (position.y <= rcRealFmt.bottom - ped->lineHeight)) {
            int xPos = position.x;
            int cxCaret = ECGetCaretWidth();

            if (ped->fWrap ||
                ((xPos > (rcRealFmt.left - cxCaret)) &&
                 (xPos <= rcRealFmt.right))) {
                // Make sure the caret is in the visible region if word
                // wrapping. This is so that the caret will be visible if the
                // line ends with a space.
                x = max(xPos, rcRealFmt.left);
                x = min(x, rcRealFmt.right - cxCaret);
                y = position.y;
            }
        }
    }

    if (ped->pLpkEditCallout) {
        NtUserSetCaretPos(x + ped->iCaretOffset, y);
    } else {
        NtUserSetCaretPos(x, y);
    }

    // FE_IME : MLSetCaretPosition -- ImmSetCompositionWindow(CFS_RECT)
    if (fpImmIsIME(THREAD_HKL())) {
        if (x != -20000 && y != -20000) {
            ECImmSetCompositionWindow(ped, x, y);
        }
    }
}

/***************************************************************************\
* MLLine
*
* Returns the length of the line (cch) given by lineNumber ignoring any
* CRLFs in the line.
*
* History:
\***************************************************************************/

ICH MLLine(
    PED ped,
    ICH lineNumber)
{
    ICH result;

    UserAssert(lineNumber < ped->cLines);

    if (lineNumber >= ped->cLines)
        return (0);

    if (lineNumber == ped->cLines - 1) {

        /*
         * Since we can't have a CRLF on the last line
         */
        return (ped->cch - ped->chLines[ped->cLines - 1]);
    } else {
        result = ped->chLines[lineNumber + 1] - ped->chLines[lineNumber];
        RIPMSG1(RIP_VERBOSE, "MLLine result=%d\n", result);

        /*
         * Now check for CRLF or CRCRLF at end of line
         */
        if (result > 1) {
            if (ped->fAnsi) {
                LPSTR pText;

                pText = ECLock(ped) + ped->chLines[lineNumber + 1] - 2;
                if (*(WORD UNALIGNED *)pText == 0x0A0D) {
                    result -= 2;
                    if (result && *(--pText) == 0x0D)
                        /*
                         * In case there was a CRCRLF
                         */
                        result--;
                }
            } else { // !fAnsi
                LPWSTR pwText;

                pwText = (LPWSTR)ECLock(ped) +
                        (ped->chLines[lineNumber + 1] - 2);
                if (*(DWORD UNALIGNED *)pwText == 0x000A000D) {
                    result = result - 2;
                    if (result && *(--pwText) == 0x0D)
                        /*
                         * In case there was a CRCRLF
                         */
                        result--;
                }

            }
            ECUnlock(ped);
        }
    }
    return (result);
}


/***************************************************************************\
* MLIchToLine AorW
*
* Returns the line number (starting from 0) which contains the given
* character index. If ich is -1, return the line the first char in the
* selection is on (the caret if no selection)
*
* History:
\***************************************************************************/

int MLIchToLine(
    PED ped,
    ICH ich)
{
    int iLo, iHi, iLine;

    iLo = 0;
    iHi = ped->cLines;

    if (ich == (ICH)-1)
        ich = ped->ichMinSel;

    while (iLo < iHi - 1) {
        iLine = max((iHi - iLo)/2, 1) + iLo;

        if (ped->chLines[iLine] > ich) {
            iHi = iLine;
        } else {
            iLo = iLine;
        }
    }

    CHECK_LINE_NUMBER(iLo, ped);

    return iLo;
}

/***************************************************************************\
* MLIchToYPos
*
* Given an ich, return its y coordinate with respect to the top line
* displayed in the window. If prevLine is TRUE and if the ich is at the
* beginning of the line, return the y coordinate of the
* previous line (if it is not a CRLF).
*
* Added for the LPK (3Dec96) - with an LPK installed, calculating X position is
* a far more processor intensive job. Where only the Y position is required
* this routine should be called instead of MLIchToXYPos.
*
* Called only when LPK installed.
*
\***************************************************************************/


/***************************************************************************\
* MLIchToYPos
*
* Given an ich, return its y coordinate with respect to the top line
* displayed in the window. If prevLine is TRUE and if the ich is at the
* beginning of the line, return the y coordinate of the
* previous line (if it is not a CRLF).
*
* Added for the LPK (3Dec96) - with an LPK installed, calculating X position is
* a far more processor intensive job. Where only the Y position is required
* this routine should be called instead of MLIchToXYPos.
*
* Called only when LPK installed.
*
\***************************************************************************/


INT MLIchToYPos(
    PED  ped,
    ICH  ich,
    BOOL prevLine)
{
    int  iline;
    int  yPosition;
    PSTR pText;

    /*
     * Determine what line the character is on
     */
    iline = MLIchToLine(ped, ich);

    /*
     * Calc. the yPosition now. Note that this may change by the height of one
     * char if the prevLine flag is set and the ICH is at the beginning of a
     * line.
     */
    yPosition = (iline - ped->ichScreenStart) * ped->lineHeight + ped->rcFmt.top;

    pText = ECLock(ped);
    if (prevLine && iline && (ich == ped->chLines[iline]) &&
            (!AWCOMPARECHAR(ped, pText + (ich - 2) * ped->cbChar, 0x0D) ||
             !AWCOMPARECHAR(ped, pText + (ich - 1) * ped->cbChar, 0x0A))) {

        /*
         * First char in the line. We want Y position of the previous
         * line if we aren't at the 0th line.
         */
        iline--;

        yPosition = yPosition - ped->lineHeight;
    }
    ECUnlock(ped);

    return yPosition;
}

/***************************************************************************\
* MLIchToXYPos
*
* Given an ich, return its x,y coordinates with respect to the top
* left character displayed in the window. Returns the coordinates of the top
* left position of the char. If prevLine is TRUE then if the ich is at the
* beginning of the line, we will return the coordinates to the right of the
* last char on the previous line (if it is not a CRLF).
*
* History:
\***************************************************************************/

void MLIchToXYPos(
    PED ped,
    HDC hdc,
    ICH ich,
    BOOL prevLine,
    LPPOINT ppt)
{
    int iline;
    ICH cch;
    int xPosition, yPosition;
    int xOffset;

    /*
     * For horizontal scroll displacement on left justified text and
     * for indent on centered or right justified text
     */
    PSTR pText, pTextStart, pLineStart;

    /*
     * Determine what line the character is on
     */
    iline = MLIchToLine(ped, ich);

    /*
     * Calc. the yPosition now. Note that this may change by the height of one
     * char if the prevLine flag is set and the ICH is at the beginning of a
     * line.
     */
    yPosition = (iline - ped->ichScreenStart) * ped->lineHeight + ped->rcFmt.top;

    /*
     * Now determine the xPosition of the character
     */
    pTextStart = ECLock(ped);

    if (prevLine && iline && (ich == ped->chLines[iline]) &&
            (!AWCOMPARECHAR(ped, pTextStart + (ich - 2) * ped->cbChar, 0x0D) ||
            !AWCOMPARECHAR(ped, pTextStart + (ich - 1) * ped->cbChar, 0x0A))) {

        /*
         * First char in the line. We want text extent upto end of the previous
         * line if we aren't at the 0th line.
         */
        iline--;

        yPosition = yPosition - ped->lineHeight;
        pLineStart = pTextStart + ped->chLines[iline] * ped->cbChar;

        /*
         * Note that we are taking the position in front of any CRLFs in the
         * text.
         */
        cch = MLLine(ped, iline);

    } else {

        pLineStart = pTextStart + ped->chLines[iline] * ped->cbChar;
        pText = pTextStart + ich * ped->cbChar;

        /*
         * Strip off CRLF or CRCRLF. Note that we may be pointing to a CR but in
         * which case we just want to strip off a single CR or 2 CRs.
         */

        /*
         * We want pText to point to the first CR at the end of the line if
         * there is one. Thus, we will get an xPosition to the right of the last
         * visible char on the line otherwise we will be to the left of
         * character ich.
         */

        /*
         * Check if we at the end of text
         */
        if (ich < ped->cch) {
            if (ped->fAnsi) {
                if (ich && *(WORD UNALIGNED *)(pText - 1) == 0x0A0D) {
                    pText--;
                    if (ich > 2 && *(pText - 1) == 0x0D)
                        pText--;
                }
            } else {
                LPWSTR pwText = (LPWSTR)pText;

                if (ich && *(DWORD UNALIGNED *)(pwText - 1) == 0x000A000D) {
                    pwText--;
                    if (ich > 2 && *(pwText - 1) == 0x0D)
                        pwText--;
                }
                pText = (LPSTR)pwText;
            }
        }

        if (pText < pLineStart)
            pText = pLineStart;

        cch = (ICH)(pText - pLineStart)/ped->cbChar;
    }

    /*
     * Find out how many pixels we indent the line for funny formats
     */
    if (ped->pLpkEditCallout) {
        /*
         * Must find position at start of character offset cch from start of line.
         * This depends on the layout and the reading order
         */
        xPosition = ped->pLpkEditCallout->EditIchToXY(
                          ped, hdc, pLineStart, MLLine(ped, iline), cch);
    } else {
        if (ped->format != ES_LEFT) {
            xOffset = MLCalcXOffset(ped, hdc, iline);
        } else {
            xOffset = -(int)ped->xOffset;
        }

        xPosition = ped->rcFmt.left + xOffset +
                MLGetLineWidth(hdc, pLineStart, cch, ped);
    }

    ECUnlock(ped);
    ppt->x = xPosition;
    ppt->y = yPosition;
    return ;
}

/***************************************************************************\
* MLMouseToIch AorW
*
* Returns the closest cch to where the mouse point is.  Also optionally
* returns lineindex in pline (So that we can tell if we are at the beginning
* of the line or end of the previous line.)
*
* History:
\***************************************************************************/

ICH MLMouseToIch(
    PED ped,
    HDC hdc,
    LPPOINT mousePt,
    LPICH pline)
{
    int xOffset;
    LPSTR pLineStart;
    int height = mousePt->y;
    int line; //WASINT
    int width = mousePt->x;
    ICH cch;
    ICH cLineLength;
    ICH cLineLengthNew;
    ICH cLineLengthHigh;
    ICH cLineLengthLow;
    ICH cLineLengthTemp;
    int textWidth;
    int iCurWidth;
    int lastHighWidth, lastLowWidth;

    /*
     * First determine which line the mouse is pointing to.
     */
    line = ped->ichScreenStart;
    if (height <= ped->rcFmt.top) {

        /*
         * Either return 0 (the very first line, or one line before the top line
         * on the screen. Note that these are signed mins and maxes since we
         * don't expect (or allow) more than 32K lines.
         */
        line = max(0, line-1);
    } else if (height >= ped->rcFmt.bottom) {

        /*
         * Are we below the last line displayed
         */
        line = min(line+(int)ped->ichLinesOnScreen, (int)(ped->cLines-1));
    } else {

        /*
         * We are somewhere on a line visible on screen
         */
        line = min(line + (int)((height - ped->rcFmt.top) / ped->lineHeight),
                (int)(ped->cLines - 1));
    }

    /*
     * Now determine what horizontal character the mouse is pointing to.
     */
    pLineStart = ECLock(ped) + ped->chLines[line] * ped->cbChar;
    cLineLength = MLLine(ped, line); /* Length is sans CRLF or CRCRLF */
    RIPMSG3(RIP_VERBOSE, "MLLine(ped=%x, line=%d) returned %d\n", ped, line, cLineLength);
    UserAssert((int)cLineLength >= 0);

    /*
     * If the language pack is loaded, visual and logical character order
     * may differ.
     */
    if (ped->pLpkEditCallout) {
        /*
         * Use the language pack to find the character nearest the cursor.
         */
        cch = ped->chLines[line] + ped->pLpkEditCallout->EditMouseToIch
            (ped, hdc, pLineStart, cLineLength, width);
    } else {
        /*
         * xOffset will be a negative value for center and right justified lines.
         * ie. We will just displace the lines left by the amount of indent for
         * right and center justification. Note that ped->xOffset will be 0 for
         * these lines since we don't support horizontal scrolling with them.
         */
        if (ped->format != ES_LEFT) {
            xOffset = MLCalcXOffset(ped, hdc, line);
        } else {
            /*
             * So that we handle a horizontally scrolled window for left justified
             * text.
             */
            xOffset = 0;
        }

        width = width - xOffset;

        /*
         * The code below is tricky... I depend on the fact that ped->xOffset is 0
         * for right and center justified lines
         */

        /*
         * Now find out how many chars fit in the given width
         */
        if (width >= ped->rcFmt.right) {

            /*
             * Return 1+last char in line or one plus the last char visible
             */
            cch = ECCchInWidth(ped, hdc, pLineStart, cLineLength,
                    ped->rcFmt.right - ped->rcFmt.left + ped->xOffset, TRUE);
            //
            // Consider DBCS in case of width >= ped->rcFmt.right
            //
            // Since ECCchInWidth and MLLineLength takes care of DBCS, we only need to
            // worry about if the last character is a double byte character or not.
            //
            // cch = ped->chLines[line] + min( ECNextIch(ped, pLineStart, cch), cLineLength);
            //
            // we need to adjust the position. LiZ -- 5/5/93
            if (ped->fAnsi && ped->fDBCS) {
                ICH cch2 = min(cch+1,cLineLength);
                if (ECAdjustIch(ped, pLineStart, cch2) != cch2) {
                    /* Displayed character on the right edge is DBCS */
                    cch = min(cch+2,cLineLength);
                } else {
                    cch = cch2;
                }
                cch += ped->chLines[line];
            } else {
                cch = ped->chLines[line] + min(cch + 1, cLineLength);
            }
        } else if (width <= ped->rcFmt.left + ped->aveCharWidth / 2) {

            /*
             * Return first char in line or one minus first char visible. Note that
             * ped->xOffset is 0 for right and centered text so we will just return
             * the first char in the string for them. (Allow a avecharwidth/2
             * positioning border so that the user can be a little off...
             */
            cch = ECCchInWidth(ped, hdc, pLineStart, cLineLength,
                    ped->xOffset, TRUE);
            if (cch)
                cch--;

            cch = ECAdjustIch( ped, pLineStart, cch );
            cch += ped->chLines[line];
        } else {

            if (cLineLength == 0) {
                cch = ped->chLines[line];
                goto edUnlock;
            }

            iCurWidth = width + ped->xOffset - ped->rcFmt.left;
            /*
             * If the user clicked past the end of the text, return the last character
             */
            lastHighWidth = MLGetLineWidth(hdc, pLineStart, cLineLength, ped);
            if (lastHighWidth <= iCurWidth) {
                cLineLengthNew = cLineLength;
                goto edAdjust;
            }
            /*
             * Now the mouse is somewhere on the visible portion of the text
             * remember cch contains the length of the line.
             */
            cLineLengthLow = 0;
            cLineLengthHigh = cLineLength + 1;
            lastLowWidth = 0;

            while (cLineLengthLow < cLineLengthHigh - 1) {

                cLineLengthNew = (cLineLengthHigh + cLineLengthLow) / 2;

                if (ped->fAnsi && ped->fDBCS) {
                    /*
                     * MLGetLineWidth returns meaningless value for truncated DBCS.
                     */
                    cLineLengthTemp = ECAdjustIch(ped, pLineStart, cLineLengthNew);
                    textWidth = MLGetLineWidth(hdc, pLineStart, cLineLengthTemp, ped);

                } else {
                    textWidth = MLGetLineWidth(hdc, pLineStart, cLineLengthNew, ped);
                }

                if (textWidth > iCurWidth) {
                    cLineLengthHigh = cLineLengthNew;
                    lastHighWidth = textWidth;
                } else {
                    cLineLengthLow = cLineLengthNew;
                    lastLowWidth = textWidth;
                }
            }

            /*
             * When the while ends, you can't know the exact desired position.
             * Try to see if the mouse pointer was on the farest half
             * of the char we got and if so, adjust cch.
             */
            if (cLineLengthLow == cLineLengthNew) {
                /*
                 * Need to compare with lastHighWidth
                 */
                if ((lastHighWidth - iCurWidth) < (iCurWidth - textWidth)) {
                    cLineLengthNew++;
                }
            } else {
                /*
                 * Need to compare with lastLowHigh
                 */
                if ((iCurWidth - lastLowWidth) < (textWidth - iCurWidth)) {
                    cLineLengthNew--;
                }
            }
edAdjust:
            cLineLength = ECAdjustIch( ped, pLineStart, cLineLengthNew );

            cch = ped->chLines[line] + cLineLength;
        }
    }
edUnlock:
    ECUnlock(ped);

    if (pline) {
        CHECK_LINE_NUMBER(line, ped);
        *pline = line;
    }
    return cch;
}

/***************************************************************************\
* MLChangeSelection AorW
*
* Changes the current selection to have the specified starting and
* ending values. Properly highlights the new selection and unhighlights
* anything deselected. If NewMinSel and NewMaxSel are out of order, we swap
* them. Doesn't update the caret position.
*
* History:
\***************************************************************************/

void MLChangeSelection(
    PED ped,
    HDC hdc,
    ICH ichNewMinSel,
    ICH ichNewMaxSel)
{

    ICH temp;
    ICH ichOldMinSel, ichOldMaxSel;

    if (ichNewMinSel > ichNewMaxSel) {
        temp = ichNewMinSel;
        ichNewMinSel = ichNewMaxSel;
        ichNewMaxSel = temp;
    }
    ichNewMinSel = min(ichNewMinSel, ped->cch);
    ichNewMaxSel = min(ichNewMaxSel, ped->cch);

    /*
     * Save the current selection
     */
    ichOldMinSel = ped->ichMinSel;
    ichOldMaxSel = ped->ichMaxSel;

    /*
     * Set new selection
     */
    ped->ichMinSel = ichNewMinSel;
    ped->ichMaxSel = ichNewMaxSel;

    /*
     * This finds the XOR of the old and new selection regions and redraws it.
     * There is nothing to repaint if we aren't visible or our selection
     * is hidden.
     */
    if (_IsWindowVisible(ped->pwnd) && (ped->fFocus || ped->fNoHideSel)) {

        BLOCK Blk[2];
        int i;

        if (ped->fFocus) {
            NtUserHideCaret(ped->hwnd);
        }

        Blk[0].StPos = ichOldMinSel;
        Blk[0].EndPos = ichOldMaxSel;
        Blk[1].StPos = ped->ichMinSel;
        Blk[1].EndPos = ped->ichMaxSel;

        if (ECCalcChangeSelection(ped, ichOldMinSel, ichOldMaxSel, (LPBLOCK)&Blk[0], (LPBLOCK)&Blk[1])) {

            /*
             * Paint both Blk[0] and Blk[1], if they exist
             */
            for (i = 0; i < 2; i++) {
                if (Blk[i].StPos != 0xFFFFFFFF)
                    MLDrawText(ped, hdc, Blk[i].StPos, Blk[i].EndPos, TRUE);
            }
        }

        /*
         * Update caret.
         */
        MLSetCaretPosition(ped, hdc);

        if (ped->fFocus) {
            NtUserShowCaret(ped->hwnd);
        }

    }
}


/**************************************************************************\
* MLUpdateiCaretLine AorW
*
* This updates the ped->iCaretLine field from the ped->ichCaret;
* Also, when the caret gets to the beginning of next line, pop it up to
* the end of current line when inserting text;
*
* History
* 4-18-91 Mikehar 31Merge
\**************************************************************************/

void MLUpdateiCaretLine(PED ped)
{
    PSTR pText;

    ped->iCaretLine = MLIchToLine(ped, ped->ichCaret);

    /*
     * If caret gets to beginning of next line, pop it up to end of current line
     * when inserting text.
     */
    pText = ECLock(ped) +
            (ped->ichCaret - 1) * ped->cbChar;
    if (ped->iCaretLine && ped->chLines[ped->iCaretLine] == ped->ichCaret &&
            (!AWCOMPARECHAR(ped, pText - ped->cbChar, 0x0D) ||
            !AWCOMPARECHAR(ped, pText, 0x0A)))
        ped->iCaretLine--;
    ECUnlock(ped);
}

/***************************************************************************\
* MLInsertText AorW
*
* Adds up to cchInsert characters from lpText to the ped starting at
* ichCaret. If the ped only allows a maximum number of characters, then we
* will only add that many characters to the ped. The number of characters
* actually added is return ed (could be 0). If we can't allocate the required
* space, we notify the parent with EN_ERRSPACE and no characters are added.
* We will rebuild the lines array as needed. fUserTyping is true if the
* input was the result of the user typing at the keyboard. This is so we can
* do some stuff faster since we will be getting only one or two chars of
* input.
*
* History:
* Created ???
* 4-18-91 Mikehar Win31 Merge
\***************************************************************************/

ICH MLInsertText(
    PED ped,
    LPSTR lpText,
    ICH cchInsert,
    BOOL fUserTyping)
{
    HDC hdc;
    ICH validCch = cchInsert;
    ICH oldCaret = ped->ichCaret;
    int oldCaretLine = ped->iCaretLine;
    BOOL fCRLF = FALSE;
    LONG ll, hl;
    POINT xyPosInitial;
    POINT xyPosFinal;
    HWND hwndSave = ped->hwnd;
    UNDO undo;
    ICH validCchTemp;

    xyPosInitial.x=0;
    xyPosInitial.y=0;
    xyPosFinal.x=0;
    xyPosFinal.y=0;

    if (validCch == 0)
        return 0;

    if (ped->cchTextMax <= ped->cch) {

        /*
         * When the max chars is reached already, notify parent
         * Fix for Bug #4183 -- 02/06/91 -- SANKAR --
         */
        ECNotifyParent(ped,EN_MAXTEXT);
        return 0;
    }

    /*
     * Limit the amount of text we add
     */
    validCch = min(validCch, ped->cchTextMax - ped->cch);

    /*
     * Make sure we don't split a CRLF in half
     */
    if (validCch) {
        if (ped->fAnsi) {
            if (*(WORD UNALIGNED *)(lpText + validCch - 1) == 0x0A0D)
                validCch--;
        } else {
            if (*(DWORD UNALIGNED *)(lpText + (validCch - 1) * ped->cbChar) == 0x000A000D)
                validCch--;
        }
    }
    if (!validCch) {
        /*
         * When the max chars is reached already, notify parent
         * Fix for Bug #4183 -- 02/06/91 -- SANKAR --
         */
        ECNotifyParent(ped,EN_MAXTEXT);
        return 0;
    }

    if (validCch == 2) {
        if (ped->fAnsi) {
            if (*(WORD UNALIGNED *)lpText == 0x0A0D)
                fCRLF = TRUE;
        } else {
            if (*(DWORD UNALIGNED *)lpText == 0x000A000D)
                fCRLF = TRUE;
        }
    }

    //
    // Save current undo state always, but clear it out only if !AutoVScroll
    //
    ECSaveUndo(Pundo(ped), (PUNDO)&undo, !ped->fAutoVScroll);

    hdc = ECGetEditDC(ped, FALSE);
    /*
     * We only need the y position. Since with an LPK loaded
     * calculating the x position is an intensive job, just
     * call MLIchToYPos.
     */
    if (ped->cch)
        if (ped->pLpkEditCallout)
            xyPosInitial.y = MLIchToYPos(ped, ped->cch-1, FALSE);
        else
            MLIchToXYPos(ped, hdc, ped->cch - 1, FALSE, &xyPosInitial);

    /*
     * Insert the text
     */
    validCchTemp = validCch;    // may not be needed, but just for precautions..
    if (!ECInsertText(ped, lpText, &validCchTemp)) {

        // Restore previous undo buffer if it was cleared
        if (!ped->fAutoVScroll)
            ECSaveUndo((PUNDO)&undo, Pundo(ped), FALSE);

        ECReleaseEditDC(ped, hdc, FALSE);
        ECNotifyParent(ped, EN_ERRSPACE);
        return (0);
    }

#if DBG
    if (validCch != validCchTemp) {
        /*
         * All characters in lpText has not been inserted to ped.
         * This could happen when cch is close to cchMax.
         * Better revisit this after NT5 ships.
         */
        RIPMSG2(RIP_WARNING, "MLInsertText: validCch is changed (%x -> %x) in ECInsertText.",
            validCch, validCchTemp);
    }
#endif

    /*
     * Note that ped->ichCaret is updated by ECInsertText
     */
    MLBuildchLines(ped, (ICH)oldCaretLine, (int)validCch, fCRLF?(BOOL)FALSE:fUserTyping, &ll, &hl);

    if (ped->cch)
       /*
        * We only need the y position. Since with an LPK loaded
        * calculating the x position is an intensive job, just
        * call MLIchToYPos.
        */
       if (ped->pLpkEditCallout)
           xyPosFinal.y = MLIchToYPos(ped, ped->cch-1, FALSE);
       else
           MLIchToXYPos(ped, hdc, ped->cch - 1, FALSE,&xyPosFinal);

    if (xyPosFinal.y < xyPosInitial.y && ((ICH)ped->ichScreenStart) + ped->ichLinesOnScreen >= ped->cLines - 1) {
        RECT rc;

        CopyRect((LPRECT)&rc, (LPRECT)&ped->rcFmt);
        rc.top = xyPosFinal.y + ped->lineHeight;
        if (ped->pLpkEditCallout) {
            int xFarOffset = ped->xOffset + ped->rcFmt.right - ped->rcFmt.left;
            // Include left or right margins in display unless clipped
            // by horizontal scrolling.
            if (ped->wLeftMargin) {
                if (!(   ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
                      && (   (!ped->fRtoLReading && ped->xOffset > 0)  // LTR and first char not fully in view
                          || ( ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) { //RTL and last char not fully in view
                    rc.left  -= ped->wLeftMargin;
                }
            }

            // Process right margin
            if (ped->wRightMargin) {
                if (!(   ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
                      && (   ( ped->fRtoLReading && ped->xOffset > 0)  // RTL and first char not fully in view
                          || (!ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) { // LTR and last char not fully in view
                    rc.right += ped->wRightMargin;
                }
            }
        }
        NtUserInvalidateRect(ped->hwnd, (LPRECT)&rc, TRUE);
    }

    if (!ped->fAutoVScroll) {
        if (ped->ichLinesOnScreen < ped->cLines) {
            MLUndo(ped);
            ECEmptyUndo(Pundo(ped));

            ECSaveUndo(&undo, Pundo(ped), FALSE);

            NtUserMessageBeep(0);
            ECReleaseEditDC(ped, hdc, FALSE);

            /*
             * When the max lines is reached already, notify parent
             * Fix for Bug #7586 -- 10/14/91 -- SANKAR --
             */
            ECNotifyParent(ped,EN_MAXTEXT);
            return (0);
        } else {
            ECEmptyUndo(&undo);
        }
    }

    if (fUserTyping && ped->fWrap) {
        //
        // To avoid oldCaret points intermediate of DBCS character,
        // adjust oldCaret position if necessary.
        //
        // !!!CR If MLBuildchLines() returns reasonable value ( and I think
        //       it does), we don't probably need this. Check this out later.
        //
        if (ped->fDBCS && ped->fAnsi) {
            oldCaret = ECAdjustIch(ped,
                                   ECLock(ped),
                                   min((ICH)LOWORD(ll),oldCaret));
            /* ECUnlock(ped); */
        } else { // same as original code
            oldCaret = min((ICH)LOWORD(ll), oldCaret);
        }
    }

    // Update ped->iCaretLine properly.
    MLUpdateiCaretLine(ped);

    ECNotifyParent(ped, EN_UPDATE);

    /*
     * Make sure window still exists.
     */
    if (!IsWindow(hwndSave))
        return 0;

    if (_IsWindowVisible(ped->pwnd)) {

        //
        // If the current font has negative A widths, we may have to start
        // drawing a few characters before the oldCaret position.
        //
        if (ped->wMaxNegAcharPos) {
            int iLine = MLIchToLine(ped, oldCaret);
            oldCaret = max( ((int)(oldCaret - ped->wMaxNegAcharPos)),
                          ((int)(ped->chLines[iLine])));
        }

        // Redraw to end of screen/text if CRLF or large insert
        if (fCRLF || !fUserTyping) {

            /*
             * Redraw to end of screen/text if crlf or large insert.
             */
            MLDrawText(ped, hdc, (fUserTyping ? oldCaret : 0), ped->cch, FALSE);
        } else
            MLDrawText(ped, hdc, oldCaret, max(ped->ichCaret, (ICH)hl), FALSE);
    }

    ECReleaseEditDC(ped, hdc, FALSE);

    /*
     * Make sure we can see the cursor
     */
    MLEnsureCaretVisible(ped);

    ped->fDirty = TRUE;

    ECNotifyParent(ped, EN_CHANGE);

    if (validCch < cchInsert)
        ECNotifyParent(ped, EN_MAXTEXT);

    if (validCch) {
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    /*
     * Make sure the window still exists.
     */
    if (!IsWindow(hwndSave))
        return 0;
    else
        return validCch;
}

/***************************************************************************\
*
*  MLReplaceSel() -
*
*  Replaces currently selected text with the passed in text, WITH UNDO
*  CAPABILITIES.
*
\***************************************************************************/
void   MLReplaceSel(PED ped, LPSTR lpText)
{
    ICH  cchText;

    //
    // Delete text, which will put it into the clean undo buffer.
    //
    ECEmptyUndo(Pundo(ped));
    MLDeleteText(ped);

    //
    // B#3356
    // Some apps do "clear" by selecting all of the text, then replacing
    // it with "", in which case MLInsertText() will return 0.  But that
    // doesn't mean failure...
    //
    if ( ped->fAnsi )
        cchText = strlen(lpText);
    else
        cchText = wcslen((LPWSTR)lpText);

    if (cchText ) {
        BOOL fFailed;
        UNDO undo;
        HWND hwndSave;

        //
        // B#1385,1427
        // Save undo buffer, but DO NOT CLEAR IT.  We want to restore it
        // if insertion fails due to OOM.
        //
        ECSaveUndo(Pundo(ped), (PUNDO)&undo, FALSE);

        hwndSave = ped->hwnd;
        fFailed = (BOOL) !MLInsertText(ped, lpText, cchText, FALSE);
        if (!IsWindow(hwndSave))
            return;

        if (fFailed) {
            //
            // UNDO the previous edit
            //
            ECSaveUndo((PUNDO)&undo, Pundo(ped), FALSE);
            MLUndo(ped);
        }
    }
}


/***************************************************************************\
* MLDeleteText AorW
*
* Deletes the characters between ichMin and ichMax. Returns the
* number of characters we deleted.
*
* History:
\***************************************************************************/

ICH MLDeleteText(
    PED ped)
{
    ICH minSel = ped->ichMinSel;
    ICH maxSel = ped->ichMaxSel;
    ICH cchDelete;
    HDC hdc;
    int minSelLine;
    int maxSelLine;
    POINT xyPos;
    RECT rc;
    BOOL fFastDelete = FALSE;
    LONG hl;
    INT  cchcount = 0;

    /*
     * Get what line the min selection is on so that we can start rebuilding the
     * text from there if we delete anything.
     */
    minSelLine = MLIchToLine(ped, minSel);
    maxSelLine = MLIchToLine(ped, maxSel);
    //
    // Calculate fFastDelete and cchcount
    //
    if (ped->fAnsi && ped->fDBCS) {
        if ((ped->fAutoVScroll) &&
            (minSelLine == maxSelLine) &&
            (ped->chLines[minSelLine] != minSel)  &&
            (ECNextIch(ped,NULL,minSel) == maxSel)) {

                fFastDelete = TRUE;
                cchcount = ((maxSel - minSel) == 1) ? 0 : -1;
        }
    } else if (((maxSel - minSel) == 1) && (minSelLine == maxSelLine) && (ped->chLines[minSelLine] != minSel)) {
            if (!ped->fAutoVScroll)
                fFastDelete = FALSE;
            else
                fFastDelete = TRUE;
    }
    if (!(cchDelete = ECDeleteText(ped)))
        return (0);

    /*
     * Start building lines at minsel line since caretline may be at the max sel
     * point.
     */
    if (fFastDelete) {
        //
        // cchcount is (-1) if it's a double byte character
        //
        MLShiftchLines(ped, minSelLine + 1, -2 + cchcount);
        MLBuildchLines(ped, minSelLine, 1, TRUE, NULL, &hl);
    } else {
        MLBuildchLines(ped, max(minSelLine-1,0), -(int)cchDelete, FALSE, NULL, NULL);
    }

    MLUpdateiCaretLine(ped);

    ECNotifyParent(ped, EN_UPDATE);

    if (_IsWindowVisible(ped->pwnd)) {

        /*
         * Now update the screen to reflect the deletion
         */
        hdc = ECGetEditDC(ped, FALSE);

        /*
         * Otherwise just redraw starting at the line we just entered
         */
        minSelLine = max(minSelLine-1,0);
        MLDrawText(ped, hdc, ped->chLines[minSelLine],
                   fFastDelete ? hl : ped->cch, FALSE);

        CopyRect(&rc, &ped->rcFmt);
        rc.left  -= ped->wLeftMargin;
        rc.right += ped->wRightMargin;

        if (ped->cch) {

            /*
             * Clear from end of text to end of window.
             *
             * We only need the y position. Since with an LPK loaded
             * calculating the x position is an intensive job, just
             * call MLIchToYPos.
             */
            if (ped->pLpkEditCallout)
                xyPos.y = MLIchToYPos(ped, ped->cch, FALSE);
            else
                MLIchToXYPos(ped, hdc, ped->cch, FALSE, &xyPos);
            rc.top = xyPos.y + ped->lineHeight;
        }

        NtUserInvalidateRect(ped->hwnd, &rc, TRUE);
        ECReleaseEditDC(ped, hdc, FALSE);

        MLEnsureCaretVisible(ped);
    }

    ped->fDirty = TRUE;

    ECNotifyParent(ped, EN_CHANGE);

    if (cchDelete)
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);

    return cchDelete;
}

/***************************************************************************\
* MLInsertchLine AorW
*
* Inserts the line iline and sets its starting character index to be
* ich. All the other line indices are moved up. Returns TRUE if successful
* else FALSE and notifies the parent that there was no memory.
*
* History:
\***************************************************************************/

BOOL MLInsertchLine(
    PED ped,
    ICH iLine,
    ICH ich,
    BOOL fUserTyping)
{
    DWORD dwSize;

    if (fUserTyping && iLine < ped->cLines) {
        ped->chLines[iLine] = ich;
        return (TRUE);
    }

    dwSize = (ped->cLines + 2) * sizeof(int);

    if (dwSize > UserLocalSize(ped->chLines)) {
        LPICH hResult;
        /*
         * Grow the line index buffer
         */
        dwSize += LINEBUMP * sizeof(int);
        hResult = (LPICH)UserLocalReAlloc(ped->chLines, dwSize, 0);

        if (!hResult) {
            ECNotifyParent(ped, EN_ERRSPACE);
            return FALSE;
        }
        ped->chLines = hResult;
    }

    /*
     * Move indices starting at iLine up
     */
    if (ped->cLines != iLine)
        RtlMoveMemory(&ped->chLines[iLine + 1], &ped->chLines[iLine],
                (ped->cLines - iLine) * sizeof(int));
    ped->cLines++;

    ped->chLines[iLine] = ich;
    return TRUE;
}

/***************************************************************************\
* MLShiftchLines AorW
*
* Move the starting index of all lines iLine or greater by delta
* bytes.
*
* History:
\***************************************************************************/

void MLShiftchLines(
    PED ped,
    ICH iLine,
    int delta)
{
    if (iLine >= ped->cLines)
        return;

    /*
     * Just add delta to the starting point of each line after iLine
     */
    for (; iLine < ped->cLines; iLine++)
        ped->chLines[iLine] += delta;
}

/***************************************************************************\
* MLBuildchLines AorW
*
* Rebuilds the start of line array (ped->chLines) starting at line
* number ichLine.
*
* History:
\***************************************************************************/

void MLBuildchLines(
    PED ped,
    ICH iLine,
    int cchDelta, // Number of chars added or deleted
    BOOL fUserTyping,
    PLONG pll,
    PLONG phl)
{
    PSTR ptext; /* Starting address of the text */

    /*
     * We keep these ICH's so that we can Unlock ped->hText when we have to grow
     * the chlines array. With large text handles, it becomes a problem if we
     * have a locked block in the way.
     */
    ICH ichLineStart;
    ICH ichLineEnd;
    ICH ichLineEndBeforeCRLF;
    ICH ichCRLF;

    ICH cch;
    HDC hdc;

    BOOL fLineBroken = FALSE; /* Initially, no new line breaks are made */
    ICH minCchBreak;
    ICH maxCchBreak;
    BOOL fOnDelimiter;

    if (!ped->cch) {
        ped->maxPixelWidth = 0;
        ped->xOffset = 0;
        ped->ichScreenStart = 0;
        ped->cLines = 1;

        if (pll)
            *pll = 0;
        if (phl)
            *phl = 0;

        goto UpdateScroll;
    }

    if (fUserTyping && cchDelta)
        MLShiftchLines(ped, iLine + 1, cchDelta);

    hdc = ECGetEditDC(ped, TRUE);

    if (!iLine && !cchDelta && !fUserTyping) {

        /*
         * Reset maxpixelwidth only if we will be running through the whole
         * text. Better too long than too short.
         */
        ped->maxPixelWidth = 0;

        /*
         * Reset number of lines in text since we will be running through all
         * the text anyway...
         */
        ped->cLines = 1;
    }

    /*
     * Set min and max line built to be the starting line
     */
    minCchBreak = maxCchBreak = (cchDelta ? ped->chLines[iLine] : 0);

    ptext = ECLock(ped);

    ichCRLF = ichLineStart = ped->chLines[iLine];

    while (ichLineStart < ped->cch) {
        if (ichLineStart >= ichCRLF) {
            ichCRLF = ichLineStart;

            /*
             * Move ichCRLF ahead to either the first CR or to the end of text.
             */
            if (ped->fAnsi) {
                while (ichCRLF < ped->cch) {
                    if (*(ptext + ichCRLF) == 0x0D) {
                        if (*(ptext + ichCRLF + 1) == 0x0A ||
                                *(WORD UNALIGNED *)(ptext + ichCRLF + 1) == 0x0A0D)
                            break;
                    }
                    ichCRLF++;
                }
            } else {
                LPWSTR pwtext = (LPWSTR)ptext;

                while (ichCRLF < ped->cch) {
                    if (*(pwtext + ichCRLF) == 0x0D) {
                        if (*(pwtext + ichCRLF + 1) == 0x0A ||
                                *(DWORD UNALIGNED *)(pwtext + ichCRLF + 1) == 0x000A000D)
                            break;
                    }
                    ichCRLF++;
                }
            }
        }


        if (!ped->fWrap) {

            UINT  LineWidth;
            /*
             * If we are not word wrapping, line breaks are signified by CRLF.
             */

            //
            // If we cut off the line at MAXLINELENGTH, we should
            // adjust ichLineEnd.
            //
            if ((ichCRLF - ichLineStart) <= MAXLINELENGTH) {
                ichLineEnd = ichCRLF;
            } else {
                ichLineEnd = ichLineStart + MAXLINELENGTH;
                if (ped->fAnsi && ped->fDBCS) {
                    ichLineEnd = ECAdjustIch( ped, (PSTR)ptext, ichLineEnd);
                }
            }

            /*
             * We will keep track of what the longest line is for the horizontal
             * scroll bar thumb positioning.
             */
            if (ped->pLpkEditCallout) {
                LineWidth = ped->pLpkEditCallout->EditGetLineWidth(
                    ped, hdc, ptext + ichLineStart*ped->cbChar,
                    ichLineEnd - ichLineStart);
            } else {
                LineWidth = MLGetLineWidth(hdc, ptext + ichLineStart * ped->cbChar,
                                            ichLineEnd - ichLineStart,
                                            ped);
            }
            ped->maxPixelWidth = max(ped->maxPixelWidth,(int)LineWidth);

        } else {

            /*
             * Check if the width of the edit control is non-zero;
             * a part of the fix for Bug #7402 -- SANKAR -- 01/21/91 --
             */
            if(ped->rcFmt.right > ped->rcFmt.left) {

                /*
                 * Find the end of the line based solely on text extents
                 */
                if (ped->pLpkEditCallout) {
                    ichLineEnd = ichLineStart +
                        ped->pLpkEditCallout->EditCchInWidth(
                            ped, hdc, ptext + ped->cbChar*ichLineStart,
                            ichCRLF - ichLineStart,
                            ped->rcFmt.right - ped->rcFmt.left);
                } else {
                    if (ped->fAnsi) {
                        ichLineEnd = ichLineStart +
                                 ECCchInWidth(ped, hdc,
                                              ptext + ichLineStart,
                                              ichCRLF - ichLineStart,
                                              ped->rcFmt.right - ped->rcFmt.left,
                                              TRUE);
                    } else {
                        ichLineEnd = ichLineStart +
                                 ECCchInWidth(ped, hdc,
                                              (LPSTR)((LPWSTR)ptext + ichLineStart),
                                              ichCRLF - ichLineStart,
                                              ped->rcFmt.right - ped->rcFmt.left,
                                              TRUE);
                    }
                }
            } else {
                ichLineEnd = ichLineStart;
            }

            if (ichLineEnd == ichLineStart && ichCRLF - ichLineStart) {

                /*
                 * Maintain a minimum of one char per line
                 */
                //
                // Since it might be a double byte char, so calling ECNextIch.
                //
                ichLineEnd = ECNextIch(ped, NULL, ichLineEnd);
            }

            /*
             * Now starting from ichLineEnd, if we are not at a hard line break,
             * then if we are not at a space AND the char before us is
             * not a space,(OR if we are at a CR) we will look word left for the
             * start of the word to break at.
             * This change was done for TWO reasons:
             * 1. If we are on a delimiter, no need to look word left to break at.
             * 2. If the previous char is a delimter, we can break at current char.
             * Change done by -- SANKAR --01/31/91--
             */
            if (ichLineEnd != ichCRLF) {
                if(ped->lpfnNextWord) {
                     fOnDelimiter = (CALLWORDBREAKPROC(*ped->lpfnNextWord, ptext,
                            ichLineEnd, ped->cch, WB_ISDELIMITER) ||
                            CALLWORDBREAKPROC(*ped->lpfnNextWord, ptext, ichLineEnd - 1,
                            ped->cch, WB_ISDELIMITER));
                //
                // This change was done for FOUR reasons:
                //
                // 1. If we are on a delimiter, no need to look word left to break at.
                // 2. If we are on a double byte character, we can break at current char.
                // 3. If the previous char is a delimter, we can break at current char.
                // 4. If the previous char is a double byte character, we can break at current char.
                //
                } else if (ped->fAnsi) {
                    fOnDelimiter = (ISDELIMETERA(*(ptext + ichLineEnd)) ||
                                    ECIsDBCSLeadByte(ped, *(ptext + ichLineEnd)));
                    if (!fOnDelimiter) {
                        PSTR pPrev = ECAnsiPrev(ped,ptext,ptext+ichLineEnd);

                        fOnDelimiter = ISDELIMETERA(*pPrev) ||
                                       ECIsDBCSLeadByte(ped,*pPrev);
                    }
                } else { // Unicode
                    fOnDelimiter = (ISDELIMETERW(*((LPWSTR)ptext + ichLineEnd))     ||
                                    UserIsFullWidth(CP_ACP,*((LPWSTR)ptext + ichLineEnd))      ||
                                    ISDELIMETERW(*((LPWSTR)ptext + ichLineEnd - 1)) ||
                                    UserIsFullWidth(CP_ACP,*((LPWSTR)ptext + ichLineEnd - 1)));
                }
                if (!fOnDelimiter ||
                    (ped->fAnsi && *(ptext + ichLineEnd) == 0x0D) ||
                    (!ped->fAnsi && *((LPWSTR)ptext + ichLineEnd) == 0x0D)) {

                    if (ped->lpfnNextWord != NULL) {
                        cch = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)ptext, ichLineEnd,
                                ped->cch, WB_LEFT);
                    } else {
                        ped->fCalcLines = TRUE;
                        ECWord(ped, ichLineEnd, TRUE, &cch, NULL);
                        ped->fCalcLines = FALSE;
                    }
                    if (cch > ichLineStart) {
                        ichLineEnd = cch;
                    }

                    /*
                     * Now, if the above test fails, it means the word left goes
                     * back before the start of the line ie. a word is longer
                     * than a line on the screen. So, we just fit as much of
                     * the word on the line as possible. Thus, we use the
                     * pLineEnd we calculated solely on width at the beginning
                     * of this else block...
                     */
                }
            }
        }
#if 0
        if (!ISDELIMETERAW((*(ptext + (ichLineEnd - 1)*ped->cbChar))) && ISDELIMETERAW((*(ptext + ichLineEnd*ped->cbChar)))) #ERROR

            if ((*(ptext + ichLineEnd - 1) != ' ' &&
                        *(ptext + ichLineEnd - 1) != VK_TAB) &&
                        (*(ptext + ichLineEnd) == ' ' ||
                        *(ptext + ichLineEnd) == VK_TAB))
#endif
        if (AWCOMPARECHAR(ped,ptext + ichLineEnd * ped->cbChar, ' ') ||
                AWCOMPARECHAR(ped,ptext + ichLineEnd * ped->cbChar, VK_TAB)) {
            /*
             * Swallow the space at the end of a line.
             */
            if (ichLineEnd < ped->cch) {
                ichLineEnd++;
            }
        }

        /*
         * Skip over crlf or crcrlf if it exists. Thus, ichLineEnd is the first
         * character in the next line.
         */
        ichLineEndBeforeCRLF = ichLineEnd;

        if (ped->fAnsi) {
            if (ichLineEnd < ped->cch && *(ptext + ichLineEnd) == 0x0D)
                ichLineEnd += (ichLineEnd + 1 == ped->cch) ? 1 : 2;

            /*
             * Skip over CRCRLF
             */
            if (ichLineEnd < ped->cch && *(ptext + ichLineEnd) == 0x0A)
                ichLineEnd++;
            UserAssert(ichLineEnd <= ped->cch);
        } else {
            if (ichLineEnd < ped->cch && *(((LPWSTR)ptext) + ichLineEnd) == 0x0D)
                ichLineEnd += (ichLineEnd + 1 == ped->cch) ? 1 : 2;

            /*
             * Skip over CRCRLF
             */
            if (ichLineEnd < ped->cch && *(((LPWSTR)ptext) + ichLineEnd) == 0x0A) {
                ichLineEnd++;
                RIPMSG0(RIP_VERBOSE, "Skip over CRCRLF\n");
            }
            UserAssert(ichLineEnd <= ped->cch);
        }

        /*
         * Now, increment iLine, allocate space for the next line, and set its
         * starting point
         */
        iLine++;

        if (!fUserTyping || (iLine > ped->cLines - 1) || (ped->chLines[iLine] != ichLineEnd)) {

            /*
             * The line break occured in a different place than before.
             */
            if (!fLineBroken) {

                /*
                 * Since we haven't broken a line before, just set the min
                 * break line.
                 */
                fLineBroken = TRUE;
                if (ichLineEndBeforeCRLF == ichLineEnd)
                    minCchBreak = maxCchBreak = (ichLineEnd ? ichLineEnd - 1 : 0);
                else
                    minCchBreak = maxCchBreak = ichLineEndBeforeCRLF;
            }
            maxCchBreak = max(maxCchBreak, ichLineEnd);

            ECUnlock(ped);

            /*
             * Now insert the new line into the array
             */
            if (!MLInsertchLine(ped, iLine, ichLineEnd, (BOOL)(cchDelta != 0)))
                goto EndUp;

            ptext = ECLock(ped);
        } else {
            maxCchBreak = ped->chLines[iLine];

            /*
             * Quick escape
             */
            goto UnlockAndEndUp;
        }

        ichLineStart = ichLineEnd;
    } /* end while (ichLineStart < ped->cch) */


    if (iLine != ped->cLines) {
        RIPMSG1(RIP_VERBOSE, "chLines[%d] is being cleared.\n", iLine);
        ped->cLines = iLine;
        ped->chLines[ped->cLines] = 0;
    }

    /*
     * Note that we incremented iLine towards the end of the while loop so, the
     * index, iLine, is actually equal to the line count
     */
    if (ped->cch && AWCOMPARECHAR(ped, ptext + (ped->cch - 1)*ped->cbChar, 0x0A) &&
            ped->chLines[ped->cLines - 1] < ped->cch) {

        /*
         * Make sure last line has no crlf in it
         */
        if (!fLineBroken) {

            /*
             * Since we haven't broken a line before, just set the min break
             * line.
             */
            fLineBroken = TRUE;
            minCchBreak = ped->cch - 1;
        }
        maxCchBreak = max(maxCchBreak, ichLineEnd);
        ECUnlock(ped);
        MLInsertchLine(ped, iLine, ped->cch, FALSE);
        MLSanityCheck(ped);
    } else
UnlockAndEndUp:
        ECUnlock(ped);

EndUp:
    ECReleaseEditDC(ped, hdc, TRUE);
    if (pll)
        *pll = minCchBreak;
    if (phl)
        *phl = maxCchBreak;

UpdateScroll:
    MLScroll(ped, FALSE, ML_REFRESH, 0, TRUE);
    MLScroll(ped, TRUE,  ML_REFRESH, 0, TRUE);

    MLSanityCheck(ped);

    return;
}

/***************************************************************************\
*
*  MLPaint()
*
*  Response to WM_PAINT message.
*
\***************************************************************************/
void   MLPaint(PED ped, HDC hdc, LPRECT lprc)
{
    HFONT       hOldFont;
    ICH         imin;
    ICH         imax;

    //
    // Do we need to draw the border ourself for old apps?
    //
    if (ped->fFlatBorder)
    {
        RECT    rcT;

        _GetClientRect(ped->pwnd, &rcT);
        if (TestWF(ped->pwnd, WFSIZEBOX))
        {
            InflateRect(&rcT, SYSMET(CXBORDER) - SYSMET(CXFRAME),
                SYSMET(CYBORDER) - SYSMET(CYFRAME));
        }
        DrawFrame(hdc, &rcT, 1, DF_WINDOWFRAME);
    }

    ECSetEditClip(ped, hdc, (BOOL) (ped->xOffset == 0));

    if (ped->hFont)
        hOldFont = SelectObject(hdc, ped->hFont);

    if (!lprc) {
        // no partial rect given -- draw all text
        imin = 0;
        imax = ped->cch;
    } else {
        // only draw pertinent text
        imin = (ICH) MLMouseToIch(ped, hdc, ((LPPOINT) &lprc->left), NULL) - 1;
        if (imin == -1)
            imin = 0;

        // HACK_ALERT:
        // The 3 is required here because, MLMouseToIch() returns decremented
        // value; We must fix MLMouseToIch.
        imax = (ICH) MLMouseToIch(ped, hdc, ((LPPOINT) &lprc->right), NULL) + 3;
        if (imax > ped->cch)
            imax = ped->cch;
    }

    MLDrawText(ped, hdc, imin, imax, FALSE);

    if (ped->hFont)
        SelectObject(hdc, hOldFont);
}

/***************************************************************************\
* MLKeyDown AorW
*
* Handles cursor movement and other VIRT KEY stuff. keyMods allows
* us to make MLKeyDownHandler calls and specify if the modifier keys (shift
* and control) are up or down. If keyMods == 0, we get the keyboard state
* using GetKeyState(VK_SHIFT) etc. Otherwise, the bits in keyMods define the
* state of the shift and control keys.
*
* History:
\***************************************************************************/

void MLKeyDown(
    PED ped,
    UINT virtKeyCode,
    int keyMods)
{
    HDC hdc;
    BOOL prevLine;
    POINT mousePt;
    int defaultDlgId;
    int iScrollAmt;

    /*
     * Variables we will use for redrawing the updated text
     */

    /*
     * new selection is specified by newMinSel, newMaxSel
     */
    ICH newMaxSel = ped->ichMaxSel;
    ICH newMinSel = ped->ichMinSel;

    /*
     * Flags for drawing the updated text
     */
    BOOL changeSelection = FALSE;

    /*
     * Comparisons we do often
     */
    BOOL MinEqMax = (newMaxSel == newMinSel);
    BOOL MinEqCar = (ped->ichCaret == newMinSel);
    BOOL MaxEqCar = (ped->ichCaret == newMaxSel);

    /*
     * State of shift and control keys.
     */
    int scState;

    if (ped->fMouseDown) {

        /*
         * If we are in the middle of a mousedown command, don't do anything.
         */
        return ;
    }

    scState = ECGetModKeys(keyMods);

    switch (virtKeyCode) {
    case VK_ESCAPE:
        if (ped->fInDialogBox) {

            /*
             * This condition is removed because, if the dialogbox does not
             * have a CANCEL button and if ESC is hit when focus is on a
             * ML edit control the dialogbox must close whether it has cancel
             * button or not to be consistent with SL edit control;
             * DefDlgProc takes care of the disabled CANCEL button case.
             * Fix for Bug #4123 -- 02/07/91 -- SANKAR --
             */
#if 0
            if (GetDlgItem(ped->hwndParent, IDCANCEL))
#endif

                /*
                 * User hit ESC...Send a close message (which in turn sends a
                 * cancelID to the app in DefDialogProc...
                 */
                PostMessage(ped->hwndParent, WM_CLOSE, 0, 0L);
        }
        return ;

    case VK_RETURN:
        if (ped->fInDialogBox) {

            /*
             * If this multiline edit control is in a dialog box, then we want
             * the RETURN key to be sent to the default dialog button (if there
             * is one). CTRL-RETURN will insert a RETURN into the text. Note
             * that CTRL-RETURN automatically translates into a linefeed (0x0A)
             * and in the MLCharHandler, we handle this as if a return was
             * entered.
             */
            if (scState != CTRLDOWN) {

                if (TestWF(ped->pwnd, EFWANTRETURN)) {

                    /*
                     * This edit control wants cr to be inserted so break out of
                     * case.
                     */
                    return ;
                }

                defaultDlgId = (int)(DWORD)LOWORD(SendMessage(ped->hwndParent,
                        DM_GETDEFID, 0, 0L));
                if (defaultDlgId) {
                    HWND hwnd = GetDlgItem(ped->hwndParent, defaultDlgId);
                    if (hwnd) {
                        SendMessage(ped->hwndParent, WM_NEXTDLGCTL, (WPARAM)hwnd, 1L);
                        if (!ped->fFocus)
                            PostMessage(hwnd, WM_KEYDOWN, VK_RETURN, 0L);
                    }
                }
            }

            return ;
        }
        break;

    case VK_TAB:

        /*
         * If this multiline edit control is in a dialog box, then we want the
         * TAB key to take you to the next control, shift TAB to take you to the
         * previous control. We always want CTRL-TAB to insert a tab into the
         * edit control regardless of weather or not we're in a dialog box.
         */
        if (scState == CTRLDOWN)
            MLChar(ped, virtKeyCode, keyMods);
        else if (ped->fInDialogBox)
            SendMessage(ped->hwndParent, WM_NEXTDLGCTL, scState == SHFTDOWN, 0L);

        return ;

    case VK_LEFT:
        //
        // If the caret isn't at the beginning, we can move left
        //
        if (ped->ichCaret) {
            // Get new caret pos.
            if (scState & CTRLDOWN) {
                // Move caret word left
                ECWord(ped, ped->ichCaret, TRUE, &ped->ichCaret, NULL);
            } else {
                if (ped->pLpkEditCallout) {
                    ped->ichCaret = MLMoveSelectionRestricted(ped, ped->ichCaret, TRUE);
                } else {
                    // Move caret char left
                    ped->ichCaret = MLMoveSelection(ped, ped->ichCaret, TRUE);
                }
            }

            // Get new selection
            if (scState & SHFTDOWN) {
                if (MaxEqCar && !MinEqMax) {
                    // Reduce selection
                    newMaxSel = ped->ichCaret;

                    UserAssert(newMinSel == ped->ichMinSel);
                } else {
                    // Extend selection
                    newMinSel = ped->ichCaret;
                }
            } else {
                // Clear selection
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } else {
            //
            // If the user tries to move left and we are at the 0th
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) {
                changeSelection = TRUE;
                newMaxSel = newMinSel = ped->ichCaret;
            }
        }
        break;

    case VK_RIGHT:
        //
        // If the caret isn't at the end, we can move right.
        //
        if (ped->ichCaret < ped->cch) {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) {
                // Move caret word right
                ECWord(ped, ped->ichCaret, FALSE, NULL, &ped->ichCaret);
            } else {
                // Move caret char right
                if (ped->pLpkEditCallout) {
                    ped->ichCaret = MLMoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } else {
                    ped->ichCaret = MLMoveSelection(ped, ped->ichCaret, FALSE);
                }
            }

            //
            // Get new selection.
            //
            if (scState & SHFTDOWN) {
                if (MinEqCar && !MinEqMax) {
                    // Reduce selection
                    newMinSel = ped->ichCaret;

                    UserAssert(newMaxSel == ped->ichMaxSel);
                } else {
                    // Extend selection
                    newMaxSel = ped->ichCaret;
                }
            } else {
                // Clear selection
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } else {
            //
            // If the user tries to move right and we are at the last
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) {
                newMaxSel = newMinSel = ped->ichCaret;
                changeSelection = TRUE;
            }
        }
        break;

    case VK_UP:
    case VK_DOWN:
        if (ped->cLines - 1 != ped->iCaretLine &&
                ped->ichCaret == ped->chLines[ped->iCaretLine + 1])
            prevLine = TRUE;
        else
            prevLine = FALSE;

        hdc = ECGetEditDC(ped, TRUE);
        MLIchToXYPos(ped, hdc, ped->ichCaret, prevLine, &mousePt);
        ECReleaseEditDC(ped, hdc, TRUE);
        mousePt.y += 1 + (virtKeyCode == VK_UP ? -ped->lineHeight : ped->lineHeight);

        if (!(scState & CTRLDOWN)) {
            //
            // Send fake mouse messages to handle this
            // If VK_SHIFT is down, extend selection & move caret up/down
            // 1 line.  Otherwise, clear selection & move caret.
            //
            MLMouseMotion(ped, WM_LBUTTONDOWN,
                            !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
            MLMouseMotion(ped, WM_LBUTTONUP,
                            !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
        }
        break;

    case VK_HOME:
        //
        // Update caret.
        //
        if (scState & CTRLDOWN) {
            // Move caret to beginning of text.
            ped->ichCaret = 0;
        } else {
            // Move caret to beginning of line.
            ped->ichCaret = ped->chLines[ped->iCaretLine];
        }

        //
        // Update selection.
        //
        newMinSel = ped->ichCaret;

        if (scState & SHFTDOWN) {
            if (MaxEqCar && !MinEqMax) {
                if (scState & CTRLDOWN)
                    newMaxSel = ped->ichMinSel;
                else {
                    newMinSel = ped->ichMinSel;
                    newMaxSel = ped->ichCaret;
                }
            }
        } else {
            // Clear selection
            newMaxSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    case VK_END:
        //
        // Update caret.
        //
        if (scState & CTRLDOWN) {
            // Move caret to end of text.
            ped->ichCaret = ped->cch;
        } else {
            // Move caret to end of line.
            ped->ichCaret = ped->chLines[ped->iCaretLine] +
                MLLine(ped, ped->iCaretLine);
        }

        // Update selection.
        newMaxSel = ped->ichCaret;

        if (scState & SHFTDOWN) {
            if (MinEqCar && !MinEqMax) {
                // Reduce selection
                if (scState & CTRLDOWN) {
                    newMinSel = ped->ichMaxSel;
                } else {
                    newMinSel = ped->ichCaret;
                    newMaxSel = ped->ichMaxSel;
                }
            }
        } else {
            // Clear selection
            newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    // FE_IME // EC_INSERT_COMPOSITION_CHAR : MLKeyDown() : VK_HANJA support
    case VK_HANJA:
        if ( HanjaKeyHandler( ped ) ) {
            changeSelection = TRUE;
            newMinSel = ped->ichCaret;
            newMaxSel = ped->ichCaret + (ped->fAnsi ? 2 : 1);
        }
        break;

    case VK_PRIOR:
    case VK_NEXT:
        if (!(scState & CTRLDOWN)) {
            /*
             * Vertical scroll by one visual screen
             */
            hdc = ECGetEditDC(ped, TRUE);
            MLIchToXYPos(ped, hdc, ped->ichCaret, FALSE, &mousePt);
            ECReleaseEditDC(ped, hdc, TRUE);
            mousePt.y += 1;

            SendMessage(ped->hwnd, WM_VSCROLL, virtKeyCode == VK_PRIOR ? SB_PAGEUP : SB_PAGEDOWN, 0L);

            /*
             * Move the cursor there
             */
            MLMouseMotion(ped, WM_LBUTTONDOWN, !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
            MLMouseMotion(ped, WM_LBUTTONUP,   !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);

        } else {
            /*
             * Horizontal scroll by one screenful minus one char
             */
            iScrollAmt = ((ped->rcFmt.right - ped->rcFmt.left) / ped->aveCharWidth) - 1;
            if (virtKeyCode == VK_PRIOR)
                iScrollAmt *= -1; /* For previous page */

            SendMessage(ped->hwnd, WM_HSCROLL, MAKELONG(EM_LINESCROLL, iScrollAmt), 0);
            break;
        }
        break;

    case VK_DELETE:
        if (ped->fReadOnly)
            break;

        switch (scState) {
        case NONEDOWN:

            /*
             * Clear selection. If no selection, delete (clear) character
             * right
             */
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) {

                /*
                 * Move cursor forwards and send a backspace message...
                 */
                if (ped->pLpkEditCallout) {
                    ped->ichMinSel = ped->ichCaret;
                    ped->ichMaxSel = MLMoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } else {
                    ped->ichCaret = MLMoveSelection(ped, ped->ichCaret, FALSE);
                    ped->ichMaxSel = ped->ichMinSel = ped->ichCaret;
                }

                goto DeleteAnotherChar;
            }
            break;

        case SHFTDOWN:

            /*
             * CUT selection ie. remove and copy to clipboard, or if no
             * selection, delete (clear) character left.
             */
            if (ped->ichMinSel == ped->ichMaxSel) {
                goto DeleteAnotherChar;
            } else {
                SendMessage(ped->hwnd, WM_CUT, (UINT)0, 0L);
            }

            break;

        case CTRLDOWN:

            /*
             * Clear selection, or delete to end of line if no selection
             */
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) {
                ped->ichMaxSel = ped->ichCaret = ped->chLines[ped->iCaretLine] +
                                                 MLLine(ped, ped->iCaretLine);
            }
            break;
        }

        if (!(scState & SHFTDOWN) && (ped->ichMinSel != ped->ichMaxSel)) {

DeleteAnotherChar:
            if (GETAPPVER() >= VER40) {
                MLChar(ped, VK_BACK, 0);
            } else {
                SendMessageWorker(ped->pwnd, WM_CHAR, VK_BACK, 0, ped->fAnsi);
            }
        }

        /*
         * No need to update text or selection since BACKSPACE message does it
         * for us.
         */
        break;

    case VK_INSERT:
        if (scState == CTRLDOWN || scState == SHFTDOWN) {

            /*
             * if CTRLDOWN Copy current selection to clipboard
             */

            /*
             * if SHFTDOWN Paste clipboard
             */
            SendMessage(ped->hwnd, (UINT)(scState == CTRLDOWN ? WM_COPY : WM_PASTE), 0, 0);
        }
        break;
    }

    if (changeSelection) {
        hdc = ECGetEditDC(ped, FALSE);
        MLChangeSelection(ped, hdc, newMinSel, newMaxSel);

        /*
         * Set the caret's line
         */
        ped->iCaretLine = MLIchToLine(ped, ped->ichCaret);

        if (virtKeyCode == VK_END &&
                // Next line: Win95 Bug#11822, EditControl repaint (Sankar)
                (ped->ichCaret == ped->chLines[ped->iCaretLine]) &&
                ped->ichCaret < ped->cch &&
                ped->fWrap && ped->iCaretLine > 0) {
            LPSTR pText = ECLock(ped);

            /*
             * Handle moving to the end of a word wrapped line. This keeps the
             * cursor from falling to the start of the next line if we have word
             * wrapped and there is no CRLF.
             */
            if ( ped->fAnsi ) {
                if (*(WORD UNALIGNED *)(pText +
                        ped->chLines[ped->iCaretLine] - 2) != 0x0A0D) {
                    ped->iCaretLine--;
                }
            } else {
                if (*(DWORD UNALIGNED *)(pText +
                     (ped->chLines[ped->iCaretLine] - 2)*ped->cbChar) != 0x000A000D) {
                    ped->iCaretLine--;
                }
            }
            CHECK_LINE_NUMBER(ped->iCaretLine, ped);
            ECUnlock(ped);
        }

        /*
         * Since drawtext sets the caret position
         */
        MLSetCaretPosition(ped, hdc);
        ECReleaseEditDC(ped, hdc, FALSE);

        /*
         * Make sure we can see the cursor
         */
        MLEnsureCaretVisible(ped);
    }
}

/***************************************************************************\
* MLChar
*
* Handles character and virtual key input
*
* History:
\***************************************************************************/

void MLChar(
    PED ped,
    DWORD keyValue,
    int keyMods)
{
    WCHAR keyPress;
    BOOL updateText = FALSE;

    /*
     * keyValue is either:
     *    a Virtual Key (eg: VK_TAB, VK_ESCAPE, VK_BACK)
     *    a character (Unicode or "ANSI")
     */
    if (ped->fAnsi)
        keyPress = LOBYTE(keyValue);
    else
        keyPress = LOWORD(keyValue);

    if (ped->fMouseDown || keyPress == VK_ESCAPE) {

        /*
         * If we are in the middle of a mousedown command, don't do anything.
         * Also, just ignore it if we get a translated escape key which happens
         * with multiline edit controls in a dialog box.
         */
        return ;
    }

    ECInOutReconversionMode(ped, FALSE);

    {
        int scState;
        scState = ECGetModKeys(keyMods);

        if (ped->fInDialogBox && scState != CTRLDOWN) {

            /*
             * If this multiline edit control is in a dialog box, then we want the
             * TAB key to take you to the next control, shift TAB to take you to the
             * previous control, and CTRL-TAB to insert a tab into the edit control.
             * We moved the focus when we received the keydown message so we will
             * ignore the TAB key now unless the ctrl key is down. Also, we want
             * CTRL-RETURN to insert a return into the text and RETURN to be sent to
             * the default button.
             */
            if (keyPress == VK_TAB ||
                    (keyPress == VK_RETURN && !TestWF(ped->pwnd, EFWANTRETURN)))
                return ;
        }

        /*
         * Allow CTRL+C to copy from a read only edit control
         * Ignore all other keys in read only controls
         */
        if ((ped->fReadOnly) && !((keyPress == 3) && (scState == CTRLDOWN))) {
            return ;
        }
    }

    switch (keyPress) {
    case 0x0A: // linefeed
        keyPress = VK_RETURN;
        /*
         * FALL THRU
         */

    case VK_RETURN:
    case VK_TAB:
    case VK_BACK:
DeleteSelection:
        if (MLDeleteText(ped))
            updateText = TRUE;
        break;

    default:
        if (keyPress >= TEXT(' ')) {
            /*
             * If this is in [a-z],[A-Z] and we are an ES_NUMBER
             * edit field, bail.
             */
            if (ped->f40Compat && TestWF(ped->pwnd, EFNUMBER)) {
                if (!ECIsCharNumeric(ped, keyPress)) {
                    goto IllegalChar;
                }
            }

            goto DeleteSelection;
        }
        break;
    }

    /*
     * Handle key codes
     */
    switch(keyPress) {
    UINT msg;

    // Ctrl+Z == Undo
    case 26:
        msg = WM_UNDO;
        goto SendEditingMessage;
        break;

    // Ctrl+X == Cut
    case 24:
        if (ped->ichMinSel == ped->ichMaxSel)
            goto IllegalChar;
        else
        {
            msg = WM_CUT;
            goto SendEditingMessage;
        }
        break;

    // Ctrl+C == Copy
    case 3:
        msg = WM_COPY;
        goto SendEditingMessage;
        break;

    // Ctrl+V == Paste
    case 22:
        msg = WM_PASTE;
SendEditingMessage:
        SendMessage(ped->hwnd, msg, 0, 0L);
        break;

    case VK_BACK:
        //
        // Delete any selected text or delete character left if no sel
        //
        if (!updateText && ped->ichMinSel)
        {
            //
            // There was no selection to delete so we just delete
            // character left if available
            //
            ped->ichMinSel = MLMoveSelection(ped, ped->ichCaret, TRUE);
            MLDeleteText(ped);
        }
        break;

    default:
        if (keyPress == VK_RETURN)
            if (ped->fAnsi)
                keyValue = 0x0A0D;
            else
                keyValue = 0x000A000D;

        if (   keyPress >= TEXT(' ')
            || keyPress == VK_RETURN
            || keyPress == VK_TAB
            || keyPress == 0x1E     // RS - Unicode block separator
            || keyPress == 0x1F     // US - Unicode segment separator
            ) {

            NtUserCallNoParam(SFI_ZZZHIDECURSORNOCAPTURE);
            if (ped->fAnsi) {
                //
                // check if it's a leading byte of double byte character
                //
                if (ECIsDBCSLeadByte(ped,(BYTE)keyPress)) {
                    int DBCSkey;

                    if ((DBCSkey = DbcsCombine(ped->hwnd, keyPress)) != 0)
                        keyValue = DBCSkey;
                }
                MLInsertText(ped, (LPSTR)&keyValue, HIBYTE(keyValue) ? 2 : 1, TRUE);
            } else
                MLInsertText(ped, (LPSTR)&keyValue, HIWORD(keyValue) ? 2 : 1, TRUE);
        } else {
IllegalChar:
            NtUserMessageBeep(0);
        }
        break;
    }
}

/***************************************************************************\
* MLPasteText AorW
*
* Pastes a line of text from the clipboard into the edit control
* starting at ped->ichCaret. Updates ichMaxSel and ichMinSel to point to the
* end of the inserted text. Notifies the parent if space cannot be
* allocated. Returns how many characters were inserted.
*
* History:
\***************************************************************************/

ICH PASCAL NEAR MLPasteText(
    PED ped)
{
    HANDLE hData;
    LPSTR lpchClip;
    ICH cchAdded = 0;
    HCURSOR hCursorOld;

#ifdef UNDO_CLEANUP           // #ifdef Added in Chicago  - johnl
    if (!ped->fAutoVScroll) {

        /*
         * Empty the undo buffer if this edit control limits the amount of text
         * the user can add to the window rect. This is so that we can undo this
         * operation if doing in causes us to exceed the window boundaries.
         */
        ECEmptyUndo(ped);
    }
#endif

    hCursorOld = NtUserSetCursor(LoadCursor(NULL, IDC_WAIT));

    if (!OpenClipboard(ped->hwnd))
        goto PasteExitNoCloseClip;

    if (!(hData = GetClipboardData(ped->fAnsi ? CF_TEXT : CF_UNICODETEXT)) ||
            (GlobalFlags(hData) == GMEM_INVALID_HANDLE)) {
        RIPMSG1(RIP_WARNING, "MLPasteText(): couldn't get a valid handle(%x)", hData);
        goto PasteExit;
    }

    /*
     * See if any text should be deleted
     */
    MLDeleteText(ped);

    USERGLOBALLOCK(hData, lpchClip);
    if (lpchClip == NULL) {
        RIPMSG1(RIP_WARNING, "MLPasteText: USERGLOBALLOCK(%x) failed.", hData);
        goto PasteExit;
    }

    /*
     * Get the length of the addition.
     */
    if (ped->fAnsi)
        cchAdded = strlen(lpchClip);
    else
        cchAdded = wcslen((LPWSTR)lpchClip);

    /*
     * Insert the text (MLInsertText checks line length)
     */
    cchAdded = MLInsertText(ped, lpchClip, cchAdded, FALSE);

    USERGLOBALUNLOCK(hData);

PasteExit:
    NtUserCloseClipboard();

PasteExitNoCloseClip:
    NtUserSetCursor(hCursorOld);

    return (cchAdded);
}

/***************************************************************************\
* MLMouseMotion AorW
*
* History:
\***************************************************************************/

void MLMouseMotion(
    PED ped,
    UINT message,
    UINT virtKeyDown,
    LPPOINT mousePt)
{
    BOOL fChangedSel = FALSE;

    HDC hdc = ECGetEditDC(ped, TRUE);

    ICH ichMaxSel = ped->ichMaxSel;
    ICH ichMinSel = ped->ichMinSel;

    ICH mouseCch;
    ICH mouseLine;
    int i, j;
    LONG  ll, lh;

    mouseCch = MLMouseToIch(ped, hdc, mousePt, &mouseLine);

    /*
     * Save for timer
     */
    ped->ptPrevMouse = *mousePt;
    ped->prevKeys = virtKeyDown;

    switch (message) {
    case WM_LBUTTONDBLCLK:
        /*
         * if shift key is down, extend selection to word we double clicked on
         * else clear current selection and select word.
         */
        // LiZ -- 5/5/93
        if (ped->fAnsi && ped->fDBCS) {
            LPSTR pText = ECLock(ped);
            ECWord(ped,ped->ichCaret,
                   ECIsDBCSLeadByte(ped, *(pText+(ped->ichCaret)))
                        ? FALSE :
                          (ped->ichCaret == ped->chLines[ped->iCaretLine]
                              ? FALSE : TRUE), &ll, &lh);
            ECUnlock(ped);
        } else {
            ECWord(ped, mouseCch, !(mouseCch == ped->chLines[mouseLine]), &ll, &lh);
        }
        if (!(virtKeyDown & MK_SHIFT)) {
            // If shift key isn't down, move caret to mouse point and clear
            // old selection
            ichMinSel = ll;
            ichMaxSel = ped->ichCaret = lh;
        } else {
            // Shiftkey is down so we want to maintain the current selection
            // (if any) and just extend or reduce it
            if (ped->ichMinSel == ped->ichCaret) {
                ichMinSel = ped->ichCaret = ll;
                ECWord(ped, ichMaxSel, TRUE, &ll, &lh);
            } else {
                ichMaxSel = ped->ichCaret = lh;
                ECWord(ped, ichMinSel, FALSE, &ll, &lh);
            }
        }

        ped->ichStartMinSel = ll;
        ped->ichStartMaxSel = lh;

        goto InitDragSelect;

    case WM_MOUSEMOVE:
        if (ped->fMouseDown) {

            /*
             * Set the system timer to automatically scroll when mouse is
             * outside of the client rectangle. Speed of scroll depends on
             * distance from window.
             */
            i = mousePt->y < 0 ? -mousePt->y : mousePt->y - ped->rcFmt.bottom;
            j = gpsi->dtScroll - ((UINT)i << 4);
            if (j < 1)
                j = 1;
            NtUserSetSystemTimer(ped->hwnd, IDSYS_SCROLL, (UINT)j, NULL);

            fChangedSel = TRUE;

            // Extend selection, move caret right
            if (ped->ichStartMinSel || ped->ichStartMaxSel) {
                // We're in WORD SELECT mode
                BOOL fReverse = (mouseCch <= ped->ichStartMinSel);
                ECWord(ped, mouseCch, !fReverse, &ll, &lh);
                if (fReverse) {
                    ichMinSel = ped->ichCaret = ll;
                    ichMaxSel = ped->ichStartMaxSel;
                } else {
                    ichMinSel = ped->ichStartMinSel;
                    ichMaxSel = ped->ichCaret = lh;
                }
            } else if ((ped->ichMinSel == ped->ichCaret) &&
                    (ped->ichMinSel != ped->ichMaxSel))
                // Reduce selection extent
                ichMinSel = ped->ichCaret = mouseCch;
            else
                // Extend selection extent
                ichMaxSel = ped->ichCaret = mouseCch;

            ped->iCaretLine = mouseLine;
        }
        break;

    case WM_LBUTTONDOWN:
        ll = lh = mouseCch;

        if (!(virtKeyDown & MK_SHIFT)) {
            // If shift key isn't down, move caret to mouse point and clear
            // old selection
            ichMinSel = ichMaxSel = ped->ichCaret = mouseCch;
        } else {
            // Shiftkey is down so we want to maintain the current selection
            // (if any) and just extend or reduce it
            if (ped->ichMinSel == ped->ichCaret)
                ichMinSel = ped->ichCaret = mouseCch;
            else
                ichMaxSel = ped->ichCaret = mouseCch;
        }

        ped->ichStartMinSel = ped->ichStartMaxSel = 0;

InitDragSelect:
        ped->iCaretLine = mouseLine;

        ped->fMouseDown = FALSE;
        NtUserSetCapture(ped->hwnd);
        ped->fMouseDown = TRUE;
        fChangedSel = TRUE;

        // Set the timer so that we can scroll automatically when the mouse
        // is moved outside the window rectangle.
        NtUserSetSystemTimer(ped->hwnd, IDSYS_SCROLL, gpsi->dtScroll, NULL);
        break;

    case WM_LBUTTONUP:
        if (ped->fMouseDown) {

            /*
             * Kill the timer so that we don't do auto mouse moves anymore
             */
            NtUserKillSystemTimer(ped->hwnd, IDSYS_SCROLL);
            NtUserReleaseCapture();
            MLSetCaretPosition(ped, hdc);
            ped->fMouseDown = FALSE;
        }
        break;
    }


    if (fChangedSel) {
        MLChangeSelection(ped, hdc, ichMinSel, ichMaxSel);
        MLEnsureCaretVisible(ped);
    }

    ECReleaseEditDC(ped, hdc, TRUE);

    if (!ped->fFocus && (message == WM_LBUTTONDOWN)) {

        /*
         * If we don't have the focus yet, get it
         */
        NtUserSetFocus(ped->hwnd);
    }
}

/***************************************************************************\
* MLScroll AorW
*
* History:
\***************************************************************************/

LONG MLScroll(
    PED  ped,
    BOOL fVertical,
    int  cmd,
    int  iAmt,
    BOOL fRedraw)
{
    SCROLLINFO  si;
    int         dx = 0;
    int         dy = 0;
    BOOL        fIncludeLeftMargin;
    int         newPos;
    int         oldPos;
    BOOL        fUp = FALSE;
    UINT        wFlag;
    DWORD       dwTime = 0;

    if (fRedraw && (cmd != ML_REFRESH)) {
        UpdateWindow(ped->hwnd);
    }

    if (ped->pLpkEditCallout && ped->fRtoLReading && !fVertical
        && ped->maxPixelWidth > ped->rcFmt.right - ped->rcFmt.left) {
        /*
         * Horizontal scoll of a right oriented window with a scrollbar.
         * Map the logical xOffset to visual coordinates.
         */
        oldPos = ped->maxPixelWidth
                 - ((int)ped->xOffset + ped->rcFmt.right - ped->rcFmt.left);
    } else
        oldPos = (int) (fVertical ? ped->ichScreenStart : ped->xOffset);

    fIncludeLeftMargin = (ped->xOffset == 0);

    switch (cmd) {
        case ML_REFRESH:
            newPos = oldPos;
            break;

        case EM_GETTHUMB:
            return(oldPos);

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:

            /*
             * If the edit contains more than 0xFFFF lines
             * it means that the scrolbar can return a position
             * that cannot fit in a WORD (16 bits), so use
             * GetScrollInfo (which is slower) in this case.
             */
            if (ped->cLines < 0xFFFF) {
                newPos = iAmt;
            } else {
                SCROLLINFO si;

                si.cbSize   = sizeof(SCROLLINFO);
                si.fMask    = SIF_TRACKPOS;

                GetScrollInfo( ped->hwnd, SB_VERT, &si);

                newPos = si.nTrackPos;
            }
            break;

        case SB_TOP:      // == SB_LEFT
            newPos = 0;
            break;

        case SB_BOTTOM:   // == SB_RIGHT
            if (fVertical)
                newPos = ped->cLines;
            else
                newPos = ped->maxPixelWidth;
            break;

        case SB_PAGEUP:   // == SB_PAGELEFT
            fUp = TRUE;
        case SB_PAGEDOWN: // == SB_PAGERIGHT

            if (fVertical)
                iAmt = ped->ichLinesOnScreen - 1;
            else
                iAmt = (ped->rcFmt.right - ped->rcFmt.left) - 1;

            if (iAmt == 0)
                iAmt++;

            if (fUp)
                iAmt = -iAmt;
            goto AddDelta;

        case SB_LINEUP:   // == SB_LINELEFT
            fUp = TRUE;
        case SB_LINEDOWN: // == SB_LINERIGHT

            dwTime = iAmt;

            iAmt = 1;

            if (fUp)
                iAmt = -iAmt;

            //   |             |
            //   |  FALL THRU  |
            //   V             V

        case EM_LINESCROLL:
            if (!fVertical)
                iAmt *= ped->aveCharWidth;

AddDelta:
            newPos = oldPos + iAmt;
            break;

        default:
            return(0L);
    }

    if (fVertical) {
        if (si.nMax = ped->cLines)
            si.nMax--;

        if (!ped->hwndParent ||
            TestWF(ValidateHwnd(ped->hwndParent), WFWIN40COMPAT))
            si.nPage = ped->ichLinesOnScreen;
        else
            si.nPage = 0;

        wFlag = WFVSCROLL;
    } else         {
        si.nMax  = ped->maxPixelWidth;
        si.nPage = ped->rcFmt.right - ped->rcFmt.left;
        wFlag = WFHSCROLL;
    }

    if (TestWF(ValidateHwnd(ped->hwnd), wFlag)) {
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
        si.nMin  = 0;
        si.nPos = newPos;
        newPos = SetScrollInfo(ped->hwnd, fVertical ? SB_VERT : SB_HORZ,
                                     &si, fRedraw);
    } else {
        // BOGUS -- this is duped code from ScrollBar code
        // but it's for the case when we want to limit the position without
        // actually having the scroll bar
        int iMaxPos;

        // Clip page to 0, range + 1
        si.nPage = max(min((int)si.nPage, si.nMax + 1), 0);


        iMaxPos = si.nMax - (si.nPage ? si.nPage - 1 : 0);
        newPos = min(max(newPos, 0), iMaxPos);
    }

    oldPos -= newPos;

    if (!oldPos)
        return(0L);

    if (ped->pLpkEditCallout && ped->fRtoLReading && !fVertical
        && ped->maxPixelWidth > ped->rcFmt.right - ped->rcFmt.left) {
        // Map visual oldPos and newPos back to logical coordinates
        newPos = ped->maxPixelWidth
                 - (newPos + ped->rcFmt.right - ped->rcFmt.left);
        oldPos = -oldPos;
        if (newPos<0) {
            // Compensate for scroll bar returning pos > max-page
            oldPos += newPos;
            newPos=0;
        }
    }

    if (fVertical) {
        ped->ichScreenStart = newPos;
        dy = oldPos * ped->lineHeight;
    } else {
        ped->xOffset = newPos;
        dx = oldPos;
    }

    if (cmd != SB_THUMBTRACK)
        // We don't want to notify the parent of thumbtracking since they might
        // try to set the thumb position to something bogus.
        // NOTEPAD used to be guilty of this -- but I rewrote it so it's not.
        // The question is WHO ELSE does this? (jeffbog)
        ECNotifyParent(ped, fVertical ? EN_VSCROLL : EN_HSCROLL);

    if (fRedraw && _IsWindowVisible(ped->pwnd)) {
        RECT    rc;
        RECT    rcUpdate;
        RECT    rcClipRect;
        HDC     hdc;

        _GetClientRect(ped->pwnd, &rc);
        CopyRect(&rcClipRect, &ped->rcFmt);

        if (fVertical) { // Is this a vertical scroll?
            rcClipRect.left -= ped->wLeftMargin;
            rcClipRect.right += ped->wRightMargin;
        }

        IntersectRect(&rc, &rc, &rcClipRect);
        rc.bottom++;

        /*
         * Chicago has this HideCaret but there doesn't appear to be a
         * corresponding ShowCaret, so we lose the Caret under NT when the
         * EC scrolls - Johnl
         *
         * HideCaret(ped->hwnd);
         */

        hdc = ECGetEditDC(ped, FALSE);
        ECSetEditClip(ped, hdc, fIncludeLeftMargin);
        if (ped->hFont)
            SelectObject(hdc, ped->hFont);
        ECGetBrush(ped, hdc);

        if (ped->pLpkEditCallout && !fVertical) {
            // Horizontal scroll with complex script support
            int xFarOffset = ped->xOffset + ped->rcFmt.right - ped->rcFmt.left;

            rc = ped->rcFmt;
            if (dwTime != 0)
                ScrollWindowEx(ped->hwnd, ped->fRtoLReading ? -dx : dx, dy, NULL, NULL, NULL,
                        &rcUpdate, MAKELONG(SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime));
            else
                NtUserScrollDC(hdc, ped->fRtoLReading ? -dx : dx, dy,
                               &rc, &rc, NULL, &rcUpdate);

            // Handle margins: Blank if clipped by horizontal scrolling,
            // display otherwise.
            if (ped->wLeftMargin) {
                rc.left  = ped->rcFmt.left - ped->wLeftMargin;
                rc.right = ped->rcFmt.left;
                if (   (ped->format != ES_LEFT)   // Always display margin for centred or far-aligned text
                    ||  // Display LTR left margin if first character fully visible
                        (!ped->fRtoLReading && ped->xOffset == 0)
                    ||  // Display RTL left margin if last character fully visible
                        (ped->fRtoLReading && xFarOffset >= ped->maxPixelWidth)) {
                    UnionRect(&rcUpdate, &rcUpdate, &rc);
                } else {
                    ExtTextOutW(hdc, rc.left, rc.top,
                        ETO_CLIPPED | ETO_OPAQUE | ETO_GLYPH_INDEX,
                        &rc, L"", 0, 0L);
                }
            }
            if (ped->wRightMargin) {
                rc.left  = ped->rcFmt.right;
                rc.right = ped->rcFmt.right + ped->wRightMargin;
                if (   (ped->format != ES_LEFT)   // Always display margin for centred or far-aligned text
                    ||  // Display RTL right margin if first character fully visible
                        (ped->fRtoLReading && ped->xOffset == 0)
                    ||  // Display LTR right margin if last character fully visible
                        (!ped->fRtoLReading && xFarOffset >= ped->maxPixelWidth)) {
                    UnionRect(&rcUpdate, &rcUpdate, &rc);
                } else {
                    ExtTextOutW(hdc, rc.left, rc.top,
                        ETO_CLIPPED | ETO_OPAQUE | ETO_GLYPH_INDEX,
                        &rc, L"", 0, 0L);
                }
            }
        } else {
            if (dwTime != 0)
                ScrollWindowEx(ped->hwnd, dx, dy, NULL, NULL, NULL,
                        &rcUpdate, MAKELONG(SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime));
            else
                NtUserScrollDC(hdc, dx, dy, &rc, &rc, NULL, &rcUpdate);

            // If we need to wipe out the left margin area
            if (ped->wLeftMargin && !fVertical) {
                // Calculate the rectangle to be wiped out
                rc.right = rc.left;
                rc.left = max(0, (INT)(ped->rcFmt.left - ped->wLeftMargin));
                if (rc.left < rc.right) {
                    if (fIncludeLeftMargin && (ped->xOffset != 0)) {

                        ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED | ETO_OPAQUE,
                            &rc, L"", 0, 0L);
                    } else
                        if((!fIncludeLeftMargin) && (ped->xOffset == 0))
                            UnionRect(&rcUpdate, &rcUpdate, &rc);
                }
            }
        }
        MLSetCaretPosition(ped,hdc);

        ECReleaseEditDC(ped, hdc, FALSE);
        NtUserInvalidateRect(ped->hwnd, &rcUpdate,
                ((ped->ichLinesOnScreen + ped->ichScreenStart) >= ped->cLines));
        UpdateWindow(ped->hwnd);
    }

    return(MAKELONG(-oldPos, 1));
}

/***************************************************************************\
* MLSetFocus AorW
*
* Gives the edit control the focus and notifies the parent
* EN_SETFOCUS.
*
* History:
\***************************************************************************/

void MLSetFocus(
    PED ped)
{
    HDC hdc;

    if (!ped->fFocus) {
        ped->fFocus = 1; /* Set focus */

        hdc = ECGetEditDC(ped, TRUE);

        /*
         * Draw the caret. We need to do this even if the window is hidden
         * because in dlg box initialization time we may set the focus to a
         * hidden edit control window. If we don't create the caret etc, it will
         * never end up showing properly.
         */
        if (ped->pLpkEditCallout) {
            ped->pLpkEditCallout->EditCreateCaret (ped, hdc, ECGetCaretWidth(), ped->lineHeight, 0);
        }
        else {
            NtUserCreateCaret(ped->hwnd, (HBITMAP)NULL, ECGetCaretWidth(), ped->lineHeight);
        }
        NtUserShowCaret(ped->hwnd);
        MLSetCaretPosition(ped, hdc);

        /*
         * Show the current selection. Only if the selection was hidden when we
         * lost the focus, must we invert (show) it.
         */
        if (!ped->fNoHideSel && ped->ichMinSel != ped->ichMaxSel &&
                _IsWindowVisible(ped->pwnd))
            MLDrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel, TRUE);

        ECReleaseEditDC(ped, hdc, TRUE);

    }
#if 0
    MLEnsureCaretVisible(ped);
#endif

    /*
     * Notify parent we have the focus
     */
    ECNotifyParent(ped, EN_SETFOCUS);
}

/***************************************************************************\
* MLKillFocus AorW
*
* The edit control loses the focus and notifies the parent via
* EN_KILLFOCUS.
*
* History:
\***************************************************************************/

void MLKillFocus(
    PED ped)
{
    HDC hdc;

    /*
     * Reset the wheel delta count.
     */
    gcWheelDelta = 0;

    if (ped->fFocus) {
        ped->fFocus = 0; /* Clear focus */

        /*
         * Do this only if we still have the focus. But we always notify the
         * parent that we lost the focus whether or not we originally had the
         * focus.
         */

        /*
         * Hide the current selection if needed
         */
        if (!ped->fNoHideSel && ped->ichMinSel != ped->ichMaxSel &&
            _IsWindowVisible(ped->pwnd)) {
            hdc = ECGetEditDC(ped, FALSE);
            MLDrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel, TRUE);
            ECReleaseEditDC(ped, hdc, FALSE);
        }

        /*
         * Destroy the caret
         */
        NtUserDestroyCaret();
    }

    /*
     * Notify parent that we lost the focus.
     */
    ECNotifyParent(ped, EN_KILLFOCUS);
}

/***************************************************************************\
* MLEnsureCaretVisible AorW
*
* Scrolls the caret into the visible region.
* Returns TRUE if scrolling was done else return s FALSE.
*
* History:
\***************************************************************************/

BOOL MLEnsureCaretVisible(
    PED ped)
{
    UINT   iLineMax;
    int    xposition;
    BOOL   fPrevLine;
    HDC    hdc;
    BOOL   fVScroll = FALSE;
    BOOL   fHScroll = FALSE;

    if (_IsWindowVisible(ped->pwnd)) {
        int iAmt;
        int iFmtWidth = ped->rcFmt.right - ped->rcFmt.left;

        if (ped->fAutoVScroll) {
            iLineMax = ped->ichScreenStart + ped->ichLinesOnScreen - 1;

            if (fVScroll = (ped->iCaretLine > iLineMax))
                iAmt = iLineMax;
            else if (fVScroll = (ped->iCaretLine < ped->ichScreenStart))
                iAmt = ped->ichScreenStart;

            if (fVScroll)
                MLScroll(ped, TRUE, EM_LINESCROLL, ped->iCaretLine - iAmt, TRUE);
        }

        if (ped->fAutoHScroll && ((int) ped->maxPixelWidth > iFmtWidth)) {
            POINT pt;
            /* Get the current position of the caret in pixels */
            if ((UINT) (ped->cLines - 1) != ped->iCaretLine &&
                ped->ichCaret == ped->chLines[ped->iCaretLine + 1])
                fPrevLine = TRUE;
            else
                fPrevLine = FALSE;

            hdc = ECGetEditDC(ped,TRUE);
            MLIchToXYPos(ped, hdc, ped->ichCaret, fPrevLine, &pt);
            ECReleaseEditDC(ped, hdc, TRUE);
            xposition = pt.x;

            // Remember, MLIchToXYPos returns coordinates with respect to the
            // top left pixel displayed on the screen.  Thus, if xPosition < 0,
            // it means xPosition is less than current ped->xOffset.

            iFmtWidth /= 3;
            if (fHScroll = (xposition < ped->rcFmt.left))
                // scroll to the left
                iAmt = ped->rcFmt.left + iFmtWidth;
            else if (fHScroll = (xposition > ped->rcFmt.right))
                // scroll to the right
                iAmt = ped->rcFmt.right - iFmtWidth;

            if (fHScroll)
                MLScroll(ped, FALSE, EM_LINESCROLL, (xposition - iAmt) / ped->aveCharWidth, TRUE);
        }
    }
    return(fVScroll);
}

/***************************************************************************\
* MLEditWndProc
*
* Class procedure for all multi line edit controls.
* Dispatches all messages to the appropriate handlers which are named
* as follows:
* SL (single line) prefixes all single line edit control procedures while
* EC (edit control) prefixes all common handlers.
*
* The MLEditWndProc only handles messages specific to multi line edit
* controls.
*
* WARNING: If you add a message here, add it to gawEditWndProc[] in
* kernel\server.c too, otherwise EditWndProcA/W will send it straight to
* DefWindowProcWorker
*
* History:
\***************************************************************************/

LRESULT MLEditWndProc(
    HWND hwnd,
    PED ped,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    LPRECT      lprc;
    POINT       pt;
    DWORD       windowstyle;

    switch (message) {

    case WM_INPUTLANGCHANGE:
        if (ped && ped->fFocus && ped->pLpkEditCallout) {
            NtUserHideCaret(hwnd);
            hdc = ECGetEditDC(ped, TRUE);
            NtUserDestroyCaret();
            ped->pLpkEditCallout->EditCreateCaret (ped, hdc, ECGetCaretWidth(), ped->lineHeight, (UINT)lParam);
            MLSetCaretPosition(ped, hdc);
            ECReleaseEditDC(ped, hdc, TRUE);
            NtUserShowCaret(hwnd);
        }
        goto PassToDefaultWindowProc;


    case WM_STYLECHANGED:
        if (ped && ped->pLpkEditCallout) {
            switch (wParam) {

                case GWL_STYLE:
                    ECUpdateFormat(ped,
                        ((LPSTYLESTRUCT)lParam)->styleNew,
                        GetWindowLong(ped->hwnd, GWL_EXSTYLE));
                    return 1L;

                case GWL_EXSTYLE:
                    ECUpdateFormat(ped,
                        GetWindowLong(ped->hwnd, GWL_STYLE),
                        ((LPSTYLESTRUCT)lParam)->styleNew);
                    return 1L;
            }
        }

        goto PassToDefaultWindowProc;

    case WM_CHAR:

        /*
         * wParam - the value of the key
         * lParam - modifiers, repeat count etc (not used)
         */
        MLChar(ped, (UINT)wParam, 0);
        break;

    case WM_ERASEBKGND:  {
            HBRUSH  hbr;

            // USE SAME RULES AS IN ECGetBrush()
            if (ped->f40Compat &&
                (ped->fReadOnly || ped->fDisabled))
                hbr = (HBRUSH) CTLCOLOR_STATIC;
            else
                hbr = (HBRUSH) CTLCOLOR_EDIT;

            FillWindow(ped->hwndParent, hwnd, (HDC)wParam, hbr);
        }
        return ((LONG)TRUE);

    case WM_GETDLGCODE: {
            LONG code = DLGC_WANTCHARS | DLGC_HASSETSEL | DLGC_WANTARROWS | DLGC_WANTALLKEYS;

            /*
             ** !!! JEFFBOG HACK !!!
             ** Only set Dialog Box Flag if GETDLGCODE message is generated by
             ** IsDialogMessage -- if so, the lParam will be a pointer to the
             ** message structure passed to IsDialogMessage; otherwise, lParam
             ** will be NULL. Reason for the HACK alert: the wParam & lParam
             ** for GETDLGCODE is still not clearly defined and may end up
             ** changing in a way that would throw this off
             **
             */
            if (lParam)
               ped->fInDialogBox = TRUE; // Mark ML edit ctrl as in a dialog box

            /*
             ** If this is a WM_SYSCHAR message generated by the UNDO keystroke
             ** we want this message so we can EAT IT in "case WM_SYSCHAR:"
             */
            if (lParam && (((LPMSG)lParam)->message == WM_SYSCHAR) &&
                    ((DWORD)((LPMSG)lParam)->lParam & SYS_ALTERNATE) &&
                    ((WORD)wParam == VK_BACK))
                 code |= DLGC_WANTMESSAGE;
            return code;
        }

    case EM_SCROLL:
        message = WM_VSCROLL;

        /*
         * FALL THROUGH
         */
    case WM_HSCROLL:
    case WM_VSCROLL:
        return MLScroll(ped, (message==WM_VSCROLL), LOWORD(wParam), HIWORD(wParam), TRUE);

    case WM_MOUSEWHEEL:
        /*
         * Don't handle zoom and datazoom.
         */
        if (wParam & (MK_SHIFT | MK_CONTROL)) {
            goto PassToDefaultWindowProc;
        }

        gcWheelDelta -= (short) HIWORD(wParam);
        windowstyle = ped->pwnd->style;
        if (    abs(gcWheelDelta) >= WHEEL_DELTA &&
                gpsi->ucWheelScrollLines > 0 &&
                (windowstyle & (WS_VSCROLL | WS_HSCROLL))) {

            int     cLineScroll;
            BOOL    fVert;
            int     cPage;

            if (windowstyle & WS_VSCROLL) {
                fVert = TRUE;
                cPage = ped->ichLinesOnScreen;
            } else {
                fVert = FALSE;
                cPage = (ped->rcFmt.right - ped->rcFmt.left) / ped->aveCharWidth;
            }

            /*
             * Limit a roll of one (1) WHEEL_DELTA to scroll one (1) page.
             */
            cLineScroll = (int) min(
                    (UINT) (max(1, (cPage - 1))),
                    gpsi->ucWheelScrollLines);

            cLineScroll *= (gcWheelDelta / WHEEL_DELTA);
            UserAssert(cLineScroll != 0);
            gcWheelDelta = gcWheelDelta % WHEEL_DELTA;
            MLScroll(ped, fVert, EM_LINESCROLL, cLineScroll, TRUE);
        }

        break;

    case WM_KEYDOWN:

        /*
         * wParam - virt keycode of the given key
         * lParam - modifiers such as repeat count etc. (not used)
         */
        MLKeyDown(ped, (UINT)wParam, 0);
        break;

    case WM_KILLFOCUS:

        /*
         * wParam - handle of the window that receives the input focus
         * lParam - not used
         */
        MLKillFocus(ped);
        break;

    case WM_CAPTURECHANGED:
        //
        // wParam -- unused
        // lParam -- hwnd of window gaining capture.
        //
        if (ped->fMouseDown) {
            //
            // We don't change the caret pos here.  If this is happening
            // due to button up, then we'll change the pos in the
            // handler after ReleaseCapture().  Otherwise, just end
            // gracefully because someone else has stolen capture out
            // from under us.
            //

            ped->fMouseDown = FALSE;
            NtUserKillSystemTimer(ped->hwnd, IDSYS_SCROLL);
        }
        break;

    case WM_SYSTIMER:

        /*
         * This allows us to automatically scroll if the user holds the mouse
         * outside the edit control window. We simulate mouse moves at timer
         * intervals set in MouseMotionHandler.
         */
        if (ped->fMouseDown)
            MLMouseMotion(ped, WM_MOUSEMOVE, ped->prevKeys, &ped->ptPrevMouse);
        break;

    case WM_MBUTTONDOWN:
        EnterReaderModeHelper(ped->hwnd);
        break;

    case WM_MOUSEMOVE:
        UserAssert(ped->fMouseDown);

        /*
         * FALL THROUGH
         */
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
        /*
         * wParam - contains a value that indicates which virtual keys are down
           lParam - contains x and y coords of the mouse cursor
         */
        POINTSTOPOINT(pt, lParam);
        MLMouseMotion(ped, message, (UINT)wParam, &pt);
        break;

    case WM_CREATE:

        /*
         * wParam - handle to window being created
         * lParam - points to a CREATESTRUCT that contains copies of parameters
         * passed to the CreateWindow function.
         */
        return (MLCreate(ped, (LPCREATESTRUCT)lParam));

    case WM_PRINTCLIENT:
        MLPaint(ped, (HDC) wParam, NULL);
        break;

    case WM_PAINT:
        /*
         * wParam - can be hdc from subclassed paint
           lParam - not used
         */
        if (wParam) {
            hdc = (HDC) wParam;
            lprc = NULL;
        } else {
            hdc = NtUserBeginPaint(ped->hwnd, &ps);
            lprc = &ps.rcPaint;
        }

        if (_IsWindowVisible(ped->pwnd))
            MLPaint(ped, hdc, lprc);

        if (!wParam)
            NtUserEndPaint(ped->hwnd, &ps);
        break;

    case WM_PASTE:

        /*
         * wParam - not used
           lParam - not used
         */
        if (!ped->fReadOnly)
            MLPasteText(ped);
        break;

    case WM_SETFOCUS:

        /*
         * wParam - handle of window that loses the input focus (may be NULL)
           lParam - not used
         */
        MLSetFocus(ped);
        break;

    case WM_SIZE:

        /*
         * wParam - defines the type of resizing fullscreen, sizeiconic,
                    sizenormal etc.
           lParam - new width in LOWORD, new height in HIGHWORD of client area
         */
        ECSize(ped, NULL, TRUE);
        break;

    case EM_FMTLINES:

        /*
         * wParam - indicates disposition of end-of-line chars. If non
         * zero, the chars CR CR LF are placed at the end of a word
         * wrapped line. If wParam is zero, the end of line chars are
         * removed. This is only done when the user gets a handle (via
         * EM_GETHANDLE) to the text. lParam - not used.
         */
        if (wParam)
            MLInsertCrCrLf(ped);
        else
            MLStripCrCrLf(ped);
        MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);
        return (LONG)(wParam != 0);

    case EM_GETHANDLE:

        /*
         * wParam - not used
            lParam - not used
         */

        /*
         * Returns a handle to the edit control's text.
         */

        /*
         * Null terminate the string. Note that we are guaranteed to have the
         * memory for the NULL since ECInsertText allocates an extra
         * WCHAR for the NULL terminator.
         */

        if (ped->fAnsi)
            *(ECLock(ped) + ped->cch) = 0;
        else
            *((LPWSTR)ECLock(ped) + ped->cch) = 0;
        ECUnlock(ped);
        return ((LRESULT)ped->hText);

    case EM_GETLINE:

        /*
         * wParam - line number to copy (0 is first line)
         * lParam - buffer to copy text to. First WORD is max # of bytes to
         * copy
         */
        return MLGetLine(ped, (ICH)wParam, (ICH)*(WORD UNALIGNED *)lParam, (LPSTR)lParam);

    case EM_LINEFROMCHAR:

        /*
         * wParam - Contains the index value for the desired char in the text
         * of the edit control. These are 0 based.
         * lParam - not used
         */
        return (LRESULT)MLIchToLine(ped, (ICH)wParam);

    case EM_LINEINDEX:

        /*
         * wParam - specifies the desired line number where the number of the
         * first line is 0. If linenumber = 0, the line with the caret is used.
         * lParam - not used.
         * This function return s the number of character positions that occur
         * preceeding the first char in a given line.
         */
        {
            ICH ichResult = MLLineIndex(ped, (ICH)wParam);
            if (ichResult == (ICH)-1) {
                return -1;
            }
            return (LRESULT)ichResult;
        }
        break;

    case EM_LINELENGTH:

        /*
         * wParam - specifies the character index of a character in the
           specified line, where the first line is 0. If -1, the length
           of the current line (with the caret) is return ed not including the
           length of any selected text.
           lParam - not used
         */
        return (LRESULT)MLLineLength(ped, (ICH)wParam);

    case EM_LINESCROLL:

        /*
         * wParam - not used
           lParam - Contains the number of lines and char positions to scroll
         */
        MLScroll(ped, TRUE,  EM_LINESCROLL, (INT)lParam, TRUE);
        MLScroll(ped, FALSE, EM_LINESCROLL, (INT)wParam, TRUE);
        break;

    case EM_REPLACESEL:

        /*
         * wParam - flag for 4.0+ apps saying whether to clear undo
           lParam - Points to a null terminated replacement text.
         */
        MLReplaceSel(ped, (LPSTR)lParam);
        if (!ped->f40Compat || !wParam)
            ECEmptyUndo(Pundo(ped));
        break;

    case EM_SETHANDLE:

        /*
         * wParam - contains a handle to the text buffer
           lParam - not used
         */
        MLSetHandle(ped, (HANDLE)wParam);
        break;

    case EM_SETRECT:
    case EM_SETRECTNP:

        //
        // wParamLo --    not used
        // lParam --    LPRECT with new formatting area
        //
        ECSize(ped, (LPRECT) lParam, (message != EM_SETRECTNP));
        break;

    case EM_SETSEL:

        /*
         * wParam - Under 3.1, specifies if we should scroll caret into
         * view or not. 0 == scroll into view. 1 == don't scroll
         * lParam - starting pos in lowword ending pos in high word
         *
         * Under Win32, wParam is the starting pos, lParam is the
         * ending pos, and the caret is not scrolled into view.
         * The message EM_SCROLLCARET forces the caret to be scrolled
         * into view.
         */
        MLSetSelection(ped, TRUE, (ICH)wParam, (ICH)lParam);
        break;

    case EM_SCROLLCARET:

        /*
         * Scroll caret into view
         */
        MLEnsureCaretVisible(ped);
        break;

    case EM_GETFIRSTVISIBLELINE:

        /*
         * Returns the first visible line for multiline edit controls.
         */
        return (LONG)ped->ichScreenStart;

    case WM_SYSKEYDOWN:
        if (((WORD)wParam == VK_BACK) && ((DWORD)lParam & SYS_ALTERNATE)) {
            SendMessage(ped->hwnd, EM_UNDO, 0, 0L);
            break;
        }
        goto PassToDefaultWindowProc;

    case WM_UNDO:
    case EM_UNDO:
        return MLUndo(ped);

    case EM_SETTABSTOPS:

        /*
         * This sets the tab stop positions for multiline edit controls.
         * wParam - Number of tab stops
         * lParam - Far ptr to a UINT array containing the Tab stop positions
         */
        return MLSetTabStops(ped, (int)wParam, (LPINT)lParam);

    case EM_POSFROMCHAR:
        //
        // wParam --    char index in text
        // lParam --    not used
        // This function returns the (x,y) position of the character
        //
    case EM_CHARFROMPOS:
        //
        // wParam --    unused
        // lParam --    pt in client coordinates
        // This function returns
        //      LOWORD: the position of the closest character
        //              to the passed in point.  Beware of
        //              points not actually in the edit client...
        //      HIWORD: the index of the line the char is on
        //
        {
            LONG  xyPos;
            LONG  line;

            hdc = ECGetEditDC(ped, TRUE);

            if (message == EM_POSFROMCHAR) {
                MLIchToXYPos(ped, hdc, (ICH)wParam, FALSE, &pt);
                xyPos = MAKELONG(pt.x, pt.y);
            } else {
                POINTSTOPOINT(pt, lParam);
                xyPos = MLMouseToIch(ped, hdc, &pt, &line);
                xyPos = MAKELONG(xyPos, line);
            }

            ECReleaseEditDC(ped, hdc, TRUE);
            return((LRESULT)xyPos);
            break;
        }

    case WM_SETREDRAW:
        DefWindowProcWorker(ped->pwnd, message, wParam, lParam, FALSE);
        if (wParam) {

            /*
             * Backwards compatability hack needed so that winraid's edit
             * controls work fine.
             */
            RedrawWindow(hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME);
        }
      break;

#if LATER
    case WM_IME_ENDCOMPOSITION:
        ECInOutReconversionMode(ped, FALSE);
        break;
#endif

    default:
PassToDefaultWindowProc:
        return DefWindowProcWorker(ped->pwnd, message, wParam, lParam, ped->fAnsi);
    }

    return 1L;
} /* MLEditWndProc */


/***************************************************************************\
* MLDrawText AorW
*
*  This function draws all the characters between ichStart and ichEnd for
*  the given Multiline Edit Control.
*
*  This function divides the block of text between ichStart and ichEnd
*  into lines and each line into strips of text based on the selection
*  attributes. It calls ECTabTheTextOut() to draw each strip.
*  This takes care of the Negative A anc C widths of the current font, if
*  it has any, on either side of each strip of text.
*
*  NOTE: If the language pack is loaded the text is not divided into strips,
*  nor is selection highlighting performed here. Whole lines are passed
*  to the language pack to display with tab expansion and selection
*  highlighting. (Since the language pack supports scripts with complex
*  character re-ordering rules, only it can do this).
*
* History:
\***************************************************************************/

void MLDrawText(
    PED ped,
    HDC hdc,
    ICH ichStart,
    ICH ichEnd,
    BOOL fSelChange)
{
    DWORD   textColorSave;
    DWORD   bkColorSave;
    PSTR    pText;
    UINT    wCurLine;
    UINT    wEndLine;
    int     xOffset;
    ICH     LengthToDraw;
    ICH     CurStripLength;
    ICH     ichAttrib, ichNewStart;
    ICH     ExtraLengthForNegA;
    ICH     ichT;
    int     iRemainingLengthInLine;
    int     xStPos, xClipStPos, xClipEndPos, yPos;
    BOOL    fFirstLineOfBlock   = TRUE;
    BOOL    fDrawEndOfLineStrip = FALSE;
    BOOL    fDrawOnSameLine     = FALSE;
    BOOL    fSelected                = FALSE;
    BOOL    fLineBegins      = FALSE;
    STRIPINFO   NegCInfo;
    POINT   pt;

    //
    // Just return if nothing to draw
    if (!ped->ichLinesOnScreen)
        return;

    ECGetBrush(ped, hdc);

    //
    // Adjust the value of ichStart such that we need to draw only those lines
    // visible on the screen.
    //
    if ((UINT)ichStart < (UINT)ped->chLines[ped->ichScreenStart]) {
        ichStart = ped->chLines[ped->ichScreenStart];
        if (ichStart > ichEnd)
            return;
    }

    // Adjust the value of ichEnd such that we need to draw only those lines
    // visible on the screen.
    wCurLine = min(ped->ichScreenStart+ped->ichLinesOnScreen,ped->cLines-1);
    ichT = ped->chLines[wCurLine] + MLLine(ped, wCurLine);
    ichEnd = min(ichEnd, ichT);

    wCurLine = MLIchToLine(ped, ichStart);    // Starting line.
    wEndLine = MLIchToLine(ped, ichEnd);           // Ending line.

    UserAssert(ped->chLines[wCurLine] <= ped->cch + 1);
    UserAssert(ped->chLines[wEndLine] <= ped->cch + 1);

    if (fSelChange && (GetBkMode(hdc) != OPAQUE))
    {
        /*
         * if changing selection on a transparent edit control, just
         * draw those lines from scratch
         */
        RECT rcStrip;
        CopyRect(&rcStrip, &ped->rcFmt);
        rcStrip.left -= ped->wLeftMargin;
        if (ped->pLpkEditCallout) {
            rcStrip.right += ped->wRightMargin;
        }
        rcStrip.top += (wCurLine - ped->ichScreenStart) * ped->lineHeight;
        rcStrip.bottom = rcStrip.top + ((wEndLine - wCurLine) + 1) * ped->lineHeight;
        NtUserInvalidateRect(ped->hwnd, &rcStrip, TRUE);
        return;
    }

    // If it is either centered or right-justified, then draw the whole lines.
    // Also draw whole lines if the language pack is handling line layout.
    if ((ped->format != ES_LEFT) || (ped->pLpkEditCallout)) {
        ichStart = ped->chLines[wCurLine];
        ichEnd = ped->chLines[wEndLine] + MLLine(ped, wEndLine);
    }

    pText = ECLock(ped);

    NtUserHideCaret(ped->hwnd);

    //
    // If ichStart stays on Second byte of DBCS, we have to
    // adjust it. LiZ -- 5/5/93
    //
    if (ped->fAnsi && ped->fDBCS) {
        ichStart = ECAdjustIch( ped, pText, ichStart );
    }
    UserAssert(ichStart <= ped->cch);
    UserAssert(ichEnd <= ped->cch);

    while (ichStart <= ichEnd) {
        // Pass whole lines to the language pack to display with selection
        // marking and tab expansion.
        if (ped->pLpkEditCallout) {
            ped->pLpkEditCallout->EditDrawText(
                ped, hdc, pText + ped->cbChar*ichStart,
                MLLine(ped, wCurLine),
                (INT)ped->ichMinSel - (INT)ichStart, (INT)ped->ichMaxSel - (INT)ichStart,
                MLIchToYPos(ped, ichStart, FALSE));
        } else {
        // xStPos:      The starting Position where the string must be drawn.
        // xClipStPos:  The starting position for the clipping rect for the block.
        // xClipEndPos: The ending position for the clipping rect for the block.

        // Calculate the xyPos of starting point of the block.
        MLIchToXYPos(ped, hdc, ichStart, FALSE, &pt);
        xClipStPos = xStPos = pt.x;
        yPos = pt.y;

        // The attributes of the block is the same as that of ichStart.
        ichAttrib = ichStart;

        // If the current font has some negative C widths and if this is the
        // begining of a block, we must start drawing some characters before the
        // block to account for the negative C widths of the strip before the
        // current strip; In this case, reset ichStart and xStPos.

        if (fFirstLineOfBlock && ped->wMaxNegC) {
            fFirstLineOfBlock = FALSE;
            ichNewStart = max(((int)(ichStart - ped->wMaxNegCcharPos)), ((int)ped->chLines[wCurLine]));

            // If ichStart needs to be changed, then change xStPos also accordingly.
            if (ichNewStart != ichStart) {
                if (ped->fAnsi && ped->fDBCS) {
                    //
                    // Adjust DBCS alignment...
                    //
                    ichNewStart = ECAdjustIchNext( ped, pText, ichNewStart );
                }
                MLIchToXYPos(ped, hdc, ichStart = ichNewStart, FALSE, &pt);
                xStPos = pt.x;
            }
        }

        // Calc the number of characters remaining to be drawn in the current line.
        iRemainingLengthInLine = MLLine(ped, wCurLine) -
                                (ichStart - ped->chLines[wCurLine]);

        // If this is the last line of a block, we may not have to draw all the
        // remaining lines; We must draw only upto ichEnd.
        if (wCurLine == wEndLine)
            LengthToDraw = ichEnd - ichStart;
        else
            LengthToDraw = iRemainingLengthInLine;

        // Find out how many pixels we indent the line for non-left-justified
        // formats
        if (ped->format != ES_LEFT)
            xOffset = MLCalcXOffset(ped, hdc, wCurLine);
        else
            xOffset = -((int)(ped->xOffset));

        // Check if this is the begining of a line.
        if (ichAttrib == ped->chLines[wCurLine]) {
            fLineBegins = TRUE;
            xClipStPos = ped->rcFmt.left - ped->wLeftMargin;
        }

        //
        // The following loop divides this 'wCurLine' into strips based on the
        // selection attributes and draw them strip by strip.
        do  {
            //
            // If ichStart is pointing at CRLF or CRCRLF, then iRemainingLength
            // could have become negative because MLLine does not include
            // CR and LF at the end of a line.
            //
            if (iRemainingLengthInLine < 0)  // If Current line is completed,
                break;                   // go on to the next line.

            //
            // Check if a part of the block is selected and if we need to
            // show it with a different attribute.
            //
            if (!(ped->ichMinSel == ped->ichMaxSel ||
                        ichAttrib >= ped->ichMaxSel ||
                        ichEnd   <  ped->ichMinSel ||
                        (!ped->fNoHideSel && !ped->fFocus))) {
                //
                // OK! There is a selection somewhere in this block!
                // Check if this strip has selection attribute.
                //
                if (ichAttrib < ped->ichMinSel) {
                    fSelected = FALSE;  // This strip is not selected

                    // Calculate the length of this strip with normal attribute.
                    CurStripLength = min(ichStart+LengthToDraw, ped->ichMinSel)-ichStart;
                    fLineBegins = FALSE;
                } else {
                    // The current strip has the selection attribute.
                    if (fLineBegins) {  // Is it the first part of a line?
                        // Then, draw the left margin area with normal attribute.
                        fSelected = FALSE;
                        CurStripLength = 0;
                        xClipStPos = ped->rcFmt.left - ped->wLeftMargin;
                        fLineBegins = FALSE;
                    } else {
                        // Else, draw the strip with selection attribute.
                        fSelected = TRUE;
                        CurStripLength = min(ichStart+LengthToDraw, ped->ichMaxSel)-ichStart;

                        // Select in the highlight colors.
                        bkColorSave = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                        if (!ped->fDisabled)
                            textColorSave = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                    }
                }
            } else {
                // The whole strip has no selection attributes.
                CurStripLength = LengthToDraw;
            }

            //
            // Other than the current strip, do we still have anything
            // left to be drawn in the current line?
            //
            fDrawOnSameLine = (LengthToDraw != CurStripLength);

            //
            // When we draw this strip, we need to draw some more characters
            // beyond the end of this strip to account for the negative A
            // widths of the characters that follow this strip.
            //
            ExtraLengthForNegA = min(iRemainingLengthInLine-CurStripLength, ped->wMaxNegAcharPos);

            //
            // The blank strip at the end of the line needs to be drawn with
            // normal attribute irrespective of whether the line has selection
            // attribute or not. Hence, if the last strip of the line has selection
            // attribute, then this blank strip needs to be drawn separately.
            // Else, we can draw the blank strip along with the last strip.
            //

            // Is this the last strip of the current line?
            if (iRemainingLengthInLine == (int)CurStripLength) {
                if (fSelected) { // Does this strip have selection attribute?
                    // Then we need to draw the end of line strip separately.
                    fDrawEndOfLineStrip = TRUE;  // Draw the end of line strip.
                    MLIchToXYPos(ped, hdc, ichStart+CurStripLength, TRUE, &pt);
                    xClipEndPos = pt.x;
                } else {
                    //
                    // Set the xClipEndPos to a big value sothat the blank
                    // strip will be drawn automatically when the last strip
                    // is drawn.
                    //
                    xClipEndPos = MAXCLIPENDPOS;
                }
            } else {
                //
                // This is not the last strip of this line; So, set the ending
                // clip position accurately.
                //
                MLIchToXYPos(ped, hdc, ichStart+CurStripLength, FALSE, &pt);
                xClipEndPos = pt.x;
            }

            //
            // Draw the current strip starting from xStPos, clipped to the area
            // between xClipStPos and xClipEndPos. Obtain "NegCInfo" and use it
            // in drawing the next strip.
            //
            ECTabTheTextOut(hdc, xClipStPos, xClipEndPos,
                    xStPos, yPos, (LPSTR)(pText+ichStart*ped->cbChar),
                CurStripLength+ExtraLengthForNegA, ichStart, ped,
                ped->rcFmt.left+xOffset, fSelected ? ECT_SELECTED : ECT_NORMAL, &NegCInfo);

            if (fSelected) {
                //
                // If this strip was selected, then the next strip won't have
                // selection attribute
                //
                fSelected = FALSE;
                SetBkColor(hdc, bkColorSave);
                if (!ped->fDisabled)
                    SetTextColor(hdc, textColorSave);
            }

            // Do we have one more strip to draw on the current line?
            if (fDrawOnSameLine || fDrawEndOfLineStrip) {
                int  iLastDrawnLength;

                //
                // Next strip's attribute is decided based on the char at ichAttrib
                //
                ichAttrib = ichStart + CurStripLength;

                //
                // When drawing the next strip, start at a few chars before
                // the actual start to account for the Neg 'C' of the strip
                // just drawn.
                //
                iLastDrawnLength = CurStripLength +ExtraLengthForNegA - NegCInfo.nCount;
                //
                // Adjust DBCS alignment...
                //
                if (ped->fAnsi && ped->fDBCS) {
                    ichNewStart = ECAdjustIch(ped,pText,ichStart+iLastDrawnLength);
                    iLastDrawnLength = ichNewStart - ichStart;
                    ichStart = ichNewStart;
                } else {
                    ichStart += iLastDrawnLength;
                }
                LengthToDraw -= iLastDrawnLength;
                iRemainingLengthInLine -= iLastDrawnLength;

                //
                // The start of clip rect for the next strip.
                //
                xStPos = NegCInfo.XStartPos;
                xClipStPos = xClipEndPos;
            }

            // Draw the blank strip at the end of line seperately, if required.
            if (fDrawEndOfLineStrip) {
                ECTabTheTextOut(hdc, xClipStPos, MAXCLIPENDPOS, xStPos, yPos,
                    (LPSTR)(pText+ichStart*ped->cbChar), LengthToDraw, ichStart,
                    ped, ped->rcFmt.left+xOffset, ECT_NORMAL, &NegCInfo);

                fDrawEndOfLineStrip = FALSE;
            }
        }
        while(fDrawOnSameLine);   // do while loop ends here.
        }

        // Let us move on to the next line of this block to be drawn.
        wCurLine++;
        if (ped->cLines > wCurLine)
            ichStart = ped->chLines[wCurLine];
        else
            ichStart = ichEnd+1;   // We have reached the end of the text.
    }  // while loop ends here

    ECUnlock(ped);

    NtUserShowCaret(ped->hwnd);
    MLSetCaretPosition(ped, hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\edmlonce.c ===
/****************************************************************************\
* edmlonce.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* dec 1990 mikeke from win30
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* MLCreate
*
* Creates the edit control for the window hwnd by allocating memory as
* required from the application's heap. Notifies parent if no memory error
* (after cleaning up if needed). Returns TRUE if no error else return s
* -1.
*
* History:
\***************************************************************************/
LONG MLCreate(
    PED ped,
    LPCREATESTRUCT lpCreateStruct)
{
    LONG windowStyle;
    LPWSTR lpszName;

    /*
     * Get values from the window instance data structure and put them in
     * the ped so that we can access them easier.
     */
    windowStyle = ped->pwnd->style;

    /*
     * Do the standard creation stuff.
     */
    if (!ECCreate(ped, windowStyle)) {
        return -1;
    }

    /*
     * Allocate line start array in local heap and lock it down.
     */
    ped->chLines = (LPICH)UserLocalAlloc(HEAP_ZERO_MEMORY, 2 * sizeof(int));
    if (ped->chLines == NULL) {
        return -1;
    }

    /*
     * Call it one line of text.
     */
    ped->cLines = 1;

    /*
     * If app wants WS_VSCROLL or WS_HSCROLL, it automatically gets
     * AutoVScroll or AutoHScroll.
     */
    if ((windowStyle & ES_AUTOVSCROLL) || (windowStyle & WS_VSCROLL)) {
        ped->fAutoVScroll = 1;
    }

    if (ped->format != ES_LEFT) {
        /*
         * If user wants right or center justified text, then we turn off
         * AUTOHSCROLL and WS_HSCROLL since non-left styles don't make sense
         * otherwise.
         */
        windowStyle &= ~WS_HSCROLL;
        ClearWindowState(ped->pwnd, WFHSCROLL);
        ped->fAutoHScroll = FALSE;
    } else if (windowStyle & WS_HSCROLL) {
        ped->fAutoHScroll = TRUE;
    }

    ped->fWrap = (!ped->fAutoHScroll && !(windowStyle & WS_HSCROLL));

    /*
     * Max # chars we will allow user to enter.
     */
    ped->cchTextMax = MAXTEXT;

    /*
     * Set the default font to be the system font.
     */
    ECSetFont(ped, NULL, FALSE);

    /*
     * Set the window text if needed and notify parent if not enough memory to
     * set the initial text.
     */
    if ((ULONG_PTR)lpCreateStruct->lpszName > gHighestUserAddress) {
        lpszName = REBASEPTR(ped->pwnd, (PVOID)lpCreateStruct->lpszName);
    } else {
        lpszName = (LPWSTR)lpCreateStruct->lpszName;
    }

    if (!ECSetText(ped, (LPSTR)lpszName)) {
        return -1;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\editsl.c ===
/****************************************************************************\
* editsl.c - Edit controls rewrite. Version II of edit controls.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Single Line Support Routines
*
* Created: 24-Jul-88 davidds
*
* Language pack notes:
*   With the language pack loaded all positional processing is based on
*   ped->xOffset rather than ped->ichScreenStart. The non-lpk optimisation of
*   maintaining ped->ichScreenStart doesn't work because of the
*   glyph reordering features of complex scripts.
*
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define SYS_ALTERNATE 0x2000

typedef BOOL (*FnGetTextExtentPoint)(HDC, PVOID, int, LPSIZE);

/***************************************************************************\
* SLCalcStringWidth
*
\***************************************************************************/

int SLCalcStringWidth(PED ped, HDC hdc, ICH ich, ICH cch)
{
    if (cch == 0)
        return 0;

    if (ped->charPasswordChar) {
        return cch * ped->cPasswordCharWidth;
    } else {
        SIZE size;

        if (ped->fNonPropFont && !ped->fDBCS) {
            size.cx = cch * ped->aveCharWidth;
        } else {
            PSTR pText = ECLock(ped);
            if (ped->fAnsi) {
                GetTextExtentPointA(hdc, (LPSTR)(pText + ich), cch, &size);
            } else {
                GetTextExtentPointW(hdc, (LPWSTR)pText + ich, cch, &size);
            }
            ECUnlock(ped);
        }
        return size.cx - ped->charOverhang;
    }
}

/***************************************************************************\
* SLCalcXOffsetLeft
*
* Calculates the starting offset for left-aligned strings.
*
\***************************************************************************/

int SLCalcXOffsetLeft(PED ped, HDC hdc, ICH ich)
{
    int cch = (int)(ich - ped->ichScreenStart);

    if (cch <= 0)
        return 0;

    return SLCalcStringWidth(ped, hdc, ped->ichScreenStart, cch);
}

/***************************************************************************\
* SLCalcXOffsetSpecial
*
* Calculates the horizontal offset (indent) required for right or center
* justified lines.
*
\***************************************************************************/

int SLCalcXOffsetSpecial(PED ped, HDC hdc, ICH ich)
{
    PSTR pText;
    ICH cch, ichStart = ped->ichScreenStart;
    int cx;

    /*
     * Calc the number of characters from start to right end.
     */
    pText = ECLock(ped);
    cch = ECCchInWidth(ped, hdc, (LPSTR)(pText + ichStart * ped->cbChar),
            ped->cch - ichStart, ped->rcFmt.right - ped->rcFmt.left, TRUE);
    ECUnlock(ped);

    /*
     * Once the last character of the string has been scrolled out of
     * the view, use normal offset calculation.
     */
    if (ped->ichScreenStart + cch < ped->cch)
        return SLCalcXOffsetLeft(ped, hdc, ich);

    cx = ped->rcFmt.right - ped->rcFmt.left - SLCalcStringWidth(ped,
            hdc, ichStart, cch);

    if (ped->format == ES_CENTER) {
         cx = max(0, cx / 2);
    } else if (ped->format == ES_RIGHT) {
        /*
         * Subtract 1 so that the 1 pixel wide cursor will be in the visible
         * region on the very right side of the screen, mle does this.
         */
        cx = max(0, cx - 1);
    }

    return cx + SLCalcStringWidth(ped, hdc, ichStart, ich - ichStart);
}

/***************************************************************************\
* SLSetCaretPosition AorW
*
* If the window has the focus, find where the caret belongs and move
* it there.
*
* History:
\***************************************************************************/

void SLSetCaretPosition(
    PED ped,
    HDC hdc)
{
    int xPosition;

    /*
     * We will only position the caret if we have the focus since we don't want
     * to move the caret while another window could own it.
     */
    if (!ped->fFocus)
        return;

    if (ped->fCaretHidden) {
        NtUserSetCaretPos(-20000, -20000);
        return;
    }

    xPosition = SLIchToLeftXPos(ped, hdc, ped->ichCaret);

    /*
     * Don't let caret go out of bounds of edit control if there is too much
     * text.
     */
    if (ped->pLpkEditCallout) {
        xPosition += ped->iCaretOffset;
        xPosition = max(xPosition , 0);
        xPosition = min(xPosition, ped->rcFmt.right - 1 -
            ((ped->cxSysCharWidth > ped->aveCharWidth) ? 1 : 2));
    } else {
        xPosition = min(xPosition, ped->rcFmt.right -
            ((ped->cxSysCharWidth > ped->aveCharWidth) ? 1 : 2));
    }

    NtUserSetCaretPos(xPosition, ped->rcFmt.top);

    // FE_IME SLSetCaretPosition - ECImmSetCompostionWindow( CFS_POINT )
    if (fpImmIsIME(THREAD_HKL())) {
        ECImmSetCompositionWindow(ped, xPosition, ped->rcFmt.top);
    }
}

/***************************************************************************\
* SLIchToLeftXPos AorW
*
* Given a character index, find its (left side) x coordinate within
* the ped->rcFmt rectangle assuming the character ped->ichScreenStart is at
* coordinates (ped->rcFmt.top, ped->rcFmt.left). A negative value is
* return ed if the character ich is to the left of ped->ichScreenStart. WARNING:
* ASSUMES AT MOST 1000 characters will be VISIBLE at one time on the screen.
* There may be 64K total characters in the editcontrol, but we can only
* display 1000 without scrolling. This shouldn't be a problem obviously.
* !NT
* History:
\***************************************************************************/

int SLIchToLeftXPos(
    PED ped,
    HDC hdc,
    ICH ich)
{
    int textExtent;
    PSTR pText;
    SIZE size;
    int  cchDiff;

    if (ped->pLpkEditCallout) {

       pText = ECLock(ped);
       textExtent = ped->pLpkEditCallout->EditIchToXY(ped, hdc, pText, ped->cch, ich);
       ECUnlock(ped);

       return textExtent;

    }

    /*
     * Check if we are adding lots and lots of chars. A paste for example could
     * cause this and GetTextExtents could overflow on this.
     */
    cchDiff = (int)ich - (int)ped->ichScreenStart;
    if (cchDiff > 1000)
        return (30000);
    else if (cchDiff < -1000)
        return (-30000);

    if (ped->format != ES_LEFT)
        return (ped->rcFmt.left + SLCalcXOffsetSpecial(ped, hdc, ich));

    /*
     * Caret position /w DBCS text, we can not optimize...
     */
    if (ped->fNonPropFont && !ped->fDBCS)
        return (ped->rcFmt.left + cchDiff*ped->aveCharWidth);

    /*
     * Check if password hidden chars are being used.
     */
    if (ped->charPasswordChar)
        return ( ped->rcFmt.left + cchDiff*ped->cPasswordCharWidth);

    pText = ECLock(ped);

    if (ped->fAnsi) {
        if (cchDiff >= 0) {

            GetTextExtentPointA(hdc, (LPSTR)(pText + ped->ichScreenStart),
                    cchDiff, &size);
            textExtent =  size.cx;

            /*
             * In case of signed/unsigned overflow since the text extent may be
             * greater than maxint. This happens with long single line edit
             * controls. The rect we edit text in will never be greater than 30000
             * pixels so we are ok if we just ignore them.
             */
            if (textExtent < 0 || textExtent > 31000)
                textExtent = 30000;
        } else {
            GetTextExtentPointA(hdc,(LPSTR)(pText + ich), -cchDiff, &size);
            textExtent = (-1) * size.cx;
        }
    } else {  //!fAnsi
        if (cchDiff >= 0) {

            GetTextExtentPointW(hdc, (LPWSTR)(pText + ped->ichScreenStart*sizeof(WCHAR)),
                    cchDiff, &size);
            textExtent =  size.cx;

            /*
             * In case of signed/unsigned overflow since the text extent may be
             * greater than maxint. This happens with long single line edit
             * controls. The rect we edit text in will never be greater than 30000
             * pixels so we are ok if we just ignore them.
             */
            if (textExtent < 0 || textExtent > 31000)
                textExtent = 30000;
        } else {
            GetTextExtentPointW(hdc,(LPWSTR)(pText + ich*sizeof(WCHAR)), -cchDiff, &size);
            textExtent = (-1) * size.cx;
        }
    }

    ECUnlock(ped);

    return (ped->rcFmt.left + textExtent -
            (textExtent ? ped->charOverhang : 0));
}

/***************************************************************************\
* SLSetSelection AorW
*
* Sets the PED to have the new selection specified.
*
* History:
\***************************************************************************/

void SLSetSelection(
    PED ped,
    ICH ichSelStart,
    ICH ichSelEnd)
{
    HDC hdc = ECGetEditDC(ped, FALSE );

    if (ichSelStart == 0xFFFFFFFF) {

        /*
         * Set no selection if we specify -1
         */
        ichSelStart = ichSelEnd = ped->ichCaret;
    }

    /*
     * Bounds ichSelStart, ichSelEnd are checked in SLChangeSelection...
     */
    SLChangeSelection(ped, hdc, ichSelStart, ichSelEnd);

    /*
     * Put the caret at the end of the selected text
     */
    ped->ichCaret = ped->ichMaxSel;

    SLSetCaretPosition(ped, hdc);

    /*
     * We may need to scroll the text to bring the caret into view...
     */
    SLScrollText(ped, hdc);

    ECReleaseEditDC(ped, hdc, FALSE);
}

/***************************************************************************\
*
*  SLGetClipRect()
*
\***************************************************************************/
void SLGetClipRect(
    PED     ped,
    HDC     hdc,
    ICH     ichStart,
    int     iCount,
    LPRECT  lpClipRect )
{
    int    iStCount;
    PSTR   pText;

    if (ped->pLpkEditCallout) {
        RIPMSG0(RIP_WARNING, "SLGetClipRect - Error - Invalid call with language pack loaded");
        RtlZeroMemory(lpClipRect, sizeof(RECT));
        return;
    }

    CopyRect(lpClipRect, &ped->rcFmt);

    pText = ECLock(ped) ;

    // Calculates the starting pos for this piece of text
    if ((iStCount = (int)(ichStart - ped->ichScreenStart)) > 0) {
        if (ped->format == ES_LEFT) {
            lpClipRect->left += SLCalcXOffsetLeft(ped, hdc, ichStart);
        }
    } else {
            // Reset the values to visible portions
            iCount -= (ped->ichScreenStart - ichStart);
            ichStart = ped->ichScreenStart;
    }

    if (ped->format != ES_LEFT) {
        lpClipRect->left += SLCalcXOffsetSpecial(ped, hdc, ichStart);
    }

    if (iCount < 0) {
        /*
         * This is not in the visible area of the edit control, so return
         * an empty rect.
         */
        SetRectEmpty(lpClipRect);
        ECUnlock(ped);
        return;
    }

    if (ped->charPasswordChar)
             lpClipRect->right = lpClipRect->left + ped->cPasswordCharWidth * iCount;
    else {
        SIZE size ;

        if ( ped->fAnsi) {
            GetTextExtentPointA(hdc, pText + ichStart, iCount, &size);
        } else {
            GetTextExtentPointW(hdc, ((LPWSTR)pText) + ichStart, iCount, &size);
        }
        lpClipRect->right = lpClipRect->left + size.cx - ped->charOverhang;
    }

    ECUnlock(ped);
}

/***************************************************************************\
* SLChangeSelection AorW
*
* Changes the current selection to have the specified starting and
* ending values. Properly highlights the new selection and unhighlights
* anything deselected. If NewMinSel and NewMaxSel are out of order, we swap
* them. Doesn't update the caret position.
*
* History:
\***************************************************************************/

void SLChangeSelection(
    PED ped,
    HDC hdc,
    ICH ichNewMinSel,
    ICH ichNewMaxSel)
{
    ICH temp;
    ICH ichOldMinSel;
    ICH ichOldMaxSel;

    if (ichNewMinSel > ichNewMaxSel) {
        temp = ichNewMinSel;
        ichNewMinSel = ichNewMaxSel;
        ichNewMaxSel = temp;
    }
    ichNewMinSel = min(ichNewMinSel, ped->cch);
    ichNewMaxSel = min(ichNewMaxSel, ped->cch);

    //
    // To avoid position to half of DBCS, check and ajust position if necessary
    //
    // We check ped->fDBCS and ped->fAnsi though ECAdjustIch checks these bits.
    // We're worrying about the overhead of EcLock and EcUnlock.
    //
    if (ped->fDBCS && ped->fAnsi) {
        PSTR pText;

        pText = ECLock(ped);
        ichNewMinSel = ECAdjustIch( ped, pText, ichNewMinSel );
        ichNewMaxSel = ECAdjustIch( ped, pText, ichNewMaxSel );
        ECUnlock(ped);
    }

    /*
     * Preserve the Old selection
     */
    ichOldMinSel = ped->ichMinSel;
    ichOldMaxSel = ped->ichMaxSel;

    /*
     * Set new selection
     */
    ped->ichMinSel = ichNewMinSel;
    ped->ichMaxSel = ichNewMaxSel;

    /*
     * We will find the intersection of current selection rectangle with the new
     * selection rectangle. We will then invert the parts of the two rectangles
     * not in the intersection.
     */
    if (_IsWindowVisible(ped->pwnd) && (ped->fFocus || ped->fNoHideSel)) {
        BLOCK Blk[2];
        int   i;
        RECT  rc;

        if (ped->fFocus)
            NtUserHideCaret(ped->hwnd);

        if (ped->pLpkEditCallout) {
            /*
             * The language pack handles display while complex script support present
             */
            PSTR pText;

            ECGetBrush(ped, hdc);   // Give user a chance to manipulate the DC
            pText = ECLock(ped);
            ped->pLpkEditCallout->EditDrawText(ped, hdc, pText, ped->cch, ped->ichMinSel, ped->ichMaxSel, ped->rcFmt.top);
            ECUnlock(ped);
        } else {
            Blk[0].StPos = ichOldMinSel;
            Blk[0].EndPos = ichOldMaxSel;
            Blk[1].StPos = ped->ichMinSel;
            Blk[1].EndPos = ped->ichMaxSel;

            if (ECCalcChangeSelection(ped, ichOldMinSel, ichOldMaxSel,
                (LPBLOCK)&Blk[0], (LPBLOCK)&Blk[1])) {

                //
                // Paint the rectangles where selection has changed.
                // Paint both Blk[0] and Blk[1], if they exist.
                //
                for (i = 0; i < 2; i++) {
                    if (Blk[i].StPos != 0xFFFFFFFF) {
                               SLGetClipRect(ped, hdc, Blk[i].StPos,
                                                       Blk[i].EndPos - Blk[i].StPos, (LPRECT)&rc);
                               SLDrawLine(ped, hdc, rc.left, rc.right, Blk[i].StPos,
                                                    Blk[i].EndPos - Blk[i].StPos,
                                          ((Blk[i].StPos >= ped->ichMinSel) &&
                                       (Blk[i].StPos < ped->ichMaxSel)));
                    }
                }
            }
        }

        //
        // Update caret.
        //
        SLSetCaretPosition(ped, hdc);

        if (ped->fFocus)
            NtUserShowCaret(ped->hwnd);
    }
}

/***************************************************************************\
*
*  SLDrawLine()
*
*  This draws the line starting from ichStart, iCount number of characters;
*  fSelStatus is TRUE if we're to draw the text as selected.
*
\***************************************************************************/
void SLDrawLine(
    PED     ped,
    HDC     hdc,
    int     xClipStPos,
    int     xClipEndPos,
    ICH     ichStart,
    int     iCount,
    BOOL    fSelStatus )
{
    RECT    rc;
    RECT    rcClip;
    PSTR    pText;
    DWORD   rgbSaveBk;
    DWORD   rgbSaveText;
    DWORD   wSaveBkMode;
    int     iStCount;
    ICH     ichNewStart;
    HBRUSH  hbrBack;

    if (ped->pLpkEditCallout) {
        RIPMSG0(RIP_WARNING, "SLDrawLine - Error - Invalid call with language pack loaded");
        return;
    }

    //
    // Anything to draw?
    //
    if (xClipStPos >= xClipEndPos || !_IsWindowVisible(ped->pwnd) )
        return;

    if (ped->fAnsi && ped->fDBCS) {
        PSTR pT,pTOrg;
        int iTCount;

        pText = ECLock(ped);
        ichNewStart = 0;
        if (ichStart > 0) {
            pT = pText + ichStart;
            ichNewStart = ichStart;

            while (ichNewStart &&
                  (ichStart - ichNewStart < ped->wMaxNegCcharPos)) {
                pT = ECAnsiPrev(ped, pText, pT);
                ichNewStart = (ICH)(pT - pText);
                if (!ichNewStart)
                    break;
            }

            // B#16152 - win95.
            // In case of T2, SLE always set an additional margin
            // to erase a character (iCount == 0 case), using aveCharWidth.
            // It erases unexpected an extra char if we don't use ichNewStart
            // and it happens when wMaxNegCcharPos == 0.
            //
            if (ped->wMaxNegCcharPos == 0 && iCount == 0) {
                pT = ECAnsiPrev(ped, pText, pT);
                ichNewStart = (ICH)(pT - pText);
            }
        }

        iTCount = 0;
        if (ichStart + iCount < ped->cch) {
            pTOrg = pT = pText + ichStart + iCount;
            while ((iTCount < (int)ped->wMaxNegAcharPos) &&
                   (ichStart + iCount + iTCount < ped->cch)) {
                pT = ECAnsiNext(ped, pT);
                iTCount = (int)(pT - pTOrg);
            }
        }

        ECUnlock(ped);
        iCount = (int)(min(ichStart+iCount+iTCount, ped->cch) - ichNewStart);
    } else {
        // Reset ichStart to take care of the negative C widths
        ichNewStart = max((int)(ichStart - ped->wMaxNegCcharPos), 0);

        // Reset ichCount to take care of the negative C and A widths
        iCount = (int)(min(ichStart+iCount+ped->wMaxNegAcharPos, ped->cch)
                    - ichNewStart);
    }
    ichStart = ichNewStart;

    //
    // Reset ichStart and iCount to the first one visible on the screen
    //
    if (ichStart < ped->ichScreenStart) {
        if (ichStart+iCount < ped->ichScreenStart)
            return;

        iCount -= (ped->ichScreenStart-ichStart);
        ichStart = ped->ichScreenStart;
    }

    CopyRect(&rc, &ped->rcFmt);

    //
    // Set the drawing rectangle
    //
    rcClip.left   = xClipStPos;
    rcClip.right  = xClipEndPos;
    rcClip.top    = rc.top;
    rcClip.bottom = rc.bottom;

    //
    // Set the proper clipping rectangle
    //
    ECSetEditClip(ped, hdc, TRUE);

    pText = ECLock(ped);

    //
    // Calculate the starting pos for this piece of text
    //
    if (ped->format == ES_LEFT) {
        if (iStCount = (int)(ichStart - ped->ichScreenStart)) {
            rc.left += SLCalcXOffsetLeft(ped, hdc, ichStart);
        }
    } else {
        rc.left += SLCalcXOffsetSpecial(ped, hdc, ichStart);
    }

    //
    // Set the background mode before calling NtUserGetControlBrush so that the app
    // can change it to TRANSPARENT if it wants to.
    //
    SetBkMode(hdc, OPAQUE);

    if (fSelStatus) {
        hbrBack = SYSHBR(HIGHLIGHT);
        if (hbrBack == NULL) {
            goto sldl_errorexit;
        }
        rgbSaveBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
        rgbSaveText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

    } else {
        //
        // We always want to send this so that the app has a chance to muck
        // with the DC.
        //
        // Note that ReadOnly and Disabled edit fields are drawn as "static"
        // instead of as "active."
        //
        hbrBack = ECGetBrush(ped, hdc);
        rgbSaveText = GetTextColor(hdc);
    }

    //
    // Erase the rectangular area before text is drawn. Note that we inflate
    // the rect by 1 so that the selection color has a one pixel border around
    // the text.
    //
    InflateRect(&rcClip, 0, 1);
    FillRect(hdc, &rcClip, hbrBack);
    InflateRect(&rcClip, 0, -1);

    if (ped->charPasswordChar) {
        wSaveBkMode = SetBkMode(hdc, TRANSPARENT);

        for (iStCount = 0; iStCount < iCount; iStCount++) {
            if ( ped->fAnsi )
                ExtTextOutA(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                            (LPSTR)&ped->charPasswordChar, 1, NULL);
            else
                ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                            (LPWSTR)&ped->charPasswordChar, 1, NULL);

            rc.left += ped->cPasswordCharWidth;
        }

        SetBkMode(hdc, wSaveBkMode);
    } else {
        if ( ped->fAnsi )
            ExtTextOutA(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                    pText+ichStart,iCount, NULL);
        else
            ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                    ((LPWSTR)pText)+ichStart,iCount, NULL);
    }

    SetTextColor(hdc, rgbSaveText);
    if (fSelStatus) {
        SetBkColor(hdc, rgbSaveBk);
    }

sldl_errorexit:
    ECUnlock(ped);
}

/***************************************************************************\
* SLGetBlkEnd AorW
*
* Given a Starting point and and end point, this function return s whether the
* first few characters fall inside or outside the selection block and if so,
* howmany characters?
*
* History:
\***************************************************************************/

int SLGetBlkEnd(
    PED ped,
    ICH ichStart,
    ICH ichEnd,
    BOOL FAR *lpfStatus)
{
    *lpfStatus = FALSE;
    if (ichStart >= ped->ichMinSel) {
        if (ichStart >= ped->ichMaxSel)
            return (ichEnd - ichStart);
        *lpfStatus = TRUE;
        return (min(ichEnd, ped->ichMaxSel) - ichStart);
    }
    return (min(ichEnd, ped->ichMinSel) - ichStart);
}

/***************************************************************************\
* SLDrawText AorW
*
* Draws text for a single line edit control in the rectangle
* specified by ped->rcFmt. If ichStart == 0, starts drawing text at the left
* side of the window starting at character index ped->ichScreenStart and draws
* as much as will fit. If ichStart > 0, then it appends the characters
* starting at ichStart to the end of the text showing in the window. (ie. We
* are just growing the text length and keeping the left side
* (ped->ichScreenStart to ichStart characters) the same. Assumes the hdc came
* from ECGetEditDC so that the caret and such are properly hidden.
*
* History:
\***************************************************************************/

void SLDrawText(
    PED ped,
    HDC hdc,
    ICH ichStart)
{
    ICH    cchToDraw;
    RECT   rc;
    PSTR   pText;
    BOOL   fSelStatus;
    int    iCount, iStCount;
    ICH    ichEnd;
    BOOL   fNoSelection;
    BOOL   fCalcRect;
    BOOL   fDrawLeftMargin = FALSE;
    BOOL   fDrawEndOfLineStrip = FALSE;
    SIZE   size;

    if (!_IsWindowVisible(ped->pwnd))
        return;

    if (ped->pLpkEditCallout) {
        // The language pack handles display while complex script support present
        ECGetBrush(ped, hdc);   // Give user a chance to manipulate the DC
        pText = ECLock(ped);
        ped->pLpkEditCallout->EditDrawText(ped, hdc, pText, ped->cch, ped->ichMinSel, ped->ichMaxSel, ped->rcFmt.top);
        ECUnlock(ped);
        SLSetCaretPosition(ped, hdc);
        return;
    }

    /*
     * When drawing the entire visible content of special-aligned sle
     * erase the view.
     */
    if (ped->format != ES_LEFT && ichStart == 0)
        FillRect(hdc, &ped->rcFmt, ECGetBrush(ped, hdc));

    pText = ECLock(ped);

    if (ichStart < ped->ichScreenStart) {
#if DBG
        ICH ichCompare = ECAdjustIch(ped, pText, ped->ichScreenStart);
        UserAssert(ichCompare == ped->ichScreenStart);
#endif
        ichStart = ped->ichScreenStart;
    }
    else if (ped->fDBCS && ped->fAnsi) {
        /*
         * If ichStart stays on trailing byte of DBCS, we have to
         * adjust it.
         */
        ichStart = ECAdjustIch(ped, pText, ichStart);
    }

    CopyRect((LPRECT)&rc, (LPRECT)&ped->rcFmt);

    /*
     * Find out how many characters will fit on the screen so that we don't do
     * any needless drawing.
     */
    cchToDraw = ECCchInWidth(ped, hdc,
            (LPSTR)(pText + ped->ichScreenStart * ped->cbChar),
            ped->cch - ped->ichScreenStart, rc.right - rc.left, TRUE);
    ichEnd = ped->ichScreenStart + cchToDraw;

    /*
     * There is no selection if,
     * 1. MinSel and MaxSel are equal OR
     * 2. (This has lost the focus AND Selection is to be hidden)
     */
    fNoSelection = ((ped->ichMinSel == ped->ichMaxSel) || (!ped->fFocus && !ped->fNoHideSel));

    if (ped->format == ES_LEFT) {
        if (iStCount = (int)(ichStart - ped->ichScreenStart)) {
            rc.left += SLCalcXOffsetLeft(ped, hdc, ichStart);
        }
    } else {
        rc.left += SLCalcXOffsetSpecial(ped, hdc, ichStart);
    }

    //
    // If this is the begining of the whole line, we may have to draw a blank
    // strip at the begining.
    //
    if ((ichStart == 0) && ped->wLeftMargin)
        fDrawLeftMargin = TRUE;

    //
    // If there is nothing to draw, that means we need to draw the end of
    // line strip, which erases the last character.
    //
    if (ichStart == ichEnd) {
        fDrawEndOfLineStrip = TRUE;
        rc.left -= ped->wLeftMargin;
    }

    while (ichStart < ichEnd) {
        fCalcRect = TRUE;

        if (fNoSelection) {
            fSelStatus = FALSE;
            iCount = ichEnd - ichStart;
        } else {
            if (fDrawLeftMargin) {
                iCount = 0;
                fSelStatus = FALSE;
                fCalcRect = FALSE;
                rc.right = rc.left;
            } else
                iCount = SLGetBlkEnd(ped, ichStart, ichEnd,
                    (BOOL  *)&fSelStatus);
        }


        if (ichStart+iCount == ichEnd) {
            if (fSelStatus)
                fDrawEndOfLineStrip = TRUE;
            else {
                rc.right = ped->rcFmt.right + ped->wRightMargin;
                fCalcRect = FALSE;
            }
        }

        if (fCalcRect) {
            if (ped->charPasswordChar)
                rc.right = rc.left + ped->cPasswordCharWidth * iCount;
            else {
                if ( ped->fAnsi )
                    GetTextExtentPointA(hdc, pText + ichStart,
                                        iCount, &size);
                else
                    GetTextExtentPointW(hdc, ((LPWSTR)pText) + ichStart,
                                        iCount, &size);
                rc.right = rc.left + size.cx;
                /*
                 * The extent is equal to the advance width. So for TrueType fonts
                 *  we need to take care of Neg A and C. For non TrueType, the extent
                 *  includes the overhang.
                 * If drawing the selection, draw only the advance width
                 */
                if (fSelStatus) {
                    rc.right -= ped->charOverhang;
                } else if (ped->fTrueType) {
                   rc.right += ped->wMaxNegC;
                   if (iStCount > 0) {
                      rc.right += ped->wMaxNegA;
                      iStCount = 0;
                   }
                }

            } /* if (ped->charPasswordChar) */

        }

        if (fDrawLeftMargin) {
            fDrawLeftMargin = FALSE;
            rc.left -= ped->wLeftMargin;
            if (rc.right < rc.left) {
                rc.right = rc.left;
            }
        }

        SLDrawLine(ped, hdc, rc.left, rc.right, ichStart, iCount, fSelStatus);
        ichStart += iCount;
        rc.left = rc.right;
        /*
         * If we're going to draw the selection, adjust rc.left
         * to include advance width of the selected text
         * For non TT fonts, ped->wMaxNegC equals ped->charOverhang
         */
        if (!fSelStatus && (iCount != 0) && (ichStart < ichEnd)) {
            rc.left -= ped->wMaxNegC;
        }
    }

    ECUnlock(ped);

    // Check if anything to be erased on the right hand side
    if (fDrawEndOfLineStrip &&
            (rc.left < (rc.right = (ped->rcFmt.right+ped->wRightMargin)))) {
        SLDrawLine(ped, hdc, rc.left, rc.right, ichStart, 0, 
            (ichEnd < ped->ichMaxSel) ? TRUE : FALSE);
    }

    SLSetCaretPosition(ped, hdc);
}

/***************************************************************************\
* SLScrollText AorW
*
* Scrolls the text to bring the caret into view. If the text is
* scrolled, the current selection is unhighlighted. Returns TRUE if the text
* is scrolled else return s false.
*
* History:
\***************************************************************************/

BOOL SLScrollText(
    PED ped,
    HDC hdc)
{
    PSTR pTextScreenStart;
    ICH scrollAmount;
    ICH newScreenStartX = ped->ichScreenStart;
    ICH cch;
    BOOLEAN fAdjustNext = FALSE;

    if (!ped->fAutoHScroll)
        return (FALSE);

    if (ped->pLpkEditCallout) {
        BOOL fChanged;

        // With complex script glyph reordering, use lpk to do horz scroll
        pTextScreenStart = ECLock(ped);
        fChanged = ped->pLpkEditCallout->EditHScroll(ped, hdc, pTextScreenStart);
        ECUnlock(ped);

        if (fChanged) {
            SLDrawText(ped, hdc, 0);
        }

        return fChanged;
    }

    /*
     * Calculate the new starting screen position
     */
    if (ped->ichCaret <= ped->ichScreenStart) {

        /*
         * Caret is to the left of the starting text on the screen we must
         * scroll the text backwards to bring it into view. Watch out when
         * subtracting unsigned numbers when we have the possibility of going
         * negative.
         */
        pTextScreenStart = ECLock(ped);

        scrollAmount = ECCchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                ped->ichCaret, (ped->rcFmt.right - ped->rcFmt.left) / 4, FALSE);

        newScreenStartX = ped->ichCaret - scrollAmount;
        ECUnlock(ped);
    } else if (ped->ichCaret != ped->ichScreenStart) {
        pTextScreenStart = ECLock(ped);
        pTextScreenStart += ped->ichScreenStart * ped->cbChar;

        cch = ECCchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                ped->ichCaret - ped->ichScreenStart,
                ped->rcFmt.right - ped->rcFmt.left, FALSE);

        if (cch < ped->ichCaret - ped->ichScreenStart) {
            fAdjustNext = TRUE;

            /*
             * Scroll Forward 1/4 -- if that leaves some empty space
             * at the end, scroll back enough to fill the space
             */
            newScreenStartX = ped->ichCaret - (3 * cch / 4);

            cch = ECCchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                    ped->cch - ped->ichScreenStart,
                    ped->rcFmt.right - ped->rcFmt.left, FALSE);

            if (newScreenStartX > (ped->cch - cch))
                newScreenStartX = ped->cch - cch;
        } else if (ped->format != ES_LEFT) {

            cch = ECCchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                    ped->cch - ped->ichScreenStart,
                    ped->rcFmt.right - ped->rcFmt.left, FALSE);

           /*
            * Scroll the text hidden behind the left border back
            * into view.
            */
           if (ped->ichScreenStart == ped->cch - cch) {

               pTextScreenStart -= ped->ichScreenStart * ped->cbChar;
               cch = ECCchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                       ped->cch, ped->rcFmt.right - ped->rcFmt.left, FALSE);

               newScreenStartX = ped->cch - cch;
           }
        }

        ECUnlock(ped);
    }

    //
    // Adjust newScreenStartX
    //
    if (ped->fAnsi && ped->fDBCS) {
        newScreenStartX = (fAdjustNext ? ECAdjustIchNext : ECAdjustIch)(ped,
                                                                        ECLock(ped),
                                                                        newScreenStartX);
        ECUnlock(ped);
    }

    if (ped->ichScreenStart != newScreenStartX) {
        // Check if we have to wipe out the left margin
        if (ped->wLeftMargin && (ped->ichScreenStart == 0)) {
            RECT   rc;
            HBRUSH hBrush;

            hBrush = ECGetBrush(ped, hdc);

            CopyInflateRect(&rc, &ped->rcFmt, 0, 1);
            rc.right = rc.left;
            rc.left -= ped->wLeftMargin;

            FillRect(hdc, &rc, hBrush);
        }

        ped->ichScreenStart = newScreenStartX;
        SLDrawText(ped, hdc, 0);

        // Caret pos is set by SLDrawText().
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* SLInsertText AorW
*
* Adds up to cchInsert characters from lpText to the ped starting at
* ichCaret. If the ped only allows a maximum number of characters, then we
* will only add that many characters to the ped and send a EN_MAXTEXT
* notification code to the parent of the ec. Also, if !fAutoHScroll, then we
* only allow as many chars as will fit in the client rectangle. The number of
* characters actually added is return ed (could be 0). If we can't allocate
* the required space, we notify the parent with EN_ERRSPACE and no characters
* are added.
*
* History:
\***************************************************************************/

ICH SLInsertText(
    PED ped,
    LPSTR lpText,
    ICH cchInsert)
{
    HDC hdc;
    PSTR pText;
    ICH cchInsertCopy = cchInsert;
    ICH cchT;
    int textWidth;
    SIZE size;

    /*
     * First determine exactly how many characters from lpText we can insert
     * into the ped.
     */
    if( ped->cchTextMax <= ped->cch)
       cchInsert = 0;
    else {
        if (!ped->fAutoHScroll) {
            pText = ECLock(ped);
            hdc = ECGetEditDC(ped, TRUE);

            cchInsert = min(cchInsert, (unsigned)(ped->cchTextMax - ped->cch));
            if (ped->charPasswordChar)
                textWidth = ped->cch * ped->cPasswordCharWidth;
            else {
                if (ped->fAnsi)
                    GetTextExtentPointA(hdc, (LPSTR)pText,  ped->cch, &size);
                else
                    GetTextExtentPointW(hdc, (LPWSTR)pText, ped->cch, &size);
                textWidth = size.cx;
            }
            cchT = ECCchInWidth(ped, hdc, lpText, cchInsert,
                                ped->rcFmt.right - ped->rcFmt.left -
                                textWidth, TRUE);
            cchInsert = min(cchInsert, cchT);

            ECUnlock(ped);
            ECReleaseEditDC(ped, hdc, TRUE);
        } else {
            cchInsert = min((unsigned)(ped->cchTextMax - ped->cch), cchInsert);
        }
    }


    /*
     * Now try actually adding the text to the ped
     */
    if (cchInsert && !ECInsertText(ped, lpText, &cchInsert)) {
        ECNotifyParent(ped, EN_ERRSPACE);
        return (0);
    }
    if (cchInsert)
        ped->fDirty = TRUE; /* Set modify flag */

    if (cchInsert < cchInsertCopy) {

        /*
         * Notify parent that we couldn't insert all the text requested
         */
        ECNotifyParent(ped, EN_MAXTEXT);
    }

    /*
     * Update selection extents and the caret position. Note that ECInsertText
     * updates ped->ichCaret, ped->ichMinSel, and ped->ichMaxSel to all be after
     * the inserted text.
     */
    return (cchInsert);
}

/***************************************************************************\
* SLPasteText AorW
*
* Pastes a line of text from the clipboard into the edit control
* starting at ped->ichMaxSel. Updates ichMaxSel and ichMinSel to point to
* the end of the inserted text. Notifies the parent if space cannot be
* allocated. Returns how many characters were inserted.
*
* History:
\***************************************************************************/

ICH PASCAL NEAR SLPasteText(
    PED ped)
{
    HANDLE hData;
    LPSTR lpchClip;
    ICH cchAdded = 0;
    ICH clipLength;

    if (!OpenClipboard(ped->hwnd))
        goto PasteExitNoCloseClip;

    if (!(hData = GetClipboardData(ped->fAnsi ? CF_TEXT : CF_UNICODETEXT)) ||
            (GlobalFlags(hData) == GMEM_INVALID_HANDLE)) {
        RIPMSG1(RIP_WARNING, "SLPasteText(): couldn't get a valid handle(%x)", hData);
        goto PasteExit;
    }

    USERGLOBALLOCK(hData, lpchClip);
    if (lpchClip == NULL) {
        RIPMSG1(RIP_WARNING, "SLPasteText(): USERGLOBALLOCK(%x) failed.", hData);
        goto PasteExit;
    }

    if (ped->fAnsi) {
        LPSTR lpchClip2 = lpchClip;

        /*
         * Find the first carrage return or line feed. Just add text to that point.
         */
        clipLength = (UINT)strlen(lpchClip);
        for (cchAdded = 0; cchAdded < clipLength; cchAdded++)
            if (*lpchClip2++ == 0x0D)
                break;

    } else { // !fAnsi
        LPWSTR lpwstrClip2 = (LPWSTR)lpchClip;

        /*
         * Find the first carrage return or line feed. Just add text to that point.
         */
        clipLength = (UINT)wcslen((LPWSTR)lpchClip);
        for (cchAdded = 0; cchAdded < clipLength; cchAdded++)
            if (*lpwstrClip2++ == 0x0D)
                break;
    }

    /*
     * Insert the text (SLInsertText checks line length)
     */
    cchAdded = SLInsertText(ped, lpchClip, cchAdded);

    USERGLOBALUNLOCK(hData);

PasteExit:
    NtUserCloseClipboard();

PasteExitNoCloseClip:
    return (cchAdded);
}

/***************************************************************************\
* SLReplaceSel AorW
*
* Replaces the text in the current selection with the given text.
*
* History:
\***************************************************************************/

void SLReplaceSel(
    PED ped,
    LPSTR lpText)
{
    UINT cchText;

    //
    // Delete text, putting it into the clean undo buffer.
    //
    ECEmptyUndo(Pundo(ped));
    ECDeleteText(ped);

    //
    // B#3356
    // Some apps do "clear" by selecting all of the text, then replacing it
    // with "", in which case SLInsertText() will return 0.  But that
    // doesn't mean failure...
    //
    if ( ped->fAnsi )
        cchText = strlen(lpText);
    else
        cchText = wcslen((LPWSTR)lpText);

    if (cchText) {
        BOOL fFailed;
        UNDO undo;
        HWND hwndSave;

        //
        // Save undo buffer, but DO NOT CLEAR IT!
        //
        ECSaveUndo(Pundo(ped), &undo, FALSE);

        hwndSave = ped->hwnd;
        fFailed = (BOOL) !SLInsertText(ped, lpText, cchText);
        if (!IsWindow(hwndSave))
            return;

        if (fFailed) {
            //
            // UNDO the previous edit.
            //
            ECSaveUndo(&undo, Pundo(ped), FALSE);
            SLUndo(ped);
            return;
        }
    }

    //
    // Success.  So update the display
    //
    ECNotifyParent(ped, EN_UPDATE);

    if (_IsWindowVisible(ped->pwnd)) {
        HDC hdc;

        hdc = ECGetEditDC(ped, FALSE);

        if (!SLScrollText(ped, hdc))
            SLDrawText(ped, hdc, 0);

        ECReleaseEditDC(ped, hdc, FALSE);
    }

    ECNotifyParent(ped, EN_CHANGE);

    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
}

/***************************************************************************\
* SLChar AorW
*
* Handles character input
*
* History:
\***************************************************************************/

void SLChar(
    PED ped,
    DWORD keyValue)
{
    HDC hdc;
    WCHAR keyPress;
    BOOL updateText = FALSE;
    HWND hwndSave = ped->hwnd;
    int InsertTextLen = 1;
    int DBCSkey;

    if (ped->fAnsi)
        keyPress = LOBYTE(keyValue);
    else
        keyPress = LOWORD(keyValue);

    if (ped->fMouseDown || (ped->fReadOnly && keyPress != 3)) {

        /*
         * Don't do anything if we are in the middle of a mousedown deal or if
         * this is a read only edit control, with exception of allowing
         * ctrl-C in order to copy to the clipboard.
         */
        return ;
    }

    if (IS_IME_ENABLED()) {
        ECInOutReconversionMode(ped, FALSE);
    }

    switch (keyPress) {
    case VK_BACK:
DeleteSelection:
        if (ECDeleteText(ped))
            updateText = TRUE;
        break;

    default:
        if (keyPress >= TEXT(' '))
        {
            /*
             * If this is in [a-z],[A-Z] and we are an ES_NUMBER
             * edit field, bail.
             */
            if (ped->f40Compat && TestWF(ped->pwnd, EFNUMBER)) {
                if (!ECIsCharNumeric(ped, keyPress)) {
                    goto IllegalChar;
                }
            }
            goto DeleteSelection;
        }
        break;
    }

    switch (keyPress) {
    case 3:

        /*
         * CTRL-C Copy
         */
        SendMessage(ped->hwnd, WM_COPY, 0, 0L);
        return;

    case VK_BACK:

        /*
         * Delete any selected text or delete character left if no sel
         */
        if (!updateText && ped->ichMinSel) {

            /*
             * There was no selection to delete so we just delete character
               left if available
             */
            //
            // Calling PrevIch rather than just doing a decrement for VK_BACK
            //
            ped->ichMinSel = ECPrevIch( ped, NULL, ped->ichMinSel);
            ECDeleteText(ped);
            updateText = TRUE;
        }
        break;

    case 22: /* CTRL-V Paste */
        SendMessage(ped->hwnd, WM_PASTE, 0, 0L);
        return;

    case 24: /* CTRL-X Cut */
        if (ped->ichMinSel == ped->ichMaxSel)
            goto IllegalChar;

        SendMessage(ped->hwnd, WM_CUT, 0, 0L);
        return;

    case 26: /* CTRL-Z Undo */
        SendMessage(ped->hwnd, EM_UNDO, 0, 0L);
        return;

    case VK_RETURN:
    case VK_ESCAPE:
        //
        // If this is an edit control for a combobox and the dropdown list
        // is visible, forward it up to the combo.
        //
        if (ped->listboxHwnd && SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0L)) {
            SendMessage(ped->hwndParent, WM_KEYDOWN, (WPARAM)keyPress, 0L);
        } else
            goto IllegalChar;
        return;

    default:
        if (keyPress >= 0x1E) {  // 1E,1F are unicode block and segment separators
            /*
             * Hide the cursor if typing, if the mouse is captured, do not mess with this
             * as it is going to desapear forever (no WM_SETCURSOR is sent to restore it
             * at the first mouse-move)
             * MCostea #166951
             */
            NtUserCallNoParam(SFI_ZZZHIDECURSORNOCAPTURE);

            if (IS_DBCS_ENABLED() && ped->fAnsi && (ECIsDBCSLeadByte(ped,(BYTE)keyPress))) {
                if ((DBCSkey = DbcsCombine(ped->hwnd, keyPress)) != 0 &&
                     SLInsertText(ped,(LPSTR)&DBCSkey, 2) == 2) {
                    InsertTextLen = 2;
                    updateText = TRUE;
                } else {
                    NtUserMessageBeep(0);
                }
            } else {  // Here the original code begins
                InsertTextLen = 1;
                if (SLInsertText(ped, (LPSTR)&keyPress, 1))
                    updateText = TRUE;
                else

                    /*
                     * Beep. Since we couldn't add the text
                     */
                    NtUserMessageBeep(0);
            } // Here the original code ends
        } else {

            /*
             * User hit an illegal control key
             */
IllegalChar:
            NtUserMessageBeep(0);
        }

        if (!IsWindow(hwndSave))
            return;
        break;
    }

    if (updateText) {

        /*
         * Dirty flag (ped->fDirty) was set when we inserted text
         */
        ECNotifyParent(ped, EN_UPDATE);
        hdc = ECGetEditDC(ped, FALSE);
        if (!SLScrollText(ped, hdc)) {
            if (ped->format == ES_LEFT) {
            //
            // Call SLDrawText with correct ichStart
            //
                SLDrawText(ped, hdc, max(0, (int)(ped->ichCaret - InsertTextLen - ped->wMaxNegCcharPos)));
            } else {
                /*
                 * We can't just draw from ichStart because string may have
                 * shifted because of alignment.
                 */
                SLDrawText(ped, hdc, 0);
            }
        }
        ECReleaseEditDC(ped, hdc, FALSE);
        ECNotifyParent(ped, EN_CHANGE);

        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }
}

/***************************************************************************\
* SLMoveSelectionRestricted AorW
*
* Moves the selection like MLMoveSelection, but also obeys limitations
* imposed by some languages such as Thai, where the cursor cannot stop
* between a character and it's attached vowel or tone marks.
*
* Only called if the language pack is loaded.
*
\***************************************************************************/

ICH SLMoveSelectionRestricted(
    PED  ped,
    ICH  ich,
    BOOL fLeft)
{
    PSTR pText;
    HDC  hdc;
    ICH  ichResult;

    pText = ECLock(ped);
    hdc = ECGetEditDC(ped, TRUE);
    ichResult = ped->pLpkEditCallout->EditMoveSelection(ped, hdc, pText, ich, fLeft);
    ECReleaseEditDC(ped, hdc, TRUE);
    ECUnlock(ped);

    return ichResult;
}

/***************************************************************************\
* SLKeyDown AorW
*
* Handles cursor movement and other VIRT KEY stuff. keyMods allows
* us to make SLKeyDownHandler calls and specify if the modifier keys (shift
* and control) are up or down. This is useful for imnplementing the
* cut/paste/clear messages for single line edit controls. If keyMods == 0,
* we get the keyboard state using GetKeyState(VK_SHIFT) etc. Otherwise, the
* bits in keyMods define the state of the shift and control keys.
*
* History:
\***************************************************************************/

void SLKeyDown(
    PED ped,
    DWORD virtKeyCode,
    int keyMods)
{
    HDC hdc;

    /*
     * Variables we will use for redrawing the updated text
     */
    ICH newMaxSel = ped->ichMaxSel;
    ICH newMinSel = ped->ichMinSel;

    /*
     * Flags for drawing the updated text
     */
    BOOL updateText = FALSE;
    BOOL changeSelection = FALSE; /* new selection is specified by
                                      newMinSel, newMaxSel */

    /*
     * Comparisons we do often
     */
    BOOL MinEqMax = (newMaxSel == newMinSel);
    BOOL MinEqCar = (ped->ichCaret == newMinSel);
    BOOL MaxEqCar = (ped->ichCaret == newMaxSel);

    /*
     * State of shift and control keys.
     */
    int scState;

    /*
     * Combo box support
     */
    BOOL fIsListVisible;
    BOOL fIsExtendedUI;

    if (ped->fMouseDown) {

        /*
         * If we are in the middle of a mouse down handler, then don't do
         * anything. ie. ignore keyboard input.
         */
        return;
    }

    scState = ECGetModKeys(keyMods);

    switch (virtKeyCode) {
    case VK_UP:
        if ( ped->listboxHwnd ) {

            /*
             * Handle Combobox support
             */
            fIsExtendedUI = (BOOL)SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0);
            fIsListVisible = (BOOL)SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0);

            if (!fIsListVisible && fIsExtendedUI) {

                /*
                 * For TandyT
                 */
DropExtendedUIListBox:

                /*
                 * Since an extendedui combo box doesn't do anything on f4, we
                 * turn off the extended ui, send the f4 to drop, and turn it
                 * back on again.
                 */
                SendMessage(ped->hwndParent, CB_SETEXTENDEDUI, 0, 0);
                SendMessage(ped->listboxHwnd, WM_KEYDOWN, VK_F4, 0);
                SendMessage(ped->hwndParent, CB_SETEXTENDEDUI, 1, 0);
                return;
            } else
                goto SendKeyToListBox;
        }

    /*
     * else fall through
     */
    case VK_LEFT:
        //
        // If the caret isn't at the beginning, we can move left
        //
        if (ped->ichCaret) {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) {
                // Move caret word left
                ECWord(ped, ped->ichCaret, TRUE, &ped->ichCaret, NULL);
            } else {
                // Move caret char left
                if (ped->pLpkEditCallout) {
                    ped->ichCaret = SLMoveSelectionRestricted(ped, ped->ichCaret, TRUE);
                } else
                ped->ichCaret = ECPrevIch(ped,NULL,ped->ichCaret);
            }

            //
            // Get new selection
            //
            if (scState & SHFTDOWN) {
                if (MaxEqCar && !MinEqMax) {
                    // Reduce selection
                    newMaxSel = ped->ichCaret;

                    UserAssert(newMinSel == ped->ichMinSel);
                } else {
                    // Extend selection
                    newMinSel = ped->ichCaret;
                }
            } else {
                //
                // Clear selection
                //
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } else {
            //
            // If the user tries to move left and we are at the 0th
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) {
                changeSelection = TRUE;
                newMaxSel = newMinSel = ped->ichCaret;
            }
        }
        break;

    case VK_DOWN:
        if (ped->listboxHwnd) {

            /*
             * Handle Combobox support
             */
            fIsExtendedUI = (BOOL)SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0);
            fIsListVisible = (BOOL)SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0);

            if (!fIsListVisible && fIsExtendedUI) {

                /*
                 * For TandyT
                 */
                goto DropExtendedUIListBox;
            } else
                goto SendKeyToListBox;
        }

    /*
     * else fall through
     */
    case VK_RIGHT:
        //
        // If the caret isn't at the end, we can move right.
        //
        if (ped->ichCaret < ped->cch) {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) {
                // Move caret word right
                ECWord(ped, ped->ichCaret, FALSE, NULL, &ped->ichCaret);
            } else {
                // Move caret char right
                if (ped->pLpkEditCallout) {
                    ped->ichCaret = SLMoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } else
                ped->ichCaret = ECNextIch(ped,NULL,ped->ichCaret);
            }

            //
            // Get new selection.
            //
            if (scState & SHFTDOWN) {
                if (MinEqCar && !MinEqMax) {
                    // Reduce selection
                    newMinSel = ped->ichCaret;

                    UserAssert(newMaxSel == ped->ichMaxSel);
                } else {
                    // Extend selection
                    newMaxSel = ped->ichCaret;
                }
            } else {
                // Clear selection
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } else {
            //
            // If the user tries to move right and we are at the last
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) {
                newMaxSel = newMinSel = ped->ichCaret;
                changeSelection = TRUE;
            }
        }
        break;

    case VK_HOME:
        //
        // Move caret to top.
        //
        ped->ichCaret = 0;

        //
        // Update selection.
        //
        if (scState & SHFTDOWN) {
            if (MaxEqCar && !MinEqMax) {
                // Reduce selection
                newMinSel = ped->ichCaret;
                newMaxSel = ped->ichMinSel;
            } else {
                // Extend selection
                newMinSel = ped->ichCaret;
            }
        } else {
            // Clear selection
            newMaxSel = newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    case VK_END:
        //
        // Move caret to end.
        //
        ped->ichCaret = ped->cch;

        //
        // Update selection.
        //
        newMaxSel = ped->ichCaret;
        if (scState & SHFTDOWN) {
            if (MinEqCar && !MinEqMax) {
                // Reduce selection
                newMinSel = ped->ichMaxSel;
            }
        } else {
            // Clear selection
            newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    case VK_DELETE:
        if (ped->fReadOnly)
            break;

        switch (scState) {
        case NONEDOWN:

            /*
             * Clear selection. If no selection, delete (clear) character
             * right.
             */
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) {

                /*
                 * Move cursor forwards and simulate a backspace.
                 */
                if (ped->pLpkEditCallout) {
                    ped->ichMinSel = ped->ichCaret;
                    ped->ichMaxSel = ped->ichCaret = SLMoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } else {
                    ped->ichCaret = ECNextIch(ped,NULL,ped->ichCaret);
                    ped->ichMaxSel = ped->ichMinSel = ped->ichCaret;
                }
                SLChar(ped, (UINT)VK_BACK);
            }
            if (ped->ichMinSel != ped->ichMaxSel)
                SLChar(ped, (UINT)VK_BACK);
            break;

        case SHFTDOWN:

            //
            // Send ourself a WM_CUT message if a selection exists.
            // Otherwise, delete the left character.
            //
            if (ped->ichMinSel == ped->ichMaxSel) {
                UserAssert(!ped->fEatNextChar);
                SLChar(ped, VK_BACK);
            } else
                SendMessage(ped->hwnd, WM_CUT, 0, 0L);

            break;

        case CTRLDOWN:

            /*
             * Delete to end of line if no selection else delete (clear)
             * selection.
             */
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) {

                /*
                 * Move cursor to end of line and simulate a backspace.
                 */
                ped->ichMaxSel = ped->ichCaret = ped->cch;
            }
            if (ped->ichMinSel != ped->ichMaxSel)
                SLChar(ped, (UINT)VK_BACK);
            break;

        }

        /*
         * No need to update text or selection since BACKSPACE message does it
         * for us.
         */
        break;

    case VK_INSERT:
        switch (scState) {
        case CTRLDOWN:

            /*
             * Copy current selection to clipboard
             */
            SendMessage(ped->hwnd, WM_COPY, 0, 0);
            break;

        case SHFTDOWN:
            SendMessage(ped->hwnd, WM_PASTE, 0, 0L);
            break;
        }
        break;

    // VK_HANJA support
    case VK_HANJA:
        if ( HanjaKeyHandler( ped ) ) {
            changeSelection = TRUE;
            newMinSel = ped->ichCaret;
            newMaxSel = ped->ichCaret + (ped->fAnsi ? 2 : 1);
        }
        break;

    case VK_F4:
    case VK_PRIOR:
    case VK_NEXT:

        /*
         * Send keys to the listbox if we are a part of a combo box. This
         * assumes the listbox ignores keyup messages which is correct right
         * now.
         */
SendKeyToListBox:
        if (ped->listboxHwnd) {

            /*
             * Handle Combobox support
             */
            SendMessage(ped->listboxHwnd, WM_KEYDOWN, virtKeyCode, 0L);
            return;
        }
    }

    if (changeSelection || updateText) {
        hdc = ECGetEditDC(ped, FALSE);

        /*
         * Scroll if needed
         */
        SLScrollText(ped, hdc);

        if (changeSelection)
            SLChangeSelection(ped, hdc, newMinSel, newMaxSel);

        if (updateText)
            SLDrawText(ped, hdc, 0);

        ECReleaseEditDC(ped, hdc, FALSE);
        if (updateText) {
            ECNotifyParent(ped, EN_CHANGE);
            NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        }
    }
}

/***************************************************************************\
* SLMouseToIch AorW
*
* Returns the closest cch to where the mouse point is.
*
* History:
\***************************************************************************/

ICH SLMouseToIch(
    PED ped,
    HDC hdc,
    LPPOINT mousePt)
{
    PSTR pText;
    int width = mousePt->x;
    int lastHighWidth, lastLowWidth;
    SIZE size;
    ICH cch;
    ICH cchLo, cchHi;
    LPSTR lpText;
    FnGetTextExtentPoint pGetTextExtentPoint;

    if (ped->pLpkEditCallout) {
        pText = ECLock(ped);
        cch = ped->pLpkEditCallout->EditMouseToIch(ped, hdc, pText, ped->cch, width);
        ECUnlock(ped);
        return cch;
    }

    if (width <= ped->rcFmt.left) {

        /*
         * Return either the first non visible character or return 0 if at
         * beginning of text
         */
        if (ped->ichScreenStart) {
            cch = ECAdjustIch(ped, ECLock(ped), ped->ichScreenStart - 1);
            ECUnlock(ped);
            return cch;
        }
        else {
            return 0;
        }
    }

    if (width > ped->rcFmt.right) {
        pText = ECLock(ped);

        /*
         * Return last char in text or one plus the last char visible
         */
        cch = ECCchInWidth(ped, hdc,
                (LPSTR)(pText + ped->ichScreenStart * ped->cbChar),
                ped->cch - ped->ichScreenStart, ped->rcFmt.right -
                ped->rcFmt.left, TRUE) + ped->ichScreenStart;

        //
        // This is marked as JAPAN in Win31J. But it should be a DBCS
        // issue. LiZ -- 5/5/93
        // We must check DBCS Lead byte. Because ECAdjustIch() pick up Prev Char.
        //  1993.3.9 by yutakas
        //
        if (ped->fAnsi && ped->fDBCS) {
            if (cch >= ped->cch) {
                cch = ped->cch;
            } else {
                if (ECIsDBCSLeadByte(ped,*(pText+cch))) {
                    cch += 2;
                } else {
                    cch ++;
                }
            }
            ECUnlock(ped);
            return cch;
        } else {
            ECUnlock(ped);
            if (cch >= ped->cch)
                return (ped->cch);
            else
                return (cch + 1);
        }
    }

    if (ped->format != ES_LEFT) {
        width -= SLCalcXOffsetSpecial(ped, hdc, ped->ichScreenStart);
    }

    /*
     * Check if password hidden chars are being used.
     */
    if (ped->charPasswordChar)
        return min( (DWORD)( (width - ped->rcFmt.left) / ped->cPasswordCharWidth),
                    ped->cch);

    if (!ped->cch)
        return (0);

    pText = ECLock(ped);
    lpText = pText + ped->ichScreenStart * ped->cbChar;

    pGetTextExtentPoint = ped->fAnsi ? (FnGetTextExtentPoint)GetTextExtentPointA
                                     : (FnGetTextExtentPoint)GetTextExtentPointW;
    width -= ped->rcFmt.left;

    /*
     * If the user clicked past the end of the text, return the last character
     */
    cchHi = ped->cch - ped->ichScreenStart;
    pGetTextExtentPoint(hdc, lpText, cchHi, &size);
    if (size.cx <= width) {
        cch = cchHi;
        goto edAdjust;
    }
    /*
     * Initialize Binary Search Bounds
     */
    cchLo = 0;
    cchHi ++;
    lastLowWidth = 0;
    lastHighWidth = size.cx;

    /*
     * Binary search for closest char
     */
    while (cchLo < cchHi - 1) {

        cch = (cchHi + cchLo) / 2;
        pGetTextExtentPoint(hdc, lpText, cch, &size);

        if (size.cx <= width) {
            cchLo = cch;
            lastLowWidth = size.cx;
        } else {
            cchHi = cch;
            lastHighWidth = size.cx;
        }
    }

    /*
     * When the while ends, you can't know the exact position.
     * Try to see if the mouse pointer was on the farest half
     * of the char we got and if so, adjust cch.
     */
    if (cchLo == cch) {
        /*
         * Need to compare with lastHighWidth
         */
        if ((lastHighWidth - width) < (width - size.cx)) {
            cch++;
        }
    } else {
        /*
         * Need to compare with lastLowWidth
         */
        if ((width - lastLowWidth) < (size.cx - width)) {
            cch--;
        }
    }

edAdjust:
    //
    // Avoid to point the intermediate of double byte character
    //
    cch = ECAdjustIch( ped, pText, cch + ped->ichScreenStart );
    ECUnlock(ped);
    return ( cch );
}

/***************************************************************************\
* SLMouseMotion AorW
*
* <brief description>
*
* History:
\***************************************************************************/

void SLMouseMotion(
    PED ped,
    UINT message,
    UINT virtKeyDown,
    LPPOINT mousePt)
{
    DWORD   selectionl;
    DWORD   selectionh;
    BOOL    changeSelection;
    ICH     newMaxSel;
    ICH     newMinSel;
    HDC     hdc;
    ICH     mouseIch;
    LPSTR   pText;

    changeSelection = FALSE;

    newMinSel = ped->ichMinSel;
    newMaxSel = ped->ichMaxSel;

    hdc = ECGetEditDC(ped, FALSE);
    mouseIch = SLMouseToIch(ped, hdc, mousePt);

    switch (message) {
        case WM_LBUTTONDBLCLK:

            // if shift key is down, extend selection to word we double clicked on
            // else clear current selection and select word.

            // in DBCS, we have different word breaking. LiZ -- 5/5/93
            // In Hangeul Environment we use word selection feature because Hangeul
            // use SPACE as word break
            if (ped->fAnsi && ped->fDBCS) {
                pText = ECLock(ped) + mouseIch;
                ECWord(ped, mouseIch,
                       (ECIsDBCSLeadByte(ped,*pText) && mouseIch < ped->cch) ? FALSE : TRUE,
                       &selectionl, &selectionh);
                ECUnlock(ped);
            } else {
                ECWord(ped, mouseIch, (mouseIch) ? TRUE : FALSE, &selectionl, &selectionh);
            }

            if (!(virtKeyDown & MK_SHIFT)) {
                // If shift key isn't down, move caret to mouse point and clear
                // old selection
                newMinSel = selectionl;
                newMaxSel = ped->ichCaret = selectionh;
            } else {
                // Shiftkey is down so we want to maintain the current selection
                // (if any) and just extend or reduce it
                if (ped->ichMinSel == ped->ichCaret) {
                    newMinSel = ped->ichCaret = selectionl;
                    ECWord(ped, newMaxSel, TRUE, &selectionl, &selectionh);
                } else {
                    newMaxSel = ped->ichCaret = selectionh;
                    ECWord(ped, newMinSel, FALSE, &selectionl, &selectionh);
                }
                /*
                 * v-ronaar: fix bug 24627 - edit selection is weird.
                 */
                ped->ichMaxSel = ped->ichCaret;
            }

            ped->ichStartMinSel = selectionl;
            ped->ichStartMaxSel = selectionh;

            goto InitDragSelect;

        case WM_MOUSEMOVE:
            //
            // We know the mouse button's down -- otherwise the OPTIMIZE
            // test would've failed in SLEditWndProc and never called
            //
            changeSelection = TRUE;

            // Extend selection, move caret word right
            if (ped->ichStartMinSel || ped->ichStartMaxSel) {
                // We're in WORD SELECT mode
                BOOL fReverse = (mouseIch <= ped->ichStartMinSel);

                ECWord(ped, mouseIch, !fReverse, &selectionl, &selectionh);

                if (fReverse) {
                    newMinSel = ped->ichCaret = selectionl;
                    newMaxSel = ped->ichStartMaxSel;
                } else {
                    newMinSel = ped->ichStartMinSel;
                    newMaxSel = ped->ichCaret = selectionh;
                }
            } else if ((ped->ichMinSel == ped->ichCaret) &&
                (ped->ichMinSel != ped->ichMaxSel))
                // Reduce selection extent
                newMinSel = ped->ichCaret = mouseIch;
            else
                // Extend selection extent
                newMaxSel = ped->ichCaret=mouseIch;
            break;

        case WM_LBUTTONDOWN:
            // If we currently don't have the focus yet, try to get it.
            if (!ped->fFocus) {
                if (!ped->fNoHideSel)
                    // Clear the selection before setting the focus so that we
                    // don't get refresh problems and flicker. Doesn't matter
                    // since the mouse down will end up changing it anyway.
                    ped->ichMinSel = ped->ichMaxSel = ped->ichCaret;

                NtUserSetFocus(ped->hwnd);

                //
                // BOGUS
                // (1) We should see if SetFocus() succeeds.
                // (2) We should ignore mouse messages if the first window
                //      ancestor with a caption isn't "active."
                //

                // If we are part of a combo box, then this is the first time
                // the edit control is getting the focus so we just want to
                // highlight the selection and we don't really want to position
                // the caret.
                if (ped->listboxHwnd)
                    break;

                // We yield at SetFocus -- text might have changed at that point
                // update selection and caret info accordingly
                // FIX for bug # 11743 -- JEFFBOG 8/23/91
                newMaxSel = ped->ichMaxSel;
                newMinSel = ped->ichMinSel;
                mouseIch  = min(mouseIch, ped->cch);
            }

            if (ped->fFocus) {
                // Only do this if we have the focus since a clever app may not
                // want to give us the focus at the SetFocus call above.
                if (!(virtKeyDown & MK_SHIFT)) {
                    // If shift key isn't down, move caret to mouse point and
                    // clear old selection
                    newMinSel = newMaxSel = ped->ichCaret = mouseIch;
                } else {
                    // Shiftkey is down so we want to maintain the current
                    // selection (if any) and just extend or reduce it
                    if (ped->ichMinSel == ped->ichCaret)
                        newMinSel = ped->ichCaret = mouseIch;
                    else
                        newMaxSel = ped->ichCaret = mouseIch;
                }

                ped->ichStartMinSel = ped->ichStartMaxSel = 0;

InitDragSelect:
                ped->fMouseDown = FALSE;
                NtUserSetCapture(ped->hwnd);
                ped->fMouseDown = TRUE;
                changeSelection = TRUE;
            }
            break;

        case WM_LBUTTONUP:
            if (ped->fMouseDown) {
                ped->fMouseDown = FALSE;
                NtUserReleaseCapture();
            }
            break;
    }

    if (changeSelection) {
        SLScrollText(ped,hdc);
        SLChangeSelection(ped, hdc, newMinSel, newMaxSel);
    }

    ECReleaseEditDC(ped, hdc, FALSE);
}

/***************************************************************************\
* SLPaint AorW
*
* Handles painting of the edit control window. Draws the border if
* necessary and draws the text in its current state.
*
* History:
\***************************************************************************/

void SLPaint(
    PED ped,
    HDC hdc)
{
    HWND   hwnd = ped->hwnd;
    HBRUSH hBrushRemote;
    RECT   rcEdit;
    HANDLE hOldFont;

    /*
     * Had to put in hide/show carets. The first one needs to be done before
     * beginpaint to correctly paint the caret if part is in the update region
     * and part is out. The second is for 1.03 compatibility. It breaks
     * micrografix's worksheet edit control if not there.
     */
    NtUserHideCaret(hwnd);

    if (_IsWindowVisible(ped->pwnd)) {
        /*
         * Erase the background since we don't do it in the erasebkgnd message.
         */
        hBrushRemote = ECGetBrush(ped, hdc);
        _GetClientRect(ped->pwnd, (LPRECT)&rcEdit);
        FillRect(hdc, &rcEdit, hBrushRemote);

        if (ped->fFlatBorder)
        {
            RECT    rcT;

            _GetClientRect(ped->pwnd, &rcT);
            DrawFrame(hdc, &rcT, 1, DF_WINDOWFRAME);
        }

        if (ped->hFont != NULL) {
            /*
             * We have to select in the font since this may be a subclassed dc
             * or a begin paint dc which hasn't been initialized with out fonts
             * like ECGetEditDC does.
             */
            hOldFont = SelectObject(hdc, ped->hFont);
        }

        SLDrawText(ped, hdc, 0);

        if (ped->hFont != NULL && hOldFont != NULL) {
            SelectObject(hdc, hOldFont);
        }
    }

    NtUserShowCaret(hwnd);
}

/***************************************************************************\
* SLSetFocus AorW
*
* Gives the edit control the focus and notifies the parent
* EN_SETFOCUS.
*
* History:
\***************************************************************************/

void SLSetFocus(
    PED ped)
{
    HDC hdc;

    if (!ped->fFocus) {

        ped->fFocus = TRUE; /* Set focus */

        /*
         * We don't want to muck with the caret since it isn't created.
         */
        hdc = ECGetEditDC(ped, TRUE);

        /*
         * Show the current selection if necessary.
         */
        if (!ped->fNoHideSel)
            SLDrawText(ped, hdc, 0);

        /*
         * Create the caret
         */
        if (ped->pLpkEditCallout) {
            ped->pLpkEditCallout->EditCreateCaret (ped, hdc, ECGetCaretWidth(),
                                                   ped->lineHeight, 0);
        }
        else {
            NtUserCreateCaret(ped->hwnd, (HBITMAP)NULL,
                    ECGetCaretWidth(),
                    ped->lineHeight );
        }
        SLSetCaretPosition(ped, hdc);
        ECReleaseEditDC(ped, hdc, TRUE);
        NtUserShowCaret(ped->hwnd);

    }

    /*
     * Notify parent we have the focus
     */
    ECNotifyParent(ped, EN_SETFOCUS);
}

/***************************************************************************\
* SLKillFocus AorW
*
* The edit control loses the focus and notifies the parent via
* EN_KILLFOCUS.
*
* History:
\***************************************************************************/

void SLKillFocus(
    PED ped,
    HWND newFocusHwnd)
{
    if (ped->fFocus) {

        /*
         * Destroy the caret (Win31/Chicago hides it first)
         */
        NtUserDestroyCaret();

        ped->fFocus = FALSE; /* Clear focus */
        /*
         * Do this only if we still have the focus. But we always notify the
         * parent that we lost the focus whether or not we originally had the
         * focus.
         */

        /*
         * Hide the current selection if needed
         */
        if (!ped->fNoHideSel && (ped->ichMinSel != ped->ichMaxSel)) {
            NtUserInvalidateRect(ped->hwnd, NULL, FALSE);
#if 0
            SLSetSelection(ped, ped->ichCaret, ped->ichCaret);
#endif
        }
    }

    /*
     * If we aren't a combo box, notify parent that we lost the focus.
     */
    if (!ped->listboxHwnd)
        ECNotifyParent(ped, EN_KILLFOCUS);
    else {

        /*
         * This editcontrol is part of a combo box and is losing the focus. If
         * the focus is NOT being sent to another control in the combo box
         * window, then it means the combo box is losing the focus. So we will
         * notify the combo box of this fact.
         */
        if ((newFocusHwnd == NULL) ||
                    (!IsChild(ped->hwndParent, newFocusHwnd))) {
            // Excel has a slaker in it's midst.  They're not using our combo
            // boxes, but they still expect to get all the internal messages
            // that we give to OUR comboboxes.  And they expect them to be at
            // the same offset from WM_USER as they were in 3.1.
            //                                           (JEFFBOG - 01/26/94)
            /*
             * Windows NT won't fix the bug described above: it only applies
             * to old 16-bit excel, and WOW converts msgs to Win3.1 values.
             */

            /*
             * Focus is being sent to a window which is not a child of the combo
             * box window which implies that the combo box is losing the focus.
             * Send a message to the combo box informing him of this fact so
             * that he can clean up...
             */
            SendMessage(ped->hwndParent, CBEC_KILLCOMBOFOCUS, 0, 0L);
        }
    }
}


/***************************************************************************\
*
*  SLPaste()
*
*  Does actual text paste and update.
*
\***************************************************************************/
void   SLPaste(PED ped)
{
    HDC hdc;

    //
    // Insert contents of clipboard, after unhilighting current selection
    // and deleting it.
    //
    ECDeleteText(ped);
    SLPasteText(ped);

    //
    // Update display
    //
    ECNotifyParent(ped, EN_UPDATE);

    hdc = ECGetEditDC(ped,FALSE);

    SLScrollText(ped, hdc);
    SLDrawText(ped, hdc, 0);

    ECReleaseEditDC(ped,hdc,FALSE);

    /*
     * Tell parent our text contents changed.
     */
    ECNotifyParent(ped, EN_CHANGE);
    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
}



/***************************************************************************\
* SLEditWndProc
*
* Class procedure for all single line edit controls.
* Dispatches all messages to the appropriate handlers which are named
* as follows:
* SL (single line) prefixes all single line edit control procedures while
* EC (edit control) prefixes all common handlers.
*
* The SLEditWndProc only handles messages specific to single line edit
* controls.
*
* WARNING: If you add a message here, add it to gawEditWndProc[] in
* kernel\server.c too, otherwise EditWndProcA/W will send it straight to
* DefWindowProcWorker
*
* History:
\***************************************************************************/

LRESULT SLEditWndProc(
    HWND hwnd,
    PED ped,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    POINT       pt;

    /*
     * Dispatch the various messages we can receive
     */
    switch (message) {

    case WM_INPUTLANGCHANGE:
        if (ped && ped->fFocus && ped->pLpkEditCallout) {
            NtUserHideCaret(hwnd);
            hdc = ECGetEditDC(ped, TRUE);
            NtUserDestroyCaret();
            ped->pLpkEditCallout->EditCreateCaret (ped, hdc, ECGetCaretWidth(), ped->lineHeight, (UINT)lParam);
            SLSetCaretPosition(ped, hdc);
            ECReleaseEditDC(ped, hdc, TRUE);
            NtUserShowCaret(hwnd);
        }
        goto PassToDefaultWindowProc;

    case WM_STYLECHANGED:
        if (ped && ped->pLpkEditCallout) {
            switch (wParam) {

                case GWL_STYLE:
                    ECUpdateFormat(ped,
                        ((LPSTYLESTRUCT)lParam)->styleNew,
                        GetWindowLong(ped->hwnd, GWL_EXSTYLE));
                    return 1L;

                case GWL_EXSTYLE:
                    ECUpdateFormat(ped,
                        GetWindowLong(ped->hwnd, GWL_STYLE),
                        ((LPSTYLESTRUCT)lParam)->styleNew);
                    return 1L;
            }
        }

        goto PassToDefaultWindowProc;

    case WM_CHAR:

        /*
         * wParam - the value of the key
           lParam - modifiers, repeat count etc (not used)
         */
        if (!ped->fEatNextChar)
            SLChar(ped, (UINT)wParam);
        else
            ped->fEatNextChar = FALSE;
        break;

    case WM_ERASEBKGND:

       /*
        * wParam - device context handle
        * lParam - not used
        * We do nothing on this message and we don't want DefWndProc to do
        * anything, so return 1
        */
        return (1L);
        break;

    case WM_GETDLGCODE: {
           LONG code = DLGC_WANTCHARS | DLGC_HASSETSEL | DLGC_WANTARROWS;

           /*
            * If this is a WM_SYSCHAR message generated by the UNDO keystroke
            * we want this message so we can EAT IT in "case WM_SYSCHAR:"
            */
            if (lParam) {
                switch (((LPMSG)lParam)->message) {
                    case WM_SYSCHAR:
                        if ((HIWORD(((LPMSG)lParam)->lParam) & SYS_ALTERNATE) &&
                            ((WORD)wParam == VK_BACK)) {
                            code |= DLGC_WANTMESSAGE;
                        }
                        break;

                    case WM_KEYDOWN:
                        if (( (((WORD)wParam == VK_RETURN) ||
                               ((WORD)wParam == VK_ESCAPE)) &&
                            (ped->listboxHwnd)      &&
                            TestWF(ValidateHwnd(ped->hwndParent), CBFDROPDOWN) &&
                            SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0L))) {
                            code |= DLGC_WANTMESSAGE;
                        }
                        break;
                }
            }
            return code;
        }

        break;

    case WM_KEYDOWN:

        /*
         * wParam - virt keycode of the given key
         * lParam - modifiers such as repeat count etc. (not used)
         */
        SLKeyDown(ped, (UINT)wParam, 0);
        break;

    case WM_KILLFOCUS:

        /*
         * wParam - handle of the window that receives the input focus
           lParam - not used
         */

        SLKillFocus(ped, (HWND)wParam);
        break;

    case WM_CAPTURECHANGED:
        if (ped->fMouseDown)
            ped->fMouseDown = FALSE;
        break;

    case WM_MOUSEMOVE:
        UserAssert(ped->fMouseDown);
        /*
         * FALL THRU
         */

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
        /*
         * wParam - contains a value that indicates which virtual keys are down
         * lParam - contains x and y coords of the mouse cursor
         */
        POINTSTOPOINT(pt, lParam);
        SLMouseMotion(ped, message, (UINT)wParam, &pt);
        break;

    case WM_CREATE:

        /*
         * wParam - handle to window being created
           lParam - points to a CREATESTRUCT that contains copies of parameters
                    passed to the CreateWindow function.
         */
        return (SLCreate(ped, (LPCREATESTRUCT)lParam));
        break;

    case WM_PRINTCLIENT:
        // wParam --    can be hdc from subclassed paint
        // lParam --    unused
        SLPaint(ped, (HDC) wParam);
        break;

    case WM_PAINT:

        /*
         * wParam --    can be hdc from subclassed paint
         * lParam --    unused
         */
        if (wParam)
            hdc = (HDC) wParam;
        else {
            // this hide/show caret is outside Begin/EndPaint to handle the
            // case when the caret is half in/half out of the update region
            NtUserHideCaret(hwnd);
            hdc = NtUserBeginPaint(hwnd, &ps);
        }

        if (_IsWindowVisible(ped->pwnd))
            SLPaint(ped, hdc);

        if (!wParam) {
            NtUserEndPaint(hwnd, &ps);
            NtUserShowCaret(hwnd);
        }
        break;

    case WM_PASTE:

        /*
         * wParam - not used
         * lParam - not used
         */
        if (!ped->fReadOnly)
            SLPaste(ped);
        break;

    case WM_SETFOCUS:

        /*
         * wParam - handle of window that loses the input focus (may be NULL)
           lParam - not used
         */
        SLSetFocus(ped);
        break;

    case WM_SIZE:

        /*
         * wParam - defines the type of resizing fullscreen, sizeiconic,
                    sizenormal etc.
           lParam - new width in LOWORD, new height in HIGHWORD of client area
         */
        ECSize(ped, NULL, TRUE);
        return 0L;

    case WM_SYSKEYDOWN:
        /*
         * wParam --    virtual key code
         * lParam --    modifiers
         */

        /*
         * Are we in a combobox with the Alt key down?
         */
        if (ped->listboxHwnd && (lParam & 0x20000000L)) {
            /*
             * Handle Combobox support. We want alt up or down arrow to behave
             * like F4 key which completes the combo box selection
             */
            if (lParam & 0x1000000) {

                /*
                 * This is an extended key such as the arrow keys not on the
                 * numeric keypad so just drop the combobox.
                 */
                if (wParam == VK_DOWN || wParam == VK_UP)
                    goto DropCombo;
                else
                    goto foo;
            }

            if (!(GetKeyState(VK_NUMLOCK) & 1) &&
                    (wParam == VK_DOWN || wParam == VK_UP)) {

                /*
                 * NUMLOCK is up and the keypad up or down arrow hit:
                 * eat character generated by keyboard driver.
                 */
                ped->fEatNextChar = TRUE;
            } else {
                goto foo;
            }

DropCombo:
            if (SendMessage(ped->hwndParent,
                    CB_GETEXTENDEDUI, 0, 0) & 0x00000001) {

                /*
                 * Extended ui doesn't honor VK_F4.
                 */
                if (SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0))
                    return(SendMessage(ped->hwndParent, CB_SHOWDROPDOWN, 0, 0));
                else
                    return (SendMessage(ped->hwndParent, CB_SHOWDROPDOWN, 1, 0));
            } else
                return (SendMessage(ped->listboxHwnd, WM_KEYDOWN, VK_F4, 0));
        }
foo:
        if (wParam == VK_BACK) {
            SendMessage(ped->hwnd, WM_UNDO, 0, 0L);
            break;
        }
        else
            goto PassToDefaultWindowProc;
        break;

    case EM_GETLINE:

        /*
         * wParam - line number to copy (always the first line for SL)
         * lParam - buffer to copy text to. FIrst word is max # of bytes to copy
         */
        return ECGetText(ped, (*(LPWORD)lParam), (LPSTR)lParam, FALSE);

    case EM_LINELENGTH:

        /*
         * wParam - ignored
         * lParam - ignored
         */
        return (LONG)ped->cch;
        break;

    case EM_SETSEL:
        /*
         * wParam -- start pos
         * lParam -- end pos
         */
        SLSetSelection(ped, (ICH)wParam, (ICH)lParam);
        break;

    case EM_REPLACESEL:

        /*
         * wParam - flag for 4.0+ apps saying whether to clear undo
         * lParam - points to a null terminated string of replacement text
         */
        SLReplaceSel(ped, (LPSTR)lParam);
        if (!ped->f40Compat || !wParam)
            ECEmptyUndo(Pundo(ped));
        break;

    case EM_GETFIRSTVISIBLELINE:

        /*
         * wParam - not used
         * lParam - not used
         *
         * effects: Returns the first visible line for single line edit controls.
         */
        return ped->ichScreenStart;
        break;

    case EM_POSFROMCHAR:
        //
        // wParam --    char index in text
        // lParam --    not used
        // This function returns the (x,y) position of the character.
        //      y is always 0 for single.
        //
    case EM_CHARFROMPOS:
        //
        // wParam --    unused
        // lParam --    pt in edit client coords
        // This function returns
        //          LOWORD: the position of the _closest_ char
        //                  to the passed in point.
        //          HIWORD: the index of the line (always 0 for single)

        {
            LONG xyPos;

            hdc = ECGetEditDC(ped, TRUE);

            if (message == EM_POSFROMCHAR)
                xyPos = MAKELONG(SLIchToLeftXPos(ped, hdc, (ICH)wParam), 0);
            else {
                POINTSTOPOINT(pt, lParam);
                xyPos = SLMouseToIch(ped, hdc, &pt);
            }

            ECReleaseEditDC(ped, hdc, TRUE);
            return((LRESULT)xyPos);
            break;
        }

    case WM_UNDO:
    case EM_UNDO:
        SLUndo(ped);
        break;

#if 0
    case WM_NCPAINT: // not in server.c gawEditWndProc[] anyway.

        /*
         * LATER - This is an NT optimization.  It needs to be revisited
         * for validity once all of the Chicago changes are done - Johnl
         */

        pwnd = (PWND)HtoP(hwnd);

        /*
         * Check to see if this window has any non-client areas that
         * would be painted.  If not, don't bother calling DefWindowProc()
         * since it'll be a wasted c/s transition.
         */
        if (!ped->fBorder &&
            TestWF(pwnd, WEFDLGMODALFRAME) == 0 &&
            !TestWF(pwnd, (WFMPRESENT | WFVPRESENT | WFHPRESENT)) &&
            TestWF(pwnd, WFSIZEBOX) == 0) {
            break;
        } else {
            goto PassToDefaultWindowProc;
        }
        break;
#endif

    default:
PassToDefaultWindowProc:
        return DefWindowProcWorker(ped->pwnd, message, wParam, lParam, ped->fAnsi);
        break;
    } /* switch (message) */

    return 1L;
} /* SLEditWndProc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\editec.c ===
/****************************************************************************\
* editec.c - Edit controls rewrite. Version II of edit controls.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Created: 24-Jul-88 davidds
\****************************************************************************/

/* Warning: The single line editcontrols contain internal styles and API which
 * are need to support comboboxes. They are defined in combcom.h/combcom.inc
 * and may be redefined or renumbered as needed.
 */

#include "precomp.h"
#pragma hdrstop

LOOKASIDE EditLookaside;

ICH ECFindTabA(LPSTR lpstr, ICH cch);
ICH ECFindTabW(LPWSTR lpstr, ICH cch);

#define umin(a, b)  ((unsigned)(a) < (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))
#define umax(a, b)  ((unsigned)(a) > (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))

#define UNICODE_CARRIAGERETURN ((WCHAR)0x0d)
#define UNICODE_LINEFEED ((WCHAR)0x0a)
#define UNICODE_TAB ((WCHAR)0x09)


// IME Menu IDs
#define ID_IMEOPENCLOSE      10001
#define ID_SOFTKBDOPENCLOSE  10002
#define ID_RECONVERTSTRING   10003

typedef struct {
    DWORD fDisableCut : 1;
    DWORD fDisablePaste : 1;
    DWORD fNeedSeparatorBeforeImeMenu : 1;
    DWORD fIME : 1;
} EditMenuItemState;

/***************************************************************************\
* Handlers common to both single and multi line edit controls.
/***************************************************************************/

/***************************************************************************\
* ECLock
*
* History:
\***************************************************************************/

PSTR ECLock(
    PED ped)
{
    PSTR ptext = LOCALLOCK(ped->hText, ped->hInstance);
    ped->iLockLevel++;

    /*
     * If this is the first lock of the text and the text is encoded
     * decode the text.
     */
    //RIPMSG2(RIP_VERBOSE, "lock  : %d '%10s'\n", ped->iLockLevel, ptext);
    if (ped->iLockLevel == 1 && ped->fEncoded) {
        /*
         * rtlrundecode can't handle zero length strings
         */
        if (ped->cch != 0) {
            STRING string;
            string.Length = string.MaximumLength = (USHORT)(ped->cch * ped->cbChar);
            string.Buffer = ptext;

            RtlRunDecodeUnicodeString(ped->seed, (PUNICODE_STRING)&string);
            //RIPMSG1(RIP_VERBOSE, "Decoding: '%10s'\n", ptext);
        }
        ped->fEncoded = FALSE;
    }
    return ptext;
}

/***************************************************************************\
* ECUnlock
*
* History:
\***************************************************************************/

void ECUnlock(
    PED ped)
{
    /*
     * if we are removing the last lock on the text and the password
     * character is set then encode the text
     */
    //RIPMSG1(RIP_VERBOSE, "unlock: %d '%10s'\n", ped->iLockLevel, ped->ptext);
    if (ped->charPasswordChar && ped->iLockLevel == 1 && ped->cch != 0) {
        UNICODE_STRING string;
        string.Length = string.MaximumLength = (USHORT)(ped->cch * ped->cbChar);
        string.Buffer = LOCALLOCK(ped->hText, ped->hInstance);

        RtlRunEncodeUnicodeString(&(ped->seed), &string);
        //RIPMSG1(RIP_VERBOSE, "Encoding: '%10s'\n", ped->ptext);
        ped->fEncoded = TRUE;
        LOCALUNLOCK(ped->hText, ped->hInstance);
    }
    LOCALUNLOCK(ped->hText, ped->hInstance);
    ped->iLockLevel--;
}

/***************************************************************************\
*
*  GetActualNegA()
*     For a given strip of text, this function computes the negative A width
* for the whole strip and returns the value as a postive number.
*     It also fills the NegAInfo structure with details about the postion
* of this strip that results in this Negative A.
*
\***************************************************************************/
UINT GetActualNegA(
    HDC hdc,
    PED ped,
    int x,
    LPSTR lpstring,
    ICH ichString,
    int nCount,
    LPSTRIPINFO NegAInfo)
{
    int iCharCount, i;
    int iLeftmostPoint = x;
    PABC  pABCwidthBuff;
    UINT  wCharIndex;
    int xStartPoint = x;
    ABC abc;

    // To begin with, let us assume that there is no negative A width for
    // this strip and initialize accodingly.

    NegAInfo->XStartPos = x;
    NegAInfo->lpString = lpstring;
    NegAInfo->nCount  = 0;
    NegAInfo->ichString = ichString;

    // If the current font is not a TrueType font, then there can not be any
    // negative A widths.
    if (!ped->fTrueType) {
        if(!ped->charOverhang) {
            return 0;
        } else {
            NegAInfo->nCount = min(nCount, (int)ped->wMaxNegAcharPos);
            return ped->charOverhang;
        }
    }

    // How many characters are to be considered for computing Negative A ?
    iCharCount = min(nCount, (int)ped->wMaxNegAcharPos);

    // Do we have the info on individual character's widths?
    if(!ped->charWidthBuffer) {
        // No! So, let us tell them to consider all the characters.
        NegAInfo->nCount = iCharCount;
        return(iCharCount * ped->aveCharWidth);
    }

    pABCwidthBuff = (PABC) ped->charWidthBuffer;

    if (ped->fAnsi) {
        for (i = 0; i < iCharCount; i++) {
            wCharIndex = (UINT)(*((unsigned char *)lpstring));
            if (*lpstring == VK_TAB) {
                // To play it safe, we assume that this tab results in a tab length of
                // 1 pixel because this is the minimum possible tab length.
                x++;
            } else {
                if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                    x += pABCwidthBuff[wCharIndex].abcA;  // Add the 'A' width.
                else {
                    GetCharABCWidthsA(hdc, wCharIndex, wCharIndex, &abc) ;
                    x += abc.abcA;
                }

                if (x < iLeftmostPoint)
                    iLeftmostPoint = x;             // Reset the leftmost point.
                if (x < xStartPoint)
                    NegAInfo->nCount = i+1;   // 'i' is index; To get the count add 1.

                if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH ) {
                    x += pABCwidthBuff[wCharIndex].abcB + pABCwidthBuff[wCharIndex].abcC;
                } else {
                    x += abc.abcB + abc.abcC;
                }
            }

            lpstring++;
        }
    } else {   // Unicode
        LPWSTR lpwstring = (LPWSTR) lpstring ;

        for (i = 0; i < iCharCount; i++) {
            wCharIndex = *lpwstring ;
            if (*lpwstring == VK_TAB) {
                // To play it safe, we assume that this tab results in a tab length of
                // 1 pixel because this is the minimum possible tab length.
                x++;
            } else {
                if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                    x += pABCwidthBuff[wCharIndex].abcA;  // Add the 'A' width.
                else {
                    GetCharABCWidthsW(hdc, wCharIndex, wCharIndex, &abc) ;
                    x += abc.abcA ;
                }

                if (x < iLeftmostPoint)
                    iLeftmostPoint = x;             // Reset the leftmost point.
                if (x < xStartPoint)
                    NegAInfo->nCount = i+1;   // 'i' is index; To get the count add 1.

                if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                    x += pABCwidthBuff[wCharIndex].abcB +
                         pABCwidthBuff[wCharIndex].abcC;
                else
                    x += abc.abcB + abc.abcC ;
            }

            lpwstring++;
        }
    }

    // Let us return the negative A for the whole strip as a positive value.
    return((UINT)(xStartPoint - iLeftmostPoint));
}


/***************************************************************************\
*
*  ECIsAncestorActive()
*
*  Returns whether or not we're the child of an "active" window.  Looks for
*  the first parent window that has a caption.
*
*  This is a function because we might use it elsewhere when getting left
*  clicked on, etc.
*
\***************************************************************************/
BOOL   ECIsAncestorActive(HWND hwnd)
{
    // We want to return TRUE always for top level windows.  That's because
    // of how WM_MOUSEACTIVATE works.  If we see the click at all, the
    // window is active.  However, if we reach a child ancestor that has
    // a caption, return the frame-on style bit.
    //
    // Note that calling FlashWindow() will have an effect.  If the user
    // clicks on an edit field in a child window that is flashed off, nothing
    // will happen unless the window stops flashing and ncactivates first.

    while (hwnd) {
        PWND pwnd = ValidateHwnd( hwnd );
        //
        // Bail out if some parent window isn't 4.0 compatible or we've
        // reached the top.  Fixes compatibility problems with 3.x apps,
        // especially MFC samples.
        //
        if (!TestWF(pwnd, WFWIN40COMPAT) || !TestWF(pwnd, WFCHILD))
            hwnd = NULL; // to break us out of the loop
        else if (TestWF(pwnd, WFCPRESENT))
            return(TestWF(pwnd, WFFRAMEON) != 0);
        else
            hwnd = GetParent(hwnd);
    }

    return(TRUE);
}

/***************************************************************************\
 * ECSetIMEMenu()
 *
 * support IME specific context menu
 *
 * Create: 30-Apr-97 Hiroyama : Ported from Memphis
\***************************************************************************/
BOOL ECSetIMEMenu(
    HMENU hMenu,
    HWND hwnd,
    EditMenuItemState state)
{

    MENUITEMINFO mii;
    HIMC hIMC;
    HKL hKL;
    HMENU hmenuSub;
    WCHAR szRes[32];
    int nPrevLastItem;
    int nItemsAdded = 0;

    UserAssert(IS_IME_ENABLED() && state.fIME);

    hKL = THREAD_HKL();
    if (!fpImmIsIME(hKL))
        return TRUE;

    hIMC = fpImmGetContext(hwnd);
    if (hIMC == NULL) {
        // early out
        return FALSE;
    }

    hmenuSub = GetSubMenu(hMenu, 0);

    if (hmenuSub == NULL) {
        return FALSE;
    }

    nPrevLastItem = GetMenuItemCount(hmenuSub);

    if (hIMC) {
        if (LOWORD(HandleToUlong(hKL)) != 0x412) {
            //
            // If Korean, do not show open/close menus
            //
            if (fpImmGetOpenStatus(hIMC))
                LoadString(hmodUser, STR_IMECLOSE, szRes, ARRAYSIZE(szRes));
            else
                LoadString(hmodUser, STR_IMEOPEN, szRes, ARRAYSIZE(szRes));

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szRes;
            mii.cch = 0xffff;
            mii.wID = ID_IMEOPENCLOSE;
            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }

        if (fpImmGetProperty(hKL, IGP_CONVERSION) & IME_CMODE_SOFTKBD) {
            DWORD fdwConversion;

            fpImmGetConversionStatus(hIMC, &fdwConversion, NULL);

            if (fdwConversion & IME_CMODE_SOFTKBD)
               LoadString(hmodUser, STR_SOFTKBDCLOSE, szRes, ARRAYSIZE(szRes));
            else
               LoadString(hmodUser, STR_SOFTKBDOPEN, szRes, ARRAYSIZE(szRes));

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szRes;
            mii.cch = 0xffff;
            mii.wID = ID_SOFTKBDOPENCLOSE;
            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }

        if (LOWORD(HandleToUlong(hKL)) != 0x412) {
            //
            // If Korean, do not show reconversion menus
            //
            DWORD dwSCS = fpImmGetProperty(hKL, IGP_SETCOMPSTR);

            LoadString(hmodUser, STR_RECONVERTSTRING, szRes, ARRAYSIZE(szRes));

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID | MIIM_STATE;
            mii.dwTypeData = szRes;
            mii.fState = 0;
            mii.cch = 0xffff;
            mii.wID = ID_RECONVERTSTRING;

            if (state.fDisableCut ||
                    !(dwSCS & SCS_CAP_SETRECONVERTSTRING) ||
                    !(dwSCS & SCS_CAP_MAKEREAD)) {
                mii.fState |= MFS_GRAYED;
            }

            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }
    }

    //
    // Add or remove the menu separator
    //
    if (state.fNeedSeparatorBeforeImeMenu && nItemsAdded != 0) {
        //
        // If the menu for Middle East has left a separator,
        // fNeedSeparatorBeforeImeMenu is FALSE.
        // I.e. we don't need to add more.
        //
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_FTYPE;
        mii.fType = MFT_SEPARATOR;
        InsertMenuItem(hmenuSub, nPrevLastItem, TRUE, &mii);
    }
    else if (!state.fNeedSeparatorBeforeImeMenu && nItemsAdded == 0) {
        //
        // Extra separator is left by ME menus. Remove it.
        //
        UserVerify(NtUserDeleteMenu(hmenuSub, nPrevLastItem - 1, MF_BYPOSITION));
    }

    fpImmReleaseContext(hwnd, hIMC);

    return TRUE;
}

void ECInOutReconversionMode(PED ped, BOOL fIn)
{
    UserAssert(fIn == TRUE || fIn == FALSE);
    if (fIn == ped->fInReconversion) {
        return;
    }
    ped->fInReconversion = fIn;
    if (ped->fFocus) {
        (fIn ? NtUserHideCaret: NtUserShowCaret)(ped->hwnd);
    }

    return;
}

/***************************************************************************\
 * ECDoIMEMenuCommand()
 *
 * support IME specific context menu
 *
 * Create: 30-Apr-97 Hiroyama : Ported from Memphis
\***************************************************************************/
BOOL NEAR ECDoIMEMenuCommand(PED ped, int cmd, HWND hwnd)
{
    HIMC hIMC;

    // early out
    switch (cmd) {
    case ID_IMEOPENCLOSE:
    case ID_SOFTKBDOPENCLOSE:
    case ID_RECONVERTSTRING:
        break;
    default:
        return FALSE;
    }

    // everybody needs hIMC, so get it here
    hIMC = fpImmGetContext(hwnd);
    if (hIMC == NULL) {
        // indicate to caller, that no further command processing needed
        return TRUE;
    }

    switch (cmd) {
    case ID_IMEOPENCLOSE:
        {
            // switch IME Open/Close status
            BOOL fOpen = fpImmGetOpenStatus(hIMC);

            fpImmSetOpenStatus(hIMC, !fOpen);
        }
        break;

    case ID_SOFTKBDOPENCLOSE:
        {
            DWORD fdwConversion;

            if (fpImmGetConversionStatus(hIMC, &fdwConversion, NULL)) {
                //
                // Toggle soft keyboard Open/Close status
                //
                fpImmEnumInputContext(0, SyncSoftKbdState,
                        (fdwConversion & IME_CMODE_SOFTKBD) != IME_CMODE_SOFTKBD);
            }
        }
        break;

    case ID_RECONVERTSTRING:
        {
            DWORD dwStrLen; // holds TCHAR count of recionversion string
            DWORD cbLen;    // holds BYTE SIZE of reconversion string
            DWORD dwSize;
            LPRECONVERTSTRING lpRCS;

            // pass current selection to IME for reconversion
            dwStrLen = ped->ichMaxSel - ped->ichMinSel;
            cbLen = dwStrLen * ped->cbChar;
            dwSize = cbLen + sizeof(RECONVERTSTRING) + 8;

            lpRCS = (LPRECONVERTSTRING)UserLocalAlloc(0, dwSize);

            if (lpRCS) {
                LPBYTE pText;
                ICH    ichSelMinOrg;

                ichSelMinOrg = ped->ichMinSel;

                pText = ECLock(ped);
                if (pText != NULL) {
                    LPBYTE lpDest;
                    BOOL (WINAPI* fpSetCompositionStringAW)(HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);

                    lpRCS->dwSize = dwSize;
                    lpRCS->dwVersion = 0;

                    lpRCS->dwStrLen =
                    lpRCS->dwCompStrLen =
                    lpRCS->dwTargetStrLen = dwStrLen;

                    lpRCS->dwStrOffset = sizeof(RECONVERTSTRING);
                    lpRCS->dwCompStrOffset =
                    lpRCS->dwTargetStrOffset = 0;

                    lpDest = (LPBYTE)lpRCS + sizeof(RECONVERTSTRING);

                    RtlCopyMemory(lpDest, pText + ped->ichMinSel * ped->cbChar, cbLen);
                    if (ped->fAnsi) {
                        LPBYTE psz = (LPBYTE)lpDest;
                        psz[cbLen] = '\0';
                        fpSetCompositionStringAW = fpImmSetCompositionStringA;
                    } else {
                        LPWSTR pwsz = (LPWSTR)lpDest;
                        pwsz[dwStrLen] = L'\0';
                        fpSetCompositionStringAW = fpImmSetCompositionStringW;
                    }

                    ECUnlock(ped);

                    UserAssert(fpSetCompositionStringAW != NULL);

                    ECInOutReconversionMode(ped, TRUE);
                    ECImmSetCompositionWindow(ped, 0, 0); // x and y will be overriden anyway

                    // Query the IME for a valid Reconvert string range first.
                    fpSetCompositionStringAW(hIMC, SCS_QUERYRECONVERTSTRING, lpRCS, dwSize, NULL, 0);

                    // If current IME updates the original reconvert structure,
                    // it is necessary to update the text selection based on the 
                    // new reconvert text range.
                    if ((lpRCS->dwCompStrLen != dwStrLen) || (ichSelMinOrg != ped->ichMinSel)) {
                        ICH ichSelStart;
                        ICH ichSelEnd;

                        ichSelStart = ichSelMinOrg + (lpRCS->dwCompStrOffset  / ped->cbChar);
                        ichSelEnd = ichSelStart + lpRCS->dwCompStrLen;

                        (ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_SETSEL, ichSelStart, ichSelEnd);
                    }

                    fpSetCompositionStringAW(hIMC, SCS_SETRECONVERTSTRING, lpRCS, dwSize, NULL, 0);
                } // pText
                UserLocalFree(lpRCS);
            }
        }
        break;

    default:
        // should never reach here.
        RIPMSG1(RIP_ERROR, "ECDoIMEMenuCommand: unknown command id %d; should never reach here.", cmd);
        return FALSE;
    }

    UserAssert(hIMC != NULL);
    fpImmReleaseContext(hwnd, hIMC);

    return TRUE;
}

/***************************************************************************\
*
*  ECMenu()
*
*  Handles context menu for edit fields.  Disables inappropriate commands.
*  Note that this is NOT subclassing friendly, like most of our functions,
*  for speed and convenience.
*
\***************************************************************************/
void  ECMenu(
    HWND hwnd,
    PED ped,
    LPPOINT pt)
{
    HMENU   hMenu;
    int     cmd = 0;
    int     x;
    int     y;
    UINT    uFlags = TPM_NONOTIFY | TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON;
    EditMenuItemState state = {
        FALSE,              // fDisableCut
        TRUE,               // fDisablePaste
        TRUE,               // fNeedSeparatorBeforeImeMenu
        IS_IME_ENABLED() && fpImmIsIME(THREAD_HKL()), // fIME
    };

    // Set focus if we don't have it.
    if (!ped->fFocus)
        NtUserSetFocus(hwnd);

    // Grab the menu from USER's resources...
    if (!(hMenu = LoadMenu( hmodUser, MAKEINTRESOURCE( ID_EC_PROPERTY_MENU ))))
        return ;


    // Undo -- not allowed if we have no saved undo info
    if (ped->undoType == UNDO_NONE)
        EnableMenuItem(hMenu, WM_UNDO, MF_BYCOMMAND | MFS_GRAYED);

    if (ped->fReadOnly || ped->charPasswordChar) {
        // Cut and Delete -- not allowed if read-only or password
        state.fDisableCut = TRUE;
    } else {
        // Cut, Delete -- not allowed if there's no selection
        if (ped->ichMinSel == ped->ichMaxSel)
            state.fDisableCut = TRUE;
    }
    // Paste -- not allowed if there's no text on the clipboard
    // (this works for both OEM and Unicode)
    // Used to be always disabled for password edits MCostea #221035

    if (NtUserIsClipboardFormatAvailable(CF_TEXT))
        state.fDisablePaste = FALSE;

    if (state.fDisableCut) {
        EnableMenuItem(hMenu, WM_CUT,   MF_BYCOMMAND | MFS_GRAYED);
        EnableMenuItem(hMenu, WM_CLEAR, MF_BYCOMMAND | MFS_GRAYED);
    }

    if (state.fDisablePaste)
        EnableMenuItem(hMenu, WM_PASTE, MF_BYCOMMAND | MFS_GRAYED);

    // Copy -- not allowed if there's no selection or password ec
    if ((ped->ichMinSel == ped->ichMaxSel) || (ped->charPasswordChar))
        EnableMenuItem(hMenu, WM_COPY, MF_BYCOMMAND | MFS_GRAYED);

    // Select All -- not allowed if there's no text or if everything is
    // selected.   Latter case takes care of first one.
    if ((ped->ichMinSel == 0) && (ped->ichMaxSel == ped->cch))
        EnableMenuItem(hMenu, EM_SETSEL, MF_BYCOMMAND | MFS_GRAYED);

    if (ped->pLpkEditCallout) {
        ped->pLpkEditCallout->EditSetMenu(ped, hMenu);
    } else {
        NtUserDeleteMenu(hMenu, ID_CNTX_DISPLAYCTRL, MF_BYCOMMAND);
        NtUserDeleteMenu(hMenu, ID_CNTX_RTL,         MF_BYCOMMAND);
        NtUserDeleteMenu(hMenu, ID_CNTX_INSERTCTRL,  MF_BYCOMMAND);

        if (state.fIME) {
            // One separator is left in the menu,
            // no need to add the one before IME menus
            state.fNeedSeparatorBeforeImeMenu = FALSE;
        } else {
            // Extra separator is left. Remove it.
            HMENU hmenuSub = GetSubMenu(hMenu, 0);
            int nItems = GetMenuItemCount(hmenuSub) - 1;

            UserAssert(nItems >= 0);
            UserAssert(GetMenuState(hmenuSub, nItems, MF_BYPOSITION) & MF_SEPARATOR);
            // remove needless separator
            UserVerify(NtUserDeleteMenu(hmenuSub, nItems, MF_BYPOSITION));
        }
    }

    // IME specific menu
    if (state.fIME) {
        ECSetIMEMenu(hMenu, hwnd, state);
    }

    // BOGUS
    // We position the menu below & to the right of the point clicked on.
    // Is this cool?  I think so.  Excel 4.0 does the same thing.  It
    // seems like it would be neat if we could avoid obscuring the
    // selection.  But in actuality, it seems even more awkward to move
    // the menu out of the way of the selection.  The user can't click
    // and drag that way, and they have to move the mouse a ton.
    //
    // We need to use TPM_NONOTIFY because VBRUN100 and VBRUN200 GP-fault
    // on unexpected menu messages.
    //

    /*
     *  if message came via the keyboard then center on the control
     *  We use -1 && -1 here not 0xFFFFFFFF like Win95 becuase we
     *  previously converted the lParam to a point with sign extending.
     */
    if (pt->x == -1 && pt->y == -1) {
        RECT rc;

        GetWindowRect(hwnd, &rc);
        x = rc.left + (rc.right - rc.left) / 2;
        y = rc.top + (rc.bottom - rc.top) / 2;
    } else {
        x = pt->x;
        y = pt->y;
    }

    if (RTL_UI()) {
        uFlags |= TPM_LAYOUTRTL;
    }
    cmd = NtUserTrackPopupMenuEx(GetSubMenu(hMenu, 0),  uFlags, x, y, hwnd, NULL);

    // Free our menu
    NtUserDestroyMenu(hMenu);

    if (cmd && (cmd != -1)) {
        if (ped->pLpkEditCallout && cmd) {
            ped->pLpkEditCallout->EditProcessMenu(ped, cmd);
        }
        if (!state.fIME || !ECDoIMEMenuCommand(ped, cmd, hwnd)) {
            // if cmd is not IME specific menu, send it.
            SendMessage(hwnd, cmd, 0, (cmd == EM_SETSEL) ? 0xFFFFFFFF : 0L );
        }
    }
}



/***************************************************************************\
*
*  ECClearText()
*
*  Clears selected text.  Does NOT _send_ a fake char backspace.
*
\***************************************************************************/
void   ECClearText(PED ped) {
    if (!ped->fReadOnly &&
        (ped->ichMinSel < ped->ichMaxSel)) {
        if (ped->fSingle)
            SLEditWndProc(ped->hwnd, ped, WM_CHAR, VK_BACK, 0L );
        else
            MLEditWndProc(ped->hwnd, ped, WM_CHAR, VK_BACK, 0L );
    }

}


/***************************************************************************\
*
*  ECCutText() -
*
*  Cuts selected text.  This removes and copies the selection to the clip,
*  or if nothing is selected we delete (clear) the left character.
*
\***************************************************************************/
void   ECCutText(PED ped) {
    // Cut selection--IE, remove and copy to clipboard, or if no selection,
    // delete (clear) character left.
    if (!ped->fReadOnly &&
        (ped->ichMinSel < ped->ichMaxSel) &&
        SendMessage(ped->hwnd, WM_COPY, 0, 0L)) {
        // If copy was successful, delete the copied text by sending a
        // backspace message which will redraw the text and take care of
        // notifying the parent of changes.
        ECClearText(ped);
    }
}

/***************************************************************************\
*
*  ECGetModKeys()
*
*  Gets modifier key states.  Currently, we only check for VK_CONTROL and
*  VK_SHIFT.
*
\***************************************************************************/
int   ECGetModKeys(int keyMods) {
    int scState;

    scState = 0;

    if (!keyMods) {
        if (GetKeyState(VK_CONTROL) < 0)
            scState |= CTRLDOWN;
        if (GetKeyState(VK_SHIFT) < 0)
            scState |= SHFTDOWN;
    } else if (keyMods != NOMODIFY)
        scState = keyMods;

    return scState;
}

/***************************************************************************\
*
*  ECTabTheTextOut() AorW
*    If fDrawText == FALSE, then this function returns the text extent of
*  of the given strip of text. It does not worry about the Negative widths.
*
*    If fDrawText == TRUE, this draws the given strip of Text expanding the
*  tabs to proper lengths, calculates and fills up the NegCInfoForStrip with
*  details required to draw the portions of this strip that goes beyond the
*  xClipEndPos due to Negative C widths.
*
*  Returns the max width AS A DWORD.  We don't care about the height
*  at all.  No one uses it.  We keep a DWORD because that way we avoid
*  overflow.
*
*  NOTE: If the language pack is loaded EcTabTheTextOut is not used - the
*  language pack must take care of all tab expansion and selection
*  highlighting with full support for bidi layout and complex script
*  glyph reordering.
*
\***************************************************************************/
UINT ECTabTheTextOut(
    HDC hdc,
    int xClipStPos,
    int xClipEndPos,
    int xStart,
    int y,
    LPSTR lpstring,
    int nCount,
    ICH ichString,
    PED ped,
    int iTabOrigin,
    BOOL fDraw,
    LPSTRIPINFO NegCInfoForStrip)
{
    int     nTabPositions;         // Count of tabstops in tabstop array.
    LPINT   lpintTabStopPositions; // Tab stop positions in pixels.

    int     cch;
    UINT    textextent;
    int     xEnd;
    int     pixeltabstop = 0;
    int     i;
    int     cxCharWidth;
    RECT    rc;
    BOOL    fOpaque;
    BOOL    fFirstPass = TRUE;
    PINT    charWidthBuff;

    int     iTabLength;
    int     nConsecutiveTabs;
    int     xStripStPos;
    int     xStripEndPos;
    int     xEndOfStrip;
    STRIPINFO  RedrawStripInfo;
    STRIPINFO  NegAInfo;
    LPSTR    lpTab;
    LPWSTR   lpwTab;
    UINT     wNegCwidth, wNegAwidth;
    int      xRightmostPoint = xClipStPos;
    int      xTabStartPos;
    int      iSavedBkMode = 0;
    WCHAR    wchar;
    SIZE     size;
    ABC   abc ;

    // Algorithm: Draw the strip opaquely first. If a tab length is so
    // small that the portions of text on either side of a tab overlap with
    // the other, then this will result in some clipping. So, such portion
    // of the strip is remembered in "RedrawStripInfo" and redrawn
    // transparently later to compensate the clippings.
    //    NOTE: "RedrawStripInfo" can hold info about just one portion. So, if
    // more than one portion of the strip needs to be redrawn transparently,
    // then we "merge" all such portions into a single strip and redraw that
    // strip at the end.

    if (fDraw) {
        // To begin with, let us assume that there is no Negative C for this
        // strip and initialize the Negative Width Info structure.
        NegCInfoForStrip->nCount = 0;
        NegCInfoForStrip->XStartPos = xClipEndPos;

        // We may not have to redraw any portion of this strip.
        RedrawStripInfo.nCount = 0;

        fOpaque = (GetBkMode(hdc) == OPAQUE) || (fDraw == ECT_SELECTED);
    }
#if DBG
    else {
        //
        // Both MLGetLineWidth() and ECCchInWidth() should be clipping
        // nCount to avoid overflow.
        //
        if (nCount > MAXLINELENGTH)
            RIPMSG0(RIP_WARNING, "ECTabTheTextOut: nCount > MAXLINELENGTH");
    }
#endif

    // Let us define the Clip rectangle.
    rc.left   = xClipStPos;
    rc.right  = xClipEndPos;
    rc.top    = y;
    rc.bottom = y + ped->lineHeight;

    // Check if anything needs to be drawn.
    if (!lpstring || !nCount) {
        if (fDraw)
            ExtTextOutW(hdc, xClipStPos, y,
                  (fOpaque ? ETO_OPAQUE | ETO_CLIPPED : ETO_CLIPPED),
                  &rc, L"", 0, 0L);
        return(0L);
    }

    //
    // Starting position
    //
    xEnd = xStart;

    cxCharWidth  = ped->aveCharWidth;

    nTabPositions = (ped->pTabStops ? *(ped->pTabStops) : 0);
    if (ped->pTabStops) {
        lpintTabStopPositions = (LPINT)(ped->pTabStops+1);
        if (nTabPositions == 1) {
            pixeltabstop = lpintTabStopPositions[0];
            if (!pixeltabstop)
                pixeltabstop = 1;
        }
    } else {
        lpintTabStopPositions = NULL;
        pixeltabstop = 8*cxCharWidth;
    }

    // The first time we will draw the strip Opaquely. If some portions need
    // to be redrawn , then we will set the mode to TRANSPARENT and
    // jump to this location to redraw those portions.

RedrawStrip:
    while (nCount) {
        wNegCwidth = ped->wMaxNegC;

        // Search for the first TAB in this strip; also compute the extent
        // of the the strip upto and not including the tab character.
        //
        // Note - If the langpack is loaded, there will be no charWidthBuffer.
        //
        if (ped->charWidthBuffer) {     // Do we have a character width buffer?
            textextent = 0;
            cch = nCount;

            if (ped->fTrueType) {     // If so, does it have ABC widths?

                UINT iRightmostPoint = 0;
                UINT wCharIndex;
                PABC pABCwidthBuff;

                pABCwidthBuff = (PABC) ped->charWidthBuffer;

                if ( ped->fAnsi ) {
                    for (i = 0; i < nCount; i++) {

                        if (lpstring[i] == VK_TAB) {
                            cch = i;
                            break;
                        }

                        wCharIndex = (UINT)(((unsigned char  *)lpstring)[i]);
                        if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH) {
                            textextent += (UINT)(pABCwidthBuff[wCharIndex].abcA +
                                pABCwidthBuff[wCharIndex].abcB);
                        } else {    // not in cache, will ask driver
                            GetCharABCWidthsA(hdc, wCharIndex, wCharIndex, &abc);
                            textextent += abc.abcA + abc.abcB ;
                        }

                        if (textextent > iRightmostPoint)
                            iRightmostPoint = textextent;

                        if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH) {
                            textextent += pABCwidthBuff[wCharIndex].abcC;
                        } else {    // not in cache
                            textextent += abc.abcC;
                        }

                        if (textextent > iRightmostPoint)
                            iRightmostPoint = textextent;
                    }

                } else {   // Unicode
                    for (i = 0; i < nCount; i++) {
                        WCHAR UNALIGNED * lpwstring = (WCHAR UNALIGNED *)lpstring;

                        if (lpwstring[i] == VK_TAB) {
                            cch = i;
                            break;
                        }

                        wCharIndex = lpwstring[i] ;
                        if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                            textextent += pABCwidthBuff[wCharIndex].abcA +
                                          pABCwidthBuff[wCharIndex].abcB;
                        else {
                            GetCharABCWidthsW(hdc, wCharIndex, wCharIndex, &abc) ;
                            textextent += abc.abcA + abc.abcB ;
                        }

                        /*
                         * Note that abcC could be negative so we need this
                         * statement here *and* below
                         */
                        if (textextent > iRightmostPoint)
                            iRightmostPoint = textextent;

                        if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                            textextent += pABCwidthBuff[wCharIndex].abcC;
                        else
                            textextent += abc.abcC ;

                        if (textextent > iRightmostPoint)
                            iRightmostPoint = textextent;
                    }
                }

                wNegCwidth = (int)(iRightmostPoint - textextent);
            } else {   // !ped->fTrueType
                // No! This is not a TrueType font; So, we have only character
                // width info in this buffer.

                charWidthBuff = ped->charWidthBuffer;

                if ( ped->fAnsi ) {
                    // Initially assume no tabs exist in the text so cch=nCount.
                    for (i = 0; i < nCount; i++) {
                        if (lpstring[i] == VK_TAB) {
                            cch = i;
                            break;
                        }

                        //
                        // Call GetTextExtentPoint for dbcs/hankaku characters
                        //
                        if (ped->fDBCS && (i+1 < nCount)
                                && ECIsDBCSLeadByte(ped,lpstring[i])) {
                            GetTextExtentPointA(hdc, &lpstring[i], 2, &size);
                            textextent += size.cx;
                            i++;
                        } else if ((UCHAR)lpstring[i] >= CHAR_WIDTH_BUFFER_LENGTH) {
                            // Skip this GetExtentPoint call for non hankaku code points
                            // Or if the character is in the width cache.
                            GetTextExtentPointA(hdc, &lpstring[i], 1, &size);
                            textextent += size.cx;
                        } else {
                            textextent += (UINT)(charWidthBuff[(UINT)(((unsigned char  *)lpstring)[i])]);
                        }
                    }
                } else {
                    LPWSTR lpwstring = (LPWSTR) lpstring ;
                    INT    cchUStart;  // start of unicode character count

                    for (i = 0; i < nCount; i++) {
                        if (lpwstring[i] == VK_TAB) {
                            cch = i;
                            break;
                        }

                        wchar = lpwstring[i];
                        if (wchar >= CHAR_WIDTH_BUFFER_LENGTH) {

                            /*
                             * We have a Unicode character that is not in our
                             * cache, get all the characters outside the cache
                             * before getting the text extent on this part of the
                             * string.
                             */
                            cchUStart = i;
                            while (wchar >= CHAR_WIDTH_BUFFER_LENGTH &&
                                    wchar != VK_TAB && i < nCount) {
                                wchar = lpwstring[++i];
                            }

                            GetTextExtentPointW(hdc, (LPWSTR)lpwstring + cchUStart,
                                    i-cchUStart, &size);
                            textextent += size.cx;


                            if (wchar == VK_TAB || i >= nCount) {
                                cch = i;
                                break;
                            }
                            /*
                             * We have a char that is in the cache, fall through.
                             */
                        }
                        /*
                         * The width of this character is in the cache buffer.
                         */
                        textextent += ped->charWidthBuffer[wchar];
                    }
                }
            } // fTrueType else.

            nCount -= cch;
        } else {  // If we don't have a buffer that contains the width info.
            /*
             * Gotta call the driver to do our text extent.
             */

            if ( ped->fAnsi ) {
                cch = (int)ECFindTabA(lpstring, nCount);
                GetTextExtentPointA(hdc, lpstring, cch, &size) ;
            } else {
                cch = (int)ECFindTabW((LPWSTR) lpstring, nCount);
                GetTextExtentPointW(hdc, (LPWSTR)lpstring, cch, &size);
            }
            nCount -= cch;
            //
            // Subtruct Overhang for Italic fonts.
            //
            textextent = (size.cx - ped->charOverhang);
        }

        //
        // textextent is computed.
        //

        xStripStPos = xEnd;
        xEnd += (int)textextent;
        xStripEndPos = xEnd;

        // We will consider the negative widths only if when we draw opaquely.
        if (fFirstPass && fDraw) {
            xRightmostPoint = max(xStripEndPos + (int)wNegCwidth, xRightmostPoint);

            // Check if this strip peeps beyond the clip region.
            if (xRightmostPoint > xClipEndPos) {
                if (!NegCInfoForStrip->nCount) {
                    NegCInfoForStrip->lpString = lpstring;
                    NegCInfoForStrip->ichString = ichString;
                    NegCInfoForStrip->nCount = nCount+cch;
                    NegCInfoForStrip->XStartPos = xStripStPos;
                }
            }
        }  /* if (fFirstPass && fDraw) */

        if ( ped->fAnsi )
            lpTab = lpstring + cch; // Possibly Points to a tab character.
        else
            lpwTab = ((LPWSTR)lpstring) + cch ;

        // we must consider all the consecutive tabs and calculate the
        // the begining of next strip.
        nConsecutiveTabs = 0;
        while (nCount &&
               (ped->fAnsi ? (*lpTab == VK_TAB) : (*lpwTab == VK_TAB))) {
            // Find the next tab position and update the x value.
            xTabStartPos = xEnd;
            if (pixeltabstop)
                xEnd = (((xEnd-iTabOrigin)/pixeltabstop)*pixeltabstop) +
                    pixeltabstop + iTabOrigin;
            else {
                for (i = 0; i < nTabPositions; i++) {
                    if (xEnd < (lpintTabStopPositions[i] + iTabOrigin)) {
                        xEnd = (lpintTabStopPositions[i] + iTabOrigin);
                        break;
                    }
                 }

                // Check if all the tabstops set are exhausted; Then start using
                // default tab stop positions.
                if (i == nTabPositions) {
                    pixeltabstop = 8*cxCharWidth;
                    xEnd = ((xEnd - iTabOrigin)/pixeltabstop)*pixeltabstop +
                        pixeltabstop + iTabOrigin;
                }
            }

            if (fFirstPass && fDraw) {
                xRightmostPoint = max(xEnd, xRightmostPoint);

                /* Check if this strip peeps beyond the clip region */
                if (xRightmostPoint > xClipEndPos) {
                    if (!NegCInfoForStrip->nCount) {
                        NegCInfoForStrip->ichString = ichString + cch + nConsecutiveTabs;
                        NegCInfoForStrip->nCount = nCount;
                        NegCInfoForStrip->lpString = (ped->fAnsi ?
                                                        lpTab : (LPSTR) lpwTab);
                        NegCInfoForStrip->XStartPos = xTabStartPos;
                    }
                }
            }   /* if(fFirstPass) */

            nConsecutiveTabs++;
            nCount--;
            ped->fAnsi ? lpTab++ : (LPSTR) (lpwTab++) ;  // Move to the next character.
        }  // while(*lpTab == TAB) //

        if (fDraw) {
            if (fFirstPass) {
                // Is anything remaining to be drawn in this strip?
                if (!nCount)
                    rc.right = xEnd;      // No! We are done.
                else {
                    // "x" is the effective starting position of next strip.
                    iTabLength = xEnd - xStripEndPos;

                    // Check if there is a possibility of this tab length being too small
                    // compared to the negative A and C widths if any.
                    if ((wNegCwidth + (wNegAwidth = ped->wMaxNegA)) > (UINT)iTabLength) {
                        // Unfortunately, there is a possiblity of an overlap.
                        // Let us find out the actual NegA for the next strip.
                        wNegAwidth = GetActualNegA(
                              hdc,
                              ped,
                              xEnd,
                              lpstring + (cch + nConsecutiveTabs)*ped->cbChar,
                              ichString + cch + nConsecutiveTabs,
                              nCount,
                              &NegAInfo);
                    }

                    // Check if they actually overlap //
                    if ((wNegCwidth + wNegAwidth) <= (UINT)iTabLength) {
                        // No overlap between the strips. This is the ideal situation.
                        rc.right = xEnd - wNegAwidth;
                    } else {
                        // Yes! They overlap.
                        rc.right = xEnd;

                        // See if negative C width is too large compared to tab length.
                        if (wNegCwidth > (UINT)iTabLength) {
                            // Must redraw transparently a part of the current strip later.
                            if (RedrawStripInfo.nCount) {
                                // A previous strip also needs to be redrawn; So, merge this
                                // strip to that strip.
                                RedrawStripInfo.nCount = (ichString -
                                    RedrawStripInfo.ichString) + cch;
                            } else {
                                RedrawStripInfo.nCount = cch;
                                RedrawStripInfo.lpString = lpstring;
                                RedrawStripInfo.ichString = ichString;
                                RedrawStripInfo.XStartPos = xStripStPos;
                            }
                        }

                        if (wNegAwidth) {
                            // Must redraw transparently the first part of the next strip later.
                            if (RedrawStripInfo.nCount) {
                                // A previous strip also needs to be redrawn; So, merge this
                                // strip to that strip.
                                RedrawStripInfo.nCount = (NegAInfo.ichString - RedrawStripInfo.ichString) +
                                       NegAInfo.nCount;
                            } else
                                RedrawStripInfo = NegAInfo;
                        }
                    }
                } // else (!nCount) //
            }  // if (fFirstPass) //

            if (rc.left < xClipEndPos) {
                if (fFirstPass) {
                    // If this is the end of the strip, then complete the rectangle.
                    if ((!nCount) && (xClipEndPos == MAXCLIPENDPOS))
                        rc.right = max(rc.right, xClipEndPos);
                    else
                        rc.right = min(rc.right, xClipEndPos);
                }

                // Draw the current strip.
                if (rc.left < rc.right)
                    if ( ped->fAnsi )
                        ExtTextOutA(hdc,
                                    xStripStPos,
                                    y,
                                    (fFirstPass && fOpaque ? (ETO_OPAQUE | ETO_CLIPPED) : ETO_CLIPPED),
                                    (LPRECT)&rc, lpstring, cch, 0L);
                    else
                        ExtTextOutW(hdc,
                                    xStripStPos,
                                    y,
                                    (fFirstPass && fOpaque ? (ETO_OPAQUE | ETO_CLIPPED) : ETO_CLIPPED),
                                    (LPRECT)&rc, (LPWSTR)lpstring, cch, 0L);

            }

            if (fFirstPass)
                rc.left = max(rc.right, xClipStPos);
            ichString += (cch+nConsecutiveTabs);
        }  // if (fDraw) //

        // Skip over the tab and the characters we just drew.
        lpstring += (cch + nConsecutiveTabs) * ped->cbChar;
    }  // while (nCount) //

    xEndOfStrip = xEnd;

    // check if we need to draw some portions transparently.
    if (fFirstPass && fDraw && RedrawStripInfo.nCount) {
        iSavedBkMode = SetBkMode(hdc, TRANSPARENT);
        fFirstPass = FALSE;

        nCount = RedrawStripInfo.nCount;
        rc.left = xClipStPos;
        rc.right = xClipEndPos;
        lpstring = RedrawStripInfo.lpString;
        ichString = RedrawStripInfo.ichString;
        xEnd = RedrawStripInfo.XStartPos;
        goto RedrawStrip;  // Redraw Transparently.
    }

    if (iSavedBkMode)             // Did we change the Bk mode?
        SetBkMode(hdc, iSavedBkMode);  // Then, let us set it back!

    return((UINT)(xEndOfStrip - xStart));
}



/***************************************************************************\
* ECCchInWidth AorW
*
* Returns maximum count of characters (up to cch) from the given
* string (starting either at the beginning and moving forward or at the
* end and moving backwards based on the setting of the fForward flag)
* which will fit in the given width. ie. Will tell you how much of
* lpstring will fit in the given width even when using proportional
* characters. WARNING: If we use kerning, then this loses...
*
* History:
*
* NOTE: ECCchInWidth is not called if the language pack is loaded.
\***************************************************************************/

ICH ECCchInWidth(
    PED ped,
    HDC hdc,
    LPSTR lpText,
    ICH cch,
    int width,
    BOOL fForward)
{
    int stringExtent;
    int cchhigh;
    int cchnew = 0;
    int cchlow = 0;
    SIZE size;
    LPSTR lpStart;

    if ((width <= 0) || !cch)
        return (0);

    /*
     * Optimize nonproportional fonts for single line ec since they don't have
     * tabs.
     */
    //
    // Change optimize condition for fixed pitch font
    //
    if (ped->fNonPropFont && ped->fSingle && !ped->fDBCS) {
        return (ECAdjustIch( ped, lpText, umin(width/ped->aveCharWidth,(int)cch)));
    }

    /*
     * Check if password hidden chars are being used.
     */
    if (ped->charPasswordChar) {
        return (umin(width / ped->cPasswordCharWidth, (int)cch));
    }

    /*
     * ALWAYS RESTRICT TO AT MOST MAXLINELENGTH to avoid overflow...
     */
    cch = umin(MAXLINELENGTH, cch);

    cchhigh = cch + 1;
    while (cchlow < cchhigh - 1) {
        cchnew = umax((cchhigh - cchlow) / 2, 1) + cchlow;

        lpStart = lpText;

        /*
         * If we want to figure out how many fit starting at the end and moving
         * backwards, make sure we move to the appropriate position in the
         * string before calculating the text extent.
         */
        if (!fForward)
            lpStart += (cch - cchnew)*ped->cbChar;

        if (ped->fSingle) {
            if (ped->fAnsi)
                GetTextExtentPointA(hdc, (LPSTR)lpStart, cchnew, &size);
            else
                GetTextExtentPointW(hdc, (LPWSTR)lpStart, cchnew, &size);
            stringExtent = size.cx;
        } else {
            stringExtent = ECTabTheTextOut(hdc, 0, 0, 0, 0,
                lpStart,
                cchnew, 0,
                ped, 0, ECT_CALC, NULL );
        }

        if (stringExtent > width) {
            cchhigh = cchnew;
        } else {
            cchlow = cchnew;
        }
    }
    //
    // Call ECAdjustIch ( generic case )
    //
    cchlow = ECAdjustIch( ped, lpText, cchlow );
    return (cchlow);
}

/***************************************************************************\
* ECFindTab
*
* Scans lpstr and return s the number of CHARs till the first TAB.
* Scans at most cch chars of lpstr.
*
* History:
\***************************************************************************/

ICH ECFindTabA(
    LPSTR lpstr,
    ICH cch)
{
    LPSTR copylpstr = lpstr;

    if (!cch)
        return 0;

    while (*lpstr != VK_TAB) {
        lpstr++;
        if (--cch == 0)
            break;
    }
    return ((ICH)(lpstr - copylpstr));
}

ICH ECFindTabW(
    LPWSTR lpstr,
    ICH cch)
{
    LPWSTR copylpstr = lpstr;

    if (!cch)
        return 0;

    while (*lpstr != VK_TAB) {
        lpstr++;
        if (--cch == 0)
            break;
    }
    return ((ICH)(lpstr - copylpstr));
}

/***************************************************************************\
*
*  ECGetBrush()
*
*  Gets appropriate background brush to erase with.
*
\***************************************************************************/
HBRUSH ECGetBrush(PED ped, HDC hdc)
{
    HBRUSH  hbr;
    BOOL    f40Compat;

    f40Compat = (GETAPPVER() >= VER40);

    // Get background brush
    if ((ped->fReadOnly || ped->fDisabled) && f40Compat) {
        hbr = ECGetControlBrush(ped, hdc, WM_CTLCOLORSTATIC);
    } else
        hbr = ECGetControlBrush(ped, hdc, WM_CTLCOLOREDIT);

    if (ped->fDisabled && (ped->fSingle || f40Compat)) {
        DWORD rgb;

        // Change text color
        rgb = GetSysColor(COLOR_GRAYTEXT);
        if (rgb != GetBkColor(hdc))
            SetTextColor(hdc, rgb);
    }
    return(hbr);
}


/***************************************************************************\
* NextWordCallBack
*
*
*
* History:
* 02-19-92 JimA Ported from Win31 sources.
\***************************************************************************/

void NextWordCallBack(
    PED ped,
    ICH ichStart,
    BOOL fLeft,
    ICH  *pichMin,
    ICH  *pichMax )
{
    ICH ichMinSel;
    ICH ichMaxSel;
    LPSTR pText;

    pText = ECLock(ped);

    if (fLeft || (!(BOOL)CALLWORDBREAKPROC(ped->lpfnNextWord, (LPSTR)pText,
            ichStart, ped->cch, WB_ISDELIMITER) &&
            (ped->fAnsi ? (*(pText + ichStart) != VK_RETURN) : (*((LPWSTR)pText + ichStart) != VK_RETURN))
        ))
        ichMinSel = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)pText, ichStart, ped->cch, WB_LEFT);
    else
        ichMinSel = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)pText, ichStart, ped->cch, WB_RIGHT);

    ichMaxSel = min(ichMinSel + 1, ped->cch);

    if (ped->fAnsi) {
        if (*(pText + ichMinSel) == VK_RETURN) {
            if (ichMinSel > 0 && *(pText + ichMinSel - 1) == VK_RETURN) {

                /*
                 * So that we can treat CRCRLF as one word also.
                 */
                ichMinSel--;
            } else if (*(pText+ichMinSel + 1) == VK_RETURN) {

                /*
                 * Move MaxSel on to the LF
                 */
                ichMaxSel++;
            }
        }
    } else {
        if (*((LPWSTR)pText + ichMinSel) == VK_RETURN) {
            if (ichMinSel > 0 && *((LPWSTR)pText + ichMinSel - 1) == VK_RETURN) {

                /*
                 * So that we can treat CRCRLF as one word also.
                 */
                ichMinSel--;
            } else if (*((LPWSTR)pText+ichMinSel + 1) == VK_RETURN) {

                /*
                 * Move MaxSel on to the LF
                 */
                ichMaxSel++;
            }
        }
    }
    ichMaxSel = CALLWORDBREAKPROC(ped->lpfnNextWord, (LPSTR)pText, ichMaxSel, ped->cch, WB_RIGHT);
    ECUnlock(ped);

    if (pichMin)  *pichMin = ichMinSel;
    if (pichMax)  *pichMax = ichMaxSel;
}

/***************************************************************************\
* NextWordLpkCallback
*
* Identifies next/prev word position for complex scripts
*
* History:
* 04-22-97 DBrown
\***************************************************************************/

void NextWordLpkCallBack(
    PED  ped,
    ICH  ichStart,
    BOOL fLeft,
    ICH *pichMin,
    ICH *pichMax)
{
    PSTR pText = ECLock(ped);
    HDC  hdc   = ECGetEditDC(ped, TRUE);

    ped->pLpkEditCallout->EditNextWord(ped, hdc, pText, ichStart, fLeft, pichMin, pichMax);

    ECReleaseEditDC(ped, hdc, TRUE);
    ECUnlock(ped);
}

/***************************************************************************\
* ECWordAorW
*
* if fLeft, Returns the ichMinSel and ichMaxSel of the word to the
* left of ichStart. ichMinSel contains the starting letter of the word,
* ichmaxsel contains all spaces up to the first character of the next word.
*
* if !fLeft, Returns the ichMinSel and ichMaxSel of the word to the right of
* ichStart. ichMinSel contains the starting letter of the word, ichmaxsel
* contains the first letter of the next word. If ichStart is in the middle
* of a word, that word is considered the left or right word.
*
* A CR LF pair or CRCRLF triple is considered a single word in
* multiline edit controls.
*
* History:
\***************************************************************************/

void ECWord(
    PED ped,
    ICH ichStart,
    BOOL fLeft,
    ICH  *pichMin,
    ICH  *pichMax )
{
    BOOL charLocated = FALSE;
    BOOL spaceLocated = FALSE;

    if ((!ichStart && fLeft) || (ichStart == ped->cch && !fLeft)) {

        /*
         * We are at the beginning of the text (looking left) or we are at end
         * of text (looking right), no word here
         */
        if (pichMin) *pichMin=0;
        if (pichMax) *pichMax=0;
        return;
    }

    /*
     * Don't give out hints about word breaks if password chars are being used,
     */
    if (ped->charPasswordChar) {
        if (pichMin) *pichMin=0;
        if (pichMax) *pichMax=ped->cch;
        return;
    }

    if (ped->fAnsi) {
        PSTR pText;
        PSTR pWordMinSel;
        PSTR pWordMaxSel;
        PSTR pPrevChar;

        UserAssert(ped->cbChar == sizeof(CHAR));

        if (ped->lpfnNextWord) {
            NextWordCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        if (ped->pLpkEditCallout) {
            NextWordLpkCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        pText = ECLock(ped);
        pWordMinSel = pWordMaxSel = pText + ichStart;

        /*
         * if fLeft: Move pWordMinSel to the left looking for the start of a word.
         * If we start at a space, we will include spaces in the selection as we
         * move left untill we find a nonspace character. At that point, we continue
         * looking left until we find a space. Thus, the selection will consist of
         * a word with its trailing spaces or, it will consist of any leading at the
         * beginning of a line of text.
         */

        /*
         * if !fLeft: (ie. right word) Move pWordMinSel looking for the start of a
         * word. If the pWordMinSel points to a character, then we move left
         * looking for a space which will signify the start of the word. If
         * pWordMinSel points to a space, we look right till we come upon a
         * character. pMaxWord will look right starting at pMinWord looking for the
         * end of the word and its trailing spaces.
         */

        if (fLeft || !ISDELIMETERA(*pWordMinSel) && *pWordMinSel != 0x0D) {

            /*
             * If we are moving left or if we are moving right and we are not on a
             * space or a CR (the start of a word), then we was look left for the
             * start of a word which is either a CR or a character. We do this by
             * looking left till we find a character (or if CR we stop), then we
             * continue looking left till we find a space or LF.
             */
            while (pWordMinSel > pText && ((!ISDELIMETERA(*(pWordMinSel - 1)) &&
                    *(pWordMinSel - 1) != 0x0A) || !charLocated)) {

                /*
                 * Treat double byte character as a word  ( in ansi pWordMinSel loop )
                 */
                pPrevChar = ECAnsiPrev( ped, pText, pWordMinSel );

                /*
                ** we are looking right ( !fLeft ).
                ** if current character is a double byte chararacter or
                ** previous character is a double byte character, we
                ** are on the beggining of a word.
                */
                if ( !fLeft && ( ISDELIMETERA( *pPrevChar )           ||
                                 *pPrevChar == 0x0A                   ||
                                 ECIsDBCSLeadByte(ped, *pWordMinSel)  ||
                                 pWordMinSel - pPrevChar == 2 ) ) {
                    /*
                     * If we are looking for the start of the word right, then we
                     * stop when we have found it. (needed in case charLocated is
                     * still FALSE)
                     */
                    break;
                }

                if ( pWordMinSel - pPrevChar == 2 ) {
                    /*
                    ** previous character is a double byte character.
                    ** if we are in a word ( charLocated == TRUE )
                    ** current position is the beginning of the word
                    ** if we are not in a word ( charLocated == FALSE )
                    ** the previous character is what we looking for.
                    */
                    if ( ! charLocated ) {
                        pWordMinSel = pPrevChar;
                    }
                    break;
                }
                pWordMinSel = pPrevChar;

                if (!ISDELIMETERA(*pWordMinSel) && *pWordMinSel != 0x0A) {

                    /*
                     * We have found the last char in the word. Continue looking
                     * backwards till we find the first char of the word
                     */
                    charLocated = TRUE;

                    /*
                     * We will consider a CR the start of a word
                     */
                    if (*pWordMinSel == 0x0D)
                        break;
                }
            }
        } else {
            while ((ISDELIMETERA(*pWordMinSel) || *pWordMinSel == 0x0A) && pWordMinSel < pText + ped->cch)
                pWordMinSel++;
        }

        /*
         * Adjust the initial position of pWordMaxSel ( in ansi )
         */
        pWordMaxSel = ECAnsiNext(ped, pWordMinSel);
        pWordMaxSel = min(pWordMaxSel, pText + ped->cch);

        /*
        ** If pWordMinSel points a double byte character AND
        **    pWordMaxSel points non space
        ** then
        **    pWordMaxSel points the beggining of next word.
        */
        if ( ( pWordMaxSel - pWordMinSel == 2 ) && ! ISDELIMETERA(*pWordMaxSel) )
            goto FastReturnA;
        if (*pWordMinSel == 0x0D) {
            if (pWordMinSel > pText && *(pWordMinSel - 1) == 0x0D)
                /* So that we can treat CRCRLF as one word also. */
                pWordMinSel--;
            else if (*(pWordMinSel + 1) == 0x0D)
                /* Move MaxSel on to the LF */
                pWordMaxSel++;
        }



        /*
         * Check if we have a one character word
         */
        if (ISDELIMETERA(*pWordMaxSel))
            spaceLocated = TRUE;

        /*
         * Move pWordMaxSel to the right looking for the end of a word and its
         * trailing spaces. WordMaxSel stops on the first character of the next
         * word. Thus, we break either at a CR or at the first nonspace char after
         * a run of spaces or LFs.
         */
        while ((pWordMaxSel < pText + ped->cch) && (!spaceLocated || (ISDELIMETERA(*pWordMaxSel)))) {
            if (*pWordMaxSel == 0x0D)
                break;

            /*
             * Treat double byte character as a word ( in ansi pWordMaxSel loop )
             */
            /*
            ** if it's a double byte character then
            ** we are at the beginning of next word
            ** which is a double byte character.
            */
            if (ECIsDBCSLeadByte( ped, *pWordMaxSel))
                break;

            pWordMaxSel++;

            if (ISDELIMETERA(*pWordMaxSel))
                spaceLocated = TRUE;

            if (*(pWordMaxSel - 1) == 0x0A)
                break;
        }

        /*
         * label for fast return ( for Ansi )
         */
FastReturnA:
        ECUnlock(ped);

        if (pichMin)   *pichMin = (ICH)(pWordMinSel - pText);
        if (pichMax)   *pichMax = (ICH)(pWordMaxSel - pText);
        return;

    } else {  // !fAnsi
        LPWSTR pwText;
        LPWSTR pwWordMinSel;
        LPWSTR pwWordMaxSel;
        BOOL charLocated = FALSE;
        BOOL spaceLocated = FALSE;
        PWSTR pwPrevChar;

        UserAssert(ped->cbChar == sizeof(WCHAR));

        if (ped->lpfnNextWord) {
            NextWordCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        if (ped->pLpkEditCallout) {
            NextWordLpkCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        pwText = (LPWSTR)ECLock(ped);
        pwWordMinSel = pwWordMaxSel = pwText + ichStart;

        /*
         * if fLeft: Move pWordMinSel to the left looking for the start of a word.
         * If we start at a space, we will include spaces in the selection as we
         * move left untill we find a nonspace character. At that point, we continue
         * looking left until we find a space. Thus, the selection will consist of
         * a word with its trailing spaces or, it will consist of any leading at the
         * beginning of a line of text.
         */

        /*
         * if !fLeft: (ie. right word) Move pWordMinSel looking for the start of a
         * word. If the pWordMinSel points to a character, then we move left
         * looking for a space which will signify the start of the word. If
         * pWordMinSel points to a space, we look right till we come upon a
         * character. pMaxWord will look right starting at pMinWord looking for the
         * end of the word and its trailing spaces.
         */


        if (fLeft || (!ISDELIMETERW(*pwWordMinSel) && *pwWordMinSel != 0x0D))
         /* If we are moving left or if we are moving right and we are not on a
          * space or a CR (the start of a word), then we was look left for the
          * start of a word which is either a CR or a character. We do this by
          * looking left till we find a character (or if CR we stop), then we
          * continue looking left till we find a space or LF.
          */ {
            while (pwWordMinSel > pwText && ((!ISDELIMETERW(*(pwWordMinSel - 1)) && *(pwWordMinSel - 1) != 0x0A) || !charLocated)) {
                /*
                 * Treat double byte character as a word  ( in unicode pwWordMinSel loop )
                 */
                pwPrevChar = pwWordMinSel - 1;
                /*
                ** we are looking right ( !fLeft ).
                **
                ** if current character is a double width chararacter
                ** or previous character is a double width character,
                ** we are on the beggining of a word.
                */
                if (!fLeft && (ISDELIMETERW( *pwPrevChar)  ||
                               *pwPrevChar == 0x0A         ||
                               UserIsFullWidth(CP_ACP,*pwWordMinSel) ||
                               UserIsFullWidth(CP_ACP,*pwPrevChar)))    {
                    /*
                     * If we are looking for the start of the word right, then we
                     * stop when we have found it. (needed in case charLocated is
                     * still FALSE)
                     */
                    break;
                }

                if (UserIsFullWidth(CP_ACP,*pwPrevChar)) {
                    /*
                    ** Previous character is a double width character.
                    **
                    ** if we are in a word ( charLocated == TRUE )
                    ** current position is the beginning of the word
                    ** if we are not in a word ( charLocated == FALSE )
                    ** the previous character is what we looking for.
                    */
                    if ( ! charLocated ) {
                        pwWordMinSel = pwPrevChar;
                    }
                    break;
                }
                pwWordMinSel = pwPrevChar;

                if (!ISDELIMETERW(*pwWordMinSel) && *pwWordMinSel != 0x0A)
                 /*
                  * We have found the last char in the word. Continue looking
                  * backwards till we find the first char of the word
                  */ {
                    charLocated = TRUE;

                    /*
                     * We will consider a CR the start of a word
                     */
                    if (*pwWordMinSel == 0x0D)
                        break;
                }
            }
        } else {

            /*
             * We are moving right and we are in between words so we need to move
             * right till we find the start of a word (either a CR or a character.
             */
            while ((ISDELIMETERW(*pwWordMinSel) || *pwWordMinSel == 0x0A) && pwWordMinSel < pwText + ped->cch)
                pwWordMinSel++;
        }

        pwWordMaxSel = min((pwWordMinSel + 1), (pwText + ped->cch));

        /*
        ** If pwWordMinSel points a double width character AND
        **    pwWordMaxSel points non space
        ** then
        **    pwWordMaxSel points the beggining of next word.
        */
        if (UserIsFullWidth(CP_ACP,*pwWordMinSel) && ! ISDELIMETERW(*pwWordMaxSel))
            goto FastReturnW;
        if (*pwWordMinSel == 0x0D) {
            if (pwWordMinSel > pwText && *(pwWordMinSel - 1) == 0x0D)
                /* So that we can treat CRCRLF as one word also. */
                pwWordMinSel--;
            else if (*(pwWordMinSel + 1) == 0x0D)
                /* Move MaxSel on to the LF */
                pwWordMaxSel++;
        }



        /*
         * Check if we have a one character word
         */
        if (ISDELIMETERW(*pwWordMaxSel))
            spaceLocated = TRUE;

        /*
         * Move pwWordMaxSel to the right looking for the end of a word and its
         * trailing spaces. WordMaxSel stops on the first character of the next
         * word. Thus, we break either at a CR or at the first nonspace char after
         * a run of spaces or LFs.
         */
        while ((pwWordMaxSel < pwText + ped->cch) && (!spaceLocated || (ISDELIMETERW(*pwWordMaxSel)))) {
            if (*pwWordMaxSel == 0x0D)
                break;

            /*
             * treat double byte character as a word ( in unicode pwWordMaxSel loop )
             */
            /*
            ** if it's a double width character
            ** then we are at the beginning of
            ** the next word which is a double
            ** width character.
            */
            if (UserIsFullWidth(CP_ACP,*pwWordMaxSel))
                break;

            pwWordMaxSel++;

            if (ISDELIMETERW(*pwWordMaxSel))
                spaceLocated = TRUE;


            if (*(pwWordMaxSel - 1) == 0x0A)
                break;
        }

        /*
         * label for fast return ( for Unicode )
         */
FastReturnW:
        ECUnlock(ped);

        if (pichMin)   *pichMin = (ICH)(pwWordMinSel - pwText);
        if (pichMax)   *pichMax = (ICH)(pwWordMaxSel - pwText);
        return;
    }
}

/***************************************************************************\
*
*  ECSaveUndo() -
*
*  Saves old undo information into given buffer, and clears out info in
*  passed in undo buffer.  If we're restoring, pundoFrom and pundoTo are
*  reversed.
*
\***************************************************************************/
void ECSaveUndo(PUNDO pundoFrom, PUNDO pundoTo, BOOL fClear)
{
    /*
     *  Save undo data
     */
    RtlCopyMemory(pundoTo, pundoFrom, sizeof(UNDO));

    /*
     *  Clear passed in undo buffer
     */
    if (fClear)
        RtlZeroMemory(pundoFrom, sizeof(UNDO) );
}

/***************************************************************************\
* ECEmptyUndo AorW
*
* empties the undo buffer.
*
* History:
\***************************************************************************/

void ECEmptyUndo(
    PUNDO pundo )
{
    if (pundo->hDeletedText)
        UserGlobalFree(pundo->hDeletedText);

    RtlZeroMemory(pundo, sizeof(UNDO) );
}

/***************************************************************************\
*
*  ECMergeUndoInsertInfo() -
*
*  When an insert takes place, this function is called with the info about
*  the new insertion (the insertion point and the count of chars inserted);
*  This looks at the existing Undo info and merges the new new insert info
*  with it.
*
\***************************************************************************/
void   ECMergeUndoInsertInfo(PUNDO pundo, ICH ichInsert, ICH cchInsert) \
{
    //
    // If undo buffer is empty, just insert the new info as UNDO_INSERT
    //
    if (pundo->undoType == UNDO_NONE) {
        pundo->undoType    = UNDO_INSERT;
        pundo->ichInsStart = ichInsert;
        pundo->ichInsEnd   = ichInsert+cchInsert;
    } else if (pundo->undoType & UNDO_INSERT) {
        //
        // If there's already some undo insert info,
        // try to merge the two.
        //
        if (pundo->ichInsEnd == ichInsert) // Check they are adjacent.
            pundo->ichInsEnd += cchInsert; // if so, just concatenate.
        else {
                // The new insert is not contiguous with the old one.
UNDOINSERT:
            //
            // If there is some UNDO_DELETE info already here, check to see
            // if the new insert takes place at a point different from where
            // that deletion occurred.
            //
            if ((pundo->undoType & UNDO_DELETE) && (pundo->ichDeleted != ichInsert)) {
                //
                // User is inserting into a different point; So, let us
                // forget any UNDO_DELETE info;
                //
                if (pundo->hDeletedText)
                    UserGlobalFree(pundo->hDeletedText);

                pundo->hDeletedText = NULL;
                pundo->ichDeleted = 0xFFFFFFFF;
                pundo->undoType &= ~UNDO_DELETE;
            }

            // Since the old insert and new insert are not adjacent, let us
            // forget everything about the old insert and keep just the new
            // insert info as the UNDO_INSERT.
            pundo->ichInsStart = ichInsert;
            pundo->ichInsEnd   = ichInsert + cchInsert;
            pundo->undoType |= UNDO_INSERT;
        }
    } else if (pundo->undoType == UNDO_DELETE) {
        // If there is some Delete Info already present go and handle it.
        goto UNDOINSERT;
    }
}


/***************************************************************************\
* ECInsertText AorW
*
* Adds cch characters from lpText into the ped->hText starting at
* ped->ichCaret. Returns TRUE if successful else FALSE. Updates
* ped->cchAlloc and ped->cch properly if additional memory was allocated or
* if characters were actually added. Updates ped->ichCaret to be at the end
* of the inserted text. min and maxsel are equal to ichcaret.
*
* History:
\***************************************************************************/

BOOL ECInsertText(
    PED ped,
    LPSTR lpText,
    ICH* pcchInsert)
{
    PSTR pedText;
    PSTR pTextBuff;
    LONG style;
    HANDLE hTextCopy;
    DWORD allocamt;

    //
    // If the last byte (lpText[cchInsert - 1]) is a DBCS leading byte
    // we need to adjust it.
    //
    *pcchInsert = ECAdjustIch(ped, lpText, *pcchInsert);

    if (!*pcchInsert)
        return TRUE;

    /*
     * Do we already have enough memory??
     */
    if (*pcchInsert >= (ped->cchAlloc - ped->cch)) {

        /*
         * Allocate what we need plus a little extra. Return FALSE if we are
         * unsuccessful.
         */
        allocamt = (ped->cch + *pcchInsert) * ped->cbChar;
        allocamt += CCHALLOCEXTRA;

// if (!ped->fSingle) {
              hTextCopy = LOCALREALLOC(ped->hText, allocamt, LHND, ped->hInstance, &lpText);
              if (hTextCopy) {
                  ped->hText = hTextCopy;
              } else {
                  return FALSE;
              }
// } else {
// if (!LocalReallocSafe(ped->hText, allocamt, LHND, pped))
//                return FALSE;
// }

        ped->cchAlloc = LOCALSIZE(ped->hText, ped->hInstance) / ped->cbChar;
    }


    /*
     * Ok, we got the memory. Now copy the text into the structure
     */
    pedText = ECLock(ped);

    if (ped->pLpkEditCallout) {
        HDC     hdc;
        INT     iResult;

        hdc = ECGetEditDC (ped, TRUE);
        iResult = ped->pLpkEditCallout->EditVerifyText (ped, hdc, pedText, ped->ichCaret, lpText, *pcchInsert);
        ECReleaseEditDC (ped, hdc, TRUE);

        if (iResult == 0) {
            ECUnlock (ped);
            return TRUE;
        }
    }

    /*
     * Get a pointer to the place where text is to be inserted
     */
    pTextBuff = pedText + ped->ichCaret * ped->cbChar;

    if (ped->ichCaret != ped->cch) {

        /*
         * We are inserting text into the middle. We have to shift text to the
         * right before inserting new text.
         */
         memmove(pTextBuff + *pcchInsert * ped->cbChar, pTextBuff, (ped->cch-ped->ichCaret) * ped->cbChar);
    }

    /*
     * Make a copy of the text being inserted in the edit buffer.
     * Use this copy for doing UPPERCASE/LOWERCASE ANSI/OEM conversions
     * Fix for Bug #3406 -- 01/29/91 -- SANKAR --
     */
    memmove(pTextBuff, lpText, *pcchInsert * ped->cbChar);
    ped->cch += *pcchInsert;

    /*
     * Get the control's style
     */
    style = ped->pwnd->style;

    /*
     * Do the Upper/Lower conversion
     */
    if (style & ES_LOWERCASE) {
        if (ped->fAnsi)
            CharLowerBuffA((LPSTR)pTextBuff, *pcchInsert);
        else
            CharLowerBuffW((LPWSTR)pTextBuff, *pcchInsert);
    } else {
        if (style & ES_UPPERCASE) {
            if (ped->fAnsi) {
                CharUpperBuffA(pTextBuff, *pcchInsert);
            } else {
                CharUpperBuffW((LPWSTR)pTextBuff, *pcchInsert);
            }
        }
    }

    /*
     * Do the OEM conversion
     */
    if ((style & ES_OEMCONVERT) &&
            // For backward compatibility with NT4, we don't perform OEM conversion
            // for older apps if the system locale is FarEast.
            //
            (!IS_DBCS_ENABLED() || GETAPPVER() >= VER50 || GetOEMCP() != GetACP())) {

        ICH i;

        if (ped->fAnsi) {
            for (i = 0; i < *pcchInsert; i++) {
                //
                // We don't need to call CharToOemBuff etc. if the character
                // is a double byte character.  And, calling ECIsDBCSLeadByte is
                // faster and less complicated because we don't have to deal
                // with the 2 byte dbcs cases.
                //
                if (IS_DBCS_ENABLED() && ECIsDBCSLeadByte(ped, *(lpText+i))) {
                    i++;
                    continue;
                }

                //
                // Windows Bug (Whistler) 35289
                // greek has funny rules for casing, so we need to check for it.
                // for nashville we should be doing something more appropriate
                // but for now, leave as Win95 golden
                //
                if (ped->charSet != GREEK_CHARSET && IsCharLowerA(*(pTextBuff + i))) {
                    CharUpperBuffA(pTextBuff + i, 1);
                    CharToOemBuffA(pTextBuff + i, pTextBuff + i, 1);
                    OemToCharBuffA(pTextBuff + i, pTextBuff + i, 1);
                    CharLowerBuffA(pTextBuff + i, 1);
                } else {
                    CharToOemBuffA(pTextBuff + i, pTextBuff + i, 1);
                    OemToCharBuffA(pTextBuff + i, pTextBuff + i, 1);
                }
            }
        } else {
            //
            // Because 'ch' may become DBCS, and have a space for NULL.
            //
            UCHAR ch[4];
            LPWSTR lpTextW = (LPWSTR)pTextBuff;

            for (i = 0; i < *pcchInsert; i++) {
                if (*(lpTextW + i) == UNICODE_CARRIAGERETURN ||
                    *(lpTextW + i) == UNICODE_LINEFEED ||
                    *(lpTextW + i) == UNICODE_TAB) {
                    continue;
                }
                //
                // Windows Bug (Whistler) 35289
                // greek has funny rules for casing, so we need to check for it.
                // for nashville we should be doing something more appropriate
                // but for now, leave as Win95 golden
                //
                if (ped->charSet != GREEK_CHARSET && IsCharLowerW(*(lpTextW + i))) {
                    CharUpperBuffW(lpTextW + i, 1);
                    *(LPDWORD)ch = 0; // make sure the null-terminate.
                    CharToOemBuffW(lpTextW + i, ch, 1);
                    //
                    // We assume any SBCS/DBCS character will converted
                    // to 1 Unicode char, Otherwise, we may overwrite
                    // next character...
                    //
                    OemToCharBuffW(ch, lpTextW + i, strlen(ch));
                    CharLowerBuffW(lpTextW + i, 1);
                } else {
                    *(LPDWORD)ch = 0; // make sure the null-terminate.
                    CharToOemBuffW(lpTextW + i, ch, 1);
                    //
                    // We assume any SBCS/DBCS character will converted
                    // to 1 Unicode char, Otherwise, we may overwrite
                    // next character...
                    //
                    OemToCharBuffW(ch, lpTextW + i, strlen(ch));
                }
            }
        }
    }

    /* Adjust UNDO fields so that we can undo this insert... */
    ECMergeUndoInsertInfo(Pundo(ped), ped->ichCaret, *pcchInsert);

    ped->ichCaret += *pcchInsert;

    if (ped->pLpkEditCallout) {
        HDC     hdc;

        hdc = ECGetEditDC (ped, TRUE);
        ped->ichCaret = ped->pLpkEditCallout->EditAdjustCaret (ped, hdc, pedText, ped->ichCaret);
        ECReleaseEditDC (ped, hdc, TRUE);
    }

    ped->ichMinSel = ped->ichMaxSel = ped->ichCaret;

    ECUnlock(ped);

    /*
     * Set dirty bit
     */
    ped->fDirty = TRUE;

    return TRUE;
}

/***************************************************************************\
* ECDeleteText AorW
*
* Deletes the text between ped->ichMinSel and ped->ichMaxSel. The
* character at ichMaxSel is not deleted. But the character at ichMinSel is
* deleted. ped->cch is updated properly and memory is deallocated if enough
* text is removed. ped->ichMinSel, ped->ichMaxSel, and ped->ichCaret are set
* to point to the original ped->ichMinSel. Returns the number of characters
* deleted.
*
* History:
\***************************************************************************/

ICH ECDeleteText(
    PED ped)
{
    PSTR pedText;
    ICH cchDelete;
    LPSTR lpDeleteSaveBuffer;
    HANDLE hDeletedText;
    DWORD bufferOffset;

    cchDelete = ped->ichMaxSel - ped->ichMinSel;

    if (!cchDelete)
        return (0);

    /*
     * Ok, now lets delete the text.
     */
    pedText = ECLock(ped);

    /*
     * Adjust UNDO fields so that we can undo this delete...
     */
    if (ped->undoType == UNDO_NONE) {
UNDODELETEFROMSCRATCH:
        if (ped->hDeletedText = UserGlobalAlloc(GPTR, (LONG)((cchDelete+1)*ped->cbChar))) {
            ped->undoType = UNDO_DELETE;
            ped->ichDeleted = ped->ichMinSel;
            ped->cchDeleted = cchDelete;
            lpDeleteSaveBuffer = ped->hDeletedText;
            RtlCopyMemory(lpDeleteSaveBuffer, pedText + ped->ichMinSel*ped->cbChar, cchDelete*ped->cbChar);
            lpDeleteSaveBuffer[cchDelete*ped->cbChar] = 0;
        }
    } else if (ped->undoType & UNDO_INSERT) {
UNDODELETE:
        ECEmptyUndo(Pundo(ped));

        ped->ichInsStart = ped->ichInsEnd = 0xFFFFFFFF;
        ped->ichDeleted = 0xFFFFFFFF;
        ped->cchDeleted = 0;
        goto UNDODELETEFROMSCRATCH;
    } else if (ped->undoType == UNDO_DELETE) {
        if (ped->ichDeleted == ped->ichMaxSel) {

            /*
             * Copy deleted text to front of undo buffer
             */
            hDeletedText = UserGlobalReAlloc(ped->hDeletedText, (LONG)(cchDelete + ped->cchDeleted + 1)*ped->cbChar, GHND);
            if (!hDeletedText)
                goto UNDODELETE;
            bufferOffset = 0;
            ped->ichDeleted = ped->ichMinSel;
        } else if (ped->ichDeleted == ped->ichMinSel) {

            /*
             * Copy deleted text to end of undo buffer
             */
            hDeletedText = UserGlobalReAlloc(ped->hDeletedText, (LONG)(cchDelete + ped->cchDeleted + 1)*ped->cbChar, GHND);
            if (!hDeletedText)
                goto UNDODELETE;
            bufferOffset = ped->cchDeleted*ped->cbChar;
        } else {

            /*
             * Clear the current UNDO delete and add the new one since
               the deletes aren't contiguous.
             */
            goto UNDODELETE;
        }

        ped->hDeletedText = hDeletedText;
        lpDeleteSaveBuffer = (LPSTR)hDeletedText;
        if (!bufferOffset) {

            /*
             * Move text in delete buffer up so that we can insert the next
             * text at the head of the buffer.
             */
            RtlMoveMemory(lpDeleteSaveBuffer + cchDelete*ped->cbChar, lpDeleteSaveBuffer,
                    ped->cchDeleted*ped->cbChar);
        }
        RtlCopyMemory(lpDeleteSaveBuffer + bufferOffset, pedText + ped->ichMinSel*ped->cbChar,
                cchDelete*ped->cbChar);

        lpDeleteSaveBuffer[(ped->cchDeleted + cchDelete)*ped->cbChar] = 0;
        ped->cchDeleted += cchDelete;
    }

    if (ped->ichMaxSel != ped->cch) {

        /*
         * We are deleting text from the middle of the buffer so we have to
           shift text to the left.
         */
        RtlMoveMemory(pedText + ped->ichMinSel*ped->cbChar, pedText + ped->ichMaxSel*ped->cbChar,
                (ped->cch - ped->ichMaxSel)*ped->cbChar);
    }

    if (ped->cchAlloc - ped->cch > CCHALLOCEXTRA) {

        /*
         * Free some memory since we deleted a lot
         */
        LOCALREALLOC(ped->hText, (DWORD)(ped->cch + (CCHALLOCEXTRA / 2))*ped->cbChar, LHND, ped->hInstance, NULL);
        ped->cchAlloc = LOCALSIZE(ped->hText, ped->hInstance) / ped->cbChar;
    }

    ped->cch -= cchDelete;

    if (ped->pLpkEditCallout) {
        HDC     hdc;

        hdc = ECGetEditDC (ped, TRUE);
        ped->ichMinSel = ped->pLpkEditCallout->EditAdjustCaret (ped, hdc, pedText, ped->ichMinSel);
        ECReleaseEditDC (ped, hdc, TRUE);
    }

    ped->ichCaret = ped->ichMaxSel = ped->ichMinSel;

    ECUnlock(ped);

    /*
     * Set dirty bit
     */
    ped->fDirty = TRUE;

    return (cchDelete);
}

/***************************************************************************\
* ECNotifyParent AorW
*
* Sends the notification code to the parent of the edit control
*
* History:
\***************************************************************************/

void ECNotifyParent(
    PED ped,
    int notificationCode)
{
    /*
     * wParam is NotificationCode (hiword) and WindowID (loword)
     * lParam is HWND of control sending the message
     * Windows 95 checks for hwndParent != NULL before sending the message, but
     * this is surely rare, and SendMessage NULL hwnd does nowt anyway (IanJa)
     */
    SendMessage(ped->hwndParent, WM_COMMAND,
            (DWORD)MAKELONG(PTR_TO_ID(ped->pwnd->spmenu), notificationCode),
            (LPARAM)ped->hwnd);
}

/***************************************************************************\
*
*  ECSetEditClip() AorW
*
*  Sets the clip rect for the hdc to the formatting rectangle intersected
*  with the client area.
*
\***************************************************************************/
void   ECSetEditClip(PED ped, HDC hdc, BOOL fLeftMargin)
{
    RECT rcClient;
    RECT rcClip;

    CopyRect(&rcClip, &ped->rcFmt);

    if (ped->pLpkEditCallout) {
        // Complex script handling chooses whether to write margins later
        rcClip.left  -= ped->wLeftMargin;
        rcClip.right += ped->wRightMargin;
    } else {
        if (fLeftMargin)  /* Should we consider the left margin?   */
            rcClip.left  -= ped->wLeftMargin;
        if (ped->fWrap)        /* Should we consider the right margin? */
            rcClip.right += ped->wRightMargin;
    }

    /* Set clip rectangle to rectClient intersect rectClip */
    /* We must clip for single line edits also. -- B#1360 */
    _GetClientRect(ped->pwnd, &rcClient);
    if (ped->fFlatBorder)
        InflateRect(&rcClient, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

    IntersectRect(&rcClient, &rcClient, &rcClip);
    IntersectClipRect(hdc,rcClient.left, rcClient.top,
            rcClient.right, rcClient.bottom);
}

/***************************************************************************\
* ECGetEditDC AorW
*
* Hides the caret, gets the DC for the edit control, and clips to
* the rcFmt rectangle specified for the edit control and sets the proper
* font. If fFastDC, just select the proper font but don't bother about clip
* regions or hiding the caret.
*
* History:
\***************************************************************************/

HDC ECGetEditDC(
    PED ped,
    BOOL fFastDC )
{
    HDC hdc;

    if (!fFastDC)
        NtUserHideCaret(ped->hwnd);

    if ( hdc = NtUserGetDC(ped->hwnd) ) {
        ECSetEditClip(ped, hdc, (BOOL)(ped->xOffset == 0));

        /*
         * Select the proper font for this edit control's dc.
         */
        if (ped->hFont)
            SelectObject(hdc, ped->hFont);
    }

    return hdc;
}

/***************************************************************************\
* ECReleaseEditDC AorW
*
* Releases the DC (hdc) for the edit control and shows the caret.
* If fFastDC, just select the proper font but don't bother about showing the
* caret.
*
* History:
\***************************************************************************/

void ECReleaseEditDC(
    PED ped,
    HDC hdc,
    BOOL fFastDC)
{
    /*
     * Restoring font not necessary
     */

    ReleaseDC(ped->hwnd, hdc);

    if (!fFastDC)
        NtUserShowCaret(ped->hwnd);
}

/***************************************************************************\
*
*  ECResetTextInfo() AorW
*
*  Handles a global change to the text by resetting text offsets, emptying
*  the undo buffer, and rebuilding the lines
*
\***************************************************************************/
void   ECResetTextInfo(PED ped)
{
    //
    // Reset caret, selections, scrolling, and dirty information.
    //
    ped->iCaretLine = ped->ichCaret = 0;
    ped->ichMinSel = ped->ichMaxSel = 0;
    ped->xOffset = ped->ichScreenStart = 0;
    ped->fDirty = FALSE;

    ECEmptyUndo(Pundo(ped));

    if (ped->fSingle) {
        if (!ped->listboxHwnd)
            ECNotifyParent(ped, EN_UPDATE);
    } else {
#ifdef BOGUS
        // B#14640
        // We don't want to strip soft breaks or anything else from text
        // that was passed in by the caller. - karlst.
        MLStripCrCrLf(ped);
#endif
        MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);
    }

    if (_IsWindowVisible(ped->pwnd)) {
        BOOL fErase;

        if (ped->fSingle)
            fErase = FALSE;
        else
            fErase = ((ped->ichLinesOnScreen + ped->ichScreenStart) >= ped->cLines);

        // Always redraw whether or not the insert was successful.  We might
        // have NULL text.  Paint() will check the redraw flag for us.
        ECInvalidateClient(ped, fErase);

        // BACKWARD COMPAT HACK: RAID expects the text to have been updated,
        // so we have to do an UpdateWindow here.  It moves an edit control
        // around with fRedraw == FALSE, so it'll never get the paint message
        // with the control in the right place.
        if (!ped->fWin31Compat)
            UpdateWindow(ped->hwnd);
    }

    if (ped->fSingle && !ped->listboxHwnd) {
        ECNotifyParent(ped, EN_CHANGE);
    }

    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, HW(ped->pwnd), OBJID_CLIENT, INDEXID_CONTAINER);
}

/***************************************************************************\
* ECSetText AorW
*
* Copies the null terminated text in lpstr to the ped. Notifies the
* parent if there isn't enough memory. Sets the minsel, maxsel, and caret to
* the beginning of the inserted text. Returns TRUE if successful else FALSE
* if no memory (and notifies the parent).
*
* History:
\***************************************************************************/

BOOL ECSetText(
    PED ped,
    LPSTR lpstr)
{
    ICH cchLength;
    ICH cchSave = ped->cch;
    ICH ichCaretSave = ped->ichCaret;
    HWND hwndSave    = ped->hwnd;
    HANDLE hText;

    ped->cch = ped->ichCaret = 0;

    ped->cchAlloc = LOCALSIZE(ped->hText, ped->hInstance) / ped->cbChar;
    if (!lpstr) {
        hText = LOCALREALLOC(ped->hText, CCHALLOCEXTRA*ped->cbChar, LHND, ped->hInstance, &lpstr);
        if (hText != NULL) {
            ped->hText = hText;
        } else {
            return FALSE;
        }
    } else {
        cchLength = StringLength(lpstr, ped->fAnsi);

#ifdef NEVER
// win3.1 does limit single line edit controls to 32K (minus 3) but NT doesn't

        if (ped->fSingle) {
            /*
             * Limit single line edit controls to 32K
             */
            cchLength = min(cchLength, (ICH)(0x7FFD/ped->cbChar));
        }
#endif

        /*
         * Add the text
         */
        if (cchLength && !ECInsertText(ped, lpstr, &cchLength)) {

            /*
             * Restore original state and notify parent we ran out of memory.
             */
            ped->cch = cchSave;
            ped->ichCaret = ichCaretSave;
            ECNotifyParent(ped, EN_ERRSPACE);
            return FALSE;
        }
    }

    ped->cchAlloc = LOCALSIZE(ped->hText, ped->hInstance) / ped->cbChar;

    if (IsWindow(hwndSave))
        ECResetTextInfo(ped);

    return TRUE;
}

/***************************************************************************\
*
* ECInvalidateClient()
*
* Invalidates client of edit field.  For old 3.x guys with borders,
* we draw it ourself (compatibility).  So we don't want to invalidate
* the border or we'll get flicker.
*
\***************************************************************************/

void ECInvalidateClient(PED ped, BOOL fErase)
{
    if (ped->fFlatBorder) {
        RECT    rcT;

        _GetClientRect(ped->pwnd, &rcT);
        InflateRect(&rcT, -SYSMET(CXBORDER),
            -SYSMET(CYBORDER));
        NtUserInvalidateRect(ped->hwnd, &rcT, fErase);
    } else {
        NtUserInvalidateRect(ped->hwnd, NULL, fErase);
    }
}


/***************************************************************************\
* ECCopy AorW
*
* Copies the text between ichMinSel and ichMaxSel to the clipboard.
* Returns the number of characters copied.
*
* History:
\***************************************************************************/

ICH ECCopy(
    PED ped)
{
    HANDLE hData;
    char *pchSel;
    char FAR *lpchClip;
    ICH cbData;

    /*
     * Don't allow copies from password style controls
     */
    if (ped->charPasswordChar) {
        NtUserMessageBeep(0);
        return 0;
    }

    cbData = (ped->ichMaxSel - ped->ichMinSel) * ped->cbChar;

    if (!cbData)
        return 0;

    if (!OpenClipboard(ped->hwnd))
        return 0;

    NtUserEmptyClipboard();

    /*
     * If we just called EmptyClipboard in the context of a 16 bit
     * app then we also have to tell WOW to nix its 16 handle copy of
     * clipboard data.  WOW does its own clipboard caching because
     * some 16 bit apps use clipboard data even after the clipboard
     * has been emptied.  See the note in the server code.
     *
     * Note: this is the only place where EmptyClipboard is called
     * for a 16 bit app not going through WOW.  If we added others
     * we might want to move this into EmptyClipboard and have two
     * versions.
     */
    if (GetClientInfo()->CI_flags & CI_16BIT) {
        pfnWowEmptyClipBoard();
    }


    /*
     * +1 for the terminating NULL
     */
    if (!(hData = UserGlobalAlloc(LHND, (LONG)(cbData + ped->cbChar)))) {
        NtUserCloseClipboard();
        return (0);
    }

    USERGLOBALLOCK(hData, lpchClip);
    UserAssert(lpchClip);
    pchSel = ECLock(ped);
    pchSel = pchSel + (ped->ichMinSel * ped->cbChar);

    RtlCopyMemory(lpchClip, pchSel, cbData);

    if (ped->fAnsi)
        *(lpchClip + cbData) = 0;
    else
        *(LPWSTR)(lpchClip + cbData) = (WCHAR)0;

    ECUnlock(ped);
    USERGLOBALUNLOCK(hData);

    SetClipboardData( ped->fAnsi ? CF_TEXT : CF_UNICODETEXT, hData);

    NtUserCloseClipboard();

    return (cbData);
}



/***************************************************************************\
* EditWndProcA
*
* Always receives Ansi messages and translates them if appropriate to unicode
* depending on the PED type
*
*
\***************************************************************************/

LRESULT EditWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_EDIT))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, TRUE);

    return EditWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT EditWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_EDIT)) {
        return DefWindowProcWorker(pwnd, message, wParam, lParam, FALSE);
    }

    return EditWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}


LRESULT EditWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    PED ped;
    HWND hwnd = HWq(pwnd);
    static BOOL fInit = TRUE;

    VALIDATECLASSANDSIZE(pwnd, FNID_EDIT);
    INITCONTROLLOOKASIDE(&EditLookaside, ED, pwnd, 4);

    /*
     * Get the ped for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,hped) when
     * we initially created the edit control.
     */
    ped = ((PEDITWND)pwnd)->ped;

    /*
     * Make sure the ANSI flag is set correctly.
     */
    if (!ped->fInitialized) {
        ped->fInitialized = TRUE;
        ped->fAnsi = TestWF(pwnd, WFANSICREATOR) ? TRUE : FALSE;
    }

    /*
     * We just call the regular EditWndProc if the ped is not created, the
     * incoming message type already matches the PED type or the message
     * does not need any translation.
     */
    if (ped->fAnsi == fAnsi ||
            (message >= WM_USER) ||
            !MessageTable[message].bThunkMessage) {
        return EditWndProc(pwnd, message, wParam, lParam);
    }

    return CsSendMessage(hwnd, message, wParam, lParam,
                         fAnsi ? (ULONG_PTR)EditWndProcW : (ULONG_PTR)EditWndProcA,
                         FNID_CALLWINDOWPROC, fAnsi);
}

/***************************************************************************\
* EditWndProc
*
* Class procedure for all edit controls.
* Dispatches all messages to the appropriate handlers which are named
* as follows:
* SL (single line) prefixes all single line edit control procedures while
* ML (multi line) prefixes all multi- line edit controls.
* EC (edit control) prefixes all common handlers.
*
* The EditWndProc only handles messages common to both single and multi
* line edit controls. Messages which are handled differently between
* single and multi are sent to SLEditWndProc or MLEditWndProc.
*
* Top level procedures are EditWndPoc, SLEditWndProc, and MLEditWndProc.
* SL*Handler or ML*Handler or EC*Handler procs are called to handle
* the various messages. Support procedures are prefixed with SL ML or
* EC depending on which code they support. They are never called
* directly and most assumptions/effects are documented in the effects
* clause.
*
* WARNING: If you add a message here, add it to gawEditWndProc[] in
* kernel\server.c too, otherwise EditWndProcA/W will send it straight to
* DefWindowProcWorker
*
* History:
\***************************************************************************/

LRESULT EditWndProc(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwnd = HWq(pwnd);
    LRESULT lreturn;
    PED  ped;

    /*
     * Get the ped for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,hped) when
     * we initially created the edit control.
     */
    ped = ((PEDITWND)pwnd)->ped;

    /*
     * Dispatch the various messages we can receive
     */
    lreturn = 1L;
    switch (message) {

    /*
     * Messages which are handled the same way for both single and multi line
     * edit controls.
     */
    case WM_KEYDOWN:
         // LPK handling of Ctrl/LShift, Ctrl/RShift
         if (ped && ped->pLpkEditCallout && ped->fAllowRTL) {

             ped->fSwapRoOnUp = FALSE; // Any keydown cancels a ctrl/shift reading order change

             switch (wParam) {
                 case VK_SHIFT:
                     if ((GetKeyState(VK_CONTROL) & 0x8000) && !(GetKeyState(VK_MENU) & 0x8000)) {
                         // Left shift or right shift pressed while control held down
                         // Check that alt (VK_MENU) isn't down to avoid false firing on AltGr which equals Ctrl+Alt.
                         if (MapVirtualKey((LONG)lParam>>16&0xff, 3) == VK_LSHIFT) {
                             // User wants left to right reading order
                             ped->fSwapRoOnUp = (ped->fRtoLReading)  || (ped->format & ES_RIGHT) ;
                             ped->fLShift = TRUE;
                         } else {
                             // User wants right to left reading order
                             ped->fSwapRoOnUp = (!ped->fRtoLReading) || (ped->format & ES_RIGHT);
                             ped->fLShift = FALSE;
                         }
                     }
                     break;

                 case VK_LEFT:
                     if (ped->fRtoLReading) {
                        wParam = VK_RIGHT;
                     }
                     break;

                 case VK_RIGHT:
                     if (ped->fRtoLReading) {
                         wParam = VK_LEFT;
                     }
                     break;
             }
         }
         goto HandleEditMsg;

    case WM_KEYUP:
        if (ped && ped->pLpkEditCallout && ped->fAllowRTL && ped->fSwapRoOnUp) {

            BOOL fReadingOrder;
            // Complete reading order change detected earlier during keydown

            ped->fSwapRoOnUp = FALSE;
            fReadingOrder = ped->fRtoLReading;

            // Remove any overriding ES_CENTRE or ES_RIGHT format from dwStyle
            SetWindowLong(hwnd, GWL_STYLE, GetWindowLong(hwnd, GWL_STYLE) & ~ES_FMTMASK);

            if (ped->fLShift) {
                // Set Left to Right reading order and right scrollbar in EX_STYLE
                SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE)
                              & ~(WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR));

                // Edit control is LTR now, then notify the parent.
                ECNotifyParent(ped, EN_ALIGN_LTR_EC);
                // ? Select a keyboard layout appropriate to LTR operation
            } else {
                // Set Right to Left reading order, right alignment and left scrollbar
                SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE)
                              | WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR);

                // Edit control is RTL now, then notify the parent.
                ECNotifyParent(ped, EN_ALIGN_RTL_EC);
                // ? Select a keyboard layout appropriate to RTL operation
            }

            // If reading order didn't change, so we are sure the alignment changed and the edit window didn't invalidate yet.
            if (fReadingOrder == (BOOL) ped->fRtoLReading) {
              ECInvalidateClient(ped, TRUE);
            }
        }
        goto HandleEditMsg;

    case WM_INPUTLANGCHANGE:
        if (ped) {
            // EC_INSERT_COMPOSITION_CHAR : WM_INPUTLANGCHANGE - call ECInitInsert()
            HKL hkl = THREAD_HKL();

            ECInitInsert(ped, hkl);

            if (ped->fInReconversion) {
                ECInOutReconversionMode(ped, FALSE);
            }

            //
            // Font and caret position might be changed while
            // another keyboard layout is active. Set those
            // if the edit control has the focus.
            //
            if (ped->fFocus && fpImmIsIME(hkl)) {
                POINT pt;

                ECImmSetCompositionFont(ped);
                NtUserGetCaretPos(&pt);
                ECImmSetCompositionWindow(ped, pt.x, pt.y);
            }
        }

        goto HandleEditMsg;

    case WM_COPY:

        /*
         * wParam - not used
         * lParam - not used
         */
        lreturn = (LONG)ECCopy(ped);
        break;

    case WM_CUT:
        /*
         *
         * wParamLo --    unused
         * lParam --    unused
         */
        ECCutText(ped);
        return 0;

    case WM_CLEAR:
        /*
         * wParamLo --    unused
         * lParam --    unused
         */
        ECClearText(ped);
        return 0;

    case WM_ENABLE:

        /*
         * wParam - nonzero if window is enabled else disable window if 0.
         * lParam - not used
         */
        lreturn = (LONG)(ped->fDisabled = !((BOOL)wParam));
        ECInvalidateClient(ped, TRUE);
        break;

    case WM_SYSCHAR:
        //
        // wParamLo --    key value
        // lParam --    unused
        //

        //
        // If this is a WM_SYSCHAR message generated by the UNDO
        // keystroke we want to EAT IT
        //
        if ((lParam & SYS_ALTERNATE) && ((WORD)wParam == VK_BACK))
            return TRUE;
        else {
            return DefWindowProcWorker(pwnd, message, wParam, lParam, ped->fAnsi);
        }
        break;

    case EM_GETLINECOUNT:

        /*
         * wParam - not used
           lParam - not used
         */
        lreturn = (LONG)ped->cLines;
        break;

    case EM_GETMODIFY:

        /*
         * wParam - not used
           lParam - not used
         */

        /*
         * Gets the state of the modify flag for this edit control.
         */
        lreturn = (LONG)ped->fDirty;
        break;

    case EM_SETMODIFY:

        /*
         * wParam - specifies the new value for the modify flag
           lParam - not used
         */

        /*
         * Sets the state of the modify flag for this edit control.
         */
        ped->fDirty = (wParam != 0);
        break;

    case EM_GETRECT:

        /*
         * wParam - not used
           lParam - pointer to a RECT data structure that gets the dimensions.
         */

        /*
         * Copies the rcFmt rect to *lpRect.
         */
        CopyRect((LPRECT)lParam, (LPRECT)&ped->rcFmt);
        lreturn = (LONG)TRUE;
        break;

    case WM_GETFONT:

        /*
         * wParam - not used
           lParam - not used
         */
        lreturn = (LRESULT)ped->hFont;
        break;

    case WM_SETFONT:

        /*
         * wParam - handle to the font
           lParam - redraw if true else don't
         */
        ECSetFont(ped, (HANDLE)wParam, (BOOL)LOWORD(lParam));
        break;

    case WM_GETTEXT:

        /*
         * wParam - max number of _bytes_ (not characters) to copy
         * lParam - buffer to copy text to. Text is 0 terminated.
         */
        lreturn = (LRESULT)ECGetText(ped, (ICH)wParam, (LPSTR)lParam, TRUE);
        break;

    case WM_SETTEXT:
        //
        // wParamLo --    unused
        // lParam --    LPSTR, null-terminated, with new text.
        //
        lreturn = (LRESULT)ECSetText(ped, (LPSTR)lParam);
        break;

    case WM_GETTEXTLENGTH:

        /*
         * Return count of CHARs!!!
         */
        lreturn = (LONG)ped->cch;
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:

        /*
         * wParam - not used
           lParam - not used
         */
        ECNcDestroyHandler(pwnd, ped);
        return 0;

    /*
     * Most apps (i.e. everyone but Quicken) don't pass on the rbutton
     * messages when they do something with 'em inside of subclassed
     * edit fields.  As such, we keep track of whether we saw the
     * down before the up.  If we don't see the up, then DefWindowProc
     * won't generate the context menu message, so no big deal.  If
     * we didn't see the down, then don't let WM_CONTEXTMENU do
     * anything.
     *
     * We also might want to not generate WM_CONTEXTMENUs for old
     * apps when the mouse is captured.
     */

    case WM_RBUTTONDOWN:
        ped->fSawRButtonDown = TRUE;
        goto HandleEditMsg;

    case WM_RBUTTONUP:
        if (ped->fSawRButtonDown) {
            ped->fSawRButtonDown = FALSE;
            if (!ped->fInReconversion) {
                goto HandleEditMsg;
            }
        }
        // Don't pass this on to DWP so WM_CONTEXTMENU isn't generated.
        return 0;

    case WM_CONTEXTMENU: {
            POINT pt ;
            int nHit = FindNCHit(pwnd, (LONG)lParam);
            if ((nHit == HTVSCROLL) || (nHit == HTHSCROLL)) {
                return DefWindowProcWorker(pwnd, message, wParam, lParam, ped->fAnsi);
            }
            POINTSTOPOINT(pt, lParam);
            if (!TestWF(pwnd, WFOLDUI) && ECIsAncestorActive(hwnd))
                ECMenu(hwnd, ped, &pt);
        }
        return 0;

    case EM_CANUNDO:

        /*
         * wParam - not used
           lParam - not used
         */
        lreturn = (LONG)(ped->undoType != UNDO_NONE);
        break;

    case EM_EMPTYUNDOBUFFER:

        /*
         * wParam - not used
           lParam - not used
         */
        ECEmptyUndo(Pundo(ped));
        break;

    case EM_GETMARGINS:
        //
        // wParam --    unused
        // lParam --    unused
        //
        return(MAKELONG(ped->wLeftMargin, ped->wRightMargin));

    case EM_SETMARGINS:
        //
        // wParam --    EC_ margin flags
        // lParam --    LOWORD is left, HIWORD is right margin
        //
        ECSetMargin(ped, (UINT)wParam, (DWORD)lParam, TRUE);
        return 0;

    case EM_GETSEL:

        /*
         * Gets the selection range for the given edit control. The
         * starting position is in the low order word. It contains the position
         * of the first nonselected character after the end of the selection in
         * the high order word.
         */
        if ((PDWORD)wParam != NULL) {
           *((PDWORD)wParam) = ped->ichMinSel;
        }
        if ((PDWORD)lParam != NULL) {
           *((PDWORD)lParam) = ped->ichMaxSel;
        }
        lreturn = MAKELONG(ped->ichMinSel,ped->ichMaxSel);
        break;

    case EM_GETLIMITTEXT:
        //
        // wParamLo --    unused
        // lParam --    unused
        //
        return(ped->cchTextMax);

    case EM_SETLIMITTEXT:        /* Renamed from EM_LIMITTEXT in Chicago */
        /*
         * wParam - max number of CHARACTERS that can be entered
         * lParam - not used
         */

        /*
         * Specifies the maximum number of characters of text the user may
         * enter. If maxLength is 0, we may enter MAXINT number of CHARACTERS.
         */
        if (ped->fSingle) {
            if (wParam) {
                wParam = min(0x7FFFFFFEu, wParam);
            } else {
                wParam = 0x7FFFFFFEu;
            }
        }

        if (wParam) {
            ped->cchTextMax = (ICH)wParam;
        } else {
            ped->cchTextMax = 0xFFFFFFFFu;
        }
        break;

    case EM_POSFROMCHAR:
        //
        // Validate that char index is within text range
        //
        if (wParam >= ped->cch) {
            return(-1L);
        }
        goto HandleEditMsg;

    case EM_CHARFROMPOS: {
        // Validate that point is within client of edit field
        RECT    rc;
        POINT   pt;

        POINTSTOPOINT(pt, lParam);
        _GetClientRect(pwnd, &rc);
        if (!PtInRect(&rc, pt)) {
            return(-1L);
        }
        goto HandleEditMsg;
    }

    case EM_SETPASSWORDCHAR:

        /*
         * wParam - sepecifies the new char to display instead of the
         * real text. if null, display the real text.
         */
        ECSetPasswordChar(ped, (UINT)wParam);
        break;

    case EM_GETPASSWORDCHAR:
        lreturn = (DWORD)ped->charPasswordChar;
        break;

    case EM_SETREADONLY:

        /*
         * wParam - state to set read only flag to
         */
        ped->fReadOnly = (wParam != 0);
        if (wParam)
            SetWindowState(pwnd, EFREADONLY);
        else
            ClearWindowState(pwnd, EFREADONLY);
        lreturn = 1L;

        ECEnableDisableIME( ped );
        // We need to redraw the edit field so that the background color
        // changes.  Read-only edits are drawn in CTLCOLOR_STATIC while
        // others are drawn with CTLCOLOR_EDIT.
        ECInvalidateClient(ped, TRUE);
        break;

    case EM_SETWORDBREAKPROC:

        /*
         * wParam - unused
         * lParam - FARPROC address of an app supplied call back function
         */
        ped->lpfnNextWord = (EDITWORDBREAKPROCA)lParam;
        break;

    case EM_GETWORDBREAKPROC:
        lreturn = (LRESULT)ped->lpfnNextWord;
        break;

    // IME
    case EM_GETIMESTATUS:
        // wParam == sub command
        switch (wParam) {
        case  EMSIS_COMPOSITIONSTRING:
            return ped->wImeStatus;
#if 0   // memphis
        case  EMSIS_GETLBBIT:
            return (DWORD)ped->bLBBit;
#endif
        }
        break;

    case EM_SETIMESTATUS:
        // wParam == sub command
        switch (wParam) {
        case EMSIS_COMPOSITIONSTRING:
            ped->wImeStatus = (WORD)lParam;
        }
        break;


    case WM_NCCREATE:
        lreturn = ECNcCreate(ped, pwnd, (LPCREATESTRUCT)lParam);
        break;

    case WM_LBUTTONDOWN:
        //
        // B#3623
        // Don't set focus to edit field if it is within an inactive,
        // captioned child.
        // We might want to version switch this...  I haven't found
        // any problems by not, but you never know...
        //
        if (ECIsAncestorActive(hwnd)) {
            /*
             * Reconversion support: quit reconversion if left button is clicked.
             * Otherwise, if the current KL is Korean, finailize the composition string.
             */
            if (ped->fInReconversion || ped->fKorea) {
                BOOLEAN fReconversion = (BOOLEAN)ped->fInReconversion;
                DWORD dwIndex = fReconversion ? CPS_CANCEL : CPS_COMPLETE;
                HIMC hImc;

                ped->fReplaceCompChr = FALSE;

                hImc = fpImmGetContext(ped->hwnd);
                if (hImc) {
                    fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, dwIndex, 0);
                    fpImmReleaseContext(ped->hwnd, hImc);
                }

                if (fReconversion) {
                    ECInOutReconversionMode(ped, FALSE);
                }

                ECSetCaretHandler(ped);
            }

            goto HandleEditMsg;
        }
        break;

    case WM_MOUSEMOVE:
        //
        // We only care about mouse messages when mouse is down.
        //
        if (ped->fMouseDown)
            goto HandleEditMsg;
        break;

    case WM_IME_SETCONTEXT:
        //
        // If ped->fInsertCompChr is TRUE, that means we will do
        // all the composition character drawing by ourself.
        //
        if ( ped->fInsertCompChr ) {
            lParam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
        }

        if ( wParam ) {

            PINPUTCONTEXT pInputContext;
            HIMC hImc;

            hImc = fpImmGetContext( hwnd );
            if ( (pInputContext = fpImmLockIMC( hImc )) != NULL ) {
                pInputContext->fdw31Compat &= ~F31COMPAT_ECSETCFS;
                fpImmUnlockIMC( hImc );
            }
            if (GetClientInfo()->CI_flags & CI_16BIT) {
                fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0L);
            }
            fpImmReleaseContext( hwnd, hImc );
        }
        return DefWindowProcWorker(pwnd, message, wParam, lParam, ped->fAnsi);

    case WM_IME_ENDCOMPOSITION:
        ECInOutReconversionMode(ped, FALSE);

        if (ped->fReplaceCompChr) {
            ICH ich;
            HDC hdc;
            //
            // we have a DBCS character to be replaced.
            // let's delete it before inserting the new one.
            //
            ich = (ped->fAnsi) ? 2 : 1;
            ped->fReplaceCompChr = FALSE;
            ped->ichMaxSel = min(ped->ichCaret + ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;
            if (ped->fSingle) {
                if (ECDeleteText( ped ) > 0) {
                    //
                    // Update the display
                    //
                    ECNotifyParent(ped, EN_UPDATE);
                    hdc = ECGetEditDC(ped, FALSE);
                    SLDrawText(ped, hdc, 0);
                    ECReleaseEditDC(ped, hdc, FALSE);
                    //
                    // Tell parent our text contents changed.
                    //
                    ECNotifyParent(ped, EN_CHANGE);
                }
            }
            else {
                MLDeleteText(ped);
            }

            ECSetCaretHandler( ped );
        }
        return DefWindowProcWorker(pwnd, message, wParam, lParam, ped->fAnsi);

    case WM_IME_STARTCOMPOSITION:
        if ( ped->fInsertCompChr ) {
            //
            // NOTE:
            // sending WM_IME_xxxCOMPOSITION will let
            // IME draw composition window. IME should
            // not do that since we cleared
            // ISC_SHOWUICOMPOSITIONWINDOW bit when
            // we got WM_IME_SETCONTEXT message.
            //
            // Korean IME should be fixed in the future.
            //
            break;

        } else {
            return DefWindowProcWorker(pwnd, message, wParam, lParam, ped->fAnsi);
        }

    // simple composition character support for FE IME.
    case WM_IME_COMPOSITION:
        return ECImeComposition(ped, wParam, lParam);

    case WM_KILLFOCUS:
        //
        // when focus is removed from the window,
        // composition character should be finalized
        //
        if (ped && fpImmIsIME(THREAD_HKL())) {
            HIMC hImc = fpImmGetContext(hwnd);

            if (hImc != NULL_HIMC) {
                if (ped->fReplaceCompChr || (ped->wImeStatus & EIMES_COMPLETECOMPSTRKILLFOCUS)) {
                    // If the composition string to be determined upon kill focus,
                    // do it now.
                    fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
                } else if (ped->fInReconversion) {
                    // If the composition string it not to be determined,
                    // and if we're in reconversion mode, cancel reconversion now.
                    fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                }

                // Get out from reconversion mode
                if (ped->fInReconversion) {
                    ECInOutReconversionMode(ped, FALSE);
                }

                fpImmReleaseContext(hwnd, hImc);
            }
        }
        goto HandleEditMsg;
        break;

    case WM_SETFOCUS:
        if (ped && !ped->fFocus) {
            HKL hkl = THREAD_HKL();

            if (fpImmIsIME(hkl)) {
                HIMC hImc;

                hImc = fpImmGetContext(hwnd);
                if (hImc) {
                    LPINPUTCONTEXT lpImc;

                    if (ped->wImeStatus & EIMES_CANCELCOMPSTRINFOCUS) {
                        // cancel when in-focus
                        fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                    }

                    ECImmSetCompositionFont(ped);

                    if ((lpImc = fpImmLockIMC(hImc)) != NULL) {

                        // We presume the CompForm will reset to CFS_DEFAULT,
                        // when the edit control loses Focus.
                        // IMEWndProc32 will call ImmSetCompositionWindow with
                        // CFS_DEFAULT, when it receive WM_IME_SETCONTEXT.
                        lpImc->fdw31Compat |= F31COMPAT_ECSETCFS;

                        fpImmUnlockIMC(hImc);
                    }
                    fpImmReleaseContext(hwnd, hImc);
                }

                //
                // force to set IME composition window when
                // first getting focus.
                //
                ped->ptScreenBounding.x = -1;
                ped->ptScreenBounding.y = -1;
            }
            /*
             * Insert and replace flags are initialized when the edit control gets the focus.
             *
             * Compat hack: a bogus application tries to cheat the system by sending input messages
             * *before* it sets the focus to the edit control. They rely on the flags not being set
             * at WM_SETFOCUS. Raid #411686
             */
            if ((GetAppCompatFlags2(VER40) & GACF2_NO_INIT_ECFLAGS_ON_SETFOCUS) == 0) {
                ECInitInsert(ped, hkl);
            }
        }
        goto HandleEditMsg;
        break;

    case WM_IME_REQUEST:
        // simple ImeRequest Handler
        return EcImeRequestHandler(ped, wParam, lParam);

    case WM_CREATE:
        if (ped)
            ECEnableDisableIME(ped);
        goto HandleEditMsg;
        break;

    default:
HandleEditMsg:
        /* (picked up from NT40FE SP3)
         * HACK ALERT: We may receive messages before the PED has been
         * allocated (eg: WM_GETMINMAXINFO is sent before WM_NCCREATE)
         * so we must test ped before dreferencing.
         */
        if (ped != NULL) {
            if (ped->fSingle) {
                lreturn = SLEditWndProc(hwnd, ped, message, wParam, lParam);
            } else {
                lreturn = MLEditWndProc(hwnd, ped, message, wParam, lParam);
            }
        }
    }

    return lreturn;
}

/***************************************************************************\
* ECFindXORblks
*
* This finds the XOR of lpOldBlk and lpNewBlk and return s resulting blocks
* through the lpBlk1 and lpBlk2; This could result in a single block or
* at the maximum two blocks;
* If a resulting block is empty, then it's StPos field has -1.
* NOTE:
* When called from MultiLine edit control, StPos and EndPos fields of
* these blocks have the Starting line and Ending line of the block;
* When called from SingleLine edit control, StPos and EndPos fields
* of these blocks have the character index of starting position and
* ending position of the block.
*
* History:
\***************************************************************************/

void ECFindXORblks(
    LPBLOCK lpOldBlk,
    LPBLOCK lpNewBlk,
    LPBLOCK lpBlk1,
    LPBLOCK lpBlk2)
{
    if (lpOldBlk->StPos >= lpNewBlk->StPos) {
        lpBlk1->StPos = lpNewBlk->StPos;
        lpBlk1->EndPos = min(lpOldBlk->StPos, lpNewBlk->EndPos);
    } else {
        lpBlk1->StPos = lpOldBlk->StPos;
        lpBlk1->EndPos = min(lpNewBlk->StPos, lpOldBlk->EndPos);
    }

    if (lpOldBlk->EndPos <= lpNewBlk->EndPos) {
        lpBlk2->StPos = max(lpOldBlk->EndPos, lpNewBlk->StPos);
        lpBlk2->EndPos = lpNewBlk->EndPos;
    } else {
        lpBlk2->StPos = max(lpNewBlk->EndPos, lpOldBlk->StPos);
        lpBlk2->EndPos = lpOldBlk->EndPos;
    }
}

/***************************************************************************\
* ECCalcChangeSelection
*
* This function finds the XOR between two selection blocks(OldBlk and NewBlk)
* and return s the resulting areas thro the same parameters; If the XOR of
* both the blocks is empty, then this return s FALSE; Otherwise TRUE.
*
* NOTE:
* When called from MultiLine edit control, StPos and EndPos fields of
* these blocks have the Starting line and Ending line of the block;
* When called from SingleLine edit control, StPos and EndPos fields
* of these blocks have the character index of starting position and
* ending position of the block.
*
* History:
\***************************************************************************/

BOOL ECCalcChangeSelection(
    PED ped,
    ICH ichOldMinSel,
    ICH ichOldMaxSel,
    LPBLOCK OldBlk,
    LPBLOCK NewBlk)
{
    BLOCK Blk[2];
    int iBlkCount = 0;

    Blk[0].StPos = Blk[0].EndPos = Blk[1].StPos = Blk[1].EndPos = 0xFFFFFFFF;

    /*
     * Check if the Old selection block existed
     */
    if (ichOldMinSel != ichOldMaxSel) {

        /*
         * Yes! Old block existed.
         */
        Blk[0].StPos = OldBlk->StPos;
        Blk[0].EndPos = OldBlk->EndPos;
        iBlkCount++;
    }

    /*
     * Check if the new Selection block exists
     */
    if (ped->ichMinSel != ped->ichMaxSel) {

        /*
         * Yes! New block exists
         */
        Blk[1].StPos = NewBlk->StPos;
        Blk[1].EndPos = NewBlk->EndPos;
        iBlkCount++;
    }

    /*
     * If both the blocks exist find the XOR of them
     */
    if (iBlkCount == 2) {

        /*
         * Check if both blocks start at the same character position
         */
        if (ichOldMinSel == ped->ichMinSel) {

            /*
             * Check if they end at the same character position
             */
            if (ichOldMaxSel == ped->ichMaxSel)
                return FALSE; /* Nothing changes */

            Blk[0].StPos = min(NewBlk -> EndPos, OldBlk -> EndPos);
            Blk[0].EndPos = max(NewBlk -> EndPos, OldBlk -> EndPos);
            Blk[1].StPos = 0xFFFFFFFF;
        } else {
            if (ichOldMaxSel == ped->ichMaxSel) {
                Blk[0].StPos = min(NewBlk->StPos, OldBlk->StPos);
                Blk[0].EndPos = max(NewBlk->StPos, OldBlk->StPos);
                Blk[1].StPos = 0xFFFFFFFF;
            } else {
                ECFindXORblks(OldBlk, NewBlk, &Blk[0], &Blk[1]);
            }
        }
    }

    RtlCopyMemory(OldBlk, &Blk[0], sizeof(BLOCK));
    RtlCopyMemory(NewBlk, &Blk[1], sizeof(BLOCK));

    return TRUE; /* Yup , There is something to paint */
}


/***************************************************************************\
* ECGetControlBrush
*
* Client side optimization replacement for NtUserGetControlBrush
*
* message is one of the WM_CTLCOLOR* messages.
*
\***************************************************************************/

HBRUSH ECGetControlBrush(
    PED  ped,
    HDC  hdc,
    LONG message)
{
    PWND pwndSend;
    PWND pwndEdit;

    pwndEdit = ValidateHwnd(ped->hwnd);

    if (pwndEdit == (PWND)NULL)
        return (HBRUSH)0;

    if ((pwndSend = (TestwndPopup(pwndEdit) ? pwndEdit->spwndOwner : pwndEdit->spwndParent)) == NULL)
        pwndSend = pwndEdit;
    else
        pwndSend = REBASEPTR(pwndEdit, pwndSend);

    UserAssert(pwndSend);

    if (PtiCurrent() != GETPTI(pwndSend)) {
        return (HBRUSH)DefWindowProcWorker(pwndSend, message,
                (WPARAM)hdc, (LPARAM)pwndEdit, ped->fAnsi);
    }

    /*
     * By using the correct A/W call we avoid a c/s transition
     * on this SendMessage().
     */
    return (HBRUSH)SendMessageWorker(pwndSend, message, (WPARAM)hdc,
            (LPARAM)ped->hwnd, ped->fAnsi);
}

UINT WINAPI QueryFontAssocStatus(void);
UINT fFontAssocStatus = 0xffff;

/***************************************************************************\
* ECGetDBCSVector( PED ped, BYTE CharSet )
*
*   This function sets DBCS Vector for specified character set and sets
*   ped->fDBCS flag if needed.
*
* History: 18-Jun-1996 Hideyuki Nagase
\***************************************************************************/
int ECGetDBCSVector(PED ped, HDC hdc, BYTE CharSet)
{
    BOOL bDBCSCodePage = FALSE;
    /*
     * if DEFAUT_CHARSET was passed, we will convert that to Shell charset..
     */
    if (CharSet == DEFAULT_CHARSET) {
        CharSet = (BYTE)GetTextCharset(hdc);

        /*
         * if CharSet is still DEFAULT_CHARSET, it means gdi has some problem..
         * then just return default.. we get charset from CP_ACP..
         */
        if (CharSet == DEFAULT_CHARSET) {
            CharSet = (BYTE)GetACPCharSet();
        }
    }

    switch (CharSet) {
    case SHIFTJIS_CHARSET:
    case HANGEUL_CHARSET:
    case CHINESEBIG5_CHARSET:
    case GB2312_CHARSET:
        bDBCSCodePage = TRUE;
        break;

    case ANSI_CHARSET:            // 0
    case SYMBOL_CHARSET:          // 2
    case OEM_CHARSET:             // 255
        if (fFontAssocStatus == 0xffff)
            fFontAssocStatus = QueryFontAssocStatus();

        if ((((CharSet + 2) & 0xf) & fFontAssocStatus)) {
            bDBCSCodePage = TRUE;
            /*
             * Bug 117558, etc.
             * Try to get a meaningful character set for associated font.
             */
            CharSet = (BYTE)GetACPCharSet();
        } else {
            bDBCSCodePage = FALSE;
        }
        break;

    default:
        bDBCSCodePage = FALSE;
    }

    if (bDBCSCodePage) {
        CHARSETINFO CharsetInfo;
        DWORD CodePage;
        CPINFO CPInfo;
        int lbIX;

        if (TranslateCharsetInfo((DWORD *)CharSet, &CharsetInfo, TCI_SRCCHARSET)) {
            CodePage = CharsetInfo.ciACP;
        } else {
            CodePage = CP_ACP;
        }

        GetCPInfo(CodePage, &CPInfo);
        for (lbIX=0 ; CPInfo.LeadByte[lbIX] != 0 ; lbIX+=2) {
            ped->DBCSVector[lbIX  ] = CPInfo.LeadByte[lbIX];
            ped->DBCSVector[lbIX+1] = CPInfo.LeadByte[lbIX+1];
        }
        ped->DBCSVector[lbIX  ] = 0x0;
        ped->DBCSVector[lbIX+1] = 0x0;
    } else {
        ped->DBCSVector[0] = 0x0;
        ped->DBCSVector[1] = 0x0;
    }

    //
    // Final check: if the font supports DBCS glyphs
    //
    // If we've got a font with DBCS glyphs, let's mark PED so.
    // But since the font's primary charset is the one other than FE,
    // we can only support UNICODE Edit control.
    //
    //  a) GDI performs A/W conversion for ANSI apps based on the primary
    //     character set in hDC, so it will break anyway.
    //  b) ANSI applications are only supported on their native system locales:
    //     GetACPCharSet() is expected to return a FE code page.
    //  c) ANSI Edit control requires DBCSVector, which cannot be
    //     initialized without a FE code page.
    //
    if (!ped->fAnsi) {
        FONTSIGNATURE fontSig;

        GetTextCharsetInfo(hdc, &fontSig, 0);
        if (fontSig.fsCsb[0] & FAREAST_CHARSET_BITS) {
            bDBCSCodePage = TRUE;
            // Since this is UNICODE, we're not
        }
    }

    return bDBCSCodePage;
}

/***************************************************************************\
* LPSTR ECAnsiNext( ped, lpCurrent )
*
*   This function advances string pointer for Edit Control use only.
*
* History:
\***************************************************************************/
LPSTR ECAnsiNext(PED ped, LPSTR lpCurrent)
{
    return lpCurrent+((ECIsDBCSLeadByte(ped,*lpCurrent)==TRUE) ? 2 : 1);
}

/***************************************************************************\
* LPSTR ECAnsiPrev( ped, lpBase, lpStr )
*
*   This function decrements string pointer for Edit Control use only.
*
* History:
\***************************************************************************/
LPSTR ECAnsiPrev(PED ped, LPSTR lpBase, LPSTR lpStr )
{
    LPSTR lpCurrent = lpStr -1;

    if (!ped->fDBCS)
        return lpCurrent;                        // just return ( lpStr - 1 )

    if (lpBase >= lpCurrent)
        return lpBase;

    if (ECIsDBCSLeadByte(ped, *lpCurrent))     // this check makes things faster
        return (lpCurrent - 1);                  // 92/04/04 takaok

    do {
        lpCurrent--;
        if (!ECIsDBCSLeadByte(ped, *lpCurrent)) {
            lpCurrent++;
            break;
        }
    } while(lpCurrent != lpBase);

    return lpStr - (((lpStr - lpCurrent) & 1) ? 1 : 2);
}

/***************************************************************************\
* ICH ECNextIch( ped, pText, ichCurrent )
*
*   This function advances string pointer for Edit Control use only.
*
* History:
\***************************************************************************/
ICH ECNextIch( PED ped, LPSTR pStart, ICH ichCurrent )
{
    if (!ped->fDBCS || !ped->fAnsi) {

        return (ichCurrent + 1);

    } else {

        ICH ichRet;
        LPSTR pText;

        if (pStart)
            pText = pStart + ichCurrent;
        else
            pText = (LPSTR)ECLock(ped) + ichCurrent;

        ichRet = ichCurrent + ( ECIsDBCSLeadByte(ped, *pText) ? 2 : 1 );

        if (!pStart)
            ECUnlock(ped);

        return (ichRet);
    }
}

/***************************************************************************\
* ICH ECPrevIch( ped, LPSTR pStart, ICH ichCurrent )
*
*   This function decrements string pointer for Edit Control use only.
*
* History:
\***************************************************************************/
ICH ECPrevIch( PED ped, LPSTR pStart, ICH ichCurrent )
{
    LPSTR lpCurrent;
    LPSTR lpStr;
    LPSTR lpBase;

#ifdef SURROGATE
    // Handle Unicode surrogates pairs when CSLPK is loaded
    if (ped->fAnsi || !ped->pLpkEditCallout)  // if no surrogate processing required
#endif
        if (!ped->fDBCS || !ped->fAnsi)
            if ( ichCurrent )
                return (ichCurrent - 1);
            else
                return (ichCurrent);

    if (ichCurrent <= 1)
        return 0;

    if (pStart)
        lpBase = pStart;
    else
        lpBase = ECLock(ped);

#ifdef SURROGATE

    // Handle characters represented by multiple codepoints

    if (ped->fAnsi) {

        // ANSI PrevIch with DBCS support
#endif

        lpStr = lpBase + ichCurrent;
        lpCurrent = lpStr - 1;
        if (ECIsDBCSLeadByte(ped,*lpCurrent)) {
            if (!pStart)
                ECUnlock(ped);
            return (ichCurrent - 2);
        }

        do {
            lpCurrent--;
            if (!ECIsDBCSLeadByte(ped, *lpCurrent)) {
                lpCurrent++;
                break;
            }
        } while(lpCurrent != lpBase);

        if (!pStart)
            ECUnlock(ped);
        return (ichCurrent - (((lpStr - lpCurrent) & 1) ? 1 : 2));

#ifdef SURROGATE

    } else {

        // Unicode PrevIch with surrogate pair support

        ichCurrent--;

        if (    (((WCHAR*)lpBase)[ichCurrent]   & 0xFC00) == 0xDC00
            &&  (((WCHAR*)lpBase)[ichCurrent-1] & 0xFC00) == 0xD800) {

            ichCurrent--;
        }

        if (!pStart)
            ECUnlock(ped);

        return ichCurrent;
    }
#endif
}

/***************************************************************************\
* BOOL ECIsDBCSLeadByte( PED ped, BYTE cch )
*
*   IsDBCSLeadByte for Edit Control use only.
*
* History: 18-Jun-1996 Hideyuki Nagase
\***************************************************************************/
BOOL ECIsDBCSLeadByte(PED ped, BYTE cch)
{
    int i;

    if (!ped->fDBCS || !ped->fAnsi)
        return (FALSE);

    for (i = 0; ped->DBCSVector[i]; i += 2) {
        if ((ped->DBCSVector[i] <= cch) && (ped->DBCSVector[i+1] >= cch))
            return (TRUE);
    }

    return (FALSE);
}

/***************************************************************************\
* int DBCSCombine(HWND hwnd, int ch)
*
* Assemble two WM_CHAR messages to single DBCS character.
* If program detects first byte of DBCS character in WM_CHAR message,
* it calls this function to obtain second WM_CHAR message from queue.
* finally this routine assembles first byte and second byte into single
* DBCS character.
*
* History:
\***************************************************************************/
WORD DbcsCombine(HWND hwnd, WORD ch)
{
    MSG msg;
    int i = 10; /* loop counter to avoid the infinite loop */

    while (!PeekMessageA(&msg, hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) {
        if (--i == 0)
            return 0;
        Sleep(1);
    }

    return (WORD)ch | ((WORD)(msg.wParam) << 8);
}

/***************************************************************************\
* ICH ECAdjustIch( PED ped, LPSTR lpstr, ICH ch )
*
* This function adjusts a current pointer correctly. If a current
* pointer is lying between DBCS first byte and second byte, this
* function adjusts a current pointer to a first byte of DBCS position
* by decrement once.
*
* History:
\***************************************************************************/
ICH ECAdjustIch( PED ped, LPSTR lpstr, ICH ch )
{
    ICH newch = ch;

    if (!ped->fAnsi || !ped->fDBCS || newch == 0)
        return ( ch );

    if (!ECIsDBCSLeadByte(ped,lpstr[--newch]))
        return ( ch );  // previous char is SBCS
    while(1) {
        if (!ECIsDBCSLeadByte(ped,lpstr[newch])) {
            newch++;
            break;
        }
        if (newch)
            newch--;
        else
            break;
    }
    return ((ch - newch) & 1) ? ch-1 : ch;
}

/***************************************************************************\
* ICH ECAdjustIchNext( PED ped, LPSTR lpstr, ICH ch )
*
* History:
* 19.Jun.1996 Hideyuki Nagase [hideyukn] - Port from Win95-FarEast version
\***************************************************************************/

ICH FAR PASCAL ECAdjustIchNext(PED ped, LPSTR lpstr, ICH ch)
{
    ICH ichNew = ECAdjustIch(ped,lpstr,ch);
    LPSTR lpnew = lpstr+ichNew;

    // if ch > ichNew then ECAdjustIch adjusted ich.
    if (ch > ichNew)
       lpnew = ECAnsiNext(ped, lpnew);

    return (ICH)(lpnew-lpstr);
}

/***************************************************************************\
* ECUpdateFormat
*
* Computes ped->format and ped->fRtoLReading from dwStyle and dwExStyle.
* Refreshes the display if either are changed.
*
* History:
*    May 12, 1997   [samera]     wrote it
*    May 12, 1997   [dbrown]     rewrote it
\***************************************************************************/

void ECUpdateFormat(
    PED   ped,
    DWORD dwStyle,
    DWORD dwExStyle)
{
    UINT fNewRtoLReading;
    UINT uiNewFormat;

    // Extract new format and reading order from style

    fNewRtoLReading = dwExStyle & WS_EX_RTLREADING ? 1 : 0;
    uiNewFormat     = dwStyle & ES_FMTMASK;


    // WS_EX_RIGHT is ignored unless dwStyle is ES_LEFT

    if (uiNewFormat == ES_LEFT && dwExStyle & WS_EX_RIGHT) {
        uiNewFormat = ES_RIGHT;
    }


    // Internally ES_LEFT and ES_RIGHT are swapped for RtoLReading order
    // (Think of them as ES_LEADING and ES_TRAILING)

    if (fNewRtoLReading) {
        switch (uiNewFormat) {
            case ES_LEFT:  uiNewFormat = ES_RIGHT; break;
            case ES_RIGHT: uiNewFormat = ES_LEFT;  break;
        }
    }


    // Format change does not cause redisplay by itself

    ped->format = uiNewFormat;


    // Refresh display on change of reading order

    if (fNewRtoLReading != ped->fRtoLReading) {

        ped->fRtoLReading = fNewRtoLReading;

        if (ped->fWrap) {
            // Redo wordwrap
            MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);
            MLUpdateiCaretLine(ped);
        } else {
            // Refresh horizontal scrollbar display
            MLScroll(ped, FALSE, 0xffffffff, 0, TRUE);
        }
        ECInvalidateClient(ped, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\edmlrare.c ===
/****************************************************************************\
* edmlRare.c - Edit controls Routines Called rarely are to be
* put in a seperate segment _EDMLRare. This file contains
* these routines.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Multi-Line Support Routines called Rarely
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* MLInsertCrCrLf AorW
*
* Inserts CR CR LF characters into the text at soft (word-wrap) line
* breaks. CR LF (hard) line breaks are unaffected. Assumes that the text
* has already been formatted ie. ped->chLines is where we want the line
* breaks to occur. Note that ped->chLines is not updated to reflect the
* movement of text by the addition of CR CR LFs. Returns TRUE if successful
* else notify parent and return FALSE if the memory couldn't be allocated.
*
* History:
\***************************************************************************/

BOOL MLInsertCrCrLf(
    PED ped)
{
    ICH dch;
    ICH li;
    ICH lineSize;
    unsigned char *pchText;
    unsigned char *pchTextNew;

    if (!ped->fWrap || !ped->cch) {

        /*
         * There are no soft line breaks if word-wrapping is off or if no chars
         */
        return TRUE;
    }

    /*
     * Calc an upper bound on the number of additional characters we will be
     * adding to the text when we insert CR CR LFs.
     */
    dch = 3 * ped->cLines;

    if (!LOCALREALLOC(ped->hText, (ped->cch + dch) * ped->cbChar, 0, ped->hInstance, NULL)) {
        ECNotifyParent(ped, EN_ERRSPACE);
        return FALSE;
    }

    ped->cchAlloc = ped->cch + dch;

    /*
     * Move the text up dch bytes and then copy it back down, inserting the CR
     * CR LF's as necessary.
     */
    pchTextNew = pchText = ECLock(ped);
    pchText += dch * ped->cbChar;

    /*
     * We will use dch to keep track of how many chars we add to the text
     */
    dch = 0;

    /*
     * Copy the text up dch bytes to pchText. This will shift all indices in
     * ped->chLines up by dch bytes.
     */
    memmove(pchText, pchTextNew, ped->cch * ped->cbChar);

    /*
     * Now copy chars from pchText down to pchTextNew and insert CRCRLF at soft
     * line breaks.
     */
    if (ped->fAnsi) {
        for (li = 0; li < ped->cLines - 1; li++) {
            lineSize = ped->chLines[li + 1] - ped->chLines[li];
            memmove(pchTextNew, pchText, lineSize);
            pchTextNew += lineSize;
            pchText += lineSize;

            /*
             * If last character in newly copied line is not a line feed, then we
             * need to add the CR CR LF triple to the end
             */
            if (*(pchTextNew - 1) != 0x0A) {
                *pchTextNew++ = 0x0D;
                *pchTextNew++ = 0x0D;
                *pchTextNew++ = 0x0A;
                dch += 3;
            }
        }

        /*
         * Now move the last line up. It won't have any line breaks in it...
         */
        memmove(pchTextNew, pchText, ped->cch - ped->chLines[ped->cLines - 1]);
    } else { //!fAnsi
        LPWSTR pwchTextNew = (LPWSTR)pchTextNew;

        for (li = 0; li < ped->cLines - 1; li++) {
            lineSize = ped->chLines[li + 1] - ped->chLines[li];
            memmove(pwchTextNew, pchText, lineSize * sizeof(WCHAR));
            pwchTextNew += lineSize;
            pchText += lineSize * sizeof(WCHAR);

            /*
             * If last character in newly copied line is not a line feed, then we
             * need to add the CR CR LF triple to the end
             */
            if (*(pwchTextNew - 1) != 0x0A) {
                *pwchTextNew++ = 0x0D;
                *pwchTextNew++ = 0x0D;
                *pwchTextNew++ = 0x0A;
                dch += 3;
            }
        }

        /*
         * Now move the last line up. It won't have any line breaks in it...
         */
        memmove(pwchTextNew, pchText,
            (ped->cch - ped->chLines[ped->cLines - 1]) * sizeof(WCHAR));
    }

    ECUnlock(ped);

    if (dch) {
        /*
         * Update number of characters in text handle
         */
        ped->cch += dch;

        /*
         * So that the next time we do anything with the text, we can strip the
         * CRCRLFs
         */
        ped->fStripCRCRLF = TRUE;
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* MLStripCrCrLf AorW
*
* Strips the CR CR LF character combination from the text. This
* shows the soft (word wrapped) line breaks. CR LF (hard) line breaks are
* unaffected.
*
* History:
\***************************************************************************/

void MLStripCrCrLf(
    PED ped)
{
    if (ped->cch) {
        if (ped->fAnsi) {
            unsigned char *pchSrc;
            unsigned char *pchDst;
            unsigned char *pchLast;

            pchSrc = pchDst = ECLock(ped);
            pchLast = pchSrc + ped->cch;
            while (pchSrc < pchLast) {
                if (   (pchSrc[0] == 0x0D)
                    && (pchSrc[1] == 0x0D)
                    && (pchSrc[2] == 0x0A)
                ) {
                    pchSrc += 3;
                    ped->cch -= 3;
                } else {
                    *pchDst++ = *pchSrc++;
                }
            }
        } else { // !fAnsi
            LPWSTR pwchSrc;
            LPWSTR pwchDst;
            LPWSTR pwchLast;

            pwchSrc = pwchDst = (LPWSTR)ECLock(ped);
            pwchLast = pwchSrc + ped->cch;
            while (pwchSrc < pwchLast) {
                if (   (pwchSrc[0] == 0x0D)
                    && (pwchSrc[1] == 0x0D)
                    && (pwchSrc[2] == 0x0A)
                ) {
                    pwchSrc += 3;
                    ped->cch -= 3;
                } else {
                    *pwchDst++ = *pwchSrc++;
                }
            }
        }
        ECUnlock(ped);

        /*
         * Make sure we don't have any values past the last character
         */
        if (ped->ichCaret > ped->cch)
            ped->ichCaret  = ped->cch;
        if (ped->ichMinSel > ped->cch)
            ped->ichMinSel = ped->cch;
        if (ped->ichMaxSel > ped->cch)
            ped->ichMaxSel = ped->cch;
    }
}

/***************************************************************************\
* MLSetHandle AorW
*
* Sets the ped to contain the given handle.
*
* History:
\***************************************************************************/

void MLSetHandle(
    PED ped,
    HANDLE hNewText)
{
    ICH newCch;

    ped->cch = ped->cchAlloc =
            LOCALSIZE(ped->hText = hNewText, ped->hInstance) / ped->cbChar;
    ped->fEncoded = FALSE;

    if (ped->cch) {

        /*
         * We have to do it this way in case the app gives us a zero size handle
         */
        if (ped->fAnsi)
            ped->cch = strlen(ECLock(ped));
        else
            ped->cch = wcslen((LPWSTR)ECLock(ped));
        ECUnlock(ped);
    }

    newCch = (ICH)(ped->cch + CCHALLOCEXTRA);

    /*
     * We do this LocalReAlloc in case the app changed the size of the handle
     */
    if (LOCALREALLOC(ped->hText, newCch*ped->cbChar, 0, ped->hInstance, NULL))
        ped->cchAlloc = newCch;

    ECResetTextInfo(ped);
}

/***************************************************************************\
* MLGetLine AorW
*
* Copies maxCchToCopy bytes of line lineNumber to the buffer
* lpBuffer. The string is not zero terminated.
*
* Returns number of characters copied
*
* History:
\***************************************************************************/

LONG MLGetLine(
    PED ped,
    ICH lineNumber, //WASDWORD
    ICH maxCchToCopy,
    LPSTR lpBuffer)
{
    PSTR pText;
    ICH cchLen;

    if (lineNumber > ped->cLines - 1) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"lineNumber\" (%ld) to MLGetLine",
                lineNumber);

        return 0L;
    }

    cchLen = MLLine(ped, lineNumber);
    maxCchToCopy = min(cchLen, maxCchToCopy);

    if (maxCchToCopy) {
        pText = ECLock(ped) +
                ped->chLines[lineNumber] * ped->cbChar;
        memmove(lpBuffer, pText, maxCchToCopy*ped->cbChar);
        ECUnlock(ped);
    }

    return maxCchToCopy;
}

/***************************************************************************\
* MLLineIndex AorW
*
* This function return s the number of character positions that occur
* preceeding the first char in a given line.
*
* History:
\***************************************************************************/

ICH MLLineIndex(
    PED ped,
    ICH iLine) //WASINT
{
    if (iLine == -1)
        iLine = ped->iCaretLine;
    if (iLine < ped->cLines) {
        return ped->chLines[iLine];
    } else {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"iLine\" (%ld) to MLLineIndex",
                iLine);

        return (ICH)-1;
    }
}

/***************************************************************************\
* MLLineLength AorW
*
* if ich = -1, return the length of the lines containing the current
* selection but not including the selection. Otherwise, return the length of
* the line containing ich.
*
* History:
\***************************************************************************/

ICH MLLineLength(
    PED ped,
    ICH ich)
{
    ICH il1, il2;
    ICH temp;

    if (ich != 0xFFFFFFFF)
        return (MLLine(ped, MLIchToLine(ped, ich)));

    /*
     * Find length of lines corresponding to current selection
     */
    il1 = MLIchToLine(ped, ped->ichMinSel);
    il2 = MLIchToLine(ped, ped->ichMaxSel);
    if (il1 == il2)
        return (MLLine(ped, il1) - (ped->ichMaxSel - ped->ichMinSel));

    temp = ped->ichMinSel - ped->chLines[il1];
    temp += MLLine(ped, il2);
    temp -= (ped->ichMaxSel - ped->chLines[il2]);

    return temp;
}

/***************************************************************************\
* MLSetSelection AorW
*
* Sets the selection to the points given and puts the cursor at
* ichMaxSel.
*
* History:
\***************************************************************************/

void MLSetSelection(
    PED  ped,
    BOOL fDoNotScrollCaret,
    ICH  ichMinSel,
    ICH  ichMaxSel)
{
    HDC hdc;

    if (ichMinSel == 0xFFFFFFFF) {

        /*
         * Set no selection if we specify -1
         */
        ichMinSel = ichMaxSel = ped->ichCaret;
    }

    /*
     * Since these are unsigned, we don't check if they are greater than 0.
     */
    ichMinSel = min(ped->cch, ichMinSel);
    ichMaxSel = min(ped->cch, ichMaxSel);

#ifdef FE_SB // MLSetSelectionHander()
    //
    // To avoid position to half of DBCS, check and ajust position if necessary
    //
    // We check ped->fDBCS and ped->fAnsi though ECAdjustIch checks these bits
    // at first. We're worrying about the overhead of ECLock and ECUnlock.
    //
    if ( ped->fDBCS && ped->fAnsi ) {

        PSTR pText;

        pText = ECLock(ped);
        ichMinSel = ECAdjustIch( ped, pText, ichMinSel );
        ichMaxSel = ECAdjustIch( ped, pText, ichMaxSel );
        ECUnlock(ped);
    }
#endif // FE_SB

    /*
     * Set the caret's position to be at ichMaxSel.
     */
    ped->ichCaret = ichMaxSel;
    ped->iCaretLine = MLIchToLine(ped, ped->ichCaret);

    hdc = ECGetEditDC(ped, FALSE);
    MLChangeSelection(ped, hdc, ichMinSel, ichMaxSel);

    MLSetCaretPosition(ped, hdc);
    ECReleaseEditDC(ped, hdc, FALSE);

#ifdef FE_SB // MLSetSelectionHander()
    if (!fDoNotScrollCaret)
        MLEnsureCaretVisible(ped);
    /*
     * #ifdef KOREA is history, with FE_SB (FarEast Single Binary).
     */
#else
#ifdef KOREA
    /*
     * Extra parameter specified interim character mode
     */
    MLEnsureCaretVisible(ped,NULL);
#else
    if (!fDoNotScrollCaret)
        MLEnsureCaretVisible(ped);
#endif
#endif // FE_SB
}

/***************************************************************************\
* MLSetTabStops AorW
*
*
* MLSetTabStops(ped, nTabPos, lpTabStops)
*
* This sets the tab stop positions set by the App by sending
* a EM_SETTABSTOPS message.
*
* nTabPos : Number of tab stops set by the caller
* lpTabStops: array of tab stop positions in Dialog units.
*
* Returns:
* TRUE if successful
* FALSE if memory allocation error.
*
* History:
\***************************************************************************/

BOOL MLSetTabStops(
    PED ped,
    int nTabPos,
    LPINT lpTabStops)
{
    int *pTabStops;

    /*
     * Check if tab positions already exist
     */
    if (!ped->pTabStops) {

        /*
         * Check if the caller wants the new tab positions
         */
        if (nTabPos) {

            /*
             * Allocate the array of tab stops
             */
            if (!(pTabStops = (LPINT)UserLocalAlloc(HEAP_ZERO_MEMORY, (nTabPos + 1) * sizeof(int)))) {
                return FALSE;
            }
        } else {
            return TRUE; /* No stops then and no stops now! */
        }
    } else {

        /*
         * Check if the caller wants the new tab positions
         */
        if (nTabPos) {

            /*
             * Check if the number of tab positions is different
             */
            if (ped->pTabStops[0] != nTabPos) {

                /*
                 * Yes! So ReAlloc to new size
                 */
                if (!(pTabStops = (LPINT)UserLocalReAlloc(ped->pTabStops,
                        (nTabPos + 1) * sizeof(int), 0)))
                    return FALSE;
            } else {
                pTabStops = ped->pTabStops;
            }
        } else {

            /*
             * Caller wants to remove all the tab stops; So, release
             */
            if (!UserLocalFree(ped->pTabStops))
                return FALSE;  /* Failure */
            ped->pTabStops = NULL;
            goto RedrawAndReturn;
        }
    }

    /*
     * Copy the new tab stops onto the tab stop array after converting the
     * dialog co-ordinates into the pixel co-ordinates
     */
    ped->pTabStops = pTabStops;
    *pTabStops++ = nTabPos; /* First element contains the count */
    while (nTabPos--) {

        /*
         * aveCharWidth must be used instead of cxSysCharWidth.
         * Fix for Bug #3871 --SANKAR-- 03/14/91
         */
        *pTabStops++ = MultDiv(*lpTabStops++, ped->aveCharWidth, 4);
    }

RedrawAndReturn:
    // Because the tabstops have changed, we need to recompute the
    // maxPixelWidth. Otherwise, horizontal scrolls will have problems.
    // Fix for Bug #6042 - 3/15/94
    MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);

    // Caret may have changed line by the line recalc above.
    MLUpdateiCaretLine(ped);

    MLEnsureCaretVisible(ped);

    // Also, we need to redraw the whole window.
    NtUserInvalidateRect(ped->hwnd, NULL, TRUE);
    return TRUE;
}

/***************************************************************************\
* MLUndo AorW
*
* Handles Undo for multiline edit controls.
*
* History:
\***************************************************************************/

BOOL MLUndo(
    PED ped)
{
    HANDLE hDeletedText = ped->hDeletedText;
    BOOL fDelete = (BOOL)(ped->undoType & UNDO_DELETE);
    ICH cchDeleted = ped->cchDeleted;
    ICH ichDeleted = ped->ichDeleted;

    if (ped->undoType == UNDO_NONE) {

        /*
         * No undo...
         */
        return FALSE;
    }

    ped->hDeletedText = NULL;
    ped->cchDeleted = 0;
    ped->ichDeleted = (ICH)-1;
    ped->undoType &= ~UNDO_DELETE;

    if (ped->undoType == UNDO_INSERT) {
        ped->undoType = UNDO_NONE;

        /*
         * Set the selection to the inserted text
         */
        MLSetSelection(ped, FALSE, ped->ichInsStart, ped->ichInsEnd);
        ped->ichInsStart = ped->ichInsEnd = (ICH)-1;

        /*
         * Now send a backspace to delete and save it in the undo buffer...
         */
        SendMessage(ped->hwnd, WM_CHAR, (WPARAM)VK_BACK, 0L);
    }

    if (fDelete) {

        /*
         * Insert deleted chars
         */

        /*
         * Set the selection to the inserted text
         */
        MLSetSelection(ped, FALSE, ichDeleted, ichDeleted);
        MLInsertText(ped, hDeletedText, cchDeleted, FALSE);

        UserGlobalFree(hDeletedText);
        MLSetSelection(ped, FALSE, ichDeleted, ichDeleted + cchDeleted);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\edecrare.c ===
/****************************************************************************\
* edECRare.c - EC Edit controls Routines Called rarely are to be
* put in a seperate segment _EDECRare. This file contains
* these routines.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Support Routines common to Single-line and Multi-Line edit controls
* called Rarely.
*
* Created: 02-08-89 sankar
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop


extern LOOKASIDE EditLookaside;

#define WS_EX_EDGEMASK (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)

/*
 * Those two macros assume PED can be referred as "ped."
 */
#define GetCharABCWidthsAorW    ((ped)->fAnsi ? GetCharABCWidthsA : GetCharABCWidthsW)
#define GetCharWidthAorW        ((ped)->fAnsi ? GetCharWidthA : GetCharWidthW)

#define umin(a, b)  ((unsigned)(a) < (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))

typedef BOOL (*PFNABCWIDTHS)(HDC, UINT, UINT, LPABC);
typedef BOOL (*PFNCHARWIDTH)(HDC, UINT, UINT, LPINT);

/***************************************************************************\
*
*  GetMaxOverlapChars - Gives maximum number of overlapping characters due to
*                       negative A or C widths.
*
\***************************************************************************/
DWORD GetMaxOverlapChars( void )
{
    return (DWORD) MAKELONG( gpsi->wMaxLeftOverlapChars, gpsi->wMaxRightOverlapChars ) ;
}

/***************************************************************************\
*
*  ECSetMargin()
*
\***************************************************************************/
void ECSetMargin(PED ped, UINT  wFlags, long lMarginValues, BOOL fRedraw)
{
    BOOL fUseFontInfo = FALSE;
    UINT wValue, wOldLeftMargin, wOldRightMargin;


    if (wFlags & EC_LEFTMARGIN)  /* Set the left margin */ {

        if ((int) (wValue = (int)(short)LOWORD(lMarginValues)) < 0) {
            fUseFontInfo = TRUE;
            wValue = min((ped->aveCharWidth / 2), (int)ped->wMaxNegA);
        }

        ped->rcFmt.left += wValue - ped->wLeftMargin;
        wOldLeftMargin = ped->wLeftMargin;
        ped->wLeftMargin = wValue;
    }

    if (wFlags & EC_RIGHTMARGIN)  /* Set the Right margin */ {

        if ((int) (wValue = (int)(short)HIWORD(lMarginValues)) < 0) {
            fUseFontInfo = TRUE;
            wValue = min((ped->aveCharWidth / 2), (int)ped->wMaxNegC);
        }

        ped->rcFmt.right -= wValue - ped->wRightMargin;
        wOldRightMargin = ped->wRightMargin;
        ped->wRightMargin = wValue;
    }

    if (fUseFontInfo) {
        if (ped->rcFmt.right - ped->rcFmt.left < 2 * ped->aveCharWidth) {
            RIPMSG0(RIP_WARNING, "ECSetMargin: rcFmt is too narrow for EC_USEFONTINFO");

            if (wFlags & EC_LEFTMARGIN)  /* Reset the left margin */ {
                ped->rcFmt.left += wOldLeftMargin - ped->wLeftMargin;
                ped->wLeftMargin = wOldLeftMargin;
            }

            if (wFlags & EC_RIGHTMARGIN)  /* Reset the Right margin */ {
                ped->rcFmt.right -= wOldRightMargin - ped->wRightMargin;
                ped->wRightMargin = wOldRightMargin;
            }

            return;
        }
    }

//    NtUserInvalidateRect(ped->hwnd, NULL, TRUE);
    if (fRedraw) {
        ECInvalidateClient(ped, TRUE);
    }
}

// --------------------------------------------------------------------------
//
//  ECCalcMarginfForDBCSFont()
//
// Jun.24.1996 HideyukN - Ported from Windows95 FarEast version (edecrare.c)
// --------------------------------------------------------------------------
void ECCalcMarginForDBCSFont(PED ped, BOOL fRedraw)
{
    if (!ped->fTrueType)
        return;

    if (!ped->fSingle) {
        // wMaxNegA came from ABC CharWidth.
        if (ped->wMaxNegA != 0) {
            ECSetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                    MAKELONG(EC_USEFONTINFO, EC_USEFONTINFO),fRedraw);
        }
    } else {
        int    iMaxNegA = 0, iMaxNegC = 0;
        int    i;
        PVOID  lpBuffer;
        LPABC  lpABCBuff;
        ABC    ABCInfo;
        HFONT  hOldFont;
        HDC    hdc = NtUserGetDC(ped->hwnd);

        if (!ped->hFont || !(hOldFont = SelectFont(hdc, ped->hFont))) {
            ReleaseDC(ped->hwnd, hdc);
            return;
        }

        if (lpBuffer = UserLocalAlloc(0,sizeof(ABC) * 256)) {
            lpABCBuff = lpBuffer;
            GetCharABCWidthsAorW(hdc, 0, 255, lpABCBuff);
        } else {
            lpABCBuff = &ABCInfo;
            GetCharABCWidthsAorW(hdc, 0, 0, lpABCBuff);
        }

        i = 0;
        while (TRUE) {
            iMaxNegA = min(iMaxNegA, lpABCBuff->abcA);
            iMaxNegC = min(iMaxNegC, lpABCBuff->abcC);
            if (++i == 256)
                break;
            if (lpBuffer) {
                lpABCBuff++;
            } else {
                GetCharABCWidthsAorW(hdc, i, i, lpABCBuff);
            }
        }

        SelectFont(hdc, hOldFont);

        if (lpBuffer) UserLocalFree(lpBuffer);

        ReleaseDC(ped->hwnd, hdc);

        if ((iMaxNegA != 0) || (iMaxNegC != 0))
           ECSetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                    MAKELONG((UINT)(-iMaxNegC), (UINT)(-iMaxNegA)),fRedraw);
    }

    return;
}

// --------------------------------------------------------------------------
//
//  GetCharDimensionsEx(HDC hDC, HFONT hfont, LPTEXTMETRIC lptm, LPINT lpcy)
//
// Jun.24.1996 HideyukN - Ported from Windows95 FarEast version (wmclient.c)
// --------------------------------------------------------------------------

CONST WCHAR AveCharWidthData[] = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
//
// if an app set a font for vertical writing, even though we don't
// handle it with EC, the escapement of tm can be NON 0. Then cxWidth from
// GetCharDimenstions() could be 0 in GetCharDimensions().
// This will break our caller who don't expect 0 at return. So I created
// this entry  for the case the caller set vertical font.
//
//
int UserGetCharDimensionsEx(HDC hDC, HFONT hfont, LPTEXTMETRIC lptm, LPINT lpcy)
{
    int         cxWidth;
    TEXTMETRIC  tm;
    LOGFONTW    lf;
    WCHAR       wchFaceName[LF_FACESIZE];

    //
    // Is this font vertical font ??
    //
    wchFaceName[0] = 0;
    GetTextFaceW(hDC, LF_FACESIZE, wchFaceName);
    if (wchFaceName[0] != L'@') {
        //
        // if not call GDI...
        //
        return(GdiGetCharDimensions(hDC, lptm, lpcy));
    }

    if (!lptm)
        lptm = &tm;

    GetTextMetrics(hDC, lptm);

    // TMPF_FIXED_PITCH
    //
    //   If this bit is set the font is a variable pitch font.
    //   If this bit is clear the font is a fixed pitch font.
    // Note very carefully that those meanings are the opposite of what the constant name implies.
    //
    if (!(lptm->tmPitchAndFamily & TMPF_FIXED_PITCH)) { // If !variable_width font
        // This is fixed pitch font....
        cxWidth = lptm->tmAveCharWidth;
    } else {
        // This is variable pitch font...
        if (hfont && GetObjectW(hfont, sizeof(LOGFONTW), &lf) && (lf.lfEscapement != 0)) {
            cxWidth = lptm->tmAveCharWidth;
        } else {
            SIZE size;
            GetTextExtentPointW(hDC, AveCharWidthData, 52, &size);
            cxWidth = ((size.cx / 26) + 1) / 2;
        }
    }

    if (lpcy)
        *lpcy = lptm->tmHeight;

    return(cxWidth);
}

/***************************************************************************\
* ECGetText AorW
*
* Copies at most maxCchToCopy chars to the buffer lpBuffer. Returns
* how many chars were actually copied. Null terminates the string based
* on the fNullTerminate flag:
* fNullTerminate --> at most (maxCchToCopy - 1) characters will be copied
* !fNullTerminate --> at most (maxCchToCopy) characters will be copied
*
* History:
\***************************************************************************/

ICH ECGetText(
    PED ped,
    ICH maxCchToCopy,
    LPSTR lpBuffer,
    BOOL fNullTerminate)
{
    PSTR pText;

    if (maxCchToCopy) {

        /*
         * Zero terminator takes the extra byte
         */
        if (fNullTerminate)
            maxCchToCopy--;
        maxCchToCopy = min(maxCchToCopy, ped->cch);

        /*
         * Zero terminate the string
         */
        if (ped->fAnsi)
            *(LPSTR)(lpBuffer + maxCchToCopy) = 0;
        else
            *(((LPWSTR)lpBuffer) + maxCchToCopy) = 0;

        pText = ECLock(ped);
        RtlCopyMemory(lpBuffer, pText, maxCchToCopy*ped->cbChar);
        ECUnlock(ped);
    }

    return maxCchToCopy;
}

/***************************************************************************\
* ECNcCreate AorW
*
* History:
\***************************************************************************/

BOOL ECNcCreate(
    PED ped,
    PWND pwnd,
    LPCREATESTRUCT lpCreateStruct)
{
    HWND hwnd = HWq(pwnd);
    BOOL fAnsi;

    fAnsi = TestWF(pwnd, WFANSICREATOR);

    /*
     * Initialize the ped
     */
    ped->fEncoded = FALSE;
    ped->iLockLevel = 0;

    ped->chLines = NULL;
    ped->pTabStops = NULL;
    ped->charWidthBuffer = NULL;
    ped->fAnsi = fAnsi ? 1 : 0; // Force TRUE to be 1 because its a 1 bit field
    ped->cbChar = (WORD)(fAnsi ? sizeof(CHAR) : sizeof(WCHAR));
    ped->hInstance = KHANDLE_TO_HANDLE(pwnd->hModule);
    // IME
    ped->hImcPrev = NULL_HIMC;

    {
        DWORD dwVer = GETEXPWINVER(lpCreateStruct->hInstance);

        ped->fWin31Compat = (dwVer >= 0x030a);
        ped->f40Compat = (dwVer >= 0x0400);
    }

    //
    // NOTE:
    // The order of the following two checks is important.  People can
    // create edit fields with a 3D and a normal border, and we don't
    // want to disallow that.  But we need to detect the "no 3D border"
    // border case too.
    //
    if (TestWF(pwnd, WEFEDGEMASK))
    {
        ped->fBorder = TRUE;
    }
    else if (TestWF(pwnd, WFBORDER))
    {
        ClearWindowState(pwnd, WFBORDER);
        ped->fFlatBorder = TRUE;
        ped->fBorder = TRUE;
    }

    if (!TestWF(pwnd, EFMULTILINE))
        ped->fSingle = TRUE;

    if (TestWF(pwnd, WFDISABLED))
        ped->fDisabled = TRUE;

    if (TestWF(pwnd, EFREADONLY)) {
        if (!ped->fWin31Compat) {
            /*
             * BACKWARD COMPATIBILITY HACK
             *
             * "MileStone" unknowingly sets the ES_READONLY style. So, we strip this
             * style here for all Win3.0 apps (this style is new for Win3.1).
             * Fix for Bug #12982 -- SANKAR -- 01/24/92 --
             */
             ClearWindowState(pwnd, EFREADONLY);
        } else
            ped->fReadOnly = TRUE;
    }


    /*
     * Allocate storage for the text for the edit controls. Storage for single
     * line edit controls will always get allocated in the local data segment.
     * Multiline will allocate in the local ds but the app may free this and
     * allocate storage elsewhere...
     */
    ped->hText = LOCALALLOC(LHND, CCHALLOCEXTRA*ped->cbChar, ped->hInstance);
    if (!ped->hText) {
        FreeLookasideEntry(&EditLookaside, ped);
        NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT); /* No ped for this window */
        return FALSE;
    }

    ped->cchAlloc = CCHALLOCEXTRA;
    ped->lineHeight = 1;

    ped->hwnd = hwnd;
    ped->hwndParent = lpCreateStruct->hwndParent;

    ped->wImeStatus = 0;

    return (BOOL)DefWindowProcWorker(pwnd,
                                     WM_NCCREATE,
                                     0,
                                     (LPARAM)lpCreateStruct,
                                     fAnsi);
}

/***************************************************************************\
* ECCreate AorW
*
* History:
\***************************************************************************/

BOOL ECCreate(
    PED ped,
    LONG windowStyle)
{
    HDC hdc;

    /*
     * Get values from the window instance data structure and put them in the
     * ped so that we can access them easier.
     */
    if (windowStyle & ES_AUTOHSCROLL)
        ped->fAutoHScroll = 1;
    if (windowStyle & ES_NOHIDESEL)
        ped->fNoHideSel = 1;

    ped->format = (LOWORD(windowStyle) & LOWORD(ES_FMTMASK));
    if (TestWF(ped->pwnd, WEFRIGHT) && !ped->format)
        ped->format = ES_RIGHT;

    ped->cchTextMax = MAXTEXT; /* Max # chars we will initially allow */

    /*
     * Set up undo initial conditions... (ie. nothing to undo)
     */
    ped->ichDeleted = (ICH)-1;
    ped->ichInsStart = (ICH)-1;
    ped->ichInsEnd = (ICH)-1;

    // initial charset value - need to do this BEFORE MLCreate is called
    // so that we know not to fool with scrollbars if nessacary
    hdc = ECGetEditDC(ped, TRUE);
    ped->charSet = (BYTE)GetTextCharset(hdc);
    ECReleaseEditDC(ped, hdc, TRUE);

    // FE_IME
    // EC_INSERT_COMPOSITION_CHARACTER: ECCreate() - call ECInitInsert()
    ECInitInsert(ped, THREAD_HKL());

    if(ped->pLpkEditCallout = fpLpkEditControl) {
        return ped->pLpkEditCallout->EditCreate(ped, HW(ped->pwnd));
    } else
        return TRUE;
}

/***************************************************************************\
* ECNcDestroyHandler AorW
*
* Destroys the edit control ped by freeing up all memory used by it.
*
* History:
\***************************************************************************/
VOID ECNcDestroyHandler(
    PWND pwnd,
    PED ped)
{
    PWND pwndParent;

    /*
     * Ped could be NULL if WM_NCCREATE failed to create it.
     */
    if (ped) {
        /*
         * Free the text buffer.
         */
        LOCALFREE(ped->hText, ped->hInstance);

        /*
         * Free up undo buffer and line start array (if present).
         */
        if (ped->hDeletedText != NULL) {
            UserGlobalFree(ped->hDeletedText);
        }

        /*
         * Free tab stop buffer (if present)
         */
        if (ped->pTabStops) {
            UserLocalFree(ped->pTabStops);
        }

        /*
         * Free line start array (if present)
         */
        if (ped->chLines) {
            UserLocalFree(ped->chLines);
        }

        /*
         * Free the character width buffer (if present).
         */
        if (ped->charWidthBuffer) {
            UserLocalFree(ped->charWidthBuffer);
        }

        /*
         * Free the cursor bitmap.
         */
        if (ped->pLpkEditCallout && ped->hCaretBitmap) {
            DeleteObject(ped->hCaretBitmap);
        }

        /*
         * Last but not least, free the ped.
         */
        FreeLookasideEntry(&EditLookaside, ped);
    }

    /*
     * Set the window's fnid status so that we can ignore rogue messages.
     */
    NtUserSetWindowFNID(HWq(pwnd), FNID_CLEANEDUP_BIT);

    /*
     * If we're part of a combo box, let it know we're gone.
     */
    pwndParent = REBASEPWND(pwnd, spwndParent);
    if (pwndParent && GETFNID(pwndParent) == FNID_COMBOBOX) {
        ComboBoxWndProcWorker(pwndParent,
                              WM_PARENTNOTIFY,
                              MAKELONG(WM_DESTROY, PTR_TO_ID(pwnd->spmenu)),
                              (LPARAM)HWq(pwnd),
                              FALSE);
    }
}

/***************************************************************************\
* ECSetPasswordChar AorW
*
* Sets the password char to display.
*
* History:
\***************************************************************************/

void ECSetPasswordChar(
    PED ped,
    UINT pwchar)
{
    HDC hdc;
    SIZE size;

    ped->charPasswordChar = pwchar;

    if (pwchar) {
        hdc = ECGetEditDC(ped, TRUE);
        if (ped->fAnsi)
            GetTextExtentPointA(hdc, (LPSTR)&pwchar, 1, &size);
        else
            GetTextExtentPointW(hdc, (LPWSTR)&pwchar, 1, &size);

        GetTextExtentPointW(hdc, (LPWSTR)&pwchar, 1, &size);
        ped->cPasswordCharWidth = max(size.cx, 1);
        ECReleaseEditDC(ped, hdc, TRUE);
    }
    if (pwchar)
        SetWindowState(ped->pwnd, EFPASSWORD);
    else
        ClearWindowState(ped->pwnd, EFPASSWORD);

    ECEnableDisableIME(ped);
}

/***************************************************************************\
*  GetNegABCwidthInfo()
*    This function fills up the ped->charWidthBuffer buffer with the
*      negative A,B and C widths for all the characters below 0x7f in the
*      currently selected font.
*  Returns:
* TRUE, if the function succeeded.
* FALSE, if GDI calls to get the char widths have failed.
*
* Note: not used if LPK installed
\***************************************************************************/
BOOL   GetNegABCwidthInfo(
    PED ped,
    HDC hdc)
{
    LPABC lpABCbuff;
    int   i;
    int   CharWidthBuff[CHAR_WIDTH_BUFFER_LENGTH]; // Local char width buffer.
    int   iOverhang;

    if (!GetCharABCWidthsA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, (LPABC)ped->charWidthBuffer)) {
        RIPMSG0(RIP_WARNING, "GetNegABCwidthInfo: GetCharABCWidthsA Failed");
        return FALSE;
    }

   // The (A+B+C) returned for some fonts (eg: Lucida Caligraphy) does not
   // equal the actual advanced width returned by GetCharWidths() minus overhang.
   // This is due to font bugs. So, we adjust the 'B' width so that this
   // discrepancy is removed.
   // Fix for Bug #2932 --sankar-- 02/17/93
   iOverhang = ped->charOverhang;
   GetCharWidthA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, (LPINT)CharWidthBuff);
   lpABCbuff = (LPABC)ped->charWidthBuffer;
   for(i = 0; i < CHAR_WIDTH_BUFFER_LENGTH; i++) {
        lpABCbuff->abcB = CharWidthBuff[i] - iOverhang
                - lpABCbuff->abcA
                - lpABCbuff->abcC;
        lpABCbuff++;
   }

   return(TRUE);
}

/***************************************************************************\
*
*  ECSize() -
*
*  Handle sizing for an edit control's client rectangle.
*  Use lprc as the bounding rectangle if specified; otherwise use the current
*  client rectangle.
*
\***************************************************************************/

void ECSize(
    PED ped,
    LPRECT lprc,
    BOOL fRedraw)
{
    RECT    rc;

    /*
     *  BiDi VB32 Creates an Edit Control and immediately sends a WM_SIZE
     *  message which causes EXSize to be called before ECSetFont, which
     *  in turn causes a divide by zero exception below. This check for
     *  ped->lineHeight will pick it up safely. [samera] 3/5/97
     */
    if(ped->lineHeight == 0)
        return;

    // assume that we won't be able to display the caret
    ped->fCaretHidden = TRUE;


    if ( lprc )
        CopyRect(&rc, lprc);
    else
        _GetClientRect(ped->pwnd, &rc);

    if (!(rc.right - rc.left) || !(rc.bottom - rc.top)) {
        if (ped->rcFmt.right - ped->rcFmt.left)
            return;

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = ped->aveCharWidth * 10;
        rc.bottom   = ped->lineHeight;
    }

    if (!lprc) {
        // subtract the margins from the given rectangle --
        // make sure that this rectangle is big enough to have these margins.
        if ((rc.right - rc.left) > (int)(ped->wLeftMargin + ped->wRightMargin)) {
            rc.left  += ped->wLeftMargin;
            rc.right -= ped->wRightMargin;
        }
    }

    //
    // Leave space so text doesn't touch borders.
    // For 3.1 compatibility, don't subtract out vertical borders unless
    // there is room.
    //
    if (ped->fBorder) {
        int cxBorder = SYSMET(CXBORDER);
        int cyBorder = SYSMET(CYBORDER);

        if (ped->fFlatBorder)
        {
            cxBorder *= 2;
            cyBorder *= 2;
        }

        if (rc.bottom < rc.top + ped->lineHeight + 2*cyBorder)
            cyBorder = 0;

        InflateRect(&rc, -cxBorder, -cyBorder);
    }

    // Is the resulting rectangle too small?  Don't change it then.
    if ((!ped->fSingle) && ((rc.right - rc.left < (int) ped->aveCharWidth) ||
        ((rc.bottom - rc.top) / ped->lineHeight == 0)))
        return;

    // now, we know we're safe to display the caret
    ped->fCaretHidden = FALSE;

    CopyRect(&ped->rcFmt, &rc);

    if (ped->fSingle)
        ped->rcFmt.bottom = min(rc.bottom, rc.top + ped->lineHeight);
    else
        MLSize(ped, fRedraw);

    if (fRedraw) {
        NtUserInvalidateRect(ped->hwnd, NULL, TRUE);
        // UpdateWindow31(ped->hwnd);    Evaluates to NOP in Chicago - Johnl
    }

    // FE_IME
    // ECSize()  - call ECImmSetCompositionWindow()
    //
    // normally this isn't needed because WM_SIZE will cause
    // WM_PAINT and the paint handler will take care of IME
    // composition window. However when the edit window is
    // restored from maximized window and client area is out
    // of screen, the window will not be redrawn.
    //
    if (ped->fFocus && fpImmIsIME(THREAD_HKL())) {
        POINT pt;

        NtUserGetCaretPos(&pt);
        ECImmSetCompositionWindow(ped, pt.x, pt.y);
    }
}

/***************************************************************************\
*
*  ECSetFont AorW () -
*
*  Sets the font used in the edit control.  Warning:  Memory compaction may
*  occur if the font wasn't previously loaded.  If the font handle passed
*  in is NULL, assume the system font.
*
\***************************************************************************/
void   ECSetFont(
    PED ped,
    HFONT hfont,
    BOOL fRedraw)
{
    short  i;
    TEXTMETRIC      TextMetrics;
    HDC             hdc;
    HFONT           hOldFont=NULL;
    UINT            wBuffSize;
    LPINT           lpCharWidthBuff;
    DWORD           dwMaxOverlapChars;
    CHWIDTHINFO     cwi;
    UINT            uExtracharPos;

    hdc = NtUserGetDC(ped->hwnd);

    if (ped->hFont = hfont) {
        //
        // Since the default font is the system font, no need to select it in
        // if that's what the user wants.
        //
        if (!(hOldFont = SelectObject(hdc, hfont))) {
            hfont = ped->hFont = NULL;
        }

        //
        // Get the metrics and ave char width for the currently selected font
        //

        //
        // Call Vertical font-aware AveWidth compute function...
        //
        // FE_SB
        ped->aveCharWidth = UserGetCharDimensionsEx(hdc, hfont, &TextMetrics, &ped->lineHeight);

        /*
         * This might fail when people uses network fonts (or bad fonts).
         */
        if (ped->aveCharWidth == 0) {
            RIPMSG0(RIP_WARNING, "ECSetFont: GdiGetCharDimensions failed");
            if (hOldFont != NULL) {
                SelectObject(hdc, hOldFont);
            }

            /*
             * We've messed up the ped so let's reset the font.
             *  Note that we won't recurse more than once because we'll
             *  pass hfont == NULL.
             * Too bad WM_SETFONT doesn't return a value.
             */
            ECSetFont(ped, NULL, fRedraw);
            return;
        }
    } else {
        ped->aveCharWidth = gpsi->cxSysFontChar;
        ped->lineHeight = gpsi->cySysFontChar;
        TextMetrics = gpsi->tmSysFont;
    }

    ped->charOverhang = TextMetrics.tmOverhang;

    //assume that they don't have any negative widths at all.
    ped->wMaxNegA = ped->wMaxNegC = ped->wMaxNegAcharPos = ped->wMaxNegCcharPos = 0;


    // Check if Proportional Width Font
    //
    // NOTE: as SDK doc says about TEXTMETRIC:
    // TMPF_FIXED_PITCH
    // If this bit is set the font is a variable pitch font. If this bit is clear
    // the font is a fixed pitch font. Note very carefully that those meanings are
    // the opposite of what the constant name implies.
    //
    // Thus we have to reverse the value using logical not (fNonPropFont has 1 bit width)
    //
    ped->fNonPropFont = !(TextMetrics.tmPitchAndFamily & FIXED_PITCH);

    // Check for a TrueType font
    // Older app OZWIN chokes if we allocate a bigger buffer for TrueType fonts
    // So, for apps older than 4.0, no special treatment for TrueType fonts.
    if (ped->f40Compat && (TextMetrics.tmPitchAndFamily & TMPF_TRUETYPE)) {
        ped->fTrueType = GetCharWidthInfo(hdc, &cwi);
#if DBG
        if (!ped->fTrueType) {
            RIPMSG0(RIP_WARNING, "ECSetFont: GetCharWidthInfo Failed");
        }
#endif
    } else {
        ped->fTrueType = FALSE;
    }

    // FE_SB
    //
    // In DBCS Windows, Edit Control must handle Double Byte Character
    // if tmCharSet field of textmetrics is double byte character set
    // such as SHIFTJIS_CHARSET(128:Japan), HANGEUL_CHARSET(129:Korea).
    //
    // We call ECGetDBCSVector even when fAnsi is false so that we could
    // treat ped->fAnsi and ped->fDBCS indivisually. I changed ECGetDBCSVector
    // function so that it returns 0 or 1, because I would like to set ped->fDBCS
    // bit field here.
    //
    ped->fDBCS = ECGetDBCSVector(ped,hdc,TextMetrics.tmCharSet);
    ped->charSet = TextMetrics.tmCharSet;

    if (ped->fDBCS) {
        //
        // Free the character width buffer if ped->fDBCS.
        //
        // I expect single GetTextExtentPoint call is faster than multiple
        // GetTextExtentPoint call (because the graphic engine has a cache buffer).
        // See editec.c/ECTabTheTextOut().
        //
        if (ped->charWidthBuffer) {
            UserLocalFree(ped->charWidthBuffer);
            ped->charWidthBuffer = NULL;
        }

        //
        // if FullWidthChar : HalfWidthChar == 2 : 1....
        //
        // TextMetrics.tmMaxCharWidth = FullWidthChar width
        // ped->aveCharWidth          = HalfWidthChar width
        //
        if (ped->fNonPropFont &&
            ((ped->aveCharWidth * 2) == TextMetrics.tmMaxCharWidth)) {
            ped->fNonPropDBCS = TRUE;
        } else {
            ped->fNonPropDBCS = FALSE;
        }

    } else {

        //
        // Since the font has changed, let us obtain and save the character width
        // info for this font.
        //
        // First left us find out if the maximum chars that can overlap due to
        // negative widths. Since we can't access USER globals, we make a call here.
        //
        if (!(ped->fSingle || ped->pLpkEditCallout)) {  // Is this a multiline edit control with no LPK present?
            //
            // For multiline edit controls, we maintain a buffer that contains
            // the character width information.
            //
            wBuffSize = (ped->fTrueType) ? (CHAR_WIDTH_BUFFER_LENGTH * sizeof(ABC)) :
                                           (CHAR_WIDTH_BUFFER_LENGTH * sizeof(int));

            if (ped->charWidthBuffer) { /* If buffer already present */
                lpCharWidthBuff = ped->charWidthBuffer;
                ped->charWidthBuffer = UserLocalReAlloc(lpCharWidthBuff, wBuffSize, HEAP_ZERO_MEMORY);
                if (ped->charWidthBuffer == NULL) {
                    UserLocalFree((HANDLE)lpCharWidthBuff);
                }
            } else {
                ped->charWidthBuffer = UserLocalAlloc(HEAP_ZERO_MEMORY, wBuffSize);
            }

            if (ped->charWidthBuffer != NULL) {
                if (ped->fTrueType) {
                    ped->fTrueType = GetNegABCwidthInfo(ped, hdc);
                }

                /*
                 * It is possible that the above attempts could have failed and reset
                 * the value of fTrueType. So, let us check that value again.
                 */
                if (!ped->fTrueType) {
                    if (!GetCharWidthA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, ped->charWidthBuffer)) {
                        UserLocalFree((HANDLE)ped->charWidthBuffer);
                        ped->charWidthBuffer=NULL;
                    } else {
                        /*
                         * We need to subtract out the overhang associated with
                         * each character since GetCharWidth includes it...
                         */
                        for (i=0;i < CHAR_WIDTH_BUFFER_LENGTH;i++)
                            ped->charWidthBuffer[i] -= ped->charOverhang;
                    }
                }
            } /* if (ped->charWidthBuffer != NULL) */
        } /* if (!ped->fSingle) */
    } /* if (ped->fDBCS) */

    {
        /*
         * Calculate MaxNeg A C metrics
         */
        dwMaxOverlapChars = GetMaxOverlapChars();
        if (ped->fTrueType) {
            if (cwi.lMaxNegA < 0)
                ped->wMaxNegA = -cwi.lMaxNegA;
            else
                ped->wMaxNegA = 0;
            if (cwi.lMaxNegC < 0)
                ped->wMaxNegC = -cwi.lMaxNegC;
            else
                ped->wMaxNegC = 0;
            if (cwi.lMinWidthD != 0) {
                ped->wMaxNegAcharPos = (ped->wMaxNegA + cwi.lMinWidthD - 1) / cwi.lMinWidthD;
                ped->wMaxNegCcharPos = (ped->wMaxNegC + cwi.lMinWidthD - 1) / cwi.lMinWidthD;
                if (ped->wMaxNegA + ped->wMaxNegC > (UINT)cwi.lMinWidthD) {
                    uExtracharPos = (ped->wMaxNegA + ped->wMaxNegC - 1) / cwi.lMinWidthD;
                    ped->wMaxNegAcharPos += uExtracharPos;
                    ped->wMaxNegCcharPos += uExtracharPos;
                }
            } else {
                ped->wMaxNegAcharPos = LOWORD(dwMaxOverlapChars);     // Left
                ped->wMaxNegCcharPos = HIWORD(dwMaxOverlapChars);     // Right
            }

        } else if (ped->charOverhang != 0) {
            /*
             * Some bitmaps fonts (i.e., italic) have under/overhangs;
             *  this is pretty much like having negative A and C widths.
             */
            ped->wMaxNegA = ped->wMaxNegC = ped->charOverhang;
            ped->wMaxNegAcharPos = LOWORD(dwMaxOverlapChars);     // Left
            ped->wMaxNegCcharPos = HIWORD(dwMaxOverlapChars);     // Right
        }
    } /* if (ped->fDBCS) */

    if (!hfont) {
        //
        // We are getting the stats for the system font so update the system
        // font fields in the ed structure since we use these when calculating
        // some spacing.
        //
        ped->cxSysCharWidth = ped->aveCharWidth;
        ped->cySysCharHeight= ped->lineHeight;
    } else if (hOldFont)
        SelectObject(hdc, hOldFont);

    if (ped->fFocus) {
        //
        // Update the caret.
        //
        NtUserHideCaret(ped->hwnd);
        NtUserDestroyCaret();

        if (ped->pLpkEditCallout) {
            ped->pLpkEditCallout->EditCreateCaret (ped, hdc, ECGetCaretWidth(), ped->lineHeight, 0);
        } else {
            NtUserCreateCaret(ped->hwnd, (HBITMAP)NULL, ECGetCaretWidth(), ped->lineHeight);
        }
        NtUserShowCaret(ped->hwnd);
    }

    ReleaseDC(ped->hwnd, hdc);

    //
    // Update password character.
    //
    if (ped->charPasswordChar)
        ECSetPasswordChar(ped, ped->charPasswordChar);

    //
    // If it is a TrueType font and it's a new app, set both the margins at the
    // max negative width values for all types of the edit controls.
    // (NOTE: Can't use ped->f40Compat here because edit-controls inside dialog
    // boxes without DS_LOCALEDIT style are always marked as 4.0 compat.
    // This is the fix for NETBENCH 3.0)
    //

    if (ped->fTrueType && (GETAPPVER() >= VER40))
        if (ped->fDBCS) {
            // For DBCS TrueType Font, we calc margin from ABC width.
            ECCalcMarginForDBCSFont(ped, fRedraw);
        } else {
            ECSetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                        MAKELONG(EC_USEFONTINFO, EC_USEFONTINFO), fRedraw);
        }

    //
    // We need to calc maxPixelWidth when font changes.
    // If the word-wrap is ON, then this is done in MLSize() called later.
    //
    if((!ped->fSingle) && (!ped->fWrap))
        MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);

    //
    // Recalc the layout.
    //
    ECSize(ped, NULL, fRedraw);

    if ( ped->fFocus && fpImmIsIME(THREAD_HKL()) ) {
        ECImmSetCompositionFont( ped );
    }
}



/***************************************************************************\
*
*  ECIsCharNumeric AorW () -
*
*  Tests whether the character entered is a numeral.
*  For multiline and singleline edit controls with the ES_NUMBER style.
*
\***************************************************************************/
BOOL ECIsCharNumeric(
    PED ped,
    DWORD keyPress)
{
    WORD wCharType;

    if (ped->fAnsi) {
        char ch = (char)keyPress;
        LCID lcid = (LCID)((ULONG_PTR)THREAD_HKL() & 0xFFFF);
        GetStringTypeA(lcid, CT_CTYPE1, &ch, 1, &wCharType);
    } else {
        WCHAR wch = (WCHAR)keyPress;
        GetStringTypeW(CT_CTYPE1, &wch, 1, &wCharType);
    }
    return (wCharType & C1_DIGIT ? TRUE : FALSE);
}

/***************************************************************************\
*
*  ECEnableDisableIME( PED ped )
*
*
*  xx/xx/9x by somebody     Created for Win95
*  xx/xx/95 by kazum        Ported to NT-J 3.51
*  04/15/96 by takaok       Ported to NT 4.0
*
\***************************************************************************/
VOID ECEnableDisableIME( PED ped )
{
    if ( ped->fReadOnly || ped->charPasswordChar ) {
    //
    // IME should be disabled
    //
        HIMC hImc;
        hImc = fpImmGetContext( ped->hwnd );

        if ( hImc != NULL_HIMC ) {
            fpImmReleaseContext( ped->hwnd, hImc );
            ped->hImcPrev = fpImmAssociateContext( ped->hwnd, NULL_HIMC );
        }

    } else {
    //
    // IME should be enabled
    //
        if ( ped->hImcPrev != NULL_HIMC ) {
            ped->hImcPrev = fpImmAssociateContext( ped->hwnd, ped->hImcPrev );

            //
            // Font and the caret position might be changed while
            // IME was being disabled. Set those now if the window
            // has the focus.
            //
            if ( ped->fFocus ) {
                POINT pt;

                ECImmSetCompositionFont( ped );

                NtUserGetCaretPos( &pt );
                ECImmSetCompositionWindow( ped, pt.x, pt.y  );
            }
        }
    }
    ECInitInsert(ped, THREAD_HKL());
}


/***************************************************************************\
*
*  ECImmSetCompositionWindow( PED ped, LONG x, LONG y )
*
*  xx/xx/9x by somebody     Created for Win95
*  xx/xx/95 by kazum        Ported to NT-J 3.51
*  04/15/96 by takaok       Ported to NT 4.0
\***************************************************************************/
VOID ECImmSetCompositionWindow( PED ped, LONG x, LONG y )
{
    COMPOSITIONFORM cf;
    COMPOSITIONFORM cft;
    RECT rcScreenWindow;
    HIMC hImc;

    hImc = fpImmGetContext( ped->hwnd );
    if ( hImc != NULL_HIMC ) {

        if ( ped->fFocus ) {
            GetWindowRect( ped->hwnd, &rcScreenWindow);
            // assuming RECT.left is the first and and RECT.top is the second field
            MapWindowPoints( ped->hwnd, HWND_DESKTOP, (LPPOINT)&rcScreenWindow, 2);
            if (ped->fInReconversion) {
                DWORD dwPoint = (DWORD)(ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_POSFROMCHAR, ped->ichMinSel, 0);

                x = GET_X_LPARAM(dwPoint);
                y = GET_Y_LPARAM(dwPoint);

                RIPMSG2(RIP_WARNING, "ECImmSetCompositionWindow: fInReconversion (%d,%d)", x, y);
            }
            //
            // The window currently has the focus.
            //
            if (ped->fSingle) {
                //
                // Single line edit control.
                //
                cf.dwStyle = CFS_POINT;
                cf.ptCurrentPos.x = x;
                cf.ptCurrentPos.y = y;
                SetRectEmpty(&cf.rcArea);

            } else {
                //
                // Multi line edit control.
                //
                cf.dwStyle = CFS_RECT;
                cf.ptCurrentPos.x = x;
                cf.ptCurrentPos.y = y;
                cf.rcArea = ped->rcFmt;
            }
            fpImmGetCompositionWindow( hImc, &cft );
            if ( (!RtlEqualMemory(&cf,&cft,sizeof(COMPOSITIONFORM))) ||
                 (ped->ptScreenBounding.x != rcScreenWindow.left)    ||
                 (ped->ptScreenBounding.y  != rcScreenWindow.top) ) {

                ped->ptScreenBounding.x = rcScreenWindow.left;
                ped->ptScreenBounding.y = rcScreenWindow.top;
                fpImmSetCompositionWindow( hImc, &cf );
            }
        }
        fpImmReleaseContext( ped->hwnd, hImc );
    }
}

/***************************************************************************\
*
*  ECImmSetCompositionFont( PED ped )
*
*  xx/xx/9x by somebody     Created for Win95
*  xx/xx/95 by kazum        Ported to NT-J 3.51
*  04/15/96 by takaok       Ported to NT 4.0
\***************************************************************************/
VOID  ECImmSetCompositionFont( PED ped )
{
    HIMC hImc;
    LOGFONTW lf;

    if ( (hImc = fpImmGetContext( ped->hwnd )) != NULL_HIMC ) {

        if (ped->hFont) {
            GetObjectW( ped->hFont,
                        sizeof(LOGFONTW),
                        (LPLOGFONTW)&lf);
        } else {
            GetObjectW( GetStockObject(SYSTEM_FONT),
                        sizeof(LOGFONTW),
                        (LPLOGFONTW)&lf);
        }
        fpImmSetCompositionFontW( hImc, &lf );
        fpImmReleaseContext( ped->hwnd, hImc );
    }
}


/***************************************************************************\
*
*  ECInitInsert( PED ped, HKL hkl )
*
*  this function is called when:
*  1) a edit control window is initialized
*  2) active keyboard layout of current thread is changed
*  3) read only attribute of this edit control is changed
*
*  04/15/96 by takaok       Created
\***************************************************************************/
VOID ECInitInsert( PED ped, HKL hkl )
{
    ped->fKorea = FALSE;
    ped->fInsertCompChr = FALSE;
    ped->fNoMoveCaret = FALSE;
    ped->fResultProcess = FALSE;

    if ( fpImmIsIME(hkl) ) {
        if (  PRIMARYLANGID(LOWORD(HandleToUlong(hkl))) == LANG_KOREAN ) {

            ped->fKorea = TRUE;
        }
        //
        // LATER:this flag should be set based on the IME caps
        // retrieved from IME. (Such IME caps should be defined)
        // For now, we can safely assume that only Korean IMEs
        // set CS_INSERTCHAR.
        //
        if ( ped->fKorea ) {
            ped->fInsertCompChr = TRUE;
        }
    }

    //
    // if we had a composition character, the shape of caret
    // is changed. We need to reset the caret shape.
    //
    if ( ped->fReplaceCompChr ) {
        ped->fReplaceCompChr = FALSE;
        ECSetCaretHandler( ped );
    }
}

/***************************************************************************\
*
*  ECSetCaretHandler( PED ped )
*
* History:
*       07/16/96 by takaok      ported from NT 3.51
*
\***************************************************************************/

void ECSetCaretHandler(PED ped)
{
    HDC     hdc;
    SIZE    size;
    PSTR    pText;

//    if (!ped->fInsertCompChr || ped->fReadOnly)
//        return;

    // In any case destroy caret beforehand otherwise SetCaretPos()
    // will get crazy.. win95d-B#992,B#2370
    //
    if (ped->fFocus) {

        NtUserHideCaret(ped->hwnd);
        DestroyCaret();
        if ( ped->fReplaceCompChr ) {

            hdc = ECGetEditDC(ped, TRUE );
            pText = ECLock(ped);

            if ( ped->fAnsi)
                 GetTextExtentPointA(hdc, pText + ped->ichCaret, 2, &size);
            else
                 GetTextExtentPointW(hdc, (LPWSTR)pText + ped->ichCaret, 1, &size);

            ECUnlock(ped);
            ECReleaseEditDC(ped, hdc, TRUE);

            CreateCaret(ped->hwnd, (HBITMAP)NULL, size.cx, ped->lineHeight);
        }
        else {
            CreateCaret(ped->hwnd,
                        (HBITMAP)NULL,
                        (ped->cxSysCharWidth > ped->aveCharWidth ? 1 : 2),
                        ped->lineHeight);
        }

        hdc = ECGetEditDC(ped, TRUE );
        if ( ped->fSingle )
            SLSetCaretPosition( ped, hdc );
        else
            MLSetCaretPosition( ped, hdc );
        ECReleaseEditDC(ped, hdc, TRUE);
        NtUserShowCaret(ped->hwnd);
    }
}


/***************************************************************************\
*
* LONG ECImeCompoistion( PED ped, WPARAM wParam, LPARAM lParam )
*
* WM_IME_COMPOSITION handler for Korean IME
*
* History:
\***************************************************************************/

extern void MLReplaceSel(PED, LPSTR);

#define GET_COMPOSITION_STRING  (ped->fAnsi ? fpImmGetCompositionStringA : fpImmGetCompositionStringW)

BOOL FAR PASCAL ECResultStrHandler(PED ped)
{
    HIMC himc;
    LPSTR lpStr;
    LONG dwLen;

    ped->fInsertCompChr = FALSE;    // clear the state
    ped->fNoMoveCaret = FALSE;

    if ((himc = fpImmGetContext(ped->hwnd)) == 0) {
        return FALSE;
    }

    dwLen = GET_COMPOSITION_STRING(himc, GCS_RESULTSTR, NULL, 0);

    if (dwLen == 0) {
        fpImmReleaseContext(ped->hwnd, himc);
        return FALSE;
    }

    dwLen *= ped->cbChar;
    dwLen += ped->cbChar;

    lpStr = (LPSTR)UserGlobalAlloc(GPTR, dwLen);
    if (lpStr == NULL) {
        fpImmReleaseContext(ped->hwnd, himc);
        return FALSE;
    }

    GET_COMPOSITION_STRING(himc, GCS_RESULTSTR, lpStr, dwLen);

    if (ped->fSingle) {
        SLReplaceSel(ped, lpStr);
    } else {
        MLReplaceSel(ped, lpStr);
    }

    UserGlobalFree((HGLOBAL)lpStr);

    fpImmReleaseContext(ped->hwnd, himc);

    ped->fReplaceCompChr = FALSE;
    ped->fNoMoveCaret = FALSE;
    ped->fResultProcess = FALSE;

    ECSetCaretHandler(ped);

    return TRUE;
}

LRESULT ECImeComposition(PED ped, WPARAM wParam, LPARAM lParam)
{
    INT ich;
    LRESULT lReturn = 1;
    HDC hdc;
    BOOL fSLTextUpdated = FALSE;
    ICH iResult;
    HIMC hImc;
    BYTE TextBuf[4];

    if (!ped->fInsertCompChr) {
        if (lParam & GCS_RESULTSTR) {
            ECInOutReconversionMode(ped, FALSE);

            if (ped->wImeStatus & EIMES_GETCOMPSTRATONCE) {
ResultAtOnce:
                ECResultStrHandler(ped);
                lParam &= ~GCS_RESULTSTR;
            }
        }
        return DefWindowProcWorker(ped->pwnd, WM_IME_COMPOSITION, wParam, lParam, ped->fAnsi);
    }

    // In case of Ansi edit control, the length of minimum composition string
    // is 2. Check here maximum byte of edit control.
    if( ped->fAnsi && ped->cchTextMax == 1 ) {
        HIMC hImc;

        hImc = fpImmGetContext( ped->hwnd );
        fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0L);
        fpImmReleaseContext( ped->hwnd, hImc );
        NtUserMessageBeep(MB_ICONEXCLAMATION);
        return lReturn;
    }

    // Don't move this after CS_NOMOVECARET check.
    // In case if skip the message, fNoMoveCaret should not be set.
    if ((lParam & CS_INSERTCHAR) && ped->fResultProcess) {

        // Now we're in result processing. GCS_RESULTSTR ends up
        // to WM_IME_CHAR and WM_CHAR. Since WM_CHAR is posted,
        // the message(s) will come later than this CS_INSERTCHAR
        // message. This composition character should be handled
        // after the WM_CHAR message(s).
        //
        if(ped->fAnsi)
            PostMessageA(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
        else
            PostMessageW(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
        ped->fResultProcess = FALSE;
        return lReturn;
    }

//
// If fReplaceCompChr is TRUE, we change the shape of caret. A block
// caret is displayed on the composition character. From the user's
// point of view, there is no difference if the caret is before the
// composition character or after the composition character. When
// the composition character is finalized, the insertion point should
// be moved to after the character, any way. Therefore checking
// CS_NOMOVECARET bit doesn't make sense in our current implementation.
// [takaok]
//
#if 0
    if (lParam & CS_NOMOVECARET)
        ped->fNoMoveCaret=TRUE;   // stick to current caret pos.
    else
        ped->fNoMoveCaret=FALSE;
#endif

    if (lParam & GCS_RESULTSTR) {

        if (ped->wImeStatus & EIMES_GETCOMPSTRATONCE) {
            goto ResultAtOnce;
        }

        ped->fResultProcess=TRUE;
        if ( ped->fReplaceCompChr ) {
            //
            // we have a DBCS character to be replaced.
            // let's delete it before inserting the new one.
            //
            ich = (ped->fAnsi) ? 2 : 1;
            ped->fReplaceCompChr = FALSE;
            ped->ichMaxSel = min(ped->ichCaret + ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;
            if ( ECDeleteText( ped ) > 0 ) {
                if ( ped->fSingle ) {
                    //
                    // Update the display
                    //
                    ECNotifyParent(ped, EN_UPDATE);
                    hdc = ECGetEditDC(ped,FALSE);
                    SLDrawText(ped, hdc, 0);
                    ECReleaseEditDC(ped,hdc,FALSE);
                    //
                    // Tell parent our text contents changed.
                    //
                    ECNotifyParent(ped, EN_CHANGE);
                }
            }
            ECSetCaretHandler( ped );
        }

    } else if(lParam & CS_INSERTCHAR) {

        //
        // If we are in the middle of a mousedown command, don't do anything.
        //
        if (ped->fMouseDown) {
            return lReturn;
        }

        //
        // We can safely assume that interimm character is always DBCS.
        //
        ich = ( ped->fAnsi ) ? 2 : 1;

        if ( ped->fReplaceCompChr ) {
            //
            // we have a character to be replaced.
            // let's delete it before inserting the new one.
            // when we have a composition characters, the
            // caret is placed before the composition character.
            //
            ped->ichMaxSel = min(ped->ichCaret+ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;
        }

        //
        // let's delete current selected text or composition character
        //
        if ( ped->fSingle ) {
            if ( ECDeleteText( ped ) > 0 ) {
                fSLTextUpdated = TRUE;
            }
        } else {
            MLDeleteText( ped );
        }

        //
        // When the composition charcter is canceled, IME may give us NULL wParam,
        // with CS_INSERTCHAR flag on. We shouldn't insert a NULL character.
        //
        if ( wParam != 0 ) {

            if ( ped->fAnsi ) {
                TextBuf[0] = HIBYTE(LOWORD(wParam)); // leading byte
                TextBuf[1] = LOBYTE(LOWORD(wParam)); // trailing byte
                TextBuf[2] = '\0';
            } else {
                TextBuf[0] = LOBYTE(LOWORD(wParam));
                TextBuf[1] = HIBYTE(LOWORD(wParam));
                TextBuf[2] = '\0';
                TextBuf[3] = '\0';
            }

            if ( ped->fSingle ) {

                iResult = SLInsertText( ped, (LPSTR)TextBuf, ich );
                if (iResult == 0) {
                    /*
                     * Couldn't insert the text, for e.g. the text exceeded the limit.
                     */
                    NtUserMessageBeep(0);
                } else if (iResult > 0) {
                    /*
                     * Remember we need to update the text.
                     */
                    fSLTextUpdated = TRUE;
                }

            } else {

                iResult = MLInsertText( ped, (LPSTR)TextBuf, ich, TRUE);
            }

            if ( iResult > 0 ) {
                //
                // ped->fReplaceCompChr will be reset:
                //
                // 1) when the character is finalized.
                //    we will receive GCS_RESULTSTR
                //
                // 2) when the character is canceled.
                //
                //    we will receive WM_IME_COMPOSITION|CS_INSERTCHAR
                //    with wParam == 0 (in case of user types backspace
                //    at the first element of composition character).
                //
                //      or
                //
                //    we will receive WM_IME_ENDCOMPOSITION message
                //
                ped->fReplaceCompChr = TRUE;

                //
                // Caret should be placed BEFORE the composition
                // character.
                //
                ped->ichCaret = max( 0, (INT)(ped->ichCaret - ich));
                ECSetCaretHandler( ped );
            } else {

                //
                // We failed to insert a character. We might run out
                // of memory, or reached to the text size limit. let's
                // cancel the composition character.
                //
                hImc = fpImmGetContext(ped->hwnd);
                fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                fpImmReleaseContext(ped->hwnd, hImc);

                ped->fReplaceCompChr = FALSE;
                ECSetCaretHandler( ped );
            }
        } else {
            //
            // the composition character is canceled.
            //
            ped->fReplaceCompChr = FALSE;
            ECSetCaretHandler( ped );
        }

        //
        // We won't notify parent the text change
        // because the composition character has
        // not been finalized.
        //
        if ( fSLTextUpdated ) {

            //
            // Update the display
            //
            ECNotifyParent(ped, EN_UPDATE);

            hdc = ECGetEditDC(ped,FALSE);

            if ( ped->fReplaceCompChr ) {
                //
                // move back the caret to the original position
                // temporarily so that our new block cursor can
                // be located within the visible area of window.
                //
                ped->ichCaret = min( ped->cch, ped->ichCaret + ich);
                SLScrollText(ped, hdc);
                ped->ichCaret = max( 0, (INT)(ped->ichCaret - ich));
            } else {
                SLScrollText(ped, hdc);
            }
            SLDrawText(ped, hdc, 0);

            ECReleaseEditDC(ped,hdc,FALSE);

            //
            // Tell parent our text contents changed.
            //
            ECNotifyParent(ped, EN_CHANGE);
        }
        return lReturn;
    }

    return DefWindowProcWorker(ped->pwnd, WM_IME_COMPOSITION, wParam, lParam, ped->fAnsi);
}


#ifdef LATER    // fyi: window 98 equiv.
LRESULT ECImeComposition(PED ped, WPARAM wParam, LPARAM lParam)
{
    INT ich;
    LRESULT lReturn = 1;
    HDC hdc;
    BOOL fSLTextUpdated = FALSE;
    ICH iResult;
    HIMC hImc;
    BYTE TextBuf[4];

    // In case of Ansi edit control, the length of minimum composition string
    // is 2. Check here maximum byte of edit control.
    if( ped->fAnsi && ped->cchTextMax == 1 ) {
        HIMC hImc;

        hImc = fpImmGetContext( ped->hwnd );
        fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0L);
        fpImmReleaseContext( ped->hwnd, hImc );
        MessageBeep(MB_ICONEXCLAMATION);
        return lReturn;
    }

    // Don't move this after CS_NOMOVECARET check.
    // In case if skip the message, fNoMoveCaret should not be set.
    if ((lParam & CS_INSERTCHAR) && ped->fResultProcess) {

        // Now we're in result processing. GCS_RESULTSTR ends up
        // to WM_IME_CHAR and WM_CHAR. Since WM_CHAR is posted,
        // the message(s) will come later than this CS_INSERTCHAR
        // message. This composition character should be handled
        // after the WM_CHAR message(s).
        //
        (ped->fAnsi ? PostMessageA : PostMessageW)(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
        ped->fResultProcess = FALSE;
        return lReturn;
    }

    ped->fNoMoveCaret = (lParam & CS_NOMOVECARET) != 0;

    if (lParam & GCS_RESULTSTR) {
        ECInOutReconversionMode(ped, FALSE);

        if (ped->wImeStatus & EIMS_GETCOMPSTRATONCE) {
            ECGetCompStrAtOnce(ped);

            goto PassToDefaultWindowProc;
        }

        // Getting into result processing
        ped->fResultProcess = TRUE;
    }
    else if (lParam & CS_INSERTCHAR) {
        ped->fInsertCompChr = TRUE; // Process this composition character.

        (ped->fSingleLine ? SLChar : MLChar)(ped, wParam, 0);

        if (ped->fInsretCompChr) {
            ped->fReplaceCompChr = TRUE;    // The next character will replace this.
            ped->fInsertCompChr = FALSE;    // Clear the state for the next character.
        }

        ECSetCaretHandler(ped);
        return 0;
    }

PassToDefaultWindowProc:
    return DefWindowProcWorker(ped->pwnd, WM_IME_COMPOSITION, wParam, lParam, ped->fAnsi);
}
#endif


/***************************************************************************\
*
* BOOL HanjaKeyHandler( PED ped )
*
* VK_HANJA handler - Korean only
*
* History: July 15,1996 takaok  ported from NT 3.51
\***************************************************************************/
BOOL HanjaKeyHandler( PED ped )
{
    BOOL changeSelection = FALSE;

    if (ped->fKorea && !ped->fReadOnly) {
        ICH oldCaret = ped->ichCaret;

        if (ped->fReplaceCompChr)
                return FALSE;

        if (ped->ichMinSel < ped->ichMaxSel)
            ped->ichCaret = ped->ichMinSel;

        if (!ped->cch || ped->cch == ped->ichCaret) {
            ped->ichCaret = oldCaret;
            NtUserMessageBeep(MB_ICONEXCLAMATION);
            return FALSE;
        }

        if (ped->fAnsi) {
            if (fpImmEscapeA(THREAD_HKL(), fpImmGetContext(ped->hwnd),
                IME_ESC_HANJA_MODE, (ECLock(ped) + ped->ichCaret * ped->cbChar))) {
                changeSelection = TRUE;
            }
            else
                ped->ichCaret = oldCaret;
            ECUnlock(ped);
        }
        else {
            if (fpImmEscapeW(THREAD_HKL(), fpImmGetContext(ped->hwnd),
                IME_ESC_HANJA_MODE, (ECLock(ped) + ped->ichCaret * ped->cbChar))) {
                changeSelection = TRUE;
            }
            else
                ped->ichCaret = oldCaret;
            ECUnlock(ped);
        }
    }
    return changeSelection;
}


//////////////////////////////////////////////////////////////////////////////
// EcImeRequestHandler()
//
// Handles WM_IME_REQUEST message originated by IME
//
// Histroy:
// 27-Mar-97 Hiroyama Created
//////////////////////////////////////////////////////////////////////////////

#ifdef CUAS_ENABLE

#define MAX_ECDOCFEED 20

ICH EcImeGetDocFeedMin(PED ped, LPSTR lpstr)
{
    ICH ich;

    if (!IS_CICERO_ENABLED())
        return ped->ichMinSel;


    if (ped->ichMinSel > MAX_ECDOCFEED) {
        ich = ped->ichMinSel - MAX_ECDOCFEED;
        ich = ECAdjustIch(ped, lpstr, ich);
    } else {
        ich = 0;
    }

    return ich;
}

ICH EcImeGetDocFeedMax(PED ped, LPSTR lpstr)
{
    ICH ich;

    if (!IS_CICERO_ENABLED())
        return ped->ichMinSel;


    if ((ped->cch - ped->ichMaxSel) > MAX_ECDOCFEED) {
        ich = ped->ichMaxSel + MAX_ECDOCFEED;
        ich = ECAdjustIch(ped, lpstr, ich);
    } else {
        ich = ped->cch;
    }

    return ich;
}

#endif // CUAS_ENABLE

LRESULT EcImeRequestHandler(PED ped, WPARAM dwSubMsg, LPARAM lParam)
{
    LRESULT lreturn = 0L;

    switch (dwSubMsg) {
    case IMR_CONFIRMRECONVERTSTRING:

#if !defined(CUAS_ENABLE)
        // Edit control does not allow IME to change it.
        break;
#else

        // Edit control does not allow IME to change it if it is not CUAS.
        if (!IS_CICERO_ENABLED())
            return 0L;

        //
        // CHECK VERSION of the structure
        //
        if (lParam && ((LPRECONVERTSTRING)lParam)->dwVersion != 0) {
            RIPMSG1(RIP_WARNING, "EcImeRequestHandler: RECONVERTSTRING dwVersion is not expected.",
                ((LPRECONVERTSTRING)lParam)->dwVersion);
            return 0L;
        }

        if (lParam && ped && ped->fFocus && ped->hText && fpImmIsIME(THREAD_HKL())) {
            LPVOID lpSrc;
            lpSrc = ECLock(ped);
            if (lpSrc == NULL) {
                RIPMSG0(RIP_WARNING, "EcImeRequestHandler: LOCALLOCK(ped) failed.");
            } else {
                LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)lParam;
                ICH ichStart;
                ICH ichEnd;
                UINT cchLen;

                ichStart = EcImeGetDocFeedMin(ped, lpSrc);
                ichEnd = EcImeGetDocFeedMax(ped, lpSrc);
                UserAssert(ichEnd >= ichStart);

                cchLen = ichEnd - ichStart;    // holds character count.

                ECUnlock(ped);

                if (lpRCS->dwStrLen != cchLen) {
                    RIPMSG0(RIP_WARNING, "EcImeRequestHandler: the given string length is not expected.");
                } else {
                    ICH ichSelStart;
                    ICH ichSelEnd;

                    ichSelStart = ichStart + (lpRCS->dwCompStrOffset  / ped->cbChar);
                    ichSelEnd = ichSelStart + lpRCS->dwCompStrLen;


                    (ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_SETSEL, ichSelStart, ichSelEnd);

                    lreturn = 1L;
                }
            }
        }
        break;
#endif // CUAS_ENABLE

    case IMR_RECONVERTSTRING:
        //
        // CHECK VERSION of the structure
        //
        if (lParam && ((LPRECONVERTSTRING)lParam)->dwVersion != 0) {
            RIPMSG1(RIP_WARNING, "EcImeRequestHandler: RECONVERTSTRING dwVersion is not expected.",
                ((LPRECONVERTSTRING)lParam)->dwVersion);
            return 0L;
        }

        if (ped && ped->fFocus && ped->hText && fpImmIsIME(THREAD_HKL())) {
#if !defined(CUAS_ENABLE)
            UINT cchLen = ped->ichMaxSel - ped->ichMinSel;    // holds character count.
#else
            ICH ichStart;
            ICH ichEnd;
            UINT cchLen;
            UINT cchSelLen;
            LPVOID lpSrc;
            lpSrc = ECLock(ped);
            if (lpSrc == NULL) {
                RIPMSG0(RIP_WARNING, "EcImeRequestHandler: LOCALLOCK(ped) failed.");
                return 0L;
            }

            ichStart = EcImeGetDocFeedMin(ped, lpSrc);
            ichEnd = EcImeGetDocFeedMax(ped, lpSrc);
            UserAssert(ichEnd >= ichStart);

            cchLen = ichEnd - ichStart;    // holds character count.
            cchSelLen = ped->ichMaxSel - ped->ichMinSel;    // holds character count.
#endif

            if (cchLen == 0) {
#if defined(CUAS_ENABLE)
                ECUnlock(ped);
#endif
                // if we have no selection,
                // just return 0.
                break;
            }

            UserAssert(ped->cbChar == sizeof(BYTE) || ped->cbChar == sizeof(WCHAR));

            // This Edit Control has selection.
            if (lParam == 0) {
                //
                // IME just want to get required size for buffer.
                // cchLen + 1 is needed to reserve room for trailing L'\0'.
                //       ~~~~
                lreturn = sizeof(RECONVERTSTRING) + (cchLen + 1) * ped->cbChar;

#if defined(CUAS_ENABLE)
                ECUnlock(ped);
#endif

            } else {
                LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)lParam;
#if !defined(CUAS_ENABLE)
                LPVOID lpSrc;
#endif
                LPVOID lpDest = (LPBYTE)lpRCS + sizeof(RECONVERTSTRING);

                // check buffer size
                // if the given buffer is smaller than actual needed size,
                // shrink our size to fit the buffer
                if ((INT)lpRCS->dwSize <= sizeof(RECONVERTSTRING) + cchLen * ped->cbChar) {
                    RIPMSG0(RIP_WARNING, "EcImeRequest: ERR09");
                    cchLen = (lpRCS->dwSize - sizeof(RECONVERTSTRING)) / ped->cbChar - ped->cbChar;
                }

                lpRCS->dwStrOffset = sizeof(RECONVERTSTRING); // buffer begins just after RECONVERTSTRING
#if !defined(CUAS_ENABLE)
                lpRCS->dwCompStrOffset =
                lpRCS->dwTargetStrOffset = 0;
                lpRCS->dwStrLen =
                lpRCS->dwCompStrLen =
                lpRCS->dwTargetStrLen = cchLen; // StrLen means TCHAR count

                lpSrc = ECLock(ped);
                if (lpSrc == NULL) {
                    RIPMSG0(RIP_WARNING, "EcImeRequestHandler: LOCALLOCK(ped) failed.");
                } else
#else
                lpRCS->dwCompStrOffset =
                lpRCS->dwTargetStrOffset = (ped->ichMinSel - ichStart) * ped->cbChar; // BYTE count offset
                lpRCS->dwStrLen = cchLen; // TCHAR count
                lpRCS->dwCompStrLen = 
                lpRCS->dwTargetStrLen = cchSelLen; // TCHAR count
#endif
                {
#if !defined(CUAS_ENABLE)
                    RtlCopyMemory(lpDest,
                                  (LPBYTE)lpSrc + ped->ichMinSel * ped->cbChar,
                                  cchLen * ped->cbChar);
#else
                    RtlCopyMemory(lpDest,
                                  (LPBYTE)lpSrc + ichStart * ped->cbChar,
                                  cchLen * ped->cbChar);
#endif
                    // Null-Terminate the string
                    if (ped->fAnsi) {
                        LPBYTE psz = (LPBYTE)lpDest;
                        psz[cchLen] = '\0';
                    } else {
                        LPWSTR pwsz = (LPWSTR)lpDest;
                        pwsz[cchLen] = L'\0';
                    }
                    ECUnlock(ped);
                    // final buffer size
                    lreturn = sizeof(RECONVERTSTRING) + (cchLen + 1) * ped->cbChar;

                    ECInOutReconversionMode(ped, TRUE);
                    ECImmSetCompositionWindow(ped, 0, 0);
                }
            }

        }
        break;
    }

    return lreturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\extract.c ===
/****************************** Module Header ******************************\
*
* Module Name: extract.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Icon Extraction Routines
*
* History:
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include "newexe.h"

/****************************************************************************
 ****************************************************************************/

#define ICON_MAGIC      0
#define ICO_MAGIC1      1
#define CUR_MAGIC1      2
#define BMP_MAGIC       ((WORD)'B'+((WORD)'M'<<8))
#define ANI_MAGIC       ((WORD)'R'+((WORD)'I'<<8))
#define ANI_MAGIC1      ((WORD)'F'+((WORD)'F'<<8))
#define ANI_MAGIC4      ((WORD)'A'+((WORD)'C'<<8))
#define ANI_MAGIC5      ((WORD)'O'+((WORD)'N'<<8))
#define MZMAGIC         ((WORD)'M'+((WORD)'Z'<<8))
#define PEMAGIC         ((WORD)'P'+((WORD)'E'<<8))
#define LEMAGIC         ((WORD)'L'+((WORD)'E'<<8))

typedef struct new_exe          NEWEXE,      *LPNEWEXE;
typedef struct exe_hdr          EXEHDR,      *LPEXEHDR;
typedef struct rsrc_nameinfo    RESNAMEINFO, *LPRESNAMEINFO;
typedef struct rsrc_typeinfo    RESTYPEINFO, *LPRESTYPEINFO;
typedef struct rsrc_typeinfo    UNALIGNED    *ULPRESTYPEINFO;
typedef struct new_rsrc         RESTABLE,    *LPRESTABLE;

#define NUMBER_OF_SECTIONS(x) ((x)->FileHeader.NumberOfSections)

#define FCC(c0,c1,c2,c3) ((DWORD)(c0)|((DWORD)(c1)<<8)|((DWORD)(c2)<<16)|((DWORD)(c3)<<24))

#define COM_FILE    FCC('.', 'c', 'o', 'm')
#define BAT_FILE    FCC('.', 'b', 'a', 't')
#define CMD_FILE    FCC('.', 'c', 'm', 'd')
#define PIF_FILE    FCC('.', 'p', 'i', 'f')
#define LNK_FILE    FCC('.', 'l', 'n', 'k')
#define ICO_FILE    FCC('.', 'i', 'c', 'o')
#define EXE_FILE    FCC('.', 'e', 'x', 'e')


#define WIN32VER30  0x00030000  // for CreateIconFromResource()

#define GET_COUNT   424242


/***************************************************************************\
* PathIsUNC
*
* Inline function to check for a double-backslash at the
* beginning of a string
*
\***************************************************************************/

__inline BOOL PathIsUNC(
    LPWSTR psz)
{
    return (psz[0] == L'\\' && psz[1] == L'\\');
}

/***************************************************************************\
* ReadAByte
*
* This is used to touch memory to assure that if we page-fault, it is
* outside win16lock.  Most icons aren't more than two pages.
*
\***************************************************************************/

BOOL ReadAByte(
    LPCVOID pMem)
{
    return ((*(PBYTE)pMem) == 0);
}

/***************************************************************************\
* RVAtoP
*
*
\***************************************************************************/

LPVOID RVAtoP(
    LPVOID pBase,
    DWORD  rva)
{
    LPEXEHDR             pmz;
    IMAGE_NT_HEADERS     *ppe;
    IMAGE_SECTION_HEADER *pSection; // section table
    int                  i;
    DWORD                size;

    pmz = (LPEXEHDR)pBase;
    ppe = (IMAGE_NT_HEADERS*)((BYTE*)pBase + pmz->e_lfanew);

    /*
     * Scan the section table looking for the RVA
     */
    pSection = IMAGE_FIRST_SECTION(ppe);

    for (i = 0; i < NUMBER_OF_SECTIONS(ppe); i++) {

        size = pSection[i].Misc.VirtualSize ?
               pSection[i].Misc.VirtualSize : pSection[i].SizeOfRawData;

        if (rva >= pSection[i].VirtualAddress &&
            rva <  pSection[i].VirtualAddress + size) {

            return (LPBYTE)pBase + pSection[i].PointerToRawData + (rva - pSection[i].VirtualAddress);
        }
    }

    return NULL;
}

/***************************************************************************\
* GetResourceTablePE
*
*
\***************************************************************************/

LPVOID GetResourceTablePE(
    LPVOID pBase)
{
    LPEXEHDR         pmz;
    IMAGE_NT_HEADERS *ppe;

    pmz = (LPEXEHDR)pBase;
    ppe = (IMAGE_NT_HEADERS*)((BYTE*)pBase + pmz->e_lfanew);

    if (pmz->e_magic != MZMAGIC)
        return 0;

    if (ppe->Signature != IMAGE_NT_SIGNATURE)
        return 0;

    if (ppe->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    {
        IMAGE_NT_HEADERS64* ppe64 = (IMAGE_NT_HEADERS64*)ppe;

        if (ppe64->FileHeader.SizeOfOptionalHeader < IMAGE_SIZEOF_NT_OPTIONAL64_HEADER)
        {
            return 0;
        }
        return RVAtoP(pBase, ppe64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress);
    }
    else 
    {
        // assume a 32-bit image
        IMAGE_NT_HEADERS32* ppe32 = (IMAGE_NT_HEADERS32*)ppe;

        if (ppe32->FileHeader.SizeOfOptionalHeader < IMAGE_SIZEOF_NT_OPTIONAL32_HEADER)
        {
            return 0;
        }
        return RVAtoP(pBase, ppe32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress);
    }
}

/****************************************************************************
* FindResourcePE
*
*   given a PE resource directory will find a resource in it.
*
*   if iResIndex < 0 we will search for the specific index
*   if iResIndex >= 0 we will return the Nth index
*   if iResIndex == GET_COUNT the count of resources will be returned
*
\*****************************************************************************/

LPVOID FindResourcePE(
    LPVOID pBase,
    LPVOID prt,
    int    iResIndex,
    int    ResType,
    DWORD  *pcb)
{
    int                            i;
    int                            cnt;
    IMAGE_RESOURCE_DIRECTORY       *pdir;
    IMAGE_RESOURCE_DIRECTORY_ENTRY *pres;
    IMAGE_RESOURCE_DATA_ENTRY UNALIGNED *pent;

    pdir = (IMAGE_RESOURCE_DIRECTORY *)prt;

    /*
     * First find the type always a ID so ignore strings totaly
     */
    cnt  = pdir->NumberOfIdEntries + pdir->NumberOfNamedEntries;
    pres = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(pdir+1);

    for (i = 0; i < cnt; i++) {

        if (pres[i].Name == (DWORD)ResType)
            break;
    }

    if (i==cnt)             // did not find the type
        return 0;

    /*
     * Now go find the actual resource  either by id (iResIndex < 0) or
     * by ordinal (iResIndex >= 0)
     */
    pdir = (IMAGE_RESOURCE_DIRECTORY*)((LPBYTE)prt +
        (pres[i].OffsetToData & ~IMAGE_RESOURCE_DATA_IS_DIRECTORY));

    cnt  = pdir->NumberOfIdEntries + pdir->NumberOfNamedEntries;
    pres = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(pdir+1);

    /*
     * If we just want size, do it.
     */
    if (iResIndex == GET_COUNT)
        return (LPVOID)UIntToPtr( cnt );

    /*
     * if we are to search for a specific id do it.
     */
    if (iResIndex < 0) {

        for (i = 0; i < cnt; i++)
            if (pres[i].Name == (DWORD)(-iResIndex))
                break;
    } else {
        i = iResIndex;
    }

    /*
     * is the index in range?
     */
    if (i >= cnt)
        return 0;

    /*
     * if we get this far the resource has a language part, ick!
     * We don't handle multi-language icons, so just return the first one.
     * Note, this isn't a problem since this function isn't called from
     * anywhere that could specify a language. As this is called from an
     * API (albeit a private one), changing this behavior is dangerous.
     */
    if (pres[i].OffsetToData & IMAGE_RESOURCE_DATA_IS_DIRECTORY) {

        pdir = (IMAGE_RESOURCE_DIRECTORY*)((LPBYTE)prt +
                (pres[i].OffsetToData & ~IMAGE_RESOURCE_DATA_IS_DIRECTORY));
        pres = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(pdir+1);
        i = 0;  // choose first one
    }

    /*
     * Nested way to deep for me!
     */
    if (pres[i].OffsetToData & IMAGE_RESOURCE_DATA_IS_DIRECTORY)
        return 0;

    pent = (IMAGE_RESOURCE_DATA_ENTRY*)((LPBYTE)prt + pres[i].OffsetToData);

    /*
     * all OffsetToData fields except the final one are relative to
     * the start of the section.  the final one is a virtual address
     * we need to go back to the header and get the virtual address
     * of the resource section to do this right.
     */
    *pcb = pent->Size;
    return RVAtoP(pBase, pent->OffsetToData);
}

/***************************************************************************\
* GetResourceTableNE
*
*
\***************************************************************************/

LPVOID GetResourceTableNE(
    LPVOID pBase)
{
    LPNEWEXE pne;
    LPEXEHDR pmz;

    pmz = (LPEXEHDR)pBase;
    pne = (LPNEWEXE)((LPBYTE)pBase + pmz->e_lfanew);

    if (pmz->e_magic != MZMAGIC)
        return 0;

    if (pne->ne_magic != NEMAGIC)           // must be a NEWEXE
        return 0;

    if (pne->ne_exetyp != NE_WINDOWS &&     // must be a Win DLL/EXE/386
        pne->ne_exetyp != NE_DEV386)
        return 0;

    if (pne->ne_expver < 0x0300)            // must be 3.0 or greater
        return 0;

    if (pne->ne_rsrctab == pne->ne_restab)  // no resources
        return 0;

    return (LPBYTE)pne + pne->ne_rsrctab;   // return resource table pointer
}

/***************************************************************************\
* FindResourceNE
*
* This returns a pointer to the rsrc_nameinfo of the resource with the
* given index and type, if it is found, otherwise it returns NULL.
*
* if iResIndex is < 0, then it is assumed to be a ID and the res table
* will be searched for a matching id.
*
* if iResIndex is >= 0, then it is assumed to be a index and the Nth
* resorce of the specifed type will be returned.
*
* if iResIndex == GET_COUNT the count of resources will be returned
*
\***************************************************************************/

LPVOID FindResourceNE(
    LPVOID lpBase,
    LPVOID prt,
    int    iResIndex,
    int    iResType,
    DWORD  *pcb)
{
    LPRESTABLE     lpResTable;
    ULPRESTYPEINFO ulpResTypeInfo;
    LPRESNAMEINFO  lpResNameInfo;  // 16 bit alignment ok - had ushorts only
    int            i;

    lpResTable = (LPRESTABLE)prt;
//ulpResTypeInfo = (ULPRESTYPEINFO)(LPWBYTE)&lpResTable->rs_typeinfo;
    ulpResTypeInfo = (ULPRESTYPEINFO)((LPBYTE)lpResTable + 2);

    while (ulpResTypeInfo->rt_id) {

        if (ulpResTypeInfo->rt_id == (iResType | RSORDID)) {

            lpResNameInfo = (LPRESNAMEINFO)(ulpResTypeInfo + 1);

            if (iResIndex == GET_COUNT)
                return (LPVOID)ulpResTypeInfo->rt_nres;

            if (iResIndex < 0) {

                for (i=0; i < (int)ulpResTypeInfo->rt_nres; i++) {

                    if (lpResNameInfo[i].rn_id == ((-iResIndex) | RSORDID))
                        break;
                }

                iResIndex = i;
            }

            if (iResIndex >= (int)ulpResTypeInfo->rt_nres)
                return NULL;

            *pcb = ((DWORD)lpResNameInfo[iResIndex].rn_length) << lpResTable->rs_align;
            return (LPBYTE)lpBase + ((long)lpResNameInfo[iResIndex].rn_offset << lpResTable->rs_align);
        }

        ulpResTypeInfo =
               (ULPRESTYPEINFO)((LPRESNAMEINFO)(ulpResTypeInfo + 1) +
                ulpResTypeInfo->rt_nres);
    }

    *pcb = 0;
    return NULL;
}

/***************************************************************************\
* ExtractIconFromICO
*
*
\***************************************************************************/

UINT ExtractIconFromICO(
    LPTSTR szFile,
    int    nIconIndex,
    int    cxIcon,
    int    cyIcon,
    HICON  *phicon,
    UINT   flags)
{
    HICON hicon;

    if (nIconIndex >= 1)
        return 0;

    flags |= LR_LOADFROMFILE;

again:

    hicon = LoadImage(NULL,
                      szFile,
                      IMAGE_ICON,
                      LOWORD(cxIcon),
                      LOWORD(cyIcon),
                      flags);

    if (hicon == NULL)
        return 0;

    /*
     * Do we just want a count?
     */
    if (phicon == NULL)
        DestroyCursor((HCURSOR)hicon);
    else
        *phicon = hicon;

    /*
     * Check for large/small icon extract
     */
    if (HIWORD(cxIcon)) {

        cxIcon = HIWORD(cxIcon);
        cyIcon = HIWORD(cyIcon);
        phicon++;

        goto again;
    }

    return 1;
}

/***************************************************************************\
* ExtractIconFromBMP
*
*
\***************************************************************************/

#define ROP_DSna 0x00220326

UINT ExtractIconFromBMP(
    LPTSTR szFile,
    int    nIconIndex,
    int    cxIcon,
    int    cyIcon,
    HICON  *phicon,
    UINT   flags)
{
    HICON    hicon;
    HBITMAP  hbm;
    HBITMAP  hbmMask;
    HDC      hdc;
    HDC      hdcMask;
    ICONINFO ii;

    if (nIconIndex >= 1)
        return 0;

    /*
     * BUGUS: don't use LR_CREATEDIBSECTION.  USER can't make an icon out
     * of a DibSection.
     */
    flags |= LR_LOADFROMFILE;

again:

    hbm = (HBITMAP)LoadImage(NULL,
                             szFile,
                             IMAGE_BITMAP,
                             LOWORD(cxIcon),
                             LOWORD(cyIcon),
                             flags);

    if (hbm == NULL)
        return 0;

    /*
     *  do we just want a count?
     */
    if (phicon == NULL) {
        DeleteObject(hbm);
        return 1;
    }

    hbmMask = CreateBitmap(LOWORD(cxIcon), LOWORD(cyIcon), 1, 1, NULL);

    hdc = CreateCompatibleDC(NULL);
    SelectObject(hdc, hbm);

    hdcMask = CreateCompatibleDC(NULL);
    SelectObject(hdcMask, hbmMask);

    SetBkColor(hdc, GetPixel(hdc, 0, 0));

    BitBlt(hdcMask, 0, 0, LOWORD(cxIcon), LOWORD(cyIcon), hdc, 0, 0, SRCCOPY);
    BitBlt(hdc, 0, 0, LOWORD(cxIcon), LOWORD(cyIcon), hdcMask, 0, 0, ROP_DSna);

    ii.fIcon    = TRUE;
    ii.xHotspot = 0;
    ii.yHotspot = 0;
    ii.hbmColor = hbm;
    ii.hbmMask  = hbmMask;
    hicon = CreateIconIndirect(&ii);

    DeleteObject(hdc);
    DeleteObject(hbm);
    DeleteObject(hdcMask);
    DeleteObject(hbmMask);

    *phicon = hicon;

    /*
     * Check for large/small icon extract
     */
    if (HIWORD(cxIcon)) {
        cxIcon = HIWORD(cxIcon);
        cyIcon = HIWORD(cyIcon);
        phicon++;

        goto again;
    }

    return 1;
}

/***************************************************************************\
* ExtractIconFromEXE
*
*
\***************************************************************************/

UINT ExtractIconFromEXE(
    HANDLE hFile,
    int    nIconIndex,
    int    cxIconSize,
    int    cyIconSize,
    HICON  *phicon,
    UINT   *piconid,
    UINT   nIcons,
    UINT   flags)
{
    HANDLE           hFileMap = INVALID_HANDLE_VALUE;
    LPVOID           lpFile = NULL;
    EXEHDR           *pmz;
    NEWEXE UNALIGNED *pne;
    LPVOID           pBase;
    LPVOID           pres = NULL;
    UINT             result = 0;
    LONG             FileLength;
    DWORD            cbSize;
    int              cxIcon;
    int              cyIcon;

    LPVOID (*FindResourceX)(LPVOID pBase,
                            LPVOID prt,
                            int    iResIndex,
                            int    iResType,
                            DWORD  *pcb);

    FileLength = (LONG)GetFileSize(hFile, NULL);

    hFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hFileMap == NULL)
        goto exit;

    lpFile = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);
    if (lpFile == NULL)
        goto exit;

    pBase = (LPVOID)lpFile;
    pmz = (struct exe_hdr *)pBase;

    _try {

        if (pmz->e_magic != MZMAGIC)
            goto exit;

        if (pmz->e_lfanew <= 0)             // not a new exe
            goto exit;

        if (pmz->e_lfanew >= FileLength)    // not a new exe
            goto exit;

        pne = (NEWEXE UNALIGNED *)((BYTE*)pmz + pmz->e_lfanew);

        switch (pne->ne_magic) {
        case NEMAGIC:
            pres = GetResourceTableNE(pBase);
            FindResourceX = FindResourceNE;
            break;

        case PEMAGIC:
            pres = GetResourceTablePE(pBase);
            FindResourceX = FindResourcePE;
            break;
        }

        /*
         * cant find the resource table, fail
         */
        if (pres == NULL)
            goto exit;

        /*
         * do we just want a count?
         */
        if (phicon == NULL) {
            result = PtrToUlong(FindResourceX(pBase,
                                             pres,
                                             GET_COUNT,
                                             (LONG_PTR)RT_GROUP_ICON,
                                             &cbSize));
            goto exit;
        }

        while (result < nIcons) {

            LPVOID lpIconDir;
            LPVOID lpIcon;
            int    idIcon;

            cxIcon = cxIconSize;
            cyIcon = cyIconSize;

            /*
             *  find the icon dir for this icon.
             */
            lpIconDir = FindResourceX(pBase,
                                      pres,
                                      nIconIndex,
                                      (LONG_PTR)RT_GROUP_ICON,
                                      &cbSize);

            if (lpIconDir == NULL)
                goto exit;

            if ((((LPNEWHEADER)lpIconDir)->Reserved != 0) ||
                (((LPNEWHEADER)lpIconDir)->ResType != FT_ICON)) {

                goto exit;
            }
again:
            idIcon = LookupIconIdFromDirectoryEx((LPBYTE)lpIconDir,
                                                 TRUE,
                                                 LOWORD(cxIcon),
                                                 LOWORD(cyIcon),
                                                 flags);
            lpIcon = FindResourceX(pBase,
                                   pres,
                                   -idIcon,
                                   (LONG_PTR)RT_ICON,
                                   &cbSize);

            if (lpIcon == NULL)
                goto exit;

            if ((((UPBITMAPINFOHEADER)lpIcon)->biSize != sizeof(BITMAPINFOHEADER)) &&
                (((UPBITMAPINFOHEADER)lpIcon)->biSize != sizeof(BITMAPCOREHEADER))) {

                goto exit;
            }

#ifndef WINNT
            /* touch this memory before calling USER
             * so if we page fault we will do it outside of the Win16Lock
             * most icons aren't more than 2 pages
             */
            ReadAByte(((BYTE *)lpIcon) + cbSize - 1);
#endif

            if (piconid)
                piconid[result] = idIcon;

            phicon[result++] = CreateIconFromResourceEx((LPBYTE)lpIcon,
                                                        cbSize,
                                                        TRUE,
                                                        WIN32VER30,
                                                        LOWORD(cxIcon),
                                                        LOWORD(cyIcon),
                                                        flags);

            /*
             * check for large/small icon extract
             */
            if (HIWORD(cxIcon)) {

                cxIcon = HIWORD(cxIcon);
                cyIcon = HIWORD(cyIcon);

                goto again;
            }

            nIconIndex++;       // next icon index
        }

    } _except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        result = 0;
    }

exit:

    if (lpFile)
        UnmapViewOfFile(lpFile);

    if (hFileMap != INVALID_HANDLE_VALUE)
        CloseHandle(hFileMap);

    return result;
}

/***************************************************************************\
* PathFindExtension
*
*
\***************************************************************************/

LPWSTR PathFindExtension(
    LPWSTR pszPath)
{
    LPWSTR pszDot;

    for (pszDot = NULL; *pszPath; pszPath = CharNext(pszPath)) {

        switch (*pszPath) {
        case L'.':
            pszDot = pszPath;    // remember the last dot
            break;

        case L'\\':
        case L' ':               // extensions can't have spaces
            pszDot = NULL;       // forget last dot, it was in a directory
            break;
        }
    }

    /*
     * if we found the extension, return ptr to the dot, else
     * ptr to end of the string (NULL extension) (cast->non const)
     */
    return pszDot ? (LPWSTR)pszDot : (LPWSTR)pszPath;
}

/***************************************************************************\
* PrivateExtractIconExA
*
* Ansi version of PrivateExtractIconExW
*
\***************************************************************************/

WINUSERAPI UINT PrivateExtractIconExA(
    LPCSTR szFileName,
    int    nIconIndex,
    HICON  *phiconLarge,
    HICON  *phiconSmall,
    UINT   nIcons)
{
    LPWSTR szFileNameW;
    UINT    uRet;

    if (!MBToWCS(szFileName, -1, &szFileNameW, -1, TRUE))
        return 0;

    uRet = PrivateExtractIconExW(szFileNameW,
                                 nIconIndex,
                                 phiconLarge,
                                 phiconSmall,
                                 nIcons);

    UserLocalFree(szFileNameW);

    return uRet;
}

/***************************************************************************\
* HasExtension
*
*
\***************************************************************************/

DWORD HasExtension(
    LPWSTR pszPath)
{
    LPWSTR p = PathFindExtension(pszPath);

    /*
     * (BobDay, emended by JasonSch):
     *
     * NOTE: This routine can produce false positives. E.g., "Fister.Bather"
     * would return .BAT. This doesn't currently hurt us in the instances where
     * this routine is used. However, people stealing this code should verify
     * that this is okay for them.
     *
     * NOTE: We could make this EXTKEY based like the extension matching
     * stuff elsewhere (e.g., shlwapi\urlpars.cpp).  EXTKEY is a QWORD
     * so UNICODE would fit.
     */
    if (*p == L'.') {

        WCHAR szExt[5];

        lstrcpynW(szExt, p, 5);

        if (lstrcmpiW(szExt,TEXT(".com")) == 0) return COM_FILE;
        if (lstrcmpiW(szExt,TEXT(".bat")) == 0) return BAT_FILE;
        if (lstrcmpiW(szExt,TEXT(".cmd")) == 0) return CMD_FILE;
        if (lstrcmpiW(szExt,TEXT(".pif")) == 0) return PIF_FILE;
        if (lstrcmpiW(szExt,TEXT(".lnk")) == 0) return LNK_FILE;
        if (lstrcmpiW(szExt,TEXT(".ico")) == 0) return ICO_FILE;
        if (lstrcmpiW(szExt,TEXT(".exe")) == 0) return EXE_FILE;
    }

    return 0;
}

/***************************************************************************\
* PrivateExtractIconsW
*
* Extracts 1 or more icons from a file.
*
* input:
*     szFileName          - EXE/DLL/ICO/CUR/ANI file to extract from
*     nIconIndex          - what icon to extract
*                             0 = first icon, 1=second icon, etc.
*                            -N = icon with id==N
*     cxIcon              - icon size wanted (if HIWORD != 0 two sizes...)
*     cyIcon              - icon size wanted (if HIWORD != 0 two sizes...)
*                           0,0 means extract at natural size.
*     phicon              - place to return extracted icon(s)
*     nIcons              - number of icons to extract.
*     flags               - LoadImage LR_* flags
*
* returns:
*     if picon is NULL, number of icons in the file is returned.
*
* notes:
*     handles extraction from PE (Win32), NE (Win16), ICO (Icon),
*     CUR (Cursor), ANI (Animated Cursor), and BMP (Bitmap) files.
*     only Win16 3.x files are supported (not 2.x)
*
*     cx/cyIcon are the size of the icon to extract, two sizes
*     can be extracted by putting size 1 in the loword and size 2 in the
*     hiword, ie MAKELONG(24, 48) would extract 24 and 48 size icons.
*     This is a hack it is done so IExtractIcon::Extract can be called by
*     outside people with custom large/small icon sizes that are not what
*     the shell uses internaly.
*
\***************************************************************************/

WINUSERAPI UINT WINAPI PrivateExtractIconsW(
    LPCWSTR szFileName,
    int     nIconIndex,
    int     cxIcon,
    int     cyIcon,
    HICON   *phicon,
    UINT    *piconid,
    UINT    nIcons,
    UINT    flags)
{
    HANDLE   hFile = (HANDLE)INVALID_HANDLE_VALUE;
    UINT     result = 0;
    WORD     magic[6];
    WCHAR    achFileName[MAX_PATH];
    FILETIME ftAccess;
    WCHAR    szExpFileName[MAX_PATH];
    DWORD    dwBytesRead;

    /*
     * Set failure defaults.
     */
    if (phicon)
        *phicon = NULL;

    /*
     * Check for special extensions, and fail quick
     */
    switch (HasExtension((LPWSTR)szFileName)) {
    case COM_FILE:
    case BAT_FILE:
    case CMD_FILE:
    case PIF_FILE:
    case LNK_FILE:
        goto exit;

    default:
        break;
    }

    /*
     * Try expanding environment variables in the file name we're passed.
     */
    ExpandEnvironmentStrings(szFileName, szExpFileName, MAX_PATH);
    szExpFileName[ MAX_PATH-1 ] = (WCHAR)0;

    /*
     * Open the file - First check to see if it is a UNC path.  If it
     * is make sure that we have access to the path...
     */
    if (PathIsUNC(szExpFileName)) {

        lstrcpynW(achFileName, szExpFileName, ARRAYSIZE(achFileName));

    } else {

        if (SearchPath(NULL,
                       szExpFileName,
                       NULL,
                       ARRAYSIZE(achFileName),
                       achFileName, NULL) == 0) {

            goto error_file;
        }
    }

    hFile = CreateFile(achFileName,
                       GENERIC_READ|FILE_WRITE_ATTRIBUTES,
                       FILE_SHARE_WRITE | FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                       0);

    if (hFile == INVALID_HANDLE_VALUE) {

        hFile = CreateFile(achFileName, GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                           0);

        if (hFile == INVALID_HANDLE_VALUE)
            goto error_file;

    } else {

        /*
         * Restore the Access Date
         */
        if (GetFileTime(hFile, NULL, &ftAccess, NULL))
            SetFileTime(hFile, NULL, &ftAccess, NULL);
    }


    ReadFile(hFile, &magic, sizeof(magic), &dwBytesRead, NULL);
    if (dwBytesRead != sizeof(magic))
        goto exit;

    if (piconid)
        *piconid = (UINT)-1;    // Fill in "don't know" value

    switch (magic[0]) {
    case MZMAGIC:
        result = ExtractIconFromEXE(hFile,
                                    nIconIndex,
                                    cxIcon,
                                    cyIcon,
                                    phicon,
                                    piconid,
                                    nIcons,
                                    flags);
        break;

    case ANI_MAGIC:    // possible .ani cursor

        /*
         * Ani cursors are easy they are RIFF files of type 'ACON'
         */
        if (magic[1] == ANI_MAGIC1 && magic[4] == ANI_MAGIC4 &&
            magic[5] == ANI_MAGIC5) {

            result = ExtractIconFromICO(achFileName,
                                        nIconIndex,
                                        cxIcon,
                                        cyIcon,
                                        phicon,
                                        flags);
        }
        break;

    case BMP_MAGIC:    // possible bitmap
        result = ExtractIconFromBMP(achFileName,
                                    nIconIndex,
                                    cxIcon,
                                    cyIcon,
                                    phicon,
                                    flags);
        break;

    case ICON_MAGIC:   // possible .ico or .cur

        /*
         * Icons and cursors look like this
         *
         * iReserved       - always zero
         * iResourceType   - 1 for icons 2 cor cursor.
         * cresIcons       - number of resolutions in this file
         *
         * We only allow 1 <= cresIcons <= 10
         */
        if (magic[1] == ICO_MAGIC1 || magic[1] == CUR_MAGIC1) {

            result = ExtractIconFromICO(achFileName,
                                        nIconIndex,
                                        cxIcon,
                                        cyIcon,
                                        phicon,
                                        flags);
        }
        break;
    }

exit:

    if (hFile!=INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return result;

    /*
     *  if we cant open the file, return a code saying we cant open the file
     *  if phicon==NULL return the count of icons in the file 0
     */

error_file:

    result = (phicon ? (UINT)-1 : 0);

    goto exit;
}

/***************************************************************************\
* PrivateExtractIconsA
*
*
\***************************************************************************/

WINUSERAPI UINT WINAPI PrivateExtractIconsA(
    LPCSTR szFileName,
    int     nIconIndex,
    int     cxIcon,
    int     cyIcon,
    HICON   *phicon,
    UINT    *piconid,
    UINT    nIcons,
    UINT    flags)
{
    LPWSTR szFileNameW;
    UINT uRet;

    if (!MBToWCS(szFileName, -1, &szFileNameW, -1, TRUE))
        return 0;

    uRet = PrivateExtractIconsW(szFileNameW,
                                nIconIndex,
                                cxIcon,
                                cyIcon,
                                phicon,
                                piconid,
                                nIcons,
                                flags);

    UserLocalFree(szFileNameW);

    return uRet;
}

/***************************************************************************\
* PrivateExtractIconExW
*
* extracts 1 or more icons from a file.
*
* input:
*     szFileName          - EXE/DLL/ICO file to extract from
*     nIconIndex          - what icon to extract
*                             0 = first icon, 1=second icon, etc.
*                            -N = icon with id==N
*     phiconLarge         - place to return extracted icon(s)
*     phiconSmall         - place to return extracted icon(s) (small size)
*     nIcons              - number of icons to extract.
*
* returns:
*     number of icons extracted, or the count of icons if phiconLarge==NULL
*
* notes:
*     handles extraction from PE (Win32), NE (Win16), and ICO (Icon) files.
*     only Win16 3.x files are supported (not 2.x)
*
\***************************************************************************/

WINUSERAPI UINT PrivateExtractIconExW(
    LPCWSTR szFileName,
    int     nIconIndex,
    HICON   *phiconLarge,
    HICON   *phiconSmall,
    UINT    nIcons)
{
    UINT result = 0;

    if ((nIconIndex == -1) || ((phiconLarge == NULL) && (phiconSmall == NULL)))
        return PrivateExtractIconsW(szFileName, 0, 0, 0, NULL, NULL, 0, 0);

    if (phiconLarge && phiconSmall && (nIcons == 1)) {

        HICON ahicon[2];

        ahicon[0] = NULL;
        ahicon[1] = NULL;

        result = PrivateExtractIconsW(szFileName,
                                      nIconIndex,
                                      MAKELONG(GetSystemMetrics(SM_CXICON),
                                               GetSystemMetrics(SM_CXSMICON)),
                                      MAKELONG(GetSystemMetrics(SM_CYICON),
                                               GetSystemMetrics(SM_CYSMICON)),
                                      ahicon,
                                      NULL,
                                      2,
                                      0);

        *phiconLarge = ahicon[0];
        *phiconSmall = ahicon[1];

    } else {

        if (phiconLarge)
            result = PrivateExtractIconsW(szFileName,
                                          nIconIndex,
                                          GetSystemMetrics(SM_CXICON),
                                          GetSystemMetrics(SM_CYICON),
                                          phiconLarge,
                                          NULL,
                                          nIcons,
                                          0);

        if (phiconSmall)
            result = PrivateExtractIconsW(szFileName,
                                          nIconIndex,
                                          GetSystemMetrics(SM_CXSMICON),
                                          GetSystemMetrics(SM_CYSMICON),
                                          phiconSmall,
                                          NULL,
                                          nIcons,
                                          0);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\edslrare.c ===
/****************************************************************************\
* edslRare.c - SL Edit controls Routines Called rarely are to be
* put in a seperate segment _EDSLRare. This file contains
* these routines.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Single-Line Support Routines called Rarely
*
* Created: 02-08-89 sankar
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* SLCreate
*
* Creates the edit control for the window hwnd by allocating memory
* as required from the application's heap. Notifies parent if no memory
* error (after cleaning up if needed). Returns TRUE if no error else return s
* -1.
*
* History:
\***************************************************************************/

LONG SLCreate(
    PED ped,
    LPCREATESTRUCT lpCreateStruct) //!!! CREATESTRUCT AorW and in other routines
{
    LPSTR lpWindowText;
    LONG windowStyle = ped->pwnd->style;

    /*
     * Do the standard creation stuff
     */
    if (!ECCreate(ped, windowStyle))
        return (-1);

    /*
     * Single lines always have no undo and 1 line
     */
    ped->cLines = 1;
    ped->undoType = UNDO_NONE;

    /*
     * Check if this edit control is part of a combobox and get a pointer to the
     * combobox structure.
     */
    if (windowStyle & ES_COMBOBOX)
        ped->listboxHwnd = GetDlgItem(lpCreateStruct->hwndParent, CBLISTBOXID);

    /*
     * Set the default font to be the system font.
     */
    ECSetFont(ped, NULL, FALSE);

    /*
     * Set the window text if needed. Return false if we can't set the text
     * SLSetText notifies the parent in case there is a no memory error.
     */
    if ((ULONG_PTR)lpCreateStruct->lpszName > gHighestUserAddress)
        lpWindowText = REBASEPTR(ped->pwnd, (PVOID)lpCreateStruct->lpszName);
    else
        lpWindowText = (LPSTR)lpCreateStruct->lpszName;

    if ((lpWindowText != NULL)
            && !IsEmptyString(lpWindowText, ped->fAnsi)
            && !ECSetText(ped, lpWindowText)) {
        return (-1);
    }

    if (windowStyle & ES_PASSWORD)
        ECSetPasswordChar(ped, (UINT)'*');

    return TRUE;
}

/***************************************************************************\
* SLUndoHandler AorW
*
* Handles UNDO for single line edit controls.
*
* History:
\***************************************************************************/

BOOL SLUndo(
    PED ped)
{
    PBYTE hDeletedText = ped->hDeletedText;
    BOOL fDelete = (BOOL)(ped->undoType & UNDO_DELETE);
    ICH cchDeleted = ped->cchDeleted;
    ICH ichDeleted = ped->ichDeleted;
    BOOL fUpdate = FALSE;

    if (ped->undoType == UNDO_NONE) {

        /*
         * No undo...
         */
        return FALSE;
    }

    ped->hDeletedText = NULL;
    ped->cchDeleted = 0;
    ped->ichDeleted = (ICH)-1;
    ped->undoType &= ~UNDO_DELETE;

    if (ped->undoType == UNDO_INSERT) {
        ped->undoType = UNDO_NONE;

        /*
         * Set the selection to the inserted text
         */
        SLSetSelection(ped, ped->ichInsStart, ped->ichInsEnd);
        ped->ichInsStart = ped->ichInsEnd = (ICH)-1;

#ifdef NEVER

        /*
         * Now send a backspace to deleted and save it in the undo buffer...
         */
        SLCharHandler(pped, VK_BACK);
        fUpdate = TRUE;
#else

        /*
         * Delete the selected text and save it in undo buff.
         * Call ECDeleteText() instead of sending a VK_BACK message
         * which results in an EN_UPDATE notification send even before
         * we insert the deleted chars. This results in Bug #6610.
         * Fix for Bug #6610 -- SANKAR -- 04/19/91 --
         */
        if (ECDeleteText(ped)) {

            /*
             * Text was deleted -- flag for update and clear selection
             */
            fUpdate = TRUE;
            SLSetSelection(ped, ichDeleted, ichDeleted);
        }
#endif
    }

    if (fDelete) {
        HWND hwndSave = ped->hwnd; // Used for validation.

        /*
         * Insert deleted chars. Set the selection to the inserted text.
         */
        SLSetSelection(ped, ichDeleted, ichDeleted);
        SLInsertText(ped, hDeletedText, cchDeleted);
        UserGlobalFree(hDeletedText);
        if (!IsWindow(hwndSave))
            return FALSE;
        SLSetSelection(ped, ichDeleted, ichDeleted + cchDeleted);
        fUpdate = TRUE;
    }

    if (fUpdate) {
        /*
         * If we have something to update, send EN_UPDATE before and
         * EN_CHANGE after the actual update.
         * A part of the fix for Bug #6610 -- SANKAR -- 04/19/91 --
         */
        ECNotifyParent(ped, EN_UPDATE);

        if (FChildVisible(ped->hwnd)) {
// JimA changed this to ECInvalidateClient(ped, FALSE) Nov 1994
//            GetClientRect(ped->hwnd, &rcEdit);
//            if (ped->fBorder && rcEdit.right - rcEdit.left && rcEdit.bottom - rcEdit.top) {
//
//                /*
//                 * Don't invalidate the border so that we avoid flicker
//                 */
//                InflateRect(&rcEdit, -1, -1);
//            }
//            NtUserInvalidateRect(ped->hwnd, &rcEdit, FALSE);
            ECInvalidateClient(ped, FALSE);
        }

        ECNotifyParent(ped, EN_CHANGE);

        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\fareast.c ===
/**************************************************************************\
* Module Name: fareast.c
*
* Win32 IMM/IME API functions
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 07-May-1996 takaok    Created.
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define COMMON_RETURN_ZERO  \
    return 0;

////////////////////////
// Fake routines
////////////////////////

VOID fakeImm_v1(PVOID dummy)
{
    UNREFERENCED_PARAMETER(dummy);
}

#ifdef CUAS_ENABLE
VOID fakeImm_vd1(DWORD dummy)
{
    UNREFERENCED_PARAMETER(dummy);
};
#endif // CUAS_ENABLE

DWORD fakeImm_d1(DWORD dummy)
{
    UNREFERENCED_PARAMETER(dummy);
    return 0;
}

#ifdef CUAS_ENABLE
DWORD fakeImm_dv1(VOID)
{
    return 0;
};
#endif // CUAS_ENABLE

VOID fakeImm_v2(PVOID dummy1, PVOID dummy2)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
}

DWORD fakeImm_d2(DWORD dummy1, DWORD dummy2)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    return 0;
}

DWORD fakeImm_d3(DWORD dummy1, DWORD dummy2, DWORD dummy3)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    UNREFERENCED_PARAMETER(dummy3);
    return 0;
}

DWORD fakeImm_bwuwl(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(msg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    return 0;
}

VOID WINAPI fakeImm_wv1(PVOID dummy)
{
    UNREFERENCED_PARAMETER(dummy);
}

DWORD WINAPI fakeImm_wd1(PVOID dummy)
{
    UNREFERENCED_PARAMETER(dummy);
    COMMON_RETURN_ZERO;
}

DWORD WINAPI fakeImm_wd2(PVOID dummy1, PVOID dummy2)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    COMMON_RETURN_ZERO;
}

//
// This stub returns true.
//
BOOL WINAPI fakeImm_bd2(PVOID dummy1, PVOID dummy2)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    return TRUE;
}

DWORD WINAPI fakeImm_wd3(PVOID dummy1, PVOID dummy2, PVOID dummy3)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    UNREFERENCED_PARAMETER(dummy3);

    COMMON_RETURN_ZERO;
}

DWORD WINAPI fakeImm_wd4(PVOID dummy1, PVOID dummy2, PVOID dummy3, PVOID dummy4)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    UNREFERENCED_PARAMETER(dummy3);
    UNREFERENCED_PARAMETER(dummy4);

    COMMON_RETURN_ZERO;
}

DWORD WINAPI fakeImm_wd5(PVOID dummy1, PVOID dummy2, PVOID dummy3, PVOID dummy4, PVOID dummy5)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    UNREFERENCED_PARAMETER(dummy3);
    UNREFERENCED_PARAMETER(dummy4);
    UNREFERENCED_PARAMETER(dummy5);

    COMMON_RETURN_ZERO;
}

DWORD WINAPI fakeImm_wd6(PVOID dummy1, PVOID dummy2, PVOID dummy3, PVOID dummy4, PVOID dummy5, PVOID dummy6)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    UNREFERENCED_PARAMETER(dummy3);
    UNREFERENCED_PARAMETER(dummy4);
    UNREFERENCED_PARAMETER(dummy5);
    UNREFERENCED_PARAMETER(dummy6);

    COMMON_RETURN_ZERO;
}

ImmApiEntries gImmApiEntries = {
    (BOOL (WINAPI* /*ImmWINNLSEnableIME*/)(HWND, BOOL))     fakeImm_wd2,
    (BOOL (WINAPI* /*ImmWINNLSGetEnableStatus*/)(HWND))     fakeImm_wd1,
    (LRESULT (WINAPI* /*SendIMEMessageExW*/)(HWND, LPARAM)) fakeImm_wd2,
    (LRESULT (WINAPI* /*SendIMEMessageExA*/)(HWND, LPARAM)) fakeImm_wd2,
    (BOOL (WINAPI* /*IMPGetIMEW*/)(HWND, LPIMEPROW))        fakeImm_wd2,
    (BOOL (WINAPI* /*IMPGetIMEA*/)(HWND, LPIMEPROA))        fakeImm_wd2,
    (BOOL (WINAPI* /*IMPQueryIMEW*/)(LPIMEPROW))            fakeImm_wd1,
    (BOOL (WINAPI* /*IMPQueryIMEA*/)(LPIMEPROA))            fakeImm_wd1,
    (BOOL (WINAPI* /*IMPSetIMEW*/)(HWND, LPIMEPROW))        fakeImm_wd2,
    (BOOL (WINAPI* /*IMPSetIMEA*/)(HWND, LPIMEPROA))        fakeImm_wd2,

    (HIMC (WINAPI* /*ImmAssociateContext*/)(HWND, HIMC))    fakeImm_wd2,
    (LRESULT (WINAPI* /*ImmEscapeA*/)(HKL, HIMC, UINT, LPVOID)) fakeImm_wd4,
    (LRESULT (WINAPI* /*ImmEscapeW*/)(HKL, HIMC, UINT, LPVOID)) fakeImm_wd4,
    (LONG (WINAPI* /*ImmGetCompositionStringA*/)(HIMC, DWORD, LPVOID, DWORD)) fakeImm_wd4,
    (LONG (WINAPI* /*ImmGetCompositionStringW*/)(HIMC, DWORD, LPVOID, DWORD)) fakeImm_wd4,
    (BOOL (WINAPI* /*ImmGetCompositionWindow*/)(HIMC, LPCOMPOSITIONFORM)) fakeImm_wd2,
    (HIMC (WINAPI* /*ImmGetContext*/)(HWND))                fakeImm_wd1,
    (HWND (WINAPI* /*ImmGetDefaultIMEWnd*/)(HWND))          fakeImm_wd1,
    (BOOL (WINAPI* /*ImmIsIME*/)(HKL))                      fakeImm_wd1,
    (BOOL (WINAPI* /*ImmReleaseContext*/)(HWND, HIMC))      fakeImm_wd2,
    (BOOL (* /*ImmRegisterClient*/)(PSHAREDINFO, HINSTANCE))           fakeImm_bd2,

    (BOOL (WINAPI* /*ImmGetCompositionFontW*/)(HIMC, LPLOGFONTW)) fakeImm_wd2,
    (BOOL (WINAPI* /*ImmGetCompositionFontA*/)(HIMC, LPLOGFONTA)) fakeImm_wd2,
    (BOOL (WINAPI* /*ImmSetCompositionFontW*/)(HIMC, LPLOGFONTW)) fakeImm_wd2,
    (BOOL (WINAPI* /*ImmSetCompositionFontA*/)(HIMC, LPLOGFONTA)) fakeImm_wd2,

    (BOOL (WINAPI* /*ImmSetCompositionWindow*/)(HIMC, LPCOMPOSITIONFORM)) fakeImm_wd2,
    (BOOL (WINAPI* /*ImmNotifyIME*/)(HIMC, DWORD, DWORD, DWORD)) fakeImm_wd4,
    (PINPUTCONTEXT (WINAPI* /*ImmLockIMC*/)(HIMC))          fakeImm_wd1,
    (BOOL (WINAPI* /*ImmUnlockIMC*/)(HIMC))                 fakeImm_wd1,
    (BOOL (WINAPI* /*ImmLoadIME*/)(HKL))                    fakeImm_wd1,
    (BOOL (WINAPI* /*ImmSetOpenStatus*/)(HIMC, BOOL))       fakeImm_wd2,
    (BOOL (WINAPI* /*ImmFreeLayout*/)(DWORD dwFlag))        fakeImm_wd1,
    (BOOL (WINAPI* /*ImmActivateLayout*/)(HKL))             fakeImm_wd1,
    (BOOL (WINAPI* /*ImmGetCandidateWindow*/)(HIMC, DWORD, LPCANDIDATEFORM)) fakeImm_wd3,
    (BOOL (WINAPI* /*ImmSetCandidateWindow*/)(HIMC, LPCANDIDATEFORM))   fakeImm_wd2,
    (BOOL (WINAPI* /*ImmConfigureIMEW*/)(HKL, HWND, DWORD, LPVOID)) fakeImm_wd4,
    (BOOL (WINAPI* /*ImmGetConversionStatus*/)(HIMC, LPDWORD, LPDWORD)) fakeImm_wd3,
    (BOOL (WINAPI* /*ImmSetConversionStatus*/)(HIMC, DWORD, DWORD)) fakeImm_wd3,
    (BOOL (WINAPI* /*ImmSetStatusWindowPos*/)(HIMC, LPPOINT))           fakeImm_wd2,
    (BOOL (WINAPI* /*ImmGetImeInfoEx*/)(PIMEINFOEX, IMEINFOEXCLASS, PVOID)) fakeImm_wd3,
    (PIMEDPI (WINAPI* /*ImmLockImeDpi*/)(HKL))              fakeImm_wd1,
    (VOID (WINAPI* /*ImmUnlockImeDpi*/)(PIMEDPI))           fakeImm_wv1,
    (BOOL (WINAPI* /*ImmGetOpenStatus*/)(HIMC))             fakeImm_wd1,
    (BOOL (* /*ImmSetActiveContext*/)(HWND, HIMC, BOOL))    fakeImm_d3,
    (BOOL (* /*ImmTranslateMessage*/)(HWND, UINT, WPARAM, LPARAM)) fakeImm_bwuwl,
    (BOOL (* /*ImmLoadLayout*/)(HKL, PIMEINFOEX))           fakeImm_d2,
    (DWORD (WINAPI* /*ImmProcessKey*/)(HWND, HKL, UINT, LPARAM, DWORD)) fakeImm_wd5,
    (LRESULT (* /*ImmPutImeMenuItemsIntoMappedFile*/)(HIMC)) fakeImm_d1,
    (DWORD (WINAPI* /*ImmGetProperty*/)(HKL, DWORD))        fakeImm_wd2,
    (BOOL (WINAPI* /*ImmSetCompositionStringA*/)(
         HIMC hImc, DWORD dwIndex, LPCVOID lpComp, DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen))
                                                            fakeImm_wd6,
    (BOOL (WINAPI* /*ImmSetCompositionStringW*/)(
         HIMC hImc, DWORD dwIndex, LPCVOID lpComp, DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen))
                                                            fakeImm_wd6,
    (BOOL (WINAPI* /*ImmEnumInputContext*/)(
         DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam))  fakeImm_wd3,

    (LRESULT (WINAPI* /*ImmSystemHandler*/)(HIMC, WPARAM, LPARAM))
                                                             fakeImm_wd3,
#ifdef CUAS_ENABLE
    // Cicero
    (HRESULT (WINAPI* /* CtfImmTIMActivate*/)(HKL))             fakeImm_wd1,
    (VOID  (WINAPI* /* CtfImmRestoreToolbarWnd*/)(DWORD))       fakeImm_vd1,
    (DWORD (WINAPI* /* CtfImmHideToolbarWnd*/)(VOID))           fakeImm_dv1,
    (LRESULT (WINAPI* /* CtfImmDispatchDefImeMessage*/)(HWND, UINT, WPARAM, LPARAM))          fakeImm_bwuwl,
#endif // CUAS_ENABLE
};


//
// Imm32's instance handle
//
// NULL if not initialized.
//

HMODULE ghImm32;

#define IMMMODULENAME L"IMM32.DLL"
#define PATHDLM     L'\\'
#define IMMMODULENAMELEN    ((sizeof PATHDLM + sizeof IMMMODULENAME) / sizeof(WCHAR))

VOID GetImmFileName(PWSTR wszImmFile)
{
    UINT i = GetSystemDirectoryW(wszImmFile, MAX_PATH);
    if (i > 0 && i < MAX_PATH - IMMMODULENAMELEN) {
        wszImmFile += i;
        if (wszImmFile[-1] != PATHDLM) {
            *wszImmFile++ = PATHDLM;
        }
    }
    wcscpy(wszImmFile, IMMMODULENAME);
}

#define REGISTER(name,cast) \
    gImmApiEntries.name = (cast)GetProcAddress(hImm, #name); \
    if (gImmApiEntries.name == NULL) { \
        RIPMSG1(RIP_WARNING, "gImmApiEntries.%s got to be NULL", #name); \
        gImmApiEntries.name = (PVOID)fakeImm_v1; \
        return; \
    } else

///////////////////////////////////////////////////////
// _InitializeImmEntryTable(HMODULE)
//
//  Initialize IMM entry table:
///////////////////////////////////////////////////////
VOID _InitializeImmEntryTable(VOID)
{
    HMODULE hImm = ghImm32;
    WCHAR wszImmFile[MAX_PATH];

    if (((PVOID)gImmApiEntries.ImmWINNLSEnableIME) != ((PVOID)fakeImm_wd2)) {
        // already initialized.
        return;
    }

    GetImmFileName(wszImmFile);

    if (hImm == NULL) {
        // check if IMM DLL is already attached to the process
        hImm = GetModuleHandleW(wszImmFile);
    }

    if (hImm == NULL) {
        hImm = ghImm32 = LoadLibraryW(wszImmFile);
        if (hImm == NULL) {
            RIPMSG1(RIP_WARNING, "_InitializeImmEntryTable: failed to load Imm32.Dll: err=%d\n", GetLastError());
            return;
        }

        // at this point, Init routine of IMM32 has been called, thus User32InitializeImmEntry.. called.
        // all what we have to do is just return here.
        return;
    }

    if (hImm == NULL) {
        RIPMSG0(RIP_WARNING, "Failed to attach IMM32.DLL.\n");
        return;
    }

    // get the addresses of the procedures
    REGISTER(ImmWINNLSEnableIME, BOOL (WINAPI*)(HWND, BOOL));
    REGISTER(ImmWINNLSGetEnableStatus, BOOL (*)(HWND));
    REGISTER(ImmSendIMEMessageExW, LRESULT (*)(HWND, LPARAM));
    REGISTER(ImmSendIMEMessageExA, LRESULT (*)(HWND, LPARAM));
    REGISTER(ImmIMPGetIMEW, BOOL(*)(HWND, LPIMEPROW));
    REGISTER(ImmIMPGetIMEA, BOOL(*)(HWND, LPIMEPROA))
    REGISTER(ImmIMPQueryIMEW, BOOL(*)(LPIMEPROW))
    REGISTER(ImmIMPQueryIMEA, BOOL(*)(LPIMEPROA));
    REGISTER(ImmIMPSetIMEW, BOOL(*)(HWND, LPIMEPROW));
    REGISTER(ImmIMPSetIMEA, BOOL(*)(HWND, LPIMEPROA));

    REGISTER(ImmAssociateContext, HIMC (WINAPI*)(HWND, HIMC));
    REGISTER(ImmEscapeA, LRESULT(WINAPI*)(HKL, HIMC, UINT, LPVOID));
    REGISTER(ImmEscapeW, LRESULT(WINAPI*)(HKL, HIMC, UINT, LPVOID));
    REGISTER(ImmGetCompositionStringA, LONG (WINAPI*)(HIMC, DWORD, LPVOID, DWORD));
    REGISTER(ImmGetCompositionStringW, LONG (WINAPI*)(HIMC, DWORD, LPVOID, DWORD));
    REGISTER(ImmGetCompositionWindow, BOOL (WINAPI*)(HIMC, LPCOMPOSITIONFORM));
    REGISTER(ImmGetContext, HIMC (WINAPI*)(HWND));
    REGISTER(ImmGetDefaultIMEWnd, HWND (WINAPI*)(HWND));
    REGISTER(ImmIsIME, BOOL (WINAPI*)(HKL));
    REGISTER(ImmReleaseContext, BOOL (WINAPI*)(HWND, HIMC));
    REGISTER(ImmRegisterClient, BOOL(*)(PSHAREDINFO, HINSTANCE));

    REGISTER(ImmGetCompositionFontW, BOOL (WINAPI*)(HIMC, LPLOGFONTW));
    REGISTER(ImmGetCompositionFontA, BOOL (WINAPI*)(HIMC, LPLOGFONTA));
    REGISTER(ImmSetCompositionFontW, BOOL (WINAPI*)(HIMC, LPLOGFONTW));
    REGISTER(ImmSetCompositionFontA, BOOL (WINAPI*)(HIMC, LPLOGFONTA));

    REGISTER(ImmSetCompositionWindow, BOOL(WINAPI*)(HIMC, LPCOMPOSITIONFORM));
    REGISTER(ImmNotifyIME, BOOL (WINAPI*)(HIMC, DWORD, DWORD, DWORD));
    REGISTER(ImmLockIMC, PINPUTCONTEXT(WINAPI*)(HIMC));
    REGISTER(ImmUnlockIMC, BOOL (WINAPI*)(HIMC));
    REGISTER(ImmLoadIME, BOOL (WINAPI*)(HKL));
    REGISTER(ImmSetOpenStatus, BOOL (WINAPI*)(HIMC, BOOL));
    REGISTER(ImmFreeLayout, BOOL (WINAPI*)(DWORD));
    REGISTER(ImmActivateLayout, BOOL (WINAPI*)(HKL));
    REGISTER(ImmGetCandidateWindow, BOOL (WINAPI*)(HIMC, DWORD, LPCANDIDATEFORM));
    REGISTER(ImmSetCandidateWindow, BOOL (WINAPI*)(HIMC, LPCANDIDATEFORM));
    REGISTER(ImmConfigureIMEW, BOOL (WINAPI*)(HKL, HWND, DWORD, LPVOID));
    REGISTER(ImmGetConversionStatus, BOOL (WINAPI*)(HIMC, LPDWORD, LPDWORD));
    REGISTER(ImmSetConversionStatus, BOOL (WINAPI*)(HIMC, DWORD, DWORD));
    REGISTER(ImmSetStatusWindowPos, BOOL (WINAPI*)(HIMC, LPPOINT));
    REGISTER(ImmGetImeInfoEx, BOOL (WINAPI*)(PIMEINFOEX, IMEINFOEXCLASS, PVOID));
    REGISTER(ImmLockImeDpi, PIMEDPI (WINAPI*)(HKL));
    REGISTER(ImmUnlockImeDpi, VOID (WINAPI*)(PIMEDPI));
    REGISTER(ImmGetOpenStatus, BOOL (WINAPI*)(HIMC));
    REGISTER(ImmSetActiveContext, BOOL (*)(HWND, HIMC, BOOL));
    REGISTER(ImmTranslateMessage, BOOL (*)(HWND, UINT, WPARAM, LPARAM));
    REGISTER(ImmLoadLayout, BOOL (*)(HKL, PIMEINFOEX));
    REGISTER(ImmProcessKey, DWORD (*)(HWND, HKL, UINT, LPARAM, DWORD));
    REGISTER(ImmPutImeMenuItemsIntoMappedFile, LRESULT(*)(HIMC));
    REGISTER(ImmGetProperty, DWORD (WINAPI*)(HKL, DWORD));
    REGISTER(ImmSetCompositionStringA,
             BOOL (WINAPI*)(HIMC hImc, DWORD dwIndex, LPCVOID lpComp,
                   DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen))
    REGISTER(ImmSetCompositionStringW,
             BOOL (WINAPI*)(HIMC hImc, DWORD dwIndex, LPCVOID lpComp,
                   DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen));
    REGISTER(ImmEnumInputContext,
             BOOL (WINAPI*)(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam));
    REGISTER(ImmSystemHandler,
            LRESULT (WINAPI*)(HIMC, WPARAM, LPARAM));

#ifdef CUAS_ENABLE
    // Cicero
    REGISTER(CtfImmTIMActivate, HRESULT (WINAPI*)(HKL));
    REGISTER(CtfImmRestoreToolbarWnd, VOID (WINAPI*)(DWORD));
    REGISTER(CtfImmHideToolbarWnd, DWORD (WINAPI*)(VOID));
    REGISTER(CtfImmDispatchDefImeMessage, LRESULT (WINAPI*)(HWND, UINT, WPARAM, LPARAM));
#endif // CUAS_ENABLE
}

BOOL bImmInitializing = FALSE;

VOID InitializeImmEntryTable(VOID)
{
    bImmInitializing = TRUE;
    _InitializeImmEntryTable();
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, User32InitializeImmEntryTable, DWORD, magic)
BOOL User32InitializeImmEntryTable(DWORD magic)
{
    if (magic != IMM_MAGIC_CALLER_ID) {
        RIPMSG1(RIP_WARNING, "User32InitializeImmEntryTable: magic # does not match: 0x%08x", magic);
        return FALSE;
    }

    if (((PVOID)gImmApiEntries.ImmWINNLSEnableIME) != ((PVOID)fakeImm_wd2)) {
        // already initialized
        return TRUE;
    }

    _InitializeImmEntryTable();

    if (ghImm32 == NULL) {
        if (!bImmInitializing) {
            // increment the load counter of IMM32.DLL; application may call FreeLibrary later
            WCHAR wszImmFile[MAX_PATH];
            GetImmFileName(wszImmFile);
            ghImm32 = LoadLibraryW(wszImmFile);
        }
    }
    // for IMM initialization
    return fpImmRegisterClient(&gSharedInfo, ghImm32);
}

//
// for historical reasons, these entries are put in user32.dll
//

FUNCLOG1(LOG_GENERAL, UINT, WINAPI, WINNLSGetIMEHotkey, HWND, hwndIme)
UINT WINAPI WINNLSGetIMEHotkey(HWND hwndIme)
{
    UNREFERENCED_PARAMETER(hwndIme);

    //
    // Win95/NT3.51 behavior, i.e. always return 0.
    //
    return 0;
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, WINNLSEnableIME, HWND, hwnd, BOOL, bFlag)
BOOL WINAPI WINNLSEnableIME(HWND hwnd, BOOL bFlag)
{
    return gImmApiEntries.ImmWINNLSEnableIME(hwnd, bFlag);
}


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, WINNLSGetEnableStatus, HWND, hwnd)
BOOL WINAPI WINNLSGetEnableStatus(HWND hwnd)
{
    return gImmApiEntries.ImmWINNLSGetEnableStatus(hwnd);
}


FUNCLOG2(LOG_GENERAL, LRESULT, WINAPI, SendIMEMessageExW, HWND, hwnd, LPARAM, lParam)
LRESULT WINAPI SendIMEMessageExW(HWND hwnd, LPARAM lParam)
{
    return gImmApiEntries.ImmSendIMEMessageExW(hwnd, lParam);
}


FUNCLOG2(LOG_GENERAL, LRESULT, WINAPI, SendIMEMessageExA, HWND, hwnd, LPARAM, lParam)
LRESULT WINAPI SendIMEMessageExA(HWND hwnd, LPARAM lParam)
{
    return gImmApiEntries.ImmSendIMEMessageExA(hwnd, lParam);
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, IMPGetIMEW, HWND, hwnd, LPIMEPROW, lpImeProW)
BOOL WINAPI IMPGetIMEW(HWND hwnd, LPIMEPROW lpImeProW)
{
    return gImmApiEntries.ImmIMPGetIMEW(hwnd, lpImeProW);
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, IMPGetIMEA, HWND, hwnd, LPIMEPROA, lpImeProA)
BOOL WINAPI IMPGetIMEA(HWND hwnd, LPIMEPROA lpImeProA)
{
    return gImmApiEntries.ImmIMPGetIMEA(hwnd, lpImeProA);
}


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IMPQueryIMEW, LPIMEPROW, lpImeProW)
BOOL WINAPI IMPQueryIMEW(LPIMEPROW lpImeProW)
{
    return gImmApiEntries.ImmIMPQueryIMEW(lpImeProW);
}


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IMPQueryIMEA, LPIMEPROA, lpImeProA)
BOOL WINAPI IMPQueryIMEA(LPIMEPROA lpImeProA)
{
    return gImmApiEntries.ImmIMPQueryIMEA(lpImeProA);
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, IMPSetIMEW, HWND, hwnd, LPIMEPROW, lpImeProW)
BOOL WINAPI IMPSetIMEW(HWND hwnd, LPIMEPROW lpImeProW)
{
    return gImmApiEntries.ImmIMPSetIMEW(hwnd, lpImeProW);
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, IMPSetIMEA, HWND, hwnd, LPIMEPROA, lpImeProA)
BOOL WINAPI IMPSetIMEA(HWND hwnd, LPIMEPROA lpImeProA)
{
    return gImmApiEntries.ImmIMPSetIMEA(hwnd, lpImeProA);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\hdata.c ===
/****************************** Module Header ******************************\
* Module Name: hdata.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager data handle functions
*
* Created: 11/12/91 Sanford Staab
*
\***************************************************************************/

#define DDEMLDB
#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* DdeCreateDataHandle (DDEML API)
*
* Description
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG7(LOG_GENERAL, HDDEDATA, DUMMYCALLINGTYPE, DdeCreateDataHandle, DWORD, idInst, LPBYTE, pSrc, DWORD, cb, DWORD, cbOff, HSZ, hszItem, UINT, wFmt, UINT, afCmd)
HDDEDATA DdeCreateDataHandle(
DWORD idInst,
LPBYTE pSrc,
DWORD cb,
DWORD cbOff,
HSZ hszItem,
UINT wFmt,
UINT afCmd)
{
    PCL_INSTANCE_INFO pcii;
    HDDEDATA hRet = 0;

    if (cb == -1) {
        RIPMSG0(RIP_WARNING, "DdeCreateDataHandle called with cb == -1");
        return NULL;
    }

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (afCmd & ~HDATA_APPOWNED) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (cb + cbOff < sizeof(DWORD) && pSrc == NULL &&
            (wFmt == CF_METAFILEPICT ||
             wFmt == CF_DSPMETAFILEPICT ||
             wFmt == CF_DIB ||
             wFmt == CF_BITMAP ||
             wFmt == CF_DSPBITMAP ||
             wFmt == CF_PALETTE ||
             wFmt == CF_ENHMETAFILE ||
             wFmt == CF_DSPENHMETAFILE)) {
        /*
         * We have the nasty possibility of blowing up in FreeDDEData if we
         * don't initialize the data for formats with indirect data to 0.
         * This is because GlobalLock/GlobalSize do not adequately validate
         * random numbers given to them.
         */
        cb += 4;
    }
    hRet = InternalCreateDataHandle(pcii, pSrc, cb, cbOff,
            hszItem ? afCmd : (afCmd | HDATA_EXECUTE),
            (WORD)((afCmd & HDATA_APPOWNED) ? 0 : DDE_FRELEASE), (WORD)wFmt);

    if (!hRet) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
    }
Exit:
    LeaveDDECrit;
    return (hRet);
}


/***************************************************************************\
* InternalCreateDataHandle
*
* Description:
* Worker function for creating a data handle. If cb is -1, pSrc is
* a GMEM_DDESHARE data handle. 0 is return ed on error.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
HDDEDATA InternalCreateDataHandle(
PCL_INSTANCE_INFO pcii,
LPBYTE pSrc,
DWORD cb, // cb of actual data to initialize with
DWORD cbOff, // offset from start of data
DWORD flags,
WORD wStatus,
WORD wFmt)
{
    PDDEMLDATA pdd;
    HDDEDATA hRet;
    LPBYTE p;
    DWORD cbOff2;

    CheckDDECritIn;

    pdd = (PDDEMLDATA)DDEMLAlloc(sizeof(DDEMLDATA));
    if (pdd == NULL) {
        return (0);
    }
    if (cb == -1) {
        pdd->hDDE = (HANDLE)pSrc;
    } else {
        if (flags & HDATA_EXECUTE) {
            cbOff2 = 0;
        } else {
            cbOff2 = sizeof(WORD) + sizeof(WORD); // skip wStatus, wFmt
        }
        pdd->hDDE = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE | GMEM_ZEROINIT,
                cb + cbOff + cbOff2);
        if (pdd->hDDE == NULL) {
            DDEMLFree(pdd);
            return (0);
        }

        if (!(flags & HDATA_EXECUTE)) {
            PDDE_DATA pdde;

            USERGLOBALLOCK(pdd->hDDE, pdde);
            UserAssert(pdde);
            pdde->wStatus = wStatus;
            pdde->wFmt = wFmt;
            USERGLOBALUNLOCK(pdd->hDDE);
        }
    }
    pdd->flags = (WORD)flags;
    hRet = (HDDEDATA)CreateHandle((ULONG_PTR)pdd, HTYPE_DATA_HANDLE,
            InstFromHandle(pcii->hInstClient));
    if (!hRet) {
        WOWGLOBALFREE(pdd->hDDE);
        DDEMLFree(pdd);
        return (0);
    }
    if (cb != -1 && pSrc != NULL) {
        USERGLOBALLOCK(pdd->hDDE, p);
        UserAssert(p);
        RtlCopyMemory(p + cbOff + cbOff2, pSrc, cb);
        USERGLOBALUNLOCK(pdd->hDDE);
        pdd->flags |= HDATA_INITIALIZED;
    }
    return (hRet);
}

/***************************************************************************\
* DdeAddData (DDEML API)
*
* Description:
* Copys data from a user buffer to a data handles. Reallocates if needed.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, HDDEDATA, DUMMYCALLINGTYPE, DdeAddData, HDDEDATA, hData, LPBYTE, pSrc, DWORD, cb, DWORD, cbOff)
HDDEDATA DdeAddData(
HDDEDATA hData,
LPBYTE pSrc,
DWORD cb,
DWORD cbOff)
{
    LPSTR pMem;
    PDDEMLDATA pdd;
    PCL_INSTANCE_INFO pcii;
    HDDEDATA hRet = 0;
    HANDLE hTempDDE;

    EnterDDECrit;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData, HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hData);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (!(pdd->flags & HDATA_EXECUTE)) {
        cbOff += 4;
    }
    if (cb + cbOff > UserGlobalSize(pdd->hDDE)) {
        /*
         * If the realloc failed, free the old ptr. We continue 
         * on in order to maintain compatibility with previous DDE code.
         */
        hTempDDE = UserGlobalReAlloc(pdd->hDDE, cb + cbOff,
                                     GMEM_MOVEABLE | GMEM_ZEROINIT);
        
        if ((hTempDDE == NULL) && ((pdd->hDDE) != NULL)) {
            UserGlobalFree(pdd->hDDE);
        }
        pdd->hDDE = hTempDDE;
    }

    USERGLOBALLOCK(pdd->hDDE, pMem);

    if (pMem == NULL) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
        goto Exit;
    }

    hRet = hData;

    if (pSrc != NULL) {
        try {
            RtlCopyMemory(pMem + cbOff, pSrc, cb);
            pdd->flags |= HDATA_INITIALIZED;
        } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            hRet = 0;
        }
    }

    USERGLOBALUNLOCK(pdd->hDDE);

Exit:
    LeaveDDECrit;
    return (hRet);
}




/***************************************************************************\
* DdeGetData (DDEML API)
*
* Description:
* Copys data from a data handle into a user buffer.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, DdeGetData, HDDEDATA, hData, LPBYTE, pDst, DWORD, cbMax, DWORD, cbOff)
DWORD DdeGetData(
HDDEDATA hData,
LPBYTE pDst,
DWORD cbMax,
DWORD cbOff)
{
    DWORD cbCopied = 0;
    DWORD cbSize;
    PDDEMLDATA pdd;
    PCL_INSTANCE_INFO pcii;

    EnterDDECrit;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData,
            HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hData);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (!(pdd->flags & HDATA_EXECUTE)) {
        cbOff += 4;
    }
    cbSize = (DWORD)UserGlobalSize(pdd->hDDE);
    if (cbOff >= cbSize) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (pDst == NULL) {
        cbCopied = cbSize - cbOff;
        goto Exit;
    } else {
        LPSTR pMem;

        cbCopied = min(cbMax, cbSize - cbOff);
        USERGLOBALLOCK(pdd->hDDE, pMem);
        UserAssert(pMem);
        try {
            RtlCopyMemory(pDst, pMem + cbOff, cbCopied);
        } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            cbCopied = 0;
        }
        if (pMem != NULL) {
            USERGLOBALUNLOCK(pdd->hDDE);
        }
    }

Exit:
    LeaveDDECrit;
    return (cbCopied);
}





/***************************************************************************\
* DdeAccessData (DDEML API)
*
* Description:
* Locks a data handle for access.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, LPBYTE, DUMMYCALLINGTYPE, DdeAccessData, HDDEDATA, hData, LPDWORD, pcbDataSize)
LPBYTE DdeAccessData(
HDDEDATA hData,
LPDWORD pcbDataSize)
{
    PCL_INSTANCE_INFO pcii;
    PDDEMLDATA pdd;
    LPBYTE pRet = NULL;
    DWORD cbOff;

    EnterDDECrit;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData,
            HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hData);
    cbOff = pdd->flags & HDATA_EXECUTE ? 0 : 4;
    if (pcbDataSize != NULL) {
        *pcbDataSize = (DWORD)UserGlobalSize(pdd->hDDE) - cbOff;
    }
    USERGLOBALLOCK(pdd->hDDE, pRet);
    UserAssert(pRet);
    pRet = (LPBYTE)pRet + cbOff;

Exit:
    LeaveDDECrit;
    return (pRet);
}




/***************************************************************************\
* DdeUnaccessData (DDEML API)
*
* Description:
* Unlocks a data handle
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeUnaccessData, HDDEDATA, hData)
BOOL DdeUnaccessData(
HDDEDATA hData)
{
    PDDEMLDATA pdd;
    BOOL fSuccess = FALSE;

    EnterDDECrit;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData,
            HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        goto Exit;
    }
    USERGLOBALUNLOCK(pdd->hDDE);
    fSuccess = TRUE;

Exit:
    LeaveDDECrit;
    return (fSuccess);
}



/***************************************************************************\
* DdeFreeDataHandle (DDEML API)
*
* Description:
* Releases application interest in a data handle.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeFreeDataHandle, HDDEDATA, hData)
BOOL DdeFreeDataHandle(
HDDEDATA hData)
{
    PDDEMLDATA pdd;
    BOOL fSuccess = FALSE;

    EnterDDECrit;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData,
            HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        goto Exit;
    }
    if (pdd->flags & HDATA_NOAPPFREE) {
        fSuccess = TRUE;
        goto Exit;
    }

    fSuccess = InternalFreeDataHandle(hData, TRUE);

Exit:
    LeaveDDECrit;
    return (fSuccess);
}




/***************************************************************************\
* InternalFreeDataHandle
*
* Description:
* Frees a data handle and its contents. The contents are NOT freed for
* APPOWNED data handles unless fIgnorefRelease is set.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL InternalFreeDataHandle(
HDDEDATA hData,
BOOL fIgnorefRelease)
{
    PDDEMLDATA pdd;

    CheckDDECritIn;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData,
            HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        return (FALSE);
    }
    if (pdd->flags & HDATA_EXECUTE) {
        if (!(pdd->flags & HDATA_APPOWNED) || fIgnorefRelease) {
            WOWGLOBALFREE(pdd->hDDE);
        }
    } else {
        FreeDDEData(pdd->hDDE, fIgnorefRelease, TRUE);
    }
    DDEMLFree(pdd);
    DestroyHandle((HANDLE)hData);
    return (TRUE);
}


/***************************************************************************\
* ApplyFreeDataHandle
*
* Description:
* Used during data handle cleanup.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ApplyFreeDataHandle(
HANDLE hData)
{
    BOOL fRet;

    CheckDDECritOut;
    EnterDDECrit;
    fRet = InternalFreeDataHandle((HDDEDATA)hData, FALSE);
    LeaveDDECrit;
    return(fRet);
}


/***************************************************************************\
* FreeDDEData
*
* Description:
* Used for freeing DDE data including any special indirect objects
* associated with the data depending on the format. This function
* SHOULD NOT BE USED TO FREE EXECUTE DATA!
*
* The data is not freed if the fRelease bit is clear and fIgnoreRelease
* is FALSE.
*
*   The fFreeTruelyGlobalObjects parameter is used to distinguish tracking
*   layer frees from DDEML frees.  Data in certain formats (CF_BITMAP,
*   CF_PALETTE) is maintained on the gdi CSR server side.  When this is
*   passed between processes, gdi is not able to maintain multiple process
*   ownership on these objects so the objects must be made global.  Thus
*   the tracking layer should NOT free these objects on behalf of another
*   process because they are truely global- however, DDEML can do this
*   because it is following the protocol which delclares who is in charge
*   of freeing global data.  (YUCK!)
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
/*
 * WARNING: This is exported for NetDDE use - DO NOT CHANGE THE PARAMETERS!
 */
VOID FreeDDEData(
HANDLE hDDE,
BOOL fIgnorefRelease,
BOOL fFreeTruelyGlobalObjects)
{
    PDDE_DATA pdde;
    LPMETAFILEPICT pmfPict;
    DWORD cb;

    USERGLOBALLOCK(hDDE, pdde);
    if (pdde == NULL) {
        return ;
    }

    if ((pdde->wStatus & DDE_FRELEASE) || fIgnorefRelease) {
        cb = (DWORD)GlobalSize(hDDE);
        /*
         * Because there is the possibility that the data never got
         * initialized we need to do this in a try-except so we
         * behave nicely.
         */
        switch (pdde->wFmt) {
        case CF_BITMAP:
        case CF_DSPBITMAP:
        case CF_PALETTE:
            if (cb >= sizeof(HANDLE)) {
                if (fFreeTruelyGlobalObjects) {
                    if (pdde->Data != 0) {
                        DeleteObject((HANDLE)pdde->Data);
                    }
                } else {
                    /*
                     * !fFreeTruelyGlobalObject implies we are only freeing
                     * the Gdi proxy.  (another process may still have this
                     * object in use.)
                     *
                     * ChrisWil: removed this call.  No longer
                     *           applicable in KMode.
                     *
                     * GdiDeleteLocalObject((ULONG)pdde->Data);
                     *
                     */
                }
            }
            break;

        case CF_DIB:
            if (cb >= sizeof(HANDLE)) {
                if (pdde->Data != 0) {
                    WOWGLOBALFREE((HANDLE)pdde->Data);
                }
            }
            break;

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
            if (cb >= sizeof(HANDLE)) {
                if (pdde->Data != 0) {
                    USERGLOBALLOCK(pdde->Data, pmfPict);
                    if (pmfPict != NULL) {
                        if (GlobalSize((HANDLE)pdde->Data) >= sizeof(METAFILEPICT)) {
                            DeleteMetaFile(pmfPict->hMF);
                        }
                        USERGLOBALUNLOCK((HANDLE)pdde->Data);
                        WOWGLOBALFREE((HANDLE)pdde->Data);
                    }
                }
            }
            break;

        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
            if (cb >= sizeof(HANDLE)) {
                if (pdde->Data != 0) {
                    DeleteEnhMetaFile((HANDLE)pdde->Data);
                }
            }
            break;
        }
        USERGLOBALUNLOCK(hDDE);
        WOWGLOBALFREE(hDDE);
    } else {
        USERGLOBALUNLOCK(hDDE);
    }
}



HBITMAP CopyBitmap(
HBITMAP hbm)
{
    BITMAP bm;
    HBITMAP hbm2 = NULL, hbmOld1, hbmOld2;
    HDC hdc, hdcMem1, hdcMem2;

    if (!GetObject(hbm, sizeof(BITMAP), &bm)) {
        return(0);
    }
    hdc = NtUserGetDC(NULL);  // screen DC
    if (!hdc) {
        return(0);
    }
    hdcMem1 = CreateCompatibleDC(hdc);
    if (!hdcMem1) {
        goto Cleanup3;
    }
    hdcMem2 = CreateCompatibleDC(hdc);
    if (!hdcMem2) {
        goto Cleanup2;
    }
    hbmOld1 = SelectObject(hdcMem1, hbm);
    hbm2 = CreateCompatibleBitmap(hdcMem1, bm.bmWidth, bm.bmHeight);
    if (!hbm2) {
        goto Cleanup1;
    }
    hbmOld2 = SelectObject(hdcMem2, hbm2);
    BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY);
    SelectObject(hdcMem1, hbmOld1);
    SelectObject(hdcMem2, hbmOld2);
Cleanup1:
    DeleteDC(hdcMem2);
Cleanup2:
    DeleteDC(hdcMem1);
Cleanup3:
    NtUserReleaseDC(NULL, hdc);
    return(hbm2);
}


HPALETTE CopyPalette(
HPALETTE hpal)
{
    int cPalEntries;
    LOGPALETTE *plp;

    if (!GetObject(hpal, sizeof(int), &cPalEntries)) {
        return(0);
    }
    plp = (LOGPALETTE *)DDEMLAlloc(sizeof(LOGPALETTE) +
            (cPalEntries - 1) * sizeof(PALETTEENTRY));
    if (!plp) {
        return(0);
    }
    if (!GetPaletteEntries(hpal, 0, cPalEntries, plp->palPalEntry)) {
        DDEMLFree(plp);
        return(0);
    }
    plp->palVersion = 0x300;
    plp->palNumEntries = (WORD)cPalEntries;
    hpal = CreatePalette(plp);
    if (hpal != NULL) {
        if (!SetPaletteEntries(hpal, 0, cPalEntries, plp->palPalEntry)) {
            DeleteObject(hpal);
            hpal = NULL;
        }
    }
    DDEMLFree(plp);
    return(hpal);
}



/***************************************************************************\
* CopyDDEData
*
* Description:
* Used to copy DDE data apropriately.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
HANDLE CopyDDEData(
HANDLE hDDE,
BOOL fIsExecute)
{
    HANDLE hDDENew;
    PDDE_DATA pdde, pddeNew;
    LPMETAFILEPICT pmfPict;
    HANDLE hmfPict;

    hDDENew = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE,
            UserGlobalSize(hDDE));
    if (!hDDENew) {
        return (0);
    }
    USERGLOBALLOCK(hDDE, pdde);
    if (pdde == NULL) {
        UserGlobalFree(hDDENew);
        return (0);
    }
    USERGLOBALLOCK(hDDENew, pddeNew);
    UserAssert(pddeNew);
    RtlCopyMemory(pddeNew, pdde, UserGlobalSize(hDDE));

    if (!fIsExecute) {
        switch (pdde->wFmt) {
        case CF_BITMAP:
        case CF_DSPBITMAP:
            pddeNew->Data = (KERNEL_PVOID)CopyBitmap((HBITMAP)pdde->Data);
            break;

        case CF_PALETTE:
            pddeNew->Data = (KERNEL_PVOID)CopyPalette((HPALETTE)pdde->Data);
            break;

        case CF_DIB:
            pddeNew->Data = (KERNEL_PVOID)CopyDDEData((HANDLE)pdde->Data, TRUE);
            break;

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
            hmfPict = CopyDDEData((HANDLE)pdde->Data, TRUE);
            USERGLOBALLOCK(hmfPict, pmfPict);
            if (pmfPict == NULL) {
                WOWGLOBALFREE(hmfPict);
                USERGLOBALUNLOCK(hDDENew);
                WOWGLOBALFREE(hDDENew);
                USERGLOBALUNLOCK(hDDE);
                return (FALSE);
            }
            pmfPict->hMF = CopyMetaFile(pmfPict->hMF, NULL);
            USERGLOBALUNLOCK(hmfPict);
            pddeNew->Data = (KERNEL_PVOID)hmfPict;
            break;

        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
            pddeNew->Data = (KERNEL_PVOID)CopyEnhMetaFile((HANDLE)pdde->Data, NULL);
            break;
        }
    }
    USERGLOBALUNLOCK(hDDENew);
    USERGLOBALUNLOCK(hDDE);
    return (hDDENew);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\handles.c ===
/****************************** Module Header ******************************\
* Module Name: handles.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* HANDLES.C - Data handle manager
*
*
* This module allows a 32 bit value to be converted into a handle that
* can be validated with a high probability of correctness.
*
* A handle array is kept which contains the 32 bit data associated with
* it, and a copy of the correect handle value. The handle itself is
* composed of a combination of the index into the array for the associated
* data, the instance value, a type value and a DDEML instance value.
*
* The HIWORD of a handle is guarenteed not to be 0.
*
* History:
* 10-28-91 Sanfords Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

// globals

PCHANDLEENTRY aHandleEntry = NULL;

// statics

int cHandlesAllocated = 0;
int iFirstFree = 0;
DWORD nextId = 1;

#define GROW_COUNT 16
// #define TESTING
#ifdef TESTING
VOID CheckHandleTable()
{
    int i;

    for (i = 0; i < cHandlesAllocated; i++) {
        if (aHandleEntry[i].handle && aHandleEntry[i].dwData) {
            switch (TypeFromHandle(aHandleEntry[i].handle)) {
            case HTYPE_INSTANCE:
                UserAssert(((PCL_INSTANCE_INFO)aHandleEntry[i].dwData)->hInstClient == aHandleEntry[i].handle);
                break;

            case HTYPE_CLIENT_CONVERSATION:
            case HTYPE_SERVER_CONVERSATION:
                UserAssert(((PCONV_INFO)aHandleEntry[i].dwData)->hConv == (HCONV)aHandleEntry[i].handle ||
                        ((PCONV_INFO)aHandleEntry[i].dwData)->hConv == 0);
                break;
            }
        }
    }
}
#else
#define CheckHandleTable()
#endif // TESTING


/***************************************************************************\
* CreateHandle
*
* Description:
* Creates a client side handle.
*
* Returns 0 on error.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
HANDLE CreateHandle(
ULONG_PTR dwData,
DWORD type,
DWORD inst)
{
    HANDLE h;
    int i, iNextFree;
    PCHANDLEENTRY phe, pheTemp;

    if (iFirstFree >= cHandlesAllocated) {
        if (cHandlesAllocated == 0) {
           aHandleEntry = (PCHANDLEENTRY)DDEMLAlloc(sizeof(CHANDLEENTRY) * GROW_COUNT);
        } else {
            pheTemp = (PCHANDLEENTRY)DDEMLReAlloc(aHandleEntry,
                                                 sizeof(CHANDLEENTRY) * (cHandlesAllocated + GROW_COUNT));
            /*
             * If the realloc failed, free the old ptr. We continue 
             * on in order to maintain compatibility with previous DDE code.
             */
            if (pheTemp == NULL) {
                DDEMLFree(aHandleEntry);
            }
            aHandleEntry = pheTemp;     
        }
        if (aHandleEntry == NULL) {
            return (0);
        }
        i = cHandlesAllocated;
        cHandlesAllocated += GROW_COUNT;
        phe = &aHandleEntry[i];
        while (i < cHandlesAllocated) {
           // phe->handle = 0; // indicates empty - ZERO init.
           phe->dwData = ++i; // index to next free spot.
           phe++;
        }
    }
    h = aHandleEntry[iFirstFree].handle = (HANDLE)LongToHandle(
         HandleFromId(nextId) |
         HandleFromIndex(iFirstFree) |
         HandleFromType(type) |
         HandleFromInst(inst) );
    iNextFree = (int)aHandleEntry[iFirstFree].dwData;
    aHandleEntry[iFirstFree].dwData = dwData;
    nextId++;
    if (nextId == 0) {     // guarentees HIWORD of handle != 0
       nextId++;
    }
    iFirstFree = iNextFree;

    CheckHandleTable();
    return (h);
}


/***************************************************************************\
* DestroyHandle
*
* Description:
* Frees up a handle.
*
* Assumptions:
* The handle is valid.
* Critical Section is entered.
*
* Returns:
* Data in handle before destruction.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
ULONG_PTR DestroyHandle(
HANDLE h)
{
    register int i;
    register ULONG_PTR dwRet;

    CheckHandleTable();

    i = IndexFromHandle(h);
    UserAssert(aHandleEntry[i].handle == h);
    aHandleEntry[i].handle = 0;
    dwRet = aHandleEntry[i].dwData;
    aHandleEntry[i].dwData = iFirstFree;
    iFirstFree = i;

    return (dwRet);
}


/***************************************************************************\
* GetHandleData
*
* Description:
* A quick way to retrieve a valid handle's data
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
ULONG_PTR GetHandleData(
HANDLE h)
{
    register ULONG_PTR dwRet;

    CheckHandleTable();
    dwRet = aHandleEntry[IndexFromHandle(h)].dwData;
    return (dwRet);
}


/***************************************************************************\
* SetHandleData
*
* Description:
* A quick way to change a valid handle's data.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
VOID SetHandleData(
HANDLE h,
ULONG_PTR dwData)
{
    aHandleEntry[IndexFromHandle(h)].dwData = dwData;
}


/***************************************************************************\
* ValidateCHandle
*
* Description:
* General handle validation routine. ExpectedType or ExpectedInstance
* can be HTYPE_ANY/HINST_ANY. (note Expected Instance is an instance
* index into the aInstance array, NOT a instance handle.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
ULONG_PTR ValidateCHandle(
HANDLE h,
DWORD ExpectedType,
DWORD ExpectedInstance)
{
    register int i;
    register ULONG_PTR dwRet;

    CheckHandleTable();
    dwRet = 0;
    i = IndexFromHandle(h);
    if (i < cHandlesAllocated &&
          aHandleEntry[i].handle == h &&
          (ExpectedType == -1 || ExpectedType == TypeFromHandle(h)) &&
          (ExpectedInstance == -1 || ExpectedInstance == InstFromHandle(h))) {
       dwRet = aHandleEntry[i].dwData;
    }

    return (dwRet);
}


PCL_INSTANCE_INFO PciiFromHandle(
HANDLE h)
{
    PCHANDLEENTRY phe;

    CheckDDECritIn;

    if (!cHandlesAllocated) {
        return(NULL);
    }
    phe = &aHandleEntry[cHandlesAllocated];

    do {
        phe--;
        if (phe->handle != 0 &&
                TypeFromHandle(phe->handle) == HTYPE_INSTANCE &&
                (InstFromHandle(phe->handle) == InstFromHandle(h))) {
            return(((PCL_INSTANCE_INFO)phe->dwData)->tid == GetCurrentThreadId() ?
                (PCL_INSTANCE_INFO)phe->dwData : NULL);
        }
    } while (phe != aHandleEntry);
    return(NULL);
}



/***************************************************************************\
* ApplyFunctionToObjects
*
* Description:
* Used for cleanup, this allows the handle array to be scanned for
* handles meeting the ExpectedType and ExpectedInstance criteria
* and apply the given function to each handle.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
VOID ApplyFunctionToObjects(
DWORD ExpectedType,
DWORD ExpectedInstance,
PFNHANDLEAPPLY pfn)
{
    PCHANDLEENTRY phe;

    CheckDDECritIn;

    if (!cHandlesAllocated) {
        return;
    }
    phe = &aHandleEntry[cHandlesAllocated];

    do {
        phe--;
        if (phe->handle != 0 &&
                (ExpectedType == HTYPE_ANY ||
                    ExpectedType == TypeFromHandle(phe->handle)) &&
                (ExpectedInstance == HTYPE_ANY ||
                    ExpectedInstance == InstFromHandle(phe->handle))) {
            LeaveDDECrit;
            CheckDDECritOut;
            (*pfn)(phe->handle);
            EnterDDECrit;
        }
    } while (phe != aHandleEntry);
}


DWORD GetFullUserHandle(WORD wHandle)
{
    DWORD dwHandle;
    PHE phe;

    dwHandle = HMIndexFromHandle(wHandle);

    if (dwHandle < gpsi->cHandleEntries) {

        phe = &gSharedInfo.aheList[dwHandle];

        if (phe->bType == TYPE_WINDOW)
            return(MAKELONG(dwHandle, phe->wUniq));
    }

    /*
     * object may be gone, but we must pass something.
     * DDE terminates will fail if we don't map this right even after
     * the window is dead!
     *
     * NOTE: This fix will only work for WOW apps, but since the 32bit
     * tracking layer locks dde windows until the last terminate is
     * received, we won't see this problem on the 32bit side.
     *
     * BUG: We WILL see a problem for OLE32 thunked DDE though.
     */
    return(wHandle);
}



/***************************************************************************\
* BestSetLastDDEMLError
*
* Description:
* This sets the LastError field of all instances that belong to the
* current thread. This is used to get error information to applications
* which generated an error where the exact instance could not be
* determined.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID BestSetLastDDEMLError(
DWORD error)
{
    PCHANDLEENTRY phe;

    CheckDDECritIn;

    if (!cHandlesAllocated) {
        return;
    }
    phe = &aHandleEntry[cHandlesAllocated];
    do {
        phe--;
        if (phe->handle != 0 && TypeFromHandle(phe->handle) == HTYPE_INSTANCE) {
            SetLastDDEMLError((PCL_INSTANCE_INFO)phe->dwData, error);
        }
    } while (phe != aHandleEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\fntsweep.c ===
/******************************Module*Header*******************************\
* Module Name: fntsweep.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* This file contains font sweeper related stuff.
* On the boot of ths system, i.e.  initialization of userk, the
* [Fonts] section of win.ini is checked to
* find out if any new fonts have been added by any font installers.
* If third party installers have installed fonts in the system directory
* those are copied to fonts directory. Any fot entries are replaced
* by appropriate *.ttf entries, any fot files are deleted if they were
* ever installed.
*
\**************************************************************************/


#include "precomp.h"
#pragma hdrstop
#include <setupbat.h>      // in sdkinc

CONST WCHAR pwszType1Key[]      = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\Type 1 Fonts";
CONST WCHAR pwszSweepType1Key[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\LastType1Sweep";
CONST WCHAR pwszUpdType1Key[]   = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\Upgraded Type1";

CONST WCHAR pwszFontsKey[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
CONST WCHAR pwszSweepKey[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\LastFontSweep";
CONST WCHAR pwszFontDrivers[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Font Drivers";

#define LAST_SWEEP_TIME L"LastSweepTime"
#define UPGRADED_TYPE1 L"UpgradedType1"

#define DWORDALIGN(X) (((X) + 3) & ~3)

WCHAR *gpwcSystemDir;
WCHAR *gpwcFontsDir;
BOOL   gbWin31Upgrade;


BOOL bCheckIfDualBootingWithWin31()
{
    WCHAR Buffer[32];
    WCHAR awcWindowsDir[MAX_PATH];
    DWORD dwRet;
    UINT  cwchWinPath;

    awcWindowsDir[0] = L'\0'; // prefix:make su